[
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__eq__", "code": "\nndarray.__eq__(self, value, /)\u00b6", "description": "Return self==value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__eq__", "code": "\nMaskedArray.__eq__(self, other)[source]\u00b6", "description": "Check whether other equals self elementwise.\nWhen either of the elements is masked, the result is masked as well,\nbut the underlying boolean data are still set, with self and other\nconsidered equal if both are masked, and unequal otherwise.\nFor structured arrays, all fields are combined, with masked values\nignored. The result is masked if all fields were masked, with self\nand other considered equal only if both were fully masked.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__getitem__", "code": "\nMaskedArray.__getitem__(self, indx)[source]\u00b6", "description": "x.__getitem__(y) &lt;==&gt; x[y]\nReturn the item described by i, as a masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ge__", "code": "\nndarray.__ge__(self, value, /)\u00b6", "description": "Return self&gt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ge__", "code": "\nMaskedArray.__ge__(self, value, /)\u00b6", "description": "Return self&gt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__floordiv__", "code": "\nMaskedArray.__floordiv__(self, other)[source]\u00b6", "description": "Divide other into self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__float__", "code": "\nndarray.__float__(self)\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__float__", "code": "\nMaskedArray.__float__(self)[source]\u00b6", "description": "Convert to float.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__floordiv__", "code": "\nndarray.__floordiv__(self, value, /)\u00b6", "description": "Return self//value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__divmod__", "code": "\nndarray.__divmod__(self, value, /)\u00b6", "description": "Return divmod(self, value).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__divmod__", "code": "\nMaskedArray.__divmod__(self, value, /)\u00b6", "description": "Return divmod(self, value).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__div__", "code": "\nMaskedArray.__div__(self, other)[source]\u00b6", "description": "Divide other into self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__deepcopy__", "code": "\nMaskedArray.__deepcopy__(self, memo=None)[source]\u00b6", "description": "Used if copy.deepcopy is called on an array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__delitem__", "code": "\nMaskedArray.__delitem__(self, key, /)\u00b6", "description": "Delete self[key].\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rfloordiv__", "code": "\nMaskedArray.__rfloordiv__(self, other)[source]\u00b6", "description": "Divide self into other, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__deepcopy__", "code": "\nndarray.__deepcopy__()\u00b6", "description": "Used if copy.deepcopy is called on an array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.capitalize", "code": "\nchararray.capitalize(self)\u00b6", "description": "Return a copy of self with only the first character of each element\ncapitalized.\n\nSee also\nchar.capitalize\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.dot", "code": "\nchararray.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.dumps", "code": "\nmemmap.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.dumps", "code": "\nMaskType.dumps()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.dumps", "code": "\nmatrix.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.dumps", "code": "\nMaskedArray.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.dumps", "code": "\nmasked_array.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.dumps", "code": "\ngeneric.dumps()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.fill", "code": "\nchararray.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.fromroots", "code": "\nclassmethod Legendre.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.getfield", "code": "\nmatrix.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.getfield", "code": "\nMaskType.getfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.getfield", "code": "\nmasked_array.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.generic.getfield", "code": "\ngeneric.getfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.getfield", "code": "\nchararray.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.has_samewindow", "code": "\nHermiteE.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.has_samewindow", "code": "\nHermite.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermline", "code": "\nnumpy.polynomial.hermite.hermline(off, scl)[source]\u00b6", "description": "Hermite series whose graph is a straight line.\n\nParameters\n\noff, sclscalarsThe specified line is given by off + scl*x.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the Hermite series for\noff + scl*x.\n\n\n\n\n\nSee also\npolyline, chebline\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermline, hermval\n&gt;&gt;&gt; hermval(0,hermline(3, 2))\n3.0\n&gt;&gt;&gt; hermval(1,hermline(3, 2))\n5.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the Hermite series foroff + scl*x.", "examples": ["; from numpy.polynomial.hermite import hermline, hermval\n; hermval(0,hermline(3, 2))\n3.0\n; hermval(1,hermline(3, 2))\n5.0\n\n", "; from numpy.polynomial.hermite import hermline, hermval\n; hermval(0,hermline(3, 2))\n3.0\n; hermval(1,hermline(3, 2))\n5.0\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.imag", "code": "\nproperty MaskedArray.imag\u00b6", "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this MaskedArray.\n\nSee also\nreal\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.imag", "code": "\nproperty masked_array.imag\u00b6", "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this MaskedArray.\n\nSee also\nreal\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.imag", "code": "\nnumpy.imag(val)[source]\u00b6", "description": "Return the imaginary part of the complex argument.\n\nParameters\n\nvalarray_likeInput array.\n\n\n\nReturns\n\noutndarray or scalarThe imaginary component of the complex argument. If val is real,\nthe type of val is used for the output.  If val has complex\nelements, the returned type is float.\n\n\n\n\n\nSee also\nreal, angle, real_if_close\n\nExamples\n&gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])\n&gt;&gt;&gt; a.imag\narray([2.,  4.,  6.])\n&gt;&gt;&gt; a.imag = np.array([8, 10, 12])\n&gt;&gt;&gt; a\narray([1. +8.j,  3.+10.j,  5.+12.j])\n&gt;&gt;&gt; np.imag(1 + 1j)\n1.0\n\n\n", "parameters": ["Parameters", "valarray_like", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe imaginary component of the complex argument. If val is real,the type of val is used for the output.  If val has complexelements, the returned type is float.", "examples": ["; a = np.array([1+2j, 3+4j, 5+6j])\n; a.imag\narray([2.,  4.,  6.])\n; a.imag = np.array([8, 10, 12])\n; a\narray([1. +8.j,  3.+10.j,  5.+12.j])\n; np.imag(1 + 1j)\n1.0\n\n", "; a = np.array([1+2j, 3+4j, 5+6j])\n; a.imag\narray([2.,  4.,  6.])\n; a.imag = np.array([8, 10, 12])\n; a\narray([1. +8.j,  3.+10.j,  5.+12.j])\n; np.imag(1 + 1j)\n1.0\n"]},
{"library": "numpy", "item_id": "numpy.record.imag", "code": "\nrecord.imag\u00b6", "description": "imaginary part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.imag", "code": "\nrecarray.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.iscontiguous", "code": "\nMaskedArray.iscontiguous(self)[source]\u00b6", "description": "Return a boolean indicating whether the data is contiguous.\n\nParameters\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3])\n&gt;&gt;&gt; x.iscontiguous()\nTrue\n\n\niscontiguous returns one of the flags of the masked array:\n&gt;&gt;&gt; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": ["; x = np.ma.array([1, 2, 3])\n; x.iscontiguous()\nTrue\n\n", "; x = np.ma.array([1, 2, 3])\n; x.iscontiguous()\nTrue\n", "; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n", "; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.iscontiguous", "code": "\nmasked_array.iscontiguous(self)[source]\u00b6", "description": "Return a boolean indicating whether the data is contiguous.\n\nParameters\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3])\n&gt;&gt;&gt; x.iscontiguous()\nTrue\n\n\niscontiguous returns one of the flags of the masked array:\n&gt;&gt;&gt; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": ["; x = np.ma.array([1, 2, 3])\n; x.iscontiguous()\nTrue\n\n", "; x = np.ma.array([1, 2, 3])\n; x.iscontiguous()\nTrue\n", "; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n", "; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : True\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isnumeric", "code": "\nchararray.isnumeric(self)[source]\u00b6", "description": "For each element in self, return True if there are only\nnumeric characters in the element.\n\nSee also\nchar.isnumeric\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.isnumeric", "code": "\nnumpy.char.isnumeric(a)\u00b6", "description": "For each element, return True if there are only numeric\ncharacters in the element.\nCalls unicode.isnumeric element-wise.\nNumeric characters include digit characters, and all characters\nthat have the Unicode numeric value property, e.g. U+2155,\nVULGAR FRACTION ONE FIFTH.\n\nParameters\n\naarray_like, unicodeInput array.\n\n\n\nReturns\n\noutndarray, boolArray of booleans of same shape as a.\n\n\n\n\n\nSee also\nunicode.isnumeric\n\n", "parameters": ["Parameters", "aarray_like, unicode", "Returns", "outndarray, bool"], "returns": "outndarray, boolArray of booleans of same shape as a.", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.isnumeric", "code": "\nchararray.isnumeric(self)\u00b6", "description": "For each element in self, return True if there are only\nnumeric characters in the element.\n\nSee also\nchar.isnumeric\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.isneginf", "code": "\nnumpy.isneginf(x, out=None)[source]\u00b6", "description": "Test element-wise for negative infinity, return result as bool array.\n\nParameters\n\nxarray_likeThe input array.\n\noutarray_like, optionalA boolean array with the same shape and type as x to store the\nresult.\n\n\n\nReturns\n\noutndarrayA boolean array with the same dimensions as the input.\nIf second argument is not supplied then a numpy boolean array is\nreturned with values True where the corresponding element of the\ninput is negative infinity and values False where the element of\nthe input is not negative infinity.\nIf a second argument is supplied the result is stored there. If the\ntype of that array is a numeric type the result is represented as\nzeros and ones, if the type is boolean then as False and True. The\nreturn value out is then a reference to that array.\n\n\n\n\n\nSee also\nisinf, isposinf, isnan, isfinite\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\nErrors result if the second argument is also supplied when x is a scalar\ninput, if first and second arguments have different shapes, or if the\nfirst argument has complex values.\nExamples\n&gt;&gt;&gt; np.isneginf(np.NINF)\nTrue\n&gt;&gt;&gt; np.isneginf(np.inf)\nFalse\n&gt;&gt;&gt; np.isneginf(np.PINF)\nFalse\n&gt;&gt;&gt; np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False])\n\n\n&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])\n&gt;&gt;&gt; y = np.array([2, 2, 2])\n&gt;&gt;&gt; np.isneginf(x, y)\narray([1, 0, 0])\n&gt;&gt;&gt; y\narray([1, 0, 0])\n\n\n", "parameters": ["Parameters", "xarray_like", "outarray_like, optional", "Returns", "outndarray"], "returns": "outndarrayA boolean array with the same dimensions as the input.If second argument is not supplied then a numpy boolean array isreturned with values True where the corresponding element of theinput is negative infinity and values False where the element ofthe input is not negative infinity.If a second argument is supplied the result is stored there. If thetype of that array is a numeric type the result is represented aszeros and ones, if the type is boolean then as False and True. Thereturn value out is then a reference to that array.", "examples": ["; np.isneginf(np.NINF)\nTrue\n; np.isneginf(np.inf)\nFalse\n; np.isneginf(np.PINF)\nFalse\n; np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False])\n\n", "; np.isneginf(np.NINF)\nTrue\n; np.isneginf(np.inf)\nFalse\n; np.isneginf(np.PINF)\nFalse\n; np.isneginf([-np.inf, 0., np.inf])\narray([ True, False, False])\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isneginf(x, y)\narray([1, 0, 0])\n; y\narray([1, 0, 0])\n\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isneginf(x, y)\narray([1, 0, 0])\n; y\narray([1, 0, 0])\n"]},
{"library": "numpy", "item_id": "numpy.dtype.isnative", "code": "\ndtype.isnative\u00b6", "description": "Boolean indicating whether the byte order of this dtype is native\nto the platform.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.isnat", "code": "\nnumpy.isnat(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'isnat'&gt;\u00b6", "description": "Test element-wise for NaT (not a time) and return result as a boolean array.\n\nNew in version 1.13.0.\n\n\nParameters\n\nxarray_likeInput array with datetime or timedelta data type.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or boolTrue where x is NaT, false otherwise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nisnan, isinf, isneginf, isposinf, isfinite\n\nExamples\n&gt;&gt;&gt; np.isnat(np.datetime64(\"NaT\"))\nTrue\n&gt;&gt;&gt; np.isnat(np.datetime64(\"2016-01-01\"))\nFalse\n&gt;&gt;&gt; np.isnat(np.array([\"NaT\", \"2016-01-01\"], dtype=\"datetime64[ns]\"))\narray([ True, False])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or bool"], "returns": "yndarray or boolTrue where x is NaT, false otherwise.This is a scalar if x is a scalar.", "examples": ["; np.isnat(np.datetime64(\"NaT\"))\nTrue\n; np.isnat(np.datetime64(\"2016-01-01\"))\nFalse\n; np.isnat(np.array([\"NaT\", \"2016-01-01\"], dtype=\"datetime64[ns]\"))\narray([ True, False])\n\n", "; np.isnat(np.datetime64(\"NaT\"))\nTrue\n; np.isnat(np.datetime64(\"2016-01-01\"))\nFalse\n; np.isnat(np.array([\"NaT\", \"2016-01-01\"], dtype=\"datetime64[ns]\"))\narray([ True, False])\n"]},
{"library": "numpy", "item_id": "numpy.less", "code": "\nnumpy.less(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'less'&gt;\u00b6", "description": "Return the truth value of (x1 &lt; x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\ngreater, less_equal, greater_equal, equal, not_equal\n\nExamples\n&gt;&gt;&gt; np.less([1, 2], [2, 2])\narray([ True, False])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.less([1, 2], [2, 2])\narray([ True, False])\n\n", "; np.less([1, 2], [2, 2])\narray([ True, False])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legzero", "code": "\nnumpy.polynomial.legendre.legzero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.mask_rows", "code": "\nnumpy.ma.mask_rows(a, axis=&lt;no value&gt;)[source]\u00b6", "description": "Mask rows of a 2D array that contain masked values.\nThis function is a shortcut to mask_rowcols with axis equal to 0.\n\nSee also\n\nmask_rowcolsMask rows and/or columns of a 2D array.\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)\n&gt;&gt;&gt; a[1, 1] = 1\n&gt;&gt;&gt; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n&gt;&gt;&gt; a = ma.masked_equal(a, 1)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n\n\n&gt;&gt;&gt; ma.mask_rows(a)\nmasked_array(\n  data=[[0, 0, 0],\n        [--, --, --],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [ True,  True,  True],\n        [False, False, False]],\n  fill_value=1)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n\n", "; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n", "; ma.mask_rows(a)\nmasked_array(\n  data=[[0, 0, 0],\n        [--, --, --],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [ True,  True,  True],\n        [False, False, False]],\n  fill_value=1)\n\n", "; ma.mask_rows(a)\nmasked_array(\n  data=[[0, 0, 0],\n        [--, --, --],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [ True,  True,  True],\n        [False, False, False]],\n  fill_value=1)\n"]},
{"library": "numpy", "item_id": "numpy.ma.mask_rowcols", "code": "\nnumpy.ma.mask_rowcols(a, axis=None)[source]\u00b6", "description": "Mask rows and/or columns of a 2D array that contain masked values.\nMask whole rows and/or columns of a 2D array that contain\nmasked values.  The masking behavior is selected using the\naxis parameter.\n\n\nIf axis is None, rows and columns are masked.\nIf axis is 0, only rows are masked.\nIf axis is 1 or -1, only columns are masked.\n\n\n\nParameters\n\naarray_like, MaskedArrayThe array to mask.  If not a MaskedArray instance (or if no array\nelements are masked).  The result is a MaskedArray with mask set\nto nomask (False). Must be a 2D array.\n\naxisint, optionalAxis along which to perform the operation. If None, applies to a\nflattened version of the array.\n\n\n\nReturns\n\naMaskedArrayA modified version of the input array, masked depending on the value\nof the axis parameter.\n\n\n\nRaises\n\nNotImplementedErrorIf input array a is not 2D.\n\n\n\n\n\nSee also\n\nmask_rowsMask rows of a 2D array that contain masked values.\n\nmask_colsMask cols of a 2D array that contain masked values.\n\nmasked_whereMask where a condition is met.\n\n\n\nNotes\nThe input array\u2019s mask is modified by this function.\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)\n&gt;&gt;&gt; a[1, 1] = 1\n&gt;&gt;&gt; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n&gt;&gt;&gt; a = ma.masked_equal(a, 1)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n&gt;&gt;&gt; ma.mask_rowcols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [--, --, --],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n  fill_value=1)\n\n\n", "parameters": ["Parameters", "aarray_like, MaskedArray", "axisint, optional", "Returns", "aMaskedArray", "Raises", "NotImplementedError"], "returns": "aMaskedArrayA modified version of the input array, masked depending on the valueof the axis parameter.", "examples": ["; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n; ma.mask_rowcols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [--, --, --],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n  fill_value=1)\n\n", "; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n; ma.mask_rowcols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [--, --, --],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [ True,  True,  True],\n        [False,  True, False]],\n  fill_value=1)\n"]},
{"library": "numpy", "item_id": "numpy.mask_indices", "code": "\nnumpy.mask_indices(n, mask_func, k=0)[source]\u00b6", "description": "Return the indices to access (n, n) arrays, given a masking function.\nAssume mask_func is a function that, for a square array a of size\n(n, n) with a possible offset argument k, when called as\nmask_func(a, k) returns a new array with zeros in certain locations\n(functions like triu or tril do precisely this). Then this function\nreturns the indices where the non-zero values would be located.\n\nParameters\n\nnintThe returned indices will be valid to access arrays of shape (n, n).\n\nmask_funccallableA function whose call signature is similar to that of triu, tril.\nThat is, mask_func(x, k) returns a boolean array, shaped like x.\nk is an optional argument to the function.\n\nkscalarAn optional argument which is passed through to mask_func. Functions\nlike triu, tril take a second argument that is interpreted as an\noffset.\n\n\n\nReturns\n\nindicestuple of arrays.The n arrays of indices corresponding to the locations where\nmask_func(np.ones((n, n)), k) is True.\n\n\n\n\n\nSee also\ntriu, tril, triu_indices, tril_indices\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\nThese are the indices that would allow you to access the upper triangular\npart of any 3x3 array:\n&gt;&gt;&gt; iu = np.mask_indices(3, np.triu)\n\n\nFor example, if a is a 3x3 array:\n&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)\n&gt;&gt;&gt; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n&gt;&gt;&gt; a[iu]\narray([0, 1, 2, 4, 5, 8])\n\n\nAn offset can be passed also to the masking function.  This gets us the\nindices starting on the first diagonal right of the main one:\n&gt;&gt;&gt; iu1 = np.mask_indices(3, np.triu, 1)\n\n\nwith which we now extract only three elements:\n&gt;&gt;&gt; a[iu1]\narray([1, 2, 5])\n\n\n", "parameters": ["Parameters", "nint", "mask_funccallable", "kscalar", "Returns", "indicestuple of arrays."], "returns": "indicestuple of arrays.The n arrays of indices corresponding to the locations wheremask_func(np.ones((n, n)), k) is True.", "examples": ["; iu = np.mask_indices(3, np.triu)\n\n", "; iu = np.mask_indices(3, np.triu)\n", "; a = np.arange(9).reshape(3, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n; a[iu]\narray([0, 1, 2, 4, 5, 8])\n\n", "; a = np.arange(9).reshape(3, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n; a[iu]\narray([0, 1, 2, 4, 5, 8])\n", "; iu1 = np.mask_indices(3, np.triu, 1)\n\n", "; iu1 = np.mask_indices(3, np.triu, 1)\n", "; a[iu1]\narray([1, 2, 5])\n\n", "; a[iu1]\narray([1, 2, 5])\n"]},
{"library": "numpy", "item_id": "numpy.ma.mask_cols", "code": "\nnumpy.ma.mask_cols(a, axis=&lt;no value&gt;)[source]\u00b6", "description": "Mask columns of a 2D array that contain masked values.\nThis function is a shortcut to mask_rowcols with axis equal to 1.\n\nSee also\n\nmask_rowcolsMask rows and/or columns of a 2D array.\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.zeros((3, 3), dtype=int)\n&gt;&gt;&gt; a[1, 1] = 1\n&gt;&gt;&gt; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n&gt;&gt;&gt; a = ma.masked_equal(a, 1)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n&gt;&gt;&gt; ma.mask_cols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [0, --, 0],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False,  True, False]],\n  fill_value=1)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n; ma.mask_cols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [0, --, 0],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False,  True, False]],\n  fill_value=1)\n\n", "; import numpy.ma as ma\n; a = np.zeros((3, 3), dtype=int)\n; a[1, 1] = 1\n; a\narray([[0, 0, 0],\n       [0, 1, 0],\n       [0, 0, 0]])\n; a = ma.masked_equal(a, 1)\n; a\nmasked_array(\n  data=[[0, 0, 0],\n        [0, --, 0],\n        [0, 0, 0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1)\n; ma.mask_cols(a)\nmasked_array(\n  data=[[0, --, 0],\n        [0, --, 0],\n        [0, --, 0]],\n  mask=[[False,  True, False],\n        [False,  True, False],\n        [False,  True, False]],\n  fill_value=1)\n"]},
{"library": "numpy", "item_id": "numpy.ma.mask_or", "code": "\nnumpy.ma.mask_or(m1, m2, copy=False, shrink=True)[source]\u00b6", "description": "Combine two masks with the logical_or operator.\nThe result may be a view on m1 or m2 if the other is nomask\n(i.e. False).\n\nParameters\n\nm1, m2array_likeInput masks.\n\ncopybool, optionalIf copy is False and one of the inputs is nomask, return a view\nof the other input mask. Defaults to False.\n\nshrinkbool, optionalWhether to shrink the output to nomask if all its values are\nFalse. Defaults to True.\n\n\n\nReturns\n\nmaskoutput maskThe result masks values that are masked in either m1 or m2.\n\n\n\nRaises\n\nValueErrorIf m1 and m2 have different flexible dtypes.\n\n\n\n\nExamples\n&gt;&gt;&gt; m1 = np.ma.make_mask([0, 1, 1, 0])\n&gt;&gt;&gt; m2 = np.ma.make_mask([1, 0, 0, 0])\n&gt;&gt;&gt; np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False])\n\n\n", "parameters": ["Parameters", "m1, m2array_like", "copybool, optional", "shrinkbool, optional", "Returns", "maskoutput mask", "Raises", "ValueError"], "returns": "maskoutput maskThe result masks values that are masked in either m1 or m2.", "examples": ["; m1 = np.ma.make_mask([0, 1, 1, 0])\n; m2 = np.ma.make_mask([1, 0, 0, 0])\n; np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False])\n\n", "; m1 = np.ma.make_mask([0, 1, 1, 0])\n; m2 = np.ma.make_mask([1, 0, 0, 0])\n; np.ma.mask_or(m1, m2)\narray([ True,  True,  True, False])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.mask", "code": "\nproperty masked_array.mask\u00b6", "description": "Current mask.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nested_iters", "code": "\nnumpy.nested_iters()\u00b6", "description": "Create nditers for use in nested loops\nCreate a tuple of nditer objects which iterate in nested loops over\ndifferent axes of the op argument. The first iterator is used in the\noutermost loop, the last in the innermost loop. Advancing one will change\nthe subsequent iterators to point at its new element.\n\nParameters\n\nopndarray or sequence of array_likeThe array(s) to iterate over.\n\naxeslist of list of intEach item is used as an \u201cop_axes\u201d argument to an nditer\n\nflags, op_flags, op_dtypes, order, casting, buffersize (optional)See nditer parameters of the same name\n\n\n\nReturns\n\niterstuple of nditerAn nditer for each item in axes, outermost first\n\n\n\n\n\nSee also\nnditer\n\nExamples\nBasic usage. Note how y is the \u201cflattened\u201d version of\n[a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified\nthe first iter\u2019s axes as [1]\n&gt;&gt;&gt; a = np.arange(12).reshape(2, 3, 2)\n&gt;&gt;&gt; i, j = np.nested_iters(a, [[1], [0, 2]], flags=[\"multi_index\"])\n&gt;&gt;&gt; for x in i:\n...      print(i.multi_index)\n...      for y in j:\n...          print('', j.multi_index, y)\n(0,)\n (0, 0) 0\n (0, 1) 1\n (1, 0) 6\n (1, 1) 7\n(1,)\n (0, 0) 2\n (0, 1) 3\n (1, 0) 8\n (1, 1) 9\n(2,)\n (0, 0) 4\n (0, 1) 5\n (1, 0) 10\n (1, 1) 11\n\n\n", "parameters": ["Parameters", "opndarray or sequence of array_like", "axeslist of list of int", "flags, op_flags, op_dtypes, order, casting, buffersize (optional)", "Returns", "iterstuple of nditer"], "returns": "iterstuple of nditerAn nditer for each item in axes, outermost first", "examples": ["; a = np.arange(12).reshape(2, 3, 2)\n; i, j = np.nested_iters(a, [[1], [0, 2]], flags=[\"multi_index\"])\n; for x in i:\n...      print(i.multi_index)\n...      for y in j:\n...          print('', j.multi_index, y)\n(0,)\n (0, 0) 0\n (0, 1) 1\n (1, 0) 6\n (1, 1) 7\n(1,)\n (0, 0) 2\n (0, 1) 3\n (1, 0) 8\n (1, 1) 9\n(2,)\n (0, 0) 4\n (0, 1) 5\n (1, 0) 10\n (1, 1) 11\n\n", "; a = np.arange(12).reshape(2, 3, 2)\n; i, j = np.nested_iters(a, [[1], [0, 2]], flags=[\"multi_index\"])\n; for x in i:\n...      print(i.multi_index)\n...      for y in j:\n...          print('', j.multi_index, y)\n(0,)\n (0, 0) 0\n (0, 1) 1\n (1, 0) 6\n (1, 1) 7\n(1,)\n (0, 0) 2\n (0, 1) 3\n (1, 0) 8\n (1, 1) 9\n(2,)\n (0, 0) 4\n (0, 1) 5\n (1, 0) 10\n (1, 1) 11\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.negative_binomial", "code": "\nRandomState.negative_binomial(n, p, size=None)\u00b6", "description": "Draw samples from a negative binomial distribution.\nSamples are drawn from a negative binomial distribution with specified\nparameters, n successes and p probability of success where n\nis &gt; 0 and p is in the interval [0, 1].\n\nNote\nNew code should use the negative_binomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnfloat or array_like of floatsParameter of the distribution, &gt; 0.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized negative binomial distribution,\nwhere each sample is equal to N, the number of failures that\noccurred before a total of n successes was reached.\n\n\n\n\n\nSee also\n\nGenerator.negative_binomialwhich should be used for new code.\n\n\n\nNotes\nThe probability mass function of the negative binomial distribution is\n\n\nwhere  is the number of successes,  is the\nprobability of success,  is the number of trials, and\n is the gamma function. When  is an integer,\n, which is\nthe more common form of this term in the the pmf. The negative\nbinomial distribution gives the probability of N failures given n\nsuccesses, with a success on the last trial.\nIf one throws a die repeatedly until the third time a \u201c1\u201d appears,\nthen the probability distribution of the number of non-\u201c1\u201ds that\nappear before the third \u201c1\u201d is a negative binomial distribution.\nReferences\n\n1\nWeisstein, Eric W. \u201cNegative Binomial Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NegativeBinomialDistribution.html\n\n2\nWikipedia, \u201cNegative binomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\nA real world example. A company drills wild-cat oil\nexploration wells, each with an estimated probability of\nsuccess of 0.1.  What is the probability of having one success\nfor each successive well, that is what is the probability of a\nsingle success after drilling 5 wells, after 6 wells, etc.?\n&gt;&gt;&gt; s = np.random.negative_binomial(1, 0.1, 100000)\n&gt;&gt;&gt; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n\n", "parameters": ["Parameters", "nfloat or array_like of floats", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.", "examples": ["; s = np.random.negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n", "; s = np.random.negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n"]},
{"library": "numpy", "item_id": "numpy.nancumprod", "code": "\nnumpy.nancumprod(a, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative product of array elements over a given axis treating Not a\nNumbers (NaNs) as one.  The cumulative product does not change when NaNs are\nencountered and leading NaNs are replaced by ones.\nOnes are returned for slices that are all-NaN or empty.\n\nNew in version 1.12.0.\n\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalAxis along which the cumulative product is computed.  By default\nthe input is flattened.\n\ndtypedtype, optionalType of the returned array, as well as of the accumulator in which\nthe elements are multiplied.  If dtype is not specified, it\ndefaults to the dtype of a, unless a has an integer dtype with\na precision less than that of the default platform integer.  In\nthat case, the default platform integer is used instead.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type of the resulting values will be cast if necessary.\n\n\n\nReturns\n\nnancumprodndarrayA new array holding the result is returned unless out is\nspecified, in which case it is returned.\n\n\n\n\n\nSee also\n\nnumpy.cumprodCumulative product across array propagating NaNs.\n\nisnanShow which elements are NaN.\n\n\n\nExamples\n&gt;&gt;&gt; np.nancumprod(1)\narray([1])\n&gt;&gt;&gt; np.nancumprod([1])\narray([1])\n&gt;&gt;&gt; np.nancumprod([1, np.nan])\narray([1.,  1.])\n&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])\n&gt;&gt;&gt; np.nancumprod(a)\narray([1.,  2.,  6.,  6.])\n&gt;&gt;&gt; np.nancumprod(a, axis=0)\narray([[1.,  2.],\n       [3.,  2.]])\n&gt;&gt;&gt; np.nancumprod(a, axis=1)\narray([[1.,  2.],\n       [3.,  3.]])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "nancumprodndarray"], "returns": "nancumprodndarrayA new array holding the result is returned unless out isspecified, in which case it is returned.", "examples": ["; np.nancumprod(1)\narray([1])\n; np.nancumprod([1])\narray([1])\n; np.nancumprod([1, np.nan])\narray([1.,  1.])\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nancumprod(a)\narray([1.,  2.,  6.,  6.])\n; np.nancumprod(a, axis=0)\narray([[1.,  2.],\n       [3.,  2.]])\n; np.nancumprod(a, axis=1)\narray([[1.,  2.],\n       [3.,  3.]])\n\n", "; np.nancumprod(1)\narray([1])\n; np.nancumprod([1])\narray([1])\n; np.nancumprod([1, np.nan])\narray([1.,  1.])\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nancumprod(a)\narray([1.,  2.,  6.,  6.])\n; np.nancumprod(a, axis=0)\narray([[1.,  2.],\n       [3.,  2.]])\n; np.nancumprod(a, axis=1)\narray([[1.,  2.],\n       [3.,  3.]])\n"]},
{"library": "numpy", "item_id": "numpy.nancumsum", "code": "\nnumpy.nancumsum(a, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.  The cumulative sum does not change when NaNs are\nencountered and leading NaNs are replaced by zeros.\nZeros are returned for slices that are all-NaN or empty.\n\nNew in version 1.12.0.\n\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalAxis along which the cumulative sum is computed. The default\n(None) is to compute the cumsum over the flattened array.\n\ndtypedtype, optionalType of the returned array and of the accumulator in which the\nelements are summed.  If dtype is not specified, it defaults\nto the dtype of a, unless a has an integer dtype with a\nprecision less than that of the default platform integer.  In\nthat case, the default platform integer is used.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary. See ufuncs-output-type for\nmore details.\n\n\n\nReturns\n\nnancumsumndarray.A new array holding the result is returned unless out is\nspecified, in which it is returned. The result has the same\nsize as a, and the same shape as a if axis is not None\nor a is a 1-d array.\n\n\n\n\n\nSee also\n\nnumpy.cumsumCumulative sum across array propagating NaNs.\n\nisnanShow which elements are NaN.\n\n\n\nExamples\n&gt;&gt;&gt; np.nancumsum(1)\narray([1])\n&gt;&gt;&gt; np.nancumsum([1])\narray([1])\n&gt;&gt;&gt; np.nancumsum([1, np.nan])\narray([1.,  1.])\n&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])\n&gt;&gt;&gt; np.nancumsum(a)\narray([1.,  3.,  6.,  6.])\n&gt;&gt;&gt; np.nancumsum(a, axis=0)\narray([[1.,  2.],\n       [4.,  2.]])\n&gt;&gt;&gt; np.nancumsum(a, axis=1)\narray([[1.,  3.],\n       [3.,  3.]])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "nancumsumndarray."], "returns": "nancumsumndarray.A new array holding the result is returned unless out isspecified, in which it is returned. The result has the samesize as a, and the same shape as a if axis is not Noneor a is a 1-d array.", "examples": ["; np.nancumsum(1)\narray([1])\n; np.nancumsum([1])\narray([1])\n; np.nancumsum([1, np.nan])\narray([1.,  1.])\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nancumsum(a)\narray([1.,  3.,  6.,  6.])\n; np.nancumsum(a, axis=0)\narray([[1.,  2.],\n       [4.,  2.]])\n; np.nancumsum(a, axis=1)\narray([[1.,  3.],\n       [3.,  3.]])\n\n", "; np.nancumsum(1)\narray([1])\n; np.nancumsum([1])\narray([1])\n; np.nancumsum([1, np.nan])\narray([1.,  1.])\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nancumsum(a)\narray([1.,  3.,  6.,  6.])\n; np.nancumsum(a, axis=0)\narray([[1.,  2.],\n       [4.,  2.]])\n; np.nancumsum(a, axis=1)\narray([[1.,  3.],\n       [3.,  3.]])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.negative_binomial", "code": "\nGenerator.negative_binomial(n, p, size=None)\u00b6", "description": "Draw samples from a negative binomial distribution.\nSamples are drawn from a negative binomial distribution with specified\nparameters, n successes and p probability of success where n\nis &gt; 0 and p is in the interval [0, 1].\n\nParameters\n\nnfloat or array_like of floatsParameter of the distribution, &gt; 0.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized negative binomial distribution,\nwhere each sample is equal to N, the number of failures that\noccurred before a total of n successes was reached.\n\n\n\n\nNotes\nThe probability mass function of the negative binomial distribution is\n\n\nwhere  is the number of successes,  is the\nprobability of success,  is the number of trials, and\n is the gamma function. When  is an integer,\n, which is\nthe more common form of this term in the the pmf. The negative\nbinomial distribution gives the probability of N failures given n\nsuccesses, with a success on the last trial.\nIf one throws a die repeatedly until the third time a \u201c1\u201d appears,\nthen the probability distribution of the number of non-\u201c1\u201ds that\nappear before the third \u201c1\u201d is a negative binomial distribution.\nReferences\n\n1\nWeisstein, Eric W. \u201cNegative Binomial Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NegativeBinomialDistribution.html\n\n2\nWikipedia, \u201cNegative binomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\nA real world example. A company drills wild-cat oil\nexploration wells, each with an estimated probability of\nsuccess of 0.1.  What is the probability of having one success\nfor each successive well, that is what is the probability of a\nsingle success after drilling 5 wells, after 6 wells, etc.?\n&gt;&gt;&gt; s = np.random.default_rng().negative_binomial(1, 0.1, 100000)\n&gt;&gt;&gt; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n\n", "parameters": ["Parameters", "nfloat or array_like of floats", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.", "examples": ["; s = np.random.default_rng().negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n", "; s = np.random.default_rng().negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n"]},
{"library": "numpy", "item_id": "numpy.random.negative_binomial", "code": "\nnumpy.random.negative_binomial(n, p, size=None)\u00b6", "description": "Draw samples from a negative binomial distribution.\nSamples are drawn from a negative binomial distribution with specified\nparameters, n successes and p probability of success where n\nis &gt; 0 and p is in the interval [0, 1].\n\nNote\nNew code should use the negative_binomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnfloat or array_like of floatsParameter of the distribution, &gt; 0.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized negative binomial distribution,\nwhere each sample is equal to N, the number of failures that\noccurred before a total of n successes was reached.\n\n\n\n\n\nSee also\n\nGenerator.negative_binomialwhich should be used for new code.\n\n\n\nNotes\nThe probability mass function of the negative binomial distribution is\n\n\nwhere  is the number of successes,  is the\nprobability of success,  is the number of trials, and\n is the gamma function. When  is an integer,\n, which is\nthe more common form of this term in the the pmf. The negative\nbinomial distribution gives the probability of N failures given n\nsuccesses, with a success on the last trial.\nIf one throws a die repeatedly until the third time a \u201c1\u201d appears,\nthen the probability distribution of the number of non-\u201c1\u201ds that\nappear before the third \u201c1\u201d is a negative binomial distribution.\nReferences\n\n1\nWeisstein, Eric W. \u201cNegative Binomial Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NegativeBinomialDistribution.html\n\n2\nWikipedia, \u201cNegative binomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Negative_binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\nA real world example. A company drills wild-cat oil\nexploration wells, each with an estimated probability of\nsuccess of 0.1.  What is the probability of having one success\nfor each successive well, that is what is the probability of a\nsingle success after drilling 5 wells, after 6 wells, etc.?\n&gt;&gt;&gt; s = np.random.negative_binomial(1, 0.1, 100000)\n&gt;&gt;&gt; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n\n", "parameters": ["Parameters", "nfloat or array_like of floats", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized negative binomial distribution,where each sample is equal to N, the number of failures thatoccurred before a total of n successes was reached.", "examples": ["; s = np.random.negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n\n", "; s = np.random.negative_binomial(1, 0.1, 100000)\n; for i in range(1, 11): \n...    probability = sum(s&lt;i) / 100000.\n...    print(i, \"wells drilled, probability of one success =\", probability)\n"]},
{"library": "numpy", "item_id": "c.NPY_TYPES", "code": "\nNPY_TYPES\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "c.NPY_SIZEOF_SHORT", "code": "\nNPY_SIZEOF_SHORT\u00b6", "description": "sizeof(short)\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "c.PyArray_Type", "code": "\nPyArray_Type\u00b6", "description": "The Python type of the ndarray is PyArray_Type. In C, every\nndarray is a pointer to a PyArrayObject structure. The ob_type\nmember of this structure contains a pointer to the PyArray_Type\ntypeobject.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "c.NPY_NAN", "code": "\nNPY_NAN\u00b6", "description": "This macro is defined to a NaN (Not a Number), and is guaranteed to have\nthe signbit unset (\u2018positive\u2019 NaN). The corresponding single and extension\nprecision macro are available with the suffix F and L.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.negative", "code": "\nnumpy.negative(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'negative'&gt;\u00b6", "description": "Numerical negative, element-wise.\n\nParameters\n\nxarray_like or scalarInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarReturned array or scalar: y = -x.\nThis is a scalar if x is a scalar.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.negative([1.,-1.])\narray([-1.,  1.])\n\n\n", "parameters": ["Parameters", "xarray_like or scalar", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarReturned array or scalar: y = -x.This is a scalar if x is a scalar.", "examples": ["; np.negative([1.,-1.])\narray([-1.,  1.])\n\n", "; np.negative([1.,-1.])\narray([-1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.nout", "code": "\nufunc.nout\u00b6", "description": "The number of outputs.\nData attribute containing the number of arguments the ufunc treats as output.\nNotes\nSince all ufuncs can take output arguments, this will always be (at least) 1.\nExamples\n&gt;&gt;&gt; np.add.nout\n1\n&gt;&gt;&gt; np.multiply.nout\n1\n&gt;&gt;&gt; np.power.nout\n1\n&gt;&gt;&gt; np.exp.nout\n1\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.nout\n1\n; np.multiply.nout\n1\n; np.power.nout\n1\n; np.exp.nout\n1\n\n", "; np.add.nout\n1\n; np.multiply.nout\n1\n; np.power.nout\n1\n; np.exp.nout\n1\n"]},
{"library": "numpy", "item_id": "numpy.npv", "code": "\nnumpy.npv(rate, values)[source]\u00b6", "description": "Returns the NPV (Net Present Value) of a cash flow series.\n\nDeprecated since version 1.18: npv is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nParameters\n\nratescalarThe discount rate.\n\nvaluesarray_like, shape(M, )The values of the time series of cash flows.  The (fixed) time\ninterval between cash flow \u201cevents\u201d must be the same as that for\nwhich rate is given (i.e., if rate is per year, then precisely\na year is understood to elapse between each cash flow event).  By\nconvention, investments or \u201cdeposits\u201d are negative, income or\n\u201cwithdrawals\u201d are positive; values must begin with the initial\ninvestment, thus values[0] will typically be negative.\n\n\n\nReturns\n\noutfloatThe NPV of the input cash flow series values at the discount\nrate.\n\n\n\n\n\nWarning\nnpv considers a series of cashflows starting in the present (t = 0).\nNPV can also be defined with a series of future cashflows, paid at the\nend, rather than the start, of each period. If future cashflows are used,\nthe first cashflow values[0] must be zeroed and added to the net\npresent value of the future cashflows. This is demonstrated in the\nexamples.\n\nNotes\nReturns the result of: [2]\n\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nL. J. Gitman, \u201cPrinciples of Managerial Finance, Brief,\u201d 3rd ed.,\nAddison-Wesley, 2003, pg. 346.\n\n\nExamples\nConsider a potential project with an initial investment of $40 000 and\nprojected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of\neach period discounted at a rate of 8% per period. To find the project\u2019s\nnet present value:\n&gt;&gt;&gt; rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000]\n&gt;&gt;&gt; np.npv(rate, cashflows).round(5)\n3065.22267\n\n\nIt may be preferable to split the projected cashflow into an initial\ninvestment and expected future cashflows. In this case, the value of\nthe initial cashflow is zero and the initial investment is later added\nto the future cashflows net present value:\n&gt;&gt;&gt; initial_cashflow = cashflows[0]\n&gt;&gt;&gt; cashflows[0] = 0\n&gt;&gt;&gt; np.round(np.npv(rate, cashflows) + initial_cashflow, 5)\n3065.22267\n\n\n", "parameters": ["Parameters", "ratescalar", "valuesarray_like, shape(M, )", "Returns", "outfloat"], "returns": "outfloatThe NPV of the input cash flow series values at the discountrate.", "examples": ["; rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000]\n; np.npv(rate, cashflows).round(5)\n3065.22267\n\n", "; rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000]\n; np.npv(rate, cashflows).round(5)\n3065.22267\n", "; initial_cashflow = cashflows[0]\n; cashflows[0] = 0\n; np.round(np.npv(rate, cashflows) + initial_cashflow, 5)\n3065.22267\n\n", "; initial_cashflow = cashflows[0]\n; cashflows[0] = 0\n; np.round(np.npv(rate, cashflows) + initial_cashflow, 5)\n3065.22267\n"]},
{"library": "numpy", "item_id": "numpy.ma.notmasked_edges", "code": "\nnumpy.ma.notmasked_edges(a, axis=None)[source]\u00b6", "description": "Find the indices of the first and last unmasked values along an axis.\nIf all values are masked, return None.  Otherwise, return a list\nof two tuples, corresponding to the indices of the first and last\nunmasked values respectively.\n\nParameters\n\naarray_likeThe input array.\n\naxisint, optionalAxis along which to perform the operation.\nIf None (default), applies to a flattened version of the array.\n\n\n\nReturns\n\nedgesndarray or listAn array of start and end indexes if there are any masked data in\nthe array. If there are no masked data in the array, edges is a\nlist of the first and last index.\n\n\n\n\n\nSee also\nflatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous, clump_masked, clump_unmasked\n\nExamples\n&gt;&gt;&gt; a = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; m = np.zeros_like(a)\n&gt;&gt;&gt; m[1:, 1:] = 1\n\n\n&gt;&gt;&gt; am = np.ma.array(a, mask=m)\n&gt;&gt;&gt; np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n\n\n&gt;&gt;&gt; np.ma.notmasked_edges(am)\narray([0, 6])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "Returns", "edgesndarray or list"], "returns": "edgesndarray or listAn array of start and end indexes if there are any masked data inthe array. If there are no masked data in the array, edges is alist of the first and last index.", "examples": ["; a = np.arange(9).reshape((3, 3))\n; m = np.zeros_like(a)\n; m[1:, 1:] = 1\n\n", "; a = np.arange(9).reshape((3, 3))\n; m = np.zeros_like(a)\n; m[1:, 1:] = 1\n", "; am = np.ma.array(a, mask=m)\n; np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n\n", "; am = np.ma.array(a, mask=m)\n; np.array(am[~am.mask])\narray([0, 1, 2, 3, 6])\n", "; np.ma.notmasked_edges(am)\narray([0, 6])\n\n", "; np.ma.notmasked_edges(am)\narray([0, 6])\n"]},
{"library": "numpy", "item_id": "numpy.ma.notmasked_contiguous", "code": "\nnumpy.ma.notmasked_contiguous(a, axis=None)[source]\u00b6", "description": "Find contiguous unmasked data in a masked array along the given axis.\n\nParameters\n\naarray_likeThe input array.\n\naxisint, optionalAxis along which to perform the operation.\nIf None (default), applies to a flattened version of the array, and this\nis the same as flatnotmasked_contiguous.\n\n\n\nReturns\n\nendpointslistA list of slices (start and end indexes) of unmasked indexes\nin the array.\nIf the input is 2d and axis is specified, the result is a list of lists.\n\n\n\n\n\nSee also\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges, clump_masked, clump_unmasked\n\nNotes\nOnly accepts 2-D arrays at most.\nExamples\n&gt;&gt;&gt; a = np.arange(12).reshape((3, 4))\n&gt;&gt;&gt; mask = np.zeros_like(a)\n&gt;&gt;&gt; mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n&gt;&gt;&gt; ma = np.ma.array(a, mask=mask)\n&gt;&gt;&gt; ma\nmasked_array(\n  data=[[0, --, 2, 3],\n        [--, --, --, 7],\n        [8, --, --, 11]],\n  mask=[[False,  True, False, False],\n        [ True,  True,  True, False],\n        [False,  True,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n\n\n&gt;&gt;&gt; np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n\n&gt;&gt;&gt; np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n\n&gt;&gt;&gt; np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "Returns", "endpointslist"], "returns": "endpointslistA list of slices (start and end indexes) of unmasked indexesin the array.If the input is 2d and axis is specified, the result is a list of lists.", "examples": ["; a = np.arange(12).reshape((3, 4))\n; mask = np.zeros_like(a)\n; mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n; ma = np.ma.array(a, mask=mask)\n; ma\nmasked_array(\n  data=[[0, --, 2, 3],\n        [--, --, --, 7],\n        [8, --, --, 11]],\n  mask=[[False,  True, False, False],\n        [ True,  True,  True, False],\n        [False,  True,  True, False]],\n  fill_value=999999)\n; np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n\n", "; a = np.arange(12).reshape((3, 4))\n; mask = np.zeros_like(a)\n; mask[1:, :-1] = 1; mask[0, 1] = 1; mask[-1, 0] = 0\n; ma = np.ma.array(a, mask=mask)\n; ma\nmasked_array(\n  data=[[0, --, 2, 3],\n        [--, --, --, 7],\n        [8, --, --, 11]],\n  mask=[[False,  True, False, False],\n        [ True,  True,  True, False],\n        [False,  True,  True, False]],\n  fill_value=999999)\n; np.array(ma[~ma.mask])\narray([ 0,  2,  3,  7, 8, 11])\n", "; np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n\n", "; np.ma.notmasked_contiguous(ma)\n[slice(0, 1, None), slice(2, 4, None), slice(7, 9, None), slice(11, 12, None)]\n", "; np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n\n", "; np.ma.notmasked_contiguous(ma, axis=0)\n[[slice(0, 1, None), slice(2, 3, None)], [], [slice(0, 1, None)], [slice(0, 3, None)]]\n", "; np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]\n\n", "; np.ma.notmasked_contiguous(ma, axis=1)\n[[slice(0, 1, None), slice(2, 4, None)], [slice(3, 4, None)], [slice(0, 1, None), slice(3, 4, None)]]\n"]},
{"library": "numpy", "item_id": "numpy.char.not_equal", "code": "\nnumpy.char.not_equal(x1, x2)\u00b6", "description": "Return (x1 != x2) element-wise.\nUnlike numpy.not_equal, this comparison is performed by first\nstripping whitespace characters from the end of the string.  This\nbehavior is provided for backward-compatibility with numarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, greater_equal, less_equal, greater, less\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.nper", "code": "\nnumpy.nper(rate, pmt, pv, fv=0, when='end')[source]\u00b6", "description": "Compute the number of periodic payments.\n\nDeprecated since version 1.18: nper is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\ndecimal.Decimal type is not supported.\n\nParameters\n\nratearray_likeRate of interest (per period)\n\npmtarray_likePayment\n\npvarray_likePresent value\n\nfvarray_like, optionalFuture value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optionalWhen payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0))\n\n\n\n\nNotes\nThe number of periods nper is computed by solving the equation:\nfv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0\n\n\nbut if rate = 0 then:\nfv + pv + pmt*nper = 0\n\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n\nExamples\nIf you only had $150/month to pay towards the loan, how long would it take\nto pay-off a loan of $8,000 at 7% annual interest?\n&gt;&gt;&gt; print(np.round(np.nper(0.07/12, -150, 8000), 5))\n64.07335\n\n\nSo, over 64 months would be required to pay off the loan.\nThe same analysis could be done with several different interest rates\nand/or payments and/or total amounts to produce an entire table.\n&gt;&gt;&gt; np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n...                    -150   : -99     : 50    ,\n...                    8000   : 9001    : 1000]))\narray([[[ 64.07334877,  74.06368256],\n        [108.07548412, 127.99022654]],\n       [[ 66.12443902,  76.87897353],\n        [114.70165583, 137.90124779]]])\n\n\n", "parameters": ["Parameters", "ratearray_like", "pmtarray_like", "pvarray_like", "fvarray_like, optional", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optional"], "returns": [], "examples": ["; print(np.round(np.nper(0.07/12, -150, 8000), 5))\n64.07335\n\n", "; print(np.round(np.nper(0.07/12, -150, 8000), 5))\n64.07335\n", "; np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n...                    -150   : -99     : 50    ,\n...                    8000   : 9001    : 1000]))\narray([[[ 64.07334877,  74.06368256],\n        [108.07548412, 127.99022654]],\n       [[ 66.12443902,  76.87897353],\n        [114.70165583, 137.90124779]]])\n\n", "; np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,\n...                    -150   : -99     : 50    ,\n...                    8000   : 9001    : 1000]))\narray([[[ 64.07334877,  74.06368256],\n        [108.07548412, 127.99022654]],\n       [[ 66.12443902,  76.87897353],\n        [114.70165583, 137.90124779]]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.normal", "code": "\nRandomState.normal(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw random samples from a normal (Gaussian) distribution.\nThe probability density function of the normal distribution, first\nderived by De Moivre and 200 years later by both Gauss and Laplace\nindependently [2], is often called the bell curve because of\nits characteristic shape (see the example below).\nThe normal distributions occurs often in nature.  For example, it\ndescribes the commonly occurring distribution of samples influenced\nby a large number of tiny, random disturbances, each with its own\nunique distribution [2].\n\nNote\nNew code should use the normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floatsMean (\u201ccentre\u201d) of the distribution.\n\nscalefloat or array_like of floatsStandard deviation (spread or \u201cwidth\u201d) of the distribution. Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.normprobability density function, distribution or cumulative density function, etc.\n\nGenerator.normalwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gaussian distribution is\n\n\nwhere  is the mean and  the standard\ndeviation. The square of the standard deviation, ,\nis called the variance.\nThe function has its peak at the mean, and its \u201cspread\u201d increases with\nthe standard deviation (the function reaches 0.607 times its maximum at\n and  [2]).  This implies that\nnormal is more likely to return samples lying close to the mean, rather\nthan those far away.\nReferences\n\n1\nWikipedia, \u201cNormal distribution\u201d,\nhttps://en.wikipedia.org/wiki/Normal_distribution\n\n2(1,2,3)\nP. R. Peebles Jr., \u201cCentral Limit Theorem\u201d in \u201cProbability,\nRandom Variables and Random Signal Principles\u201d, 4th ed., 2001,\npp. 51, 51, 125.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation\n&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)\n\n\nVerify the mean and the variance:\n&gt;&gt;&gt; abs(mu - np.mean(s))\n0.0  # may vary\n\n\n&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nTwo-by-four array of samples from N(3, 6.25):\n&gt;&gt;&gt; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized normal distribution.", "examples": ["; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.normal(mu, sigma, 1000)\n\n", "; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.normal(mu, sigma, 1000)\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.not_equal", "code": "\nnumpy.not_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'not_equal'&gt;\u00b6", "description": "Return (x1 != x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays.  If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, greater, greater_equal, less, less_equal\n\nExamples\n&gt;&gt;&gt; np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n&gt;&gt;&gt; np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n; np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])\n\n", "; np.not_equal([1.,2.], [1., 3.])\narray([False,  True])\n; np.not_equal([1, 2], [[1, 3],[1, 4]])\narray([[False,  True],\n       [False,  True]])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.norm", "code": "\nnumpy.linalg.norm(x, ord=None, axis=None, keepdims=False)[source]\u00b6", "description": "Matrix or vector norm.\nThis function is able to return one of eight different matrix norms,\nor one of an infinite number of vector norms (described below), depending\non the value of the ord parameter.\n\nParameters\n\nxarray_likeInput array.  If axis is None, x must be 1-D or 2-D, unless ord\nis None. If both axis and ord are None, the 2-norm of\nx.ravel will be returned.\n\nord{non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019}, optionalOrder of the norm (see table under Notes). inf means numpy\u2019s\ninf object. The default is None.\n\naxis{None, int, 2-tuple of ints}, optional.If axis is an integer, it specifies the axis of x along which to\ncompute the vector norms.  If axis is a 2-tuple, it specifies the\naxes that hold 2-D matrices, and the matrix norms of these matrices\nare computed.  If axis is None then either a vector norm (when x\nis 1-D) or a matrix norm (when x is 2-D) is returned. The default\nis None.\n\nNew in version 1.8.0.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are normed over are left in the\nresult as dimensions with size one.  With this option the result will\nbroadcast correctly against the original x.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\nnfloat or ndarrayNorm of the matrix or vector(s).\n\n\n\n\nNotes\nFor values of ord &lt;= 0, the result is, strictly speaking, not a\nmathematical \u2018norm\u2019, but it may still be useful for various numerical\npurposes.\nThe following norms can be calculated:\n\n\n\n\n\n\n\nord\nnorm for matrices\nnorm for vectors\n\n\n\nNone\nFrobenius norm\n2-norm\n\n\u2018fro\u2019\nFrobenius norm\n\u2013\n\n\u2018nuc\u2019\nnuclear norm\n\u2013\n\ninf\nmax(sum(abs(x), axis=1))\nmax(abs(x))\n\n-inf\nmin(sum(abs(x), axis=1))\nmin(abs(x))\n\n0\n\u2013\nsum(x != 0)\n\n1\nmax(sum(abs(x), axis=0))\nas below\n\n-1\nmin(sum(abs(x), axis=0))\nas below\n\n2\n2-norm (largest sing. value)\nas below\n\n-2\nsmallest singular value\nas below\n\nother\n\u2013\nsum(abs(x)**ord)**(1./ord)\n\n\n\nThe Frobenius norm is given by [1]:\n\n\n\nThe nuclear norm is the sum of the singular values.\nReferences\n\n1\nG. H. Golub and C. F. Van Loan, Matrix Computations,\nBaltimore, MD, Johns Hopkins University Press, 1985, pg. 15\n\n\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; a = np.arange(9) - 4\n&gt;&gt;&gt; a\narray([-4, -3, -2, ...,  2,  3,  4])\n&gt;&gt;&gt; b = a.reshape((3, 3))\n&gt;&gt;&gt; b\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])\n\n\n&gt;&gt;&gt; LA.norm(a)\n7.745966692414834\n&gt;&gt;&gt; LA.norm(b)\n7.745966692414834\n&gt;&gt;&gt; LA.norm(b, 'fro')\n7.745966692414834\n&gt;&gt;&gt; LA.norm(a, np.inf)\n4.0\n&gt;&gt;&gt; LA.norm(b, np.inf)\n9.0\n&gt;&gt;&gt; LA.norm(a, -np.inf)\n0.0\n&gt;&gt;&gt; LA.norm(b, -np.inf)\n2.0\n\n\n&gt;&gt;&gt; LA.norm(a, 1)\n20.0\n&gt;&gt;&gt; LA.norm(b, 1)\n7.0\n&gt;&gt;&gt; LA.norm(a, -1)\n-4.6566128774142013e-010\n&gt;&gt;&gt; LA.norm(b, -1)\n6.0\n&gt;&gt;&gt; LA.norm(a, 2)\n7.745966692414834\n&gt;&gt;&gt; LA.norm(b, 2)\n7.3484692283495345\n\n\n&gt;&gt;&gt; LA.norm(a, -2)\n0.0\n&gt;&gt;&gt; LA.norm(b, -2)\n1.8570331885190563e-016 # may vary\n&gt;&gt;&gt; LA.norm(a, 3)\n5.8480354764257312 # may vary\n&gt;&gt;&gt; LA.norm(a, -3)\n0.0\n\n\nUsing the axis argument to compute vector norms:\n&gt;&gt;&gt; c = np.array([[ 1, 2, 3],\n...               [-1, 1, 4]])\n&gt;&gt;&gt; LA.norm(c, axis=0)\narray([ 1.41421356,  2.23606798,  5.        ])\n&gt;&gt;&gt; LA.norm(c, axis=1)\narray([ 3.74165739,  4.24264069])\n&gt;&gt;&gt; LA.norm(c, ord=1, axis=1)\narray([ 6.,  6.])\n\n\nUsing the axis argument to compute matrix norms:\n&gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)\n&gt;&gt;&gt; LA.norm(m, axis=(1,2))\narray([  3.74165739,  11.22497216])\n&gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])\n(3.7416573867739413, 11.224972160321824)\n\n\n", "parameters": ["Parameters", "xarray_like", "ord{non-zero int, inf, -inf, \u2018fro\u2019, \u2018nuc\u2019}, optional", "axis{None, int, 2-tuple of ints}, optional.", "keepdimsbool, optional", "Returns", "nfloat or ndarray"], "returns": "nfloat or ndarrayNorm of the matrix or vector(s).", "examples": ["; from numpy import linalg as LA\n; a = np.arange(9) - 4\n; a\narray([-4, -3, -2, ...,  2,  3,  4])\n; b = a.reshape((3, 3))\n; b\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])\n\n", "; from numpy import linalg as LA\n; a = np.arange(9) - 4\n; a\narray([-4, -3, -2, ...,  2,  3,  4])\n; b = a.reshape((3, 3))\n; b\narray([[-4, -3, -2],\n       [-1,  0,  1],\n       [ 2,  3,  4]])\n", "; LA.norm(a)\n7.745966692414834\n; LA.norm(b)\n7.745966692414834\n; LA.norm(b, 'fro')\n7.745966692414834\n; LA.norm(a, np.inf)\n4.0\n; LA.norm(b, np.inf)\n9.0\n; LA.norm(a, -np.inf)\n0.0\n; LA.norm(b, -np.inf)\n2.0\n\n", "; LA.norm(a)\n7.745966692414834\n; LA.norm(b)\n7.745966692414834\n; LA.norm(b, 'fro')\n7.745966692414834\n; LA.norm(a, np.inf)\n4.0\n; LA.norm(b, np.inf)\n9.0\n; LA.norm(a, -np.inf)\n0.0\n; LA.norm(b, -np.inf)\n2.0\n", "; LA.norm(a, 1)\n20.0\n; LA.norm(b, 1)\n7.0\n; LA.norm(a, -1)\n-4.6566128774142013e-010\n; LA.norm(b, -1)\n6.0\n; LA.norm(a, 2)\n7.745966692414834\n; LA.norm(b, 2)\n7.3484692283495345\n\n", "; LA.norm(a, 1)\n20.0\n; LA.norm(b, 1)\n7.0\n; LA.norm(a, -1)\n-4.6566128774142013e-010\n; LA.norm(b, -1)\n6.0\n; LA.norm(a, 2)\n7.745966692414834\n; LA.norm(b, 2)\n7.3484692283495345\n", "; LA.norm(a, -2)\n0.0\n; LA.norm(b, -2)\n1.8570331885190563e-016 # may vary\n; LA.norm(a, 3)\n5.8480354764257312 # may vary\n; LA.norm(a, -3)\n0.0\n\n", "; LA.norm(a, -2)\n0.0\n; LA.norm(b, -2)\n1.8570331885190563e-016 # may vary\n; LA.norm(a, 3)\n5.8480354764257312 # may vary\n; LA.norm(a, -3)\n0.0\n", "; c = np.array([[ 1, 2, 3],\n...               [-1, 1, 4]])\n; LA.norm(c, axis=0)\narray([ 1.41421356,  2.23606798,  5.        ])\n; LA.norm(c, axis=1)\narray([ 3.74165739,  4.24264069])\n; LA.norm(c, ord=1, axis=1)\narray([ 6.,  6.])\n\n", "; c = np.array([[ 1, 2, 3],\n...               [-1, 1, 4]])\n; LA.norm(c, axis=0)\narray([ 1.41421356,  2.23606798,  5.        ])\n; LA.norm(c, axis=1)\narray([ 3.74165739,  4.24264069])\n; LA.norm(c, ord=1, axis=1)\narray([ 6.,  6.])\n", "; m = np.arange(8).reshape(2,2,2)\n; LA.norm(m, axis=(1,2))\narray([  3.74165739,  11.22497216])\n; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])\n(3.7416573867739413, 11.224972160321824)\n\n", "; m = np.arange(8).reshape(2,2,2)\n; LA.norm(m, axis=(1,2))\narray([  3.74165739,  11.22497216])\n; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])\n(3.7416573867739413, 11.224972160321824)\n"]},
{"library": "numpy", "item_id": "numpy.random.pareto", "code": "\nnumpy.random.pareto(a, size=None)\u00b6", "description": "Draw samples from a Pareto II or Lomax distribution with\nspecified shape.\nThe Lomax or Pareto II distribution is a shifted Pareto\ndistribution. The classical Pareto distribution can be\nobtained from the Lomax distribution by adding 1 and\nmultiplying by the scale parameter m (see Notes).  The\nsmallest value of the Lomax distribution is zero while for the\nclassical Pareto distribution it is mu, where the standard\nPareto distribution has location mu = 1.  Lomax can also\nbe considered as a simplified version of the Generalized\nPareto distribution (available in SciPy), with the scale set\nto one and the location set to zero.\nThe Pareto distribution must be greater than zero, and is\nunbounded above.  It is also known as the \u201c80-20 rule\u201d.  In\nthis distribution, 80 percent of the weights are in the lowest\n20 percent of the range, while the other 20 percent fill the\nremaining 80 percent of the range.\n\nNote\nNew code should use the pareto method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsShape of the distribution. Must be positive.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Pareto distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lomaxprobability density function, distribution or cumulative density function, etc.\n\nscipy.stats.genparetoprobability density function, distribution or cumulative density function, etc.\n\nGenerator.paretowhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Pareto distribution is\n\n\nwhere  is the shape and  the scale.\nThe Pareto distribution, named after the Italian economist\nVilfredo Pareto, is a power law probability distribution\nuseful in many real world problems.  Outside the field of\neconomics it is generally referred to as the Bradford\ndistribution. Pareto developed the distribution to describe\nthe distribution of wealth in an economy.  It has also found\nuse in insurance, web page access statistics, oil field sizes,\nand many other problems, including the download frequency for\nprojects in Sourceforge [1].  It is one of the so-called\n\u201cfat-tailed\u201d distributions.\nReferences\n\n1\nFrancis Hunt and Paul Johnson, On the Pareto Distribution of\nSourceforge projects.\n\n2\nPareto, V. (1896). Course of Political Economy. Lausanne.\n\n3\nReiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\nValues, Birkhauser Verlag, Basel, pp 23-30.\n\n4\nWikipedia, \u201cPareto distribution\u201d,\nhttps://en.wikipedia.org/wiki/Pareto_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a, m = 3., 2.  # shape and mode\n&gt;&gt;&gt; s = (np.random.pareto(a, 1000) + 1) * m\n\n\nDisplay the histogram of the samples, along with the probability\ndensity function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, _ = plt.hist(s, 100, density=True)\n&gt;&gt;&gt; fit = a*m**a / bins**(a+1)\n&gt;&gt;&gt; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Pareto distribution.", "examples": ["; a, m = 3., 2.  # shape and mode\n; s = (np.random.pareto(a, 1000) + 1) * m\n\n", "; a, m = 3., 2.  # shape and mode\n; s = (np.random.pareto(a, 1000) + 1) * m\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.pad", "code": "\nnumpy.pad(array, pad_width, mode='constant', **kwargs)[source]\u00b6", "description": "Pad an array.\n\nParameters\n\narrayarray_like of rank NThe array to pad.\n\npad_width{sequence, array_like, int}Number of values padded to the edges of each axis.\n((before_1, after_1), \u2026 (before_N, after_N)) unique pad widths\nfor each axis.\n((before, after),) yields same before and after pad for each axis.\n(pad,) or int is a shortcut for before = after = pad width for all\naxes.\n\nmodestr or function, optionalOne of the following string values or a user supplied function.\n\n\u2018constant\u2019 (default)Pads with a constant value.\n\n\u2018edge\u2019Pads with the edge values of array.\n\n\u2018linear_ramp\u2019Pads with the linear ramp between end_value and the\narray edge value.\n\n\u2018maximum\u2019Pads with the maximum value of all or part of the\nvector along each axis.\n\n\u2018mean\u2019Pads with the mean value of all or part of the\nvector along each axis.\n\n\u2018median\u2019Pads with the median value of all or part of the\nvector along each axis.\n\n\u2018minimum\u2019Pads with the minimum value of all or part of the\nvector along each axis.\n\n\u2018reflect\u2019Pads with the reflection of the vector mirrored on\nthe first and last values of the vector along each\naxis.\n\n\u2018symmetric\u2019Pads with the reflection of the vector mirrored\nalong the edge of the array.\n\n\u2018wrap\u2019Pads with the wrap of the vector along the axis.\nThe first values are used to pad the end and the\nend values are used to pad the beginning.\n\n\u2018empty\u2019Pads with undefined values.\n\nNew in version 1.17.\n\n\n&lt;function&gt;Padding function, see Notes.\n\n\n\nstat_lengthsequence or int, optionalUsed in \u2018maximum\u2019, \u2018mean\u2019, \u2018median\u2019, and \u2018minimum\u2019.  Number of\nvalues at edge of each axis used to calculate the statistic value.\n((before_1, after_1), \u2026 (before_N, after_N)) unique statistic\nlengths for each axis.\n((before, after),) yields same before and after statistic lengths\nfor each axis.\n(stat_length,) or int is a shortcut for before = after = statistic\nlength for all axes.\nDefault is None, to use the entire axis.\n\nconstant_valuessequence or scalar, optionalUsed in \u2018constant\u2019.  The values to set the padded values for each\naxis.\n((before_1, after_1), ... (before_N, after_N)) unique pad constants\nfor each axis.\n((before, after),) yields same before and after constants for each\naxis.\n(constant,) or constant is a shortcut for before = after = constant for\nall axes.\nDefault is 0.\n\nend_valuessequence or scalar, optionalUsed in \u2018linear_ramp\u2019.  The values used for the ending value of the\nlinear_ramp and that will form the edge of the padded array.\n((before_1, after_1), ... (before_N, after_N)) unique end values\nfor each axis.\n((before, after),) yields same before and after end values for each\naxis.\n(constant,) or constant is a shortcut for before = after = constant for\nall axes.\nDefault is 0.\n\nreflect_type{\u2018even\u2019, \u2018odd\u2019}, optionalUsed in \u2018reflect\u2019, and \u2018symmetric\u2019.  The \u2018even\u2019 style is the\ndefault with an unaltered reflection around the edge value.  For\nthe \u2018odd\u2019 style, the extended part of the array is created by\nsubtracting the reflected values from two times the edge value.\n\n\n\nReturns\n\npadndarrayPadded array of rank equal to array with shape increased\naccording to pad_width.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nFor an array with rank greater than 1, some of the padding of later\naxes is calculated from padding of previous axes.  This is easiest to\nthink about with a rank 2 array where the corners of the padded array\nare calculated by using padded values from the first axis.\nThe padding function, if used, should modify a rank 1 array in-place. It\nhas the following signature:\npadding_func(vector, iaxis_pad_width, iaxis, kwargs)\n\n\nwhere\n\n\nvectorndarrayA rank 1 array already padded with zeros.  Padded values are\nvector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].\n\niaxis_pad_widthtupleA 2-tuple of ints, iaxis_pad_width[0] represents the number of\nvalues padded at the beginning of vector where\niaxis_pad_width[1] represents the number of values padded at\nthe end of vector.\n\niaxisintThe axis currently being calculated.\n\nkwargsdictAny keyword arguments the function requires.\n\n\n\nExamples\n&gt;&gt;&gt; a = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; np.pad(a, (2, 3), 'constant', constant_values=(4, 6))\narray([4, 4, 1, ..., 6, 6, 6])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'edge')\narray([1, 1, 1, ..., 5, 5, 5])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))\narray([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])\n\n\n&gt;&gt;&gt; np.pad(a, (2,), 'maximum')\narray([5, 5, 1, 2, 3, 4, 5, 5, 5])\n\n\n&gt;&gt;&gt; np.pad(a, (2,), 'mean')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n\n&gt;&gt;&gt; np.pad(a, (2,), 'median')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n\n&gt;&gt;&gt; a = [[1, 2], [3, 4]]\n&gt;&gt;&gt; np.pad(a, ((3, 2), (2, 3)), 'minimum')\narray([[1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [3, 3, 3, 4, 3, 3, 3],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1]])\n\n\n&gt;&gt;&gt; a = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect')\narray([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'reflect', reflect_type='odd')\narray([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric')\narray([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')\narray([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])\n\n\n&gt;&gt;&gt; np.pad(a, (2, 3), 'wrap')\narray([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])\n\n\n&gt;&gt;&gt; def pad_with(vector, pad_width, iaxis, kwargs):\n...     pad_value = kwargs.get('padder', 10)\n...     vector[:pad_width[0]] = pad_value\n...     vector[-pad_width[1]:] = pad_value\n&gt;&gt;&gt; a = np.arange(6)\n&gt;&gt;&gt; a = a.reshape((2, 3))\n&gt;&gt;&gt; np.pad(a, 2, pad_with)\narray([[10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10,  0,  1,  2, 10, 10],\n       [10, 10,  3,  4,  5, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10]])\n&gt;&gt;&gt; np.pad(a, 2, pad_with, padder=100)\narray([[100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100,   0,   1,   2, 100, 100],\n       [100, 100,   3,   4,   5, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100]])\n\n\n", "parameters": ["Parameters", "arrayarray_like of rank N", "pad_width{sequence, array_like, int}", "modestr or function, optional", "\u2018constant\u2019 (default)", "\u2018edge\u2019", "\u2018linear_ramp\u2019", "\u2018maximum\u2019", "\u2018mean\u2019", "\u2018median\u2019", "\u2018minimum\u2019", "\u2018reflect\u2019", "\u2018symmetric\u2019", "\u2018wrap\u2019", "\u2018empty\u2019", "&lt;function&gt;", "stat_lengthsequence or int, optional", "constant_valuessequence or scalar, optional", "end_valuessequence or scalar, optional", "reflect_type{\u2018even\u2019, \u2018odd\u2019}, optional", "Returns", "padndarray"], "returns": "padndarrayPadded array of rank equal to array with shape increasedaccording to pad_width.", "examples": ["; a = [1, 2, 3, 4, 5]\n; np.pad(a, (2, 3), 'constant', constant_values=(4, 6))\narray([4, 4, 1, ..., 6, 6, 6])\n\n", "; a = [1, 2, 3, 4, 5]\n; np.pad(a, (2, 3), 'constant', constant_values=(4, 6))\narray([4, 4, 1, ..., 6, 6, 6])\n", "; np.pad(a, (2, 3), 'edge')\narray([1, 1, 1, ..., 5, 5, 5])\n\n", "; np.pad(a, (2, 3), 'edge')\narray([1, 1, 1, ..., 5, 5, 5])\n", "; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))\narray([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])\n\n", "; np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))\narray([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])\n", "; np.pad(a, (2,), 'maximum')\narray([5, 5, 1, 2, 3, 4, 5, 5, 5])\n\n", "; np.pad(a, (2,), 'maximum')\narray([5, 5, 1, 2, 3, 4, 5, 5, 5])\n", "; np.pad(a, (2,), 'mean')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n", "; np.pad(a, (2,), 'mean')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n", "; np.pad(a, (2,), 'median')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n\n", "; np.pad(a, (2,), 'median')\narray([3, 3, 1, 2, 3, 4, 5, 3, 3])\n", "; a = [[1, 2], [3, 4]]\n; np.pad(a, ((3, 2), (2, 3)), 'minimum')\narray([[1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [3, 3, 3, 4, 3, 3, 3],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1]])\n\n", "; a = [[1, 2], [3, 4]]\n; np.pad(a, ((3, 2), (2, 3)), 'minimum')\narray([[1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1],\n       [3, 3, 3, 4, 3, 3, 3],\n       [1, 1, 1, 2, 1, 1, 1],\n       [1, 1, 1, 2, 1, 1, 1]])\n", "; a = [1, 2, 3, 4, 5]\n; np.pad(a, (2, 3), 'reflect')\narray([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])\n\n", "; a = [1, 2, 3, 4, 5]\n; np.pad(a, (2, 3), 'reflect')\narray([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])\n", "; np.pad(a, (2, 3), 'reflect', reflect_type='odd')\narray([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])\n\n", "; np.pad(a, (2, 3), 'reflect', reflect_type='odd')\narray([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])\n", "; np.pad(a, (2, 3), 'symmetric')\narray([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])\n\n", "; np.pad(a, (2, 3), 'symmetric')\narray([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])\n", "; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')\narray([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])\n\n", "; np.pad(a, (2, 3), 'symmetric', reflect_type='odd')\narray([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])\n", "; np.pad(a, (2, 3), 'wrap')\narray([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])\n\n", "; np.pad(a, (2, 3), 'wrap')\narray([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])\n", "; def pad_with(vector, pad_width, iaxis, kwargs):\n...     pad_value = kwargs.get('padder', 10)\n...     vector[:pad_width[0]] = pad_value\n...     vector[-pad_width[1]:] = pad_value\n; a = np.arange(6)\n; a = a.reshape((2, 3))\n; np.pad(a, 2, pad_with)\narray([[10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10,  0,  1,  2, 10, 10],\n       [10, 10,  3,  4,  5, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10]])\n; np.pad(a, 2, pad_with, padder=100)\narray([[100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100,   0,   1,   2, 100, 100],\n       [100, 100,   3,   4,   5, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100]])\n\n", "; def pad_with(vector, pad_width, iaxis, kwargs):\n...     pad_value = kwargs.get('padder', 10)\n...     vector[:pad_width[0]] = pad_value\n...     vector[-pad_width[1]:] = pad_value\n; a = np.arange(6)\n; a = a.reshape((2, 3))\n; np.pad(a, 2, pad_with)\narray([[10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10,  0,  1,  2, 10, 10],\n       [10, 10,  3,  4,  5, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10],\n       [10, 10, 10, 10, 10, 10, 10]])\n; np.pad(a, 2, pad_with, padder=100)\narray([[100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100,   0,   1,   2, 100, 100],\n       [100, 100,   3,   4,   5, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100],\n       [100, 100, 100, 100, 100, 100, 100]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.outerproduct", "code": "\nnumpy.ma.outerproduct(a, b)[source]\u00b6", "description": "Compute the outer product of two vectors.\nGiven two vectors, a = [a0, a1, ..., aM] and\nb = [b0, b1, ..., bN],\nthe outer product [1] is:\n[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n\n\nParameters\n\na(M,) array_likeFirst input vector.  Input is flattened if\nnot already 1-dimensional.\n\nb(N,) array_likeSecond input vector.  Input is flattened if\nnot already 1-dimensional.\n\nout(M, N) ndarray, optionalA location where the result is stored\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\nout(M, N) ndarrayout[i, j] = a[i] * b[j]\n\n\n\n\n\nSee also\ninner\n\neinsumeinsum('i,j-&gt;ij', a.ravel(), b.ravel()) is the equivalent.\n\nufunc.outerA generalization to N dimensions and other operations. np.multiply.outer(a.ravel(), b.ravel()) is the equivalent.\n\n\n\nNotes\nMasked values are replaced by 0.\nReferences\n\n1\n: G. H. Golub and C. F. Van Loan, Matrix Computations, 3rd\ned., Baltimore, MD, Johns Hopkins University Press, 1996,\npg. 8.\n\n\nExamples\nMake a (very coarse) grid for computing a Mandelbrot set:\n&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n&gt;&gt;&gt; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n&gt;&gt;&gt; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n&gt;&gt;&gt; grid = rl + im\n&gt;&gt;&gt; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n\nAn example using a \u201cvector\u201d of letters:\n&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)\n&gt;&gt;&gt; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n\n", "parameters": ["Parameters", "a(M,) array_like", "b(N,) array_like", "out(M, N) ndarray, optional", "Returns", "out(M, N) ndarray"], "returns": "out(M, N) ndarrayout[i, j] = a[i] * b[j]", "examples": ["; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n", "; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.normal", "code": "\nGenerator.normal(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw random samples from a normal (Gaussian) distribution.\nThe probability density function of the normal distribution, first\nderived by De Moivre and 200 years later by both Gauss and Laplace\nindependently [2], is often called the bell curve because of\nits characteristic shape (see the example below).\nThe normal distributions occurs often in nature.  For example, it\ndescribes the commonly occurring distribution of samples influenced\nby a large number of tiny, random disturbances, each with its own\nunique distribution [2].\n\nParameters\n\nlocfloat or array_like of floatsMean (\u201ccentre\u201d) of the distribution.\n\nscalefloat or array_like of floatsStandard deviation (spread or \u201cwidth\u201d) of the distribution. Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.normprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Gaussian distribution is\n\n\nwhere  is the mean and  the standard\ndeviation. The square of the standard deviation, ,\nis called the variance.\nThe function has its peak at the mean, and its \u201cspread\u201d increases with\nthe standard deviation (the function reaches 0.607 times its maximum at\n and  [2]).  This implies that\nnormal is more likely to return samples lying close to the\nmean, rather than those far away.\nReferences\n\n1\nWikipedia, \u201cNormal distribution\u201d,\nhttps://en.wikipedia.org/wiki/Normal_distribution\n\n2(1,2,3)\nP. R. Peebles Jr., \u201cCentral Limit Theorem\u201d in \u201cProbability,\nRandom Variables and Random Signal Principles\u201d, 4th ed., 2001,\npp. 51, 51, 125.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation\n&gt;&gt;&gt; s = np.random.default_rng().normal(mu, sigma, 1000)\n\n\nVerify the mean and the variance:\n&gt;&gt;&gt; abs(mu - np.mean(s))\n0.0  # may vary\n\n\n&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nTwo-by-four array of samples from N(3, 6.25):\n&gt;&gt;&gt; np.random.default_rng().normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized normal distribution.", "examples": ["; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.default_rng().normal(mu, sigma, 1000)\n\n", "; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.default_rng().normal(mu, sigma, 1000)\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; np.random.default_rng().normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; np.random.default_rng().normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.normal", "code": "\nnumpy.random.normal(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw random samples from a normal (Gaussian) distribution.\nThe probability density function of the normal distribution, first\nderived by De Moivre and 200 years later by both Gauss and Laplace\nindependently [2], is often called the bell curve because of\nits characteristic shape (see the example below).\nThe normal distributions occurs often in nature.  For example, it\ndescribes the commonly occurring distribution of samples influenced\nby a large number of tiny, random disturbances, each with its own\nunique distribution [2].\n\nNote\nNew code should use the normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floatsMean (\u201ccentre\u201d) of the distribution.\n\nscalefloat or array_like of floatsStandard deviation (spread or \u201cwidth\u201d) of the distribution. Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.normprobability density function, distribution or cumulative density function, etc.\n\nGenerator.normalwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gaussian distribution is\n\n\nwhere  is the mean and  the standard\ndeviation. The square of the standard deviation, ,\nis called the variance.\nThe function has its peak at the mean, and its \u201cspread\u201d increases with\nthe standard deviation (the function reaches 0.607 times its maximum at\n and  [2]).  This implies that\nnormal is more likely to return samples lying close to the mean, rather\nthan those far away.\nReferences\n\n1\nWikipedia, \u201cNormal distribution\u201d,\nhttps://en.wikipedia.org/wiki/Normal_distribution\n\n2(1,2,3)\nP. R. Peebles Jr., \u201cCentral Limit Theorem\u201d in \u201cProbability,\nRandom Variables and Random Signal Principles\u201d, 4th ed., 2001,\npp. 51, 51, 125.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, sigma = 0, 0.1 # mean and standard deviation\n&gt;&gt;&gt; s = np.random.normal(mu, sigma, 1000)\n\n\nVerify the mean and the variance:\n&gt;&gt;&gt; abs(mu - np.mean(s))\n0.0  # may vary\n\n\n&gt;&gt;&gt; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nTwo-by-four array of samples from N(3, 6.25):\n&gt;&gt;&gt; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized normal distribution.", "examples": ["; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.normal(mu, sigma, 1000)\n\n", "; mu, sigma = 0, 0.1 # mean and standard deviation\n; s = np.random.normal(mu, sigma, 1000)\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n\n", "; abs(mu - np.mean(s))\n0.0  # may vary\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n\n", "; abs(sigma - np.std(s, ddof=1))\n0.1  # may vary\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, 1/(sigma * np.sqrt(2 * np.pi)) *\n...                np.exp( - (bins - mu)**2 / (2 * sigma**2) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; np.random.normal(3, 2.5, size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.outer", "code": "\nufunc.outer(A, B, **kwargs)\u00b6", "description": "Apply the ufunc op to all pairs (a, b) with a in A and b in B.\nLet M = A.ndim, N = B.ndim. Then the result, C, of\nop.outer(A, B) is an array of dimension M + N such that:\n\n\nFor A and B one-dimensional, this is equivalent to:\nr = empty(len(A),len(B))\nfor i in range(len(A)):\n    for j in range(len(B)):\n        r[i,j] = op(A[i], B[j]) # op = ufunc in question\n\n\n\nParameters\n\nAarray_likeFirst array\n\nBarray_likeSecond array\n\nkwargsanyArguments to pass on to the ufunc. Typically dtype or out.\n\n\n\nReturns\n\nrndarrayOutput array\n\n\n\n\n\nSee also\nnumpy.outer\n\nExamples\n&gt;&gt;&gt; np.multiply.outer([1, 2, 3], [4, 5, 6])\narray([[ 4,  5,  6],\n       [ 8, 10, 12],\n       [12, 15, 18]])\n\n\nA multi-dimensional example:\n&gt;&gt;&gt; A = np.array([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; A.shape\n(2, 3)\n&gt;&gt;&gt; B = np.array([[1, 2, 3, 4]])\n&gt;&gt;&gt; B.shape\n(1, 4)\n&gt;&gt;&gt; C = np.multiply.outer(A, B)\n&gt;&gt;&gt; C.shape; C\n(2, 3, 1, 4)\narray([[[[ 1,  2,  3,  4]],\n        [[ 2,  4,  6,  8]],\n        [[ 3,  6,  9, 12]]],\n       [[[ 4,  8, 12, 16]],\n        [[ 5, 10, 15, 20]],\n        [[ 6, 12, 18, 24]]]])\n\n\n", "parameters": ["Parameters", "Aarray_like", "Barray_like", "kwargsany", "Returns", "rndarray"], "returns": "rndarrayOutput array", "examples": ["; np.multiply.outer([1, 2, 3], [4, 5, 6])\narray([[ 4,  5,  6],\n       [ 8, 10, 12],\n       [12, 15, 18]])\n\n", "; np.multiply.outer([1, 2, 3], [4, 5, 6])\narray([[ 4,  5,  6],\n       [ 8, 10, 12],\n       [12, 15, 18]])\n", "; A = np.array([[1, 2, 3], [4, 5, 6]])\n; A.shape\n(2, 3)\n; B = np.array([[1, 2, 3, 4]])\n; B.shape\n(1, 4)\n; C = np.multiply.outer(A, B)\n; C.shape; C\n(2, 3, 1, 4)\narray([[[[ 1,  2,  3,  4]],\n        [[ 2,  4,  6,  8]],\n        [[ 3,  6,  9, 12]]],\n       [[[ 4,  8, 12, 16]],\n        [[ 5, 10, 15, 20]],\n        [[ 6, 12, 18, 24]]]])\n\n", "; A = np.array([[1, 2, 3], [4, 5, 6]])\n; A.shape\n(2, 3)\n; B = np.array([[1, 2, 3, 4]])\n; B.shape\n(1, 4)\n; C = np.multiply.outer(A, B)\n; C.shape; C\n(2, 3, 1, 4)\narray([[[[ 1,  2,  3,  4]],\n        [[ 2,  4,  6,  8]],\n        [[ 3,  6,  9, 12]]],\n       [[[ 4,  8, 12, 16]],\n        [[ 5, 10, 15, 20]],\n        [[ 6, 12, 18, 24]]]])\n"]},
{"library": "numpy", "item_id": "numpy.packbits", "code": "\nnumpy.packbits(a, axis=None, bitorder='big')\u00b6", "description": "Packs the elements of a binary-valued array into bits in a uint8 array.\nThe result is padded to full bytes by inserting zero bits at the end.\n\nParameters\n\naarray_likeAn array of integers or booleans whose elements should be packed to\nbits.\n\naxisint, optionalThe dimension over which bit-packing is done.\nNone implies packing the flattened array.\n\nbitorder{\u2018big\u2019, \u2018little\u2019}, optionalThe order of the input bits. \u2018big\u2019 will mimic bin(val),\n[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011 =&gt; ``, 'little' will\nreverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3.\nDefaults to \u2018big\u2019.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\npackedndarrayArray of type uint8 whose elements represent bits corresponding to the\nlogical (0 or nonzero) value of the input elements. The shape of\npacked has the same number of dimensions as the input (unless axis\nis None, in which case the output is 1-D).\n\n\n\n\n\nSee also\n\nunpackbitsUnpacks elements of a uint8 array into a binary-valued output array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n&gt;&gt;&gt; b = np.packbits(a, axis=-1)\n&gt;&gt;&gt; b\narray([[[160],\n        [ 64]],\n       [[192],\n        [ 32]]], dtype=uint8)\n\n\nNote that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,\nand 32 = 0010 0000.\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "bitorder{\u2018big\u2019, \u2018little\u2019}, optional", "Returns", "packedndarray"], "returns": "packedndarrayArray of type uint8 whose elements represent bits corresponding to thelogical (0 or nonzero) value of the input elements. The shape ofpacked has the same number of dimensions as the input (unless axisis None, in which case the output is 1-D).", "examples": ["; a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n; b = np.packbits(a, axis=-1)\n; b\narray([[[160],\n        [ 64]],\n       [[192],\n        [ 32]]], dtype=uint8)\n\n", "; a = np.array([[[1,0,1],\n...                [0,1,0]],\n...               [[1,1,0],\n...                [0,0,1]]])\n; b = np.packbits(a, axis=-1)\n; b\narray([[[160],\n        [ 64]],\n       [[192],\n        [ 32]]], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyint", "code": "\nnumpy.polynomial.polynomial.polyint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a polynomial.\nReturns the polynomial coefficients c integrated m times from\nlbnd along axis.  At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.) The argument c is an array of\ncoefficients, from low to high degree along each axis, e.g., [1,2,3]\nrepresents the polynomial 1 + 2*x + 3*x**2 while [[1,2],[1,2]]\nrepresents 1 + 1*x + 2*y + 2*x*y if axis=0 is x and axis=1 is\ny.\n\nParameters\n\ncarray_like1-D array of polynomial coefficients, ordered from low to high.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at zero\nis the first value in the list, the value of the second integral\nat zero is the second value, etc.  If k == [] (the default),\nall constants are set to zero.  If m == 1, a single scalar can\nbe given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayCoefficient array of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 1, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\npolyder\n\nNotes\nNote that the result of each integration is multiplied by scl.  Why\nis this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x. Then\n, so one will need to set scl equal to\n - perhaps not what one would have first thought.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c = (1,2,3)\n&gt;&gt;&gt; P.polyint(c) # should return array([0, 1, 1, 1])\narray([0.,  1.,  1.,  1.])\n&gt;&gt;&gt; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])\n array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary\n         0.05      ])\n&gt;&gt;&gt; P.polyint(c,k=3) # should return array([3, 1, 1, 1])\narray([3.,  1.,  1.,  1.])\n&gt;&gt;&gt; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])\narray([6.,  1.,  1.,  1.])\n&gt;&gt;&gt; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayCoefficient array of the integral.", "examples": ["; from numpy.polynomial import polynomial as P\n; c = (1,2,3)\n; P.polyint(c) # should return array([0, 1, 1, 1])\narray([0.,  1.,  1.,  1.])\n; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])\n array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary\n         0.05      ])\n; P.polyint(c,k=3) # should return array([3, 1, 1, 1])\narray([3.,  1.,  1.,  1.])\n; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])\narray([6.,  1.,  1.,  1.])\n; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])\n\n", "; from numpy.polynomial import polynomial as P\n; c = (1,2,3)\n; P.polyint(c) # should return array([0, 1, 1, 1])\narray([0.,  1.,  1.,  1.])\n; P.polyint(c,3) # should return array([0, 0, 0, 1/6, 1/12, 1/20])\n array([ 0.        ,  0.        ,  0.        ,  0.16666667,  0.08333333, # may vary\n         0.05      ])\n; P.polyint(c,k=3) # should return array([3, 1, 1, 1])\narray([3.,  1.,  1.,  1.])\n; P.polyint(c,lbnd=-2) # should return array([6, 1, 1, 1])\narray([6.,  1.,  1.,  1.])\n; P.polyint(c,scl=-2) # should return array([0, -2, -2, -2])\narray([ 0., -2., -2., -2.])\n"]},
{"library": "numpy", "item_id": "numpy.polyint", "code": "\nnumpy.polyint(p, m=1, k=None)[source]\u00b6", "description": "Return an antiderivative (indefinite integral) of a polynomial.\nThe returned order m antiderivative P of polynomial p satisfies\n and is defined up to m - 1\nintegration constants k. The constants determine the low-order\npolynomial part\n\n\nof P so that .\n\nParameters\n\nparray_like or poly1dPolynomial to integrate.\nA sequence is interpreted as polynomial coefficients, see poly1d.\n\nmint, optionalOrder of the antiderivative. (Default: 1)\n\nklist of m scalars or scalar, optionalIntegration constants. They are given in the order of integration:\nthose corresponding to highest-order terms come first.\nIf None (default), all constants are assumed to be zero.\nIf m = 1, a single scalar can be given instead of a list.\n\n\n\n\n\nSee also\n\npolyderderivative of a polynomial\n\npoly1d.integequivalent method\n\n\n\nExamples\nThe defining property of the antiderivative:\n&gt;&gt;&gt; p = np.poly1d([1,1,1])\n&gt;&gt;&gt; P = np.polyint(p)\n&gt;&gt;&gt; P\n poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary\n&gt;&gt;&gt; np.polyder(P) == p\nTrue\n\n\nThe integration constants default to zero, but can be specified:\n&gt;&gt;&gt; P = np.polyint(p, 3)\n&gt;&gt;&gt; P(0)\n0.0\n&gt;&gt;&gt; np.polyder(P)(0)\n0.0\n&gt;&gt;&gt; np.polyder(P, 2)(0)\n0.0\n&gt;&gt;&gt; P = np.polyint(p, 3, k=[6,5,3])\n&gt;&gt;&gt; P\npoly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary\n\n\nNote that 3 = 6 / 2!, and that the constants are given in the order of\nintegrations. Constant of the highest-order polynomial term comes first:\n&gt;&gt;&gt; np.polyder(P, 2)(0)\n6.0\n&gt;&gt;&gt; np.polyder(P, 1)(0)\n5.0\n&gt;&gt;&gt; P(0)\n3.0\n\n\n", "parameters": ["Parameters", "parray_like or poly1d", "mint, optional", "klist of m scalars or scalar, optional"], "returns": [], "examples": ["; p = np.poly1d([1,1,1])\n; P = np.polyint(p)\n; P\n poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary\n; np.polyder(P) == p\nTrue\n\n", "; p = np.poly1d([1,1,1])\n; P = np.polyint(p)\n; P\n poly1d([ 0.33333333,  0.5       ,  1.        ,  0.        ]) # may vary\n; np.polyder(P) == p\nTrue\n", "; P = np.polyint(p, 3)\n; P(0)\n0.0\n; np.polyder(P)(0)\n0.0\n; np.polyder(P, 2)(0)\n0.0\n; P = np.polyint(p, 3, k=[6,5,3])\n; P\npoly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary\n\n", "; P = np.polyint(p, 3)\n; P(0)\n0.0\n; np.polyder(P)(0)\n0.0\n; np.polyder(P, 2)(0)\n0.0\n; P = np.polyint(p, 3, k=[6,5,3])\n; P\npoly1d([ 0.01666667,  0.04166667,  0.16666667,  3. ,  5. ,  3. ]) # may vary\n", "; np.polyder(P, 2)(0)\n6.0\n; np.polyder(P, 1)(0)\n5.0\n; P(0)\n3.0\n\n", "; np.polyder(P, 2)(0)\n6.0\n; np.polyder(P, 1)(0)\n5.0\n; P(0)\n3.0\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.put", "code": "\nmasked_array.put(self, indices, values, mode='raise')[source]\u00b6", "description": "Set storage-indexed locations to corresponding values.\nSets self._data.flat[n] = values[n] for each n in indices.\nIf values is shorter than indices then it will repeat.\nIf values has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.\n\nParameters\n\nindices1-D array_likeTarget indices, interpreted as integers.\n\nvaluesarray_likeValues to place in self._data copy at target indices.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices will behave.\n\u2018raise\u2019 : raise an error.\n\u2018wrap\u2019 : wrap around.\n\u2018clip\u2019 : clip to the range.\n\n\n\n\nNotes\nvalues can be a scalar or length 1 array.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.put([0,4,8],[10,20,30])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n\n&gt;&gt;&gt; x.put(4,999)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "indices1-D array_like", "valuesarray_like", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional"], "returns": [], "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.put([0,4,8],[10,20,30])\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.put([0,4,8],[10,20,30])\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n", "; x.put(4,999)\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n", "; x.put(4,999)\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.generic.put", "code": "\ngeneric.put()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.put", "code": "\nchararray.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.put", "code": "\nnumpy.put(a, ind, v, mode='raise')[source]\u00b6", "description": "Replaces specified elements of an array with given values.\nThe indexing works on the flattened target array. put is roughly\nequivalent to:\na.flat[ind] = v\n\n\n\nParameters\n\nandarrayTarget array.\n\nindarray_likeTarget indices, interpreted as integers.\n\nvarray_likeValues to place in a at target indices. If v is shorter than\nind it will be repeated as necessary.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices will behave.\n\n\u2018raise\u2019 \u2013 raise an error (default)\n\u2018wrap\u2019 \u2013 wrap around\n\u2018clip\u2019 \u2013 clip to the range\n\n\u2018clip\u2019 mode means that all indices that are too large are replaced\nby the index that addresses the last element along that axis. Note\nthat this disables indexing with negative numbers. In \u2018raise\u2019 mode,\nif an exception occurs the target array may still be modified.\n\n\n\n\n\nSee also\nputmask, place\n\nput_along_axisPut elements by matching the array and the index arrays\n\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; np.put(a, [0, 2], [-44, -55])\n&gt;&gt;&gt; a\narray([-44,   1, -55,   3,   4])\n\n\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; np.put(a, 22, -5, mode='clip')\n&gt;&gt;&gt; a\narray([ 0,  1,  2,  3, -5])\n\n\n", "parameters": ["Parameters", "andarray", "indarray_like", "varray_like", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional"], "returns": [], "examples": ["; a = np.arange(5)\n; np.put(a, [0, 2], [-44, -55])\n; a\narray([-44,   1, -55,   3,   4])\n\n", "; a = np.arange(5)\n; np.put(a, [0, 2], [-44, -55])\n; a\narray([-44,   1, -55,   3,   4])\n", "; a = np.arange(5)\n; np.put(a, 22, -5, mode='clip')\n; a\narray([ 0,  1,  2,  3, -5])\n\n", "; a = np.arange(5)\n; np.put(a, 22, -5, mode='clip')\n; a\narray([ 0,  1,  2,  3, -5])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.put", "code": "\nchararray.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.pv", "code": "\nnumpy.pv(rate, nper, pmt, fv=0, when='end')[source]\u00b6", "description": "Compute the present value.\n\nDeprecated since version 1.18: pv is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nGiven:\na future value, fv\nan interest rate compounded once per period, of which\nthere are\nnper total\na (fixed) payment, pmt, paid either\nat the beginning (when = {\u2018begin\u2019, 1}) or the end\n(when = {\u2018end\u2019, 0}) of each period\n\n\nReturn:the value now\n\n\n\nParameters\n\nratearray_likeRate of interest (per period)\n\nnperarray_likeNumber of compounding periods\n\npmtarray_likePayment\n\nfvarray_like, optionalFuture value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optionalWhen payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0))\n\n\n\nReturns\n\noutndarray, floatPresent value of a series of payments or investments.\n\n\n\n\nNotes\nThe present value is computed by solving the equation:\nfv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0\n\n\nor, when rate = 0:\nfv + pv + pmt * nper = 0\n\n\nfor pv, which is then returned.\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nWheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\nOpen Document Format for Office Applications (OpenDocument)v1.2,\nPart 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\nPre-Draft 12. Organization for the Advancement of Structured Information\nStandards (OASIS). Billerica, MA, USA. [ODT Document].\nAvailable:\nhttp://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\nOpenDocument-formula-20090508.odt\n\n\nExamples\nWhat is the present value (e.g., the initial investment)\nof an investment that needs to total $15692.93\nafter 10 years of saving $100 every month?  Assume the\ninterest rate is 5% (annually) compounded monthly.\n&gt;&gt;&gt; np.pv(0.05/12, 10*12, -100, 15692.93)\n-100.00067131625819\n\n\nBy convention, the negative sign represents cash flow out\n(i.e., money not available today).  Thus, to end up with\n$15,692.93 in 10 years saving $100 a month at 5% annual\ninterest, one\u2019s initial deposit should also be $100.\nIf any input is array_like, pv returns an array of equal shape.\nLet\u2019s compare different interest rates in the example above:\n&gt;&gt;&gt; a = np.array((0.05, 0.04, 0.03))/12\n&gt;&gt;&gt; np.pv(a, 10*12, -100, 15692.93)\narray([ -100.00067132,  -649.26771385, -1273.78633713]) # may vary\n\n\nSo, to end up with the same $15692.93 under the same $100 per month\n\u201csavings plan,\u201d for annual interest rates of 4% and 3%, one would\nneed initial investments of $649.27 and $1273.79, respectively.\n", "parameters": ["Parameters", "ratearray_like", "nperarray_like", "pmtarray_like", "fvarray_like, optional", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optional", "Returns", "outndarray, float"], "returns": "outndarray, floatPresent value of a series of payments or investments.", "examples": ["; np.pv(0.05/12, 10*12, -100, 15692.93)\n-100.00067131625819\n\n", "; np.pv(0.05/12, 10*12, -100, 15692.93)\n-100.00067131625819\n", "; a = np.array((0.05, 0.04, 0.03))/12\n; np.pv(a, 10*12, -100, 15692.93)\narray([ -100.00067132,  -649.26771385, -1273.78633713]) # may vary\n\n", "; a = np.array((0.05, 0.04, 0.03))/12\n; np.pv(a, 10*12, -100, 15692.93)\narray([ -100.00067132,  -649.26771385, -1273.78633713]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.putmask", "code": "\nnumpy.putmask(a, mask, values)\u00b6", "description": "Changes elements of an array based on conditional and input values.\nSets a.flat[n] = values[n] for each n where mask.flat[n]==True.\nIf values is not the same size as a and mask then it will repeat.\nThis gives behavior different from a[mask] = values.\n\nParameters\n\naarray_likeTarget array.\n\nmaskarray_likeBoolean mask array. It has to be the same shape as a.\n\nvaluesarray_likeValues to put into a where mask is True. If values is smaller\nthan a it will be repeated.\n\n\n\n\n\nSee also\nplace, put, take, copyto\n\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; np.putmask(x, x&gt;2, x**2)\n&gt;&gt;&gt; x\narray([[ 0,  1,  2],\n       [ 9, 16, 25]])\n\n\nIf values is smaller than a it is repeated:\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.putmask(x, x&gt;1, [-33, -44])\n&gt;&gt;&gt; x\narray([  0,   1, -33, -44, -33])\n\n\n", "parameters": ["Parameters", "aarray_like", "maskarray_like", "valuesarray_like"], "returns": [], "examples": ["; x = np.arange(6).reshape(2, 3)\n; np.putmask(x, x&gt;2, x**2)\n; x\narray([[ 0,  1,  2],\n       [ 9, 16, 25]])\n\n", "; x = np.arange(6).reshape(2, 3)\n; np.putmask(x, x&gt;2, x**2)\n; x\narray([[ 0,  1,  2],\n       [ 9, 16, 25]])\n", "; x = np.arange(5)\n; np.putmask(x, x&gt;1, [-33, -44])\n; x\narray([  0,   1, -33, -44, -33])\n\n", "; x = np.arange(5)\n; np.putmask(x, x&gt;1, [-33, -44])\n; x\narray([  0,   1, -33, -44, -33])\n"]},
{"library": "numpy", "item_id": "numpy.put_along_axis", "code": "\nnumpy.put_along_axis(arr, indices, values, axis)[source]\u00b6", "description": "Put values into the destination array by matching 1d index and data slices.\nThis iterates over matching 1d slices oriented along the specified axis in\nthe index and data arrays, and uses the former to place values into the\nlatter. These slices can be different lengths.\nFunctions returning an index along an axis, like argsort and\nargpartition, produce suitable indices for this function.\n\nNew in version 1.15.0.\n\n\nParameters\n\narr: ndarray (Ni\u2026, M, Nk\u2026)Destination array.\n\nindices: ndarray (Ni\u2026, J, Nk\u2026)Indices to change along each 1d slice of arr. This must match the\ndimension of arr, but dimensions in Ni and Nj may be 1 to broadcast\nagainst arr.\n\nvalues: array_like (Ni\u2026, J, Nk\u2026)values to insert at those indices. Its shape and dimension are\nbroadcast to match that of indices.\n\naxis: intThe axis to take 1d slices along. If axis is None, the destination\narray is treated as if a flattened 1d view had been created of it.\n\n\n\n\n\nSee also\n\ntake_along_axisTake values from the input array by matching 1d index and data slices\n\n\n\nNotes\nThis is equivalent to (but faster than) the following use of ndindex and\ns_, which sets each of ii and kk to a tuple of indices:\nNi, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\nJ = indices.shape[axis]  # Need not equal M\n\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        a_1d       = a      [ii + s_[:,] + kk]\n        indices_1d = indices[ii + s_[:,] + kk]\n        values_1d  = values [ii + s_[:,] + kk]\n        for j in range(J):\n            a_1d[indices_1d[j]] = values_1d[j]\n\n\nEquivalently, eliminating the inner loop, the last two lines would be:\na_1d[indices_1d] = values_1d\n\n\nExamples\nFor this sample array\n&gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]])\n\n\nWe can replace the maximum values with:\n&gt;&gt;&gt; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n&gt;&gt;&gt; ai\narray([[1],\n       [0]])\n&gt;&gt;&gt; np.put_along_axis(a, ai, 99, axis=1)\n&gt;&gt;&gt; a\narray([[10, 99, 20],\n       [99, 40, 50]])\n\n\n", "parameters": ["Parameters", "arr: ndarray (Ni\u2026, M, Nk\u2026)", "indices: ndarray (Ni\u2026, J, Nk\u2026)", "values: array_like (Ni\u2026, J, Nk\u2026)", "axis: int"], "returns": [], "examples": ["; a = np.array([[10, 30, 20], [60, 40, 50]])\n\n", "; a = np.array([[10, 30, 20], [60, 40, 50]])\n", "; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai\narray([[1],\n       [0]])\n; np.put_along_axis(a, ai, 99, axis=1)\n; a\narray([[10, 99, 20],\n       [99, 40, 50]])\n\n", "; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai\narray([[1],\n       [0]])\n; np.put_along_axis(a, ai, 99, axis=1)\n; a\narray([[10, 99, 20],\n       [99, 40, 50]])\n"]},
{"library": "numpy", "item_id": "numpy.record.ptp", "code": "\nrecord.ptp()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.put", "code": "\nrecord.put()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.put", "code": "\nndarray.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.put", "code": "\nrecarray.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.put", "code": "\nmemmap.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.put", "code": "\nmatrix.put(indices, values, mode='raise')\u00b6", "description": "Set a.flat[n] = values[n] for all n in indices.\nRefer to numpy.put for full documentation.\n\nSee also\n\nnumpy.putequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.put", "code": "\nMaskType.put()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.put", "code": "\nMaskedArray.put(self, indices, values, mode='raise')[source]\u00b6", "description": "Set storage-indexed locations to corresponding values.\nSets self._data.flat[n] = values[n] for each n in indices.\nIf values is shorter than indices then it will repeat.\nIf values has some masked values, the initial mask is updated\nin consequence, else the corresponding values are unmasked.\n\nParameters\n\nindices1-D array_likeTarget indices, interpreted as integers.\n\nvaluesarray_likeValues to place in self._data copy at target indices.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices will behave.\n\u2018raise\u2019 : raise an error.\n\u2018wrap\u2019 : wrap around.\n\u2018clip\u2019 : clip to the range.\n\n\n\n\nNotes\nvalues can be a scalar or length 1 array.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.put([0,4,8],[10,20,30])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n\n&gt;&gt;&gt; x.put(4,999)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "indices1-D array_like", "valuesarray_like", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional"], "returns": [], "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.put([0,4,8],[10,20,30])\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.put([0,4,8],[10,20,30])\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 20, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n", "; x.put(4,999)\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n\n", "; x.put(4,999)\n; x\nmasked_array(\n  data=[[10, --, 3],\n        [--, 999, --],\n        [7, --, 30]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.recarray.ptp", "code": "\nrecarray.ptp(axis=None, out=None, keepdims=False)\u00b6", "description": "Peak to peak (maximum - minimum) value along a given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\n\nnumpy.ptpequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.ptp", "code": "\nndarray.ptp(axis=None, out=None, keepdims=False)\u00b6", "description": "Peak to peak (maximum - minimum) value along a given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\n\nnumpy.ptpequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.ptp", "code": "\nmemmap.ptp(axis=None, out=None, keepdims=False)\u00b6", "description": "Peak to peak (maximum - minimum) value along a given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\n\nnumpy.ptpequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.ptp", "code": "\nmatrix.ptp(self, axis=None, out=None)[source]\u00b6", "description": "Peak-to-peak (maximum - minimum) value along the given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\nnumpy.ptp\n\nNotes\nSame as ndarray.ptp, except, where that would return an ndarray object,\nthis returns a matrix object.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.ptp()\n11\n&gt;&gt;&gt; x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n&gt;&gt;&gt; x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.ptp()\n11\n; x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n; x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.ptp()\n11\n; x.ptp(0)\nmatrix([[8, 8, 8, 8]])\n; x.ptp(1)\nmatrix([[3],\n        [3],\n        [3]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.ptp", "code": "\nMaskType.ptp()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.ptp", "code": "\nMaskedArray.ptp(self, axis=None, out=None, fill_value=None, keepdims=False)[source]\u00b6", "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\nParameters\n\naxis{None, int}, optionalAxis along which to find the peaks.  If None (default) the\nflattened array is used.\n\nout{None, array_like}, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary.\n\nfill_value{var}, optionalValue used to fill in the masked values.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nptpndarray.A new array holding the result, unless out was\nspecified, in which case a reference to out is returned.\n\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "out{None, array_like}, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "ptpndarray."], "returns": "ptpndarray.A new array holding the result, unless out wasspecified, in which case a reference to out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.ptp", "code": "\nmasked_array.ptp(self, axis=None, out=None, fill_value=None, keepdims=False)[source]\u00b6", "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\nParameters\n\naxis{None, int}, optionalAxis along which to find the peaks.  If None (default) the\nflattened array is used.\n\nout{None, array_like}, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary.\n\nfill_value{var}, optionalValue used to fill in the masked values.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nptpndarray.A new array holding the result, unless out was\nspecified, in which case a reference to out is returned.\n\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "out{None, array_like}, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "ptpndarray."], "returns": "ptpndarray.A new array holding the result, unless out wasspecified, in which case a reference to out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.generic.ptp", "code": "\ngeneric.ptp()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.ptp", "code": "\nchararray.ptp(axis=None, out=None, keepdims=False)\u00b6", "description": "Peak to peak (maximum - minimum) value along a given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\n\nnumpy.ptpequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.ptp", "code": "\nchararray.ptp(axis=None, out=None, keepdims=False)\u00b6", "description": "Peak to peak (maximum - minimum) value along a given axis.\nRefer to numpy.ptp for full documentation.\n\nSee also\n\nnumpy.ptpequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.ptp", "code": "\nnumpy.ma.ptp(obj, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return (maximum - minimum) along the given dimension\n(i.e. peak-to-peak value).\n\nParameters\n\naxis{None, int}, optionalAxis along which to find the peaks.  If None (default) the\nflattened array is used.\n\nout{None, array_like}, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary.\n\nfill_value{var}, optionalValue used to fill in the masked values.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nptpndarray.A new array holding the result, unless out was\nspecified, in which case a reference to out is returned.\n\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "out{None, array_like}, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "ptpndarray."], "returns": "ptpndarray.A new array holding the result, unless out wasspecified, in which case a reference to out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.ptp", "code": "\nnumpy.ptp(a, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Range of values (maximum - minimum) along an axis.\nThe name of the function comes from the acronym for \u2018peak to peak\u2019.\n\nParameters\n\naarray_likeInput values.\n\naxisNone or int or tuple of ints, optionalAxis along which to find the peaks.  By default, flatten the\narray.  axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.15.0.\n\nIf this is a tuple of ints, a reduction is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\noutarray_likeAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type of the output values will be cast if necessary.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the ptp method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nptpndarrayA new array holding the result, unless out was\nspecified, in which case a reference to out is returned.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(4).reshape((2,2))\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n\n\n&gt;&gt;&gt; np.ptp(x, axis=0)\narray([2, 2])\n\n\n&gt;&gt;&gt; np.ptp(x, axis=1)\narray([1, 1])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "outarray_like", "keepdimsbool, optional", "Returns", "ptpndarray"], "returns": "ptpndarrayA new array holding the result, unless out wasspecified, in which case a reference to out is returned.", "examples": ["; x = np.arange(4).reshape((2,2))\n; x\narray([[0, 1],\n       [2, 3]])\n\n", "; x = np.arange(4).reshape((2,2))\n; x\narray([[0, 1],\n       [2, 3]])\n", "; np.ptp(x, axis=0)\narray([2, 2])\n\n", "; np.ptp(x, axis=0)\narray([2, 2])\n", "; np.ptp(x, axis=1)\narray([1, 1])\n\n", "; np.ptp(x, axis=1)\narray([1, 1])\n"]},
{"library": "numpy", "item_id": "numpy.promote_types", "code": "\nnumpy.promote_types(type1, type2)\u00b6", "description": "Returns the data type with the smallest size and smallest scalar\nkind to which both type1 and type2 may be safely cast.\nThe returned data type is always in native byte order.\nThis function is symmetric, but rarely associative.\n\nParameters\n\ntype1dtype or dtype specifierFirst data type.\n\ntype2dtype or dtype specifierSecond data type.\n\n\n\nReturns\n\noutdtypeThe promoted data type.\n\n\n\n\n\nSee also\nresult_type, dtype, can_cast\n\nNotes\n\nNew in version 1.6.0.\n\nStarting in NumPy 1.9, promote_types function now returns a valid string\nlength when given an integer or float dtype as one argument and a string\ndtype as another argument. Previously it always returned the input string\ndtype, even if it wasn\u2019t long enough to store the max integer/float value\nconverted to a string.\nExamples\n&gt;&gt;&gt; np.promote_types('f4', 'f8')\ndtype('float64')\n\n\n&gt;&gt;&gt; np.promote_types('i8', 'f4')\ndtype('float64')\n\n\n&gt;&gt;&gt; np.promote_types('&gt;i8', '&lt;c8')\ndtype('complex128')\n\n\n&gt;&gt;&gt; np.promote_types('i4', 'S8')\ndtype('S11')\n\n\nAn example of a non-associative case:\n&gt;&gt;&gt; p = np.promote_types\n&gt;&gt;&gt; p('S', p('i1', 'u1'))\ndtype('S6')\n&gt;&gt;&gt; p(p('S', 'i1'), 'u1')\ndtype('S4')\n\n\n", "parameters": ["Parameters", "type1dtype or dtype specifier", "type2dtype or dtype specifier", "Returns", "outdtype"], "returns": "outdtypeThe promoted data type.", "examples": ["; np.promote_types('f4', 'f8')\ndtype('float64')\n\n", "; np.promote_types('f4', 'f8')\ndtype('float64')\n", "; np.promote_types('i8', 'f4')\ndtype('float64')\n\n", "; np.promote_types('i8', 'f4')\ndtype('float64')\n", "; np.promote_types('&gt;i8', '&lt;c8')\ndtype('complex128')\n\n", "; np.promote_types('&gt;i8', '&lt;c8')\ndtype('complex128')\n", "; np.promote_types('i4', 'S8')\ndtype('S11')\n\n", "; np.promote_types('i4', 'S8')\ndtype('S11')\n", "; p = np.promote_types\n; p('S', p('i1', 'u1'))\ndtype('S6')\n; p(p('S', 'i1'), 'u1')\ndtype('S4')\n\n", "; p = np.promote_types\n; p('S', p('i1', 'u1'))\ndtype('S6')\n; p(p('S', 'i1'), 'u1')\ndtype('S4')\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.randint", "code": "\nRandomState.randint(low, high=None, size=None, dtype=int)\u00b6", "description": "Return random integers from low (inclusive) to high (exclusive).\nReturn random integers from the \u201cdiscrete uniform\u201d distribution of\nthe specified dtype in the \u201chalf-open\u201d interval [low, high). If\nhigh is None (the default), then results are from [0, low).\n\nNote\nNew code should use the integers method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlowint or array-like of intsLowest (signed) integers to be drawn from the distribution (unless\nhigh=None, in which case this parameter is one above the\nhighest such integer).\n\nhighint or array-like of ints, optionalIf provided, one above the largest (signed) integer to be drawn\nfrom the distribution (see above for behavior if high=None).\nIf array-like, must contain integer values\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result. Byteorder must be native.\nThe default value is int.\n\nNew in version 1.11.0.\n\n\n\n\nReturns\n\noutint or ndarray of intssize-shaped array of random integers from the appropriate\ndistribution, or a single such random int if size not provided.\n\n\n\n\n\nSee also\n\nrandom_integerssimilar to randint, only for the closed interval [low, high], and 1 is the lowest value if high is omitted.\n\nGenerator.integerswhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n&gt;&gt;&gt; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nGenerate a 2 x 4 array of ints between 0 and 4, inclusive:\n&gt;&gt;&gt; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n\n\nGenerate a 1 x 3 array with 3 different upper bounds\n&gt;&gt;&gt; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n\n\nGenerate a 1 by 3 array with 3 different lower bounds\n&gt;&gt;&gt; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n\n\nGenerate a 2 by 4 array using broadcasting with dtype of uint8\n&gt;&gt;&gt; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n\n\n", "parameters": ["Parameters", "lowint or array-like of ints", "highint or array-like of ints, optional", "sizeint or tuple of ints, optional", "dtypedtype, optional", "Returns", "outint or ndarray of ints"], "returns": "outint or ndarray of intssize-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.", "examples": ["; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n", "; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n", "; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n\n", "; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n", "; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n\n", "; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n", "; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n\n", "; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n", "; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n\n", "; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.rand", "code": "\nRandomState.rand(d0, d1, ..., dn)\u00b6", "description": "Random values in a given shape.\n\nNote\nThis is a convenience function for users porting code from Matlab,\nand wraps random_sample. That function takes a\ntuple to specify the size of the output, which is consistent with\nother NumPy functions like numpy.zeros and numpy.ones.\n\nCreate an array of the given shape and populate it with\nrandom samples from a uniform distribution\nover [0, 1).\n\nParameters\n\nd0, d1, \u2026, dnint, optionalThe dimensions of the returned array, must be non-negative.\nIf no argument is given a single Python float is returned.\n\n\n\nReturns\n\noutndarray, shape (d0, d1, ..., dn)Random values.\n\n\n\n\n\nSee also\nrandom\n\nExamples\n&gt;&gt;&gt; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n\n", "parameters": ["Parameters", "d0, d1, \u2026, dnint, optional", "Returns", "outndarray, shape (d0, d1, ..., dn)"], "returns": "outndarray, shape (d0, d1, ..., dn)Random values.", "examples": ["; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n", "; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n"]},
{"library": "numpy", "item_id": "numpy.random.rand", "code": "\nnumpy.random.rand(d0, d1, ..., dn)\u00b6", "description": "Random values in a given shape.\n\nNote\nThis is a convenience function for users porting code from Matlab,\nand wraps random_sample. That function takes a\ntuple to specify the size of the output, which is consistent with\nother NumPy functions like numpy.zeros and numpy.ones.\n\nCreate an array of the given shape and populate it with\nrandom samples from a uniform distribution\nover [0, 1).\n\nParameters\n\nd0, d1, \u2026, dnint, optionalThe dimensions of the returned array, must be non-negative.\nIf no argument is given a single Python float is returned.\n\n\n\nReturns\n\noutndarray, shape (d0, d1, ..., dn)Random values.\n\n\n\n\n\nSee also\nrandom\n\nExamples\n&gt;&gt;&gt; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n\n", "parameters": ["Parameters", "d0, d1, \u2026, dnint, optional", "Returns", "outndarray, shape (d0, d1, ..., dn)"], "returns": "outndarray, shape (d0, d1, ..., dn)Random values.", "examples": ["; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n\n", "; np.random.rand(3,2)\narray([[ 0.14022471,  0.96360618],  #random\n       [ 0.37601032,  0.25528411],  #random\n       [ 0.49313049,  0.94909878]]) #random\n"]},
{"library": "numpy", "item_id": "numpy.matlib.randn", "code": "\nnumpy.matlib.randn(*args)[source]\u00b6", "description": "Return a random matrix with data from the \u201cstandard normal\u201d distribution.\nrandn generates a matrix filled with random floats sampled from a\nunivariate \u201cnormal\u201d (Gaussian) distribution of mean 0 and variance 1.\n\nParameters\n\n*argsArgumentsShape of the output.\nIf given as N integers, each integer specifies the size of one\ndimension. If given as a tuple, this tuple gives the complete shape.\n\n\n\nReturns\n\nZmatrix of floatsA matrix of floating-point samples drawn from the standard normal\ndistribution.\n\n\n\n\n\nSee also\nrand, numpy.random.RandomState.randn\n\nNotes\nFor random samples from , use:\nsigma * np.matlib.randn(...) + mu\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.randn(1)\nmatrix([[-1.0856306]])\n&gt;&gt;&gt; np.matlib.randn(1, 2, 3)\nmatrix([[ 0.99734545,  0.2829785 , -1.50629471],\n        [-0.57860025,  1.65143654, -2.42667924]])\n\n\nTwo-by-four matrix of samples from :\n&gt;&gt;&gt; 2.5 * np.matlib.randn((2, 4)) + 3\nmatrix([[1.92771843, 6.16484065, 0.83314899, 1.30278462],\n        [2.76322758, 6.72847407, 1.40274501, 1.8900451 ]])\n\n\n", "parameters": ["Parameters", "*argsArguments", "Returns", "Zmatrix of floats"], "returns": "Zmatrix of floatsA matrix of floating-point samples drawn from the standard normaldistribution.", "examples": ["; np.random.seed(123)\n; import numpy.matlib\n; np.matlib.randn(1)\nmatrix([[-1.0856306]])\n; np.matlib.randn(1, 2, 3)\nmatrix([[ 0.99734545,  0.2829785 , -1.50629471],\n        [-0.57860025,  1.65143654, -2.42667924]])\n\n", "; np.random.seed(123)\n; import numpy.matlib\n; np.matlib.randn(1)\nmatrix([[-1.0856306]])\n; np.matlib.randn(1, 2, 3)\nmatrix([[ 0.99734545,  0.2829785 , -1.50629471],\n        [-0.57860025,  1.65143654, -2.42667924]])\n", "; 2.5 * np.matlib.randn((2, 4)) + 3\nmatrix([[1.92771843, 6.16484065, 0.83314899, 1.30278462],\n        [2.76322758, 6.72847407, 1.40274501, 1.8900451 ]])\n\n", "; 2.5 * np.matlib.randn((2, 4)) + 3\nmatrix([[1.92771843, 6.16484065, 0.83314899, 1.30278462],\n        [2.76322758, 6.72847407, 1.40274501, 1.8900451 ]])\n"]},
{"library": "numpy", "item_id": "numpy.random.randint", "code": "\nnumpy.random.randint(low, high=None, size=None, dtype=int)\u00b6", "description": "Return random integers from low (inclusive) to high (exclusive).\nReturn random integers from the \u201cdiscrete uniform\u201d distribution of\nthe specified dtype in the \u201chalf-open\u201d interval [low, high). If\nhigh is None (the default), then results are from [0, low).\n\nNote\nNew code should use the integers method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlowint or array-like of intsLowest (signed) integers to be drawn from the distribution (unless\nhigh=None, in which case this parameter is one above the\nhighest such integer).\n\nhighint or array-like of ints, optionalIf provided, one above the largest (signed) integer to be drawn\nfrom the distribution (see above for behavior if high=None).\nIf array-like, must contain integer values\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result. Byteorder must be native.\nThe default value is int.\n\nNew in version 1.11.0.\n\n\n\n\nReturns\n\noutint or ndarray of intssize-shaped array of random integers from the appropriate\ndistribution, or a single such random int if size not provided.\n\n\n\n\n\nSee also\n\nrandom_integerssimilar to randint, only for the closed interval [low, high], and 1 is the lowest value if high is omitted.\n\nGenerator.integerswhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n&gt;&gt;&gt; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nGenerate a 2 x 4 array of ints between 0 and 4, inclusive:\n&gt;&gt;&gt; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n\n\nGenerate a 1 x 3 array with 3 different upper bounds\n&gt;&gt;&gt; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n\n\nGenerate a 1 by 3 array with 3 different lower bounds\n&gt;&gt;&gt; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n\n\nGenerate a 2 by 4 array using broadcasting with dtype of uint8\n&gt;&gt;&gt; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n\n\n", "parameters": ["Parameters", "lowint or array-like of ints", "highint or array-like of ints, optional", "sizeint or tuple of ints, optional", "dtypedtype, optional", "Returns", "outint or ndarray of ints"], "returns": "outint or ndarray of intssize-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.", "examples": ["; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n", "; np.random.randint(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0]) # random\n; np.random.randint(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n", "; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n\n", "; np.random.randint(5, size=(2, 4))\narray([[4, 0, 2, 1], # random\n       [3, 2, 2, 0]])\n", "; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n\n", "; np.random.randint(1, [3, 5, 10])\narray([2, 2, 9]) # random\n", "; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n\n", "; np.random.randint([1, 5, 7], 10)\narray([9, 8, 7]) # random\n", "; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n\n", "; np.random.randint([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7], # random\n       [ 1, 16,  9, 12]], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.matlib.rand", "code": "\nnumpy.matlib.rand(*args)[source]\u00b6", "description": "Return a matrix of random values with given shape.\nCreate a matrix of the given shape and propagate it with\nrandom samples from a uniform distribution over [0, 1).\n\nParameters\n\n*argsArgumentsShape of the output.\nIf given as N integers, each integer specifies the size of one\ndimension.\nIf given as a tuple, this tuple gives the complete shape.\n\n\n\nReturns\n\noutndarrayThe matrix of random values with shape given by *args.\n\n\n\n\n\nSee also\nrandn, numpy.random.RandomState.rand\n\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.rand(2, 3)\nmatrix([[0.69646919, 0.28613933, 0.22685145],\n        [0.55131477, 0.71946897, 0.42310646]])\n&gt;&gt;&gt; np.matlib.rand((2, 3))\nmatrix([[0.9807642 , 0.68482974, 0.4809319 ],\n        [0.39211752, 0.34317802, 0.72904971]])\n\n\nIf the first argument is a tuple, other arguments are ignored:\n&gt;&gt;&gt; np.matlib.rand((2, 3), 4)\nmatrix([[0.43857224, 0.0596779 , 0.39804426],\n        [0.73799541, 0.18249173, 0.17545176]])\n\n\n", "parameters": ["Parameters", "*argsArguments", "Returns", "outndarray"], "returns": "outndarrayThe matrix of random values with shape given by *args.", "examples": ["; np.random.seed(123)\n; import numpy.matlib\n; np.matlib.rand(2, 3)\nmatrix([[0.69646919, 0.28613933, 0.22685145],\n        [0.55131477, 0.71946897, 0.42310646]])\n; np.matlib.rand((2, 3))\nmatrix([[0.9807642 , 0.68482974, 0.4809319 ],\n        [0.39211752, 0.34317802, 0.72904971]])\n\n", "; np.random.seed(123)\n; import numpy.matlib\n; np.matlib.rand(2, 3)\nmatrix([[0.69646919, 0.28613933, 0.22685145],\n        [0.55131477, 0.71946897, 0.42310646]])\n; np.matlib.rand((2, 3))\nmatrix([[0.9807642 , 0.68482974, 0.4809319 ],\n        [0.39211752, 0.34317802, 0.72904971]])\n", "; np.matlib.rand((2, 3), 4)\nmatrix([[0.43857224, 0.0596779 , 0.39804426],\n        [0.73799541, 0.18249173, 0.17545176]])\n\n", "; np.matlib.rand((2, 3), 4)\nmatrix([[0.43857224, 0.0596779 , 0.39804426],\n        [0.73799541, 0.18249173, 0.17545176]])\n"]},
{"library": "numpy", "item_id": "numpy.radians", "code": "\nnumpy.radians(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'radians'&gt;\u00b6", "description": "Convert angles from degrees to radians.\n\nParameters\n\nxarray_likeInput array in degrees.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding radian values.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\ndeg2radequivalent function\n\n\n\nExamples\nConvert a degree array to radians\n&gt;&gt;&gt; deg = np.arange(12.) * 30.\n&gt;&gt;&gt; np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n\n\n&gt;&gt;&gt; out = np.zeros((deg.shape))\n&gt;&gt;&gt; ret = np.radians(deg, out)\n&gt;&gt;&gt; ret is out\nTrue\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding radian values.This is a scalar if x is a scalar.", "examples": ["; deg = np.arange(12.) * 30.\n; np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n\n", "; deg = np.arange(12.) * 30.\n; np.radians(deg)\narray([ 0.        ,  0.52359878,  1.04719755,  1.57079633,  2.0943951 ,\n        2.61799388,  3.14159265,  3.66519143,  4.1887902 ,  4.71238898,\n        5.23598776,  5.75958653])\n", "; out = np.zeros((deg.shape))\n; ret = np.radians(deg, out)\n; ret is out\nTrue\n\n", "; out = np.zeros((deg.shape))\n; ret = np.radians(deg, out)\n; ret is out\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.rad2deg", "code": "\nnumpy.rad2deg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'rad2deg'&gt;\u00b6", "description": "Convert angles from radians to degrees.\n\nParameters\n\nxarray_likeAngle in radians.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding angle in degrees.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\ndeg2radConvert angles from degrees to radians.\n\nunwrapRemove large jumps in angle by wrapping.\n\n\n\nNotes\n\nNew in version 1.3.0.\n\nrad2deg(x) is 180 * x / pi.\nExamples\n&gt;&gt;&gt; np.rad2deg(np.pi/2)\n90.0\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding angle in degrees.This is a scalar if x is a scalar.", "examples": ["; np.rad2deg(np.pi/2)\n90.0\n\n", "; np.rad2deg(np.pi/2)\n90.0\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.reduceat", "code": "\nufunc.reduceat(a, indices, axis=0, dtype=None, out=None)\u00b6", "description": "Performs a (local) reduce with specified slices over a single axis.\nFor i in range(len(indices)), reduceat computes\nufunc.reduce(a[indices[i]:indices[i+1]]), which becomes the i-th\ngeneralized \u201crow\u201d parallel to axis in the final result (i.e., in a\n2-D array, for example, if axis = 0, it becomes the i-th row, but if\naxis = 1, it becomes the i-th column).  There are three exceptions to this:\n\nwhen i = len(indices) - 1 (so for the last index),\nindices[i+1] = a.shape[axis].\nif indices[i] &gt;= indices[i + 1], the i-th generalized \u201crow\u201d is\nsimply a[indices[i]].\nif indices[i] &gt;= len(a) or indices[i] &lt; 0, an error is raised.\n\nThe shape of the output depends on the size of indices, and may be\nlarger than a (this happens if len(indices) &gt; a.shape[axis]).\n\nParameters\n\naarray_likeThe array to act on.\n\nindicesarray_likePaired indices, comma separated (not colon), specifying slices to\nreduce.\n\naxisint, optionalThe axis along which to apply the reduceat.\n\ndtypedata-type code, optionalThe type used to represent the intermediate results. Defaults\nto the data type of the output array if this is provided, or\nthe data type of the input array if no output array is provided.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If not provided or None,\na freshly-allocated array is returned. For consistency with\nufunc.__call__, if given as a keyword, this may be wrapped in a\n1-element tuple.\n\nChanged in version 1.13.0: Tuples are allowed for keyword argument.\n\n\n\n\nReturns\n\nrndarrayThe reduced values. If out was supplied, r is a reference to\nout.\n\n\n\n\nNotes\nA descriptive example:\nIf a is 1-D, the function ufunc.accumulate(a) is the same as\nufunc.reduceat(a, indices)[::2] where indices is\nrange(len(array) - 1) with a zero placed\nin every other element:\nindices = zeros(2 * len(a) - 1), indices[1::2] = range(1, len(a)).\nDon\u2019t be fooled by this attribute\u2019s name: reduceat(a) is not\nnecessarily smaller than a.\nExamples\nTo take the running sum of four successive values:\n&gt;&gt;&gt; np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\narray([ 6, 10, 14, 18])\n\n\nA 2-D example:\n&gt;&gt;&gt; x = np.linspace(0, 15, 16).reshape(4,4)\n&gt;&gt;&gt; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n\n\n# reduce such that the result has the following five rows:\n# [row1 + row2 + row3]\n# [row4]\n# [row2]\n# [row3]\n# [row1 + row2 + row3 + row4]\n\n\n&gt;&gt;&gt; np.add.reduceat(x, [0, 3, 1, 2, 0])\narray([[12.,  15.,  18.,  21.],\n       [12.,  13.,  14.,  15.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [24.,  28.,  32.,  36.]])\n\n\n# reduce such that result has the following two columns:\n# [col1 * col2 * col3, col4]\n\n\n&gt;&gt;&gt; np.multiply.reduceat(x, [0, 3], 1)\narray([[   0.,     3.],\n       [ 120.,     7.],\n       [ 720.,    11.],\n       [2184.,    15.]])\n\n\n", "parameters": ["Parameters", "aarray_like", "indicesarray_like", "axisint, optional", "dtypedata-type code, optional", "outndarray, None, or tuple of ndarray and None, optional", "Returns", "rndarray"], "returns": "rndarrayThe reduced values. If out was supplied, r is a reference toout.", "examples": ["; np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\narray([ 6, 10, 14, 18])\n\n", "; np.add.reduceat(np.arange(8),[0,4, 1,5, 2,6, 3,7])[::2]\narray([ 6, 10, 14, 18])\n", "; x = np.linspace(0, 15, 16).reshape(4,4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n\n", "; x = np.linspace(0, 15, 16).reshape(4,4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n", "; np.add.reduceat(x, [0, 3, 1, 2, 0])\narray([[12.,  15.,  18.,  21.],\n       [12.,  13.,  14.,  15.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [24.,  28.,  32.,  36.]])\n\n", "; np.add.reduceat(x, [0, 3, 1, 2, 0])\narray([[12.,  15.,  18.,  21.],\n       [12.,  13.,  14.,  15.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [24.,  28.,  32.,  36.]])\n", "; np.multiply.reduceat(x, [0, 3], 1)\narray([[   0.,     3.],\n       [ 120.,     7.],\n       [ 720.,    11.],\n       [2184.,    15.]])\n\n", "; np.multiply.reduceat(x, [0, 3], 1)\narray([[   0.,     3.],\n       [ 120.,     7.],\n       [ 720.,    11.],\n       [2184.,    15.]])\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.reduce", "code": "\nufunc.reduce(a, axis=0, dtype=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Reduces a\u2019s dimension by one, by applying ufunc along one axis.\nLet .  Then\n =\nthe result of iterating j over , cumulatively applying\nufunc to each .\nFor a one-dimensional array, reduce produces results equivalent to:\nr = op.identity # op = ufunc\nfor i in range(len(A)):\n  r = op(r, A[i])\nreturn r\n\n\nFor example, add.reduce() is equivalent to sum().\n\nParameters\n\naarray_likeThe array to act on.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which a reduction is performed.\nThe default (axis = 0) is perform a reduction over the first\ndimension of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.7.0.\n\nIf this is None, a reduction is performed over all the axes.\nIf this is a tuple of ints, a reduction is performed on multiple\naxes, instead of a single axis or all the axes as before.\nFor operations which are either not commutative or not associative,\ndoing a reduction over multiple axes is not well-defined. The\nufuncs do not currently raise an exception in this case, but will\nlikely do so in the future.\n\ndtypedata-type code, optionalThe type used to represent the intermediate results. Defaults\nto the data-type of the output array if this is provided, or\nthe data-type of the input array if no output array is provided.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If not provided or None,\na freshly-allocated array is returned. For consistency with\nufunc.__call__, if given as a keyword, this may be wrapped in a\n1-element tuple.\n\nChanged in version 1.13.0: Tuples are allowed for keyword argument.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original arr.\n\nNew in version 1.7.0.\n\n\ninitialscalar, optionalThe value with which to start the reduction.\nIf the ufunc has no identity or the dtype is object, this defaults\nto None - otherwise it defaults to ufunc.identity.\nIf None is given, the first element of the reduction is used,\nand an error is thrown if the reduction is empty.\n\nNew in version 1.15.0.\n\n\nwherearray_like of bool, optionalA boolean array which is broadcasted to match the dimensions\nof a, and selects elements to include in the reduction. Note\nthat for ufuncs like minimum that do not have an identity\ndefined, one has to pass in also initial.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nrndarrayThe reduced array. If out was supplied, r is a reference to it.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.multiply.reduce([2,3,5])\n30\n\n\nA multi-dimensional array example:\n&gt;&gt;&gt; X = np.arange(8).reshape((2,2,2))\n&gt;&gt;&gt; X\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n&gt;&gt;&gt; np.add.reduce(X, 0)\narray([[ 4,  6],\n       [ 8, 10]])\n&gt;&gt;&gt; np.add.reduce(X) # confirm: default axis value is 0\narray([[ 4,  6],\n       [ 8, 10]])\n&gt;&gt;&gt; np.add.reduce(X, 1)\narray([[ 2,  4],\n       [10, 12]])\n&gt;&gt;&gt; np.add.reduce(X, 2)\narray([[ 1,  5],\n       [ 9, 13]])\n\n\nYou can use the initial keyword argument to initialize the reduction\nwith a different value, and where to select specific elements to include:\n&gt;&gt;&gt; np.add.reduce([10], initial=5)\n15\n&gt;&gt;&gt; np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10)\narray([14., 14.])\n&gt;&gt;&gt; a = np.array([10., np.nan, 10])\n&gt;&gt;&gt; np.add.reduce(a, where=~np.isnan(a))\n20.0\n\n\nAllows reductions of empty arrays where they would normally fail, i.e.\nfor ufuncs without an identity.\n&gt;&gt;&gt; np.minimum.reduce([], initial=np.inf)\ninf\n&gt;&gt;&gt; np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False])\narray([ 1., 10.])\n&gt;&gt;&gt; np.minimum.reduce([])\nTraceback (most recent call last):\n    ...\nValueError: zero-size array to reduction operation minimum which has no identity\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type code, optional", "outndarray, None, or tuple of ndarray and None, optional", "keepdimsbool, optional", "initialscalar, optional", "wherearray_like of bool, optional", "Returns", "rndarray"], "returns": "rndarrayThe reduced array. If out was supplied, r is a reference to it.", "examples": ["; np.multiply.reduce([2,3,5])\n30\n\n", "; np.multiply.reduce([2,3,5])\n30\n", "; X = np.arange(8).reshape((2,2,2))\n; X\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; np.add.reduce(X, 0)\narray([[ 4,  6],\n       [ 8, 10]])\n; np.add.reduce(X) # confirm: default axis value is 0\narray([[ 4,  6],\n       [ 8, 10]])\n; np.add.reduce(X, 1)\narray([[ 2,  4],\n       [10, 12]])\n; np.add.reduce(X, 2)\narray([[ 1,  5],\n       [ 9, 13]])\n\n", "; X = np.arange(8).reshape((2,2,2))\n; X\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; np.add.reduce(X, 0)\narray([[ 4,  6],\n       [ 8, 10]])\n; np.add.reduce(X) # confirm: default axis value is 0\narray([[ 4,  6],\n       [ 8, 10]])\n; np.add.reduce(X, 1)\narray([[ 2,  4],\n       [10, 12]])\n; np.add.reduce(X, 2)\narray([[ 1,  5],\n       [ 9, 13]])\n", "; np.add.reduce([10], initial=5)\n15\n; np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10)\narray([14., 14.])\n; a = np.array([10., np.nan, 10])\n; np.add.reduce(a, where=~np.isnan(a))\n20.0\n\n", "; np.add.reduce([10], initial=5)\n15\n; np.add.reduce(np.ones((2, 2, 2)), axis=(0, 2), initial=10)\narray([14., 14.])\n; a = np.array([10., np.nan, 10])\n; np.add.reduce(a, where=~np.isnan(a))\n20.0\n", "; np.minimum.reduce([], initial=np.inf)\ninf\n; np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False])\narray([ 1., 10.])\n; np.minimum.reduce([])\nTraceback (most recent call last):\n    ...\nValueError: zero-size array to reduction operation minimum which has no identity\n\n", "; np.minimum.reduce([], initial=np.inf)\ninf\n; np.minimum.reduce([[1., 2.], [3., 4.]], initial=10., where=[True, False])\narray([ 1., 10.])\n; np.minimum.reduce([])\nTraceback (most recent call last):\n    ...\nValueError: zero-size array to reduction operation minimum which has no identity\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.recordmask", "code": "\nproperty masked_array.recordmask\u00b6", "description": "Get or set the mask of the array if it has no named fields. For\nstructured arrays, returns a ndarray of booleans where entries are\nTrue if all the fields are masked, False otherwise:\n&gt;&gt;&gt; x = np.ma.array([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)],\n...         mask=[(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)],\n...        dtype=[('a', int), ('b', int)])\n&gt;&gt;&gt; x.recordmask\narray([False, False,  True, False, False])\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.suppress_warnings.record", "code": "\nsuppress_warnings.record(self, category=&lt;class 'Warning'&gt;, message='', module=None)[source]\u00b6", "description": "Append a new recording filter or apply it if the state is entered.\nAll warnings matching will be appended to the log attribute.\n\nParameters\n\ncategoryclass, optionalWarning class to filter\n\nmessagestring, optionalRegular expression matching the warning message.\n\nmodulemodule, optionalModule to filter for. Note that the module (and its file)\nmust match exactly and cannot be a submodule. This may make\nit unreliable for external modules.\n\n\n\nReturns\n\nloglistA list which will be filled with all matched warnings.\n\n\n\n\nNotes\nWhen added within a context, filters are only added inside\nthe context and will be forgotten when the context is exited.\n", "parameters": ["Parameters", "categoryclass, optional", "messagestring, optional", "modulemodule, optional", "Returns", "loglist"], "returns": "loglistA list which will be filled with all matched warnings.", "examples": []},
{"library": "numpy", "item_id": "numpy.record", "code": "\nclass numpy.record[source]\u00b6", "description": "A data-type scalar that allows field access as attribute lookup.\n\nAttributes\n\nTtranspose\n\nbasebase object\n\ndatapointer to start of data\n\ndtypedtype object\n\nflagsinteger value of flags\n\nflata 1-d view of scalar\n\nimagimaginary part of scalar\n\nitemsizelength of one element in bytes\n\nnbyteslength of item in bytes\n\nndimnumber of array dimensions\n\nrealreal part of scalar\n\nshapetuple of array dimensions\n\nsizenumber of elements in the gentype\n\nstridestuple of bytes steps in each dimension\n\n\n\n\nMethods\n\n\n\n\n\n\nall()\nNot implemented (virtual attribute)\n\nany()\nNot implemented (virtual attribute)\n\nargmax()\nNot implemented (virtual attribute)\n\nargmin()\nNot implemented (virtual attribute)\n\nargsort()\nNot implemented (virtual attribute)\n\nastype()\nNot implemented (virtual attribute)\n\nbyteswap()\nNot implemented (virtual attribute)\n\nchoose()\nNot implemented (virtual attribute)\n\nclip()\nNot implemented (virtual attribute)\n\ncompress()\nNot implemented (virtual attribute)\n\nconjugate()\nNot implemented (virtual attribute)\n\ncopy()\nNot implemented (virtual attribute)\n\ncumprod()\nNot implemented (virtual attribute)\n\ncumsum()\nNot implemented (virtual attribute)\n\ndiagonal()\nNot implemented (virtual attribute)\n\ndump()\nNot implemented (virtual attribute)\n\ndumps()\nNot implemented (virtual attribute)\n\nfill()\nNot implemented (virtual attribute)\n\nflatten()\nNot implemented (virtual attribute)\n\ngetfield()\nNot implemented (virtual attribute)\n\nitem()\nNot implemented (virtual attribute)\n\nitemset()\nNot implemented (virtual attribute)\n\nmax()\nNot implemented (virtual attribute)\n\nmean()\nNot implemented (virtual attribute)\n\nmin()\nNot implemented (virtual attribute)\n\nnewbyteorder([new_order])\nReturn a new dtype with a different byte order.\n\nnonzero()\nNot implemented (virtual attribute)\n\npprint(self)\nPretty-print all fields.\n\nprod()\nNot implemented (virtual attribute)\n\nptp()\nNot implemented (virtual attribute)\n\nput()\nNot implemented (virtual attribute)\n\nravel()\nNot implemented (virtual attribute)\n\nrepeat()\nNot implemented (virtual attribute)\n\nreshape()\nNot implemented (virtual attribute)\n\nresize()\nNot implemented (virtual attribute)\n\nround()\nNot implemented (virtual attribute)\n\nsearchsorted()\nNot implemented (virtual attribute)\n\nsetfield()\nNot implemented (virtual attribute)\n\nsetflags()\nNot implemented (virtual attribute)\n\nsort()\nNot implemented (virtual attribute)\n\nsqueeze()\nNot implemented (virtual attribute)\n\nstd()\nNot implemented (virtual attribute)\n\nsum()\nNot implemented (virtual attribute)\n\nswapaxes()\nNot implemented (virtual attribute)\n\ntake()\nNot implemented (virtual attribute)\n\ntofile()\nNot implemented (virtual attribute)\n\ntolist()\nNot implemented (virtual attribute)\n\ntostring()\nNot implemented (virtual attribute)\n\ntrace()\nNot implemented (virtual attribute)\n\ntranspose()\nNot implemented (virtual attribute)\n\nvar()\nNot implemented (virtual attribute)\n\nview()\nNot implemented (virtual attribute)\n\n\n\n\n\n\n\n\n\nconj\n\n\ntobytes\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.reciprocal", "code": "\nnumpy.reciprocal(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'reciprocal'&gt;\u00b6", "description": "Return the reciprocal of the argument, element-wise.\nCalculates 1/x.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayReturn array.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\n\nNote\nThis function is not designed to work with integers.\n\nFor integer arguments with absolute value larger than 1 the result is\nalways zero because of the way Python handles integer division.  For\ninteger zero the result is an overflow.\nExamples\n&gt;&gt;&gt; np.reciprocal(2.)\n0.5\n&gt;&gt;&gt; np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayReturn array.This is a scalar if x is a scalar.", "examples": ["; np.reciprocal(2.)\n0.5\n; np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])\n\n", "; np.reciprocal(2.)\n0.5\n; np.reciprocal([1, 2., 3.33])\narray([ 1.       ,  0.5      ,  0.3003003])\n"]},
{"library": "numpy", "item_id": "numpy.recarray", "code": "\nclass numpy.recarray[source]\u00b6", "description": "Construct an ndarray that allows field access using attributes.\nArrays may have a data-types containing fields, analogous\nto columns in a spread sheet.  An example is [(x, int), (y, float)],\nwhere each entry in the array is a pair of (int, float).  Normally,\nthese attributes are accessed using dictionary lookups such as arr['x']\nand arr['y'].  Record arrays allow the fields to be accessed as members\nof the array, using arr.x and arr.y.\n\nParameters\n\nshapetupleShape of output array.\n\ndtypedata-type, optionalThe desired data-type.  By default, the data-type is determined\nfrom formats, names, titles, aligned and byteorder.\n\nformatslist of data-types, optionalA list containing the data-types for the different columns, e.g.\n['i4', 'f8', 'i4'].  formats does not support the new\nconvention of using types directly, i.e. (int, float, int).\nNote that formats must be a list, not a tuple.\nGiven that formats is somewhat limited, we recommend specifying\ndtype instead.\n\nnamestuple of str, optionalThe name of each column, e.g. ('x', 'y', 'z').\n\nbufbuffer, optionalBy default, a new array is created of the given shape and data-type.\nIf buf is specified and is an object exposing the buffer interface,\nthe array will use the memory from the existing buffer.  In this case,\nthe offset and strides keywords are available.\n\n\n\nReturns\n\nrecrecarrayEmpty array of the given shape and type.\n\n\n\nOther Parameters\n\ntitlestuple of str, optionalAliases for column names.  For example, if names were\n('x', 'y', 'z') and titles is\n('x_coordinate', 'y_coordinate', 'z_coordinate'), then\narr['x'] is equivalent to both arr.x and arr.x_coordinate.\n\nbyteorder{\u2018&lt;\u2019, \u2018&gt;\u2019, \u2018=\u2019}, optionalByte-order for all fields.\n\nalignedbool, optionalAlign the fields in memory as the C-compiler would.\n\nstridestuple of ints, optionalBuffer (buf) is interpreted according to these strides (strides\ndefine how many bytes each array element, row, column, etc.\noccupy in memory).\n\noffsetint, optionalStart reading buffer (buf) from this offset onwards.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalRow-major (C-style) or column-major (Fortran-style) order.\n\n\n\n\n\nSee also\n\nrec.fromrecordsConstruct a record array from data.\n\nrecordfundamental data-type for recarray.\n\nformat_parserdetermine a data-type from formats, names, titles.\n\n\n\nNotes\nThis constructor can be compared to empty: it creates a new record\narray but does not fill it with data.  To create a record array from data,\nuse one of the following methods:\n\nCreate a standard ndarray and convert it to a record array,\nusing arr.view(np.recarray)\nUse the buf keyword.\nUse np.rec.fromrecords.\n\nExamples\nCreate an array with two fields, x and y:\n&gt;&gt;&gt; x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n&gt;&gt;&gt; x\narray([(1., 2), (3., 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n\n\n&gt;&gt;&gt; x['x']\narray([1., 3.])\n\n\nView the array as a record array:\n&gt;&gt;&gt; x = x.view(np.recarray)\n\n\n&gt;&gt;&gt; x.x\narray([1., 3.])\n\n\n&gt;&gt;&gt; x.y\narray([2, 4])\n\n\nCreate a new, empty record array:\n&gt;&gt;&gt; np.recarray((2,),\n... dtype=[('x', int), ('y', float), ('z', int)]) \nrec.array([(-1073741821, 1.2249118382103472e-301, 24547520),\n       (3471280, 1.2134086255804012e-316, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;f8'), ('z', '&lt;i4')])\n\n\n\nAttributes\n\nTThe transposed array.\n\nbaseBase object if memory is from some other object.\n\nctypesAn object to simplify the interaction of the array with the ctypes module.\n\ndataPython buffer object pointing to the start of the array\u2019s data.\n\ndtypeData-type of the array\u2019s elements.\n\nflagsInformation about the memory layout of the array.\n\nflatA 1-D iterator over the array.\n\nimagThe imaginary part of the array.\n\nitemsizeLength of one array element in bytes.\n\nnbytesTotal bytes consumed by the elements of the array.\n\nndimNumber of array dimensions.\n\nrealThe real part of the array.\n\nshapeTuple of array dimensions.\n\nsizeNumber of elements in the array.\n\nstridesTuple of bytes to step in each dimension when traversing an array.\n\n\n\n\nMethods\n\n\n\n\n\n\nall([axis,\u00a0out,\u00a0keepdims])\nReturns True if all elements evaluate to True.\n\nany([axis,\u00a0out,\u00a0keepdims])\nReturns True if any of the elements of a evaluate to True.\n\nargmax([axis,\u00a0out])\nReturn indices of the maximum values along the given axis.\n\nargmin([axis,\u00a0out])\nReturn indices of the minimum values along the given axis of a.\n\nargpartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nReturns the indices that would partition this array.\n\nargsort([axis,\u00a0kind,\u00a0order])\nReturns the indices that would sort this array.\n\nastype(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])\nCopy of the array, cast to a specified type.\n\nbyteswap([inplace])\nSwap the bytes of the array elements\n\nchoose(choices[,\u00a0out,\u00a0mode])\nUse an index array to construct a new array from a set of choices.\n\nclip([min,\u00a0max,\u00a0out])\nReturn an array whose values are limited to [min, max].\n\ncompress(condition[,\u00a0axis,\u00a0out])\nReturn selected slices of this array along given axis.\n\nconj()\nComplex-conjugate all elements.\n\nconjugate()\nReturn the complex conjugate, element-wise.\n\ncopy([order])\nReturn a copy of the array.\n\ncumprod([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative product of the elements along the given axis.\n\ncumsum([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative sum of the elements along the given axis.\n\ndiagonal([offset,\u00a0axis1,\u00a0axis2])\nReturn specified diagonals.\n\ndot(b[,\u00a0out])\nDot product of two arrays.\n\ndump(file)\nDump a pickle of the array to the specified file.\n\ndumps()\nReturns the pickle of the array as a string.\n\nfill(value)\nFill the array with a scalar value.\n\nflatten([order])\nReturn a copy of the array collapsed into one dimension.\n\ngetfield(dtype[,\u00a0offset])\nReturns a field of the given array as a certain type.\n\nitem(*args)\nCopy an element of an array to a standard Python scalar and return it.\n\nitemset(*args)\nInsert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\n\nmax([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the maximum along a given axis.\n\nmean([axis,\u00a0dtype,\u00a0out,\u00a0keepdims])\nReturns the average of the array elements along given axis.\n\nmin([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the minimum along a given axis.\n\nnewbyteorder([new_order])\nReturn the array with the same data viewed with a different byte order.\n\nnonzero()\nReturn the indices of the elements that are non-zero.\n\npartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nRearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.\n\nprod([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0\u2026])\nReturn the product of the array elements over the given axis\n\nptp([axis,\u00a0out,\u00a0keepdims])\nPeak to peak (maximum - minimum) value along a given axis.\n\nput(indices,\u00a0values[,\u00a0mode])\nSet a.flat[n] = values[n] for all n in indices.\n\nravel([order])\nReturn a flattened array.\n\nrepeat(repeats[,\u00a0axis])\nRepeat elements of an array.\n\nreshape(shape[,\u00a0order])\nReturns an array containing the same data with a new shape.\n\nresize(new_shape[,\u00a0refcheck])\nChange shape and size of array in-place.\n\nround([decimals,\u00a0out])\nReturn a with each element rounded to the given number of decimals.\n\nsearchsorted(v[,\u00a0side,\u00a0sorter])\nFind indices where elements of v should be inserted in a to maintain order.\n\nsetfield(val,\u00a0dtype[,\u00a0offset])\nPut a value into a specified place in a field defined by a data-type.\n\nsetflags([write,\u00a0align,\u00a0uic])\nSet array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.\n\nsort([axis,\u00a0kind,\u00a0order])\nSort an array in-place.\n\nsqueeze([axis])\nRemove single-dimensional entries from the shape of a.\n\nstd([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])\nReturns the standard deviation of the array elements along given axis.\n\nsum([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the sum of the array elements over the given axis.\n\nswapaxes(axis1,\u00a0axis2)\nReturn a view of the array with axis1 and axis2 interchanged.\n\ntake(indices[,\u00a0axis,\u00a0out,\u00a0mode])\nReturn an array formed from the elements of a at the given indices.\n\ntobytes([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntofile(fid[,\u00a0sep,\u00a0format])\nWrite array to a file as text or binary (default).\n\ntolist()\nReturn the array as an a.ndim-levels deep nested list of Python scalars.\n\ntostring([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntrace([offset,\u00a0axis1,\u00a0axis2,\u00a0dtype,\u00a0out])\nReturn the sum along diagonals of the array.\n\ntranspose(*axes)\nReturns a view of the array with axes transposed.\n\nvar([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])\nReturns the variance of the array elements, along given axis.\n\nview([dtype,\u00a0type])\nNew view of array with the same data.\n\n\n\n\n\n\n\n\n\nfield\n\n\n\n\n", "parameters": ["Parameters", "shapetuple", "dtypedata-type, optional", "formatslist of data-types, optional", "namestuple of str, optional", "bufbuffer, optional", "Returns", "recrecarray", "Other Parameters", "titlestuple of str, optional", "byteorder{\u2018&lt;\u2019, \u2018&gt;\u2019, \u2018=\u2019}, optional", "alignedbool, optional", "stridestuple of ints, optional", "offsetint, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Attributes", "T", "base", "ctypes", "data", "dtype", "flags", "flat", "imag", "itemsize", "nbytes", "ndim", "real", "shape", "size", "strides"], "returns": "recrecarrayEmpty array of the given shape and type.", "examples": ["; x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n; x\narray([(1., 2), (3., 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n\n", "; x = np.array([(1.0, 2), (3.0, 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n; x\narray([(1., 2), (3., 4)], dtype=[('x', '&lt;f8'), ('y', '&lt;i8')])\n", "; x['x']\narray([1., 3.])\n\n", "; x['x']\narray([1., 3.])\n", "; x = x.view(np.recarray)\n\n", "; x = x.view(np.recarray)\n", "; x.x\narray([1., 3.])\n\n", "; x.x\narray([1., 3.])\n", "; x.y\narray([2, 4])\n\n", "; x.y\narray([2, 4])\n", "; np.recarray((2,),\n... dtype=[('x', int), ('y', float), ('z', int)]) \nrec.array([(-1073741821, 1.2249118382103472e-301, 24547520),\n       (3471280, 1.2134086255804012e-316, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;f8'), ('z', '&lt;i4')])\n\n", "; np.recarray((2,),\n... dtype=[('x', int), ('y', float), ('z', int)]) \nrec.array([(-1073741821, 1.2249118382103472e-301, 24547520),\n       (3471280, 1.2134086255804012e-316, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;f8'), ('z', '&lt;i4')])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.rfind", "code": "\nchararray.rfind(self, sub, start=0, end=None)\u00b6", "description": "For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].\n\nSee also\nchar.rfind\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.shrink_mask", "code": "\nmasked_array.shrink_mask(self)[source]\u00b6", "description": "Reduce a mask to nomask when possible.\n\nParameters\n\nNone\n\n\nReturns\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n&gt;&gt;&gt; x.mask\narray([[False, False],\n       [False, False]])\n&gt;&gt;&gt; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n&gt;&gt;&gt; x.mask\nFalse\n\n\n", "parameters": ["Parameters", "None", "Returns", "None"], "returns": "None", "examples": ["; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n; x.mask\narray([[False, False],\n       [False, False]])\n; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; x.mask\nFalse\n\n", "; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n; x.mask\narray([[False, False],\n       [False, False]])\n; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; x.mask\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.record.searchsorted", "code": "\nrecord.searchsorted()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.searchsorted", "code": "\nrecarray.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.searchsorted", "code": "\nndarray.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.sharedmask", "code": "\nproperty masked_array.sharedmask\u00b6", "description": "Share status of the mask (read-only).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.shares_memory", "code": "\nnumpy.shares_memory(a, b, max_work=None)\u00b6", "description": "Determine if two arrays share memory\n\nParameters\n\na, bndarrayInput arrays\n\nmax_workint, optionalEffort to spend on solving the overlap problem (maximum number\nof candidate solutions to consider). The following special\nvalues are recognized:\n\nmax_work=MAY_SHARE_EXACT  (default)The problem is solved exactly. In this case, the function returns\nTrue only if there is an element shared between the arrays.\n\nmax_work=MAY_SHARE_BOUNDSOnly the memory bounds of a and b are checked.\n\n\n\n\n\nReturns\n\noutbool\n\n\nRaises\n\nnumpy.TooHardErrorExceeded max_work.\n\n\n\n\n\nSee also\nmay_share_memory\n\nExamples\n&gt;&gt;&gt; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n\n\n", "parameters": ["Parameters", "a, bndarray", "max_workint, optional", "max_work=MAY_SHARE_EXACT  (default)", "max_work=MAY_SHARE_BOUNDS", "Returns", "outbool", "Raises", "numpy.TooHardError"], "returns": "outbool", "examples": ["; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n\n", "; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.shape", "code": "\nproperty MaskedArray.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.square", "code": "\nnumpy.square(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'square'&gt;\u00b6", "description": "Return the element-wise square of the input.\n\nParameters\n\nxarray_likeInput data.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarElement-wise x*x, of the same shape and dtype as x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nnumpy.linalg.matrix_power, sqrt, power\n\nExamples\n&gt;&gt;&gt; np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarElement-wise x*x, of the same shape and dtype as x.This is a scalar if x is a scalar.", "examples": ["; np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])\n\n", "; np.square([-1j, 1])\narray([-1.-0.j,  1.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.strides", "code": "\nndarray.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.memmap.strides", "code": "\nmemmap.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.matrix.strides", "code": "\nmatrix.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.take", "code": "\nndarray.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.take", "code": "\nmemmap.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.take", "code": "\nmatrix.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.take", "code": "\nMaskType.take()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.trace", "code": "\ngeneric.trace()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.typename", "code": "\nnumpy.typename(char)[source]\u00b6", "description": "Return a description for the given data type code.\n\nParameters\n\ncharstrData type code.\n\n\n\nReturns\n\noutstrDescription of the input data type code.\n\n\n\n\n\nSee also\ndtype, typecodes\n\nExamples\n&gt;&gt;&gt; typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n&gt;&gt;&gt; for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer\n\n\n", "parameters": ["Parameters", "charstr", "Returns", "outstr"], "returns": "outstrDescription of the input data type code.", "examples": ["; typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n; for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer\n\n", "; typechars = ['S1', '?', 'B', 'D', 'G', 'F', 'I', 'H', 'L', 'O', 'Q',\n...              'S', 'U', 'V', 'b', 'd', 'g', 'f', 'i', 'h', 'l', 'q']\n; for typechar in typechars:\n...     print(typechar, ' : ', np.typename(typechar))\n...\nS1  :  character\n?  :  bool\nB  :  unsigned char\nD  :  complex double precision\nG  :  complex long double precision\nF  :  complex single precision\nI  :  unsigned integer\nH  :  unsigned short\nL  :  unsigned long integer\nO  :  object\nQ  :  unsigned long long integer\nS  :  string\nU  :  unicode\nV  :  void\nb  :  signed char\nd  :  double precision\ng  :  long precision\nf  :  single precision\ni  :  integer\nh  :  short\nl  :  long integer\nq  :  long long integer\n"]},
{"library": "numpy", "item_id": "numpy.dtype.type", "code": "\ndtype.type\u00b6", "description": "The type object used to instantiate a scalar of this data-type.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.truncate", "code": "\nPolynomial.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.truncate", "code": "\nLegendre.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.ufunc.types", "code": "\nufunc.types\u00b6", "description": "Returns a list with types grouped input-&gt;output.\nData attribute listing the data-type \u201cDomain-Range\u201d groupings the ufunc can\ndeliver. The data-types are given using the character codes.\n\nSee also\nnumpy.ufunc.ntypes\n\nExamples\n&gt;&gt;&gt; np.add.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n\n\n&gt;&gt;&gt; np.multiply.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n\n\n&gt;&gt;&gt; np.power.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D', 'GG-&gt;G',\n'OO-&gt;O']\n\n\n&gt;&gt;&gt; np.exp.types\n['f-&gt;f', 'd-&gt;d', 'g-&gt;g', 'F-&gt;F', 'D-&gt;D', 'G-&gt;G', 'O-&gt;O']\n\n\n&gt;&gt;&gt; np.remainder.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'OO-&gt;O']\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n\n", "; np.add.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n", "; np.multiply.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n\n", "; np.multiply.types\n['??-&gt;?', 'bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l',\n'LL-&gt;L', 'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D',\n'GG-&gt;G', 'OO-&gt;O']\n", "; np.power.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D', 'GG-&gt;G',\n'OO-&gt;O']\n\n", "; np.power.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'FF-&gt;F', 'DD-&gt;D', 'GG-&gt;G',\n'OO-&gt;O']\n", "; np.exp.types\n['f-&gt;f', 'd-&gt;d', 'g-&gt;g', 'F-&gt;F', 'D-&gt;D', 'G-&gt;G', 'O-&gt;O']\n\n", "; np.exp.types\n['f-&gt;f', 'd-&gt;d', 'g-&gt;g', 'F-&gt;F', 'D-&gt;D', 'G-&gt;G', 'O-&gt;O']\n", "; np.remainder.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'OO-&gt;O']\n\n", "; np.remainder.types\n['bb-&gt;b', 'BB-&gt;B', 'hh-&gt;h', 'HH-&gt;H', 'ii-&gt;i', 'II-&gt;I', 'll-&gt;l', 'LL-&gt;L',\n'qq-&gt;q', 'QQ-&gt;Q', 'ff-&gt;f', 'dd-&gt;d', 'gg-&gt;g', 'OO-&gt;O']\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.weibull", "code": "\nGenerator.weibull(a, size=None)\u00b6", "description": "Draw samples from a Weibull distribution.\nDraw samples from a 1-parameter Weibull distribution with the given\nshape parameter a.\n\n\nHere, U is drawn from the uniform distribution over (0,1].\nThe more common 2-parameter Weibull, including a scale parameter\n is just .\n\nParameters\n\nafloat or array_like of floatsShape parameter of the distribution.  Must be nonnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Weibull distribution.\n\n\n\n\n\nSee also\nscipy.stats.weibull_max, scipy.stats.weibull_min, scipy.stats.genextreme, gumbel\n\nNotes\nThe Weibull (or Type III asymptotic extreme value distribution\nfor smallest values, SEV Type III, or Rosin-Rammler\ndistribution) is one of a class of Generalized Extreme Value\n(GEV) distributions used in modeling extreme value problems.\nThis class includes the Gumbel and Frechet distributions.\nThe probability density for the Weibull distribution is\n\n\nwhere  is the shape and  the scale.\nThe function has its peak (the mode) at\n.\nWhen a = 1, the Weibull distribution reduces to the exponential\ndistribution.\nReferences\n\n1\nWaloddi Weibull, Royal Technical University, Stockholm,\n1939 \u201cA Statistical Theory Of The Strength Of Materials\u201d,\nIngeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\nGeneralstabens Litografiska Anstalts Forlag, Stockholm.\n\n2\nWaloddi Weibull, \u201cA Statistical Distribution Function of\nWide Applicability\u201d, Journal Of Applied Mechanics ASME Paper\n1951.\n\n3\nWikipedia, \u201cWeibull distribution\u201d,\nhttps://en.wikipedia.org/wiki/Weibull_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; s = rng.weibull(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n\n&gt;&gt;&gt; count, bins, ignored = plt.hist(rng.weibull(5.,1000))\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; scale = count.max()/weib(x, 1., 5.).max()\n&gt;&gt;&gt; plt.plot(x, weib(x, 1., 5.)*scale)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Weibull distribution.", "examples": ["; rng = np.random.default_rng()\n; a = 5. # shape\n; s = rng.weibull(a, 1000)\n\n", "; rng = np.random.default_rng()\n; a = 5. # shape\n; s = rng.weibull(a, 1000)\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n", "; count, bins, ignored = plt.hist(rng.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n\n", "; count, bins, ignored = plt.hist(rng.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.busdaycalendar.weekmask", "code": "\nbusdaycalendar.weekmask\u00b6", "description": "A copy of the seven-element boolean mask indicating valid days.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.zipf", "code": "\nRandomState.zipf(a, size=None)\u00b6", "description": "Draw samples from a Zipf distribution.\nSamples are drawn from a Zipf distribution with specified parameter\na &gt; 1.\nThe Zipf distribution (also known as the zeta distribution) is a\ncontinuous probability distribution that satisfies Zipf\u2019s law: the\nfrequency of an item is inversely proportional to its rank in a\nfrequency table.\n\nNote\nNew code should use the zipf method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsDistribution parameter. Must be greater than 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar. Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Zipf distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.zipfprobability density function, distribution, or cumulative density function, etc.\n\nGenerator.zipfwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Zipf distribution is\n\n\nwhere  is the Riemann Zeta function.\nIt is named for the American linguist George Kingsley Zipf, who noted\nthat the frequency of any word in a sample of a language is inversely\nproportional to its rank in the frequency table.\nReferences\n\n1\nZipf, G. K., \u201cSelected Studies of the Principle of Relative\nFrequency in Language,\u201d Cambridge, MA: Harvard Univ. Press,\n1932.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 2. # parameter\n&gt;&gt;&gt; s = np.random.zipf(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy import special  \n\n\nTruncate s values at 50 so plot is interesting:\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n&gt;&gt;&gt; x = np.arange(1., 50.)\n&gt;&gt;&gt; y = x**(-a) / special.zetac(a)  \n&gt;&gt;&gt; plt.plot(x, y/max(y), linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Zipf distribution.", "examples": ["; a = 2. # parameter\n; s = np.random.zipf(a, 1000)\n\n", "; a = 2. # parameter\n; s = np.random.zipf(a, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n", "; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n\n", "; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.zipf", "code": "\nnumpy.random.zipf(a, size=None)\u00b6", "description": "Draw samples from a Zipf distribution.\nSamples are drawn from a Zipf distribution with specified parameter\na &gt; 1.\nThe Zipf distribution (also known as the zeta distribution) is a\ncontinuous probability distribution that satisfies Zipf\u2019s law: the\nfrequency of an item is inversely proportional to its rank in a\nfrequency table.\n\nNote\nNew code should use the zipf method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsDistribution parameter. Must be greater than 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar. Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Zipf distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.zipfprobability density function, distribution, or cumulative density function, etc.\n\nGenerator.zipfwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Zipf distribution is\n\n\nwhere  is the Riemann Zeta function.\nIt is named for the American linguist George Kingsley Zipf, who noted\nthat the frequency of any word in a sample of a language is inversely\nproportional to its rank in the frequency table.\nReferences\n\n1\nZipf, G. K., \u201cSelected Studies of the Principle of Relative\nFrequency in Language,\u201d Cambridge, MA: Harvard Univ. Press,\n1932.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 2. # parameter\n&gt;&gt;&gt; s = np.random.zipf(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy import special  \n\n\nTruncate s values at 50 so plot is interesting:\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n&gt;&gt;&gt; x = np.arange(1., 50.)\n&gt;&gt;&gt; y = x**(-a) / special.zetac(a)  \n&gt;&gt;&gt; plt.plot(x, y/max(y), linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Zipf distribution.", "examples": ["; a = 2. # parameter\n; s = np.random.zipf(a, 1000)\n\n", "; a = 2. # parameter\n; s = np.random.zipf(a, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n", "; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n\n", "; count, bins, ignored = plt.hist(s[s&lt;50], 50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.chararray.zfill", "code": "\nchararray.zfill(self, width)[source]\u00b6", "description": "Return the numeric string left-filled with zeros in a string of\nlength width.\n\nSee also\nchar.zfill\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.weibull", "code": "\nnumpy.random.weibull(a, size=None)\u00b6", "description": "Draw samples from a Weibull distribution.\nDraw samples from a 1-parameter Weibull distribution with the given\nshape parameter a.\n\n\nHere, U is drawn from the uniform distribution over (0,1].\nThe more common 2-parameter Weibull, including a scale parameter\n is just .\n\nNote\nNew code should use the weibull method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsShape parameter of the distribution.  Must be nonnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Weibull distribution.\n\n\n\n\n\nSee also\nscipy.stats.weibull_max, scipy.stats.weibull_min, scipy.stats.genextreme, gumbel\n\nGenerator.weibullwhich should be used for new code.\n\n\n\nNotes\nThe Weibull (or Type III asymptotic extreme value distribution\nfor smallest values, SEV Type III, or Rosin-Rammler\ndistribution) is one of a class of Generalized Extreme Value\n(GEV) distributions used in modeling extreme value problems.\nThis class includes the Gumbel and Frechet distributions.\nThe probability density for the Weibull distribution is\n\n\nwhere  is the shape and  the scale.\nThe function has its peak (the mode) at\n.\nWhen a = 1, the Weibull distribution reduces to the exponential\ndistribution.\nReferences\n\n1\nWaloddi Weibull, Royal Technical University, Stockholm,\n1939 \u201cA Statistical Theory Of The Strength Of Materials\u201d,\nIngeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\nGeneralstabens Litografiska Anstalts Forlag, Stockholm.\n\n2\nWaloddi Weibull, \u201cA Statistical Distribution Function of\nWide Applicability\u201d, Journal Of Applied Mechanics ASME Paper\n1951.\n\n3\nWikipedia, \u201cWeibull distribution\u201d,\nhttps://en.wikipedia.org/wiki/Weibull_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; s = np.random.weibull(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n\n&gt;&gt;&gt; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; scale = count.max()/weib(x, 1., 5.).max()\n&gt;&gt;&gt; plt.plot(x, weib(x, 1., 5.)*scale)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Weibull distribution.", "examples": ["; a = 5. # shape\n; s = np.random.weibull(a, 1000)\n\n", "; a = 5. # shape\n; s = np.random.weibull(a, 1000)\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n", "; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n\n", "; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.zfill", "code": "\nchararray.zfill(self, width)\u00b6", "description": "Return the numeric string left-filled with zeros in a string of\nlength width.\n\nSee also\nchar.zfill\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.zipf", "code": "\nGenerator.zipf(a, size=None)\u00b6", "description": "Draw samples from a Zipf distribution.\nSamples are drawn from a Zipf distribution with specified parameter\na &gt; 1.\nThe Zipf distribution (also known as the zeta distribution) is a\ncontinuous probability distribution that satisfies Zipf\u2019s law: the\nfrequency of an item is inversely proportional to its rank in a\nfrequency table.\n\nParameters\n\nafloat or array_like of floatsDistribution parameter. Must be greater than 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar. Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Zipf distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.zipfprobability density function, distribution, or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Zipf distribution is\n\n\nwhere  is the Riemann Zeta function.\nIt is named for the American linguist George Kingsley Zipf, who noted\nthat the frequency of any word in a sample of a language is inversely\nproportional to its rank in the frequency table.\nReferences\n\n1\nZipf, G. K., \u201cSelected Studies of the Principle of Relative\nFrequency in Language,\u201d Cambridge, MA: Harvard Univ. Press,\n1932.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 2. # parameter\n&gt;&gt;&gt; s = np.random.default_rng().zipf(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy import special  \n\n\nTruncate s values at 50 so plot is interesting:\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s[s&lt;50],\n...         50, density=True)\n&gt;&gt;&gt; x = np.arange(1., 50.)\n&gt;&gt;&gt; y = x**(-a) / special.zetac(a)  \n&gt;&gt;&gt; plt.plot(x, y/max(y), linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Zipf distribution.", "examples": ["; a = 2. # parameter\n; s = np.random.default_rng().zipf(a, 1000)\n\n", "; a = 2. # parameter\n; s = np.random.default_rng().zipf(a, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n\n", "; import matplotlib.pyplot as plt\n; from scipy import special  \n", "; count, bins, ignored = plt.hist(s[s&lt;50],\n...         50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n\n", "; count, bins, ignored = plt.hist(s[s&lt;50],\n...         50, density=True)\n; x = np.arange(1., 50.)\n; y = x**(-a) / special.zetac(a)  \n; plt.plot(x, y/max(y), linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.zeros_like", "code": "\nnumpy.zeros_like(a, dtype=None, order='K', subok=True, shape=None)[source]\u00b6", "description": "Return an array of zeros with the same shape and type as a given array.\n\nParameters\n\naarray_likeThe shape and data-type of a define these same attributes of\nthe returned array.\n\ndtypedata-type, optionalOverrides the data type of the result.\n\nNew in version 1.6.0.\n\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optionalOverrides the memory layout of the result. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible.\n\nNew in version 1.6.0.\n\n\nsubokbool, optional.If True, then the newly created array will use the sub-class\ntype of \u2018a\u2019, otherwise it will be a base-class array. Defaults\nto True.\n\nshapeint or sequence of ints, optional.Overrides the shape of the result. If order=\u2019K\u2019 and the number of\ndimensions is unchanged, will try to keep order, otherwise,\norder=\u2019C\u2019 is implied.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\noutndarrayArray of zeros with the same shape and type as a.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nones_likeReturn an array of ones with shape and type of input.\n\nfull_likeReturn a new array with shape of input filled with value.\n\nzerosReturn a new array setting values to zero.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(6)\n&gt;&gt;&gt; x = x.reshape((2, 3))\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y = np.arange(3, dtype=float)\n&gt;&gt;&gt; y\narray([0., 1., 2.])\n&gt;&gt;&gt; np.zeros_like(y)\narray([0.,  0.,  0.])\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optional", "subokbool, optional.", "shapeint or sequence of ints, optional.", "Returns", "outndarray"], "returns": "outndarrayArray of zeros with the same shape and type as a.", "examples": ["; x = np.arange(6)\n; x = x.reshape((2, 3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x = np.arange(6)\n; x = x.reshape((2, 3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.zeros_like(x)\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y = np.arange(3, dtype=float)\n; y\narray([0., 1., 2.])\n; np.zeros_like(y)\narray([0.,  0.,  0.])\n\n", "; y = np.arange(3, dtype=float)\n; y\narray([0., 1., 2.])\n; np.zeros_like(y)\narray([0.,  0.,  0.])\n"]},
{"library": "numpy", "item_id": "numpy.char.zfill", "code": "\nnumpy.char.zfill(a, width)\u00b6", "description": "Return the numeric string left-filled with zeros\nCalls str.zfill element-wise.\n\nParameters\n\naarray_like, {str, unicode}Input array.\n\nwidthintWidth of string to left-fill elements in a.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.zfill\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "widthint", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.matlib.zeros", "code": "\nnumpy.matlib.zeros(shape, dtype=None, order='C')[source]\u00b6", "description": "Return a matrix of given shape and type, filled with zeros.\n\nParameters\n\nshapeint or sequence of intsShape of the matrix\n\ndtypedata-type, optionalThe desired data-type for the matrix, default is float.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to store the result in C- or Fortran-contiguous order,\ndefault is \u2018C\u2019.\n\n\n\nReturns\n\noutmatrixZero matrix of given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nnumpy.zerosEquivalent array function.\n\nmatlib.onesReturn a matrix of ones.\n\n\n\nNotes\nIf shape has length one i.e. (N,), or is a scalar N,\nout becomes a single row matrix of shape (1,N).\nExamples\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.zeros((2, 3))\nmatrix([[0.,  0.,  0.],\n        [0.,  0.,  0.]])\n\n\n&gt;&gt;&gt; np.matlib.zeros(2)\nmatrix([[0.,  0.]])\n\n\n", "parameters": ["Parameters", "shapeint or sequence of ints", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outmatrix"], "returns": "outmatrixZero matrix of given shape, dtype, and order.", "examples": ["; import numpy.matlib\n; np.matlib.zeros((2, 3))\nmatrix([[0.,  0.,  0.],\n        [0.,  0.,  0.]])\n\n", "; import numpy.matlib\n; np.matlib.zeros((2, 3))\nmatrix([[0.,  0.,  0.],\n        [0.,  0.,  0.]])\n", "; np.matlib.zeros(2)\nmatrix([[0.,  0.]])\n\n", "; np.matlib.zeros(2)\nmatrix([[0.,  0.]])\n"]},
{"library": "numpy", "item_id": "numpy.zeros", "code": "\nnumpy.zeros(shape, dtype=float, order='C')\u00b6", "description": "Return a new array of given shape and type, filled with zeros.\n\nParameters\n\nshapeint or tuple of intsShape of the new array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalThe desired data-type for the array, e.g., numpy.int8.  Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019Whether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of zeros with the given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nemptyReturn a new uninitialized array.\n\nonesReturn a new array setting values to one.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nExamples\n&gt;&gt;&gt; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n\n&gt;&gt;&gt; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n\n\n&gt;&gt;&gt; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n\n\n&gt;&gt;&gt; s = (2,2)\n&gt;&gt;&gt; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n\n\n&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n\n", "parameters": ["Parameters", "shapeint or tuple of ints", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019", "Returns", "outndarray"], "returns": "outndarrayArray of zeros with the given shape, dtype, and order.", "examples": ["; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n", "; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n", "; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n\n", "; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n", "; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n\n", "; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n", "; s = (2,2)\n; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n\n", "; s = (2,2)\n; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n", "; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n", "; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.zeros", "code": "\nnumpy.ma.zeros(shape, dtype=float, order='C') = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return a new array of given shape and type, filled with zeros.\n\nParameters\n\nshapeint or tuple of intsShape of the new array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalThe desired data-type for the array, e.g., numpy.int8.  Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019Whether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of zeros with the given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nemptyReturn a new uninitialized array.\n\nonesReturn a new array setting values to one.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nExamples\n&gt;&gt;&gt; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n\n&gt;&gt;&gt; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n\n\n&gt;&gt;&gt; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n\n\n&gt;&gt;&gt; s = (2,2)\n&gt;&gt;&gt; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n\n\n&gt;&gt;&gt; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n\n", "parameters": ["Parameters", "shapeint or tuple of ints", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019", "Returns", "outndarray"], "returns": "outndarrayArray of zeros with the given shape, dtype, and order.", "examples": ["; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n\n", "; np.zeros(5)\narray([ 0.,  0.,  0.,  0.,  0.])\n", "; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n\n", "; np.zeros((5,), dtype=int)\narray([0, 0, 0, 0, 0])\n", "; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n\n", "; np.zeros((2, 1))\narray([[ 0.],\n       [ 0.]])\n", "; s = (2,2)\n; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n\n", "; s = (2,2)\n; np.zeros(s)\narray([[ 0.,  0.],\n       [ 0.,  0.]])\n", "; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n", "; np.zeros((2,), dtype=[('x', 'i4'), ('y', 'i4')]) # custom dtype\narray([(0, 0), (0, 0)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.window", "code": "\nPolynomial.window = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.window", "code": "\nLegendre.window = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.window", "code": "\nLaguerre.window = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.window", "code": "\nHermiteE.window = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.window", "code": "\nHermite.window = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.window", "code": "\nChebyshev.window = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.wald", "code": "\nRandomState.wald(mean, scale, size=None)\u00b6", "description": "Draw samples from a Wald, or inverse Gaussian, distribution.\nAs the scale approaches infinity, the distribution becomes more like a\nGaussian. Some references claim that the Wald is an inverse Gaussian\nwith mean equal to 1, but this is by no means universal.\nThe inverse Gaussian distribution was first studied in relationship to\nBrownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\nbecause there is an inverse relationship between the time to cover a\nunit distance and distance covered in unit time.\n\nNote\nNew code should use the wald method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmeanfloat or array_like of floatsDistribution mean, must be &gt; 0.\n\nscalefloat or array_like of floatsScale parameter, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and scale are both scalars.\nOtherwise, np.broadcast(mean, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Wald distribution.\n\n\n\n\n\nSee also\n\nGenerator.waldwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the Wald distribution is\n\n\nAs noted above the inverse Gaussian distribution first arise\nfrom attempts to model Brownian motion. It is also a\ncompetitor to the Weibull for use in reliability modeling and\nmodeling stock returns and interest rate processes.\nReferences\n\n1\nBrighton Webs Ltd., Wald Distribution,\nhttps://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp\n\n2\nChhikara, Raj S., and Folks, J. Leroy, \u201cThe Inverse Gaussian\nDistribution: Theory : Methodology, and Applications\u201d, CRC Press,\n1988.\n\n3\nWikipedia, \u201cInverse Gaussian distribution\u201d\nhttps://en.wikipedia.org/wiki/Inverse_Gaussian_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Wald distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.who", "code": "\nnumpy.who(vardict=None)[source]\u00b6", "description": "Print the NumPy arrays in the given dictionary.\nIf there is no dictionary passed in or vardict is None then returns\nNumPy arrays in the globals() dictionary (all NumPy arrays in the\nnamespace).\n\nParameters\n\nvardictdict, optionalA dictionary possibly containing ndarrays.  Default is globals().\n\n\n\nReturns\n\noutNoneReturns \u2018None\u2019.\n\n\n\n\nNotes\nPrints out the name, shape, bytes and type of all of the ndarrays\npresent in vardict.\nExamples\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; b = np.ones(20)\n&gt;&gt;&gt; np.who()\nName            Shape            Bytes            Type\n===========================================================\na               10               80               int64\nb               20               160              float64\nUpper bound on total bytes  =       240\n\n\n&gt;&gt;&gt; d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n... 'idx':5}\n&gt;&gt;&gt; np.who(d)\nName            Shape            Bytes            Type\n===========================================================\nx               2                16               float64\ny               3                24               float64\nUpper bound on total bytes  =       40\n\n\n", "parameters": ["Parameters", "vardictdict, optional", "Returns", "outNone"], "returns": "outNoneReturns \u2018None\u2019.", "examples": ["; a = np.arange(10)\n; b = np.ones(20)\n; np.who()\nName            Shape            Bytes            Type\n===========================================================\na               10               80               int64\nb               20               160              float64\nUpper bound on total bytes  =       240\n\n", "; a = np.arange(10)\n; b = np.ones(20)\n; np.who()\nName            Shape            Bytes            Type\n===========================================================\na               10               80               int64\nb               20               160              float64\nUpper bound on total bytes  =       240\n", "; d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n... 'idx':5}\n; np.who(d)\nName            Shape            Bytes            Type\n===========================================================\nx               2                16               float64\ny               3                24               float64\nUpper bound on total bytes  =       40\n\n", "; d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',\n... 'idx':5}\n; np.who(d)\nName            Shape            Bytes            Type\n===========================================================\nx               2                16               float64\ny               3                24               float64\nUpper bound on total bytes  =       40\n"]},
{"library": "numpy", "item_id": "numpy.ma.where", "code": "\nnumpy.ma.where(condition, x=&lt;no value&gt;, y=&lt;no value&gt;)[source]\u00b6", "description": "Return a masked array with elements from x or y, depending on condition.\n\nNote\nWhen only condition is provided, this function is identical to\nnonzero. The rest of this documentation covers only the case where\nall three arguments are provided.\n\n\nParameters\n\nconditionarray_like, boolWhere True, yield x, otherwise yield y.\n\nx, yarray_like, optionalValues from which to choose. x, y and condition need to be\nbroadcastable to some shape.\n\n\n\nReturns\n\noutMaskedArrayAn masked array with masked elements where the condition is masked,\nelements from x where condition is True, and elements from y\nelsewhere.\n\n\n\n\n\nSee also\n\nnumpy.whereEquivalent function in the top-level NumPy module.\n\nnonzeroThe function that is called when x and y are omitted\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[0.0, --, 2.0],\n        [--, 4.0, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n&gt;&gt;&gt; np.ma.where(x &gt; 5, x, -3.1416)\nmasked_array(\n  data=[[-3.1416, --, -3.1416],\n        [--, -3.1416, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "conditionarray_like, bool", "x, yarray_like, optional", "Returns", "outMaskedArray"], "returns": "outMaskedArrayAn masked array with masked elements where the condition is masked,elements from x where condition is True, and elements from yelsewhere.", "examples": ["; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n; x\nmasked_array(\n  data=[[0.0, --, 2.0],\n        [--, 4.0, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n; np.ma.where(x &gt; 5, x, -3.1416)\nmasked_array(\n  data=[[-3.1416, --, -3.1416],\n        [--, -3.1416, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n\n", "; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],\n...                                                    [1, 0, 1],\n...                                                    [0, 1, 0]])\n; x\nmasked_array(\n  data=[[0.0, --, 2.0],\n        [--, 4.0, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n; np.ma.where(x &gt; 5, x, -3.1416)\nmasked_array(\n  data=[[-3.1416, --, -3.1416],\n        [--, -3.1416, --],\n        [6.0, --, 8.0]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.where", "code": "\nnumpy.where(condition[, x, y])\u00b6", "description": "Return elements chosen from x or y depending on condition.\n\nNote\nWhen only condition is provided, this function is a shorthand for\nnp.asarray(condition).nonzero(). Using nonzero directly should be\npreferred, as it behaves correctly for subclasses. The rest of this\ndocumentation covers only the case where all three arguments are\nprovided.\n\n\nParameters\n\nconditionarray_like, boolWhere True, yield x, otherwise yield y.\n\nx, yarray_likeValues from which to choose. x, y and condition need to be\nbroadcastable to some shape.\n\n\n\nReturns\n\noutndarrayAn array with elements from x where condition is True, and elements\nfrom y elsewhere.\n\n\n\n\n\nSee also\nchoose\n\nnonzeroThe function that is called when x and y are omitted\n\n\n\nNotes\nIf all the arrays are 1-D, where is equivalent to:\n[xv if c else yv\n for c, xv, yv in zip(condition, x, y)]\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; np.where(a &lt; 5, a, 10*a)\narray([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])\n\n\nThis can be used on multidimensional arrays too:\n&gt;&gt;&gt; np.where([[True, False], [True, True]],\n...          [[1, 2], [3, 4]],\n...          [[9, 8], [7, 6]])\narray([[1, 8],\n       [3, 4]])\n\n\nThe shapes of x, y, and the condition are broadcast together:\n&gt;&gt;&gt; x, y = np.ogrid[:3, :4]\n&gt;&gt;&gt; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast\narray([[10,  0,  0,  0],\n       [10, 11,  1,  1],\n       [10, 11, 12,  2]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1, 2],\n...               [0, 2, 4],\n...               [0, 3, 6]])\n&gt;&gt;&gt; np.where(a &lt; 4, a, -1)  # -1 is broadcast\narray([[ 0,  1,  2],\n       [ 0,  2, -1],\n       [ 0,  3, -1]])\n\n\n", "parameters": ["Parameters", "conditionarray_like, bool", "x, yarray_like", "Returns", "outndarray"], "returns": "outndarrayAn array with elements from x where condition is True, and elementsfrom y elsewhere.", "examples": ["; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.where(a &lt; 5, a, 10*a)\narray([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])\n\n", "; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.where(a &lt; 5, a, 10*a)\narray([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])\n", "; np.where([[True, False], [True, True]],\n...          [[1, 2], [3, 4]],\n...          [[9, 8], [7, 6]])\narray([[1, 8],\n       [3, 4]])\n\n", "; np.where([[True, False], [True, True]],\n...          [[1, 2], [3, 4]],\n...          [[9, 8], [7, 6]])\narray([[1, 8],\n       [3, 4]])\n", "; x, y = np.ogrid[:3, :4]\n; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast\narray([[10,  0,  0,  0],\n       [10, 11,  1,  1],\n       [10, 11, 12,  2]])\n\n", "; x, y = np.ogrid[:3, :4]\n; np.where(x &lt; y, x, 10 + y)  # both x and 10+y are broadcast\narray([[10,  0,  0,  0],\n       [10, 11,  1,  1],\n       [10, 11, 12,  2]])\n", "; a = np.array([[0, 1, 2],\n...               [0, 2, 4],\n...               [0, 3, 6]])\n; np.where(a &lt; 4, a, -1)  # -1 is broadcast\narray([[ 0,  1,  2],\n       [ 0,  2, -1],\n       [ 0,  3, -1]])\n\n", "; a = np.array([[0, 1, 2],\n...               [0, 2, 4],\n...               [0, 3, 6]])\n; np.where(a &lt; 4, a, -1)  # -1 is broadcast\narray([[ 0,  1,  2],\n       [ 0,  2, -1],\n       [ 0,  3, -1]])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.wald", "code": "\nGenerator.wald(mean, scale, size=None)\u00b6", "description": "Draw samples from a Wald, or inverse Gaussian, distribution.\nAs the scale approaches infinity, the distribution becomes more like a\nGaussian. Some references claim that the Wald is an inverse Gaussian\nwith mean equal to 1, but this is by no means universal.\nThe inverse Gaussian distribution was first studied in relationship to\nBrownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\nbecause there is an inverse relationship between the time to cover a\nunit distance and distance covered in unit time.\n\nParameters\n\nmeanfloat or array_like of floatsDistribution mean, must be &gt; 0.\n\nscalefloat or array_like of floatsScale parameter, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and scale are both scalars.\nOtherwise, np.broadcast(mean, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Wald distribution.\n\n\n\n\nNotes\nThe probability density function for the Wald distribution is\n\n\nAs noted above the inverse Gaussian distribution first arise\nfrom attempts to model Brownian motion. It is also a\ncompetitor to the Weibull for use in reliability modeling and\nmodeling stock returns and interest rate processes.\nReferences\n\n1\nBrighton Webs Ltd., Wald Distribution,\nhttps://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp\n\n2\nChhikara, Raj S., and Folks, J. Leroy, \u201cThe Inverse Gaussian\nDistribution: Theory : Methodology, and Applications\u201d, CRC Press,\n1988.\n\n3\nWikipedia, \u201cInverse Gaussian distribution\u201d\nhttps://en.wikipedia.org/wiki/Inverse_Gaussian_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.default_rng().wald(3, 2, 100000), bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Wald distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.default_rng().wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.default_rng().wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.weibull", "code": "\nRandomState.weibull(a, size=None)\u00b6", "description": "Draw samples from a Weibull distribution.\nDraw samples from a 1-parameter Weibull distribution with the given\nshape parameter a.\n\n\nHere, U is drawn from the uniform distribution over (0,1].\nThe more common 2-parameter Weibull, including a scale parameter\n is just .\n\nNote\nNew code should use the weibull method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsShape parameter of the distribution.  Must be nonnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Weibull distribution.\n\n\n\n\n\nSee also\nscipy.stats.weibull_max, scipy.stats.weibull_min, scipy.stats.genextreme, gumbel\n\nGenerator.weibullwhich should be used for new code.\n\n\n\nNotes\nThe Weibull (or Type III asymptotic extreme value distribution\nfor smallest values, SEV Type III, or Rosin-Rammler\ndistribution) is one of a class of Generalized Extreme Value\n(GEV) distributions used in modeling extreme value problems.\nThis class includes the Gumbel and Frechet distributions.\nThe probability density for the Weibull distribution is\n\n\nwhere  is the shape and  the scale.\nThe function has its peak (the mode) at\n.\nWhen a = 1, the Weibull distribution reduces to the exponential\ndistribution.\nReferences\n\n1\nWaloddi Weibull, Royal Technical University, Stockholm,\n1939 \u201cA Statistical Theory Of The Strength Of Materials\u201d,\nIngeniorsvetenskapsakademiens Handlingar Nr 151, 1939,\nGeneralstabens Litografiska Anstalts Forlag, Stockholm.\n\n2\nWaloddi Weibull, \u201cA Statistical Distribution Function of\nWide Applicability\u201d, Journal Of Applied Mechanics ASME Paper\n1951.\n\n3\nWikipedia, \u201cWeibull distribution\u201d,\nhttps://en.wikipedia.org/wiki/Weibull_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; s = np.random.weibull(a, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n\n&gt;&gt;&gt; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n&gt;&gt;&gt; x = np.arange(1,100.)/50.\n&gt;&gt;&gt; scale = count.max()/weib(x, 1., 5.).max()\n&gt;&gt;&gt; plt.plot(x, weib(x, 1., 5.)*scale)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Weibull distribution.", "examples": ["; a = 5. # shape\n; s = np.random.weibull(a, 1000)\n\n", "; a = 5. # shape\n; s = np.random.weibull(a, 1000)\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n\n", "; import matplotlib.pyplot as plt\n; x = np.arange(1,100.)/50.\n; def weib(x,n,a):\n...     return (a / n) * (x / n)**(a - 1) * np.exp(-(x / n)**a)\n", "; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n\n", "; count, bins, ignored = plt.hist(np.random.weibull(5.,1000))\n; x = np.arange(1,100.)/50.\n; scale = count.max()/weib(x, 1., 5.).max()\n; plt.plot(x, weib(x, 1., 5.)*scale)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.wald", "code": "\nnumpy.random.wald(mean, scale, size=None)\u00b6", "description": "Draw samples from a Wald, or inverse Gaussian, distribution.\nAs the scale approaches infinity, the distribution becomes more like a\nGaussian. Some references claim that the Wald is an inverse Gaussian\nwith mean equal to 1, but this is by no means universal.\nThe inverse Gaussian distribution was first studied in relationship to\nBrownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian\nbecause there is an inverse relationship between the time to cover a\nunit distance and distance covered in unit time.\n\nNote\nNew code should use the wald method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmeanfloat or array_like of floatsDistribution mean, must be &gt; 0.\n\nscalefloat or array_like of floatsScale parameter, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and scale are both scalars.\nOtherwise, np.broadcast(mean, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Wald distribution.\n\n\n\n\n\nSee also\n\nGenerator.waldwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the Wald distribution is\n\n\nAs noted above the inverse Gaussian distribution first arise\nfrom attempts to model Brownian motion. It is also a\ncompetitor to the Weibull for use in reliability modeling and\nmodeling stock returns and interest rate processes.\nReferences\n\n1\nBrighton Webs Ltd., Wald Distribution,\nhttps://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp\n\n2\nChhikara, Raj S., and Folks, J. Leroy, \u201cThe Inverse Gaussian\nDistribution: Theory : Methodology, and Applications\u201d, CRC Press,\n1988.\n\n3\nWikipedia, \u201cInverse Gaussian distribution\u201d\nhttps://en.wikipedia.org/wiki/Inverse_Gaussian_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Wald distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.wald(3, 2, 100000), bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.vstack", "code": "\nnumpy.vstack(tup)[source]\u00b6", "description": "Stack arrays in sequence vertically (row wise).\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape (N,) have been reshaped to (1,N). Rebuilds arrays divided by\nvsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\nParameters\n\ntupsequence of ndarraysThe arrays must have the same shape along all but the first axis.\n1-D arrays must have the same length.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nhstackStack arrays in sequence horizontally (column wise).\n\ndstackStack arrays in sequence depth wise (along third dimension).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nvsplitSplit array into a list of multiple sub-arrays vertically.\n\nblockAssemble arrays from blocks.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; a = np.array([[1], [2], [3]])\n&gt;&gt;&gt; b = np.array([[2], [3], [4]])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n\n", "parameters": ["Parameters", "tupsequence of ndarrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.", "examples": ["; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.vstack", "code": "\nnumpy.ma.vstack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nStack arrays in sequence vertically (row wise).\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape (N,) have been reshaped to (1,N). Rebuilds arrays divided by\nvsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\n\nParameters\n\ntupsequence of ndarraysThe arrays must have the same shape along all but the first axis.\n1-D arrays must have the same length.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nhstackStack arrays in sequence horizontally (column wise).\n\ndstackStack arrays in sequence depth wise (along third dimension).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nvsplitSplit array into a list of multiple sub-arrays vertically.\n\nblockAssemble arrays from blocks.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; a = np.array([[1], [2], [3]])\n&gt;&gt;&gt; b = np.array([[2], [3], [4]])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n\n", "parameters": ["Parameters", "tupsequence of ndarrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.", "examples": ["; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n"]},
{"library": "numpy", "item_id": "numpy.vsplit", "code": "\nnumpy.vsplit(ary, indices_or_sections)[source]\u00b6", "description": "Split an array into multiple sub-arrays vertically (row-wise).\nPlease refer to the split documentation.  vsplit is equivalent\nto split with axis=0 (default), the array is always split along the\nfirst axis regardless of the array dimension.\n\nSee also\n\nsplitSplit an array into multiple sub-arrays of equal size.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)\n&gt;&gt;&gt; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n&gt;&gt;&gt; np.vsplit(x, 2)\n[array([[0., 1., 2., 3.],\n       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],\n       [12., 13., 14., 15.]])]\n&gt;&gt;&gt; np.vsplit(x, np.array([3, 6]))\n[array([[ 0.,  1.,  2.,  3.],\n       [ 4.,  5.,  6.,  7.],\n       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]\n\n\nWith a higher dimensional array the split is still along the first axis.\n&gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)\n&gt;&gt;&gt; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n&gt;&gt;&gt; np.vsplit(x, 2)\n[array([[[0., 1.],\n        [2., 3.]]]), array([[[4., 5.],\n        [6., 7.]]])]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.vsplit(x, 2)\n[array([[0., 1., 2., 3.],\n       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],\n       [12., 13., 14., 15.]])]\n; np.vsplit(x, np.array([3, 6]))\n[array([[ 0.,  1.,  2.,  3.],\n       [ 4.,  5.,  6.,  7.],\n       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]\n\n", "; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.vsplit(x, 2)\n[array([[0., 1., 2., 3.],\n       [4., 5., 6., 7.]]), array([[ 8.,  9., 10., 11.],\n       [12., 13., 14., 15.]])]\n; np.vsplit(x, np.array([3, 6]))\n[array([[ 0.,  1.,  2.,  3.],\n       [ 4.,  5.,  6.,  7.],\n       [ 8.,  9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.vsplit(x, 2)\n[array([[[0., 1.],\n        [2., 3.]]]), array([[[4., 5.],\n        [6., 7.]]])]\n\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.vsplit(x, 2)\n[array([[[0., 1.],\n        [2., 3.]]]), array([[[4., 5.],\n        [6., 7.]]])]\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.vonmises", "code": "\nRandomState.vonmises(mu, kappa, size=None)\u00b6", "description": "Draw samples from a von Mises distribution.\nSamples are drawn from a von Mises distribution with specified mode\n(mu) and dispersion (kappa), on the interval [-pi, pi].\nThe von Mises distribution (also known as the circular normal\ndistribution) is a continuous probability distribution on the unit\ncircle.  It may be thought of as the circular analogue of the normal\ndistribution.\n\nNote\nNew code should use the vonmises method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmufloat or array_like of floatsMode (\u201ccenter\u201d) of the distribution.\n\nkappafloat or array_like of floatsDispersion of the distribution, has to be &gt;=0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mu and kappa are both scalars.\nOtherwise, np.broadcast(mu, kappa).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized von Mises distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.vonmisesprobability density function, distribution, or cumulative density function, etc.\n\nGenerator.vonmiseswhich should be used for new code.\n\n\n\nNotes\nThe probability density for the von Mises distribution is\n\n\nwhere  is the mode and  the dispersion,\nand  is the modified Bessel function of order 0.\nThe von Mises is named for Richard Edler von Mises, who was born in\nAustria-Hungary, in what is now the Ukraine.  He fled to the United\nStates in 1939 and became a professor at Harvard.  He worked in\nprobability theory, aerodynamics, fluid mechanics, and philosophy of\nscience.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nvon Mises, R., \u201cMathematical Theory of Probability\nand Statistics\u201d, New York: Academic Press, 1964.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, kappa = 0.0, 4.0 # mean and dispersion\n&gt;&gt;&gt; s = np.random.vonmises(mu, kappa, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy.special import i0  \n&gt;&gt;&gt; plt.hist(s, 50, density=True)\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, num=51)\n&gt;&gt;&gt; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n&gt;&gt;&gt; plt.plot(x, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "mufloat or array_like of floats", "kappafloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized von Mises distribution.", "examples": ["; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.vonmises(mu, kappa, 1000)\n\n", "; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.vonmises(mu, kappa, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.vonmises", "code": "\nGenerator.vonmises(mu, kappa, size=None)\u00b6", "description": "Draw samples from a von Mises distribution.\nSamples are drawn from a von Mises distribution with specified mode\n(mu) and dispersion (kappa), on the interval [-pi, pi].\nThe von Mises distribution (also known as the circular normal\ndistribution) is a continuous probability distribution on the unit\ncircle.  It may be thought of as the circular analogue of the normal\ndistribution.\n\nParameters\n\nmufloat or array_like of floatsMode (\u201ccenter\u201d) of the distribution.\n\nkappafloat or array_like of floatsDispersion of the distribution, has to be &gt;=0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mu and kappa are both scalars.\nOtherwise, np.broadcast(mu, kappa).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized von Mises distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.vonmisesprobability density function, distribution, or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the von Mises distribution is\n\n\nwhere  is the mode and  the dispersion,\nand  is the modified Bessel function of order 0.\nThe von Mises is named for Richard Edler von Mises, who was born in\nAustria-Hungary, in what is now the Ukraine.  He fled to the United\nStates in 1939 and became a professor at Harvard.  He worked in\nprobability theory, aerodynamics, fluid mechanics, and philosophy of\nscience.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nvon Mises, R., \u201cMathematical Theory of Probability\nand Statistics\u201d, New York: Academic Press, 1964.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, kappa = 0.0, 4.0 # mean and dispersion\n&gt;&gt;&gt; s = np.random.default_rng().vonmises(mu, kappa, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy.special import i0  \n&gt;&gt;&gt; plt.hist(s, 50, density=True)\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, num=51)\n&gt;&gt;&gt; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n&gt;&gt;&gt; plt.plot(x, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "mufloat or array_like of floats", "kappafloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized von Mises distribution.", "examples": ["; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.default_rng().vonmises(mu, kappa, 1000)\n\n", "; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.default_rng().vonmises(mu, kappa, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.record.view", "code": "\nrecord.view()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.vonmises", "code": "\nnumpy.random.vonmises(mu, kappa, size=None)\u00b6", "description": "Draw samples from a von Mises distribution.\nSamples are drawn from a von Mises distribution with specified mode\n(mu) and dispersion (kappa), on the interval [-pi, pi].\nThe von Mises distribution (also known as the circular normal\ndistribution) is a continuous probability distribution on the unit\ncircle.  It may be thought of as the circular analogue of the normal\ndistribution.\n\nNote\nNew code should use the vonmises method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmufloat or array_like of floatsMode (\u201ccenter\u201d) of the distribution.\n\nkappafloat or array_like of floatsDispersion of the distribution, has to be &gt;=0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mu and kappa are both scalars.\nOtherwise, np.broadcast(mu, kappa).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized von Mises distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.vonmisesprobability density function, distribution, or cumulative density function, etc.\n\nGenerator.vonmiseswhich should be used for new code.\n\n\n\nNotes\nThe probability density for the von Mises distribution is\n\n\nwhere  is the mode and  the dispersion,\nand  is the modified Bessel function of order 0.\nThe von Mises is named for Richard Edler von Mises, who was born in\nAustria-Hungary, in what is now the Ukraine.  He fled to the United\nStates in 1939 and became a professor at Harvard.  He worked in\nprobability theory, aerodynamics, fluid mechanics, and philosophy of\nscience.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nvon Mises, R., \u201cMathematical Theory of Probability\nand Statistics\u201d, New York: Academic Press, 1964.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, kappa = 0.0, 4.0 # mean and dispersion\n&gt;&gt;&gt; s = np.random.vonmises(mu, kappa, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from scipy.special import i0  \n&gt;&gt;&gt; plt.hist(s, 50, density=True)\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, num=51)\n&gt;&gt;&gt; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n&gt;&gt;&gt; plt.plot(x, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "mufloat or array_like of floats", "kappafloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized von Mises distribution.", "examples": ["; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.vonmises(mu, kappa, 1000)\n\n", "; mu, kappa = 0.0, 4.0 # mean and dispersion\n; s = np.random.vonmises(mu, kappa, 1000)\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; from scipy.special import i0  \n; plt.hist(s, 50, density=True)\n; x = np.linspace(-np.pi, np.pi, num=51)\n; y = np.exp(kappa*np.cos(x-mu))/(2*np.pi*i0(kappa))  \n; plt.plot(x, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.view", "code": "\nndarray.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.view", "code": "\nrecarray.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.view", "code": "\nmemmap.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.view", "code": "\nmatrix.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.view", "code": "\nMaskType.view()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.view", "code": "\nmasked_array.view(self, dtype=None, type=None, fill_value=None)[source]\u00b6", "description": "Return a view of the MaskedArray data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16.\nThe default, None, results in the view having the same data-type\nas a. As with ndarray.view, dtype can also be specified as\nan ndarray sub-class, which then specifies the type of the\nreturned object (this is equivalent to setting the type\nparameter).\n\ntypePython type, optionalType of the returned view, either ndarray or a subclass.  The\ndefault None results in type preservation.\n\nfill_valuescalar, optionalThe value to use for invalid entries (None by default).\nIf None, then this argument is inferred from the passed dtype, or\nin its absence the original array, as discussed in the notes below.\n\n\n\n\n\nSee also\n\nnumpy.ndarray.viewEquivalent method on ndarray object.\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nIf fill_value is not specified, but dtype is specified (and is not\nan ndarray sub-class), the fill_value of the MaskedArray will be\nreset. If neither fill_value nor dtype are specified (or if\ndtype is an ndarray sub-class), then the fill value is preserved.\nFinally, if fill_value is specified, but dtype is not, the fill\nvalue is set to the specified value.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional", "fill_valuescalar, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.view", "code": "\nMaskedArray.view(self, dtype=None, type=None, fill_value=None)[source]\u00b6", "description": "Return a view of the MaskedArray data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16.\nThe default, None, results in the view having the same data-type\nas a. As with ndarray.view, dtype can also be specified as\nan ndarray sub-class, which then specifies the type of the\nreturned object (this is equivalent to setting the type\nparameter).\n\ntypePython type, optionalType of the returned view, either ndarray or a subclass.  The\ndefault None results in type preservation.\n\nfill_valuescalar, optionalThe value to use for invalid entries (None by default).\nIf None, then this argument is inferred from the passed dtype, or\nin its absence the original array, as discussed in the notes below.\n\n\n\n\n\nSee also\n\nnumpy.ndarray.viewEquivalent method on ndarray object.\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nIf fill_value is not specified, but dtype is specified (and is not\nan ndarray sub-class), the fill_value of the MaskedArray will be\nreset. If neither fill_value nor dtype are specified (or if\ndtype is an ndarray sub-class), then the fill value is preserved.\nFinally, if fill_value is specified, but dtype is not, the fill\nvalue is set to the specified value.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional", "fill_valuescalar, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.view", "code": "\ngeneric.view()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.view", "code": "\nchararray.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.view", "code": "\nchararray.view(dtype=None, type=None)\u00b6", "description": "New view of array with the same data.\n\nParameters\n\ndtypedata-type or ndarray sub-class, optionalData-type descriptor of the returned view, e.g., float32 or int16. The\ndefault, None, results in the view having the same data-type as a.\nThis argument can also be specified as an ndarray sub-class, which\nthen specifies the type of the returned object (this is equivalent to\nsetting the type parameter).\n\ntypePython type, optionalType of the returned view, e.g., ndarray or matrix.  Again, the\ndefault None results in type preservation.\n\n\n\n\nNotes\na.view() is used two different ways:\na.view(some_dtype) or a.view(dtype=some_dtype) constructs a view\nof the array\u2019s memory with a different data-type.  This can cause a\nreinterpretation of the bytes of memory.\na.view(ndarray_subclass) or a.view(type=ndarray_subclass) just\nreturns an instance of ndarray_subclass that looks at the same array\n(same shape, dtype, etc.)  This does not cause a reinterpretation of the\nmemory.\nFor a.view(some_dtype), if some_dtype has a different number of\nbytes per entry than the previous dtype (for example, converting a\nregular array to a structured array), then the behavior of the view\ncannot be predicted just from the superficial appearance of a (shown\nby print(a)). It also depends on exactly how a is stored in\nmemory. Therefore if a is C-ordered versus fortran-ordered, versus\ndefined as a slice or transpose, etc., the view may give different\nresults.\nExamples\n&gt;&gt;&gt; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n\nViewing array data using a different type and dtype:\n&gt;&gt;&gt; y = x.view(dtype=np.int16, type=np.matrix)\n&gt;&gt;&gt; y\nmatrix([[513]], dtype=int16)\n&gt;&gt;&gt; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n\nCreating a view on a structured array so it can be used in calculations\n&gt;&gt;&gt; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n&gt;&gt;&gt; xv = x.view(dtype=np.int8).reshape(-1,2)\n&gt;&gt;&gt; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n&gt;&gt;&gt; xv.mean(0)\narray([2.,  3.])\n\n\nMaking changes to the view changes the underlying array\n&gt;&gt;&gt; xv[0,1] = 20\n&gt;&gt;&gt; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n\nUsing a view to convert an array to a recarray:\n&gt;&gt;&gt; z = x.view(np.recarray)\n&gt;&gt;&gt; z.a\narray([1, 3], dtype=int8)\n\n\nViews share data:\n&gt;&gt;&gt; x[0] = (9, 10)\n&gt;&gt;&gt; z[0]\n(9, 10)\n\n\nViews that change the dtype size (bytes per entry) should normally be\navoided on arrays defined by slices, transposes, fortran-ordering, etc.:\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n&gt;&gt;&gt; y = x[:, 0:2]\n&gt;&gt;&gt; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n&gt;&gt;&gt; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n&gt;&gt;&gt; z = y.copy()\n&gt;&gt;&gt; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n\n", "parameters": ["Parameters", "dtypedata-type or ndarray sub-class, optional", "typePython type, optional"], "returns": [], "examples": ["; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n\n", "; x = np.array([(1, 2)], dtype=[('a', np.int8), ('b', np.int8)])\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n\n", "; y = x.view(dtype=np.int16, type=np.matrix)\n; y\nmatrix([[513]], dtype=int16)\n; print(type(y))\n&lt;class 'numpy.matrix'&gt;\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n\n", "; x = np.array([(1, 2),(3,4)], dtype=[('a', np.int8), ('b', np.int8)])\n; xv = x.view(dtype=np.int8).reshape(-1,2)\n; xv\narray([[1, 2],\n       [3, 4]], dtype=int8)\n; xv.mean(0)\narray([2.,  3.])\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n\n", "; xv[0,1] = 20\n; x\narray([(1, 20), (3,  4)], dtype=[('a', 'i1'), ('b', 'i1')])\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n\n", "; z = x.view(np.recarray)\n; z.a\narray([1, 3], dtype=int8)\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n\n", "; x[0] = (9, 10)\n; z[0]\n(9, 10)\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n\n", "; x = np.array([[1,2,3],[4,5,6]], dtype=np.int16)\n; y = x[:, 0:2]\n; y\narray([[1, 2],\n       [4, 5]], dtype=int16)\n; y.view(dtype=[('width', np.int16), ('length', np.int16)])\nTraceback (most recent call last):\n    ...\nValueError: To change to a dtype of a different size, the array must be C-contiguous\n; z = y.copy()\n; z.view(dtype=[('width', np.int16), ('length', np.int16)])\narray([[(1, 2)],\n       [(4, 5)]], dtype=[('width', '&lt;i2'), ('length', '&lt;i2')])\n"]},
{"library": "numpy", "item_id": "numpy.vdot", "code": "\nnumpy.vdot(a, b)\u00b6", "description": "Return the dot product of two vectors.\nThe vdot(a, b) function handles complex numbers differently than\ndot(a, b).  If the first argument is complex the complex conjugate\nof the first argument is used for the calculation of the dot product.\nNote that vdot handles multidimensional arrays differently than dot:\nit does not perform a matrix product, but flattens input arguments\nto 1-D vectors first. Consequently, it should only be used for vectors.\n\nParameters\n\naarray_likeIf a is complex the complex conjugate is taken before calculation\nof the dot product.\n\nbarray_likeSecond argument to the dot product.\n\n\n\nReturns\n\noutputndarrayDot product of a and b.  Can be an int, float, or\ncomplex depending on the types of a and b.\n\n\n\n\n\nSee also\n\ndotReturn the dot product without using the complex conjugate of the first argument.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1+2j,3+4j])\n&gt;&gt;&gt; b = np.array([5+6j,7+8j])\n&gt;&gt;&gt; np.vdot(a, b)\n(70-8j)\n&gt;&gt;&gt; np.vdot(b, a)\n(70+8j)\n\n\nNote that higher-dimensional arrays are flattened!\n&gt;&gt;&gt; a = np.array([[1, 4], [5, 6]])\n&gt;&gt;&gt; b = np.array([[4, 1], [2, 2]])\n&gt;&gt;&gt; np.vdot(a, b)\n30\n&gt;&gt;&gt; np.vdot(b, a)\n30\n&gt;&gt;&gt; 1*4 + 4*1 + 5*2 + 6*2\n30\n\n\n", "parameters": ["Parameters", "aarray_like", "barray_like", "Returns", "outputndarray"], "returns": "outputndarrayDot product of a and b.  Can be an int, float, orcomplex depending on the types of a and b.", "examples": ["; a = np.array([1+2j,3+4j])\n; b = np.array([5+6j,7+8j])\n; np.vdot(a, b)\n(70-8j)\n; np.vdot(b, a)\n(70+8j)\n\n", "; a = np.array([1+2j,3+4j])\n; b = np.array([5+6j,7+8j])\n; np.vdot(a, b)\n(70-8j)\n; np.vdot(b, a)\n(70+8j)\n", "; a = np.array([[1, 4], [5, 6]])\n; b = np.array([[4, 1], [2, 2]])\n; np.vdot(a, b)\n30\n; np.vdot(b, a)\n30\n; 1*4 + 4*1 + 5*2 + 6*2\n30\n\n", "; a = np.array([[1, 4], [5, 6]])\n; b = np.array([[4, 1], [2, 2]])\n; np.vdot(a, b)\n30\n; np.vdot(b, a)\n30\n; 1*4 + 4*1 + 5*2 + 6*2\n30\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.variable", "code": "\nproperty poly1d.variable\u00b6", "description": "The name of the polynomial variable\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.vectorize", "code": "\nclass numpy.vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False, signature=None)[source]\u00b6", "description": "Generalized function class.\nDefine a vectorized function which takes a nested sequence of objects or\nnumpy arrays as inputs and returns a single numpy array or a tuple of numpy\narrays. The vectorized function evaluates pyfunc over successive tuples\nof the input arrays like the python map function, except it uses the\nbroadcasting rules of numpy.\nThe data type of the output of vectorized is determined by calling\nthe function with the first element of the input.  This can be avoided\nby specifying the otypes argument.\n\nParameters\n\npyfunccallableA python function or method.\n\notypesstr or list of dtypes, optionalThe output data type. It must be specified as either a string of\ntypecode characters or a list of data type specifiers. There should\nbe one data type specifier for each output.\n\ndocstr, optionalThe docstring for the function. If None, the docstring will be the\npyfunc.__doc__.\n\nexcludedset, optionalSet of strings or integers representing the positional or keyword\narguments for which the function will not be vectorized.  These will be\npassed directly to pyfunc unmodified.\n\nNew in version 1.7.0.\n\n\ncachebool, optionalIf True, then cache the first function call that determines the number\nof outputs if otypes is not provided.\n\n\nNew in version 1.7.0.\n\n\n\nsignaturestring, optionalGeneralized universal function signature, e.g., (m,n),(n)-&gt;(m) for\nvectorized matrix-vector multiplication. If provided, pyfunc will\nbe called with (and expected to return) arrays with shapes given by the\nsize of corresponding core dimensions. By default, pyfunc is\nassumed to take scalars as input and output.\n\nNew in version 1.12.0.\n\n\n\n\nReturns\n\nvectorizedcallableVectorized function.\n\n\n\n\n\nSee also\n\nfrompyfuncTakes an arbitrary Python function and returns a ufunc\n\n\n\nNotes\nThe vectorize function is provided primarily for convenience, not for\nperformance. The implementation is essentially a for loop.\nIf otypes is not specified, then a call to the function with the\nfirst argument will be used to determine the number of outputs.  The\nresults of this call will be cached if cache is True to prevent\ncalling the function twice.  However, to implement the cache, the\noriginal function must be wrapped which will slow down subsequent\ncalls, so only do this if your function is expensive.\nThe new keyword argument interface and excluded argument support\nfurther degrades performance.\nReferences\n\nR5cc1f1f25381-1\nNumPy Reference, section Generalized Universal Function API.\n\n\nExamples\n&gt;&gt;&gt; def myfunc(a, b):\n...     \"Return a-b if a&gt;b, otherwise return a+b\"\n...     if a &gt; b:\n...         return a - b\n...     else:\n...         return a + b\n\n\n&gt;&gt;&gt; vfunc = np.vectorize(myfunc)\n&gt;&gt;&gt; vfunc([1, 2, 3, 4], 2)\narray([3, 4, 1, 2])\n\n\nThe docstring is taken from the input function to vectorize unless it\nis specified:\n&gt;&gt;&gt; vfunc.__doc__\n'Return a-b if a&gt;b, otherwise return a+b'\n&gt;&gt;&gt; vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n&gt;&gt;&gt; vfunc.__doc__\n'Vectorized `myfunc`'\n\n\nThe output type is determined by evaluating the first element of the input,\nunless it is specified:\n&gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)\n&gt;&gt;&gt; type(out[0])\n&lt;class 'numpy.int64'&gt;\n&gt;&gt;&gt; vfunc = np.vectorize(myfunc, otypes=[float])\n&gt;&gt;&gt; out = vfunc([1, 2, 3, 4], 2)\n&gt;&gt;&gt; type(out[0])\n&lt;class 'numpy.float64'&gt;\n\n\nThe excluded argument can be used to prevent vectorizing over certain\narguments.  This can be useful for array-like arguments of a fixed length\nsuch as the coefficients for a polynomial as in polyval:\n&gt;&gt;&gt; def mypolyval(p, x):\n...     _p = list(p)\n...     res = _p.pop(0)\n...     while _p:\n...         res = res*x + _p.pop(0)\n...     return res\n&gt;&gt;&gt; vpolyval = np.vectorize(mypolyval, excluded=['p'])\n&gt;&gt;&gt; vpolyval(p=[1, 2, 3], x=[0, 1])\narray([3, 6])\n\n\nPositional arguments may also be excluded by specifying their position:\n&gt;&gt;&gt; vpolyval.excluded.add(0)\n&gt;&gt;&gt; vpolyval([1, 2, 3], x=[0, 1])\narray([3, 6])\n\n\nThe signature argument allows for vectorizing functions that act on\nnon-scalar arrays of fixed length. For example, you can use it for a\nvectorized calculation of Pearson correlation coefficient and its p-value:\n&gt;&gt;&gt; import scipy.stats\n&gt;&gt;&gt; pearsonr = np.vectorize(scipy.stats.pearsonr,\n...                 signature='(n),(n)-&gt;(),()')\n&gt;&gt;&gt; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n(array([ 1., -1.]), array([ 0.,  0.]))\n\n\nOr for a vectorized convolution:\n&gt;&gt;&gt; convolve = np.vectorize(np.convolve, signature='(n),(m)-&gt;(k)')\n&gt;&gt;&gt; convolve(np.eye(4), [1, 2, 1])\narray([[1., 2., 1., 0., 0., 0.],\n       [0., 1., 2., 1., 0., 0.],\n       [0., 0., 1., 2., 1., 0.],\n       [0., 0., 0., 1., 2., 1.]])\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0\\*args,\u00a0\\*\\*kwargs)\nReturn arrays with the results of pyfunc broadcast (vectorized) over args and kwargs not in excluded.\n\n\n\n", "parameters": ["Parameters", "pyfunccallable", "otypesstr or list of dtypes, optional", "docstr, optional", "excludedset, optional", "cachebool, optional", "signaturestring, optional", "Returns", "vectorizedcallable"], "returns": "vectorizedcallableVectorized function.", "examples": ["; def myfunc(a, b):\n...     \"Return a-b if a&gt;b, otherwise return a+b\"\n...     if a &gt; b:\n...         return a - b\n...     else:\n...         return a + b\n\n", "; def myfunc(a, b):\n...     \"Return a-b if a&gt;b, otherwise return a+b\"\n...     if a &gt; b:\n...         return a - b\n...     else:\n...         return a + b\n", "; vfunc = np.vectorize(myfunc)\n; vfunc([1, 2, 3, 4], 2)\narray([3, 4, 1, 2])\n\n", "; vfunc = np.vectorize(myfunc)\n; vfunc([1, 2, 3, 4], 2)\narray([3, 4, 1, 2])\n", "; vfunc.__doc__\n'Return a-b if a&gt;b, otherwise return a+b'\n; vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n; vfunc.__doc__\n'Vectorized `myfunc`'\n\n", "; vfunc.__doc__\n'Return a-b if a&gt;b, otherwise return a+b'\n; vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')\n; vfunc.__doc__\n'Vectorized `myfunc`'\n", "; out = vfunc([1, 2, 3, 4], 2)\n; type(out[0])\n&lt;class 'numpy.int64'&gt;\n; vfunc = np.vectorize(myfunc, otypes=[float])\n; out = vfunc([1, 2, 3, 4], 2)\n; type(out[0])\n&lt;class 'numpy.float64'&gt;\n\n", "; out = vfunc([1, 2, 3, 4], 2)\n; type(out[0])\n&lt;class 'numpy.int64'&gt;\n; vfunc = np.vectorize(myfunc, otypes=[float])\n; out = vfunc([1, 2, 3, 4], 2)\n; type(out[0])\n&lt;class 'numpy.float64'&gt;\n", "; def mypolyval(p, x):\n...     _p = list(p)\n...     res = _p.pop(0)\n...     while _p:\n...         res = res*x + _p.pop(0)\n...     return res\n; vpolyval = np.vectorize(mypolyval, excluded=['p'])\n; vpolyval(p=[1, 2, 3], x=[0, 1])\narray([3, 6])\n\n", "; def mypolyval(p, x):\n...     _p = list(p)\n...     res = _p.pop(0)\n...     while _p:\n...         res = res*x + _p.pop(0)\n...     return res\n; vpolyval = np.vectorize(mypolyval, excluded=['p'])\n; vpolyval(p=[1, 2, 3], x=[0, 1])\narray([3, 6])\n", "; vpolyval.excluded.add(0)\n; vpolyval([1, 2, 3], x=[0, 1])\narray([3, 6])\n\n", "; vpolyval.excluded.add(0)\n; vpolyval([1, 2, 3], x=[0, 1])\narray([3, 6])\n", "; import scipy.stats\n; pearsonr = np.vectorize(scipy.stats.pearsonr,\n...                 signature='(n),(n)-&gt;(),()')\n; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n(array([ 1., -1.]), array([ 0.,  0.]))\n\n", "; import scipy.stats\n; pearsonr = np.vectorize(scipy.stats.pearsonr,\n...                 signature='(n),(n)-&gt;(),()')\n; pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])\n(array([ 1., -1.]), array([ 0.,  0.]))\n", "; convolve = np.vectorize(np.convolve, signature='(n),(m)-&gt;(k)')\n; convolve(np.eye(4), [1, 2, 1])\narray([[1., 2., 1., 0., 0., 0.],\n       [0., 1., 2., 1., 0., 0.],\n       [0., 0., 1., 2., 1., 0.],\n       [0., 0., 0., 1., 2., 1.]])\n\n", "; convolve = np.vectorize(np.convolve, signature='(n),(m)-&gt;(k)')\n; convolve(np.eye(4), [1, 2, 1])\narray([[1., 2., 1., 0., 0., 0.],\n       [0., 1., 2., 1., 0., 0.],\n       [0., 0., 1., 2., 1., 0.],\n       [0., 0., 0., 1., 2., 1.]])\n"]},
{"library": "numpy", "item_id": "numpy.record.var", "code": "\nrecord.var()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.var", "code": "\nndarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the variance of the array elements, along given axis.\nRefer to numpy.var for full documentation.\n\nSee also\n\nnumpy.varequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.var", "code": "\nmemmap.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the variance of the array elements, along given axis.\nRefer to numpy.var for full documentation.\n\nSee also\n\nnumpy.varequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.var", "code": "\nmatrix.var(self, axis=None, dtype=None, out=None, ddof=0)[source]\u00b6", "description": "Returns the variance of the matrix elements, along the given axis.\nRefer to numpy.var for full documentation.\n\nSee also\nnumpy.var\n\nNotes\nThis is the same as ndarray.var, except that where an ndarray would\nbe returned, a matrix object is returned instead.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4)))\n&gt;&gt;&gt; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.var()\n11.916666666666666\n&gt;&gt;&gt; x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary\n&gt;&gt;&gt; x.var(1)\nmatrix([[1.25],\n        [1.25],\n        [1.25]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.var()\n11.916666666666666\n; x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary\n; x.var(1)\nmatrix([[1.25],\n        [1.25],\n        [1.25]])\n\n", "; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.var()\n11.916666666666666\n; x.var(0)\nmatrix([[ 10.66666667,  10.66666667,  10.66666667,  10.66666667]]) # may vary\n; x.var(1)\nmatrix([[1.25],\n        [1.25],\n        [1.25]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.var", "code": "\nMaskType.var()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.var", "code": "\nMaskedArray.var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the variance along the specified axis.\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n\nParameters\n\naarray_likeArray containing numbers whose variance is desired.  If a is not an\narray, a conversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before.\n\ndtypedata-type, optionalType to use in computing the variance.  For arrays of integer type\nthe default is float64; for arrays of float types it is the same as\nthe array type.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary.\n\nddofint, optional\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is\nN - ddof, where N represents the number of elements. By\ndefault ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the var method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nvariancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;\notherwise, a reference to the output array is returned.\n\n\n\n\n\nSee also\nstd, mean, nanmean, nanstd, nanvar, ufuncs-output-type\n\nNotes\nThe variance is the average of the squared deviations from the mean,\ni.e.,  var = mean(abs(x - x.mean())**2).\nThe mean is normally calculated as x.sum() / N, where N = len(x).\nIf, however, ddof is specified, the divisor N - ddof is used\ninstead.  In standard statistical practice, ddof=1 provides an\nunbiased estimator of the variance of a hypothetical infinite population.\nddof=0 provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.var(a)\n1.25\n&gt;&gt;&gt; np.var(a, axis=0)\narray([1.,  1.])\n&gt;&gt;&gt; np.var(a, axis=1)\narray([0.25,  0.25])\n\n\nIn single precision, var() can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.var(a)\n0.20250003\n\n\nComputing the variance in float64 is more accurate:\n&gt;&gt;&gt; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "variancendarray, see dtype parameter above"], "returns": "variancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n"]},
{"library": "numpy", "item_id": "numpy.recarray.var", "code": "\nrecarray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the variance of the array elements, along given axis.\nRefer to numpy.var for full documentation.\n\nSee also\n\nnumpy.varequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.var", "code": "\nmasked_array.var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the variance along the specified axis.\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n\nParameters\n\naarray_likeArray containing numbers whose variance is desired.  If a is not an\narray, a conversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before.\n\ndtypedata-type, optionalType to use in computing the variance.  For arrays of integer type\nthe default is float64; for arrays of float types it is the same as\nthe array type.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary.\n\nddofint, optional\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is\nN - ddof, where N represents the number of elements. By\ndefault ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the var method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nvariancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;\notherwise, a reference to the output array is returned.\n\n\n\n\n\nSee also\nstd, mean, nanmean, nanstd, nanvar, ufuncs-output-type\n\nNotes\nThe variance is the average of the squared deviations from the mean,\ni.e.,  var = mean(abs(x - x.mean())**2).\nThe mean is normally calculated as x.sum() / N, where N = len(x).\nIf, however, ddof is specified, the divisor N - ddof is used\ninstead.  In standard statistical practice, ddof=1 provides an\nunbiased estimator of the variance of a hypothetical infinite population.\nddof=0 provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.var(a)\n1.25\n&gt;&gt;&gt; np.var(a, axis=0)\narray([1.,  1.])\n&gt;&gt;&gt; np.var(a, axis=1)\narray([0.25,  0.25])\n\n\nIn single precision, var() can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.var(a)\n0.20250003\n\n\nComputing the variance in float64 is more accurate:\n&gt;&gt;&gt; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "variancendarray, see dtype parameter above"], "returns": "variancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n"]},
{"library": "numpy", "item_id": "numpy.generic.var", "code": "\ngeneric.var()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.var", "code": "\nchararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the variance of the array elements, along given axis.\nRefer to numpy.var for full documentation.\n\nSee also\n\nnumpy.varequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.var", "code": "\nchararray.var(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the variance of the array elements, along given axis.\nRefer to numpy.var for full documentation.\n\nSee also\n\nnumpy.varequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.var", "code": "\nnumpy.var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the variance along the specified axis.\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n\nParameters\n\naarray_likeArray containing numbers whose variance is desired.  If a is not an\narray, a conversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before.\n\ndtypedata-type, optionalType to use in computing the variance.  For arrays of integer type\nthe default is float64; for arrays of float types it is the same as\nthe array type.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary.\n\nddofint, optional\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is\nN - ddof, where N represents the number of elements. By\ndefault ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the var method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nvariancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;\notherwise, a reference to the output array is returned.\n\n\n\n\n\nSee also\nstd, mean, nanmean, nanstd, nanvar, ufuncs-output-type\n\nNotes\nThe variance is the average of the squared deviations from the mean,\ni.e.,  var = mean(abs(x - x.mean())**2).\nThe mean is normally calculated as x.sum() / N, where N = len(x).\nIf, however, ddof is specified, the divisor N - ddof is used\ninstead.  In standard statistical practice, ddof=1 provides an\nunbiased estimator of the variance of a hypothetical infinite population.\nddof=0 provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.var(a)\n1.25\n&gt;&gt;&gt; np.var(a, axis=0)\narray([1.,  1.])\n&gt;&gt;&gt; np.var(a, axis=1)\narray([0.25,  0.25])\n\n\nIn single precision, var() can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.var(a)\n0.20250003\n\n\nComputing the variance in float64 is more accurate:\n&gt;&gt;&gt; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "variancendarray, see dtype parameter above"], "returns": "variancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n"]},
{"library": "numpy", "item_id": "numpy.ma.var", "code": "\nnumpy.ma.var(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Compute the variance along the specified axis.\nReturns the variance of the array elements, a measure of the spread of a\ndistribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\n\nParameters\n\naarray_likeArray containing numbers whose variance is desired.  If a is not an\narray, a conversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the variance is computed.  The default is to\ncompute the variance of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a variance is performed over multiple axes,\ninstead of a single axis or all the axes as before.\n\ndtypedata-type, optionalType to use in computing the variance.  For arrays of integer type\nthe default is float64; for arrays of float types it is the same as\nthe array type.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary.\n\nddofint, optional\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is\nN - ddof, where N represents the number of elements. By\ndefault ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the var method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nvariancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;\notherwise, a reference to the output array is returned.\n\n\n\n\n\nSee also\nstd, mean, nanmean, nanstd, nanvar, ufuncs-output-type\n\nNotes\nThe variance is the average of the squared deviations from the mean,\ni.e.,  var = mean(abs(x - x.mean())**2).\nThe mean is normally calculated as x.sum() / N, where N = len(x).\nIf, however, ddof is specified, the divisor N - ddof is used\ninstead.  In standard statistical practice, ddof=1 provides an\nunbiased estimator of the variance of a hypothetical infinite population.\nddof=0 provides a maximum likelihood estimate of the variance for\nnormally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.var(a)\n1.25\n&gt;&gt;&gt; np.var(a, axis=0)\narray([1.,  1.])\n&gt;&gt;&gt; np.var(a, axis=1)\narray([0.25,  0.25])\n\n\nIn single precision, var() can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.var(a)\n0.20250003\n\n\nComputing the variance in float64 is more accurate:\n&gt;&gt;&gt; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n&gt;&gt;&gt; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "variancendarray, see dtype parameter above"], "returns": "variancendarray, see dtype parameter aboveIf out=None, returns a new array containing the variance;otherwise, a reference to the output array is returned.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.var(a)\n1.25\n; np.var(a, axis=0)\narray([1.,  1.])\n; np.var(a, axis=1)\narray([0.25,  0.25])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.var(a)\n0.20250003\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n\n", "; np.var(a, dtype=np.float64)\n0.20249999932944759 # may vary\n; ((1-0.55)**2 + (0.1-0.55)**2)/2\n0.2025\n"]},
{"library": "numpy", "item_id": "numpy.ma.vander", "code": "\nnumpy.ma.vander(x, n=None)[source]\u00b6", "description": "Generate a Vandermonde matrix.\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the increasing boolean argument.\nSpecifically, when increasing is False, the i-th output column is\nthe input vector raised element-wise to the power of N - i - 1. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.\n\nParameters\n\nxarray_like1-D input array.\n\nNint, optionalNumber of columns in the output.  If N is not specified, a square\narray is returned (N = len(x)).\n\nincreasingbool, optionalOrder of the powers of the columns.  If True, the powers increase\nfrom left to right, if False (the default) they are reversed.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\noutndarrayVandermonde matrix.  If increasing is False, the first column is\nx^(N-1), the second x^(N-2) and so forth. If increasing is\nTrue, the columns are x^0, x^1, ..., x^(N-1).\n\n\n\n\n\nSee also\npolynomial.polynomial.polyvander\n\nNotes\nMasked values in the input array result in rows of zeros.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 5])\n&gt;&gt;&gt; N = 3\n&gt;&gt;&gt; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n\n&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n\n&gt;&gt;&gt; x = np.array([1, 2, 3, 5])\n&gt;&gt;&gt; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n&gt;&gt;&gt; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\n\nThe determinant of a square Vandermonde matrix is the product\nof the differences between the values of the input vector:\n&gt;&gt;&gt; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n&gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n\n\n", "parameters": ["Parameters", "xarray_like", "Nint, optional", "increasingbool, optional", "Returns", "outndarray"], "returns": "outndarrayVandermonde matrix.  If increasing is False, the first column isx^(N-1), the second x^(N-2) and so forth. If increasing isTrue, the columns are x^0, x^1, ..., x^(N-1).", "examples": ["; x = np.array([1, 2, 3, 5])\n; N = 3\n; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n", "; x = np.array([1, 2, 3, 5])\n; N = 3\n; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n", "; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n", "; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n", "; x = np.array([1, 2, 3, 5])\n; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\n", "; x = np.array([1, 2, 3, 5])\n; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n", "; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n\n", "; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n"]},
{"library": "numpy", "item_id": "numpy.vander", "code": "\nnumpy.vander(x, N=None, increasing=False)[source]\u00b6", "description": "Generate a Vandermonde matrix.\nThe columns of the output matrix are powers of the input vector. The\norder of the powers is determined by the increasing boolean argument.\nSpecifically, when increasing is False, the i-th output column is\nthe input vector raised element-wise to the power of N - i - 1. Such\na matrix with a geometric progression in each row is named for Alexandre-\nTheophile Vandermonde.\n\nParameters\n\nxarray_like1-D input array.\n\nNint, optionalNumber of columns in the output.  If N is not specified, a square\narray is returned (N = len(x)).\n\nincreasingbool, optionalOrder of the powers of the columns.  If True, the powers increase\nfrom left to right, if False (the default) they are reversed.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\noutndarrayVandermonde matrix.  If increasing is False, the first column is\nx^(N-1), the second x^(N-2) and so forth. If increasing is\nTrue, the columns are x^0, x^1, ..., x^(N-1).\n\n\n\n\n\nSee also\npolynomial.polynomial.polyvander\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 5])\n&gt;&gt;&gt; N = 3\n&gt;&gt;&gt; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n\n&gt;&gt;&gt; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n\n&gt;&gt;&gt; x = np.array([1, 2, 3, 5])\n&gt;&gt;&gt; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n&gt;&gt;&gt; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\n\nThe determinant of a square Vandermonde matrix is the product\nof the differences between the values of the input vector:\n&gt;&gt;&gt; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n&gt;&gt;&gt; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n\n\n", "parameters": ["Parameters", "xarray_like", "Nint, optional", "increasingbool, optional", "Returns", "outndarray"], "returns": "outndarrayVandermonde matrix.  If increasing is False, the first column isx^(N-1), the second x^(N-2) and so forth. If increasing isTrue, the columns are x^0, x^1, ..., x^(N-1).", "examples": ["; x = np.array([1, 2, 3, 5])\n; N = 3\n; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n", "; x = np.array([1, 2, 3, 5])\n; N = 3\n; np.vander(x, N)\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n", "; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n\n", "; np.column_stack([x**(N-1-i) for i in range(N)])\narray([[ 1,  1,  1],\n       [ 4,  2,  1],\n       [ 9,  3,  1],\n       [25,  5,  1]])\n", "; x = np.array([1, 2, 3, 5])\n; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n\n", "; x = np.array([1, 2, 3, 5])\n; np.vander(x)\narray([[  1,   1,   1,   1],\n       [  8,   4,   2,   1],\n       [ 27,   9,   3,   1],\n       [125,  25,   5,   1]])\n; np.vander(x, increasing=True)\narray([[  1,   1,   1,   1],\n       [  1,   2,   4,   8],\n       [  1,   3,   9,  27],\n       [  1,   5,  25, 125]])\n", "; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n\n", "; np.linalg.det(np.vander(x))\n48.000000000000043 # may vary\n; (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1)\n48\n"]},
{"library": "numpy", "item_id": "numpy.nditer.value", "code": "\nnditer.value\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.upper", "code": "\nchararray.upper(self)[source]\u00b6", "description": "Return an array with the elements of self converted to\nuppercase.\n\nSee also\nchar.upper\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.upper", "code": "\nchararray.upper(self)\u00b6", "description": "Return an array with the elements of self converted to\nuppercase.\n\nSee also\nchar.upper\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.upper", "code": "\nnumpy.char.upper(a)\u00b6", "description": "Return an array with the elements converted to uppercase.\nCalls str.upper element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like, {str, unicode}Input array.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.upper\n\nExamples\n&gt;&gt;&gt; c = np.array(['a1b c', '1bca', 'bca1']); c\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n&gt;&gt;&gt; np.char.upper(c)\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type", "examples": ["; c = np.array(['a1b c', '1bca', 'bca1']); c\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n; np.char.upper(c)\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n\n", "; c = np.array(['a1b c', '1bca', 'bca1']); c\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n; np.char.upper(c)\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n"]},
{"library": "numpy", "item_id": "numpy.unwrap", "code": "\nnumpy.unwrap(p, discont=3.141592653589793, axis=-1)[source]\u00b6", "description": "Unwrap by changing deltas between values to 2*pi complement.\nUnwrap radian phase p by changing absolute jumps greater than\ndiscont to their 2*pi complement along the given axis.\n\nParameters\n\nparray_likeInput array.\n\ndiscontfloat, optionalMaximum discontinuity between values, default is pi.\n\naxisint, optionalAxis along which unwrap will operate, default is the last axis.\n\n\n\nReturns\n\noutndarrayOutput array.\n\n\n\n\n\nSee also\nrad2deg, deg2rad\n\nNotes\nIf the discontinuity in p is smaller than pi, but larger than\ndiscont, no unwrapping is done because taking the 2*pi complement\nwould only make the discontinuity larger.\nExamples\n&gt;&gt;&gt; phase = np.linspace(0, np.pi, num=5)\n&gt;&gt;&gt; phase[3:] += np.pi\n&gt;&gt;&gt; phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n&gt;&gt;&gt; np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n\n\n", "parameters": ["Parameters", "parray_like", "discontfloat, optional", "axisint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array.", "examples": ["; phase = np.linspace(0, np.pi, num=5)\n; phase[3:] += np.pi\n; phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n; np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n\n", "; phase = np.linspace(0, np.pi, num=5)\n; phase[3:] += np.pi\n; phase\narray([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary\n; np.unwrap(phase)\narray([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.unshare_mask", "code": "\nMaskedArray.unshare_mask(self)[source]\u00b6", "description": "Copy the mask and set the sharedmask flag to False.\nWhether the mask is shared between masked arrays can be seen from\nthe sharedmask property. unshare_mask ensures the mask is not shared.\nA copy of the mask is only made if it was shared.\n\nSee also\nsharedmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.unshare_mask", "code": "\nmasked_array.unshare_mask(self)[source]\u00b6", "description": "Copy the mask and set the sharedmask flag to False.\nWhether the mask is shared between masked arrays can be seen from\nthe sharedmask property. unshare_mask ensures the mask is not shared.\nA copy of the mask is only made if it was shared.\n\nSee also\nsharedmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.unravel_index", "code": "\nnumpy.unravel_index(indices, shape, order='C')\u00b6", "description": "Converts a flat index or array of flat indices into a tuple\nof coordinate arrays.\n\nParameters\n\nindicesarray_likeAn integer array whose elements are indices into the flattened\nversion of an array of dimensions shape. Before version 1.6.0,\nthis function accepted just one index value.\n\nshapetuple of intsThe shape of the array to use for unraveling indices.\n\nChanged in version 1.16.0: Renamed from dims to shape.\n\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalDetermines whether the indices should be viewed as indexing in\nrow-major (C-style) or column-major (Fortran-style) order.\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nunraveled_coordstuple of ndarrayEach array in the tuple has the same shape as the indices\narray.\n\n\n\n\n\nSee also\nravel_multi_index\n\nExamples\n&gt;&gt;&gt; np.unravel_index([22, 41, 37], (7,6))\n(array([3, 6, 6]), array([4, 5, 1]))\n&gt;&gt;&gt; np.unravel_index([31, 41, 13], (7,6), order='F')\n(array([3, 6, 6]), array([4, 5, 1]))\n\n\n&gt;&gt;&gt; np.unravel_index(1621, (6,7,8,9))\n(3, 1, 4, 1)\n\n\n", "parameters": ["Parameters", "indicesarray_like", "shapetuple of ints", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "unraveled_coordstuple of ndarray"], "returns": "unraveled_coordstuple of ndarrayEach array in the tuple has the same shape as the indicesarray.", "examples": ["; np.unravel_index([22, 41, 37], (7,6))\n(array([3, 6, 6]), array([4, 5, 1]))\n; np.unravel_index([31, 41, 13], (7,6), order='F')\n(array([3, 6, 6]), array([4, 5, 1]))\n\n", "; np.unravel_index([22, 41, 37], (7,6))\n(array([3, 6, 6]), array([4, 5, 1]))\n; np.unravel_index([31, 41, 13], (7,6), order='F')\n(array([3, 6, 6]), array([4, 5, 1]))\n", "; np.unravel_index(1621, (6,7,8,9))\n(3, 1, 4, 1)\n\n", "; np.unravel_index(1621, (6,7,8,9))\n(3, 1, 4, 1)\n"]},
{"library": "numpy", "item_id": "numpy.unpackbits", "code": "\nnumpy.unpackbits(a, axis=None, count=None, bitorder='big')\u00b6", "description": "Unpacks elements of a uint8 array into a binary-valued output array.\nEach element of a represents a bit-field that should be unpacked\ninto a binary-valued output array. The shape of the output array is\neither 1-D (if axis is None) or the same shape as the input\narray with unpacking done along the axis specified.\n\nParameters\n\nandarray, uint8 typeInput array.\n\naxisint, optionalThe dimension over which bit-unpacking is done.\nNone implies unpacking the flattened array.\n\ncountint or None, optionalThe number of elements to unpack along axis, provided as a way\nof undoing the effect of packing a size that is not a multiple\nof eight. A non-negative number means to only unpack count\nbits. A negative number means to trim off that many bits from\nthe end. None means to unpack the entire array (the\ndefault). Counts larger than the available number of bits will\nadd zero padding to the output. Negative counts must not\nexceed the available number of bits.\n\nNew in version 1.17.0.\n\n\nbitorder{\u2018big\u2019, \u2018little\u2019}, optionalThe order of the returned bits. \u2018big\u2019 will mimic bin(val),\n3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1], \u2018little\u2019 will reverse\nthe order to [1, 1, 0, 0, 0, 0, 0, 0].\nDefaults to \u2018big\u2019.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nunpackedndarray, uint8 typeThe elements are binary-valued (0 or 1).\n\n\n\n\n\nSee also\n\npackbitsPacks the elements of a binary-valued array into bits in a uint8 array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[2], [7], [23]], dtype=np.uint8)\n&gt;&gt;&gt; a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n&gt;&gt;&gt; b = np.unpackbits(a, axis=1)\n&gt;&gt;&gt; b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n&gt;&gt;&gt; c = np.unpackbits(a, axis=1, count=-3)\n&gt;&gt;&gt; c\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0]], dtype=uint8)\n\n\n&gt;&gt;&gt; p = np.packbits(b, axis=0)\n&gt;&gt;&gt; np.unpackbits(p, axis=0)\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n&gt;&gt;&gt; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))\nTrue\n\n\n", "parameters": ["Parameters", "andarray, uint8 type", "axisint, optional", "countint or None, optional", "bitorder{\u2018big\u2019, \u2018little\u2019}, optional", "Returns", "unpackedndarray, uint8 type"], "returns": "unpackedndarray, uint8 typeThe elements are binary-valued (0 or 1).", "examples": ["; a = np.array([[2], [7], [23]], dtype=np.uint8)\n; a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n; b = np.unpackbits(a, axis=1)\n; b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n; c = np.unpackbits(a, axis=1, count=-3)\n; c\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0]], dtype=uint8)\n\n", "; a = np.array([[2], [7], [23]], dtype=np.uint8)\n; a\narray([[ 2],\n       [ 7],\n       [23]], dtype=uint8)\n; b = np.unpackbits(a, axis=1)\n; b\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)\n; c = np.unpackbits(a, axis=1, count=-3)\n; c\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0],\n       [0, 0, 0, 1, 0]], dtype=uint8)\n", "; p = np.packbits(b, axis=0)\n; np.unpackbits(p, axis=0)\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))\nTrue\n\n", "; p = np.packbits(b, axis=0)\n; np.unpackbits(p, axis=0)\narray([[0, 0, 0, 0, 0, 0, 1, 0],\n       [0, 0, 0, 0, 0, 1, 1, 1],\n       [0, 0, 0, 1, 0, 1, 1, 1],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)\n; np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.union1d", "code": "\nnumpy.union1d(ar1, ar2)[source]\u00b6", "description": "Find the union of two arrays.\nReturn the unique, sorted array of values that are in either of the two\ninput arrays.\n\nParameters\n\nar1, ar2array_likeInput arrays. They are flattened if they are not already 1D.\n\n\n\nReturns\n\nunion1dndarrayUnique, sorted union of the input arrays.\n\n\n\n\n\nSee also\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nExamples\n&gt;&gt;&gt; np.union1d([-1, 0, 1], [-2, 0, 2])\narray([-2, -1,  0,  1,  2])\n\n\nTo find the union of more than two arrays, use functools.reduce:\n&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([1, 2, 3, 4, 6])\n\n\n", "parameters": ["Parameters", "ar1, ar2array_like", "Returns", "union1dndarray"], "returns": "union1dndarrayUnique, sorted union of the input arrays.", "examples": ["; np.union1d([-1, 0, 1], [-2, 0, 2])\narray([-2, -1,  0,  1,  2])\n\n", "; np.union1d([-1, 0, 1], [-2, 0, 2])\narray([-2, -1,  0,  1,  2])\n", "; from functools import reduce\n; reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([1, 2, 3, 4, 6])\n\n", "; from functools import reduce\n; reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([1, 2, 3, 4, 6])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.uniform", "code": "\nRandomState.uniform(low=0.0, high=1.0, size=None)\u00b6", "description": "Draw samples from a uniform distribution.\nSamples are uniformly distributed over the half-open interval\n[low, high) (includes low, but excludes high).  In other words,\nany value within the given interval is equally likely to be drawn\nby uniform.\n\nNote\nNew code should use the uniform method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlowfloat or array_like of floats, optionalLower boundary of the output interval.  All values generated will be\ngreater than or equal to low.  The default value is 0.\n\nhighfloat or array_like of floatsUpper boundary of the output interval.  All values generated will be\nless than high.  The default value is 1.0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if low and high are both scalars.\nOtherwise, np.broadcast(low, high).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized uniform distribution.\n\n\n\n\n\nSee also\n\nrandintDiscrete uniform distribution, yielding integers.\n\nrandom_integersDiscrete uniform distribution over the closed interval [low, high].\n\nrandom_sampleFloats uniformly distributed over [0, 1).\n\nrandomAlias for random_sample.\n\nrandConvenience function that accepts dimensions as input, e.g., rand(2,2) would generate a 2-by-2 array of floats, uniformly distributed over [0, 1).\n\nGenerator.uniformwhich should be used for new code.\n\n\n\nNotes\nThe probability density function of the uniform distribution is\n\n\nanywhere within the interval [a, b), and zero elsewhere.\nWhen high == low, values of low will be returned.\nIf high &lt; low, the results are officially undefined\nand may eventually raise an error, i.e. do not rely on this\nfunction to behave when passed arguments satisfying that\ninequality condition.\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; s = np.random.uniform(-1,0,1000)\n\n\nAll values are within the given interval:\n&gt;&gt;&gt; np.all(s &gt;= -1)\nTrue\n&gt;&gt;&gt; np.all(s &lt; 0)\nTrue\n\n\nDisplay the histogram of the samples, along with the\nprobability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 15, density=True)\n&gt;&gt;&gt; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "lowfloat or array_like of floats, optional", "highfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized uniform distribution.", "examples": ["; s = np.random.uniform(-1,0,1000)\n\n", "; s = np.random.uniform(-1,0,1000)\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.uniform", "code": "\nGenerator.uniform(low=0.0, high=1.0, size=None)\u00b6", "description": "Draw samples from a uniform distribution.\nSamples are uniformly distributed over the half-open interval\n[low, high) (includes low, but excludes high).  In other words,\nany value within the given interval is equally likely to be drawn\nby uniform.\n\nParameters\n\nlowfloat or array_like of floats, optionalLower boundary of the output interval.  All values generated will be\ngreater than or equal to low.  The default value is 0.\n\nhighfloat or array_like of floatsUpper boundary of the output interval.  All values generated will be\nless than high.  The default value is 1.0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if low and high are both scalars.\nOtherwise, np.broadcast(low, high).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized uniform distribution.\n\n\n\n\n\nSee also\n\nintegersDiscrete uniform distribution, yielding integers.\n\nrandomFloats uniformly distributed over [0, 1).\n\n\n\nNotes\nThe probability density function of the uniform distribution is\n\n\nanywhere within the interval [a, b), and zero elsewhere.\nWhen high == low, values of low will be returned.\nIf high &lt; low, the results are officially undefined\nand may eventually raise an error, i.e. do not rely on this\nfunction to behave when passed arguments satisfying that\ninequality condition.\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; s = np.random.default_rng().uniform(-1,0,1000)\n\n\nAll values are within the given interval:\n&gt;&gt;&gt; np.all(s &gt;= -1)\nTrue\n&gt;&gt;&gt; np.all(s &lt; 0)\nTrue\n\n\nDisplay the histogram of the samples, along with the\nprobability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 15, density=True)\n&gt;&gt;&gt; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "lowfloat or array_like of floats, optional", "highfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized uniform distribution.", "examples": ["; s = np.random.default_rng().uniform(-1,0,1000)\n\n", "; s = np.random.default_rng().uniform(-1,0,1000)\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.uniform", "code": "\nnumpy.random.uniform(low=0.0, high=1.0, size=None)\u00b6", "description": "Draw samples from a uniform distribution.\nSamples are uniformly distributed over the half-open interval\n[low, high) (includes low, but excludes high).  In other words,\nany value within the given interval is equally likely to be drawn\nby uniform.\n\nNote\nNew code should use the uniform method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlowfloat or array_like of floats, optionalLower boundary of the output interval.  All values generated will be\ngreater than or equal to low.  The default value is 0.\n\nhighfloat or array_like of floatsUpper boundary of the output interval.  All values generated will be\nless than high.  The default value is 1.0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if low and high are both scalars.\nOtherwise, np.broadcast(low, high).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized uniform distribution.\n\n\n\n\n\nSee also\n\nrandintDiscrete uniform distribution, yielding integers.\n\nrandom_integersDiscrete uniform distribution over the closed interval [low, high].\n\nrandom_sampleFloats uniformly distributed over [0, 1).\n\nrandomAlias for random_sample.\n\nrandConvenience function that accepts dimensions as input, e.g., rand(2,2) would generate a 2-by-2 array of floats, uniformly distributed over [0, 1).\n\nGenerator.uniformwhich should be used for new code.\n\n\n\nNotes\nThe probability density function of the uniform distribution is\n\n\nanywhere within the interval [a, b), and zero elsewhere.\nWhen high == low, values of low will be returned.\nIf high &lt; low, the results are officially undefined\nand may eventually raise an error, i.e. do not rely on this\nfunction to behave when passed arguments satisfying that\ninequality condition.\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; s = np.random.uniform(-1,0,1000)\n\n\nAll values are within the given interval:\n&gt;&gt;&gt; np.all(s &gt;= -1)\nTrue\n&gt;&gt;&gt; np.all(s &lt; 0)\nTrue\n\n\nDisplay the histogram of the samples, along with the\nprobability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 15, density=True)\n&gt;&gt;&gt; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "lowfloat or array_like of floats, optional", "highfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized uniform distribution.", "examples": ["; s = np.random.uniform(-1,0,1000)\n\n", "; s = np.random.uniform(-1,0,1000)\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n\n", "; np.all(s &gt;= -1)\nTrue\n; np.all(s &lt; 0)\nTrue\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 15, density=True)\n; plt.plot(bins, np.ones_like(bins), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.unique", "code": "\nnumpy.unique(ar, return_index=False, return_inverse=False, return_counts=False, axis=None)[source]\u00b6", "description": "Find the unique elements of an array.\nReturns the sorted unique elements of an array. There are three optional\noutputs in addition to the unique elements:\n\nthe indices of the input array that give the unique values\nthe indices of the unique array that reconstruct the input array\nthe number of times each unique value comes up in the input array\n\n\nParameters\n\nararray_likeInput array. Unless axis is specified, this will be flattened if it\nis not already 1-D.\n\nreturn_indexbool, optionalIf True, also return the indices of ar (along the specified axis,\nif provided, or in the flattened array) that result in the unique array.\n\nreturn_inversebool, optionalIf True, also return the indices of the unique array (for the specified\naxis, if provided) that can be used to reconstruct ar.\n\nreturn_countsbool, optionalIf True, also return the number of times each unique item appears\nin ar.\n\nNew in version 1.9.0.\n\n\naxisint or None, optionalThe axis to operate on. If None, ar will be flattened. If an integer,\nthe subarrays indexed by the given axis will be flattened and treated\nas the elements of a 1-D array with the dimension of the given axis,\nsee the notes for more details.  Object arrays or structured arrays\nthat contain objects are not supported if the axis kwarg is used. The\ndefault is None.\n\nNew in version 1.13.0.\n\n\n\n\nReturns\n\nuniquendarrayThe sorted unique values.\n\nunique_indicesndarray, optionalThe indices of the first occurrences of the unique values in the\noriginal array. Only provided if return_index is True.\n\nunique_inversendarray, optionalThe indices to reconstruct the original array from the\nunique array. Only provided if return_inverse is True.\n\nunique_countsndarray, optionalThe number of times each of the unique values comes up in the\noriginal array. Only provided if return_counts is True.\n\nNew in version 1.9.0.\n\n\n\n\n\n\nSee also\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nNotes\nWhen an axis is specified the subarrays indexed by the axis are sorted.\nThis is done by making the specified axis the first dimension of the array\n(move the axis to the first dimension to keep the order of the other axes)\nand then flattening the subarrays in C order. The flattened subarrays are\nthen viewed as a structured type with each element given a label, with the\neffect that we end up with a 1-D array of structured types that can be\ntreated in the same way as any other 1-D array. The result is that the\nflattened subarrays are sorted in lexicographic order starting with the\nfirst element.\nExamples\n&gt;&gt;&gt; np.unique([1, 1, 2, 2, 3, 3])\narray([1, 2, 3])\n&gt;&gt;&gt; a = np.array([[1, 1], [2, 3]])\n&gt;&gt;&gt; np.unique(a)\narray([1, 2, 3])\n\n\nReturn the unique rows of a 2D array\n&gt;&gt;&gt; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])\n&gt;&gt;&gt; np.unique(a, axis=0)\narray([[1, 0, 0], [2, 3, 4]])\n\n\nReturn the indices of the original array that give the unique values:\n&gt;&gt;&gt; a = np.array(['a', 'b', 'b', 'c', 'a'])\n&gt;&gt;&gt; u, indices = np.unique(a, return_index=True)\n&gt;&gt;&gt; u\narray(['a', 'b', 'c'], dtype='&lt;U1')\n&gt;&gt;&gt; indices\narray([0, 1, 3])\n&gt;&gt;&gt; a[indices]\narray(['a', 'b', 'c'], dtype='&lt;U1')\n\n\nReconstruct the input array from the unique values:\n&gt;&gt;&gt; a = np.array([1, 2, 6, 4, 2, 3, 2])\n&gt;&gt;&gt; u, indices = np.unique(a, return_inverse=True)\n&gt;&gt;&gt; u\narray([1, 2, 3, 4, 6])\n&gt;&gt;&gt; indices\narray([0, 1, 4, ..., 1, 2, 1])\n&gt;&gt;&gt; u[indices]\narray([1, 2, 6, ..., 2, 3, 2])\n\n\n", "parameters": ["Parameters", "ararray_like", "return_indexbool, optional", "return_inversebool, optional", "return_countsbool, optional", "axisint or None, optional", "Returns", "uniquendarray", "unique_indicesndarray, optional", "unique_inversendarray, optional", "unique_countsndarray, optional"], "returns": "uniquendarrayThe sorted unique values.unique_indicesndarray, optionalThe indices of the first occurrences of the unique values in theoriginal array. Only provided if return_index is True.unique_inversendarray, optionalThe indices to reconstruct the original array from theunique array. Only provided if return_inverse is True.unique_countsndarray, optionalThe number of times each of the unique values comes up in theoriginal array. Only provided if return_counts is True.New in version 1.9.0.", "examples": ["; np.unique([1, 1, 2, 2, 3, 3])\narray([1, 2, 3])\n; a = np.array([[1, 1], [2, 3]])\n; np.unique(a)\narray([1, 2, 3])\n\n", "; np.unique([1, 1, 2, 2, 3, 3])\narray([1, 2, 3])\n; a = np.array([[1, 1], [2, 3]])\n; np.unique(a)\narray([1, 2, 3])\n", "; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])\n; np.unique(a, axis=0)\narray([[1, 0, 0], [2, 3, 4]])\n\n", "; a = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4]])\n; np.unique(a, axis=0)\narray([[1, 0, 0], [2, 3, 4]])\n", "; a = np.array(['a', 'b', 'b', 'c', 'a'])\n; u, indices = np.unique(a, return_index=True)\n; u\narray(['a', 'b', 'c'], dtype='&lt;U1')\n; indices\narray([0, 1, 3])\n; a[indices]\narray(['a', 'b', 'c'], dtype='&lt;U1')\n\n", "; a = np.array(['a', 'b', 'b', 'c', 'a'])\n; u, indices = np.unique(a, return_index=True)\n; u\narray(['a', 'b', 'c'], dtype='&lt;U1')\n; indices\narray([0, 1, 3])\n; a[indices]\narray(['a', 'b', 'c'], dtype='&lt;U1')\n", "; a = np.array([1, 2, 6, 4, 2, 3, 2])\n; u, indices = np.unique(a, return_inverse=True)\n; u\narray([1, 2, 3, 4, 6])\n; indices\narray([0, 1, 4, ..., 1, 2, 1])\n; u[indices]\narray([1, 2, 6, ..., 2, 3, 2])\n\n", "; a = np.array([1, 2, 6, 4, 2, 3, 2])\n; u, indices = np.unique(a, return_inverse=True)\n; u\narray([1, 2, 3, 4, 6])\n; indices\narray([0, 1, 4, ..., 1, 2, 1])\n; u[indices]\narray([1, 2, 6, ..., 2, 3, 2])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.truncate", "code": "\nLaguerre.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.truncate", "code": "\nHermiteE.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.truncate", "code": "\nHermite.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.truncate", "code": "\nChebyshev.truncate(self, size)[source]\u00b6", "description": "Truncate series to length size.\nReduce the series to length size by discarding the high\ndegree terms. The value of size must be a positive integer. This\ncan be useful in least squares where the coefficients of the\nhigh degree terms may be very small.\n\nParameters\n\nsizepositive intThe series is reduced to length size by discarding the high\ndegree terms. The value of size must be a positive integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with truncated coefficients.\n\n\n\n\n", "parameters": ["Parameters", "sizepositive int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with truncated coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.trunc", "code": "\nnumpy.trunc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'trunc'&gt;\u00b6", "description": "Return the truncated value of the input, element-wise.\nThe truncated value of the scalar x is the nearest integer i which\nis closer to zero than x is. In short, the fractional part of the\nsigned number x is discarded.\n\nParameters\n\nxarray_likeInput data.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe truncated value of each element in x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nceil, floor, rint\n\nNotes\n\nNew in version 1.3.0.\n\nExamples\n&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n&gt;&gt;&gt; np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe truncated value of each element in x.This is a scalar if x is a scalar.", "examples": ["; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])\n\n", "; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.trunc(a)\narray([-1., -1., -0.,  0.,  1.,  1.,  2.])\n"]},
{"library": "numpy", "item_id": "numpy.triu_indices_from", "code": "\nnumpy.triu_indices_from(arr, k=0)[source]\u00b6", "description": "Return the indices for the upper-triangle of arr.\nSee triu_indices for full details.\n\nParameters\n\narrndarray, shape(N, N)The indices will be valid for square arrays.\n\nkint, optionalDiagonal offset (see triu for details).\n\n\n\nReturns\n\ntriu_indices_fromtuple, shape(2) of ndarray, shape(N)Indices for the upper-triangle of arr.\n\n\n\n\n\nSee also\ntriu_indices, triu\n\nNotes\n\nNew in version 1.4.0.\n\n", "parameters": ["Parameters", "arrndarray, shape(N, N)", "kint, optional", "Returns", "triu_indices_fromtuple, shape(2) of ndarray, shape(N)"], "returns": "triu_indices_fromtuple, shape(2) of ndarray, shape(N)Indices for the upper-triangle of arr.", "examples": []},
{"library": "numpy", "item_id": "numpy.true_divide", "code": "\nnumpy.true_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'true_divide'&gt;\u00b6", "description": "Returns a true division of the inputs, element-wise.\nInstead of the Python traditional \u2018floor division\u2019, this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n\nx1array_likeDividend array.\n\nx2array_likeDivisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\nThe floor division operator // was added in Python 2.2 making\n// and / equivalent operators.  The default floor division\noperation of / can be replaced by true division with from\n__future__ import division.\nIn Python 3.0, // is the floor division operator and / the\ntrue division operator.  The true_divide(x1, x2) function is\nequivalent to true division in Python.\nExamples\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n\n&gt;&gt;&gt; x//4\narray([0, 0, 0, 0, 1])\n\n\n&gt;&gt;&gt; from __future__ import division\n&gt;&gt;&gt; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n&gt;&gt;&gt; x//4\narray([0, 0, 0, 0, 1])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThis is a scalar if both x1 and x2 are scalars.", "examples": ["; x = np.arange(5)\n; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n", "; x = np.arange(5)\n; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n", "; x//4\narray([0, 0, 0, 0, 1])\n\n", "; x//4\narray([0, 0, 0, 0, 1])\n", "; from __future__ import division\n; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n; x//4\narray([0, 0, 0, 0, 1])\n\n", "; from __future__ import division\n; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n; x//4\narray([0, 0, 0, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.triu_indices", "code": "\nnumpy.triu_indices(n, k=0, m=None)[source]\u00b6", "description": "Return the indices for the upper-triangle of an (n, m) array.\n\nParameters\n\nnintThe size of the arrays for which the returned indices will\nbe valid.\n\nkint, optionalDiagonal offset (see triu for details).\n\nmint, optional\nNew in version 1.9.0.\n\nThe column dimension of the arrays for which the returned\narrays will be valid.\nBy default m is taken equal to n.\n\n\n\nReturns\n\nindstuple, shape(2) of ndarrays, shape(n)The indices for the triangle. The returned tuple contains two arrays,\neach with the indices along one dimension of the array.  Can be used\nto slice a ndarray of shape(n, n).\n\n\n\n\n\nSee also\n\ntril_indicessimilar function, for lower-triangular.\n\nmask_indicesgeneric function accepting an arbitrary mask function.\n\n\ntriu, tril\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\nCompute two different sets of indices to access 4x4 arrays, one for the\nupper triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n&gt;&gt;&gt; iu1 = np.triu_indices(4)\n&gt;&gt;&gt; iu2 = np.triu_indices(4, 2)\n\n\nHere is how they can be used with a sample array:\n&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)\n&gt;&gt;&gt; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\nBoth for indexing:\n&gt;&gt;&gt; a[iu1]\narray([ 0,  1,  2, ..., 10, 11, 15])\n\n\nAnd for assigning values:\n&gt;&gt;&gt; a[iu1] = -1\n&gt;&gt;&gt; a\narray([[-1, -1, -1, -1],\n       [ 4, -1, -1, -1],\n       [ 8,  9, -1, -1],\n       [12, 13, 14, -1]])\n\n\nThese cover only a small part of the whole array (two diagonals right\nof the main one):\n&gt;&gt;&gt; a[iu2] = -10\n&gt;&gt;&gt; a\narray([[ -1,  -1, -10, -10],\n       [  4,  -1,  -1, -10],\n       [  8,   9,  -1,  -1],\n       [ 12,  13,  14,  -1]])\n\n\n", "parameters": ["Parameters", "nint", "kint, optional", "mint, optional", "Returns", "indstuple, shape(2) of ndarrays, shape(n)"], "returns": "indstuple, shape(2) of ndarrays, shape(n)The indices for the triangle. The returned tuple contains two arrays,each with the indices along one dimension of the array.  Can be usedto slice a ndarray of shape(n, n).", "examples": ["; iu1 = np.triu_indices(4)\n; iu2 = np.triu_indices(4, 2)\n\n", "; iu1 = np.triu_indices(4)\n; iu2 = np.triu_indices(4, 2)\n", "; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n", "; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n", "; a[iu1]\narray([ 0,  1,  2, ..., 10, 11, 15])\n\n", "; a[iu1]\narray([ 0,  1,  2, ..., 10, 11, 15])\n", "; a[iu1] = -1\n; a\narray([[-1, -1, -1, -1],\n       [ 4, -1, -1, -1],\n       [ 8,  9, -1, -1],\n       [12, 13, 14, -1]])\n\n", "; a[iu1] = -1\n; a\narray([[-1, -1, -1, -1],\n       [ 4, -1, -1, -1],\n       [ 8,  9, -1, -1],\n       [12, 13, 14, -1]])\n", "; a[iu2] = -10\n; a\narray([[ -1,  -1, -10, -10],\n       [  4,  -1,  -1, -10],\n       [  8,   9,  -1,  -1],\n       [ 12,  13,  14,  -1]])\n\n", "; a[iu2] = -10\n; a\narray([[ -1,  -1, -10, -10],\n       [  4,  -1,  -1, -10],\n       [  8,   9,  -1,  -1],\n       [ 12,  13,  14,  -1]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.trimcoef", "code": "\nnumpy.polynomial.polyutils.trimcoef(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.trimseq", "code": "\nnumpy.polynomial.polyutils.trimseq(seq)[source]\u00b6", "description": "Remove small Poly series coefficients.\n\nParameters\n\nseqsequenceSequence of Poly series coefficients. This routine fails for\nempty sequences.\n\n\n\nReturns\n\nseriessequenceSubsequence with trailing zeros removed. If the resulting sequence\nwould be empty, return the first element. The returned sequence may\nor may not be a view.\n\n\n\n\nNotes\nDo not lose the type info if the sequence contains unknown objects.\n", "parameters": ["Parameters", "seqsequence", "Returns", "seriessequence"], "returns": "seriessequenceSubsequence with trailing zeros removed. If the resulting sequencewould be empty, return the first element. The returned sequence mayor may not be a view.", "examples": []},
{"library": "numpy", "item_id": "numpy.triu", "code": "\nnumpy.triu(m, k=0)[source]\u00b6", "description": "Upper triangle of an array.\nReturn a copy of a matrix with the elements below the k-th diagonal\nzeroed.\nPlease refer to the documentation for tril for further details.\n\nSee also\n\ntrillower triangle of an array\n\n\n\nExamples\n&gt;&gt;&gt; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n\n\n", "parameters": [], "returns": [], "examples": ["; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n\n", "; np.triu([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 1,  2,  3],\n       [ 4,  5,  6],\n       [ 0,  8,  9],\n       [ 0,  0, 12]])\n"]},
{"library": "numpy", "item_id": "numpy.trim_zeros", "code": "\nnumpy.trim_zeros(filt, trim='fb')[source]\u00b6", "description": "Trim the leading and/or trailing zeros from a 1-D array or sequence.\n\nParameters\n\nfilt1-D array or sequenceInput array.\n\ntrimstr, optionalA string with \u2018f\u2019 representing trim from front and \u2018b\u2019 to trim from\nback. Default is \u2018fb\u2019, trim zeros from both front and back of the\narray.\n\n\n\nReturns\n\ntrimmed1-D array or sequenceThe result of trimming the input. The input data type is preserved.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n&gt;&gt;&gt; np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])\n\n\n&gt;&gt;&gt; np.trim_zeros(a, 'b')\narray([0, 0, 0, ..., 0, 2, 1])\n\n\nThe input data type is preserved, list/tuple in means list/tuple out.\n&gt;&gt;&gt; np.trim_zeros([0, 1, 2, 0])\n[1, 2]\n\n\n", "parameters": ["Parameters", "filt1-D array or sequence", "trimstr, optional", "Returns", "trimmed1-D array or sequence"], "returns": "trimmed1-D array or sequenceThe result of trimming the input. The input data type is preserved.", "examples": ["; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n; np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])\n\n", "; a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))\n; np.trim_zeros(a)\narray([1, 2, 3, 0, 2, 1])\n", "; np.trim_zeros(a, 'b')\narray([0, 0, 0, ..., 0, 2, 1])\n\n", "; np.trim_zeros(a, 'b')\narray([0, 0, 0, ..., 0, 2, 1])\n", "; np.trim_zeros([0, 1, 2, 0])\n[1, 2]\n\n", "; np.trim_zeros([0, 1, 2, 0])\n[1, 2]\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.trim", "code": "\nPolynomial.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.trim", "code": "\nLegendre.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.trim", "code": "\nLaguerre.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.trim", "code": "\nHermiteE.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.trim", "code": "\nHermite.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.trim", "code": "\nChebyshev.trim(self, tol=0)[source]\u00b6", "description": "Remove trailing coefficients\nRemove trailing coefficients until a coefficient is reached whose\nabsolute value greater than tol or the beginning of the series is\nreached. If all the coefficients would be removed the series is set\nto [0]. A new series instance is returned with the new\ncoefficients.  The current instance remains unchanged.\n\nParameters\n\ntolnon-negative number.All trailing coefficients less than tol will be removed.\n\n\n\nReturns\n\nnew_seriesseriesContains the new set of coefficients.\n\n\n\n\n", "parameters": ["Parameters", "tolnon-negative number.", "Returns", "new_seriesseries"], "returns": "new_seriesseriesContains the new set of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.tril_indices_from", "code": "\nnumpy.tril_indices_from(arr, k=0)[source]\u00b6", "description": "Return the indices for the lower-triangle of arr.\nSee tril_indices for full details.\n\nParameters\n\narrarray_likeThe indices will be valid for square arrays whose dimensions are\nthe same as arr.\n\nkint, optionalDiagonal offset (see tril for details).\n\n\n\n\n\nSee also\ntril_indices, tril\n\nNotes\n\nNew in version 1.4.0.\n\n", "parameters": ["Parameters", "arrarray_like", "kint, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.tril_indices", "code": "\nnumpy.tril_indices(n, k=0, m=None)[source]\u00b6", "description": "Return the indices for the lower-triangle of an (n, m) array.\n\nParameters\n\nnintThe row dimension of the arrays for which the returned\nindices will be valid.\n\nkint, optionalDiagonal offset (see tril for details).\n\nmint, optional\nNew in version 1.9.0.\n\nThe column dimension of the arrays for which the returned\narrays will be valid.\nBy default m is taken equal to n.\n\n\n\nReturns\n\nindstuple of arraysThe indices for the triangle. The returned tuple contains two arrays,\neach with the indices along one dimension of the array.\n\n\n\n\n\nSee also\n\ntriu_indicessimilar function, for upper-triangular.\n\nmask_indicesgeneric function accepting an arbitrary mask function.\n\n\ntril, triu\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\nCompute two different sets of indices to access 4x4 arrays, one for the\nlower triangular part starting at the main diagonal, and one starting two\ndiagonals further right:\n&gt;&gt;&gt; il1 = np.tril_indices(4)\n&gt;&gt;&gt; il2 = np.tril_indices(4, 2)\n\n\nHere is how they can be used with a sample array:\n&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)\n&gt;&gt;&gt; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n\nBoth for indexing:\n&gt;&gt;&gt; a[il1]\narray([ 0,  4,  5, ..., 13, 14, 15])\n\n\nAnd for assigning values:\n&gt;&gt;&gt; a[il1] = -1\n&gt;&gt;&gt; a\narray([[-1,  1,  2,  3],\n       [-1, -1,  6,  7],\n       [-1, -1, -1, 11],\n       [-1, -1, -1, -1]])\n\n\nThese cover almost the whole array (two diagonals right of the main one):\n&gt;&gt;&gt; a[il2] = -10\n&gt;&gt;&gt; a\narray([[-10, -10, -10,   3],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10]])\n\n\n", "parameters": ["Parameters", "nint", "kint, optional", "mint, optional", "Returns", "indstuple of arrays"], "returns": "indstuple of arraysThe indices for the triangle. The returned tuple contains two arrays,each with the indices along one dimension of the array.", "examples": ["; il1 = np.tril_indices(4)\n; il2 = np.tril_indices(4, 2)\n\n", "; il1 = np.tril_indices(4)\n; il2 = np.tril_indices(4, 2)\n", "; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n\n", "; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n", "; a[il1]\narray([ 0,  4,  5, ..., 13, 14, 15])\n\n", "; a[il1]\narray([ 0,  4,  5, ..., 13, 14, 15])\n", "; a[il1] = -1\n; a\narray([[-1,  1,  2,  3],\n       [-1, -1,  6,  7],\n       [-1, -1, -1, 11],\n       [-1, -1, -1, -1]])\n\n", "; a[il1] = -1\n; a\narray([[-1,  1,  2,  3],\n       [-1, -1,  6,  7],\n       [-1, -1, -1, 11],\n       [-1, -1, -1, -1]])\n", "; a[il2] = -10\n; a\narray([[-10, -10, -10,   3],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10]])\n\n", "; a[il2] = -10\n; a\narray([[-10, -10, -10,   3],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10],\n       [-10, -10, -10, -10]])\n"]},
{"library": "numpy", "item_id": "numpy.tril", "code": "\nnumpy.tril(m, k=0)[source]\u00b6", "description": "Lower triangle of an array.\nReturn a copy of an array with elements above the k-th diagonal zeroed.\n\nParameters\n\nmarray_like, shape (M, N)Input array.\n\nkint, optionalDiagonal above which to zero elements.  k = 0 (the default) is the\nmain diagonal, k &lt; 0 is below it and k &gt; 0 is above.\n\n\n\nReturns\n\ntrilndarray, shape (M, N)Lower triangle of m, of same shape and data-type as m.\n\n\n\n\n\nSee also\n\ntriusame thing, only for the upper triangle\n\n\n\nExamples\n&gt;&gt;&gt; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n\n\n", "parameters": ["Parameters", "marray_like, shape (M, N)", "kint, optional", "Returns", "trilndarray, shape (M, N)"], "returns": "trilndarray, shape (M, N)Lower triangle of m, of same shape and data-type as m.", "examples": ["; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n\n", "; np.tril([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], -1)\narray([[ 0,  0,  0],\n       [ 4,  0,  0],\n       [ 7,  8,  0],\n       [10, 11, 12]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.triangular", "code": "\nRandomState.triangular(left, mode, right, size=None)\u00b6", "description": "Draw samples from the triangular distribution over the\ninterval [left, right].\nThe triangular distribution is a continuous probability\ndistribution with lower limit left, peak at mode, and upper\nlimit right. Unlike the other distributions, these parameters\ndirectly define the shape of the pdf.\n\nNote\nNew code should use the triangular method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nleftfloat or array_like of floatsLower limit.\n\nmodefloat or array_like of floatsThe value where the peak of the distribution occurs.\nThe value must fulfill the condition left &lt;= mode &lt;= right.\n\nrightfloat or array_like of floatsUpper limit, must be larger than left.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if left, mode, and right\nare all scalars.  Otherwise, np.broadcast(left, mode, right).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized triangular distribution.\n\n\n\n\n\nSee also\n\nGenerator.triangularwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the triangular distribution is\n\n\nThe triangular distribution is often used in ill-defined\nproblems where the underlying distribution is not known, but\nsome knowledge of the limits and mode exists. Often it is used\nin simulations.\nReferences\n\n1\nWikipedia, \u201cTriangular distribution\u201d\nhttps://en.wikipedia.org/wiki/Triangular_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "leftfloat or array_like of floats", "modefloat or array_like of floats", "rightfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized triangular distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.triangular", "code": "\nGenerator.triangular(left, mode, right, size=None)\u00b6", "description": "Draw samples from the triangular distribution over the\ninterval [left, right].\nThe triangular distribution is a continuous probability\ndistribution with lower limit left, peak at mode, and upper\nlimit right. Unlike the other distributions, these parameters\ndirectly define the shape of the pdf.\n\nParameters\n\nleftfloat or array_like of floatsLower limit.\n\nmodefloat or array_like of floatsThe value where the peak of the distribution occurs.\nThe value must fulfill the condition left &lt;= mode &lt;= right.\n\nrightfloat or array_like of floatsUpper limit, must be larger than left.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if left, mode, and right\nare all scalars.  Otherwise, np.broadcast(left, mode, right).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized triangular distribution.\n\n\n\n\nNotes\nThe probability density function for the triangular distribution is\n\n\nThe triangular distribution is often used in ill-defined\nproblems where the underlying distribution is not known, but\nsome knowledge of the limits and mode exists. Often it is used\nin simulations.\nReferences\n\n1\nWikipedia, \u201cTriangular distribution\u201d\nhttps://en.wikipedia.org/wiki/Triangular_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.default_rng().triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "leftfloat or array_like of floats", "modefloat or array_like of floats", "rightfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized triangular distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.default_rng().triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.default_rng().triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.triangular", "code": "\nnumpy.random.triangular(left, mode, right, size=None)\u00b6", "description": "Draw samples from the triangular distribution over the\ninterval [left, right].\nThe triangular distribution is a continuous probability\ndistribution with lower limit left, peak at mode, and upper\nlimit right. Unlike the other distributions, these parameters\ndirectly define the shape of the pdf.\n\nNote\nNew code should use the triangular method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nleftfloat or array_like of floatsLower limit.\n\nmodefloat or array_like of floatsThe value where the peak of the distribution occurs.\nThe value must fulfill the condition left &lt;= mode &lt;= right.\n\nrightfloat or array_like of floatsUpper limit, must be larger than left.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if left, mode, and right\nare all scalars.  Otherwise, np.broadcast(left, mode, right).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized triangular distribution.\n\n\n\n\n\nSee also\n\nGenerator.triangularwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the triangular distribution is\n\n\nThe triangular distribution is often used in ill-defined\nproblems where the underlying distribution is not known, but\nsome knowledge of the limits and mode exists. Often it is used\nin simulations.\nReferences\n\n1\nWikipedia, \u201cTriangular distribution\u201d\nhttps://en.wikipedia.org/wiki/Triangular_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "leftfloat or array_like of floats", "modefloat or array_like of floats", "rightfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized triangular distribution.", "examples": ["; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; h = plt.hist(np.random.triangular(-3, 0, 8, 100000), bins=200,\n...              density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.tri", "code": "\nnumpy.tri(N, M=None, k=0, dtype=&lt;class 'float'&gt;)[source]\u00b6", "description": "An array with ones at and below the given diagonal and zeros elsewhere.\n\nParameters\n\nNintNumber of rows in the array.\n\nMint, optionalNumber of columns in the array.\nBy default, M is taken equal to N.\n\nkint, optionalThe sub-diagonal at and below which the array is filled.\nk = 0 is the main diagonal, while k &lt; 0 is below it,\nand k &gt; 0 is above.  The default is 0.\n\ndtypedtype, optionalData type of the returned array.  The default is float.\n\n\n\nReturns\n\ntrindarray of shape (N, M)Array with its lower triangle filled with ones and zero elsewhere;\nin other words T[i,j] == 1 for j &lt;= i + k, 0 otherwise.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n\n&gt;&gt;&gt; np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])\n\n\n", "parameters": ["Parameters", "Nint", "Mint, optional", "kint, optional", "dtypedtype, optional", "Returns", "trindarray of shape (N, M)"], "returns": "trindarray of shape (N, M)Array with its lower triangle filled with ones and zero elsewhere;in other words T[i,j] == 1 for j &lt;= i + k, 0 otherwise.", "examples": ["; np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n\n", "; np.tri(3, 5, 2, dtype=int)\narray([[1, 1, 1, 0, 0],\n       [1, 1, 1, 1, 0],\n       [1, 1, 1, 1, 1]])\n", "; np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])\n\n", "; np.tri(3, 5, -1)\narray([[0.,  0.,  0.,  0.,  0.],\n       [1.,  0.,  0.,  0.,  0.],\n       [1.,  1.,  0.,  0.,  0.]])\n"]},
{"library": "numpy", "item_id": "numpy.trapz", "code": "\nnumpy.trapz(y, x=None, dx=1.0, axis=-1)[source]\u00b6", "description": "Integrate along the given axis using the composite trapezoidal rule.\nIntegrate y (x) along given axis.\n\nParameters\n\nyarray_likeInput array to integrate.\n\nxarray_like, optionalThe sample points corresponding to the y values. If x is None,\nthe sample points are assumed to be evenly spaced dx apart. The\ndefault is None.\n\ndxscalar, optionalThe spacing between sample points when x is None. The default is 1.\n\naxisint, optionalThe axis along which to integrate.\n\n\n\nReturns\n\ntrapzfloatDefinite integral as approximated by trapezoidal rule.\n\n\n\n\n\nSee also\nsum, cumsum\n\nNotes\nImage [2] illustrates trapezoidal rule \u2013 y-axis locations of points\nwill be taken from y array, by default x-axis distances between\npoints will be 1.0, alternatively they can be provided with x array\nor with dx scalar.  Return value will be equal to combined area under\nthe red lines.\nReferences\n\n1\nWikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule\n\n2\nIllustration image:\nhttps://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png\n\n\nExamples\n&gt;&gt;&gt; np.trapz([1,2,3])\n4.0\n&gt;&gt;&gt; np.trapz([1,2,3], x=[4,6,8])\n8.0\n&gt;&gt;&gt; np.trapz([1,2,3], dx=2)\n8.0\n&gt;&gt;&gt; a = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; a\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.trapz(a, axis=0)\narray([1.5, 2.5, 3.5])\n&gt;&gt;&gt; np.trapz(a, axis=1)\narray([2.,  8.])\n\n\n", "parameters": ["Parameters", "yarray_like", "xarray_like, optional", "dxscalar, optional", "axisint, optional", "Returns", "trapzfloat"], "returns": "trapzfloatDefinite integral as approximated by trapezoidal rule.", "examples": ["; np.trapz([1,2,3])\n4.0\n; np.trapz([1,2,3], x=[4,6,8])\n8.0\n; np.trapz([1,2,3], dx=2)\n8.0\n; a = np.arange(6).reshape(2, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.trapz(a, axis=0)\narray([1.5, 2.5, 3.5])\n; np.trapz(a, axis=1)\narray([2.,  8.])\n\n", "; np.trapz([1,2,3])\n4.0\n; np.trapz([1,2,3], x=[4,6,8])\n8.0\n; np.trapz([1,2,3], dx=2)\n8.0\n; a = np.arange(6).reshape(2, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.trapz(a, axis=0)\narray([1.5, 2.5, 3.5])\n; np.trapz(a, axis=1)\narray([2.,  8.])\n"]},
{"library": "numpy", "item_id": "numpy.record.transpose", "code": "\nrecord.transpose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.transpose", "code": "\nrecarray.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.transpose", "code": "\nndarray.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.transpose", "code": "\nmemmap.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.transpose", "code": "\nmatrix.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.transpose", "code": "\nMaskType.transpose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.transpose", "code": "\nmasked_array.transpose(*axes)[source]\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.generic.transpose", "code": "\ngeneric.transpose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.transpose", "code": "\nMaskedArray.transpose(*axes)[source]\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.transpose", "code": "\nchararray.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.transpose", "code": "\nchararray.transpose(*axes)\u00b6", "description": "Returns a view of the array with axes transposed.\nFor a 1-D array this has no effect, as a transposed vector is simply the\nsame vector. To convert a 1-D array into a 2D column vector, an additional\ndimension must be added. np.atleast2d(a).T achieves this, as does\na[:, np.newaxis].\nFor a 2-D array, this is a standard matrix transpose.\nFor an n-D array, if axes are given, their order indicates how the\naxes are permuted (see Examples). If axes are not provided and\na.shape = (i[0], i[1], ... i[n-2], i[n-1]), then\na.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0]).\n\nParameters\n\naxesNone, tuple of ints, or n ints\nNone or no argument: reverses the order of the axes.\ntuple of ints: i in the j-th place in the tuple means a\u2019s\ni-th axis becomes a.transpose()\u2019s j-th axis.\nn ints: same as an n-tuple of the same ints (this form is\nintended simply as a \u201cconvenience\u201d alternative to the tuple form)\n\n\n\n\nReturns\n\noutndarrayView of a, with axes suitably permuted.\n\n\n\n\n\nSee also\n\nndarray.TArray property returning the array transposed.\n\nndarray.reshapeGive a new shape to an array without changing its data.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; a.transpose()\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n&gt;&gt;&gt; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n\n", "parameters": ["Parameters", "axesNone, tuple of ints, or n ints", "Returns", "outndarray"], "returns": "outndarrayView of a, with axes suitably permuted.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; a\narray([[1, 2],\n       [3, 4]])\n; a.transpose()\narray([[1, 3],\n       [2, 4]])\n; a.transpose((1, 0))\narray([[1, 3],\n       [2, 4]])\n; a.transpose(1, 0)\narray([[1, 3],\n       [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.transpose", "code": "\nnumpy.transpose(a, axes=None)[source]\u00b6", "description": "Permute the dimensions of an array.\n\nParameters\n\naarray_likeInput array.\n\naxeslist of ints, optionalBy default, reverse the dimensions, otherwise permute the axes\naccording to the values given.\n\n\n\nReturns\n\npndarraya with its axes permuted.  A view is returned whenever\npossible.\n\n\n\n\n\nSee also\nmoveaxis, argsort\n\nNotes\nUse transpose(a, argsort(axes)) to invert the transposition of tensors\nwhen using the axes keyword argument.\nTransposing a 1-D array returns an unchanged view of the original array.\nExamples\n&gt;&gt;&gt; x = np.arange(4).reshape((2,2))\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n\n\n&gt;&gt;&gt; np.transpose(x)\narray([[0, 2],\n       [1, 3]])\n\n\n&gt;&gt;&gt; x = np.ones((1, 2, 3))\n&gt;&gt;&gt; np.transpose(x, (1, 0, 2)).shape\n(2, 1, 3)\n\n\n", "parameters": ["Parameters", "aarray_like", "axeslist of ints, optional", "Returns", "pndarray"], "returns": "pndarraya with its axes permuted.  A view is returned wheneverpossible.", "examples": ["; x = np.arange(4).reshape((2,2))\n; x\narray([[0, 1],\n       [2, 3]])\n\n", "; x = np.arange(4).reshape((2,2))\n; x\narray([[0, 1],\n       [2, 3]])\n", "; np.transpose(x)\narray([[0, 2],\n       [1, 3]])\n\n", "; np.transpose(x)\narray([[0, 2],\n       [1, 3]])\n", "; x = np.ones((1, 2, 3))\n; np.transpose(x, (1, 0, 2)).shape\n(2, 1, 3)\n\n", "; x = np.ones((1, 2, 3))\n; np.transpose(x, (1, 0, 2)).shape\n(2, 1, 3)\n"]},
{"library": "numpy", "item_id": "numpy.ma.transpose", "code": "\nnumpy.ma.transpose(a, axes=None)[source]\u00b6", "description": "Permute the dimensions of an array.\nThis function is exactly equivalent to numpy.transpose.\n\nSee also\n\nnumpy.transposeEquivalent function in top-level NumPy module.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = ma.arange(4).reshape((2,2))\n&gt;&gt;&gt; x[1, 1] = ma.masked\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[0, 1],\n        [2, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n\n\n&gt;&gt;&gt; ma.transpose(x)\nmasked_array(\n  data=[[0, 2],\n        [1, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; x = ma.arange(4).reshape((2,2))\n; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[0, 1],\n        [2, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n\n", "; import numpy.ma as ma\n; x = ma.arange(4).reshape((2,2))\n; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[0, 1],\n        [2, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n", "; ma.transpose(x)\nmasked_array(\n  data=[[0, 2],\n        [1, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n\n", "; ma.transpose(x)\nmasked_array(\n  data=[[0, 2],\n        [1, --]],\n  mask=[[False, False],\n        [False,  True]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.record.trace", "code": "\nrecord.trace()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.translate", "code": "\nchararray.translate(self, table, deletechars=None)\u00b6", "description": "For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.\n\nSee also\nchar.translate\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.translate", "code": "\nnumpy.char.translate(a, table, deletechars=None)\u00b6", "description": "For each element in a, return a copy of the string where all\ncharacters occurring in the optional argument deletechars are\nremoved, and the remaining characters have been mapped through the\ngiven translation table.\nCalls str.translate element-wise.\n\nParameters\n\naarray-like of str or unicode\ntablestr of length 256\ndeletecharsstr\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.translate\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "tablestr of length 256", "deletecharsstr", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.translate", "code": "\nchararray.translate(self, table, deletechars=None)[source]\u00b6", "description": "For each element in self, return a copy of the string where\nall characters occurring in the optional argument\ndeletechars are removed, and the remaining characters have\nbeen mapped through the given translation table.\n\nSee also\nchar.translate\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.trace", "code": "\nrecarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.trace", "code": "\nndarray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.trace", "code": "\nmemmap.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.trace", "code": "\nmatrix.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.trace", "code": "\nMaskType.trace()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.trace", "code": "\nMaskedArray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)[source]\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.trace", "code": "\nmasked_array.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)[source]\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.trace", "code": "\nchararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.trace", "code": "\nnumpy.trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None)[source]\u00b6", "description": "Return the sum along diagonals of the array.\nIf a is 2-D, the sum along its diagonal with the given offset\nis returned, i.e., the sum of elements a[i,i+offset] for all i.\nIf a has more than two dimensions, then the axes specified by axis1 and\naxis2 are used to determine the 2-D sub-arrays whose traces are returned.\nThe shape of the resulting array is the same as that of a with axis1\nand axis2 removed.\n\nParameters\n\naarray_likeInput array, from which the diagonals are taken.\n\noffsetint, optionalOffset of the diagonal from the main diagonal. Can be both positive\nand negative. Defaults to 0.\n\naxis1, axis2int, optionalAxes to be used as the first and second axis of the 2-D sub-arrays\nfrom which the diagonals should be taken. Defaults are the first two\naxes of a.\n\ndtypedtype, optionalDetermines the data-type of the returned array and of the accumulator\nwhere the elements are summed. If dtype has the value None and a is\nof integer type of precision less than the default integer\nprecision, then the default integer precision is used. Otherwise,\nthe precision is the same as that of a.\n\noutndarray, optionalArray into which the output is placed. Its type is preserved and\nit must be of the right shape to hold the output.\n\n\n\nReturns\n\nsum_along_diagonalsndarrayIf a is 2-D, the sum along the diagonal is returned.  If a has\nlarger dimensions, then an array of sums along diagonals is returned.\n\n\n\n\n\nSee also\ndiag, diagonal, diagflat\n\nExamples\n&gt;&gt;&gt; np.trace(np.eye(3))\n3.0\n&gt;&gt;&gt; a = np.arange(8).reshape((2,2,2))\n&gt;&gt;&gt; np.trace(a)\narray([6, 8])\n\n\n&gt;&gt;&gt; a = np.arange(24).reshape((2,2,2,3))\n&gt;&gt;&gt; np.trace(a).shape\n(2, 3)\n\n\n", "parameters": ["Parameters", "aarray_like", "offsetint, optional", "axis1, axis2int, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "sum_along_diagonalsndarray"], "returns": "sum_along_diagonalsndarrayIf a is 2-D, the sum along the diagonal is returned.  If a haslarger dimensions, then an array of sums along diagonals is returned.", "examples": ["; np.trace(np.eye(3))\n3.0\n; a = np.arange(8).reshape((2,2,2))\n; np.trace(a)\narray([6, 8])\n\n", "; np.trace(np.eye(3))\n3.0\n; a = np.arange(8).reshape((2,2,2))\n; np.trace(a)\narray([6, 8])\n", "; a = np.arange(24).reshape((2,2,2,3))\n; np.trace(a).shape\n(2, 3)\n\n", "; a = np.arange(24).reshape((2,2,2,3))\n; np.trace(a).shape\n(2, 3)\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.trace", "code": "\nchararray.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None)\u00b6", "description": "Return the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.trace", "code": "\nnumpy.ma.trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None) a.trace(offset=0, axis1=0, axis2=1, dtype=None, out=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "\nReturn the sum along diagonals of the array.\nRefer to numpy.trace for full documentation.\n\n\nSee also\n\nnumpy.traceequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.tostring", "code": "\nrecord.tostring()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.tostring", "code": "\nrecarray.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.matrix.tostring", "code": "\nmatrix.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.memmap.tostring", "code": "\nmemmap.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.tostring", "code": "\nMaskType.tostring()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.tostring", "code": "\nMaskedArray.tostring(self, fill_value=None, order='C')[source]\u00b6", "description": "This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.lib.user_array.container.tostring", "code": "\ncontainer.tostring(self)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.tostring", "code": "\ngeneric.tostring()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.tostring", "code": "\nmasked_array.tostring(self, fill_value=None, order='C')[source]\u00b6", "description": "This function is a compatibility alias for tobytes. Despite its name it\nreturns bytes not strings.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.tostring", "code": "\nndarray.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.chararray.tostring", "code": "\nchararray.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.tostring", "code": "\nchararray.tostring(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\nThis function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.torecords", "code": "\nMaskedArray.torecords(self)[source]\u00b6", "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n\nthe _data field stores the _data part of the array.\nthe _mask field stores the _mask part of the array.\n\n\nParameters\n\nNone\n\n\nReturns\n\nrecordndarrayA new flexible-type ndarray with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.\n\n\n\n\nNotes\nA side-effect of transforming a masked array into a flexible ndarray is\nthat meta information (fill_value, \u2026) will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n\n", "parameters": ["Parameters", "None", "Returns", "recordndarray"], "returns": "recordndarrayA new flexible-type ndarray with two fields: the first elementcontaining a value, the second element containing the correspondingmask boolean. The returned record shape matches self.shape.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.torecords", "code": "\nmasked_array.torecords(self)[source]\u00b6", "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n\nthe _data field stores the _data part of the array.\nthe _mask field stores the _mask part of the array.\n\n\nParameters\n\nNone\n\n\nReturns\n\nrecordndarrayA new flexible-type ndarray with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.\n\n\n\n\nNotes\nA side-effect of transforming a masked array into a flexible ndarray is\nthat meta information (fill_value, \u2026) will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n\n", "parameters": ["Parameters", "None", "Returns", "recordndarray"], "returns": "recordndarrayA new flexible-type ndarray with two fields: the first elementcontaining a value, the second element containing the correspondingmask boolean. The returned record shape matches self.shape.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n"]},
{"library": "numpy", "item_id": "numpy.record.tolist", "code": "\nrecord.tolist()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.tolist", "code": "\nrecarray.tolist()\u00b6", "description": "Return the array as an a.ndim-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe item function.\nIf a.ndim is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.\n\nParameters\n\nnone\n\n\nReturns\n\nyobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.\n\n\n\n\nNotes\nThe array may be recreated via a = np.array(a.tolist()), although this\nmay sometimes lose precision.\nExamples\nFor a 1D array, a.tolist() is almost the same as list(a), \nexcept that tolist changes numpy scalars to Python scalars:\n&gt;&gt;&gt; a = np.uint32([1, 2])\n&gt;&gt;&gt; a_list = list(a)\n&gt;&gt;&gt; a_list\n[1, 2]\n&gt;&gt;&gt; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n&gt;&gt;&gt; a_tolist = a.tolist()\n&gt;&gt;&gt; a_tolist\n[1, 2]\n&gt;&gt;&gt; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n\nAdditionally, for a 2D array, tolist applies recursively:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; list(a)\n[array([1, 2]), array([3, 4])]\n&gt;&gt;&gt; a.tolist()\n[[1, 2], [3, 4]]\n\n\nThe base case for this recursion is a 0D array:\n&gt;&gt;&gt; a = np.array(1)\n&gt;&gt;&gt; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n&gt;&gt;&gt; a.tolist()\n1\n\n\n", "parameters": ["Parameters", "none", "Returns", "yobject, or list of object, or list of list of object, or \u2026"], "returns": "yobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.", "examples": ["; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n", "; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.tolist", "code": "\nndarray.tolist()\u00b6", "description": "Return the array as an a.ndim-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe item function.\nIf a.ndim is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.\n\nParameters\n\nnone\n\n\nReturns\n\nyobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.\n\n\n\n\nNotes\nThe array may be recreated via a = np.array(a.tolist()), although this\nmay sometimes lose precision.\nExamples\nFor a 1D array, a.tolist() is almost the same as list(a), \nexcept that tolist changes numpy scalars to Python scalars:\n&gt;&gt;&gt; a = np.uint32([1, 2])\n&gt;&gt;&gt; a_list = list(a)\n&gt;&gt;&gt; a_list\n[1, 2]\n&gt;&gt;&gt; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n&gt;&gt;&gt; a_tolist = a.tolist()\n&gt;&gt;&gt; a_tolist\n[1, 2]\n&gt;&gt;&gt; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n\nAdditionally, for a 2D array, tolist applies recursively:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; list(a)\n[array([1, 2]), array([3, 4])]\n&gt;&gt;&gt; a.tolist()\n[[1, 2], [3, 4]]\n\n\nThe base case for this recursion is a 0D array:\n&gt;&gt;&gt; a = np.array(1)\n&gt;&gt;&gt; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n&gt;&gt;&gt; a.tolist()\n1\n\n\n", "parameters": ["Parameters", "none", "Returns", "yobject, or list of object, or list of list of object, or \u2026"], "returns": "yobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.", "examples": ["; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n", "; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n"]},
{"library": "numpy", "item_id": "numpy.memmap.tolist", "code": "\nmemmap.tolist()\u00b6", "description": "Return the array as an a.ndim-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe item function.\nIf a.ndim is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.\n\nParameters\n\nnone\n\n\nReturns\n\nyobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.\n\n\n\n\nNotes\nThe array may be recreated via a = np.array(a.tolist()), although this\nmay sometimes lose precision.\nExamples\nFor a 1D array, a.tolist() is almost the same as list(a), \nexcept that tolist changes numpy scalars to Python scalars:\n&gt;&gt;&gt; a = np.uint32([1, 2])\n&gt;&gt;&gt; a_list = list(a)\n&gt;&gt;&gt; a_list\n[1, 2]\n&gt;&gt;&gt; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n&gt;&gt;&gt; a_tolist = a.tolist()\n&gt;&gt;&gt; a_tolist\n[1, 2]\n&gt;&gt;&gt; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n\nAdditionally, for a 2D array, tolist applies recursively:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; list(a)\n[array([1, 2]), array([3, 4])]\n&gt;&gt;&gt; a.tolist()\n[[1, 2], [3, 4]]\n\n\nThe base case for this recursion is a 0D array:\n&gt;&gt;&gt; a = np.array(1)\n&gt;&gt;&gt; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n&gt;&gt;&gt; a.tolist()\n1\n\n\n", "parameters": ["Parameters", "none", "Returns", "yobject, or list of object, or list of list of object, or \u2026"], "returns": "yobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.", "examples": ["; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n", "; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.tolist", "code": "\nMaskType.tolist()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.tolist", "code": "\nmatrix.tolist(self)[source]\u00b6", "description": "Return the matrix as a (possibly nested) list.\nSee ndarray.tolist for full documentation.\n\nSee also\nndarray.tolist\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.tolist()\n[[0, 1, 2, 3], [4, 5, 6, 7], [8, 9, 10, 11]]\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.tolist", "code": "\nmasked_array.tolist(self, fill_value=None)[source]\u00b6", "description": "Return the data portion of the masked array as a hierarchical Python list.\nData items are converted to the nearest compatible Python type.\nMasked values are converted to fill_value. If fill_value is None,\nthe corresponding entries in the output list will be None.\n\nParameters\n\nfill_valuescalar, optionalThe value to use for invalid entries. Default is None.\n\n\n\nReturns\n\nresultlistThe Python list representation of the masked array.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n&gt;&gt;&gt; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n\n", "parameters": ["Parameters", "fill_valuescalar, optional", "Returns", "resultlist"], "returns": "resultlistThe Python list representation of the masked array.", "examples": ["; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n", "; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.tolist", "code": "\nMaskedArray.tolist(self, fill_value=None)[source]\u00b6", "description": "Return the data portion of the masked array as a hierarchical Python list.\nData items are converted to the nearest compatible Python type.\nMasked values are converted to fill_value. If fill_value is None,\nthe corresponding entries in the output list will be None.\n\nParameters\n\nfill_valuescalar, optionalThe value to use for invalid entries. Default is None.\n\n\n\nReturns\n\nresultlistThe Python list representation of the masked array.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n&gt;&gt;&gt; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n\n", "parameters": ["Parameters", "fill_valuescalar, optional", "Returns", "resultlist"], "returns": "resultlistThe Python list representation of the masked array.", "examples": ["; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n\n", "; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)\n; x.tolist()\n[[1, None, 3], [None, 5, None], [7, None, 9]]\n; x.tolist(-999)\n[[1, -999, 3], [-999, 5, -999], [7, -999, 9]]\n"]},
{"library": "numpy", "item_id": "numpy.generic.tolist", "code": "\ngeneric.tolist()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.tolist", "code": "\nchararray.tolist()\u00b6", "description": "Return the array as an a.ndim-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe item function.\nIf a.ndim is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.\n\nParameters\n\nnone\n\n\nReturns\n\nyobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.\n\n\n\n\nNotes\nThe array may be recreated via a = np.array(a.tolist()), although this\nmay sometimes lose precision.\nExamples\nFor a 1D array, a.tolist() is almost the same as list(a), \nexcept that tolist changes numpy scalars to Python scalars:\n&gt;&gt;&gt; a = np.uint32([1, 2])\n&gt;&gt;&gt; a_list = list(a)\n&gt;&gt;&gt; a_list\n[1, 2]\n&gt;&gt;&gt; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n&gt;&gt;&gt; a_tolist = a.tolist()\n&gt;&gt;&gt; a_tolist\n[1, 2]\n&gt;&gt;&gt; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n\nAdditionally, for a 2D array, tolist applies recursively:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; list(a)\n[array([1, 2]), array([3, 4])]\n&gt;&gt;&gt; a.tolist()\n[[1, 2], [3, 4]]\n\n\nThe base case for this recursion is a 0D array:\n&gt;&gt;&gt; a = np.array(1)\n&gt;&gt;&gt; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n&gt;&gt;&gt; a.tolist()\n1\n\n\n", "parameters": ["Parameters", "none", "Returns", "yobject, or list of object, or list of list of object, or \u2026"], "returns": "yobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.", "examples": ["; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n", "; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.tolist", "code": "\nchararray.tolist()\u00b6", "description": "Return the array as an a.ndim-levels deep nested list of Python scalars.\nReturn a copy of the array data as a (nested) Python list.\nData items are converted to the nearest compatible builtin Python type, via\nthe item function.\nIf a.ndim is 0, then since the depth of the nested list is 0, it will\nnot be a list at all, but a simple Python scalar.\n\nParameters\n\nnone\n\n\nReturns\n\nyobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.\n\n\n\n\nNotes\nThe array may be recreated via a = np.array(a.tolist()), although this\nmay sometimes lose precision.\nExamples\nFor a 1D array, a.tolist() is almost the same as list(a), \nexcept that tolist changes numpy scalars to Python scalars:\n&gt;&gt;&gt; a = np.uint32([1, 2])\n&gt;&gt;&gt; a_list = list(a)\n&gt;&gt;&gt; a_list\n[1, 2]\n&gt;&gt;&gt; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n&gt;&gt;&gt; a_tolist = a.tolist()\n&gt;&gt;&gt; a_tolist\n[1, 2]\n&gt;&gt;&gt; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n\nAdditionally, for a 2D array, tolist applies recursively:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; list(a)\n[array([1, 2]), array([3, 4])]\n&gt;&gt;&gt; a.tolist()\n[[1, 2], [3, 4]]\n\n\nThe base case for this recursion is a 0D array:\n&gt;&gt;&gt; a = np.array(1)\n&gt;&gt;&gt; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n&gt;&gt;&gt; a.tolist()\n1\n\n\n", "parameters": ["Parameters", "none", "Returns", "yobject, or list of object, or list of list of object, or \u2026"], "returns": "yobject, or list of object, or list of list of object, or \u2026The possibly nested list of array elements.", "examples": ["; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n\n", "; a = np.uint32([1, 2])\n; a_list = list(a)\n; a_list\n[1, 2]\n; type(a_list[0])\n&lt;class 'numpy.uint32'&gt;\n; a_tolist = a.tolist()\n; a_tolist\n[1, 2]\n; type(a_tolist[0])\n&lt;class 'int'&gt;\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n\n", "; a = np.array([[1, 2], [3, 4]])\n; list(a)\n[array([1, 2]), array([3, 4])]\n; a.tolist()\n[[1, 2], [3, 4]]\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n\n", "; a = np.array(1)\n; list(a)\nTraceback (most recent call last):\n  ...\nTypeError: iteration over a 0-d array\n; a.tolist()\n1\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.toflex", "code": "\nMaskedArray.toflex(self)[source]\u00b6", "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n\nthe _data field stores the _data part of the array.\nthe _mask field stores the _mask part of the array.\n\n\nParameters\n\nNone\n\n\nReturns\n\nrecordndarrayA new flexible-type ndarray with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.\n\n\n\n\nNotes\nA side-effect of transforming a masked array into a flexible ndarray is\nthat meta information (fill_value, \u2026) will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n\n", "parameters": ["Parameters", "None", "Returns", "recordndarray"], "returns": "recordndarrayA new flexible-type ndarray with two fields: the first elementcontaining a value, the second element containing the correspondingmask boolean. The returned record shape matches self.shape.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.toflex", "code": "\nmasked_array.toflex(self)[source]\u00b6", "description": "Transforms a masked array into a flexible-type array.\nThe flexible type array that is returned will have two fields:\n\nthe _data field stores the _data part of the array.\nthe _mask field stores the _mask part of the array.\n\n\nParameters\n\nNone\n\n\nReturns\n\nrecordndarrayA new flexible-type ndarray with two fields: the first element\ncontaining a value, the second element containing the corresponding\nmask boolean. The returned record shape matches self.shape.\n\n\n\n\nNotes\nA side-effect of transforming a masked array into a flexible ndarray is\nthat meta information (fill_value, \u2026) will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n\n", "parameters": ["Parameters", "None", "Returns", "recordndarray"], "returns": "recordndarrayA new flexible-type ndarray with two fields: the first elementcontaining a value, the second element containing the correspondingmask boolean. The returned record shape matches self.shape.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.toflex()\narray([[(1, False), (2,  True), (3, False)],\n       [(4,  True), (5, False), (6,  True)],\n       [(7, False), (8,  True), (9, False)]],\n      dtype=[('_data', '&lt;i8'), ('_mask', '?')])\n"]},
{"library": "numpy", "item_id": "numpy.record.tofile", "code": "\nrecord.tofile()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.tofile", "code": "\nrecarray.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.tofile", "code": "\nndarray.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.tofile", "code": "\nmemmap.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.tofile", "code": "\nmatrix.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.tofile", "code": "\nMaskType.tofile()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.tofile", "code": "\nMaskedArray.tofile(self, fid, sep='', format='%s')[source]\u00b6", "description": "Save a masked array to a file in binary format.\n\nWarning\nThis function is not implemented yet.\n\n\nRaises\n\nNotImplementedErrorWhen tofile is called.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.tofile", "code": "\nmasked_array.tofile(self, fid, sep='', format='%s')[source]\u00b6", "description": "Save a masked array to a file in binary format.\n\nWarning\nThis function is not implemented yet.\n\n\nRaises\n\nNotImplementedErrorWhen tofile is called.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.tofile", "code": "\ngeneric.tofile()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.tofile", "code": "\nchararray.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.tofile", "code": "\nchararray.tofile(fid, sep=\"\", format=\"%s\")\u00b6", "description": "Write array to a file as text or binary (default).\nData is always written in \u2018C\u2019 order, independent of the order of a.\nThe data produced by this method can be recovered using the function\nfromfile().\n\nParameters\n\nfidfile or str or PathAn open file object, or a string containing a filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\nsepstrSeparator between array items for text output.\nIf \u201c\u201d (empty), a binary file is written, equivalent to\nfile.write(a.tobytes()).\n\nformatstrFormat string for text file output.\nEach entry in the array is formatted to text by first converting\nit to the closest Python type, and then using \u201cformat\u201d % item.\n\n\n\n\nNotes\nThis is a convenience function for quick storage of array data.\nInformation on endianness and precision is lost, so this method is not a\ngood choice for files intended to archive data or transport data between\nmachines with different endianness. Some of these problems can be overcome\nby outputting the data as text files, at the expense of speed and file\nsize.\nWhen fid is a file object, array contents are directly written to the\nfile, bypassing the file object\u2019s write method. As a result, tofile\ncannot be used with files objects supporting compression (e.g., GzipFile)\nor file-like objects that do not support fileno() (e.g., BytesIO).\n", "parameters": ["Parameters", "fidfile or str or Path", "sepstr", "formatstr"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.tobytes", "code": "\nrecord.tobytes()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.tobytes", "code": "\nrecarray.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.tobytes", "code": "\nndarray.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.memmap.tobytes", "code": "\nmemmap.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.matrix.tobytes", "code": "\nmatrix.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.tobytes", "code": "\nMaskType.tobytes()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.tobytes", "code": "\nMaskedArray.tobytes(self, fill_value=None, order='C')[source]\u00b6", "description": "Return the array data as a string containing the raw bytes in the array.\nThe array is filled with a fill value before the string conversion.\n\nNew in version 1.9.0.\n\n\nParameters\n\nfill_valuescalar, optionalValue used to fill in the masked values. Default is None, in which\ncase MaskedArray.fill_value is used.\n\norder{\u2018C\u2019,\u2019F\u2019,\u2019A\u2019}, optionalOrder of the data item in the copy. Default is \u2018C\u2019.\n\n\u2018C\u2019   \u2013 C order (row major).\n\u2018F\u2019   \u2013 Fortran order (column major).\n\u2018A\u2019   \u2013 Any, current order of array.\nNone  \u2013 Same as \u2018A\u2019.\n\n\n\n\n\n\nSee also\nnumpy.ndarray.tobytes, tolist, tofile\n\nNotes\nAs for ndarray.tobytes, information about the shape, dtype, etc.,\nbut also about fill_value, will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n&gt;&gt;&gt; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n\n", "parameters": ["Parameters", "fill_valuescalar, optional", "order{\u2018C\u2019,\u2019F\u2019,\u2019A\u2019}, optional"], "returns": [], "examples": ["; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n", "; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.tobytes", "code": "\nmasked_array.tobytes(self, fill_value=None, order='C')[source]\u00b6", "description": "Return the array data as a string containing the raw bytes in the array.\nThe array is filled with a fill value before the string conversion.\n\nNew in version 1.9.0.\n\n\nParameters\n\nfill_valuescalar, optionalValue used to fill in the masked values. Default is None, in which\ncase MaskedArray.fill_value is used.\n\norder{\u2018C\u2019,\u2019F\u2019,\u2019A\u2019}, optionalOrder of the data item in the copy. Default is \u2018C\u2019.\n\n\u2018C\u2019   \u2013 C order (row major).\n\u2018F\u2019   \u2013 Fortran order (column major).\n\u2018A\u2019   \u2013 Any, current order of array.\nNone  \u2013 Same as \u2018A\u2019.\n\n\n\n\n\n\nSee also\nnumpy.ndarray.tobytes, tolist, tofile\n\nNotes\nAs for ndarray.tobytes, information about the shape, dtype, etc.,\nbut also about fill_value, will be lost.\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n&gt;&gt;&gt; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n\n", "parameters": ["Parameters", "fill_valuescalar, optional", "order{\u2018C\u2019,\u2019F\u2019,\u2019A\u2019}, optional"], "returns": [], "examples": ["; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n\n", "; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n; x.tobytes()\nb'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.generic.tobytes", "code": "\ngeneric.tobytes()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.tobytes", "code": "\nchararray.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.tobytes", "code": "\nchararray.tobytes(order='C')\u00b6", "description": "Construct Python bytes containing the raw data bytes in the array.\nConstructs Python bytes showing a copy of the raw contents of\ndata memory. The bytes object can be produced in either \u2018C\u2019 or \u2018Fortran\u2019,\nor \u2018Any\u2019 order (the default is \u2018C\u2019-order). \u2018Any\u2019 order means C-order\nunless the F_CONTIGUOUS flag in the array is set, in which case it\nmeans \u2018Fortran\u2019 order.\n\nNew in version 1.9.0.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, None}, optionalOrder of the data for multidimensional arrays:\nC, Fortran, or the same as for the original array.\n\n\n\nReturns\n\nsbytesPython bytes exhibiting a copy of a\u2019s raw data.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n&gt;&gt;&gt; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n&gt;&gt;&gt; x.tobytes('C') == x.tobytes()\nTrue\n&gt;&gt;&gt; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, None}, optional", "Returns", "sbytes"], "returns": "sbytesPython bytes exhibiting a copy of a\u2019s raw data.", "examples": ["; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n\n", "; x = np.array([[0, 1], [2, 3]], dtype='&lt;u2')\n; x.tobytes()\nb'\\x00\\x00\\x01\\x00\\x02\\x00\\x03\\x00'\n; x.tobytes('C') == x.tobytes()\nTrue\n; x.tobytes('F')\nb'\\x00\\x00\\x02\\x00\\x01\\x00\\x03\\x00'\n"]},
{"library": "numpy", "item_id": "numpy.chararray.title", "code": "\nchararray.title(self)[source]\u00b6", "description": "For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.\n\nSee also\nchar.title\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.title", "code": "\nchararray.title(self)\u00b6", "description": "For each element in self, return a titlecased version of the\nstring: words start with uppercase characters, all remaining cased\ncharacters are lowercase.\n\nSee also\nchar.title\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.title", "code": "\nnumpy.char.title(a)\u00b6", "description": "Return element-wise title cased version of string or unicode.\nTitle case words start with uppercase characters, all remaining cased\ncharacters are lowercase.\nCalls str.title element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like, {str, unicode}Input array.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.title\n\nExamples\n&gt;&gt;&gt; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\narray(['a1b c', '1b ca', 'b ca1', 'ca1b'],\n    dtype='|S5')\n&gt;&gt;&gt; np.char.title(c)\narray(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],\n    dtype='|S5')\n\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": ["; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\narray(['a1b c', '1b ca', 'b ca1', 'ca1b'],\n    dtype='|S5')\n; np.char.title(c)\narray(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],\n    dtype='|S5')\n\n", "; c=np.array(['a1b c','1b ca','b ca1','ca1b'],'S5'); c\narray(['a1b c', '1b ca', 'b ca1', 'ca1b'],\n    dtype='|S5')\n; np.char.title(c)\narray(['A1B C', '1B Ca', 'B Ca1', 'Ca1B'],\n    dtype='|S5')\n"]},
{"library": "numpy", "item_id": "numpy.testing.Tester", "code": "\nnumpy.testing.Tester[source]\u00b6", "description": "alias of numpy.testing._private.nosetester.NoseTester\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.tile", "code": "\nnumpy.tile(A, reps)[source]\u00b6", "description": "Construct an array by repeating A the number of times given by reps.\nIf reps has length d, the result will have dimension of\nmax(d, A.ndim).\nIf A.ndim &lt; d, A is promoted to be d-dimensional by prepending new\naxes. So a shape (3,) array is promoted to (1, 3) for 2-D replication,\nor shape (1, 1, 3) for 3-D replication. If this is not the desired\nbehavior, promote A to d-dimensions manually before calling this\nfunction.\nIf A.ndim &gt; d, reps is promoted to A.ndim by pre-pending 1\u2019s to it.\nThus for an A of shape (2, 3, 4, 5), a reps of (2, 2) is treated as\n(1, 1, 2, 2).\nNote : Although tile may be used for broadcasting, it is strongly\nrecommended to use numpy\u2019s broadcasting operations and functions.\n\nParameters\n\nAarray_likeThe input array.\n\nrepsarray_likeThe number of repetitions of A along each axis.\n\n\n\nReturns\n\ncndarrayThe tiled output array.\n\n\n\n\n\nSee also\n\nrepeatRepeat elements of an array.\n\nbroadcast_toBroadcast an array to a new shape\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([0, 1, 2])\n&gt;&gt;&gt; np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n&gt;&gt;&gt; np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n&gt;&gt;&gt; np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])\n\n\n&gt;&gt;&gt; b = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.tile(b, 2)\narray([[1, 2, 1, 2],\n       [3, 4, 3, 4]])\n&gt;&gt;&gt; np.tile(b, (2, 1))\narray([[1, 2],\n       [3, 4],\n       [1, 2],\n       [3, 4]])\n\n\n&gt;&gt;&gt; c = np.array([1,2,3,4])\n&gt;&gt;&gt; np.tile(c,(4,1))\narray([[1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4]])\n\n\n", "parameters": ["Parameters", "Aarray_like", "repsarray_like", "Returns", "cndarray"], "returns": "cndarrayThe tiled output array.", "examples": ["; a = np.array([0, 1, 2])\n; np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n; np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n; np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])\n\n", "; a = np.array([0, 1, 2])\n; np.tile(a, 2)\narray([0, 1, 2, 0, 1, 2])\n; np.tile(a, (2, 2))\narray([[0, 1, 2, 0, 1, 2],\n       [0, 1, 2, 0, 1, 2]])\n; np.tile(a, (2, 1, 2))\narray([[[0, 1, 2, 0, 1, 2]],\n       [[0, 1, 2, 0, 1, 2]]])\n", "; b = np.array([[1, 2], [3, 4]])\n; np.tile(b, 2)\narray([[1, 2, 1, 2],\n       [3, 4, 3, 4]])\n; np.tile(b, (2, 1))\narray([[1, 2],\n       [3, 4],\n       [1, 2],\n       [3, 4]])\n\n", "; b = np.array([[1, 2], [3, 4]])\n; np.tile(b, 2)\narray([[1, 2, 1, 2],\n       [3, 4, 3, 4]])\n; np.tile(b, (2, 1))\narray([[1, 2],\n       [3, 4],\n       [1, 2],\n       [3, 4]])\n", "; c = np.array([1,2,3,4])\n; np.tile(c,(4,1))\narray([[1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4]])\n\n", "; c = np.array([1,2,3,4])\n; np.tile(c,(4,1))\narray([[1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4],\n       [1, 2, 3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.testing.Tester.test", "code": "\nTester.test(self, label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, raise_warnings=None, timer=False)[source]\u00b6", "description": "Run tests for module using nose.\n\nParameters\n\nlabel{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optionalIdentifies the tests to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:\n\n\u2018fast\u2019 - the default - which corresponds to the nosetests -A\noption of \u2018not slow\u2019.\n\u2018full\u2019 - fast (as above) and slow tests as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.\nNone or \u2018\u2019 - run all tests.\nattribute_identifier - string passed directly to nosetests as \u2018-A\u2019.\n\n\nverboseint, optionalVerbosity value for test outputs, in the range 1-10. Default is 1.\n\nextra_argvlist, optionalList with any extra arguments to pass to nosetests.\n\ndoctestsbool, optionalIf True, run doctests in module. Default is False.\n\ncoveragebool, optionalIf True, report coverage of NumPy code. Default is False.\n(This requires the\ncoverage module).\n\nraise_warningsNone, str or sequence of warnings, optionalThis specifies which warnings to configure as \u2018raise\u2019 instead\nof being shown once during the test execution. Valid strings are:\n\n\u201cdevelop\u201d : equals (Warning,)\n\u201crelease\u201d : equals (), do not raise on any warnings.\n\n\ntimerbool or int, optionalTiming of individual tests with nose-timer (which needs to be\ninstalled).  If True, time tests and report on all of them.\nIf an integer (say N), report timing results for N slowest\ntests.\n\n\n\nReturns\n\nresultobjectReturns the result of running the tests as a\nnose.result.TextTestResult object.\n\n\n\n\nNotes\nEach NumPy module exposes test in its namespace to run all tests for it.\nFor example, to run all tests for numpy.lib:\n&gt;&gt;&gt; np.lib.test() \n\n\nExamples\n&gt;&gt;&gt; result = np.lib.test() \nRunning unit tests for numpy.lib\n...\nRan 976 tests in 3.933s\n\n\nOK\n&gt;&gt;&gt; result.errors \n[]\n&gt;&gt;&gt; result.knownfail \n[]\n\n\n", "parameters": ["Parameters", "label{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional", "verboseint, optional", "extra_argvlist, optional", "doctestsbool, optional", "coveragebool, optional", "raise_warningsNone, str or sequence of warnings, optional", "timerbool or int, optional", "Returns", "resultobject"], "returns": "resultobjectReturns the result of running the tests as anose.result.TextTestResult object.", "examples": ["; result = np.lib.test() \nRunning unit tests for numpy.lib\n...\nRan 976 tests in 3.933s\n\n", "; result = np.lib.test() \nRunning unit tests for numpy.lib\n...\nRan 976 tests in 3.933s\n", "; result.errors \n[]\n; result.knownfail \n[]\n\n", "; result.errors \n[]\n; result.knownfail \n[]\n"]},
{"library": "numpy", "item_id": "numpy.linalg.tensorsolve", "code": "\nnumpy.linalg.tensorsolve(a, b, axes=None)[source]\u00b6", "description": "Solve the tensor equation a x = b for x.\nIt is assumed that all indices of x are summed over in the product,\ntogether with the rightmost indices of a, as is done in, for example,\ntensordot(a, x, axes=b.ndim).\n\nParameters\n\naarray_likeCoefficient tensor, of shape b.shape + Q. Q, a tuple, equals\nthe shape of that sub-tensor of a consisting of the appropriate\nnumber of its rightmost indices, and must be such that\nprod(Q) == prod(b.shape) (in which sense a is said to be\n\u2018square\u2019).\n\nbarray_likeRight-hand tensor, which can be of any shape.\n\naxestuple of ints, optionalAxes in a to reorder to the right, before inversion.\nIf None (default), no reordering is done.\n\n\n\nReturns\n\nxndarray, shape Q\n\n\nRaises\n\nLinAlgErrorIf a is singular or not \u2018square\u2019 (in the above sense).\n\n\n\n\n\nSee also\nnumpy.tensordot, tensorinv, numpy.einsum\n\nExamples\n&gt;&gt;&gt; a = np.eye(2*3*4)\n&gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)\n&gt;&gt;&gt; b = np.random.randn(2*3, 4)\n&gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)\n&gt;&gt;&gt; x.shape\n(2, 3, 4)\n&gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "barray_like", "axestuple of ints, optional", "Returns", "xndarray, shape Q", "Raises", "LinAlgError"], "returns": "xndarray, shape Q", "examples": ["; a = np.eye(2*3*4)\n; a.shape = (2*3, 4, 2, 3, 4)\n; b = np.random.randn(2*3, 4)\n; x = np.linalg.tensorsolve(a, b)\n; x.shape\n(2, 3, 4)\n; np.allclose(np.tensordot(a, x, axes=3), b)\nTrue\n\n", "; a = np.eye(2*3*4)\n; a.shape = (2*3, 4, 2, 3, 4)\n; b = np.random.randn(2*3, 4)\n; x = np.linalg.tensorsolve(a, b)\n; x.shape\n(2, 3, 4)\n; np.allclose(np.tensordot(a, x, axes=3), b)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.linalg.tensorinv", "code": "\nnumpy.linalg.tensorinv(a, ind=2)[source]\u00b6", "description": "Compute the \u2018inverse\u2019 of an N-dimensional array.\nThe result is an inverse for a relative to the tensordot operation\ntensordot(a, b, ind), i. e., up to floating-point accuracy,\ntensordot(tensorinv(a), a, ind) is the \u201cidentity\u201d tensor for the\ntensordot operation.\n\nParameters\n\naarray_likeTensor to \u2018invert\u2019. Its shape must be \u2018square\u2019, i. e.,\nprod(a.shape[:ind]) == prod(a.shape[ind:]).\n\nindint, optionalNumber of first indices that are involved in the inverse sum.\nMust be a positive integer, default is 2.\n\n\n\nReturns\n\nbndarraya\u2019s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].\n\n\n\nRaises\n\nLinAlgErrorIf a is singular or not \u2018square\u2019 (in the above sense).\n\n\n\n\n\nSee also\nnumpy.tensordot, tensorsolve\n\nExamples\n&gt;&gt;&gt; a = np.eye(4*6)\n&gt;&gt;&gt; a.shape = (4, 6, 8, 3)\n&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)\n&gt;&gt;&gt; ainv.shape\n(8, 3, 4, 6)\n&gt;&gt;&gt; b = np.random.randn(4, 6)\n&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))\nTrue\n\n\n&gt;&gt;&gt; a = np.eye(4*6)\n&gt;&gt;&gt; a.shape = (24, 8, 3)\n&gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)\n&gt;&gt;&gt; ainv.shape\n(8, 3, 24)\n&gt;&gt;&gt; b = np.random.randn(24)\n&gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "indint, optional", "Returns", "bndarray", "Raises", "LinAlgError"], "returns": "bndarraya\u2019s tensordot inverse, shape a.shape[ind:] + a.shape[:ind].", "examples": ["; a = np.eye(4*6)\n; a.shape = (4, 6, 8, 3)\n; ainv = np.linalg.tensorinv(a, ind=2)\n; ainv.shape\n(8, 3, 4, 6)\n; b = np.random.randn(4, 6)\n; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))\nTrue\n\n", "; a = np.eye(4*6)\n; a.shape = (4, 6, 8, 3)\n; ainv = np.linalg.tensorinv(a, ind=2)\n; ainv.shape\n(8, 3, 4, 6)\n; b = np.random.randn(4, 6)\n; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))\nTrue\n", "; a = np.eye(4*6)\n; a.shape = (24, 8, 3)\n; ainv = np.linalg.tensorinv(a, ind=1)\n; ainv.shape\n(8, 3, 24)\n; b = np.random.randn(24)\n; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))\nTrue\n\n", "; a = np.eye(4*6)\n; a.shape = (24, 8, 3)\n; ainv = np.linalg.tensorinv(a, ind=1)\n; ainv.shape\n(8, 3, 24)\n; b = np.random.randn(24)\n; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.tensordot", "code": "\nnumpy.tensordot(a, b, axes=2)[source]\u00b6", "description": "Compute tensor dot product along specified axes.\nGiven two tensors, a and b, and an array_like object containing\ntwo array_like objects, (a_axes, b_axes), sum the products of\na\u2019s and b\u2019s elements (components) over the axes specified by\na_axes and b_axes. The third argument can be a single non-negative\ninteger_like scalar, N; if it is such, then the last N dimensions\nof a and the first N dimensions of b are summed over.\n\nParameters\n\na, barray_likeTensors to \u201cdot\u201d.\n\naxesint or (2,) array_like\ninteger_like\nIf an int N, sum over the last N axes of a and the first N axes\nof b in order. The sizes of the corresponding axes must match.\n(2,) array_like\nOr, a list of axes to be summed over, first sequence applying to a,\nsecond to b. Both elements array_like must be of the same length.\n\n\n\n\nReturns\n\noutputndarrayThe tensor dot product of the input.\n\n\n\n\n\nSee also\ndot, einsum\n\nNotes\n\nThree common use cases are:\naxes = 0 : tensor product \naxes = 1 : tensor dot product \naxes = 2 : (default) tensor double contraction \n\n\n\nWhen axes is integer_like, the sequence for evaluation will be: first\nthe -Nth axis in a and 0th axis in b, and the -1th axis in a and\nNth axis in b last.\nWhen there is more than one axis to sum over - and they are not the last\n(first) axes of a (b) - the argument axes should consist of\ntwo sequences of the same length, with the first axis to sum over given\nfirst in both sequences, the second axis second, and so forth.\nThe shape of the result consists of the non-contracted axes of the\nfirst tensor, followed by the non-contracted axes of the second.\nExamples\nA \u201ctraditional\u201d example:\n&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)\n&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)\n&gt;&gt;&gt; c = np.tensordot(a,b, axes=([1,0],[0,1]))\n&gt;&gt;&gt; c.shape\n(5, 2)\n&gt;&gt;&gt; c\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n&gt;&gt;&gt; # A slower but equivalent way of computing the same...\n&gt;&gt;&gt; d = np.zeros((5,2))\n&gt;&gt;&gt; for i in range(5):\n...   for j in range(2):\n...     for k in range(3):\n...       for n in range(4):\n...         d[i,j] += a[k,n,i] * b[n,k,j]\n&gt;&gt;&gt; c == d\narray([[ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True]])\n\n\nAn extended example taking advantage of the overloading of + and *:\n&gt;&gt;&gt; a = np.array(range(1, 9))\n&gt;&gt;&gt; a.shape = (2, 2, 2)\n&gt;&gt;&gt; A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n&gt;&gt;&gt; A.shape = (2, 2)\n&gt;&gt;&gt; a; A\narray([[[1, 2],\n        [3, 4]],\n       [[5, 6],\n        [7, 8]]])\narray([['a', 'b'],\n       ['c', 'd']], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A) # third argument default is 2 for double-contraction\narray(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A, 1)\narray([[['acc', 'bdd'],\n        ['aaacccc', 'bbbdddd']],\n       [['aaaaacccccc', 'bbbbbdddddd'],\n        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A, 0) # tensor product (result too long to incl.)\narray([[[[['a', 'b'],\n          ['c', 'd']],\n          ...\n\n\n&gt;&gt;&gt; np.tensordot(a, A, (0, 1))\narray([[['abbbbb', 'cddddd'],\n        ['aabbbbbb', 'ccdddddd']],\n       [['aaabbbbbbb', 'cccddddddd'],\n        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A, (2, 1))\narray([[['abb', 'cdd'],\n        ['aaabbbb', 'cccdddd']],\n       [['aaaaabbbbbb', 'cccccdddddd'],\n        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A, ((0, 1), (0, 1)))\narray(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n\n\n&gt;&gt;&gt; np.tensordot(a, A, ((2, 1), (1, 0)))\narray(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n\n\n", "parameters": ["Parameters", "a, barray_like", "axesint or (2,) array_like", "Returns", "outputndarray"], "returns": "outputndarrayThe tensor dot product of the input.", "examples": ["; a = np.arange(60.).reshape(3,4,5)\n; b = np.arange(24.).reshape(4,3,2)\n; c = np.tensordot(a,b, axes=([1,0],[0,1]))\n; c.shape\n(5, 2)\n; c\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; # A slower but equivalent way of computing the same...\n; d = np.zeros((5,2))\n; for i in range(5):\n...   for j in range(2):\n...     for k in range(3):\n...       for n in range(4):\n...         d[i,j] += a[k,n,i] * b[n,k,j]\n; c == d\narray([[ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True]])\n\n", "; a = np.arange(60.).reshape(3,4,5)\n; b = np.arange(24.).reshape(4,3,2)\n; c = np.tensordot(a,b, axes=([1,0],[0,1]))\n; c.shape\n(5, 2)\n; c\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; # A slower but equivalent way of computing the same...\n; d = np.zeros((5,2))\n; for i in range(5):\n...   for j in range(2):\n...     for k in range(3):\n...       for n in range(4):\n...         d[i,j] += a[k,n,i] * b[n,k,j]\n; c == d\narray([[ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True],\n       [ True,  True]])\n", "; a = np.array(range(1, 9))\n; a.shape = (2, 2, 2)\n; A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n; A.shape = (2, 2)\n; a; A\narray([[[1, 2],\n        [3, 4]],\n       [[5, 6],\n        [7, 8]]])\narray([['a', 'b'],\n       ['c', 'd']], dtype=object)\n\n", "; a = np.array(range(1, 9))\n; a.shape = (2, 2, 2)\n; A = np.array(('a', 'b', 'c', 'd'), dtype=object)\n; A.shape = (2, 2)\n; a; A\narray([[[1, 2],\n        [3, 4]],\n       [[5, 6],\n        [7, 8]]])\narray([['a', 'b'],\n       ['c', 'd']], dtype=object)\n", "; np.tensordot(a, A) # third argument default is 2 for double-contraction\narray(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n\n", "; np.tensordot(a, A) # third argument default is 2 for double-contraction\narray(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)\n", "; np.tensordot(a, A, 1)\narray([[['acc', 'bdd'],\n        ['aaacccc', 'bbbdddd']],\n       [['aaaaacccccc', 'bbbbbdddddd'],\n        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n\n", "; np.tensordot(a, A, 1)\narray([[['acc', 'bdd'],\n        ['aaacccc', 'bbbdddd']],\n       [['aaaaacccccc', 'bbbbbdddddd'],\n        ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)\n", "; np.tensordot(a, A, 0) # tensor product (result too long to incl.)\narray([[[[['a', 'b'],\n          ['c', 'd']],\n          ...\n\n", "; np.tensordot(a, A, 0) # tensor product (result too long to incl.)\narray([[[[['a', 'b'],\n          ['c', 'd']],\n          ...\n", "; np.tensordot(a, A, (0, 1))\narray([[['abbbbb', 'cddddd'],\n        ['aabbbbbb', 'ccdddddd']],\n       [['aaabbbbbbb', 'cccddddddd'],\n        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n\n", "; np.tensordot(a, A, (0, 1))\narray([[['abbbbb', 'cddddd'],\n        ['aabbbbbb', 'ccdddddd']],\n       [['aaabbbbbbb', 'cccddddddd'],\n        ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)\n", "; np.tensordot(a, A, (2, 1))\narray([[['abb', 'cdd'],\n        ['aaabbbb', 'cccdddd']],\n       [['aaaaabbbbbb', 'cccccdddddd'],\n        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n\n", "; np.tensordot(a, A, (2, 1))\narray([[['abb', 'cdd'],\n        ['aaabbbb', 'cccdddd']],\n       [['aaaaabbbbbb', 'cccccdddddd'],\n        ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)\n", "; np.tensordot(a, A, ((0, 1), (0, 1)))\narray(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n\n", "; np.tensordot(a, A, ((0, 1), (0, 1)))\narray(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)\n", "; np.tensordot(a, A, ((2, 1), (1, 0)))\narray(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n\n", "; np.tensordot(a, A, ((2, 1), (1, 0)))\narray(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)\n"]},
{"library": "numpy", "item_id": "numpy.tanh", "code": "\nnumpy.tanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'tanh'&gt;\u00b6", "description": "Compute hyperbolic tangent element-wise.\nEquivalent to np.sinh(x)/np.cosh(x) or -1j * np.tan(1j*x).\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding hyperbolic tangent values.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nIf out is provided, the function writes the result into it,\nand returns a reference to out.  (See Examples)\nReferences\n\n1\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.\nhttp://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cHyperbolic function\u201d,\nhttps://en.wikipedia.org/wiki/Hyperbolic_function\n\n\nExamples\n&gt;&gt;&gt; np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n\n&gt;&gt;&gt; # Example of providing the optional output parameter illustrating\n&gt;&gt;&gt; # that what is returned is a reference to said parameter\n&gt;&gt;&gt; out1 = np.array([0], dtype='d')\n&gt;&gt;&gt; out2 = np.tanh([0.1], out1)\n&gt;&gt;&gt; out2 is out1\nTrue\n\n\n&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`\n&gt;&gt;&gt; np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding hyperbolic tangent values.This is a scalar if x is a scalar.", "examples": ["; np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n\n", "; np.tanh((0, np.pi*1j, np.pi*1j/2))\narray([ 0. +0.00000000e+00j,  0. -1.22460635e-16j,  0. +1.63317787e+16j])\n", "; # Example of providing the optional output parameter illustrating\n; # that what is returned is a reference to said parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.tanh([0.1], out1)\n; out2 is out1\nTrue\n\n", "; # Example of providing the optional output parameter illustrating\n; # that what is returned is a reference to said parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.tanh([0.1], out1)\n; out2 is out1\nTrue\n", "; # Example of ValueError due to provision of shape mis-matched `out`\n; np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n", "; # Example of ValueError due to provision of shape mis-matched `out`\n; np.tanh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n"]},
{"library": "numpy", "item_id": "numpy.tan", "code": "\nnumpy.tan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'tan'&gt;\u00b6", "description": "Compute tangent element-wise.\nEquivalent to np.sin(x)/np.cos(x) element-wise.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding tangent values.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nIf out is provided, the function writes the result into it,\nand returns a reference to out.  (See Examples)\nReferences\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\nExamples\n&gt;&gt;&gt; from math import pi\n&gt;&gt;&gt; np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example of providing the optional output parameter illustrating\n&gt;&gt;&gt; # that what is returned is a reference to said parameter\n&gt;&gt;&gt; out1 = np.array([0], dtype='d')\n&gt;&gt;&gt; out2 = np.cos([0.1], out1)\n&gt;&gt;&gt; out2 is out1\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`\n&gt;&gt;&gt; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding tangent values.This is a scalar if x is a scalar.", "examples": ["; from math import pi\n; np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n;\n; # Example of providing the optional output parameter illustrating\n; # that what is returned is a reference to said parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.cos([0.1], out1)\n; out2 is out1\nTrue\n;\n; # Example of ValueError due to provision of shape mis-matched `out`\n; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n", "; from math import pi\n; np.tan(np.array([-pi,pi/2,pi]))\narray([  1.22460635e-16,   1.63317787e+16,  -1.22460635e-16])\n;\n; # Example of providing the optional output parameter illustrating\n; # that what is returned is a reference to said parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.cos([0.1], out1)\n; out2 is out1\nTrue\n;\n; # Example of ValueError due to provision of shape mis-matched `out`\n; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n"]},
{"library": "numpy", "item_id": "numpy.take_along_axis", "code": "\nnumpy.take_along_axis(arr, indices, axis)[source]\u00b6", "description": "Take values from the input array by matching 1d index and data slices.\nThis iterates over matching 1d slices oriented along the specified axis in\nthe index and data arrays, and uses the former to look up values in the\nlatter. These slices can be different lengths.\nFunctions returning an index along an axis, like argsort and\nargpartition, produce suitable indices for this function.\n\nNew in version 1.15.0.\n\n\nParameters\n\narr: ndarray (Ni\u2026, M, Nk\u2026)Source array\n\nindices: ndarray (Ni\u2026, J, Nk\u2026)Indices to take along each 1d slice of arr. This must match the\ndimension of arr, but dimensions Ni and Nj only need to broadcast\nagainst arr.\n\naxis: intThe axis to take 1d slices along. If axis is None, the input array is\ntreated as if it had first been flattened to 1d, for consistency with\nsort and argsort.\n\n\n\nReturns\n\nout: ndarray (Ni\u2026, J, Nk\u2026)The indexed result.\n\n\n\n\n\nSee also\n\ntakeTake along an axis, using the same indices for every 1d slice\n\nput_along_axisPut values into the destination array by matching 1d index and data slices\n\n\n\nNotes\nThis is equivalent to (but faster than) the following use of ndindex and\ns_, which sets each of ii and kk to a tuple of indices:\nNi, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]\nJ = indices.shape[axis]  # Need not equal M\nout = np.empty(Ni + (J,) + Nk)\n\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        a_1d       = a      [ii + s_[:,] + kk]\n        indices_1d = indices[ii + s_[:,] + kk]\n        out_1d     = out    [ii + s_[:,] + kk]\n        for j in range(J):\n            out_1d[j] = a_1d[indices_1d[j]]\n\n\nEquivalently, eliminating the inner loop, the last two lines would be:\nout_1d[:] = a_1d[indices_1d]\n\n\nExamples\nFor this sample array\n&gt;&gt;&gt; a = np.array([[10, 30, 20], [60, 40, 50]])\n\n\nWe can sort either by using sort directly, or argsort and this function\n&gt;&gt;&gt; np.sort(a, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n&gt;&gt;&gt; ai = np.argsort(a, axis=1); ai\narray([[0, 2, 1],\n       [1, 2, 0]])\n&gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n\n\nThe same works for max and min, if you expand the dimensions:\n&gt;&gt;&gt; np.expand_dims(np.max(a, axis=1), axis=1)\narray([[30],\n       [60]])\n&gt;&gt;&gt; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n&gt;&gt;&gt; ai\narray([[1],\n       [0]])\n&gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)\narray([[30],\n       [60]])\n\n\nIf we want to get the max and min at the same time, we can stack the\nindices first\n&gt;&gt;&gt; ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)\n&gt;&gt;&gt; ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)\n&gt;&gt;&gt; ai = np.concatenate([ai_min, ai_max], axis=1)\n&gt;&gt;&gt; ai\narray([[0, 1],\n       [1, 0]])\n&gt;&gt;&gt; np.take_along_axis(a, ai, axis=1)\narray([[10, 30],\n       [40, 60]])\n\n\n", "parameters": ["Parameters", "arr: ndarray (Ni\u2026, M, Nk\u2026)", "indices: ndarray (Ni\u2026, J, Nk\u2026)", "axis: int", "Returns", "out: ndarray (Ni\u2026, J, Nk\u2026)"], "returns": "out: ndarray (Ni\u2026, J, Nk\u2026)The indexed result.", "examples": ["; a = np.array([[10, 30, 20], [60, 40, 50]])\n\n", "; a = np.array([[10, 30, 20], [60, 40, 50]])\n", "; np.sort(a, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n; ai = np.argsort(a, axis=1); ai\narray([[0, 2, 1],\n       [1, 2, 0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n\n", "; np.sort(a, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n; ai = np.argsort(a, axis=1); ai\narray([[0, 2, 1],\n       [1, 2, 0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[10, 20, 30],\n       [40, 50, 60]])\n", "; np.expand_dims(np.max(a, axis=1), axis=1)\narray([[30],\n       [60]])\n; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai\narray([[1],\n       [0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[30],\n       [60]])\n\n", "; np.expand_dims(np.max(a, axis=1), axis=1)\narray([[30],\n       [60]])\n; ai = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai\narray([[1],\n       [0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[30],\n       [60]])\n", "; ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)\n; ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai = np.concatenate([ai_min, ai_max], axis=1)\n; ai\narray([[0, 1],\n       [1, 0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[10, 30],\n       [40, 60]])\n\n", "; ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1)\n; ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1)\n; ai = np.concatenate([ai_min, ai_max], axis=1)\n; ai\narray([[0, 1],\n       [1, 0]])\n; np.take_along_axis(a, ai, axis=1)\narray([[10, 30],\n       [40, 60]])\n"]},
{"library": "numpy", "item_id": "numpy.record.take", "code": "\nrecord.take()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.take", "code": "\nMaskedArray.take(self, indices, axis=None, out=None, mode='raise')[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.take", "code": "\nrecarray.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.take", "code": "\nmasked_array.take(self, indices, axis=None, out=None, mode='raise')[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.take", "code": "\ngeneric.take()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.take", "code": "\nchararray.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.take", "code": "\nnumpy.take(a, indices, axis=None, out=None, mode='raise')[source]\u00b6", "description": "Take elements from an array along an axis.\nWhen axis is not None, this function does the same thing as \u201cfancy\u201d\nindexing (indexing arrays using arrays); however, it can be easier to use\nif you need elements along a given axis. A call such as\nnp.take(arr, indices, axis=3) is equivalent to\narr[:,:,:,indices,...].\nExplained without fancy indexing, this is equivalent to the following use\nof ndindex, which sets each of ii, jj, and kk to a tuple of\nindices:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nNj = indices.shape\nfor ii in ndindex(Ni):\n    for jj in ndindex(Nj):\n        for kk in ndindex(Nk):\n            out[ii + jj + kk] = a[ii + (indices[jj],) + kk]\n\n\n\nParameters\n\naarray_like (Ni\u2026, M, Nk\u2026)The source array.\n\nindicesarray_like (Nj\u2026)The indices of the values to extract.\n\nNew in version 1.8.0.\n\nAlso allow scalars for indices.\n\naxisint, optionalThe axis over which to select values. By default, the flattened\ninput array is used.\n\noutndarray, optional (Ni\u2026, Nj\u2026, Nk\u2026)If provided, the result will be placed in this array. It should\nbe of the appropriate shape and dtype. Note that out is always\nbuffered if mode=\u2019raise\u2019; use other modes for better performance.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices will behave.\n\n\u2018raise\u2019 \u2013 raise an error (default)\n\u2018wrap\u2019 \u2013 wrap around\n\u2018clip\u2019 \u2013 clip to the range\n\n\u2018clip\u2019 mode means that all indices that are too large are replaced\nby the index that addresses the last element along that axis. Note\nthat this disables indexing with negative numbers.\n\n\n\nReturns\n\noutndarray (Ni\u2026, Nj\u2026, Nk\u2026)The returned array has the same type as a.\n\n\n\n\n\nSee also\n\ncompressTake elements using a boolean mask\n\nndarray.takeequivalent method\n\ntake_along_axisTake elements by matching the array and the index arrays\n\n\n\nNotes\nBy eliminating the inner loop in the description above, and using s_ to\nbuild simple slice objects, take can be expressed  in terms of applying\nfancy indexing to each 1-d slice:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nj):\n        out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]\n\n\nFor this reason, it is equivalent to (but faster than) the following use\nof apply_along_axis:\nout = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)\n\n\nExamples\n&gt;&gt;&gt; a = [4, 3, 5, 7, 6, 8]\n&gt;&gt;&gt; indices = [0, 1, 4]\n&gt;&gt;&gt; np.take(a, indices)\narray([4, 3, 6])\n\n\nIn this example if a is an ndarray, \u201cfancy\u201d indexing can be used.\n&gt;&gt;&gt; a = np.array(a)\n&gt;&gt;&gt; a[indices]\narray([4, 3, 6])\n\n\nIf indices is not one dimensional, the output also has these dimensions.\n&gt;&gt;&gt; np.take(a, [[0, 1], [2, 3]])\narray([[4, 3],\n       [5, 7]])\n\n\n", "parameters": ["Parameters", "aarray_like (Ni\u2026, M, Nk\u2026)", "indicesarray_like (Nj\u2026)", "axisint, optional", "outndarray, optional (Ni\u2026, Nj\u2026, Nk\u2026)", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional", "Returns", "outndarray (Ni\u2026, Nj\u2026, Nk\u2026)"], "returns": "outndarray (Ni\u2026, Nj\u2026, Nk\u2026)The returned array has the same type as a.", "examples": ["; a = [4, 3, 5, 7, 6, 8]\n; indices = [0, 1, 4]\n; np.take(a, indices)\narray([4, 3, 6])\n\n", "; a = [4, 3, 5, 7, 6, 8]\n; indices = [0, 1, 4]\n; np.take(a, indices)\narray([4, 3, 6])\n", "; a = np.array(a)\n; a[indices]\narray([4, 3, 6])\n\n", "; a = np.array(a)\n; a[indices]\narray([4, 3, 6])\n", "; np.take(a, [[0, 1], [2, 3]])\narray([[4, 3],\n       [5, 7]])\n\n", "; np.take(a, [[0, 1], [2, 3]])\narray([[4, 3],\n       [5, 7]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.T", "code": "\nproperty matrix.T\u00b6", "description": "Returns the transpose of the matrix.\nDoes not conjugate!  For the complex conjugate transpose, use .H.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectThe (non-conjugated) transpose of the matrix.\n\n\n\n\n\nSee also\ntranspose, getH\n\nExamples\n&gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]')\n&gt;&gt;&gt; m\nmatrix([[1, 2],\n        [3, 4]])\n&gt;&gt;&gt; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object"], "returns": "retmatrix objectThe (non-conjugated) transpose of the matrix.", "examples": ["; m = np.matrix('[1, 2; 3, 4]')\n; m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n", "; m = np.matrix('[1, 2; 3, 4]')\n; m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.take", "code": "\nchararray.take(indices, axis=None, out=None, mode='raise')\u00b6", "description": "Return an array formed from the elements of a at the given indices.\nRefer to numpy.take for full documentation.\n\nSee also\n\nnumpy.takeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.T", "code": "\nproperty MaskedArray.T\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.T", "code": "\nproperty masked_array.T\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.T", "code": "\nrecord.T\u00b6", "description": "transpose\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.T", "code": "\nrecarray.T\u00b6", "description": "The transposed array.\nSame as self.transpose().\n\nSee also\ntranspose\n\nExamples\n&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])\n&gt;&gt;&gt; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n&gt;&gt;&gt; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])\n&gt;&gt;&gt; x\narray([ 1.,  2.,  3.,  4.])\n&gt;&gt;&gt; x.T\narray([ 1.,  2.,  3.,  4.])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n\n", "; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.T", "code": "\nndarray.T\u00b6", "description": "The transposed array.\nSame as self.transpose().\n\nSee also\ntranspose\n\nExamples\n&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])\n&gt;&gt;&gt; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n&gt;&gt;&gt; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])\n&gt;&gt;&gt; x\narray([ 1.,  2.,  3.,  4.])\n&gt;&gt;&gt; x.T\narray([ 1.,  2.,  3.,  4.])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n\n", "; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.T", "code": "\nmemmap.T\u00b6", "description": "The transposed array.\nSame as self.transpose().\n\nSee also\ntranspose\n\nExamples\n&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])\n&gt;&gt;&gt; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n&gt;&gt;&gt; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])\n&gt;&gt;&gt; x\narray([ 1.,  2.,  3.,  4.])\n&gt;&gt;&gt; x.T\narray([ 1.,  2.,  3.,  4.])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n\n", "; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.T", "code": "\nMaskType.T\u00b6", "description": "transpose\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.T", "code": "\ngeneric.T\u00b6", "description": "transpose\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.T", "code": "\nchararray.T\u00b6", "description": "The transposed array.\nSame as self.transpose().\n\nSee also\ntranspose\n\nExamples\n&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])\n&gt;&gt;&gt; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n&gt;&gt;&gt; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])\n&gt;&gt;&gt; x\narray([ 1.,  2.,  3.,  4.])\n&gt;&gt;&gt; x.T\narray([ 1.,  2.,  3.,  4.])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n\n", "; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.T", "code": "\nchararray.T\u00b6", "description": "The transposed array.\nSame as self.transpose().\n\nSee also\ntranspose\n\nExamples\n&gt;&gt;&gt; x = np.array([[1.,2.],[3.,4.]])\n&gt;&gt;&gt; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n&gt;&gt;&gt; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n&gt;&gt;&gt; x = np.array([1.,2.,3.,4.])\n&gt;&gt;&gt; x\narray([ 1.,  2.,  3.,  4.])\n&gt;&gt;&gt; x.T\narray([ 1.,  2.,  3.,  4.])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n\n", "; x = np.array([[1.,2.],[3.,4.]])\n; x\narray([[ 1.,  2.],\n       [ 3.,  4.]])\n; x.T\narray([[ 1.,  3.],\n       [ 2.,  4.]])\n; x = np.array([1.,2.,3.,4.])\n; x\narray([ 1.,  2.,  3.,  4.])\n; x.T\narray([ 1.,  2.,  3.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.swapcase", "code": "\nchararray.swapcase(self)[source]\u00b6", "description": "For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.\n\nSee also\nchar.swapcase\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.swapcase", "code": "\nchararray.swapcase(self)\u00b6", "description": "For each element in self, return a copy of the string with\nuppercase characters converted to lowercase and vice versa.\n\nSee also\nchar.swapcase\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.swapcase", "code": "\nnumpy.char.swapcase(a)\u00b6", "description": "Return element-wise a copy of the string with\nuppercase characters converted to lowercase and vice versa.\nCalls str.swapcase element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like, {str, unicode}Input array.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.swapcase\n\nExamples\n&gt;&gt;&gt; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c\narray(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],\n    dtype='|S5')\n&gt;&gt;&gt; np.char.swapcase(c)\narray(['A1b C', '1B cA', 'B cA1', 'Ca1B'],\n    dtype='|S5')\n\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type", "examples": ["; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c\narray(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],\n    dtype='|S5')\n; np.char.swapcase(c)\narray(['A1b C', '1B cA', 'B cA1', 'Ca1B'],\n    dtype='|S5')\n\n", "; c=np.array(['a1B c','1b Ca','b Ca1','cA1b'],'S5'); c\narray(['a1B c', '1b Ca', 'b Ca1', 'cA1b'],\n    dtype='|S5')\n; np.char.swapcase(c)\narray(['A1b C', '1B cA', 'B cA1', 'Ca1B'],\n    dtype='|S5')\n"]},
{"library": "numpy", "item_id": "numpy.record.swapaxes", "code": "\nrecord.swapaxes()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.swapaxes", "code": "\nrecarray.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.swapaxes", "code": "\nndarray.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.swapaxes", "code": "\nmemmap.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.swapaxes", "code": "\nmatrix.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.swapaxes", "code": "\nMaskType.swapaxes()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.swapaxes", "code": "\ngeneric.swapaxes()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.swapaxes", "code": "\nchararray.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.swapaxes", "code": "\nmasked_array.swapaxes(axis1, axis2)[source]\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.swapaxes", "code": "\nchararray.swapaxes(axis1, axis2)\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.swapaxes", "code": "\nnumpy.swapaxes(a, axis1, axis2)[source]\u00b6", "description": "Interchange two axes of an array.\n\nParameters\n\naarray_likeInput array.\n\naxis1intFirst axis.\n\naxis2intSecond axis.\n\n\n\nReturns\n\na_swappedndarrayFor NumPy &gt;= 1.10.0, if a is an ndarray, then a view of a is\nreturned; otherwise a new array is created. For earlier NumPy\nversions a view of a is returned only if the order of the\naxes is changed, otherwise the input array is returned.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3]])\n&gt;&gt;&gt; np.swapaxes(x,0,1)\narray([[1],\n       [2],\n       [3]])\n\n\n&gt;&gt;&gt; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n&gt;&gt;&gt; x\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n\n\n&gt;&gt;&gt; np.swapaxes(x,0,2)\narray([[[0, 4],\n        [2, 6]],\n       [[1, 5],\n        [3, 7]]])\n\n\n", "parameters": ["Parameters", "aarray_like", "axis1int", "axis2int", "Returns", "a_swappedndarray"], "returns": "a_swappedndarrayFor NumPy &gt;= 1.10.0, if a is an ndarray, then a view of a isreturned; otherwise a new array is created. For earlier NumPyversions a view of a is returned only if the order of theaxes is changed, otherwise the input array is returned.", "examples": ["; x = np.array([[1,2,3]])\n; np.swapaxes(x,0,1)\narray([[1],\n       [2],\n       [3]])\n\n", "; x = np.array([[1,2,3]])\n; np.swapaxes(x,0,1)\narray([[1],\n       [2],\n       [3]])\n", "; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n; x\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n\n", "; x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])\n; x\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n", "; np.swapaxes(x,0,2)\narray([[[0, 4],\n        [2, 6]],\n       [[1, 5],\n        [3, 7]]])\n\n", "; np.swapaxes(x,0,2)\narray([[[0, 4],\n        [2, 6]],\n       [[1, 5],\n        [3, 7]]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.swapaxes", "code": "\nnumpy.ma.swapaxes(self, *args, **params) a.swapaxes(axis1, axis2) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "\nReturn a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.swapaxes", "code": "\nMaskedArray.swapaxes(axis1, axis2)[source]\u00b6", "description": "Return a view of the array with axis1 and axis2 interchanged.\nRefer to numpy.swapaxes for full documentation.\n\nSee also\n\nnumpy.swapaxesequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.svd", "code": "\nnumpy.linalg.svd(a, full_matrices=True, compute_uv=True, hermitian=False)[source]\u00b6", "description": "Singular Value Decomposition.\nWhen a is a 2D array, it is factorized as u @ np.diag(s) @ vh\n= (u * s) @ vh, where u and vh are 2D unitary arrays and s is a 1D\narray of a\u2019s singular values. When a is higher-dimensional, SVD is\napplied in stacked mode as explained below.\n\nParameters\n\na(\u2026, M, N) array_likeA real or complex array with a.ndim &gt;= 2.\n\nfull_matricesbool, optionalIf True (default), u and vh have the shapes (..., M, M) and\n(..., N, N), respectively.  Otherwise, the shapes are\n(..., M, K) and (..., K, N), respectively, where\nK = min(M, N).\n\ncompute_uvbool, optionalWhether or not to compute u and vh in addition to s.  True\nby default.\n\nhermitianbool, optionalIf True, a is assumed to be Hermitian (symmetric if real-valued),\nenabling a more efficient method for finding singular values.\nDefaults to False.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nu{ (\u2026, M, M), (\u2026, M, K) } arrayUnitary array(s). The first a.ndim - 2 dimensions have the same\nsize as those of the input a. The size of the last two dimensions\ndepends on the value of full_matrices. Only returned when\ncompute_uv is True.\n\ns(\u2026, K) arrayVector(s) with the singular values, within each vector sorted in\ndescending order. The first a.ndim - 2 dimensions have the same\nsize as those of the input a.\n\nvh{ (\u2026, N, N), (\u2026, K, N) } arrayUnitary array(s). The first a.ndim - 2 dimensions have the same\nsize as those of the input a. The size of the last two dimensions\ndepends on the value of full_matrices. Only returned when\ncompute_uv is True.\n\n\n\nRaises\n\nLinAlgErrorIf SVD computation does not converge.\n\n\n\n\nNotes\n\nChanged in version 1.8.0: Broadcasting rules apply, see the numpy.linalg documentation for\ndetails.\n\nThe decomposition is performed using LAPACK routine _gesdd.\nSVD is usually described for the factorization of a 2D matrix .\nThe higher-dimensional case will be discussed below. In the 2D case, SVD is\nwritten as , where , ,\n and . The 1D array s\ncontains the singular values of a and u and vh are unitary. The rows\nof vh are the eigenvectors of  and the columns of u are\nthe eigenvectors of . In both cases the corresponding\n(possibly non-zero) eigenvalues are given by s**2.\nIf a has more than two dimensions, then broadcasting rules apply, as\nexplained in Linear algebra on several matrices at once. This means that SVD is\nworking in \u201cstacked\u201d mode: it iterates over all indices of the first\na.ndim - 2 dimensions and for each combination SVD is applied to the\nlast two indices. The matrix a can be reconstructed from the\ndecomposition with either (u * s[..., None, :]) @ vh or\nu @ (s[..., None] * vh). (The @ operator can be replaced by the\nfunction np.matmul for python versions below 3.5.)\nIf a is a matrix object (as opposed to an ndarray), then so are\nall the return values.\nExamples\n&gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)\n&gt;&gt;&gt; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)\n\n\nReconstruction based on full SVD, 2D case:\n&gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=True)\n&gt;&gt;&gt; u.shape, s.shape, vh.shape\n((9, 9), (6,), (6, 6))\n&gt;&gt;&gt; np.allclose(a, np.dot(u[:, :6] * s, vh))\nTrue\n&gt;&gt;&gt; smat = np.zeros((9, 6), dtype=complex)\n&gt;&gt;&gt; smat[:6, :6] = np.diag(s)\n&gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n\n\nReconstruction based on reduced SVD, 2D case:\n&gt;&gt;&gt; u, s, vh = np.linalg.svd(a, full_matrices=False)\n&gt;&gt;&gt; u.shape, s.shape, vh.shape\n((9, 6), (6,), (6, 6))\n&gt;&gt;&gt; np.allclose(a, np.dot(u * s, vh))\nTrue\n&gt;&gt;&gt; smat = np.diag(s)\n&gt;&gt;&gt; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n\n\nReconstruction based on full SVD, 4D case:\n&gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=True)\n&gt;&gt;&gt; u.shape, s.shape, vh.shape\n((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))\n&gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))\nTrue\n&gt;&gt;&gt; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))\nTrue\n\n\nReconstruction based on reduced SVD, 4D case:\n&gt;&gt;&gt; u, s, vh = np.linalg.svd(b, full_matrices=False)\n&gt;&gt;&gt; u.shape, s.shape, vh.shape\n((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))\n&gt;&gt;&gt; np.allclose(b, np.matmul(u * s[..., None, :], vh))\nTrue\n&gt;&gt;&gt; np.allclose(b, np.matmul(u, s[..., None] * vh))\nTrue\n\n\n", "parameters": ["Parameters", "a(\u2026, M, N) array_like", "full_matricesbool, optional", "compute_uvbool, optional", "hermitianbool, optional", "Returns", "u{ (\u2026, M, M), (\u2026, M, K) } array", "s(\u2026, K) array", "vh{ (\u2026, N, N), (\u2026, K, N) } array", "Raises", "LinAlgError"], "returns": "u{ (\u2026, M, M), (\u2026, M, K) } arrayUnitary array(s). The first a.ndim - 2 dimensions have the samesize as those of the input a. The size of the last two dimensionsdepends on the value of full_matrices. Only returned whencompute_uv is True.s(\u2026, K) arrayVector(s) with the singular values, within each vector sorted indescending order. The first a.ndim - 2 dimensions have the samesize as those of the input a.vh{ (\u2026, N, N), (\u2026, K, N) } arrayUnitary array(s). The first a.ndim - 2 dimensions have the samesize as those of the input a. The size of the last two dimensionsdepends on the value of full_matrices. Only returned whencompute_uv is True.", "examples": ["; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)\n; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)\n\n", "; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)\n; b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)\n", "; u, s, vh = np.linalg.svd(a, full_matrices=True)\n; u.shape, s.shape, vh.shape\n((9, 9), (6,), (6, 6))\n; np.allclose(a, np.dot(u[:, :6] * s, vh))\nTrue\n; smat = np.zeros((9, 6), dtype=complex)\n; smat[:6, :6] = np.diag(s)\n; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n\n", "; u, s, vh = np.linalg.svd(a, full_matrices=True)\n; u.shape, s.shape, vh.shape\n((9, 9), (6,), (6, 6))\n; np.allclose(a, np.dot(u[:, :6] * s, vh))\nTrue\n; smat = np.zeros((9, 6), dtype=complex)\n; smat[:6, :6] = np.diag(s)\n; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n", "; u, s, vh = np.linalg.svd(a, full_matrices=False)\n; u.shape, s.shape, vh.shape\n((9, 6), (6,), (6, 6))\n; np.allclose(a, np.dot(u * s, vh))\nTrue\n; smat = np.diag(s)\n; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n\n", "; u, s, vh = np.linalg.svd(a, full_matrices=False)\n; u.shape, s.shape, vh.shape\n((9, 6), (6,), (6, 6))\n; np.allclose(a, np.dot(u * s, vh))\nTrue\n; smat = np.diag(s)\n; np.allclose(a, np.dot(u, np.dot(smat, vh)))\nTrue\n", "; u, s, vh = np.linalg.svd(b, full_matrices=True)\n; u.shape, s.shape, vh.shape\n((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))\n; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))\nTrue\n; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))\nTrue\n\n", "; u, s, vh = np.linalg.svd(b, full_matrices=True)\n; u.shape, s.shape, vh.shape\n((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))\n; np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))\nTrue\n; np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))\nTrue\n", "; u, s, vh = np.linalg.svd(b, full_matrices=False)\n; u.shape, s.shape, vh.shape\n((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))\n; np.allclose(b, np.matmul(u * s[..., None, :], vh))\nTrue\n; np.allclose(b, np.matmul(u, s[..., None] * vh))\nTrue\n\n", "; u, s, vh = np.linalg.svd(b, full_matrices=False)\n; u.shape, s.shape, vh.shape\n((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))\n; np.allclose(b, np.matmul(u * s[..., None, :], vh))\nTrue\n; np.allclose(b, np.matmul(u, s[..., None] * vh))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.sum", "code": "\nndarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\u00b6", "description": "Return the sum of the array elements over the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.sumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.suppress_warnings", "code": "\nclass numpy.testing.suppress_warnings(forwarding_rule='always')[source]\u00b6", "description": "Context manager and decorator doing much the same as\nwarnings.catch_warnings.\nHowever, it also provides a filter mechanism to work around\nhttps://bugs.python.org/issue4180.\nThis bug causes Python before 3.4 to not reliably show warnings again\nafter they have been ignored once (even within catch_warnings). It\nmeans that no \u201cignore\u201d filter can be used easily, since following\ntests might need to see the warning. Additionally it allows easier\nspecificity for testing warnings and can be nested.\n\nParameters\n\nforwarding_rulestr, optionalOne of \u201calways\u201d, \u201conce\u201d, \u201cmodule\u201d, or \u201clocation\u201d. Analogous to\nthe usual warnings module filter mode, it is useful to reduce\nnoise mostly on the outmost level. Unsuppressed and unrecorded\nwarnings will be forwarded based on this rule. Defaults to \u201calways\u201d.\n\u201clocation\u201d is equivalent to the warnings \u201cdefault\u201d, match by exact\nlocation the warning warning originated from.\n\n\n\n\nNotes\nFilters added inside the context manager will be discarded again\nwhen leaving it. Upon entering all filters defined outside a\ncontext will be applied automatically.\nWhen a recording filter is added, matching warnings are stored in the\nlog attribute as well as in the list returned by record.\nIf filters are added and the module keyword is given, the\nwarning registry of this module will additionally be cleared when\napplying it, entering the context, or exiting it. This could cause\nwarnings to appear a second time after leaving the context if they\nwere configured to be printed once (default) and were already\nprinted before the context was entered.\nNesting this context manager will work as expected when the\nforwarding rule is \u201calways\u201d (default). Unfiltered and unrecorded\nwarnings will be passed out and be matched by the outer level.\nOn the outmost level they will be printed (or caught by another\nwarnings context). The forwarding rule argument can modify this\nbehaviour.\nLike catch_warnings this context manager is not threadsafe.\nExamples\nWith a context manager:\nwith np.testing.suppress_warnings() as sup:\n    sup.filter(DeprecationWarning, \"Some text\")\n    sup.filter(module=np.ma.core)\n    log = sup.record(FutureWarning, \"Does this occur?\")\n    command_giving_warnings()\n    # The FutureWarning was given once, the filtered warnings were\n    # ignored. All other warnings abide outside settings (may be\n    # printed/error)\n    assert_(len(log) == 1)\n    assert_(len(sup.log) == 1)  # also stored in log attribute\n\n\nOr as a decorator:\nsup = np.testing.suppress_warnings()\nsup.filter(module=np.ma.core)  # module must match exactly\n@sup\ndef some_function():\n    # do something which causes a warning in np.ma.core\n    pass\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0func)\nFunction decorator to apply certain suppressions to a whole function.\n\nfilter(self[,\u00a0category,\u00a0message,\u00a0module])\nAdd a new suppressing filter or apply it if the state is entered.\n\nrecord(self[,\u00a0category,\u00a0message,\u00a0module])\nAppend a new recording filter or apply it if the state is entered.\n\n\n\n", "parameters": ["Parameters", "forwarding_rulestr, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.sum", "code": "\nrecord.sum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.sum", "code": "\nmemmap.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\u00b6", "description": "Return the sum of the array elements over the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.sumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.sum", "code": "\nMaskType.sum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.sum", "code": "\nmatrix.sum(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Returns the sum of the matrix elements, along the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\nnumpy.sum\n\nNotes\nThis is the same as ndarray.sum, except that where an ndarray would\nbe returned, a matrix object is returned instead.\nExamples\n&gt;&gt;&gt; x = np.matrix([[1, 2], [4, 3]])\n&gt;&gt;&gt; x.sum()\n10\n&gt;&gt;&gt; x.sum(axis=1)\nmatrix([[3],\n        [7]])\n&gt;&gt;&gt; x.sum(axis=1, dtype='float')\nmatrix([[3.],\n        [7.]])\n&gt;&gt;&gt; out = np.zeros((2, 1), dtype='float')\n&gt;&gt;&gt; x.sum(axis=1, dtype='float', out=np.asmatrix(out))\nmatrix([[3.],\n        [7.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix([[1, 2], [4, 3]])\n; x.sum()\n10\n; x.sum(axis=1)\nmatrix([[3],\n        [7]])\n; x.sum(axis=1, dtype='float')\nmatrix([[3.],\n        [7.]])\n; out = np.zeros((2, 1), dtype='float')\n; x.sum(axis=1, dtype='float', out=np.asmatrix(out))\nmatrix([[3.],\n        [7.]])\n\n", "; x = np.matrix([[1, 2], [4, 3]])\n; x.sum()\n10\n; x.sum(axis=1)\nmatrix([[3],\n        [7]])\n; x.sum(axis=1, dtype='float')\nmatrix([[3.],\n        [7.]])\n; out = np.zeros((2, 1), dtype='float')\n; x.sum(axis=1, dtype='float', out=np.asmatrix(out))\nmatrix([[3.],\n        [7.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.sum", "code": "\nMaskedArray.sum(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.ndarray.sumcorresponding function for ndarrays\n\nnumpy.sumequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.sum()\n25\n&gt;&gt;&gt; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.recarray.sum", "code": "\nrecarray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\u00b6", "description": "Return the sum of the array elements over the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.sumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.sum", "code": "\nmasked_array.sum(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.ndarray.sumcorresponding function for ndarrays\n\nnumpy.sumequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.sum()\n25\n&gt;&gt;&gt; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.generic.sum", "code": "\ngeneric.sum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.sum", "code": "\nchararray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\u00b6", "description": "Return the sum of the array elements over the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.sumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.sum", "code": "\nchararray.sum(axis=None, dtype=None, out=None, keepdims=False, initial=0, where=True)\u00b6", "description": "Return the sum of the array elements over the given axis.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.sumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.sum", "code": "\nnumpy.ma.sum(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return the sum of the array elements over the given axis.\nMasked elements are set to 0 internally.\nRefer to numpy.sum for full documentation.\n\nSee also\n\nnumpy.ndarray.sumcorresponding function for ndarrays\n\nnumpy.sumequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.sum()\n25\n&gt;&gt;&gt; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.sum()\n25\n; x.sum(axis=1)\nmasked_array(data=[4, 5, 16],\n             mask=[False, False, False],\n       fill_value=999999)\n; x.sum(axis=0)\nmasked_array(data=[8, 5, 12],\n             mask=[False, False, False],\n       fill_value=999999)\n; print(type(x.sum(axis=0, dtype=np.int64)[0]))\n&lt;class 'numpy.int64'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.sum", "code": "\nnumpy.sum(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)[source]\u00b6", "description": "Sum of array elements over a given axis.\n\nParameters\n\naarray_likeElements to sum.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which a sum is performed.  The default,\naxis=None, will sum all of the elements of the input array.  If\naxis is negative it counts from the last to the first axis.\n\nNew in version 1.7.0.\n\nIf axis is a tuple of ints, a sum is performed on all of the axes\nspecified in the tuple instead of a single axis or all the axes as\nbefore.\n\ndtypedtype, optionalThe type of the returned array and of the accumulator in which the\nelements are summed.  The dtype of a is used by default unless a\nhas an integer dtype of less precision than the default platform\ninteger.  In that case, if a is signed then the platform integer\nis used while if a is unsigned then an unsigned integer of the\nsame precision as the platform integer is used.\n\noutndarray, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output, but the type of the output\nvalues will be cast if necessary.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the sum method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\ninitialscalar, optionalStarting value for the sum. See reduce for details.\n\nNew in version 1.15.0.\n\n\nwherearray_like of bool, optionalElements to include in the sum. See reduce for details.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nsum_along_axisndarrayAn array with the same shape as a, with the specified\naxis removed.   If a is a 0-d array, or if axis is None, a scalar\nis returned.  If an output array is specified, a reference to\nout is returned.\n\n\n\n\n\nSee also\n\nndarray.sumEquivalent method.\n\nadd.reduceEquivalent functionality of add.\n\ncumsumCumulative sum of array elements.\n\ntrapzIntegration of array values using the composite trapezoidal rule.\n\n\nmean, average\n\nNotes\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nThe sum of an empty array is the neutral element 0:\n&gt;&gt;&gt; np.sum([])\n0.0\n\n\nFor floating point numbers the numerical precision of sum (and\nnp.add.reduce) is in general limited by directly adding each number\nindividually to the result causing rounding errors in every step.\nHowever, often numpy will use a  numerically better approach (partial\npairwise summation) leading to improved precision in many use-cases.\nThis improved precision is always provided when no axis is given.\nWhen axis is given, it will depend on which axis is summed.\nTechnically, to provide the best speed possible, the improved precision\nis only used when the summation is along the fast axis in memory.\nNote that the exact precision may vary depending on other parameters.\nIn contrast to NumPy, Python\u2019s math.fsum function uses a slower but\nmore precise approach to summation.\nEspecially when summing a large number of lower precision floating point\nnumbers, such as float32, numerical errors can become significant.\nIn such cases it can be advisable to use dtype=\u201dfloat64\u201d to use a higher\nprecision for the output.\nExamples\n&gt;&gt;&gt; np.sum([0.5, 1.5])\n2.0\n&gt;&gt;&gt; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]])\n6\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n&gt;&gt;&gt; np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n&gt;&gt;&gt; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\n\n\nIf the accumulator is too small, overflow occurs:\n&gt;&gt;&gt; np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\n\n\nYou can also start the sum with a value other than zero:\n&gt;&gt;&gt; np.sum([10], initial=5)\n15\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "keepdimsbool, optional", "initialscalar, optional", "wherearray_like of bool, optional", "Returns", "sum_along_axisndarray"], "returns": "sum_along_axisndarrayAn array with the same shape as a, with the specifiedaxis removed.   If a is a 0-d array, or if axis is None, a scalaris returned.  If an output array is specified, a reference toout is returned.", "examples": ["; np.sum([0.5, 1.5])\n2.0\n; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n; np.sum([[0, 1], [0, 5]])\n6\n; np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n; np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\n\n", "; np.sum([0.5, 1.5])\n2.0\n; np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)\n1\n; np.sum([[0, 1], [0, 5]])\n6\n; np.sum([[0, 1], [0, 5]], axis=0)\narray([0, 6])\n; np.sum([[0, 1], [0, 5]], axis=1)\narray([1, 5])\n; np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)\narray([1., 5.])\n", "; np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\n\n", "; np.ones(128, dtype=np.int8).sum(dtype=np.int8)\n-128\n", "; np.sum([10], initial=5)\n15\n\n", "; np.sum([10], initial=5)\n15\n"]},
{"library": "numpy", "item_id": "numpy.chararray.strip", "code": "\nchararray.strip(self, chars=None)[source]\u00b6", "description": "For each element in self, return a copy with the leading and\ntrailing characters removed.\n\nSee also\nchar.strip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.subdtype", "code": "\ndtype.subdtype\u00b6", "description": "Tuple (item_dtype, shape) if this dtype describes a sub-array, and\nNone otherwise.\nThe shape is the fixed shape of the sub-array described by this\ndata type, and item_dtype the data type of the array.\nIf a field whose dtype object has this attribute is retrieved,\nthen the extra dimensions implied by shape are tacked on to\nthe end of the retrieved array.\n\nSee also\ndtype.base\n\nExamples\n&gt;&gt;&gt; x = numpy.dtype('8f')\n&gt;&gt;&gt; x.subdtype\n(dtype('float32'), (8,))\n\n\n&gt;&gt;&gt; x =  numpy.dtype('i2')\n&gt;&gt;&gt; x.subdtype\n&gt;&gt;&gt;\n\n\n", "parameters": [], "returns": [], "examples": ["; x = numpy.dtype('8f')\n; x.subdtype\n(dtype('float32'), (8,))\n\n", "; x = numpy.dtype('8f')\n; x.subdtype\n(dtype('float32'), (8,))\n", "; x =  numpy.dtype('i2')\n; x.subdtype\n;\n\n", "; x =  numpy.dtype('i2')\n; x.subdtype\n;\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.strip", "code": "\nchararray.strip(self, chars=None)\u00b6", "description": "For each element in self, return a copy with the leading and\ntrailing characters removed.\n\nSee also\nchar.strip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.strip", "code": "\nnumpy.char.strip(a, chars=None)\u00b6", "description": "For each element in a, return a copy with the leading and\ntrailing characters removed.\nCalls str.strip element-wise.\n\nParameters\n\naarray-like of str or unicode\ncharsstr or unicode, optionalThe chars argument is a string specifying the set of\ncharacters to be removed. If omitted or None, the chars\nargument defaults to removing whitespace. The chars argument\nis not a prefix or suffix; rather, all combinations of its\nvalues are stripped.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.strip\n\nExamples\n&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n&gt;&gt;&gt; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n&gt;&gt;&gt; np.char.strip(c)\narray(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7')\n&gt;&gt;&gt; np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads\narray(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7')\n&gt;&gt;&gt; np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails\narray(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7')\n\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "charsstr or unicode, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": ["; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.strip(c)\narray(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7')\n; np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads\narray(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7')\n; np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails\narray(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7')\n\n", "; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.strip(c)\narray(['aAaAaA', 'aA', 'abBABba'], dtype='&lt;U7')\n; np.char.strip(c, 'a') # 'a' unstripped from c[1] because whitespace leads\narray(['AaAaA', '  aA  ', 'bBABb'], dtype='&lt;U7')\n; np.char.strip(c, 'A') # 'A' unstripped from c[1] because (unprinted) ws trails\narray(['aAaAa', '  aA  ', 'abBABba'], dtype='&lt;U7')\n"]},
{"library": "numpy", "item_id": "numpy.record.strides", "code": "\nrecord.strides\u00b6", "description": "tuple of bytes steps in each dimension\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.strides", "code": "\nMaskType.strides\u00b6", "description": "tuple of bytes steps in each dimension\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.subtract", "code": "\nnumpy.subtract(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'subtract'&gt;\u00b6", "description": "Subtract arguments, element-wise.\n\nParameters\n\nx1, x2array_likeThe arrays to be subtracted from each other. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe difference of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\nEquivalent to x1 - x2 in terms of array broadcasting.\nExamples\n&gt;&gt;&gt; np.subtract(1.0, 4.0)\n-3.0\n\n\n&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))\n&gt;&gt;&gt; x2 = np.arange(3.0)\n&gt;&gt;&gt; np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe difference of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.subtract(1.0, 4.0)\n-3.0\n\n", "; np.subtract(1.0, 4.0)\n-3.0\n", "; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])\n\n", "; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.subtract(x1, x2)\narray([[ 0.,  0.,  0.],\n       [ 3.,  3.,  3.],\n       [ 6.,  6.,  6.]])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.strides", "code": "\nrecarray.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.strides", "code": "\nMaskedArray.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.strides", "code": "\nmasked_array.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.chararray.strides", "code": "\nchararray.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.strides", "code": "\nchararray.strides\u00b6", "description": "Tuple of bytes to step in each dimension when traversing an array.\nThe byte offset of element (i[0], i[1], ..., i[n]) in an array a\nis:\noffset = sum(np.array(i) * a.strides)\n\n\nA more detailed explanation of strides can be found in the\n\u201cndarray.rst\u201d file in the NumPy reference guide.\n\nSee also\nnumpy.lib.stride_tricks.as_strided\n\nNotes\nImagine an array of 32-bit integers (each 4 bytes):\nx = np.array([[0, 1, 2, 3, 4],\n              [5, 6, 7, 8, 9]], dtype=np.int32)\n\n\nThis array is stored in memory as 40 bytes, one after the other\n(known as a contiguous block of memory).  The strides of an array tell\nus how many bytes we have to skip in memory to move to the next position\nalong a certain axis.  For example, we have to skip 4 bytes (1 value) to\nmove to the next column, but 20 bytes (5 values) to get to the same\nposition in the next row.  As such, the strides for the array x will be\n(20, 4).\nExamples\n&gt;&gt;&gt; y = np.reshape(np.arange(2*3*4), (2,3,4))\n&gt;&gt;&gt; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n&gt;&gt;&gt; y.strides\n(48, 16, 4)\n&gt;&gt;&gt; y[1,1,1]\n17\n&gt;&gt;&gt; offset=sum(y.strides * np.array((1,1,1)))\n&gt;&gt;&gt; offset/y.itemsize\n17\n\n\n&gt;&gt;&gt; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n&gt;&gt;&gt; x.strides\n(32, 4, 224, 1344)\n&gt;&gt;&gt; i = np.array([3,5,2,2])\n&gt;&gt;&gt; offset = sum(i * x.strides)\n&gt;&gt;&gt; x[3,5,2,2]\n813\n&gt;&gt;&gt; offset / x.itemsize\n813\n\n\n", "parameters": [], "returns": [], "examples": ["; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n\n", "; y = np.reshape(np.arange(2*3*4), (2,3,4))\n; y\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n; y.strides\n(48, 16, 4)\n; y[1,1,1]\n17\n; offset=sum(y.strides * np.array((1,1,1)))\n; offset/y.itemsize\n17\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n\n", "; x = np.reshape(np.arange(5*6*7*8), (5,6,7,8)).transpose(2,3,1,0)\n; x.strides\n(32, 4, 224, 1344)\n; i = np.array([3,5,2,2])\n; offset = sum(i * x.strides)\n; x[3,5,2,2]\n813\n; offset / x.itemsize\n813\n"]},
{"library": "numpy", "item_id": "numpy.char.str_len", "code": "\nnumpy.char.str_len(a)\u00b6", "description": "Return len(a) element-wise.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of integers\n\n\n\n\n\nSee also\n__builtin__.len\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of integers", "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.str", "code": "\ndtype.str\u00b6", "description": "The array-protocol typestring of this data-type object.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.std", "code": "\nrecord.std()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.std", "code": "\nrecarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.stdequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.std", "code": "\nndarray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.stdequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.strides", "code": "\ngeneric.strides\u00b6", "description": "tuple of bytes steps in each dimension\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.std", "code": "\nmemmap.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.stdequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.std", "code": "\nMaskType.std()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.std", "code": "\nMaskedArray.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nMasked entries are ignored.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.ndarray.stdcorresponding function for ndarrays\n\nnumpy.stdEquivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.std", "code": "\nmasked_array.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nMasked entries are ignored.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.ndarray.stdcorresponding function for ndarrays\n\nnumpy.stdEquivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.std", "code": "\ngeneric.std()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.std", "code": "\nchararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.stdequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.std", "code": "\nchararray.std(axis=None, dtype=None, out=None, ddof=0, keepdims=False)\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.stdequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.std", "code": "\nmatrix.std(self, axis=None, dtype=None, out=None, ddof=0)[source]\u00b6", "description": "Return the standard deviation of the array elements along the given axis.\nRefer to numpy.std for full documentation.\n\nSee also\nnumpy.std\n\nNotes\nThis is the same as ndarray.std, except that where an ndarray would\nbe returned, a matrix object is returned instead.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4)))\n&gt;&gt;&gt; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.std()\n3.4520525295346629 # may vary\n&gt;&gt;&gt; x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary\n&gt;&gt;&gt; x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.std()\n3.4520525295346629 # may vary\n; x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary\n; x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])\n\n", "; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.std()\n3.4520525295346629 # may vary\n; x.std(0)\nmatrix([[ 3.26598632,  3.26598632,  3.26598632,  3.26598632]]) # may vary\n; x.std(1)\nmatrix([[ 1.11803399],\n        [ 1.11803399],\n        [ 1.11803399]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.std", "code": "\nnumpy.ma.std(self, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns the standard deviation of the array elements along given axis.\nMasked entries are ignored.\nRefer to numpy.std for full documentation.\n\nSee also\n\nnumpy.ndarray.stdcorresponding function for ndarrays\n\nnumpy.stdEquivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.SFC64.state", "code": "\nSFC64.state\u00b6", "description": "Get or set the PRNG state\n\nReturns\n\nstatedictDictionary containing the information required to describe the\nstate of the PRNG\n\n\n\n\n", "parameters": [], "returns": "statedictDictionary containing the information required to describe thestate of the PRNG", "examples": []},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.state", "code": "\nSeedSequence.state\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.PCG64.state", "code": "\nPCG64.state\u00b6", "description": "Get or set the PRNG state\n\nReturns\n\nstatedictDictionary containing the information required to describe the\nstate of the PRNG\n\n\n\n\n", "parameters": [], "returns": "statedictDictionary containing the information required to describe thestate of the PRNG", "examples": []},
{"library": "numpy", "item_id": "numpy.random.MT19937.state", "code": "\nMT19937.state\u00b6", "description": "Get or set the PRNG state\n\nReturns\n\nstatedictDictionary containing the information required to describe the\nstate of the PRNG\n\n\n\n\n", "parameters": [], "returns": "statedictDictionary containing the information required to describe thestate of the PRNG", "examples": []},
{"library": "numpy", "item_id": "numpy.std", "code": "\nnumpy.std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the standard deviation along the specified axis.\nReturns the standard deviation, a measure of the spread of a distribution,\nof the array elements. The standard deviation is computed for the\nflattened array by default, otherwise over the specified axis.\n\nParameters\n\naarray_likeCalculate the standard deviation of these values.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the standard deviation is computed. The\ndefault is to compute the standard deviation of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a standard deviation is performed over\nmultiple axes, instead of a single axis or all the axes as before.\n\ndtypedtype, optionalType to use in computing the standard deviation. For arrays of\ninteger type the default is float64, for arrays of float types it is\nthe same as the array type.\n\noutndarray, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output but the type (of the calculated\nvalues) will be cast if necessary.\n\nddofint, optionalMeans Delta Degrees of Freedom.  The divisor used in calculations\nis N - ddof, where N represents the number of elements.\nBy default ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the std method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nstandard_deviationndarray, see dtype parameter above.If out is None, return a new array containing the standard deviation,\notherwise return a reference to the output array.\n\n\n\n\n\nSee also\nvar, mean, nanmean, nanstd, nanvar, ufuncs-output-type\n\nNotes\nThe standard deviation is the square root of the average of the squared\ndeviations from the mean, i.e., std = sqrt(mean(abs(x - x.mean())**2)).\nThe average squared deviation is normally calculated as\nx.sum() / N, where N = len(x).  If, however, ddof is specified,\nthe divisor N - ddof is used instead. In standard statistical\npractice, ddof=1 provides an unbiased estimator of the variance\nof the infinite population. ddof=0 provides a maximum likelihood\nestimate of the variance for normally distributed variables. The\nstandard deviation computed in this function is the square root of\nthe estimated variance, so even with ddof=1, it will not be an\nunbiased estimate of the standard deviation per se.\nNote that, for complex numbers, std takes the absolute\nvalue before squaring, so that the result is always real and nonnegative.\nFor floating-point input, the std is computed using the same\nprecision the input has. Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example below).\nSpecifying a higher-accuracy accumulator using the dtype keyword can\nalleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.std(a)\n1.1180339887498949 # may vary\n&gt;&gt;&gt; np.std(a, axis=0)\narray([1.,  1.])\n&gt;&gt;&gt; np.std(a, axis=1)\narray([0.5,  0.5])\n\n\nIn single precision, std() can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.std(a)\n0.45000005\n\n\nComputing the standard deviation in float64 is more accurate:\n&gt;&gt;&gt; np.std(a, dtype=np.float64)\n0.44999999925494177 # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "standard_deviationndarray, see dtype parameter above."], "returns": "standard_deviationndarray, see dtype parameter above.If out is None, return a new array containing the standard deviation,otherwise return a reference to the output array.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.std(a)\n1.1180339887498949 # may vary\n; np.std(a, axis=0)\narray([1.,  1.])\n; np.std(a, axis=1)\narray([0.5,  0.5])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.std(a)\n1.1180339887498949 # may vary\n; np.std(a, axis=0)\narray([1.,  1.])\n; np.std(a, axis=1)\narray([0.5,  0.5])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.std(a)\n0.45000005\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.std(a)\n0.45000005\n", "; np.std(a, dtype=np.float64)\n0.44999999925494177 # may vary\n\n", "; np.std(a, dtype=np.float64)\n0.44999999925494177 # may vary\n"]},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.state", "code": "\nBitGenerator.state\u00b6", "description": "Get or set the PRNG state\nThe base BitGenerator.state must be overridden by a subclass\n\nReturns\n\nstatedictDictionary containing the information required to describe the\nstate of the PRNG\n\n\n\n\n", "parameters": [], "returns": "statedictDictionary containing the information required to describe thestate of the PRNG", "examples": []},
{"library": "numpy", "item_id": "numpy.random.Philox.state", "code": "\nPhilox.state\u00b6", "description": "Get or set the PRNG state\n\nReturns\n\nstatedictDictionary containing the information required to describe the\nstate of the PRNG\n\n\n\n\n", "parameters": [], "returns": "statedictDictionary containing the information required to describe thestate of the PRNG", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.startswith", "code": "\nchararray.startswith(self, prefix, start=0, end=None)[source]\u00b6", "description": "Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.\n\nSee also\nchar.startswith\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.standard_t", "code": "\nGenerator.standard_t(df, size=None)\u00b6", "description": "Draw samples from a standard Student\u2019s t distribution with df degrees\nof freedom.\nA special case of the hyperbolic distribution.  As df gets\nlarge, the result resembles that of the standard normal\ndistribution (standard_normal).\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.\n\n\n\n\nNotes\nThe probability density function for the t distribution is\n\n\nThe t test is based on an assumption that the data come from a\nNormal distribution. The t test provides a way to test whether\nthe sample mean (that is the mean calculated from the data) is\na good estimate of the true mean.\nThe derivation of the t-distribution was first published in\n1908 by William Gosset while working for the Guinness Brewery\nin Dublin. Due to proprietary issues, he had to publish under\na pseudonym, and so he used the name Student.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics With R\u201d,\nSpringer, 2002.\n\n2\nWikipedia, \u201cStudent\u2019s t-distribution\u201d\nhttps://en.wikipedia.org/wiki/Student\u2019s_t-distribution\n\n\nExamples\nFrom Dalgaard page 83 [1], suppose the daily energy intake for 11\nwomen in kilojoules (kJ) is:\n&gt;&gt;&gt; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n\nDoes their energy intake deviate systematically from the recommended\nvalue of 7725 kJ?\nWe have 10 degrees of freedom, so is the sample mean within 95% of the\nrecommended value?\n&gt;&gt;&gt; s = np.random.default_rng().standard_t(10, size=100000)\n&gt;&gt;&gt; np.mean(intake)\n6753.636363636364\n&gt;&gt;&gt; intake.std(ddof=1)\n1142.1232221373727\n\n\nCalculate the t statistic, setting the ddof parameter to the unbiased\nvalue so the divisor in the standard deviation will be degrees of\nfreedom, N-1.\n&gt;&gt;&gt; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(s, bins=100, density=True)\n\n\nFor a one-sided t-test, how far out in the distribution does the t\nstatistic appear?\n&gt;&gt;&gt; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n\nSo the p-value is about 0.009, which says the null hypothesis has a\nprobability of about 99% of being true.\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.", "examples": ["; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n", "; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n", "; s = np.random.default_rng().standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n\n", "; s = np.random.default_rng().standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.startswith", "code": "\nchararray.startswith(self, prefix, start=0, end=None)\u00b6", "description": "Returns a boolean array which is True where the string element\nin self starts with prefix, otherwise False.\n\nSee also\nchar.startswith\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.startswith", "code": "\nnumpy.char.startswith(a, prefix, start=0, end=None)\u00b6", "description": "Returns a boolean array which is True where the string element\nin a starts with prefix, otherwise False.\nCalls str.startswith element-wise.\n\nParameters\n\naarray_like of str or unicode\nprefixstr\nstart, endint, optionalWith optional start, test beginning at that position. With\noptional end, stop comparing at that position.\n\n\n\nReturns\n\noutndarrayArray of booleans\n\n\n\n\n\nSee also\nstr.startswith\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "prefixstr", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayArray of booleans", "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.standard_t", "code": "\nRandomState.standard_t(df, size=None)\u00b6", "description": "Draw samples from a standard Student\u2019s t distribution with df degrees\nof freedom.\nA special case of the hyperbolic distribution.  As df gets\nlarge, the result resembles that of the standard normal\ndistribution (standard_normal).\n\nNote\nNew code should use the standard_t method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.\n\n\n\n\n\nSee also\n\nGenerator.standard_twhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the t distribution is\n\n\nThe t test is based on an assumption that the data come from a\nNormal distribution. The t test provides a way to test whether\nthe sample mean (that is the mean calculated from the data) is\na good estimate of the true mean.\nThe derivation of the t-distribution was first published in\n1908 by William Gosset while working for the Guinness Brewery\nin Dublin. Due to proprietary issues, he had to publish under\na pseudonym, and so he used the name Student.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics With R\u201d,\nSpringer, 2002.\n\n2\nWikipedia, \u201cStudent\u2019s t-distribution\u201d\nhttps://en.wikipedia.org/wiki/Student\u2019s_t-distribution\n\n\nExamples\nFrom Dalgaard page 83 [1], suppose the daily energy intake for 11\nwomen in kilojoules (kJ) is:\n&gt;&gt;&gt; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n\nDoes their energy intake deviate systematically from the recommended\nvalue of 7725 kJ?\nWe have 10 degrees of freedom, so is the sample mean within 95% of the\nrecommended value?\n&gt;&gt;&gt; s = np.random.standard_t(10, size=100000)\n&gt;&gt;&gt; np.mean(intake)\n6753.636363636364\n&gt;&gt;&gt; intake.std(ddof=1)\n1142.1232221373727\n\n\nCalculate the t statistic, setting the ddof parameter to the unbiased\nvalue so the divisor in the standard deviation will be degrees of\nfreedom, N-1.\n&gt;&gt;&gt; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(s, bins=100, density=True)\n\n\nFor a one-sided t-test, how far out in the distribution does the t\nstatistic appear?\n&gt;&gt;&gt; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n\nSo the p-value is about 0.009, which says the null hypothesis has a\nprobability of about 99% of being true.\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.", "examples": ["; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n", "; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n", "; s = np.random.standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n\n", "; s = np.random.standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n"]},
{"library": "numpy", "item_id": "numpy.random.standard_t", "code": "\nnumpy.random.standard_t(df, size=None)\u00b6", "description": "Draw samples from a standard Student\u2019s t distribution with df degrees\nof freedom.\nA special case of the hyperbolic distribution.  As df gets\nlarge, the result resembles that of the standard normal\ndistribution (standard_normal).\n\nNote\nNew code should use the standard_t method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.\n\n\n\n\n\nSee also\n\nGenerator.standard_twhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the t distribution is\n\n\nThe t test is based on an assumption that the data come from a\nNormal distribution. The t test provides a way to test whether\nthe sample mean (that is the mean calculated from the data) is\na good estimate of the true mean.\nThe derivation of the t-distribution was first published in\n1908 by William Gosset while working for the Guinness Brewery\nin Dublin. Due to proprietary issues, he had to publish under\na pseudonym, and so he used the name Student.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics With R\u201d,\nSpringer, 2002.\n\n2\nWikipedia, \u201cStudent\u2019s t-distribution\u201d\nhttps://en.wikipedia.org/wiki/Student\u2019s_t-distribution\n\n\nExamples\nFrom Dalgaard page 83 [1], suppose the daily energy intake for 11\nwomen in kilojoules (kJ) is:\n&gt;&gt;&gt; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n\nDoes their energy intake deviate systematically from the recommended\nvalue of 7725 kJ?\nWe have 10 degrees of freedom, so is the sample mean within 95% of the\nrecommended value?\n&gt;&gt;&gt; s = np.random.standard_t(10, size=100000)\n&gt;&gt;&gt; np.mean(intake)\n6753.636363636364\n&gt;&gt;&gt; intake.std(ddof=1)\n1142.1232221373727\n\n\nCalculate the t statistic, setting the ddof parameter to the unbiased\nvalue so the divisor in the standard deviation will be degrees of\nfreedom, N-1.\n&gt;&gt;&gt; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; h = plt.hist(s, bins=100, density=True)\n\n\nFor a one-sided t-test, how far out in the distribution does the t\nstatistic appear?\n&gt;&gt;&gt; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n\nSo the p-value is about 0.009, which says the null hypothesis has a\nprobability of about 99% of being true.\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard Student\u2019s t distribution.", "examples": ["; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n\n", "; intake = np.array([5260., 5470, 5640, 6180, 6390, 6515, 6805, 7515, \\\n...                    7515, 8230, 8770])\n", "; s = np.random.standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n\n", "; s = np.random.standard_t(10, size=100000)\n; np.mean(intake)\n6753.636363636364\n; intake.std(ddof=1)\n1142.1232221373727\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n\n", "; t = (np.mean(intake)-7725)/(intake.std(ddof=1)/np.sqrt(len(intake)))\n; import matplotlib.pyplot as plt\n; h = plt.hist(s, bins=100, density=True)\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n\n", "; np.sum(s&lt;t) / float(len(s))\n0.0090699999999999999  #random\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.standard_normal", "code": "\nRandomState.standard_normal(size=None)\u00b6", "description": "Draw samples from a standard Normal distribution (mean=0, stdev=1).\n\nNote\nNew code should use the standard_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarrayA floating-point array of shape size of drawn samples, or a\nsingle sample if size was not specified.\n\n\n\n\n\nSee also\n\nnormalEquivalent function with additional loc and scale arguments for setting the mean and standard deviation.\n\nGenerator.standard_normalwhich should be used for new code.\n\n\n\nNotes\nFor random samples from , use one of:\nmu + sigma * np.random.standard_normal(size=...)\nnp.random.normal(mu, sigma, size=...)\n\n\nExamples\n&gt;&gt;&gt; np.random.standard_normal()\n2.1923875335537315 #random\n\n\n&gt;&gt;&gt; s = np.random.standard_normal(8000)\n&gt;&gt;&gt; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n&gt;&gt;&gt; s.shape\n(8000,)\n&gt;&gt;&gt; s = np.random.standard_normal(size=(3, 4, 2))\n&gt;&gt;&gt; s.shape\n(3, 4, 2)\n\n\nTwo-by-four array of samples from :\n&gt;&gt;&gt; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayA floating-point array of shape size of drawn samples, or asingle sample if size was not specified.", "examples": ["; np.random.standard_normal()\n2.1923875335537315 #random\n\n", "; np.random.standard_normal()\n2.1923875335537315 #random\n", "; s = np.random.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = np.random.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n\n", "; s = np.random.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = np.random.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n", "; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.standard_normal", "code": "\nGenerator.standard_normal(size=None, dtype=np.float64, out=None)\u00b6", "description": "Draw samples from a standard Normal distribution (mean=0, stdev=1).\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result, only float64 and float32 are supported.\nByteorder must be native. The default value is np.float64.\n\noutndarray, optionalAlternative output array in which to place the result. If size is not None,\nit must have the same shape as the provided size and must match the type of\nthe output values.\n\n\n\nReturns\n\noutfloat or ndarrayA floating-point array of shape size of drawn samples, or a\nsingle sample if size was not specified.\n\n\n\n\n\nSee also\n\nnormalEquivalent function with additional loc and scale arguments for setting the mean and standard deviation.\n\n\n\nNotes\nFor random samples from , use one of:\nmu + sigma * gen.standard_normal(size=...)\ngen.normal(mu, sigma, size=...)\n\n\nExamples\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.standard_normal()\n2.1923875335537315 #random\n\n\n&gt;&gt;&gt; s = rng.standard_normal(8000)\n&gt;&gt;&gt; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n&gt;&gt;&gt; s.shape\n(8000,)\n&gt;&gt;&gt; s = rng.standard_normal(size=(3, 4, 2))\n&gt;&gt;&gt; s.shape\n(3, 4, 2)\n\n\nTwo-by-four array of samples from :\n&gt;&gt;&gt; 3 + 2.5 * rng.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayA floating-point array of shape size of drawn samples, or asingle sample if size was not specified.", "examples": ["; rng = np.random.default_rng()\n; rng.standard_normal()\n2.1923875335537315 #random\n\n", "; rng = np.random.default_rng()\n; rng.standard_normal()\n2.1923875335537315 #random\n", "; s = rng.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = rng.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n\n", "; s = rng.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = rng.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n", "; 3 + 2.5 * rng.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; 3 + 2.5 * rng.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.standard_normal", "code": "\nnumpy.random.standard_normal(size=None)\u00b6", "description": "Draw samples from a standard Normal distribution (mean=0, stdev=1).\n\nNote\nNew code should use the standard_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarrayA floating-point array of shape size of drawn samples, or a\nsingle sample if size was not specified.\n\n\n\n\n\nSee also\n\nnormalEquivalent function with additional loc and scale arguments for setting the mean and standard deviation.\n\nGenerator.standard_normalwhich should be used for new code.\n\n\n\nNotes\nFor random samples from , use one of:\nmu + sigma * np.random.standard_normal(size=...)\nnp.random.normal(mu, sigma, size=...)\n\n\nExamples\n&gt;&gt;&gt; np.random.standard_normal()\n2.1923875335537315 #random\n\n\n&gt;&gt;&gt; s = np.random.standard_normal(8000)\n&gt;&gt;&gt; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n&gt;&gt;&gt; s.shape\n(8000,)\n&gt;&gt;&gt; s = np.random.standard_normal(size=(3, 4, 2))\n&gt;&gt;&gt; s.shape\n(3, 4, 2)\n\n\nTwo-by-four array of samples from :\n&gt;&gt;&gt; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayA floating-point array of shape size of drawn samples, or asingle sample if size was not specified.", "examples": ["; np.random.standard_normal()\n2.1923875335537315 #random\n\n", "; np.random.standard_normal()\n2.1923875335537315 #random\n", "; s = np.random.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = np.random.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n\n", "; s = np.random.standard_normal(8000)\n; s\narray([ 0.6888893 ,  0.78096262, -0.89086505, ...,  0.49876311,  # random\n       -0.38672696, -0.4685006 ])                                # random\n; s.shape\n(8000,)\n; s = np.random.standard_normal(size=(3, 4, 2))\n; s.shape\n(3, 4, 2)\n", "; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; 3 + 2.5 * np.random.standard_normal(size=(2, 4))\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.standard_gamma", "code": "\nRandomState.standard_gamma(shape, size=None)\u00b6", "description": "Draw samples from a standard Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale=1.\n\nNote\nNew code should use the standard_gamma method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nshapefloat or array_like of floatsParameter, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape is a scalar.  Otherwise,\nnp.array(shape).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\nGenerator.standard_gammawhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 1. # mean and width\n&gt;&gt;&gt; s = np.random.standard_gamma(shape, 1000000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard gamma distribution.", "examples": ["; shape, scale = 2., 1. # mean and width\n; s = np.random.standard_gamma(shape, 1000000)\n\n", "; shape, scale = 2., 1. # mean and width\n; s = np.random.standard_gamma(shape, 1000000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.standard_gamma", "code": "\nGenerator.standard_gamma(shape, size=None, dtype=np.float64, out=None)\u00b6", "description": "Draw samples from a standard Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale=1.\n\nParameters\n\nshapefloat or array_like of floatsParameter, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape is a scalar.  Otherwise,\nnp.array(shape).size samples are drawn.\n\ndtypedtype, optionalDesired dtype of the result, only float64 and float32 are supported.\nByteorder must be native. The default value is np.float64.\n\noutndarray, optionalAlternative output array in which to place the result. If size is\nnot None, it must have the same shape as the provided size and\nmust match the type of the output values.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 1. # mean and width\n&gt;&gt;&gt; s = np.random.default_rng().standard_gamma(shape, 1000000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "sizeint or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard gamma distribution.", "examples": ["; shape, scale = 2., 1. # mean and width\n; s = np.random.default_rng().standard_gamma(shape, 1000000)\n\n", "; shape, scale = 2., 1. # mean and width\n; s = np.random.default_rng().standard_gamma(shape, 1000000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.standard_exponential", "code": "\nRandomState.standard_exponential(size=None)\u00b6", "description": "Draw samples from the standard exponential distribution.\nstandard_exponential is identical to the exponential distribution\nwith a scale parameter of 1.\n\nNote\nNew code should use the standard_exponential method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarrayDrawn samples.\n\n\n\n\n\nSee also\n\nGenerator.standard_exponentialwhich should be used for new code.\n\n\n\nExamples\nOutput a 3x8000 array:\n&gt;&gt;&gt; n = np.random.standard_exponential((3, 8000))\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayDrawn samples.", "examples": ["; n = np.random.standard_exponential((3, 8000))\n\n", "; n = np.random.standard_exponential((3, 8000))\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.standard_exponential", "code": "\nGenerator.standard_exponential(size=None, dtype=np.float64, method='zig', out=None)\u00b6", "description": "Draw samples from the standard exponential distribution.\nstandard_exponential is identical to the exponential distribution\nwith a scale parameter of 1.\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result, only float64 and float32 are supported.\nByteorder must be native. The default value is np.float64.\n\nmethodstr, optionalEither \u2018inv\u2019 or \u2018zig\u2019. \u2018inv\u2019 uses the default inverse CDF method.\n\u2018zig\u2019 uses the much faster Ziggurat method of Marsaglia and Tsang.\n\noutndarray, optionalAlternative output array in which to place the result. If size is not None,\nit must have the same shape as the provided size and must match the type of\nthe output values.\n\n\n\nReturns\n\noutfloat or ndarrayDrawn samples.\n\n\n\n\nExamples\nOutput a 3x8000 array:\n&gt;&gt;&gt; n = np.random.default_rng().standard_exponential((3, 8000))\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "dtypedtype, optional", "methodstr, optional", "outndarray, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayDrawn samples.", "examples": ["; n = np.random.default_rng().standard_exponential((3, 8000))\n\n", "; n = np.random.default_rng().standard_exponential((3, 8000))\n"]},
{"library": "numpy", "item_id": "numpy.random.standard_exponential", "code": "\nnumpy.random.standard_exponential(size=None)\u00b6", "description": "Draw samples from the standard exponential distribution.\nstandard_exponential is identical to the exponential distribution\nwith a scale parameter of 1.\n\nNote\nNew code should use the standard_exponential method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarrayDrawn samples.\n\n\n\n\n\nSee also\n\nGenerator.standard_exponentialwhich should be used for new code.\n\n\n\nExamples\nOutput a 3x8000 array:\n&gt;&gt;&gt; n = np.random.standard_exponential((3, 8000))\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray"], "returns": "outfloat or ndarrayDrawn samples.", "examples": ["; n = np.random.standard_exponential((3, 8000))\n\n", "; n = np.random.standard_exponential((3, 8000))\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.standard_cauchy", "code": "\nGenerator.standard_cauchy(size=None)\u00b6", "description": "Draw samples from a standard Cauchy distribution with mode = 0.\nAlso known as the Lorentz distribution.\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\nsamplesndarray or scalarThe drawn samples.\n\n\n\n\nNotes\nThe probability density function for the full Cauchy distribution is\n\n\nand the Standard Cauchy distribution just sets  and\n\nThe Cauchy distribution arises in the solution to the driven harmonic\noscillator problem, and also describes spectral line broadening. It\nalso describes the distribution of values at which a line tilted at\na random angle will cut the x axis.\nWhen studying hypothesis tests that assume normality, seeing how the\ntests perform on data from a Cauchy distribution is a good indicator of\ntheir sensitivity to a heavy-tailed distribution, since the Cauchy looks\nvery much like a Gaussian distribution, but with heavier tails.\nReferences\n\n1\nNIST/SEMATECH e-Handbook of Statistical Methods, \u201cCauchy\nDistribution\u201d,\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm\n\n2\nWeisstein, Eric W. \u201cCauchy Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/CauchyDistribution.html\n\n3\nWikipedia, \u201cCauchy distribution\u201d\nhttps://en.wikipedia.org/wiki/Cauchy_distribution\n\n\nExamples\nDraw samples and plot the distribution:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; s = np.random.default_rng().standard_cauchy(1000000)\n&gt;&gt;&gt; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n&gt;&gt;&gt; plt.hist(s, bins=100)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "samplesndarray or scalar"], "returns": "samplesndarray or scalarThe drawn samples.", "examples": ["; import matplotlib.pyplot as plt\n; s = np.random.default_rng().standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; s = np.random.default_rng().standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.standard_gamma", "code": "\nnumpy.random.standard_gamma(shape, size=None)\u00b6", "description": "Draw samples from a standard Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale=1.\n\nNote\nNew code should use the standard_gamma method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nshapefloat or array_like of floatsParameter, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape is a scalar.  Otherwise,\nnp.array(shape).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized standard gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\nGenerator.standard_gammawhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 1. # mean and width\n&gt;&gt;&gt; s = np.random.standard_gamma(shape, 1000000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized standard gamma distribution.", "examples": ["; shape, scale = 2., 1. # mean and width\n; s = np.random.standard_gamma(shape, 1000000)\n\n", "; shape, scale = 2., 1. # mean and width\n; s = np.random.standard_gamma(shape, 1000000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1) * ((np.exp(-bins/scale))/  \n...                       (sps.gamma(shape) * scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.standard_cauchy", "code": "\nRandomState.standard_cauchy(size=None)\u00b6", "description": "Draw samples from a standard Cauchy distribution with mode = 0.\nAlso known as the Lorentz distribution.\n\nNote\nNew code should use the standard_cauchy method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\nsamplesndarray or scalarThe drawn samples.\n\n\n\n\n\nSee also\n\nGenerator.standard_cauchywhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the full Cauchy distribution is\n\n\nand the Standard Cauchy distribution just sets  and\n\nThe Cauchy distribution arises in the solution to the driven harmonic\noscillator problem, and also describes spectral line broadening. It\nalso describes the distribution of values at which a line tilted at\na random angle will cut the x axis.\nWhen studying hypothesis tests that assume normality, seeing how the\ntests perform on data from a Cauchy distribution is a good indicator of\ntheir sensitivity to a heavy-tailed distribution, since the Cauchy looks\nvery much like a Gaussian distribution, but with heavier tails.\nReferences\n\n1\nNIST/SEMATECH e-Handbook of Statistical Methods, \u201cCauchy\nDistribution\u201d,\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm\n\n2\nWeisstein, Eric W. \u201cCauchy Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/CauchyDistribution.html\n\n3\nWikipedia, \u201cCauchy distribution\u201d\nhttps://en.wikipedia.org/wiki/Cauchy_distribution\n\n\nExamples\nDraw samples and plot the distribution:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; s = np.random.standard_cauchy(1000000)\n&gt;&gt;&gt; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n&gt;&gt;&gt; plt.hist(s, bins=100)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "samplesndarray or scalar"], "returns": "samplesndarray or scalarThe drawn samples.", "examples": ["; import matplotlib.pyplot as plt\n; s = np.random.standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; s = np.random.standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.stack", "code": "\nnumpy.stack(arrays, axis=0, out=None)[source]\u00b6", "description": "Join a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the\ndimensions of the result. For example, if axis=0 it will be the first\ndimension and if axis=-1 it will be the last dimension.\n\nNew in version 1.10.0.\n\n\nParameters\n\narrayssequence of array_likeEach array must have the same shape.\n\naxisint, optionalThe axis in the result array along which the input arrays are stacked.\n\noutndarray, optionalIf provided, the destination to place the result. The shape must be\ncorrect, matching that of what stack would have returned if no\nout argument were specified.\n\n\n\nReturns\n\nstackedndarrayThe stacked array has one more dimension than the input arrays.\n\n\n\n\n\nSee also\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nsplitSplit array into a list of multiple sub-arrays of equal size.\n\nblockAssemble arrays from blocks.\n\n\n\nExamples\n&gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]\n&gt;&gt;&gt; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n\n&gt;&gt;&gt; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n\n&gt;&gt;&gt; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "arrayssequence of array_like", "axisint, optional", "outndarray, optional", "Returns", "stackedndarray"], "returns": "stackedndarrayThe stacked array has one more dimension than the input arrays.", "examples": ["; arrays = [np.random.randn(3, 4) for _ in range(10)]\n; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n", "; arrays = [np.random.randn(3, 4) for _ in range(10)]\n; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n", "; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n", "; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n", "; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n", "; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.random.standard_cauchy", "code": "\nnumpy.random.standard_cauchy(size=None)\u00b6", "description": "Draw samples from a standard Cauchy distribution with mode = 0.\nAlso known as the Lorentz distribution.\n\nNote\nNew code should use the standard_cauchy method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\nsamplesndarray or scalarThe drawn samples.\n\n\n\n\n\nSee also\n\nGenerator.standard_cauchywhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the full Cauchy distribution is\n\n\nand the Standard Cauchy distribution just sets  and\n\nThe Cauchy distribution arises in the solution to the driven harmonic\noscillator problem, and also describes spectral line broadening. It\nalso describes the distribution of values at which a line tilted at\na random angle will cut the x axis.\nWhen studying hypothesis tests that assume normality, seeing how the\ntests perform on data from a Cauchy distribution is a good indicator of\ntheir sensitivity to a heavy-tailed distribution, since the Cauchy looks\nvery much like a Gaussian distribution, but with heavier tails.\nReferences\n\n1\nNIST/SEMATECH e-Handbook of Statistical Methods, \u201cCauchy\nDistribution\u201d,\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3663.htm\n\n2\nWeisstein, Eric W. \u201cCauchy Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/CauchyDistribution.html\n\n3\nWikipedia, \u201cCauchy distribution\u201d\nhttps://en.wikipedia.org/wiki/Cauchy_distribution\n\n\nExamples\nDraw samples and plot the distribution:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; s = np.random.standard_cauchy(1000000)\n&gt;&gt;&gt; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n&gt;&gt;&gt; plt.hist(s, bins=100)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "samplesndarray or scalar"], "returns": "samplesndarray or scalarThe drawn samples.", "examples": ["; import matplotlib.pyplot as plt\n; s = np.random.standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; s = np.random.standard_cauchy(1000000)\n; s = s[(s&gt;-25) &amp; (s&lt;25)]  # truncate distribution so it plots well\n; plt.hist(s, bins=100)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ma.stack", "code": "\nnumpy.ma.stack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nJoin a sequence of arrays along a new axis.\nThe axis parameter specifies the index of the new axis in the\ndimensions of the result. For example, if axis=0 it will be the first\ndimension and if axis=-1 it will be the last dimension.\n\nNew in version 1.10.0.\n\n\n\nParameters\n\narrayssequence of array_like\nEach array must have the same shape.\n\n\naxisint, optionalThe axis in the result array along which the input arrays are stacked.\n\noutndarray, optionalIf provided, the destination to place the result. The shape must be\ncorrect, matching that of what stack would have returned if no\nout argument were specified.\n\n\n\n\n\nReturns\n\nstackedndarrayThe stacked array has one more dimension than the input arrays.\n\n\n\n\n\nSee also\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nsplitSplit array into a list of multiple sub-arrays of equal size.\n\nblockAssemble arrays from blocks.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; arrays = [np.random.randn(3, 4) for _ in range(10)]\n&gt;&gt;&gt; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n\n&gt;&gt;&gt; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n\n&gt;&gt;&gt; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "arrayssequence of array_like", "axisint, optional", "outndarray, optional", "Returns", "stackedndarray"], "returns": "stackedndarrayThe stacked array has one more dimension than the input arrays.", "examples": ["; arrays = [np.random.randn(3, 4) for _ in range(10)]\n; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n\n", "; arrays = [np.random.randn(3, 4) for _ in range(10)]\n; np.stack(arrays, axis=0).shape\n(10, 3, 4)\n", "; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n\n", "; np.stack(arrays, axis=1).shape\n(3, 10, 4)\n", "; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n\n", "; np.stack(arrays, axis=2).shape\n(3, 4, 10)\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.stack((a, b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; np.stack((a, b), axis=-1)\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.record.squeeze", "code": "\nrecord.squeeze()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.squeeze", "code": "\nrecarray.squeeze(axis=None)\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.squeeze", "code": "\nndarray.squeeze(axis=None)\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.squeeze", "code": "\nmatrix.squeeze(self, axis=None)[source]\u00b6", "description": "Return a possibly reshaped matrix.\nRefer to numpy.squeeze for more documentation.\n\nParameters\n\naxisNone or int or tuple of ints, optionalSelects a subset of the single-dimensional entries in the shape.\nIf an axis is selected with shape entry greater than one,\nan error is raised.\n\n\n\nReturns\n\nsqueezedmatrixThe matrix, but as a (1, N) matrix if it had shape (N, 1).\n\n\n\n\n\nSee also\n\nnumpy.squeezerelated function\n\n\n\nNotes\nIf m has a single column then that column is returned\nas the single row of a matrix.  Otherwise m is returned.\nThe returned matrix is always either m itself or a view into m.\nSupplying an axis keyword argument will not affect the returned matrix\nbut it may cause an error to be raised.\nExamples\n&gt;&gt;&gt; c = np.matrix([[1], [2]])\n&gt;&gt;&gt; c\nmatrix([[1],\n        [2]])\n&gt;&gt;&gt; c.squeeze()\nmatrix([[1, 2]])\n&gt;&gt;&gt; r = c.T\n&gt;&gt;&gt; r\nmatrix([[1, 2]])\n&gt;&gt;&gt; r.squeeze()\nmatrix([[1, 2]])\n&gt;&gt;&gt; m = np.matrix([[1, 2], [3, 4]])\n&gt;&gt;&gt; m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])\n\n\n", "parameters": ["Parameters", "axisNone or int or tuple of ints, optional", "Returns", "squeezedmatrix"], "returns": "squeezedmatrixThe matrix, but as a (1, N) matrix if it had shape (N, 1).", "examples": ["; c = np.matrix([[1], [2]])\n; c\nmatrix([[1],\n        [2]])\n; c.squeeze()\nmatrix([[1, 2]])\n; r = c.T\n; r\nmatrix([[1, 2]])\n; r.squeeze()\nmatrix([[1, 2]])\n; m = np.matrix([[1, 2], [3, 4]])\n; m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])\n\n", "; c = np.matrix([[1], [2]])\n; c\nmatrix([[1],\n        [2]])\n; c.squeeze()\nmatrix([[1, 2]])\n; r = c.T\n; r\nmatrix([[1, 2]])\n; r.squeeze()\nmatrix([[1, 2]])\n; m = np.matrix([[1, 2], [3, 4]])\n; m.squeeze()\nmatrix([[1, 2],\n        [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.squeeze", "code": "\nmemmap.squeeze(axis=None)\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.squeeze", "code": "\nMaskType.squeeze()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.squeeze", "code": "\nMaskedArray.squeeze(axis=None)[source]\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.squeeze", "code": "\nmasked_array.squeeze(axis=None)[source]\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.sqrt", "code": "\nnumpy.sqrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'sqrt'&gt;\u00b6", "description": "Return the non-negative square-root of an array, element-wise.\n\nParameters\n\nxarray_likeThe values whose square-roots are required.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayAn array of the same shape as x, containing the positive\nsquare-root of each element in x.  If any element in x is\ncomplex, a complex array is returned (and the square-roots of\nnegative reals are calculated).  If all of the elements in x\nare real, so is y, with negative elements returning nan.\nIf out was provided, y is a reference to it.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nlib.scimath.sqrtA version which returns complex numbers when given negative reals.\n\n\n\nNotes\nsqrt has\u2013consistent with common convention\u2013as its branch cut the\nreal \u201cinterval\u201d [-inf, 0), and is continuous from above on it.\nA branch cut is a curve in the complex plane across which a given\ncomplex function fails to be continuous.\nExamples\n&gt;&gt;&gt; np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n\n&gt;&gt;&gt; np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n\n&gt;&gt;&gt; np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayAn array of the same shape as x, containing the positivesquare-root of each element in x.  If any element in x iscomplex, a complex array is returned (and the square-roots ofnegative reals are calculated).  If all of the elements in xare real, so is y, with negative elements returning nan.If out was provided, y is a reference to it.This is a scalar if x is a scalar.", "examples": ["; np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n\n", "; np.sqrt([1,4,9])\narray([ 1.,  2.,  3.])\n", "; np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n\n", "; np.sqrt([4, -1, -3+4J])\narray([ 2.+0.j,  0.+1.j,  1.+2.j])\n", "; np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])\n\n", "; np.sqrt([4, -1, np.inf])\narray([ 2., nan, inf])\n"]},
{"library": "numpy", "item_id": "numpy.generic.squeeze", "code": "\ngeneric.squeeze()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.squeeze", "code": "\nchararray.squeeze(axis=None)\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.squeeze", "code": "\nchararray.squeeze(axis=None)\u00b6", "description": "Remove single-dimensional entries from the shape of a.\nRefer to numpy.squeeze for full documentation.\n\nSee also\n\nnumpy.squeezeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.splitlines", "code": "\nchararray.splitlines(self, keepends=None)[source]\u00b6", "description": "For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.\n\nSee also\nchar.splitlines\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.squeeze", "code": "\nnumpy.ma.squeeze(a, axis=None)[source]\u00b6", "description": "Remove single-dimensional entries from the shape of an array.\n\nParameters\n\naarray_likeInput data.\n\naxisNone or int or tuple of ints, optional\nNew in version 1.7.0.\n\nSelects a subset of the single-dimensional entries in the\nshape. If an axis is selected with shape entry greater than\none, an error is raised.\n\n\n\nReturns\n\nsqueezedndarrayThe input array, but with all or a subset of the\ndimensions of length 1 removed. This is always a itself\nor a view into a.\n\n\n\nRaises\n\nValueErrorIf axis is not None, and an axis being squeezed is not of length 1\n\n\n\n\n\nSee also\n\nexpand_dimsThe inverse operation, adding singleton dimensions\n\nreshapeInsert, remove, and combine dimensions, and resize existing ones\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[[0], [1], [2]]])\n&gt;&gt;&gt; x.shape\n(1, 3, 1)\n&gt;&gt;&gt; np.squeeze(x).shape\n(3,)\n&gt;&gt;&gt; np.squeeze(x, axis=0).shape\n(3, 1)\n&gt;&gt;&gt; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n&gt;&gt;&gt; np.squeeze(x, axis=2).shape\n(1, 3)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "Returns", "squeezedndarray", "Raises", "ValueError"], "returns": "squeezedndarrayThe input array, but with all or a subset of thedimensions of length 1 removed. This is always a itselfor a view into a.", "examples": ["; x = np.array([[[0], [1], [2]]])\n; x.shape\n(1, 3, 1)\n; np.squeeze(x).shape\n(3,)\n; np.squeeze(x, axis=0).shape\n(3, 1)\n; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n; np.squeeze(x, axis=2).shape\n(1, 3)\n\n", "; x = np.array([[[0], [1], [2]]])\n; x.shape\n(1, 3, 1)\n; np.squeeze(x).shape\n(3,)\n; np.squeeze(x, axis=0).shape\n(3, 1)\n; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n; np.squeeze(x, axis=2).shape\n(1, 3)\n"]},
{"library": "numpy", "item_id": "numpy.squeeze", "code": "\nnumpy.squeeze(a, axis=None)[source]\u00b6", "description": "Remove single-dimensional entries from the shape of an array.\n\nParameters\n\naarray_likeInput data.\n\naxisNone or int or tuple of ints, optional\nNew in version 1.7.0.\n\nSelects a subset of the single-dimensional entries in the\nshape. If an axis is selected with shape entry greater than\none, an error is raised.\n\n\n\nReturns\n\nsqueezedndarrayThe input array, but with all or a subset of the\ndimensions of length 1 removed. This is always a itself\nor a view into a.\n\n\n\nRaises\n\nValueErrorIf axis is not None, and an axis being squeezed is not of length 1\n\n\n\n\n\nSee also\n\nexpand_dimsThe inverse operation, adding singleton dimensions\n\nreshapeInsert, remove, and combine dimensions, and resize existing ones\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[[0], [1], [2]]])\n&gt;&gt;&gt; x.shape\n(1, 3, 1)\n&gt;&gt;&gt; np.squeeze(x).shape\n(3,)\n&gt;&gt;&gt; np.squeeze(x, axis=0).shape\n(3, 1)\n&gt;&gt;&gt; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n&gt;&gt;&gt; np.squeeze(x, axis=2).shape\n(1, 3)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "Returns", "squeezedndarray", "Raises", "ValueError"], "returns": "squeezedndarrayThe input array, but with all or a subset of thedimensions of length 1 removed. This is always a itselfor a view into a.", "examples": ["; x = np.array([[[0], [1], [2]]])\n; x.shape\n(1, 3, 1)\n; np.squeeze(x).shape\n(3,)\n; np.squeeze(x, axis=0).shape\n(3, 1)\n; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n; np.squeeze(x, axis=2).shape\n(1, 3)\n\n", "; x = np.array([[[0], [1], [2]]])\n; x.shape\n(1, 3, 1)\n; np.squeeze(x).shape\n(3,)\n; np.squeeze(x, axis=0).shape\n(3, 1)\n; np.squeeze(x, axis=1).shape\nTraceback (most recent call last):\n...\nValueError: cannot select an axis to squeeze out which has size not equal to one\n; np.squeeze(x, axis=2).shape\n(1, 3)\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.splitlines", "code": "\nchararray.splitlines(self, keepends=None)\u00b6", "description": "For each element in self, return a list of the lines in the\nelement, breaking at line boundaries.\n\nSee also\nchar.splitlines\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.split", "code": "\nchararray.split(self, sep=None, maxsplit=None)[source]\u00b6", "description": "For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.\n\nSee also\nchar.split\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.split", "code": "\nchararray.split(self, sep=None, maxsplit=None)\u00b6", "description": "For each element in self, return a list of the words in the\nstring, using sep as the delimiter string.\n\nSee also\nchar.split\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.split", "code": "\nnumpy.split(ary, indices_or_sections, axis=0)[source]\u00b6", "description": "Split an array into multiple sub-arrays as views into ary.\n\nParameters\n\naryndarrayArray to be divided into sub-arrays.\n\nindices_or_sectionsint or 1-D arrayIf indices_or_sections is an integer, N, the array will be divided\ninto N equal arrays along axis.  If such a split is not possible,\nan error is raised.\nIf indices_or_sections is a 1-D array of sorted integers, the entries\nindicate where along axis the array is split.  For example,\n[2, 3] would, for axis=0, result in\n\n\nary[:2]\nary[2:3]\nary[3:]\n\n\nIf an index exceeds the dimension of the array along axis,\nan empty sub-array is returned correspondingly.\n\naxisint, optionalThe axis along which to split, default is 0.\n\n\n\nReturns\n\nsub-arrayslist of ndarraysA list of sub-arrays as views into ary.\n\n\n\nRaises\n\nValueErrorIf indices_or_sections is given as an integer, but\na split does not result in equal division.\n\n\n\n\n\nSee also\n\narray_splitSplit an array into multiple sub-arrays of equal or near-equal size.  Does not raise an exception if an equal division cannot be made.\n\nhsplitSplit array into multiple sub-arrays horizontally (column-wise).\n\nvsplitSplit array into multiple sub-arrays vertically (row wise).\n\ndsplitSplit array into multiple sub-arrays along the 3rd axis (depth).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nstackJoin a sequence of arrays along a new axis.\n\nhstackStack arrays in sequence horizontally (column wise).\n\nvstackStack arrays in sequence vertically (row wise).\n\ndstackStack arrays in sequence depth wise (along third dimension).\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(9.0)\n&gt;&gt;&gt; np.split(x, 3)\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\n\n\n&gt;&gt;&gt; x = np.arange(8.0)\n&gt;&gt;&gt; np.split(x, [3, 5, 6, 10])\n[array([0.,  1.,  2.]),\n array([3.,  4.]),\n array([5.]),\n array([6.,  7.]),\n array([], dtype=float64)]\n\n\n", "parameters": ["Parameters", "aryndarray", "indices_or_sectionsint or 1-D array", "axisint, optional", "Returns", "sub-arrayslist of ndarrays", "Raises", "ValueError"], "returns": "sub-arrayslist of ndarraysA list of sub-arrays as views into ary.", "examples": ["; x = np.arange(9.0)\n; np.split(x, 3)\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\n\n", "; x = np.arange(9.0)\n; np.split(x, 3)\n[array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.,  8.])]\n", "; x = np.arange(8.0)\n; np.split(x, [3, 5, 6, 10])\n[array([0.,  1.,  2.]),\n array([3.,  4.]),\n array([5.]),\n array([6.,  7.]),\n array([], dtype=float64)]\n\n", "; x = np.arange(8.0)\n; np.split(x, [3, 5, 6, 10])\n[array([0.,  1.,  2.]),\n array([3.,  4.]),\n array([5.]),\n array([6.,  7.]),\n array([], dtype=float64)]\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.spawn_key", "code": "\nSeedSequence.spawn_key\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.splitlines", "code": "\nnumpy.char.splitlines(a, keepends=None)\u00b6", "description": "For each element in a, return a list of the lines in the\nelement, breaking at line boundaries.\nCalls str.splitlines element-wise.\n\nParameters\n\naarray_like of str or unicode\nkeependsbool, optionalLine breaks are not included in the resulting list unless\nkeepends is given and true.\n\n\n\nReturns\n\noutndarrayArray of list objects\n\n\n\n\n\nSee also\nstr.splitlines\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "keependsbool, optional", "Returns", "outndarray"], "returns": "outndarrayArray of list objects", "examples": []},
{"library": "numpy", "item_id": "numpy.char.split", "code": "\nnumpy.char.split(a, sep=None, maxsplit=None)\u00b6", "description": "For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.\nCalls str.split element-wise.\n\nParameters\n\naarray_like of str or unicode\nsepstr or unicode, optionalIf sep is not specified or None, any whitespace string is a\nseparator.\n\nmaxsplitint, optionalIf maxsplit is given, at most maxsplit splits are done.\n\n\n\nReturns\n\noutndarrayArray of list objects\n\n\n\n\n\nSee also\nstr.split, rsplit\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "sepstr or unicode, optional", "maxsplitint, optional", "Returns", "outndarray"], "returns": "outndarrayArray of list objects", "examples": []},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.spawn", "code": "\nSeedSequence.spawn(n_children)\u00b6", "description": "Spawn a number of child SeedSequence s by extending the\nspawn_key.\n\nParameters\n\nn_childrenint\n\n\nReturns\n\nseqslist of SeedSequence s\n\n\n\n", "parameters": ["Parameters", "n_childrenint", "Returns", "seqslist of SeedSequence s"], "returns": "seqslist of SeedSequence s", "examples": []},
{"library": "numpy", "item_id": "numpy.spacing", "code": "\nnumpy.spacing(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'spacing'&gt;\u00b6", "description": "Return the distance between x and the nearest adjacent number.\n\nParameters\n\nxarray_likeValues to find the spacing of.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThe spacing of values of x.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nIt can be considered as a generalization of EPS:\nspacing(np.float64(1)) == np.finfo(np.float64).eps, and there\nshould not be any representable number between x + spacing(x) and\nx for any finite x.\nSpacing of +- inf and NaN is NaN.\nExamples\n&gt;&gt;&gt; np.spacing(1) == np.finfo(np.float64).eps\nTrue\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe spacing of values of x.This is a scalar if x is a scalar.", "examples": ["; np.spacing(1) == np.finfo(np.float64).eps\nTrue\n\n", "; np.spacing(1) == np.finfo(np.float64).eps\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.source", "code": "\nnumpy.source(object, output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;)[source]\u00b6", "description": "Print or write to a file the source code for a NumPy object.\nThe source code is only returned for objects written in Python. Many\nfunctions and classes are defined in C and will therefore not return\nuseful information.\n\nParameters\n\nobjectnumpy objectInput object. This can be any object (function, class, module,\n\u2026).\n\noutputfile object, optionalIf output not supplied then source code is printed to screen\n(sys.stdout).  File object must be created with either write \u2018w\u2019 or\nappend \u2018a\u2019 modes.\n\n\n\n\n\nSee also\nlookfor, info\n\nExamples\n&gt;&gt;&gt; np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    \"\"\".... (full docstring printed)\"\"\"\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)\n\n\nThe source code is only returned for objects written in Python.\n&gt;&gt;&gt; np.source(np.array)                         \nNot available for this object.\n\n\n", "parameters": ["Parameters", "objectnumpy object", "outputfile object, optional"], "returns": [], "examples": ["; np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    \"\"\".... (full docstring printed)\"\"\"\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)\n\n", "; np.source(np.interp)                        \nIn file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py\ndef interp(x, xp, fp, left=None, right=None):\n    \"\"\".... (full docstring printed)\"\"\"\n    if isinstance(x, (float, int, number)):\n        return compiled_interp([x], xp, fp, left, right).item()\n    else:\n        return compiled_interp(x, xp, fp, left, right)\n", "; np.source(np.array)                         \nNot available for this object.\n\n", "; np.source(np.array)                         \nNot available for this object.\n"]},
{"library": "numpy", "item_id": "numpy.sort_complex", "code": "\nnumpy.sort_complex(a)[source]\u00b6", "description": "Sort a complex array using the real part first, then the imaginary part.\n\nParameters\n\naarray_likeInput array\n\n\n\nReturns\n\noutcomplex ndarrayAlways returns a sorted complex array.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.sort_complex([5, 3, 6, 2, 1])\narray([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n\n\n&gt;&gt;&gt; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\narray([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "outcomplex ndarray"], "returns": "outcomplex ndarrayAlways returns a sorted complex array.", "examples": ["; np.sort_complex([5, 3, 6, 2, 1])\narray([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n\n", "; np.sort_complex([5, 3, 6, 2, 1])\narray([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])\n", "; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\narray([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n\n", "; np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])\narray([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])\n"]},
{"library": "numpy", "item_id": "numpy.record.sort", "code": "\nrecord.sort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.sort", "code": "\nrecarray.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.sort", "code": "\nndarray.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.sort", "code": "\nMaskType.sort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.sort", "code": "\nmemmap.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.sort", "code": "\nmatrix.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.sort", "code": "\nMaskedArray.sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Sort the array, in-place\n\nParameters\n\naarray_likeArray to be sorted.\n\naxisint, optionalAxis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nsorted_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\n\nnumpy.ndarray.sortMethod to sort an array in-place.\n\nargsortIndirect sort.\n\nlexsortIndirect stable sort on multiple keys.\n\nsearchsortedFind elements in a sorted array.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Default\n&gt;&gt;&gt; a.sort()\n&gt;&gt;&gt; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Put missing values in the front\n&gt;&gt;&gt; a.sort(endwith=False)\n&gt;&gt;&gt; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # fill_value takes over endwith\n&gt;&gt;&gt; a.sort(endwith=False, fill_value=3)\n&gt;&gt;&gt; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "sorted_arrayndarray"], "returns": "sorted_arrayndarrayArray of the same type and shape as a.", "examples": ["; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.sort", "code": "\nmasked_array.sort(self, axis=-1, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Sort the array, in-place\n\nParameters\n\naarray_likeArray to be sorted.\n\naxisint, optionalAxis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nsorted_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\n\nnumpy.ndarray.sortMethod to sort an array in-place.\n\nargsortIndirect sort.\n\nlexsortIndirect stable sort on multiple keys.\n\nsearchsortedFind elements in a sorted array.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Default\n&gt;&gt;&gt; a.sort()\n&gt;&gt;&gt; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Put missing values in the front\n&gt;&gt;&gt; a.sort(endwith=False)\n&gt;&gt;&gt; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # fill_value takes over endwith\n&gt;&gt;&gt; a.sort(endwith=False, fill_value=3)\n&gt;&gt;&gt; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "sorted_arrayndarray"], "returns": "sorted_arrayndarrayArray of the same type and shape as a.", "examples": ["; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.generic.sort", "code": "\ngeneric.sort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.sort", "code": "\nchararray.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.sort", "code": "\nchararray.sort(axis=-1, kind=None, order=None)\u00b6", "description": "Sort an array in-place. Refer to numpy.sort for full documentation.\n\nParameters\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with datatype. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.sortReturn a sorted copy of an array.\n\nnumpy.argsortIndirect sort.\n\nnumpy.lexsortIndirect stable sort on multiple keys.\n\nnumpy.searchsortedFind elements in sorted array.\n\nnumpy.partitionPartial sort.\n\n\n\nNotes\nSee numpy.sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4], [3,1]])\n&gt;&gt;&gt; a.sort(axis=1)\n&gt;&gt;&gt; a\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; a.sort(axis=0)\n&gt;&gt;&gt; a\narray([[1, 3],\n       [1, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n&gt;&gt;&gt; a.sort(order='y')\n&gt;&gt;&gt; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n\n", "; a = np.array([[1,4], [3,1]])\n; a.sort(axis=1)\n; a\narray([[1, 4],\n       [1, 3]])\n; a.sort(axis=0)\n; a\narray([[1, 3],\n       [1, 4]])\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n\n", "; a = np.array([('a', 2), ('c', 1)], dtype=[('x', 'S1'), ('y', int)])\n; a.sort(order='y')\n; a\narray([(b'c', 1), (b'a', 2)],\n      dtype=[('x', 'S1'), ('y', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.sort", "code": "\nnumpy.sort(a, axis=-1, kind=None, order=None)[source]\u00b6", "description": "Return a sorted copy of an array.\n\nParameters\n\naarray_likeArray to be sorted.\n\naxisint or None, optionalAxis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort or radix sort under the covers and, in general,\nthe actual implementation will vary with data type. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\nReturns\n\nsorted_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\n\nndarray.sortMethod to sort an array in-place.\n\nargsortIndirect sort.\n\nlexsortIndirect stable sort on multiple keys.\n\nsearchsortedFind elements in a sorted array.\n\npartitionPartial sort.\n\n\n\nNotes\nThe various sorting algorithms are characterized by their average speed,\nworst case performance, work space size, and whether they are stable. A\nstable sort keeps items with the same key in the same relative\norder. The four algorithms implemented in NumPy have the following\nproperties:\n\n\n\n\n\n\n\n\n\nkind\nspeed\nworst case\nwork space\nstable\n\n\n\n\u2018quicksort\u2019\n1\nO(n^2)\n0\nno\n\n\u2018heapsort\u2019\n3\nO(n*log(n))\n0\nno\n\n\u2018mergesort\u2019\n2\nO(n*log(n))\n~n/2\nyes\n\n\u2018timsort\u2019\n2\nO(n*log(n))\n~n/2\nyes\n\n\n\n\nNote\nThe datatype determines which of \u2018mergesort\u2019 or \u2018timsort\u2019\nis actually used, even if \u2018mergesort\u2019 is specified. User selection\nat a finer scale is not currently available.\n\nAll the sort algorithms make temporary copies of the data when\nsorting along any but the last axis.  Consequently, sorting along\nthe last axis is faster and uses less space than sorting along\nany other axis.\nThe sort order for complex numbers is lexicographic. If both the real\nand imaginary parts are non-nan then the order is determined by the\nreal parts except when they are equal, in which case the order is\ndetermined by the imaginary parts.\nPrevious to numpy 1.4.0 sorting real and complex arrays containing nan\nvalues led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan\nvalues are sorted to the end. The extended sort order is:\n\n\nReal: [R, nan]\nComplex: [R + Rj, R + nanj, nan + Rj, nan + nanj]\n\n\nwhere R is a non-nan real value. Complex values with the same nan\nplacements are sorted according to the non-nan part if it exists.\nNon-nan values are sorted as before.\n\nNew in version 1.12.0.\n\nquicksort has been changed to introsort.\nWhen sorting does not make enough progress it switches to\nheapsort.\nThis implementation makes quicksort O(n*log(n)) in the worst case.\n\u2018stable\u2019 automatically chooses the best stable sorting algorithm\nfor the data type being sorted.\nIt, along with \u2018mergesort\u2019 is currently mapped to\ntimsort\nor radix sort\ndepending on the data type.\nAPI forward compatibility currently limits the\nability to select the implementation and it is hardwired for the different\ndata types.\n\nNew in version 1.17.0.\n\nTimsort is added for better performance on already or nearly\nsorted data. On random data timsort is almost identical to\nmergesort. It is now used for stable sort while quicksort is still the\ndefault sort if none is chosen. For timsort details, refer to\nCPython listsort.txt.\n\u2018mergesort\u2019 and \u2018stable\u2019 are mapped to radix sort for integer data types. Radix sort is an\nO(n) sort instead of O(n log n).\n\nChanged in version 1.17.0.\n\nNaT now sorts to the end of arrays for consistency with NaN.\nExamples\n&gt;&gt;&gt; a = np.array([[1,4],[3,1]])\n&gt;&gt;&gt; np.sort(a)                # sort along the last axis\narray([[1, 4],\n       [1, 3]])\n&gt;&gt;&gt; np.sort(a, axis=None)     # sort the flattened array\narray([1, 1, 3, 4])\n&gt;&gt;&gt; np.sort(a, axis=0)        # sort along the first axis\narray([[1, 1],\n       [3, 4]])\n\n\nUse the order keyword to specify a field to use when sorting a\nstructured array:\n&gt;&gt;&gt; dtype = [('name', 'S10'), ('height', float), ('age', int)]\n&gt;&gt;&gt; values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n...           ('Galahad', 1.7, 38)]\n&gt;&gt;&gt; a = np.array(values, dtype=dtype)       # create a structured array\n&gt;&gt;&gt; np.sort(a, order='height')                        \narray([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n       ('Lancelot', 1.8999999999999999, 38)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n\n\nSort by age, then height if ages are equal:\n&gt;&gt;&gt; np.sort(a, order=['age', 'height'])               \narray([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n       ('Arthur', 1.8, 41)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint or None, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional", "Returns", "sorted_arrayndarray"], "returns": "sorted_arrayndarrayArray of the same type and shape as a.", "examples": ["; a = np.array([[1,4],[3,1]])\n; np.sort(a)                # sort along the last axis\narray([[1, 4],\n       [1, 3]])\n; np.sort(a, axis=None)     # sort the flattened array\narray([1, 1, 3, 4])\n; np.sort(a, axis=0)        # sort along the first axis\narray([[1, 1],\n       [3, 4]])\n\n", "; a = np.array([[1,4],[3,1]])\n; np.sort(a)                # sort along the last axis\narray([[1, 4],\n       [1, 3]])\n; np.sort(a, axis=None)     # sort the flattened array\narray([1, 1, 3, 4])\n; np.sort(a, axis=0)        # sort along the first axis\narray([[1, 1],\n       [3, 4]])\n", "; dtype = [('name', 'S10'), ('height', float), ('age', int)]\n; values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n...           ('Galahad', 1.7, 38)]\n; a = np.array(values, dtype=dtype)       # create a structured array\n; np.sort(a, order='height')                        \narray([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n       ('Lancelot', 1.8999999999999999, 38)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n\n", "; dtype = [('name', 'S10'), ('height', float), ('age', int)]\n; values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),\n...           ('Galahad', 1.7, 38)]\n; a = np.array(values, dtype=dtype)       # create a structured array\n; np.sort(a, order='height')                        \narray([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),\n       ('Lancelot', 1.8999999999999999, 38)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n", "; np.sort(a, order=['age', 'height'])               \narray([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n       ('Arthur', 1.8, 41)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n\n", "; np.sort(a, order=['age', 'height'])               \narray([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),\n       ('Arthur', 1.8, 41)],\n      dtype=[('name', '|S10'), ('height', '&lt;f8'), ('age', '&lt;i4')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.sort", "code": "\nnumpy.ma.sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Sort the array, in-place\n\nParameters\n\naarray_likeArray to be sorted.\n\naxisint, optionalAxis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is a structured array, this argument specifies which fields\nto compare first, second, and so on.  This list does not need to\ninclude all of the fields.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values sorting at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nsorted_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\n\nnumpy.ndarray.sortMethod to sort an array in-place.\n\nargsortIndirect sort.\n\nlexsortIndirect stable sort on multiple keys.\n\nsearchsortedFind elements in a sorted array.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Default\n&gt;&gt;&gt; a.sort()\n&gt;&gt;&gt; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # Put missing values in the front\n&gt;&gt;&gt; a.sort(endwith=False)\n&gt;&gt;&gt; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n&gt;&gt;&gt; # fill_value takes over endwith\n&gt;&gt;&gt; a.sort(endwith=False, fill_value=3)\n&gt;&gt;&gt; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "sorted_arrayndarray"], "returns": "sorted_arrayndarrayArray of the same type and shape as a.", "examples": ["; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Default\n; a.sort()\n; a\nmasked_array(data=[1, 3, 5, --, --],\n             mask=[False, False, False,  True,  True],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # Put missing values in the front\n; a.sort(endwith=False)\n; a\nmasked_array(data=[--, --, 1, 3, 5],\n             mask=[ True,  True, False, False, False],\n       fill_value=999999)\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])\n; # fill_value takes over endwith\n; a.sort(endwith=False, fill_value=3)\n; a\nmasked_array(data=[1, --, --, 3, 5],\n             mask=[False,  True,  True, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.linalg.solve", "code": "\nnumpy.linalg.solve(a, b)[source]\u00b6", "description": "Solve a linear matrix equation, or system of linear scalar equations.\nComputes the \u201cexact\u201d solution, x, of the well-determined, i.e., full\nrank, linear matrix equation ax = b.\n\nParameters\n\na(\u2026, M, M) array_likeCoefficient matrix.\n\nb{(\u2026, M,), (\u2026, M, K)}, array_likeOrdinate or \u201cdependent variable\u201d values.\n\n\n\nReturns\n\nx{(\u2026, M,), (\u2026, M, K)} ndarraySolution to the system a x = b.  Returned shape is identical to b.\n\n\n\nRaises\n\nLinAlgErrorIf a is singular or not square.\n\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThe solutions are computed using LAPACK routine _gesv.\na must be square and of full-rank, i.e., all rows (or, equivalently,\ncolumns) must be linearly independent; if either is not true, use\nlstsq for the least-squares best \u201csolution\u201d of the\nsystem/equation.\nReferences\n\n1\nG. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando,\nFL, Academic Press, Inc., 1980, pg. 22.\n\n\nExamples\nSolve the system of equations 3 * x0 + x1 = 9 and x0 + 2 * x1 = 8:\n&gt;&gt;&gt; a = np.array([[3,1], [1,2]])\n&gt;&gt;&gt; b = np.array([9,8])\n&gt;&gt;&gt; x = np.linalg.solve(a, b)\n&gt;&gt;&gt; x\narray([2.,  3.])\n\n\nCheck that the solution is correct:\n&gt;&gt;&gt; np.allclose(np.dot(a, x), b)\nTrue\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "b{(\u2026, M,), (\u2026, M, K)}, array_like", "Returns", "x{(\u2026, M,), (\u2026, M, K)} ndarray", "Raises", "LinAlgError"], "returns": "x{(\u2026, M,), (\u2026, M, K)} ndarraySolution to the system a x = b.  Returned shape is identical to b.", "examples": ["; a = np.array([[3,1], [1,2]])\n; b = np.array([9,8])\n; x = np.linalg.solve(a, b)\n; x\narray([2.,  3.])\n\n", "; a = np.array([[3,1], [1,2]])\n; b = np.array([9,8])\n; x = np.linalg.solve(a, b)\n; x\narray([2.,  3.])\n", "; np.allclose(np.dot(a, x), b)\nTrue\n\n", "; np.allclose(np.dot(a, x), b)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.soften_mask", "code": "\nMaskedArray.soften_mask(self)[source]\u00b6", "description": "Force the mask to soft.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. soften_mask sets hardmask to False.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.soften_mask", "code": "\nmasked_array.soften_mask(self)[source]\u00b6", "description": "Force the mask to soft.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. soften_mask sets hardmask to False.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.soften_mask", "code": "\nnumpy.ma.soften_mask(self) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Force the mask to soft.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. soften_mask sets hardmask to False.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.dec.slow", "code": "\nnumpy.testing.dec.slow(t)\u00b6", "description": "Label a test as \u2018slow\u2019.\nThe exact definition of a slow test is obviously both subjective and\nhardware-dependent, but in general any individual test that requires more\nthan a second or two should be labeled as slow (the whole suite consists of\nthousands of tests, so even a second is significant).\n\nParameters\n\ntcallableThe test to label as slow.\n\n\n\nReturns\n\ntcallableThe decorated test t.\n\n\n\n\nExamples\nThe numpy.testing module includes import decorators as dec.\nA test can be decorated as slow like this:\nfrom numpy.testing import *\n\n@dec.slow\ndef test_big(self):\n    print('Big, slow test')\n\n\n", "parameters": ["Parameters", "tcallable", "Returns", "tcallable"], "returns": "tcallableThe decorated test t.", "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.slogdet", "code": "\nnumpy.linalg.slogdet(a)[source]\u00b6", "description": "Compute the sign and (natural) logarithm of the determinant of an array.\nIf an array has a very small or very large determinant, then a call to\ndet may overflow or underflow. This routine is more robust against such\nissues, because it computes the logarithm of the determinant rather than\nthe determinant itself.\n\nParameters\n\na(\u2026, M, M) array_likeInput array, has to be a square 2-D array.\n\n\n\nReturns\n\nsign(\u2026) array_likeA number representing the sign of the determinant. For a real matrix,\nthis is 1, 0, or -1. For a complex matrix, this is a complex number\nwith absolute value 1 (i.e., it is on the unit circle), or else 0.\n\nlogdet(\u2026) array_likeThe natural log of the absolute value of the determinant.\n\nIf the determinant is zero, then `sign` will be 0 and `logdet` will be\n-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.\n\n\n\n\nSee also\ndet\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\n\nNew in version 1.6.0.\n\nThe determinant is computed via LU factorization using the LAPACK\nroutine z/dgetrf.\nExamples\nThe determinant of a 2-D array [[a, b], [c, d]] is ad - bc:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)\n&gt;&gt;&gt; (sign, logdet)\n(-1, 0.69314718055994529) # may vary\n&gt;&gt;&gt; sign * np.exp(logdet)\n-2.0\n\n\nComputing log-determinants for a stack of matrices:\n&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n&gt;&gt;&gt; a.shape\n(3, 2, 2)\n&gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)\n&gt;&gt;&gt; (sign, logdet)\n(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))\n&gt;&gt;&gt; sign * np.exp(logdet)\narray([-2., -3., -8.])\n\n\nThis routine succeeds where ordinary det does not:\n&gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)\n0.0\n&gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)\n(1, -1151.2925464970228)\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "Returns", "sign(\u2026) array_like", "logdet(\u2026) array_like", "If the determinant is zero, then `sign` will be 0 and `logdet` will be", "-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``."], "returns": "sign(\u2026) array_likeA number representing the sign of the determinant. For a real matrix,this is 1, 0, or -1. For a complex matrix, this is a complex numberwith absolute value 1 (i.e., it is on the unit circle), or else 0.logdet(\u2026) array_likeThe natural log of the absolute value of the determinant.If the determinant is zero, then `sign` will be 0 and `logdet` will be-Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; (sign, logdet) = np.linalg.slogdet(a)\n; (sign, logdet)\n(-1, 0.69314718055994529) # may vary\n; sign * np.exp(logdet)\n-2.0\n\n", "; a = np.array([[1, 2], [3, 4]])\n; (sign, logdet) = np.linalg.slogdet(a)\n; (sign, logdet)\n(-1, 0.69314718055994529) # may vary\n; sign * np.exp(logdet)\n-2.0\n", "; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n; a.shape\n(3, 2, 2)\n; sign, logdet = np.linalg.slogdet(a)\n; (sign, logdet)\n(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))\n; sign * np.exp(logdet)\narray([-2., -3., -8.])\n\n", "; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n; a.shape\n(3, 2, 2)\n; sign, logdet = np.linalg.slogdet(a)\n; (sign, logdet)\n(array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))\n; sign * np.exp(logdet)\narray([-2., -3., -8.])\n", "; np.linalg.det(np.eye(500) * 0.1)\n0.0\n; np.linalg.slogdet(np.eye(500) * 0.1)\n(1, -1151.2925464970228)\n\n", "; np.linalg.det(np.eye(500) * 0.1)\n0.0\n; np.linalg.slogdet(np.eye(500) * 0.1)\n(1, -1151.2925464970228)\n"]},
{"library": "numpy", "item_id": "numpy.testing.dec.skipif", "code": "\nnumpy.testing.dec.skipif(skip_condition, msg=None)\u00b6", "description": "Make function raise SkipTest exception if a given condition is true.\nIf the condition is a callable, it is used at runtime to dynamically\nmake the decision. This is useful for tests that may require costly\nimports, to delay the cost until the test suite is actually executed.\n\nParameters\n\nskip_conditionbool or callableFlag to determine whether to skip the decorated test.\n\nmsgstr, optionalMessage to give on raising a SkipTest exception. Default is None.\n\n\n\nReturns\n\ndecoratorfunctionDecorator which, when applied to a function, causes SkipTest\nto be raised when skip_condition is True, and the function\nto be called normally otherwise.\n\n\n\n\nNotes\nThe decorator itself is decorated with the nose.tools.make_decorator\nfunction in order to transmit function name, and various other metadata.\n", "parameters": ["Parameters", "skip_conditionbool or callable", "msgstr, optional", "Returns", "decoratorfunction"], "returns": "decoratorfunctionDecorator which, when applied to a function, causes SkipTestto be raised when skip_condition is True, and the functionto be called normally otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.record.size", "code": "\nrecord.size\u00b6", "description": "number of elements in the gentype\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.size", "code": "\nnumpy.ma.size(obj, axis=None)[source]\u00b6", "description": "Return the number of elements along a given axis.\n\nParameters\n\naarray_likeInput data.\n\naxisint, optionalAxis along which the elements are counted.  By default, give\nthe total number of elements.\n\n\n\nReturns\n\nelement_countintNumber of elements along the specified axis.\n\n\n\n\n\nSee also\n\nshapedimensions of array\n\nndarray.shapedimensions of array\n\nndarray.sizenumber of elements in array\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])\n&gt;&gt;&gt; np.size(a)\n6\n&gt;&gt;&gt; np.size(a,1)\n3\n&gt;&gt;&gt; np.size(a,0)\n2\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "Returns", "element_countint"], "returns": "element_countintNumber of elements along the specified axis.", "examples": ["; a = np.array([[1,2,3],[4,5,6]])\n; np.size(a)\n6\n; np.size(a,1)\n3\n; np.size(a,0)\n2\n\n", "; a = np.array([[1,2,3],[4,5,6]])\n; np.size(a)\n6\n; np.size(a,1)\n3\n; np.size(a,0)\n2\n"]},
{"library": "numpy", "item_id": "numpy.recarray.size", "code": "\nrecarray.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.size", "code": "\nMaskType.size\u00b6", "description": "number of elements in the gentype\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.size", "code": "\nndarray.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.size", "code": "\nMaskedArray.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.memmap.size", "code": "\nmemmap.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.matrix.size", "code": "\nmatrix.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.generic.size", "code": "\ngeneric.size\u00b6", "description": "number of elements in the gentype\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.size", "code": "\nmasked_array.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.chararray.size", "code": "\nchararray.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.size", "code": "\nchararray.size\u00b6", "description": "Number of elements in the array.\nEqual to np.prod(a.shape), i.e., the product of the array\u2019s\ndimensions.\nNotes\na.size returns a standard arbitrary precision Python integer. This\nmay not be the case with other methods of obtaining the same value\n(like the suggested np.prod(a.shape), which returns an instance\nof np.int_), and may be relevant if the value is used further in\ncalculations that may overflow a fixed size integer type.\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 5, 2), dtype=np.complex128)\n&gt;&gt;&gt; x.size\n30\n&gt;&gt;&gt; np.prod(x.shape)\n30\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n\n", "; x = np.zeros((3, 5, 2), dtype=np.complex128)\n; x.size\n30\n; np.prod(x.shape)\n30\n"]},
{"library": "numpy", "item_id": "numpy.broadcast.size", "code": "\nbroadcast.size\u00b6", "description": "Total size of broadcasted result.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.size\n9\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.size\n9\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.size\n9\n"]},
{"library": "numpy", "item_id": "numpy.sinc", "code": "\nnumpy.sinc(x)[source]\u00b6", "description": "Return the sinc function.\nThe sinc function is .\n\nParameters\n\nxndarrayArray (possibly multi-dimensional) of values for which to to\ncalculate sinc(x).\n\n\n\nReturns\n\noutndarraysinc(x), which has the same shape as the input.\n\n\n\n\nNotes\nsinc(0) is the limit value 1.\nThe name sinc is short for \u201csine cardinal\u201d or \u201csinus cardinalis\u201d.\nThe sinc function is used in various signal processing applications,\nincluding in anti-aliasing, in the construction of a Lanczos resampling\nfilter, and in interpolation.\nFor bandlimited interpolation of discrete-time signals, the ideal\ninterpolation kernel is proportional to the sinc function.\nReferences\n\n1\nWeisstein, Eric W. \u201cSinc Function.\u201d From MathWorld\u2013A Wolfram Web\nResource. http://mathworld.wolfram.com/SincFunction.html\n\n2\nWikipedia, \u201cSinc function\u201d,\nhttps://en.wikipedia.org/wiki/Sinc_function\n\n\nExamples\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.linspace(-4, 4, 41)\n&gt;&gt;&gt; np.sinc(x)\n array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])\n\n\n&gt;&gt;&gt; plt.plot(x, np.sinc(x))\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Sinc Function\")\nText(0.5, 1.0, 'Sinc Function')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"X\")\nText(0.5, 0, 'X')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xndarray", "Returns", "outndarray"], "returns": "outndarraysinc(x), which has the same shape as the input.", "examples": ["; import matplotlib.pyplot as plt\n; x = np.linspace(-4, 4, 41)\n; np.sinc(x)\n array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])\n\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-4, 4, 41)\n; np.sinc(x)\n array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary\n        -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,\n        6.68206631e-02,   1.16434881e-01,   1.26137788e-01,\n        8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,\n        -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,\n        3.89804309e-17,   2.33872321e-01,   5.04551152e-01,\n        7.56826729e-01,   9.35489284e-01,   1.00000000e+00,\n        9.35489284e-01,   7.56826729e-01,   5.04551152e-01,\n        2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,\n       -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,\n       -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,\n        1.16434881e-01,   6.68206631e-02,   3.89804309e-17,\n        -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,\n        -4.92362781e-02,  -3.89804309e-17])\n", "; plt.plot(x, np.sinc(x))\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Sinc Function\")\nText(0.5, 1.0, 'Sinc Function')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"X\")\nText(0.5, 0, 'X')\n; plt.show()\n\n", "; plt.plot(x, np.sinc(x))\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Sinc Function\")\nText(0.5, 1.0, 'Sinc Function')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"X\")\nText(0.5, 0, 'X')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.sin", "code": "\nnumpy.sin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'sin'&gt;\u00b6", "description": "Trigonometric sine, element-wise.\n\nParameters\n\nxarray_likeAngle, in radians ( rad equals 360 degrees).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyarray_likeThe sine of each element of x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\narcsin, sinh, cos\n\nNotes\nThe sine is one of the fundamental functions of trigonometry (the\nmathematical study of triangles).  Consider a circle of radius 1\ncentered on the origin.  A ray comes in from the  axis, makes\nan angle at the origin (measured counter-clockwise from that axis), and\ndeparts from the origin.  The  coordinate of the outgoing\nray\u2019s intersection with the unit circle is the sine of that angle.  It\nranges from -1 for  to +1 for   The\nfunction has zeroes where the angle is a multiple of .\nSines of angles between  and  are negative.\nThe numerous properties of the sine and related functions are included\nin any standard trigonometry text.\nExamples\nPrint sine of one angle:\n&gt;&gt;&gt; np.sin(np.pi/2.)\n1.0\n\n\nPrint sines of an array of angles given in degrees:\n&gt;&gt;&gt; np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n\n\nPlot the sine function:\n&gt;&gt;&gt; import matplotlib.pylab as plt\n&gt;&gt;&gt; x = np.linspace(-np.pi, np.pi, 201)\n&gt;&gt;&gt; plt.plot(x, np.sin(x))\n&gt;&gt;&gt; plt.xlabel('Angle [rad]')\n&gt;&gt;&gt; plt.ylabel('sin(x)')\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yarray_like"], "returns": "yarray_likeThe sine of each element of x.This is a scalar if x is a scalar.", "examples": ["; np.sin(np.pi/2.)\n1.0\n\n", "; np.sin(np.pi/2.)\n1.0\n", "; np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n\n", "; np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. )\narray([ 0.        ,  0.5       ,  0.70710678,  0.8660254 ,  1.        ])\n", "; import matplotlib.pylab as plt\n; x = np.linspace(-np.pi, np.pi, 201)\n; plt.plot(x, np.sin(x))\n; plt.xlabel('Angle [rad]')\n; plt.ylabel('sin(x)')\n; plt.axis('tight')\n; plt.show()\n\n", "; import matplotlib.pylab as plt\n; x = np.linspace(-np.pi, np.pi, 201)\n; plt.plot(x, np.sin(x))\n; plt.xlabel('Angle [rad]')\n; plt.ylabel('sin(x)')\n; plt.axis('tight')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.signbit", "code": "\nnumpy.signbit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'signbit'&gt;\u00b6", "description": "Returns element-wise True where signbit is set (less than zero).\n\nParameters\n\nxarray_likeThe input value(s).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nresultndarray of boolOutput array, or reference to out if that was supplied.\nThis is a scalar if x is a scalar.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.signbit(-1.2)\nTrue\n&gt;&gt;&gt; np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "resultndarray of bool"], "returns": "resultndarray of boolOutput array, or reference to out if that was supplied.This is a scalar if x is a scalar.", "examples": ["; np.signbit(-1.2)\nTrue\n; np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False])\n\n", "; np.signbit(-1.2)\nTrue\n; np.signbit(np.array([1, -2.3, 2.1]))\narray([False,  True, False])\n"]},
{"library": "numpy", "item_id": "numpy.sinh", "code": "\nnumpy.sinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'sinh'&gt;\u00b6", "description": "Hyperbolic sine, element-wise.\nEquivalent to 1/2 * (np.exp(x) - np.exp(-x)) or\n-1j * np.sin(1j*x).\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding hyperbolic sine values.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nIf out is provided, the function writes the result into it,\nand returns a reference to out.  (See Examples)\nReferences\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972, pg. 83.\nExamples\n&gt;&gt;&gt; np.sinh(0)\n0.0\n&gt;&gt;&gt; np.sinh(np.pi*1j/2)\n1j\n&gt;&gt;&gt; np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n&gt;&gt;&gt; # Discrepancy due to vagaries of floating point arithmetic.\n\n\n&gt;&gt;&gt; # Example of providing the optional output parameter\n&gt;&gt;&gt; out1 = np.array([0], dtype='d')\n&gt;&gt;&gt; out2 = np.sinh([0.1], out1)\n&gt;&gt;&gt; out2 is out1\nTrue\n\n\n&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`\n&gt;&gt;&gt; np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding hyperbolic sine values.This is a scalar if x is a scalar.", "examples": ["; np.sinh(0)\n0.0\n; np.sinh(np.pi*1j/2)\n1j\n; np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n; # Discrepancy due to vagaries of floating point arithmetic.\n\n", "; np.sinh(0)\n0.0\n; np.sinh(np.pi*1j/2)\n1j\n; np.sinh(np.pi*1j) # (exact value is 0)\n1.2246063538223773e-016j\n; # Discrepancy due to vagaries of floating point arithmetic.\n", "; # Example of providing the optional output parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.sinh([0.1], out1)\n; out2 is out1\nTrue\n\n", "; # Example of providing the optional output parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.sinh([0.1], out1)\n; out2 is out1\nTrue\n", "; # Example of ValueError due to provision of shape mis-matched `out`\n; np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n", "; # Example of ValueError due to provision of shape mis-matched `out`\n; np.sinh(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.signature", "code": "\nufunc.signature\u00b6", "description": "Definition of the core elements a generalized ufunc operates on.\nThe signature determines how the dimensions of each input/output array\nare split into core and loop dimensions:\n\nEach dimension in the signature is matched to a dimension of the\ncorresponding passed-in array, starting from the end of the shape tuple.\nCore dimensions assigned to the same label in the signature must have\nexactly matching sizes, no broadcasting is performed.\nThe core dimensions are removed from all inputs and the remaining\ndimensions are broadcast together, defining the loop dimensions.\n\nNotes\nGeneralized ufuncs are used internally in many linalg functions, and in\nthe testing suite; the examples below are taken from these.\nFor ufuncs that operate on scalars, the signature is None, which is\nequivalent to \u2018()\u2019 for every argument.\nExamples\n&gt;&gt;&gt; np.core.umath_tests.matrix_multiply.signature\n'(m,n),(n,p)-&gt;(m,p)'\n&gt;&gt;&gt; np.linalg._umath_linalg.det.signature\n'(m,m)-&gt;()'\n&gt;&gt;&gt; np.add.signature is None\nTrue  # equivalent to '(),()-&gt;()'\n\n\n", "parameters": [], "returns": [], "examples": ["; np.core.umath_tests.matrix_multiply.signature\n'(m,n),(n,p)-&gt;(m,p)'\n; np.linalg._umath_linalg.det.signature\n'(m,m)-&gt;()'\n; np.add.signature is None\nTrue  # equivalent to '(),()-&gt;()'\n\n", "; np.core.umath_tests.matrix_multiply.signature\n'(m,n),(n,p)-&gt;(m,p)'\n; np.linalg._umath_linalg.det.signature\n'(m,m)-&gt;()'\n; np.add.signature is None\nTrue  # equivalent to '(),()-&gt;()'\n"]},
{"library": "numpy", "item_id": "numpy.sign", "code": "\nnumpy.sign(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'sign'&gt;\u00b6", "description": "Returns an element-wise indication of the sign of a number.\nThe sign function returns -1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0.  nan\nis returned for nan inputs.\nFor complex inputs, the sign function returns\nsign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j.\ncomplex(nan, 0) is returned for complex nan inputs.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe sign of x.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nThere is more than one definition of sign in common use for complex\nnumbers.  The definition used here is equivalent to \nwhich is different from a common alternative, .\nExamples\n&gt;&gt;&gt; np.sign([-5., 4.5])\narray([-1.,  1.])\n&gt;&gt;&gt; np.sign(0)\n0\n&gt;&gt;&gt; np.sign(5-2j)\n(1+0j)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe sign of x.This is a scalar if x is a scalar.", "examples": ["; np.sign([-5., 4.5])\narray([-1.,  1.])\n; np.sign(0)\n0\n; np.sign(5-2j)\n(1+0j)\n\n", "; np.sign([-5., 4.5])\narray([-1.,  1.])\n; np.sign(0)\n0\n; np.sign(5-2j)\n(1+0j)\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.shuffle", "code": "\nRandomState.shuffle(x)\u00b6", "description": "Modify a sequence in-place by shuffling its contents.\nThis function only shuffles the array along the first axis of a\nmulti-dimensional array. The order of sub-arrays is changed but\ntheir contents remains the same.\n\nNote\nNew code should use the shuffle method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nxarray_likeThe array or list to be shuffled.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\n\nGenerator.shufflewhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; arr = np.arange(10)\n&gt;&gt;&gt; np.random.shuffle(arr)\n&gt;&gt;&gt; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n\nMulti-dimensional arrays are only shuffled along the first axis:\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; np.random.shuffle(arr)\n&gt;&gt;&gt; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "None"], "returns": "None", "examples": ["; arr = np.arange(10)\n; np.random.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n", "; arr = np.arange(10)\n; np.random.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n"]},
{"library": "numpy", "item_id": "numpy.random.shuffle", "code": "\nnumpy.random.shuffle(x)\u00b6", "description": "Modify a sequence in-place by shuffling its contents.\nThis function only shuffles the array along the first axis of a\nmulti-dimensional array. The order of sub-arrays is changed but\ntheir contents remains the same.\n\nNote\nNew code should use the shuffle method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nxarray_likeThe array or list to be shuffled.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\n\nGenerator.shufflewhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; arr = np.arange(10)\n&gt;&gt;&gt; np.random.shuffle(arr)\n&gt;&gt;&gt; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n\nMulti-dimensional arrays are only shuffled along the first axis:\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; np.random.shuffle(arr)\n&gt;&gt;&gt; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "None"], "returns": "None", "examples": ["; arr = np.arange(10)\n; np.random.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n", "; arr = np.arange(10)\n; np.random.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.shrink_mask", "code": "\nMaskedArray.shrink_mask(self)[source]\u00b6", "description": "Reduce a mask to nomask when possible.\n\nParameters\n\nNone\n\n\nReturns\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n&gt;&gt;&gt; x.mask\narray([[False, False],\n       [False, False]])\n&gt;&gt;&gt; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n&gt;&gt;&gt; x.mask\nFalse\n\n\n", "parameters": ["Parameters", "None", "Returns", "None"], "returns": "None", "examples": ["; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n; x.mask\narray([[False, False],\n       [False, False]])\n; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; x.mask\nFalse\n\n", "; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)\n; x.mask\narray([[False, False],\n       [False, False]])\n; x.shrink_mask()\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; x.mask\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.shuffle", "code": "\nGenerator.shuffle(x, axis=0)\u00b6", "description": "Modify a sequence in-place by shuffling its contents.\nThe order of sub-arrays is changed but their contents remains the same.\n\nParameters\n\nxarray_likeThe array or list to be shuffled.\n\naxisint, optionalThe axis which x is shuffled along. Default is 0.\nIt is only supported on ndarray objects.\n\n\n\nReturns\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; arr = np.arange(10)\n&gt;&gt;&gt; rng.shuffle(arr)\n&gt;&gt;&gt; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; rng.shuffle(arr)\n&gt;&gt;&gt; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; rng.shuffle(arr, axis=1)\n&gt;&gt;&gt; arr\narray([[2, 0, 1], # random\n       [5, 3, 4],\n       [8, 6, 7]])\n\n\n", "parameters": ["Parameters", "xarray_like", "axisint, optional", "Returns", "None"], "returns": "None", "examples": ["; rng = np.random.default_rng()\n; arr = np.arange(10)\n; rng.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n\n", "; rng = np.random.default_rng()\n; arr = np.arange(10)\n; rng.shuffle(arr)\n; arr\n[1 7 5 2 9 4 3 6 0 8] # random\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.shuffle(arr)\n; arr\narray([[3, 4, 5], # random\n       [6, 7, 8],\n       [0, 1, 2]])\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.shuffle(arr, axis=1)\n; arr\narray([[2, 0, 1], # random\n       [5, 3, 4],\n       [8, 6, 7]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.shuffle(arr, axis=1)\n; arr\narray([[2, 0, 1], # random\n       [5, 3, 4],\n       [8, 6, 7]])\n"]},
{"library": "numpy", "item_id": "numpy.lib.Arrayterator.shape", "code": "\nproperty Arrayterator.shape\u00b6", "description": "The shape of the array to be iterated over.\nFor an example, see Arrayterator.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.shape", "code": "\nnumpy.ma.shape(obj)[source]\u00b6", "description": "Return the shape of an array.\n\nParameters\n\naarray_likeInput array.\n\n\n\nReturns\n\nshapetuple of intsThe elements of the shape tuple give the lengths of the\ncorresponding array dimensions.\n\n\n\n\n\nSee also\nalen\n\nndarray.shapeEquivalent array method.\n\n\n\nExamples\n&gt;&gt;&gt; np.shape(np.eye(3))\n(3, 3)\n&gt;&gt;&gt; np.shape([[1, 2]])\n(1, 2)\n&gt;&gt;&gt; np.shape([0])\n(1,)\n&gt;&gt;&gt; np.shape(0)\n()\n\n\n&gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n&gt;&gt;&gt; np.shape(a)\n(2,)\n&gt;&gt;&gt; a.shape\n(2,)\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "shapetuple of ints"], "returns": "shapetuple of intsThe elements of the shape tuple give the lengths of thecorresponding array dimensions.", "examples": ["; np.shape(np.eye(3))\n(3, 3)\n; np.shape([[1, 2]])\n(1, 2)\n; np.shape([0])\n(1,)\n; np.shape(0)\n()\n\n", "; np.shape(np.eye(3))\n(3, 3)\n; np.shape([[1, 2]])\n(1, 2)\n; np.shape([0])\n(1,)\n; np.shape(0)\n()\n", "; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n; np.shape(a)\n(2,)\n; a.shape\n(2,)\n\n", "; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n; np.shape(a)\n(2,)\n; a.shape\n(2,)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.shape", "code": "\nproperty masked_array.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.shape", "code": "\nnumpy.shape(a)[source]\u00b6", "description": "Return the shape of an array.\n\nParameters\n\naarray_likeInput array.\n\n\n\nReturns\n\nshapetuple of intsThe elements of the shape tuple give the lengths of the\ncorresponding array dimensions.\n\n\n\n\n\nSee also\nalen\n\nndarray.shapeEquivalent array method.\n\n\n\nExamples\n&gt;&gt;&gt; np.shape(np.eye(3))\n(3, 3)\n&gt;&gt;&gt; np.shape([[1, 2]])\n(1, 2)\n&gt;&gt;&gt; np.shape([0])\n(1,)\n&gt;&gt;&gt; np.shape(0)\n()\n\n\n&gt;&gt;&gt; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n&gt;&gt;&gt; np.shape(a)\n(2,)\n&gt;&gt;&gt; a.shape\n(2,)\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "shapetuple of ints"], "returns": "shapetuple of intsThe elements of the shape tuple give the lengths of thecorresponding array dimensions.", "examples": ["; np.shape(np.eye(3))\n(3, 3)\n; np.shape([[1, 2]])\n(1, 2)\n; np.shape([0])\n(1,)\n; np.shape(0)\n()\n\n", "; np.shape(np.eye(3))\n(3, 3)\n; np.shape([[1, 2]])\n(1, 2)\n; np.shape([0])\n(1,)\n; np.shape(0)\n()\n", "; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n; np.shape(a)\n(2,)\n; a.shape\n(2,)\n\n", "; a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])\n; np.shape(a)\n(2,)\n; a.shape\n(2,)\n"]},
{"library": "numpy", "item_id": "numpy.recarray.shape", "code": "\nrecarray.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.record.shape", "code": "\nrecord.shape\u00b6", "description": "tuple of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.shape", "code": "\nndarray.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.memmap.shape", "code": "\nmemmap.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.nditer.shape", "code": "\nnditer.shape\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.shape", "code": "\nmatrix.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.shape", "code": "\nMaskType.shape\u00b6", "description": "tuple of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.shape", "code": "\ngeneric.shape\u00b6", "description": "tuple of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.shape", "code": "\ndtype.shape\u00b6", "description": "Shape tuple of the sub-array if this data type describes a sub-array,\nand () otherwise.\nExamples\n&gt;&gt;&gt; dt = np.dtype(('i4', 4))\n&gt;&gt;&gt; dt.shape\n(4,)\n\n\n&gt;&gt;&gt; dt = np.dtype(('i4', (2, 3)))\n&gt;&gt;&gt; dt.shape\n(2, 3)\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype(('i4', 4))\n; dt.shape\n(4,)\n\n", "; dt = np.dtype(('i4', 4))\n; dt.shape\n(4,)\n", "; dt = np.dtype(('i4', (2, 3)))\n; dt.shape\n(2, 3)\n\n", "; dt = np.dtype(('i4', (2, 3)))\n; dt.shape\n(2, 3)\n"]},
{"library": "numpy", "item_id": "numpy.chararray.shape", "code": "\nchararray.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.shape", "code": "\nchararray.shape\u00b6", "description": "Tuple of array dimensions.\nThe shape property is usually used to get the current shape of an array,\nbut may also be used to reshape the array in-place by assigning a tuple of\narray dimensions to it.  As with numpy.reshape, one of the new shape\ndimensions can be -1, in which case its value is inferred from the size of\nthe array and the remaining dimensions. Reshaping an array in-place will\nfail if a copy is required.\n\nSee also\n\nnumpy.reshapesimilar function\n\nndarray.reshapesimilar method\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; x.shape\n(4,)\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.shape\n(2, 3, 4)\n&gt;&gt;&gt; y.shape = (3, 8)\n&gt;&gt;&gt; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n&gt;&gt;&gt; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n&gt;&gt;&gt; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n\n", "; x = np.array([1, 2, 3, 4])\n; x.shape\n(4,)\n; y = np.zeros((2, 3, 4))\n; y.shape\n(2, 3, 4)\n; y.shape = (3, 8)\n; y\narray([[ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.]])\n; y.shape = (3, 6)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: total size of new array must be unchanged\n; np.zeros((4,2))[::2].shape = (-1,)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nAttributeError: incompatible shape for a non-contiguous array\n"]},
{"library": "numpy", "item_id": "numpy.broadcast.shape", "code": "\nbroadcast.shape\u00b6", "description": "Shape of broadcasted result.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.shape\n(3, 3)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.shape\n(3, 3)\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.shape\n(3, 3)\n"]},
{"library": "numpy", "item_id": "numpy.random.SFC64", "code": "\nclass numpy.random.SFC64(seed=None)\u00b6", "description": "BitGenerator for Chris Doty-Humphrey\u2019s Small Fast Chaotic PRNG.\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\nSeedSequence to derive the initial BitGenerator state. One may also\npass in a SeedSequence instance.\n\n\n\n\nNotes\nSFC64 is a 256-bit implementation of Chris Doty-Humphrey\u2019s Small Fast\nChaotic PRNG ([1]). SFC64 has a few different cycles that one might be\non, depending on the seed; the expected period will be about\n ([2]). SFC64 incorporates a 64-bit counter which means\nthat the absolute minimum cycle length is  and that distinct\nseeds will not run into each other for at least  iterations.\nSFC64 provides a capsule containing function pointers that produce\ndoubles, and unsigned 32 and 64- bit integers. These are not\ndirectly consumable in Python and must be consumed by a Generator\nor similar object that supports low-level access.\nState and Seeding\nThe SFC64 state vector consists of 4 unsigned 64-bit values. The last\nis a 64-bit counter that increments by 1 each iteration.\nThe input seed is processed by SeedSequence to generate the first\n3 values, then the SFC64 algorithm is iterated a small number of times\nto mix.\nCompatibility Guarantee\nSFC64 makes a guarantee that a fixed seed will always produce the same\nrandom integer stream.\nReferences\n\n1\n\u201cPractRand\u201d\n\n2\n\u201cRandom Invertible Mapping Statistics\u201d\n\n\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.setxor1d", "code": "\nnumpy.setxor1d(ar1, ar2, assume_unique=False)[source]\u00b6", "description": "Find the set exclusive-or of two arrays.\nReturn the sorted, unique values that are in only one (not both) of the\ninput arrays.\n\nParameters\n\nar1, ar2array_likeInput arrays.\n\nassume_uniqueboolIf True, the input arrays are both assumed to be unique, which\ncan speed up the calculation.  Default is False.\n\n\n\nReturns\n\nsetxor1dndarraySorted 1D array of unique values that are in only one of the input\narrays.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4])\n&gt;&gt;&gt; b = np.array([2, 3, 5, 7, 5])\n&gt;&gt;&gt; np.setxor1d(a,b)\narray([1, 4, 5, 7])\n\n\n", "parameters": ["Parameters", "ar1, ar2array_like", "assume_uniquebool", "Returns", "setxor1dndarray"], "returns": "setxor1dndarraySorted 1D array of unique values that are in only one of the inputarrays.", "examples": ["; a = np.array([1, 2, 3, 2, 4])\n; b = np.array([2, 3, 5, 7, 5])\n; np.setxor1d(a,b)\narray([1, 4, 5, 7])\n\n", "; a = np.array([1, 2, 3, 2, 4])\n; b = np.array([2, 3, 5, 7, 5])\n; np.setxor1d(a,b)\narray([1, 4, 5, 7])\n"]},
{"library": "numpy", "item_id": "numpy.record.setflags", "code": "\nrecord.setflags()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.setflags", "code": "\nrecarray.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.setflags", "code": "\nndarray.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.setflags", "code": "\nmasked_array.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.memmap.setflags", "code": "\nmemmap.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.matrix.setflags", "code": "\nmatrix.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.setflags", "code": "\nMaskType.setflags()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.setflags", "code": "\ngeneric.setflags()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.setflags", "code": "\nchararray.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.setflags", "code": "\nchararray.setflags(write=None, align=None, uic=None)\u00b6", "description": "Set array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY),\nrespectively.\nThese Boolean-valued flags affect how numpy interprets the memory\narea used by a (see Notes below). The ALIGNED flag can only\nbe set to True if the data is actually aligned according to the type.\nThe WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set\nto True. The flag WRITEABLE can only be set to True if the array owns its\nown memory, or the ultimate owner of the memory exposes a writeable buffer\ninterface, or is a string. (The exception for string is made so that\nunpickling can be done without copying memory.)\n\nParameters\n\nwritebool, optionalDescribes whether or not a can be written to.\n\nalignbool, optionalDescribes whether or not a is aligned properly for its type.\n\nuicbool, optionalDescribes whether or not a is a copy of another \u201cbase\u201d array.\n\n\n\n\nNotes\nArray flags provide information about how the memory area used\nfor the array is to be interpreted. There are 7 Boolean flags\nin use, only four of which can be changed by the user:\nWRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.\nWRITEABLE (W) the data area can be written to;\nALIGNED (A) the data and strides are aligned appropriately for the hardware\n(as determined by the compiler);\nUPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;\nWRITEBACKIFCOPY (X) this array is a copy of some other array (referenced\nby .base). When the C-API function PyArray_ResolveWritebackIfCopy is\ncalled, the base array will be updated with the contents of this array.\nAll flags can be accessed using the single (upper case) letter as well\nas the full name.\nExamples\n&gt;&gt;&gt; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n&gt;&gt;&gt; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(write=0, align=0)\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n&gt;&gt;&gt; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n\n", "parameters": ["Parameters", "writebool, optional", "alignbool, optional", "uicbool, optional"], "returns": [], "examples": ["; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n\n", "; y = np.array([[3, 1, 7],\n...               [2, 0, 0],\n...               [8, 5, 9]])\n; y\narray([[3, 1, 7],\n       [2, 0, 0],\n       [8, 5, 9]])\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(write=0, align=0)\n; y.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : True\n  WRITEABLE : False\n  ALIGNED : False\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n; y.setflags(uic=1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: cannot set WRITEBACKIFCOPY flag to True\n"]},
{"library": "numpy", "item_id": "numpy.record.setfield", "code": "\nrecord.setfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.setfield", "code": "\nrecarray.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.setfield", "code": "\nmatrix.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.setfield", "code": "\nndarray.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.setfield", "code": "\nmemmap.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.setfield", "code": "\nMaskType.setfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.setfield", "code": "\nmasked_array.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.generic.setfield", "code": "\ngeneric.setfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.setfield", "code": "\nchararray.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.setfield", "code": "\nchararray.setfield(val, dtype, offset=0)\u00b6", "description": "Put a value into a specified place in a field defined by a data-type.\nPlace val into a\u2019s field defined by dtype and beginning offset\nbytes into the field.\n\nParameters\n\nvalobjectValue to be placed in field.\n\ndtypedtype objectData-type of the field in which to place val.\n\noffsetint, optionalThe number of bytes into the field at which to place val.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\ngetfield\n\nExamples\n&gt;&gt;&gt; x = np.eye(3)\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n&gt;&gt;&gt; x.setfield(3, np.int32)\n&gt;&gt;&gt; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n&gt;&gt;&gt; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n&gt;&gt;&gt; x.setfield(np.eye(3), np.int32)\n&gt;&gt;&gt; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "valobject", "dtypedtype object", "offsetint, optional", "Returns", "None"], "returns": "None", "examples": ["; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; x = np.eye(3)\n; x.getfield(np.float64)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n; x.setfield(3, np.int32)\n; x.getfield(np.int32)\narray([[3, 3, 3],\n       [3, 3, 3],\n       [3, 3, 3]], dtype=int32)\n; x\narray([[1.0e+000, 1.5e-323, 1.5e-323],\n       [1.5e-323, 1.0e+000, 1.5e-323],\n       [1.5e-323, 1.5e-323, 1.0e+000]])\n; x.setfield(np.eye(3), np.int32)\n; x\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.seterrobj", "code": "\nnumpy.seterrobj(errobj)\u00b6", "description": "Set the object that defines floating-point error handling.\nThe error object contains all information that defines the error handling\nbehavior in NumPy. seterrobj is used internally by the other\nfunctions that set error handling behavior (seterr, seterrcall).\n\nParameters\n\nerrobjlistThe error object, a list containing three elements:\n[internal numpy buffer size, error mask, error callback function].\nThe error mask is a single integer that holds the treatment information\non all four floating point errors. The information for each error type\nis contained in three bits of the integer. If we print it in base 8, we\ncan see what treatment is set for \u201cinvalid\u201d, \u201cunder\u201d, \u201cover\u201d, and\n\u201cdivide\u201d (in that order). The printed string can be interpreted with\n\n0 : \u2018ignore\u2019\n1 : \u2018warn\u2019\n2 : \u2018raise\u2019\n3 : \u2018call\u2019\n4 : \u2018print\u2019\n5 : \u2018log\u2019\n\n\n\n\n\n\nSee also\ngeterrobj, seterr, geterr, seterrcall, geterrcall, getbufsize, setbufsize\n\nNotes\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see seterr.\nExamples\n&gt;&gt;&gt; old_errobj = np.geterrobj()  # first get the defaults\n&gt;&gt;&gt; old_errobj\n[8192, 521, None]\n\n\n&gt;&gt;&gt; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n&gt;&gt;&gt; new_errobj = [20000, 12, err_handler]\n&gt;&gt;&gt; np.seterrobj(new_errobj)\n&gt;&gt;&gt; np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n'14'\n&gt;&gt;&gt; np.geterr()\n{'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n&gt;&gt;&gt; np.geterrcall() is err_handler\nTrue\n\n\n", "parameters": ["Parameters", "errobjlist"], "returns": [], "examples": ["; old_errobj = np.geterrobj()  # first get the defaults\n; old_errobj\n[8192, 521, None]\n\n", "; old_errobj = np.geterrobj()  # first get the defaults\n; old_errobj\n[8192, 521, None]\n", "; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n; new_errobj = [20000, 12, err_handler]\n; np.seterrobj(new_errobj)\n; np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n'14'\n; np.geterr()\n{'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n; np.geterrcall() is err_handler\nTrue\n\n", "; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n; new_errobj = [20000, 12, err_handler]\n; np.seterrobj(new_errobj)\n; np.base_repr(12, 8)  # int for divide=4 ('print') and over=1 ('warn')\n'14'\n; np.geterr()\n{'over': 'warn', 'divide': 'print', 'invalid': 'ignore', 'under': 'ignore'}\n; np.geterrcall() is err_handler\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.seterrcall", "code": "\nnumpy.seterrcall(func)[source]\u00b6", "description": "Set the floating-point error callback function or log object.\nThere are two ways to capture floating-point error messages.  The first\nis to set the error-handler to \u2018call\u2019, using seterr.  Then, set\nthe function to call using this function.\nThe second is to set the error-handler to \u2018log\u2019, using seterr.\nFloating-point errors then trigger a call to the \u2018write\u2019 method of\nthe provided object.\n\nParameters\n\nfunccallable f(err, flag) or object with write methodFunction to call upon floating-point errors (\u2018call\u2019-mode) or\nobject whose \u2018write\u2019 method is used to log such message (\u2018log\u2019-mode).\nThe call function takes two arguments. The first is a string describing\nthe type of error (such as \u201cdivide by zero\u201d, \u201coverflow\u201d, \u201cunderflow\u201d,\nor \u201cinvalid value\u201d), and the second is the status flag.  The flag is a\nbyte, whose four least-significant bits indicate the type of error, one\nof \u201cdivide\u201d, \u201cover\u201d, \u201cunder\u201d, \u201cinvalid\u201d:\n[0 0 0 0 divide over under invalid]\n\n\nIn other words, flags = divide + 2*over + 4*under + 8*invalid.\nIf an object is provided, its write method should take one argument,\na string.\n\n\n\nReturns\n\nhcallable, log instance or NoneThe old error handler.\n\n\n\n\n\nSee also\nseterr, geterr, geterrcall\n\nExamples\nCallback upon error:\n&gt;&gt;&gt; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n\n\n&gt;&gt;&gt; saved_handler = np.seterrcall(err_handler)\n&gt;&gt;&gt; save_err = np.seterr(all='call')\n&gt;&gt;&gt; from collections import OrderedDict\n\n\n&gt;&gt;&gt; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n\n&gt;&gt;&gt; np.seterrcall(saved_handler)\n&lt;function err_handler at 0x...&gt;\n&gt;&gt;&gt; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])\n\n\nLog error message:\n&gt;&gt;&gt; class Log(object):\n...     def write(self, msg):\n...         print(\"LOG: %s\" % msg)\n...\n\n\n&gt;&gt;&gt; log = Log()\n&gt;&gt;&gt; saved_handler = np.seterrcall(log)\n&gt;&gt;&gt; save_err = np.seterr(all='log')\n\n\n&gt;&gt;&gt; np.array([1, 2, 3]) / 0.0\nLOG: Warning: divide by zero encountered in true_divide\narray([inf, inf, inf])\n\n\n&gt;&gt;&gt; np.seterrcall(saved_handler)\n&lt;numpy.core.numeric.Log object at 0x...&gt;\n&gt;&gt;&gt; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])\n\n\n", "parameters": ["Parameters", "funccallable f(err, flag) or object with write method", "Returns", "hcallable, log instance or None"], "returns": "hcallable, log instance or NoneThe old error handler.", "examples": ["; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n\n", "; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n", "; saved_handler = np.seterrcall(err_handler)\n; save_err = np.seterr(all='call')\n; from collections import OrderedDict\n\n", "; saved_handler = np.seterrcall(err_handler)\n; save_err = np.seterr(all='call')\n; from collections import OrderedDict\n", "; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n", "; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n", "; np.seterrcall(saved_handler)\n&lt;function err_handler at 0x...&gt;\n; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])\n\n", "; np.seterrcall(saved_handler)\n&lt;function err_handler at 0x...&gt;\n; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'call'), ('invalid', 'call'), ('over', 'call'), ('under', 'call')])\n", "; class Log(object):\n...     def write(self, msg):\n...         print(\"LOG: %s\" % msg)\n...\n\n", "; class Log(object):\n...     def write(self, msg):\n...         print(\"LOG: %s\" % msg)\n...\n", "; log = Log()\n; saved_handler = np.seterrcall(log)\n; save_err = np.seterr(all='log')\n\n", "; log = Log()\n; saved_handler = np.seterrcall(log)\n; save_err = np.seterr(all='log')\n", "; np.array([1, 2, 3]) / 0.0\nLOG: Warning: divide by zero encountered in true_divide\narray([inf, inf, inf])\n\n", "; np.array([1, 2, 3]) / 0.0\nLOG: Warning: divide by zero encountered in true_divide\narray([inf, inf, inf])\n", "; np.seterrcall(saved_handler)\n&lt;numpy.core.numeric.Log object at 0x...&gt;\n; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])\n\n", "; np.seterrcall(saved_handler)\n&lt;numpy.core.numeric.Log object at 0x...&gt;\n; OrderedDict(sorted(np.seterr(**save_err).items()))\nOrderedDict([('divide', 'log'), ('invalid', 'log'), ('over', 'log'), ('under', 'log')])\n"]},
{"library": "numpy", "item_id": "numpy.seterr", "code": "\nnumpy.seterr(all=None, divide=None, over=None, under=None, invalid=None)[source]\u00b6", "description": "Set how floating-point errors are handled.\nNote that operations on integer scalar types (such as int16) are\nhandled like floating point, and are affected by these settings.\n\nParameters\n\nall{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optionalSet treatment for all types of floating-point errors at once:\n\nignore: Take no action when the exception occurs.\nwarn: Print a RuntimeWarning (via the Python warnings module).\nraise: Raise a FloatingPointError.\ncall: Call a function specified using the seterrcall function.\nprint: Print a warning directly to stdout.\nlog: Record error in a Log object specified by seterrcall.\n\nThe default is not to change the current behavior.\n\ndivide{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optionalTreatment for division by zero.\n\nover{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optionalTreatment for floating-point overflow.\n\nunder{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optionalTreatment for floating-point underflow.\n\ninvalid{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optionalTreatment for invalid floating-point operation.\n\n\n\nReturns\n\nold_settingsdictDictionary containing the old settings.\n\n\n\n\n\nSee also\n\nseterrcallSet a callback function for the \u2018call\u2019 mode.\n\n\ngeterr, geterrcall, errstate\n\nNotes\nThe floating-point exceptions are defined in the IEEE 754 standard [1]:\n\nDivision by zero: infinite result obtained from finite numbers.\nOverflow: result too large to be expressed.\nUnderflow: result so close to zero that some precision\nwas lost.\nInvalid operation: result is not an expressible number, typically\nindicates that a NaN was produced.\n\n\n1\nhttps://en.wikipedia.org/wiki/IEEE_754\n\n\nExamples\n&gt;&gt;&gt; old_settings = np.seterr(all='ignore')  #seterr to known value\n&gt;&gt;&gt; np.seterr(over='raise')\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n&gt;&gt;&gt; np.seterr(**old_settings)  # reset to default\n{'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}\n\n\n&gt;&gt;&gt; np.int16(32000) * np.int16(3)\n30464\n&gt;&gt;&gt; old_settings = np.seterr(all='warn', over='raise')\n&gt;&gt;&gt; np.int16(32000) * np.int16(3)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFloatingPointError: overflow encountered in short_scalars\n\n\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; old_settings = np.seterr(all='print')\n&gt;&gt;&gt; OrderedDict(np.geterr())\nOrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])\n&gt;&gt;&gt; np.int16(32000) * np.int16(3)\n30464\n\n\n", "parameters": ["Parameters", "all{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optional", "divide{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optional", "over{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optional", "under{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optional", "invalid{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}, optional", "Returns", "old_settingsdict"], "returns": "old_settingsdictDictionary containing the old settings.", "examples": ["; old_settings = np.seterr(all='ignore')  #seterr to known value\n; np.seterr(over='raise')\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n; np.seterr(**old_settings)  # reset to default\n{'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}\n\n", "; old_settings = np.seterr(all='ignore')  #seterr to known value\n; np.seterr(over='raise')\n{'divide': 'ignore', 'over': 'ignore', 'under': 'ignore', 'invalid': 'ignore'}\n; np.seterr(**old_settings)  # reset to default\n{'divide': 'ignore', 'over': 'raise', 'under': 'ignore', 'invalid': 'ignore'}\n", "; np.int16(32000) * np.int16(3)\n30464\n; old_settings = np.seterr(all='warn', over='raise')\n; np.int16(32000) * np.int16(3)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFloatingPointError: overflow encountered in short_scalars\n\n", "; np.int16(32000) * np.int16(3)\n30464\n; old_settings = np.seterr(all='warn', over='raise')\n; np.int16(32000) * np.int16(3)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nFloatingPointError: overflow encountered in short_scalars\n", "; from collections import OrderedDict\n; old_settings = np.seterr(all='print')\n; OrderedDict(np.geterr())\nOrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])\n; np.int16(32000) * np.int16(3)\n30464\n\n", "; from collections import OrderedDict\n; old_settings = np.seterr(all='print')\n; OrderedDict(np.geterr())\nOrderedDict([('divide', 'print'), ('over', 'print'), ('under', 'print'), ('invalid', 'print')])\n; np.int16(32000) * np.int16(3)\n30464\n"]},
{"library": "numpy", "item_id": "numpy.setbufsize", "code": "\nnumpy.setbufsize(size)[source]\u00b6", "description": "Set the size of the buffer used in ufuncs.\n\nParameters\n\nsizeintSize of buffer.\n\n\n\n\n", "parameters": ["Parameters", "sizeint"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.dec.setastest", "code": "\nnumpy.testing.dec.setastest(tf=True)\u00b6", "description": "Signals to nose that this function is or is not a test.\n\nParameters\n\ntfboolIf True, specifies that the decorated callable is a test.\nIf False, specifies that the decorated callable is not a test.\nDefault is True.\n\n\n\n\nNotes\nThis decorator can\u2019t use the nose namespace, because it can be\ncalled from a non-test module. See also istest and nottest in\nnose.tools.\nExamples\nsetastest can be used in the following way:\nfrom numpy.testing import dec\n\n@dec.setastest(False)\ndef func_with_test_in_name(arg1, arg2):\n    pass\n\n\n", "parameters": ["Parameters", "tfbool"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.distutils.log.set_verbosity", "code": "\nnumpy.distutils.log.set_verbosity(v, force=False)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.setdiff1d", "code": "\nnumpy.setdiff1d(ar1, ar2, assume_unique=False)[source]\u00b6", "description": "Find the set difference of two arrays.\nReturn the unique values in ar1 that are not in ar2.\n\nParameters\n\nar1array_likeInput array.\n\nar2array_likeInput comparison array.\n\nassume_uniqueboolIf True, the input arrays are both assumed to be unique, which\ncan speed up the calculation.  Default is False.\n\n\n\nReturns\n\nsetdiff1dndarray1D array of values in ar1 that are not in ar2. The result\nis sorted when assume_unique=False, but otherwise only sorted\nif the input is sorted.\n\n\n\n\n\nSee also\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2, 3, 2, 4, 1])\n&gt;&gt;&gt; b = np.array([3, 4, 5, 6])\n&gt;&gt;&gt; np.setdiff1d(a, b)\narray([1, 2])\n\n\n", "parameters": ["Parameters", "ar1array_like", "ar2array_like", "assume_uniquebool", "Returns", "setdiff1dndarray"], "returns": "setdiff1dndarray1D array of values in ar1 that are not in ar2. The resultis sorted when assume_unique=False, but otherwise only sortedif the input is sorted.", "examples": ["; a = np.array([1, 2, 3, 2, 4, 1])\n; b = np.array([3, 4, 5, 6])\n; np.setdiff1d(a, b)\narray([1, 2])\n\n", "; a = np.array([1, 2, 3, 2, 4, 1])\n; b = np.array([3, 4, 5, 6])\n; np.setdiff1d(a, b)\narray([1, 2])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.set_state", "code": "\nRandomState.set_state(state)\u00b6", "description": "Set the internal state of the generator from a tuple.\nFor use if one has reason to manually (re-)set the internal state of\nthe bit generator used by the RandomState instance. By default,\nRandomState uses the \u201cMersenne Twister\u201d[1] pseudo-random number\ngenerating algorithm.\n\nParameters\n\nstate{tuple(str, ndarray of 624 uints, int, int, float), dict}The state tuple has the following items:\n\nthe string \u2018MT19937\u2019, specifying the Mersenne Twister algorithm.\na 1-D array of 624 unsigned integers keys.\nan integer pos.\nan integer has_gauss.\na float cached_gaussian.\n\nIf state is a dictionary, it is directly set using the BitGenerators\nstate property.\n\n\n\nReturns\n\noutNoneReturns \u2018None\u2019 on success.\n\n\n\n\n\nSee also\nget_state\n\nNotes\nset_state and get_state are not needed to work with any of the\nrandom distributions in NumPy. If the internal state is manually altered,\nthe user should know exactly what he/she is doing.\nFor backwards compatibility, the form (str, array of 624 uints, int) is\nalso accepted although it is missing some information about the cached\nGaussian value: state = ('MT19937', keys, pos).\nReferences\n\n1\nM. Matsumoto and T. Nishimura, \u201cMersenne Twister: A\n623-dimensionally equidistributed uniform pseudorandom number\ngenerator,\u201d ACM Trans. on Modeling and Computer Simulation,\nVol. 8, No. 1, pp. 3-30, Jan. 1998.\n\n\n", "parameters": ["Parameters", "state{tuple(str, ndarray of 624 uints, int, int, float), dict}", "Returns", "outNone"], "returns": "outNoneReturns \u2018None\u2019 on success.", "examples": []},
{"library": "numpy", "item_id": "numpy.set_string_function", "code": "\nnumpy.set_string_function(f, repr=True)[source]\u00b6", "description": "Set a Python function to be used when pretty printing arrays.\n\nParameters\n\nffunction or NoneFunction to be used to pretty print arrays. The function should expect\na single array argument and return a string of the representation of\nthe array. If None, the function is reset to the default NumPy function\nto print arrays.\n\nreprbool, optionalIf True (default), the function for pretty printing (__repr__)\nis set, if False the function that returns the default string\nrepresentation (__str__) is set.\n\n\n\n\n\nSee also\nset_printoptions, get_printoptions\n\nExamples\n&gt;&gt;&gt; def pprint(arr):\n...     return 'HA! - What are you going to do now?'\n...\n&gt;&gt;&gt; np.set_string_function(pprint)\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; a\nHA! - What are you going to do now?\n&gt;&gt;&gt; _ = a\n&gt;&gt;&gt; # [0 1 2 3 4 5 6 7 8 9]\n\n\nWe can reset the function to the default:\n&gt;&gt;&gt; np.set_string_function(None)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\nrepr affects either pretty printing or normal string representation.\nNote that __repr__ is still affected by setting __str__\nbecause the width of each array element in the returned string becomes\nequal to the length of the result of __str__().\n&gt;&gt;&gt; x = np.arange(4)\n&gt;&gt;&gt; np.set_string_function(lambda x:'random', repr=False)\n&gt;&gt;&gt; x.__str__()\n'random'\n&gt;&gt;&gt; x.__repr__()\n'array([0, 1, 2, 3])'\n\n\n", "parameters": ["Parameters", "ffunction or None", "reprbool, optional"], "returns": [], "examples": ["; def pprint(arr):\n...     return 'HA! - What are you going to do now?'\n...\n; np.set_string_function(pprint)\n; a = np.arange(10)\n; a\nHA! - What are you going to do now?\n; _ = a\n; # [0 1 2 3 4 5 6 7 8 9]\n\n", "; def pprint(arr):\n...     return 'HA! - What are you going to do now?'\n...\n; np.set_string_function(pprint)\n; a = np.arange(10)\n; a\nHA! - What are you going to do now?\n; _ = a\n; # [0 1 2 3 4 5 6 7 8 9]\n", "; np.set_string_function(None)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n", "; np.set_string_function(None)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n", "; x = np.arange(4)\n; np.set_string_function(lambda x:'random', repr=False)\n; x.__str__()\n'random'\n; x.__repr__()\n'array([0, 1, 2, 3])'\n\n", "; x = np.arange(4)\n; np.set_string_function(lambda x:'random', repr=False)\n; x.__str__()\n'random'\n; x.__repr__()\n'array([0, 1, 2, 3])'\n"]},
{"library": "numpy", "item_id": "numpy.random.set_state", "code": "\nnumpy.random.set_state(state)\u00b6", "description": "Set the internal state of the generator from a tuple.\nFor use if one has reason to manually (re-)set the internal state of\nthe bit generator used by the RandomState instance. By default,\nRandomState uses the \u201cMersenne Twister\u201d[1] pseudo-random number\ngenerating algorithm.\n\nParameters\n\nstate{tuple(str, ndarray of 624 uints, int, int, float), dict}The state tuple has the following items:\n\nthe string \u2018MT19937\u2019, specifying the Mersenne Twister algorithm.\na 1-D array of 624 unsigned integers keys.\nan integer pos.\nan integer has_gauss.\na float cached_gaussian.\n\nIf state is a dictionary, it is directly set using the BitGenerators\nstate property.\n\n\n\nReturns\n\noutNoneReturns \u2018None\u2019 on success.\n\n\n\n\n\nSee also\nget_state\n\nNotes\nset_state and get_state are not needed to work with any of the\nrandom distributions in NumPy. If the internal state is manually altered,\nthe user should know exactly what he/she is doing.\nFor backwards compatibility, the form (str, array of 624 uints, int) is\nalso accepted although it is missing some information about the cached\nGaussian value: state = ('MT19937', keys, pos).\nReferences\n\n1\nM. Matsumoto and T. Nishimura, \u201cMersenne Twister: A\n623-dimensionally equidistributed uniform pseudorandom number\ngenerator,\u201d ACM Trans. on Modeling and Computer Simulation,\nVol. 8, No. 1, pp. 3-30, Jan. 1998.\n\n\n", "parameters": ["Parameters", "state{tuple(str, ndarray of 624 uints, int, int, float), dict}", "Returns", "outNone"], "returns": "outNoneReturns \u2018None\u2019 on success.", "examples": []},
{"library": "numpy", "item_id": "numpy.set_printoptions", "code": "\nnumpy.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, suppress=None, nanstr=None, infstr=None, formatter=None, sign=None, floatmode=None, **kwarg)[source]\u00b6", "description": "Set printing options.\nThese options determine the way floating point numbers, arrays and\nother NumPy objects are displayed.\n\nParameters\n\nprecisionint or None, optionalNumber of digits of precision for floating point output (default 8).\nMay be None if floatmode is not fixed, to print as many digits as\nnecessary to uniquely specify the value.\n\nthresholdint, optionalTotal number of array elements which trigger summarization\nrather than full repr (default 1000).\nTo always use the full repr without summarization, pass sys.maxsize.\n\nedgeitemsint, optionalNumber of array items in summary at beginning and end of\neach dimension (default 3).\n\nlinewidthint, optionalThe number of characters per line for the purpose of inserting\nline breaks (default 75).\n\nsuppressbool, optionalIf True, always print floating point numbers using fixed point\nnotation, in which case numbers equal to zero in the current precision\nwill print as zero.  If False, then scientific notation is used when\nabsolute value of the smallest number is &lt; 1e-4 or the ratio of the\nmaximum absolute value to the minimum is &gt; 1e3. The default is False.\n\nnanstrstr, optionalString representation of floating point not-a-number (default nan).\n\ninfstrstr, optionalString representation of floating point infinity (default inf).\n\nsignstring, either \u2018-\u2018, \u2018+\u2019, or \u2018 \u2018, optionalControls printing of the sign of floating-point types. If \u2018+\u2019, always\nprint the sign of positive values. If \u2018 \u2018, always prints a space\n(whitespace character) in the sign position of positive values.  If\n\u2018-\u2018, omit the sign character of positive values. (default \u2018-\u2018)\n\nformatterdict of callables, optionalIf not None, the keys should indicate the type(s) that the respective\nformatting function applies to.  Callables should return a string.\nTypes that are not specified (by their corresponding keys) are handled\nby the default formatters.  Individual types for which a formatter\ncan be set are:\n\n\u2018bool\u2019\n\u2018int\u2019\n\u2018timedelta\u2019 : a numpy.timedelta64\n\u2018datetime\u2019 : a numpy.datetime64\n\u2018float\u2019\n\u2018longfloat\u2019 : 128-bit floats\n\u2018complexfloat\u2019\n\u2018longcomplexfloat\u2019 : composed of two 128-bit floats\n\u2018numpystr\u2019 : types numpy.string_ and numpy.unicode_\n\u2018object\u2019 : np.object_ arrays\n\u2018str\u2019 : all other strings\n\nOther keys that can be used to set a group of types at once are:\n\n\u2018all\u2019 : sets all types\n\u2018int_kind\u2019 : sets \u2018int\u2019\n\u2018float_kind\u2019 : sets \u2018float\u2019 and \u2018longfloat\u2019\n\u2018complex_kind\u2019 : sets \u2018complexfloat\u2019 and \u2018longcomplexfloat\u2019\n\u2018str_kind\u2019 : sets \u2018str\u2019 and \u2018numpystr\u2019\n\n\nfloatmodestr, optionalControls the interpretation of the precision option for\nfloating-point types. Can take the following values\n(default maxprec_equal):\n\n\n\u2018fixed\u2019: Always print exactly precision fractional digits,even if this would print more or fewer digits than\nnecessary to specify the value uniquely.\n\n\n\n\n\u2018unique\u2019: Print the minimum number of fractional digits necessaryto represent each value uniquely. Different elements may\nhave a different number of digits. The value of the\nprecision option is ignored.\n\n\n\n\n\u2018maxprec\u2019: Print at most precision fractional digits, but ifan element can be uniquely represented with fewer digits\nonly print it with that many.\n\n\n\n\n\u2018maxprec_equal\u2019: Print at most precision fractional digits,but if every element in the array can be uniquely\nrepresented with an equal number of fewer digits, use that\nmany digits for all elements.\n\n\n\n\n\nlegacystring or False, optionalIf set to the string \u20181.13\u2019 enables 1.13 legacy printing mode. This\napproximates numpy 1.13 print output by including a space in the sign\nposition of floats and different behavior for 0d arrays. If set to\nFalse, disables legacy mode. Unrecognized strings will be ignored\nwith a warning for forward compatibility.\n\nNew in version 1.14.0.\n\n\n\n\n\n\nSee also\nget_printoptions, printoptions, set_string_function, array2string\n\nNotes\nformatter is always reset with a call to set_printoptions.\nUse printoptions as a context manager to set the values temporarily.\nExamples\nFloating point precision can be set:\n&gt;&gt;&gt; np.set_printoptions(precision=4)\n&gt;&gt;&gt; np.array([1.123456789])\n[1.1235]\n\n\nLong arrays can be summarised:\n&gt;&gt;&gt; np.set_printoptions(threshold=5)\n&gt;&gt;&gt; np.arange(10)\narray([0, 1, 2, ..., 7, 8, 9])\n\n\nSmall results can be suppressed:\n&gt;&gt;&gt; eps = np.finfo(float).eps\n&gt;&gt;&gt; x = np.arange(4.)\n&gt;&gt;&gt; x**2 - (x + eps)**2\narray([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n&gt;&gt;&gt; np.set_printoptions(suppress=True)\n&gt;&gt;&gt; x**2 - (x + eps)**2\narray([-0., -0.,  0.,  0.])\n\n\nA custom formatter can be used to display array elements as desired:\n&gt;&gt;&gt; np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n&gt;&gt;&gt; x = np.arange(3)\n&gt;&gt;&gt; x\narray([int: 0, int: -1, int: -2])\n&gt;&gt;&gt; np.set_printoptions()  # formatter gets reset\n&gt;&gt;&gt; x\narray([0, 1, 2])\n\n\nTo put back the default options, you can use:\n&gt;&gt;&gt; np.set_printoptions(edgeitems=3, infstr='inf',\n... linewidth=75, nanstr='nan', precision=8,\n... suppress=False, threshold=1000, formatter=None)\n\n\nAlso to temporarily override options, use printoptions as a context manager:\n&gt;&gt;&gt; with np.printoptions(precision=2, suppress=True, threshold=5):\n...     np.linspace(0, 10, 10)\narray([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])\n\n\n", "parameters": ["Parameters", "precisionint or None, optional", "thresholdint, optional", "edgeitemsint, optional", "linewidthint, optional", "suppressbool, optional", "nanstrstr, optional", "infstrstr, optional", "signstring, either \u2018-\u2018, \u2018+\u2019, or \u2018 \u2018, optional", "formatterdict of callables, optional", "floatmodestr, optional", "\u2018fixed\u2019: Always print exactly precision fractional digits,", "\u2018unique\u2019: Print the minimum number of fractional digits necessary", "\u2018maxprec\u2019: Print at most precision fractional digits, but if", "\u2018maxprec_equal\u2019: Print at most precision fractional digits,", "legacystring or False, optional"], "returns": [], "examples": ["; np.set_printoptions(precision=4)\n; np.array([1.123456789])\n[1.1235]\n\n", "; np.set_printoptions(precision=4)\n; np.array([1.123456789])\n[1.1235]\n", "; np.set_printoptions(threshold=5)\n; np.arange(10)\narray([0, 1, 2, ..., 7, 8, 9])\n\n", "; np.set_printoptions(threshold=5)\n; np.arange(10)\narray([0, 1, 2, ..., 7, 8, 9])\n", "; eps = np.finfo(float).eps\n; x = np.arange(4.)\n; x**2 - (x + eps)**2\narray([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n; np.set_printoptions(suppress=True)\n; x**2 - (x + eps)**2\narray([-0., -0.,  0.,  0.])\n\n", "; eps = np.finfo(float).eps\n; x = np.arange(4.)\n; x**2 - (x + eps)**2\narray([-4.9304e-32, -4.4409e-16,  0.0000e+00,  0.0000e+00])\n; np.set_printoptions(suppress=True)\n; x**2 - (x + eps)**2\narray([-0., -0.,  0.,  0.])\n", "; np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n; x = np.arange(3)\n; x\narray([int: 0, int: -1, int: -2])\n; np.set_printoptions()  # formatter gets reset\n; x\narray([0, 1, 2])\n\n", "; np.set_printoptions(formatter={'all':lambda x: 'int: '+str(-x)})\n; x = np.arange(3)\n; x\narray([int: 0, int: -1, int: -2])\n; np.set_printoptions()  # formatter gets reset\n; x\narray([0, 1, 2])\n", "; np.set_printoptions(edgeitems=3, infstr='inf',\n... linewidth=75, nanstr='nan', precision=8,\n... suppress=False, threshold=1000, formatter=None)\n\n", "; np.set_printoptions(edgeitems=3, infstr='inf',\n... linewidth=75, nanstr='nan', precision=8,\n... suppress=False, threshold=1000, formatter=None)\n", "; with np.printoptions(precision=2, suppress=True, threshold=5):\n...     np.linspace(0, 10, 10)\narray([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])\n\n", "; with np.printoptions(precision=2, suppress=True, threshold=5):\n...     np.linspace(0, 10, 10)\narray([ 0.  ,  1.11,  2.22, ...,  7.78,  8.89, 10.  ])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.set_fill_value", "code": "\nMaskedArray.set_fill_value(self, value=None)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.set_fill_value", "code": "\nmasked_array.set_fill_value(self, value=None)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.set_fill_value", "code": "\nnumpy.ma.set_fill_value(a, fill_value)[source]\u00b6", "description": "Set the filling value of a, if a is a masked array.\nThis function changes the fill value of the masked array a in place.\nIf a is not a masked array, the function returns silently, without\ndoing anything.\n\nParameters\n\naarray_likeInput array.\n\nfill_valuedtypeFilling value. A consistency test is performed to make sure\nthe value is compatible with the dtype of a.\n\n\n\nReturns\n\nNoneNothing returned by this function.\n\n\n\n\n\nSee also\n\nmaximum_fill_valueReturn the default fill value for a dtype.\n\nMaskedArray.fill_valueReturn current fill value.\n\nMaskedArray.set_fill_valueEquivalent method.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4])\n&gt;&gt;&gt; a = ma.masked_where(a &lt; 3, a)\n&gt;&gt;&gt; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; ma.set_fill_value(a, -999)\n&gt;&gt;&gt; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=-999)\n\n\nNothing happens if a is not a masked array.\n&gt;&gt;&gt; a = list(range(5))\n&gt;&gt;&gt; a\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; ma.set_fill_value(a, 100)\n&gt;&gt;&gt; a\n[0, 1, 2, 3, 4]\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4])\n&gt;&gt;&gt; ma.set_fill_value(a, 100)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "aarray_like", "fill_valuedtype", "Returns", "None"], "returns": "NoneNothing returned by this function.", "examples": ["; import numpy.ma as ma\n; a = np.arange(5)\n; a\narray([0, 1, 2, 3, 4])\n; a = ma.masked_where(a &lt; 3, a)\n; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=999999)\n; ma.set_fill_value(a, -999)\n; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=-999)\n\n", "; import numpy.ma as ma\n; a = np.arange(5)\n; a\narray([0, 1, 2, 3, 4])\n; a = ma.masked_where(a &lt; 3, a)\n; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=999999)\n; ma.set_fill_value(a, -999)\n; a\nmasked_array(data=[--, --, --, 3, 4],\n             mask=[ True,  True,  True, False, False],\n       fill_value=-999)\n", "; a = list(range(5))\n; a\n[0, 1, 2, 3, 4]\n; ma.set_fill_value(a, 100)\n; a\n[0, 1, 2, 3, 4]\n; a = np.arange(5)\n; a\narray([0, 1, 2, 3, 4])\n; ma.set_fill_value(a, 100)\n; a\narray([0, 1, 2, 3, 4])\n\n", "; a = list(range(5))\n; a\n[0, 1, 2, 3, 4]\n; ma.set_fill_value(a, 100)\n; a\n[0, 1, 2, 3, 4]\n; a = np.arange(5)\n; a\narray([0, 1, 2, 3, 4])\n; ma.set_fill_value(a, 100)\n; a\narray([0, 1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.select", "code": "\nnumpy.select(condlist, choicelist, default=0)[source]\u00b6", "description": "Return an array drawn from elements in choicelist, depending on conditions.\n\nParameters\n\ncondlistlist of bool ndarraysThe list of conditions which determine from which array in choicelist\nthe output elements are taken. When multiple conditions are satisfied,\nthe first one encountered in condlist is used.\n\nchoicelistlist of ndarraysThe list of arrays from which the output elements are taken. It has\nto be of the same length as condlist.\n\ndefaultscalar, optionalThe element inserted in output when all conditions evaluate to False.\n\n\n\nReturns\n\noutputndarrayThe output at position m is the m-th element of the array in\nchoicelist where the m-th element of the corresponding array in\ncondlist is True.\n\n\n\n\n\nSee also\n\nwhereReturn elements from one of two arrays depending on condition.\n\n\ntake, choose, compress, diag, diagonal\n\nExamples\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; condlist = [x&lt;3, x&gt;5]\n&gt;&gt;&gt; choicelist = [x, x**2]\n&gt;&gt;&gt; np.select(condlist, choicelist)\narray([ 0,  1,  2, ..., 49, 64, 81])\n\n\n", "parameters": ["Parameters", "condlistlist of bool ndarrays", "choicelistlist of ndarrays", "defaultscalar, optional", "Returns", "outputndarray"], "returns": "outputndarrayThe output at position m is the m-th element of the array inchoicelist where the m-th element of the corresponding array incondlist is True.", "examples": ["; x = np.arange(10)\n; condlist = [x&lt;3, x&gt;5]\n; choicelist = [x, x**2]\n; np.select(condlist, choicelist)\narray([ 0,  1,  2, ..., 49, 64, 81])\n\n", "; x = np.arange(10)\n; condlist = [x&lt;3, x&gt;5]\n; choicelist = [x, x**2]\n; np.select(condlist, choicelist)\narray([ 0,  1,  2, ..., 49, 64, 81])\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence", "code": "\nclass numpy.random.SeedSequence(entropy=None, *, spawn_key=(), pool_size=4)\u00b6", "description": "SeedSequence mixes sources of entropy in a reproducible way to set the\ninitial state for independent and very probably non-overlapping\nBitGenerators.\nOnce the SeedSequence is instantiated, you can call the generate_state\nmethod to get an appropriately sized seed. Calling spawn(n) will\ncreate n SeedSequences that can be used to seed independent\nBitGenerators, i.e. for different threads.\n\nParameters\n\nentropy{None, int, sequence[int]}, optionalThe entropy for creating a SeedSequence.\n\nspawn_key{(), sequence[int]}, optionalA third source of entropy, used internally when calling\nSeedSequence.spawn\n\npool_size{int}, optionalSize of the pooled entropy to store. Default is 4 to give a 128-bit\nentropy pool. 8 (for 256 bits) is another reasonable choice if working\nwith larger PRNGs, but there is very little to be gained by selecting\nanother value.\n\nn_children_spawned{int}, optionalThe number of children already spawned. Only pass this if\nreconstructing a SeedSequence from a serialized form.\n\n\n\n\nNotes\nBest practice for achieving reproducible bit streams is to use\nthe default None for the initial entropy, and then use\nSeedSequence.entropy to log/pickle the entropy for reproducibility:\n&gt;&gt;&gt; sq1 = np.random.SeedSequence()\n&gt;&gt;&gt; sq1.entropy\n243799254704924441050048792905230269161  # random\n&gt;&gt;&gt; sq2 = np.random.SeedSequence(sq1.entropy)\n&gt;&gt;&gt; np.all(sq1.generate_state(10) == sq2.generate_state(10))\nTrue\n\n\n\nAttributes\n\nentropy\nn_children_spawned\npool\npool_size\nspawn_key\nstate\n\n\n\nMethods\n\n\n\n\n\n\ngenerate_state(n_words[,\u00a0dtype])\nReturn the requested number of words for PRNG seeding.\n\nspawn(n_children)\nSpawn a number of child SeedSequence s by extending the spawn_key.\n\n\n\n", "parameters": ["Parameters", "entropy{None, int, sequence[int]}, optional", "spawn_key{(), sequence[int]}, optional", "pool_size{int}, optional", "n_children_spawned{int}, optional", "Attributes", "entropy", "n_children_spawned", "pool", "pool_size", "spawn_key", "state"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.seed", "code": "\nRandomState.seed(self, seed=None)\u00b6", "description": "Reseed a legacy MT19937 BitGenerator\nNotes\nThis is a convenience, legacy function.\nThe best practice is to not reseed a BitGenerator, rather to\nrecreate a new one. This method is here for legacy reasons.\nThis example demonstrates best practice.\n&gt;&gt;&gt; from numpy.random import MT19937\n&gt;&gt;&gt; from numpy.random import RandomState, SeedSequence\n&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(123456789)))\n# Later, you want to restart the stream\n&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(987654321)))\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.seed", "code": "\nnumpy.random.seed(self, seed=None)\u00b6", "description": "Reseed a legacy MT19937 BitGenerator\nNotes\nThis is a convenience, legacy function.\nThe best practice is to not reseed a BitGenerator, rather to\nrecreate a new one. This method is here for legacy reasons.\nThis example demonstrates best practice.\n&gt;&gt;&gt; from numpy.random import MT19937\n&gt;&gt;&gt; from numpy.random import RandomState, SeedSequence\n&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(123456789)))\n# Later, you want to restart the stream\n&gt;&gt;&gt; rs = RandomState(MT19937(SeedSequence(987654321)))\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.searchsorted", "code": "\nmemmap.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.searchsorted", "code": "\nmatrix.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.searchsorted", "code": "\nMaskType.searchsorted()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.searchsorted", "code": "\nMaskedArray.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.searchsorted", "code": "\nmasked_array.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.searchsorted", "code": "\ngeneric.searchsorted()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.searchsorted", "code": "\nchararray.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.searchsorted", "code": "\nchararray.searchsorted(v, side='left', sorter=None)\u00b6", "description": "Find indices where elements of v should be inserted in a to maintain order.\nFor full documentation, see numpy.searchsorted\n\nSee also\n\nnumpy.searchsortedequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.searchsorted", "code": "\nnumpy.searchsorted(a, v, side='left', sorter=None)[source]\u00b6", "description": "Find indices where elements should be inserted to maintain order.\nFind the indices into a sorted array a such that, if the\ncorresponding elements in v were inserted before the indices, the\norder of a would be preserved.\nAssuming that a is sorted:\n\n\n\n\n\n\nside\nreturned index i satisfies\n\n\n\nleft\na[i-1] &lt; v &lt;= a[i]\n\nright\na[i-1] &lt;= v &lt; a[i]\n\n\n\n\nParameters\n\na1-D array_likeInput array. If sorter is None, then it must be sorted in\nascending order, otherwise sorter must be an array of indices\nthat sort it.\n\nvarray_likeValues to insert into a.\n\nside{\u2018left\u2019, \u2018right\u2019}, optionalIf \u2018left\u2019, the index of the first suitable location found is given.\nIf \u2018right\u2019, return the last such index.  If there is no suitable\nindex, return either 0 or N (where N is the length of a).\n\nsorter1-D array_like, optionalOptional array of integer indices that sort array a into ascending\norder. They are typically the result of argsort.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nindicesarray of intsArray of insertion points with the same shape as v.\n\n\n\n\n\nSee also\n\nsortReturn a sorted copy of an array.\n\nhistogramProduce histogram from 1-D data.\n\n\n\nNotes\nBinary search is used to find the required insertion points.\nAs of NumPy 1.4.0 searchsorted works with real/complex arrays containing\nnan values. The enhanced sort order is documented in sort.\nThis function uses the same algorithm as the builtin python bisect.bisect_left\n(side='left') and bisect.bisect_right (side='right') functions,\nwhich is also vectorized in the v argument.\nExamples\n&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3)\n2\n&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], 3, side='right')\n3\n&gt;&gt;&gt; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\narray([0, 5, 1, 2])\n\n\n", "parameters": ["Parameters", "a1-D array_like", "varray_like", "side{\u2018left\u2019, \u2018right\u2019}, optional", "sorter1-D array_like, optional", "Returns", "indicesarray of ints"], "returns": "indicesarray of intsArray of insertion points with the same shape as v.", "examples": ["; np.searchsorted([1,2,3,4,5], 3)\n2\n; np.searchsorted([1,2,3,4,5], 3, side='right')\n3\n; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\narray([0, 5, 1, 2])\n\n", "; np.searchsorted([1,2,3,4,5], 3)\n2\n; np.searchsorted([1,2,3,4,5], 3, side='right')\n3\n; np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])\narray([0, 5, 1, 2])\n"]},
{"library": "numpy", "item_id": "numpy.sctype2char", "code": "\nnumpy.sctype2char(sctype)[source]\u00b6", "description": "Return the string representation of a scalar dtype.\n\nParameters\n\nsctypescalar dtype or objectIf a scalar dtype, the corresponding string character is\nreturned. If an object, sctype2char tries to infer its scalar type\nand then return the corresponding string character.\n\n\n\nReturns\n\ntypecharstrThe string character corresponding to the scalar type.\n\n\n\nRaises\n\nValueErrorIf sctype is an object for which the type can not be inferred.\n\n\n\n\n\nSee also\nobj2sctype, issctype, issubsctype, mintypecode\n\nExamples\n&gt;&gt;&gt; for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:\n...     print(np.sctype2char(sctype))\nl # may vary\nd\nD\nS\nO\n\n\n&gt;&gt;&gt; x = np.array([1., 2-1.j])\n&gt;&gt;&gt; np.sctype2char(x)\n'D'\n&gt;&gt;&gt; np.sctype2char(list)\n'O'\n\n\n", "parameters": ["Parameters", "sctypescalar dtype or object", "Returns", "typecharstr", "Raises", "ValueError"], "returns": "typecharstrThe string character corresponding to the scalar type.", "examples": ["; for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:\n...     print(np.sctype2char(sctype))\nl # may vary\nd\nD\nS\nO\n\n", "; for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:\n...     print(np.sctype2char(sctype))\nl # may vary\nd\nD\nS\nO\n", "; x = np.array([1., 2-1.j])\n; np.sctype2char(x)\n'D'\n; np.sctype2char(list)\n'O'\n\n", "; x = np.array([1., 2-1.j])\n; np.sctype2char(x)\n'D'\n; np.sctype2char(list)\n'O'\n"]},
{"library": "numpy", "item_id": "numpy.savez_compressed", "code": "\nnumpy.savez_compressed(file, *args, **kwds)[source]\u00b6", "description": "Save several arrays into a single file in compressed .npz format.\nIf keyword arguments are given, then filenames are taken from the keywords.\nIf arguments are passed in with no keywords, then stored filenames are\narr_0, arr_1, etc.\n\nParameters\n\nfilestr or fileEither the filename (string) or an open file (file-like object)\nwhere the data will be saved. If file is a string or a Path, the\n.npz extension will be appended to the filename if it is not\nalready there.\n\nargsArguments, optionalArrays to save to the file. Since it is not possible for Python to\nknow the names of the arrays outside savez, the arrays will be saved\nwith names \u201carr_0\u201d, \u201carr_1\u201d, and so on. These arguments can be any\nexpression.\n\nkwdsKeyword arguments, optionalArrays to save to the file. Arrays will be saved in the file with the\nkeyword names.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\n\nnumpy.saveSave a single array to a binary file in NumPy format.\n\nnumpy.savetxtSave an array to a file as plain text.\n\nnumpy.savezSave several arrays into an uncompressed .npz file format\n\nnumpy.loadLoad the files created by savez_compressed.\n\n\n\nNotes\nThe .npz file format is a zipped archive of files named after the\nvariables they contain.  The archive is compressed with\nzipfile.ZIP_DEFLATED and each file in the archive contains one variable\nin .npy format. For a description of the .npy format, see \nnumpy.lib.format.\nWhen opening the saved .npz file with load a NpzFile object is\nreturned. This is a dictionary-like object which can be queried for\nits list of arrays (with the .files attribute), and for the arrays\nthemselves.\nExamples\n&gt;&gt;&gt; test_array = np.random.rand(3, 2)\n&gt;&gt;&gt; test_vector = np.random.rand(4)\n&gt;&gt;&gt; np.savez_compressed('/tmp/123', a=test_array, b=test_vector)\n&gt;&gt;&gt; loaded = np.load('/tmp/123.npz')\n&gt;&gt;&gt; print(np.array_equal(test_array, loaded['a']))\nTrue\n&gt;&gt;&gt; print(np.array_equal(test_vector, loaded['b']))\nTrue\n\n\n", "parameters": ["Parameters", "filestr or file", "argsArguments, optional", "kwdsKeyword arguments, optional", "Returns", "None"], "returns": "None", "examples": ["; test_array = np.random.rand(3, 2)\n; test_vector = np.random.rand(4)\n; np.savez_compressed('/tmp/123', a=test_array, b=test_vector)\n; loaded = np.load('/tmp/123.npz')\n; print(np.array_equal(test_array, loaded['a']))\nTrue\n; print(np.array_equal(test_vector, loaded['b']))\nTrue\n\n", "; test_array = np.random.rand(3, 2)\n; test_vector = np.random.rand(4)\n; np.savez_compressed('/tmp/123', a=test_array, b=test_vector)\n; loaded = np.load('/tmp/123.npz')\n; print(np.array_equal(test_array, loaded['a']))\nTrue\n; print(np.array_equal(test_vector, loaded['b']))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.savez", "code": "\nnumpy.savez(file, *args, **kwds)[source]\u00b6", "description": "Save several arrays into a single file in uncompressed .npz format.\nIf arguments are passed in with no keywords, the corresponding variable\nnames, in the .npz file, are \u2018arr_0\u2019, \u2018arr_1\u2019, etc. If keyword\narguments are given, the corresponding variable names, in the .npz\nfile will match the keyword names.\n\nParameters\n\nfilestr or fileEither the filename (string) or an open file (file-like object)\nwhere the data will be saved. If file is a string or a Path, the\n.npz extension will be appended to the filename if it is not\nalready there.\n\nargsArguments, optionalArrays to save to the file. Since it is not possible for Python to\nknow the names of the arrays outside savez, the arrays will be saved\nwith names \u201carr_0\u201d, \u201carr_1\u201d, and so on. These arguments can be any\nexpression.\n\nkwdsKeyword arguments, optionalArrays to save to the file. Arrays will be saved in the file with the\nkeyword names.\n\n\n\nReturns\n\nNone\n\n\n\n\nSee also\n\nsaveSave a single array to a binary file in NumPy format.\n\nsavetxtSave an array to a file as plain text.\n\nsavez_compressedSave several arrays into a compressed .npz archive\n\n\n\nNotes\nThe .npz file format is a zipped archive of files named after the\nvariables they contain.  The archive is not compressed and each file\nin the archive contains one variable in .npy format. For a\ndescription of the .npy format, see numpy.lib.format.\nWhen opening the saved .npz file with load a NpzFile object is\nreturned. This is a dictionary-like object which can be queried for\nits list of arrays (with the .files attribute), and for the arrays\nthemselves.\nWhen saving dictionaries, the dictionary keys become filenames\ninside the ZIP archive. Therefore, keys should be valid filenames.\nE.g., avoid keys that begin with / or contain ..\nExamples\n&gt;&gt;&gt; from tempfile import TemporaryFile\n&gt;&gt;&gt; outfile = TemporaryFile()\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = np.sin(x)\n\n\nUsing savez with *args, the arrays are saved with default names.\n&gt;&gt;&gt; np.savez(outfile, x, y)\n&gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n&gt;&gt;&gt; npzfile = np.load(outfile)\n&gt;&gt;&gt; npzfile.files\n['arr_0', 'arr_1']\n&gt;&gt;&gt; npzfile['arr_0']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\nUsing savez with **kwds, the arrays are saved with the keyword names.\n&gt;&gt;&gt; outfile = TemporaryFile()\n&gt;&gt;&gt; np.savez(outfile, x=x, y=y)\n&gt;&gt;&gt; _ = outfile.seek(0)\n&gt;&gt;&gt; npzfile = np.load(outfile)\n&gt;&gt;&gt; sorted(npzfile.files)\n['x', 'y']\n&gt;&gt;&gt; npzfile['x']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n", "parameters": ["Parameters", "filestr or file", "argsArguments, optional", "kwdsKeyword arguments, optional", "Returns", "None"], "returns": "None", "examples": ["; from tempfile import TemporaryFile\n; outfile = TemporaryFile()\n; x = np.arange(10)\n; y = np.sin(x)\n\n", "; from tempfile import TemporaryFile\n; outfile = TemporaryFile()\n; x = np.arange(10)\n; y = np.sin(x)\n", "; np.savez(outfile, x, y)\n; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n; npzfile = np.load(outfile)\n; npzfile.files\n['arr_0', 'arr_1']\n; npzfile['arr_0']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n", "; np.savez(outfile, x, y)\n; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n; npzfile = np.load(outfile)\n; npzfile.files\n['arr_0', 'arr_1']\n; npzfile['arr_0']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n", "; outfile = TemporaryFile()\n; np.savez(outfile, x=x, y=y)\n; _ = outfile.seek(0)\n; npzfile = np.load(outfile)\n; sorted(npzfile.files)\n['x', 'y']\n; npzfile['x']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n", "; outfile = TemporaryFile()\n; np.savez(outfile, x=x, y=y)\n; _ = outfile.seek(0)\n; npzfile = np.load(outfile)\n; sorted(npzfile.files)\n['x', 'y']\n; npzfile['x']\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n"]},
{"library": "numpy", "item_id": "numpy.savetxt", "code": "\nnumpy.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='n', header='', footer='', comments='# ', encoding=None)[source]\u00b6", "description": "Save an array to a text file.\n\nParameters\n\nfnamefilename or file handleIf the filename ends in .gz, the file is automatically saved in\ncompressed gzip format.  loadtxt understands gzipped files\ntransparently.\n\nX1D or 2D array_likeData to be saved to a text file.\n\nfmtstr or sequence of strs, optionalA single format (%10.5f), a sequence of formats, or a\nmulti-format string, e.g. \u2018Iteration %d \u2013 %10.5f\u2019, in which\ncase delimiter is ignored. For complex X, the legal options\nfor fmt are:\n\na single specifier, fmt=\u2019%.4e\u2019, resulting in numbers formatted\nlike \u2018 (%s+%sj)\u2019 % (fmt, fmt)\na full string specifying every real and imaginary part, e.g.\n\u2018 %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej\u2019 for 3 columns\na list of specifiers, one per column - in this case, the real\nand imaginary part must have separate specifiers,\ne.g. [\u2018%.3e + %.3ej\u2019, \u2018(%.15e%+.15ej)\u2019] for 2 columns\n\n\ndelimiterstr, optionalString or character separating columns.\n\nnewlinestr, optionalString or character separating lines.\n\nNew in version 1.5.0.\n\n\nheaderstr, optionalString that will be written at the beginning of the file.\n\nNew in version 1.7.0.\n\n\nfooterstr, optionalString that will be written at the end of the file.\n\nNew in version 1.7.0.\n\n\ncommentsstr, optionalString that will be prepended to the header and footer strings,\nto mark them as comments. Default: \u2018# \u2018,  as expected by e.g.\nnumpy.loadtxt.\n\nNew in version 1.7.0.\n\n\nencoding{None, str}, optionalEncoding used to encode the outputfile. Does not apply to output\nstreams. If the encoding is something other than \u2018bytes\u2019 or \u2018latin1\u2019\nyou will not be able to load the file in NumPy versions &lt; 1.14. Default\nis \u2018latin1\u2019.\n\nNew in version 1.14.0.\n\n\n\n\n\n\nSee also\n\nsaveSave an array to a binary file in NumPy .npy format\n\nsavezSave several arrays into an uncompressed .npz archive\n\nsavez_compressedSave several arrays into a compressed .npz archive\n\n\n\nNotes\nFurther explanation of the fmt parameter\n(%[flag]width[.precision]specifier):\n\nflags:- : left justify\n+ : Forces to precede result with + or -.\n0 : Left pad the number with zeros instead of space (see width).\n\nwidth:Minimum number of characters to be printed. The value is not truncated\nif it has more characters.\n\nprecision:\nFor integer specifiers (eg. d,i,o,x), the minimum number of\ndigits.\nFor e, E and f specifiers, the number of digits to print\nafter the decimal point.\nFor g and G, the maximum number of significant digits.\nFor s, the maximum number of characters.\n\n\nspecifiers:c : character\nd or i : signed decimal integer\ne or E : scientific notation with e or E.\nf : decimal floating point\ng,G : use the shorter of e,E or f\no : signed octal\ns : string of characters\nu : unsigned decimal integer\nx,X : unsigned hexadecimal integer\n\n\nThis explanation of fmt is not complete, for an exhaustive\nspecification see [1].\nReferences\n\n1\nFormat Specification Mini-Language,\nPython Documentation.\n\n\nExamples\n&gt;&gt;&gt; x = y = z = np.arange(0.0,5.0,1.0)\n&gt;&gt;&gt; np.savetxt('test.out', x, delimiter=',')   # X is an array\n&gt;&gt;&gt; np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n&gt;&gt;&gt; np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n\n", "parameters": ["Parameters", "fnamefilename or file handle", "X1D or 2D array_like", "fmtstr or sequence of strs, optional", "delimiterstr, optional", "newlinestr, optional", "headerstr, optional", "footerstr, optional", "commentsstr, optional", "encoding{None, str}, optional"], "returns": [], "examples": ["; x = y = z = np.arange(0.0,5.0,1.0)\n; np.savetxt('test.out', x, delimiter=',')   # X is an array\n; np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n; np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n\n", "; x = y = z = np.arange(0.0,5.0,1.0)\n; np.savetxt('test.out', x, delimiter=',')   # X is an array\n; np.savetxt('test.out', (x,y,z))   # x,y,z equal sized 1D arrays\n; np.savetxt('test.out', x, fmt='%1.4e')   # use exponential notation\n"]},
{"library": "numpy", "item_id": "numpy.random.sample", "code": "\nnumpy.random.sample()\u00b6", "description": "This is an alias of random_sample. See random_sample  for the complete\ndocumentation.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.save", "code": "\nnumpy.save(file, arr, allow_pickle=True, fix_imports=True)[source]\u00b6", "description": "Save an array to a binary file in NumPy .npy format.\n\nParameters\n\nfilefile, str, or pathlib.PathFile or filename to which the data is saved.  If file is a file-object,\nthen the filename is unchanged.  If file is a string or Path, a .npy\nextension will be appended to the filename if it does not already\nhave one.\n\narrarray_likeArray data to be saved.\n\nallow_picklebool, optionalAllow saving object arrays using Python pickles. Reasons for disallowing\npickles include security (loading pickled data can execute arbitrary\ncode) and portability (pickled objects may not be loadable on different\nPython installations, for example if the stored objects require libraries\nthat are not available, and not all pickled data is compatible between\nPython 2 and Python 3).\nDefault: True\n\nfix_importsbool, optionalOnly useful in forcing objects in object arrays on Python 3 to be\npickled in a Python 2 compatible way. If fix_imports is True, pickle\nwill try to map the new Python 3 names to the old module names used in\nPython 2, so that the pickle data stream is readable with Python 2.\n\n\n\n\n\nSee also\n\nsavezSave several arrays into a .npz archive\n\n\nsavetxt, load\n\nNotes\nFor a description of the .npy format, see numpy.lib.format.\nAny data saved to the file is appended to the end of the file.\nExamples\n&gt;&gt;&gt; from tempfile import TemporaryFile\n&gt;&gt;&gt; outfile = TemporaryFile()\n\n\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; np.save(outfile, x)\n\n\n&gt;&gt;&gt; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n&gt;&gt;&gt; np.load(outfile)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\n&gt;&gt;&gt; with open('test.npy', 'wb') as f:\n...     np.save(f, np.array([1, 2]))\n...     np.save(f, np.array([1, 3]))\n&gt;&gt;&gt; with open('test.npy', 'rb') as f:\n...     a = np.load(f)\n...     b = np.load(f)\n&gt;&gt;&gt; print(a, b)\n# [1 2] [1 3]\n\n\n", "parameters": ["Parameters", "filefile, str, or pathlib.Path", "arrarray_like", "allow_picklebool, optional", "fix_importsbool, optional"], "returns": [], "examples": ["; from tempfile import TemporaryFile\n; outfile = TemporaryFile()\n\n", "; from tempfile import TemporaryFile\n; outfile = TemporaryFile()\n", "; x = np.arange(10)\n; np.save(outfile, x)\n\n", "; x = np.arange(10)\n; np.save(outfile, x)\n", "; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n; np.load(outfile)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n", "; _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file\n; np.load(outfile)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n", "; with open('test.npy', 'wb') as f:\n...     np.save(f, np.array([1, 2]))\n...     np.save(f, np.array([1, 3]))\n; with open('test.npy', 'rb') as f:\n...     a = np.load(f)\n...     b = np.load(f)\n; print(a, b)\n# [1 2] [1 3]\n\n", "; with open('test.npy', 'wb') as f:\n...     np.save(f, np.array([1, 2]))\n...     np.save(f, np.array([1, 3]))\n; with open('test.npy', 'rb') as f:\n...     a = np.load(f)\n...     b = np.load(f)\n; print(a, b)\n# [1 2] [1 3]\n"]},
{"library": "numpy", "item_id": "numpy.s_", "code": "\nnumpy.s_ = &lt;numpy.lib.index_tricks.IndexExpression object&gt;\u00b6", "description": "A nicer way to build up index tuples for arrays.\n\nNote\nUse one of the two predefined instances index_exp or s_\nrather than directly using IndexExpression.\n\nFor any index combination, including slicing and axis insertion,\na[indices] is the same as a[np.index_exp[indices]] for any\narray a. However, np.index_exp[indices] can be used anywhere\nin Python code and returns a tuple of slice objects that can be\nused in the construction of complex index expressions.\n\nParameters\n\nmaketupleboolIf True, always returns a tuple.\n\n\n\n\n\nSee also\n\nindex_expPredefined instance that always returns a tuple: index_exp = IndexExpression(maketuple=True).\n\ns_Predefined instance without tuple conversion: s_ = IndexExpression(maketuple=False).\n\n\n\nNotes\nYou can do all this with slice() plus a few special objects,\nbut there\u2019s a lot to remember and this version is simpler because\nit uses the standard array indexing syntax.\nExamples\n&gt;&gt;&gt; np.s_[2::2]\nslice(2, None, 2)\n&gt;&gt;&gt; np.index_exp[2::2]\n(slice(2, None, 2),)\n\n\n&gt;&gt;&gt; np.array([0, 1, 2, 3, 4])[np.s_[2::2]]\narray([2, 4])\n\n\n", "parameters": ["Parameters", "maketuplebool"], "returns": [], "examples": ["; np.s_[2::2]\nslice(2, None, 2)\n; np.index_exp[2::2]\n(slice(2, None, 2),)\n\n", "; np.s_[2::2]\nslice(2, None, 2)\n; np.index_exp[2::2]\n(slice(2, None, 2),)\n", "; np.array([0, 1, 2, 3, 4])[np.s_[2::2]]\narray([2, 4])\n\n", "; np.array([0, 1, 2, 3, 4])[np.s_[2::2]]\narray([2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.testing.rundocs", "code": "\nnumpy.testing.rundocs(filename=None, raise_on_error=True)[source]\u00b6", "description": "Run doctests found in the given file.\nBy default rundocs raises an AssertionError on failure.\n\nParameters\n\nfilenamestrThe path to the file for which the doctests are run.\n\nraise_on_errorboolWhether to raise an AssertionError when a doctest fails. Default is\nTrue.\n\n\n\n\nNotes\nThe doctests can be run by the user/developer by adding the doctests\nargument to the test() call. For example, to run all tests (including\ndoctests) for numpy.lib:\n&gt;&gt;&gt; np.lib.test(doctests=True)  \n\n\n", "parameters": ["Parameters", "filenamestr", "raise_on_errorbool"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.run_module_suite", "code": "\nnumpy.testing.run_module_suite(file_to_run=None, argv=None)[source]\u00b6", "description": "Run a test module.\nEquivalent to calling $ nosetests &lt;argv&gt; &lt;file_to_run&gt; from\nthe command line\n\nParameters\n\nfile_to_runstr, optionalPath to test module, or None.\nBy default, run the module from which this function is called.\n\nargvlist of stringsArguments to be passed to the nose test runner. argv[0] is\nignored. All command line arguments accepted by nosetests\nwill work. If it is the default value None, sys.argv is used.\n\nNew in version 1.9.0.\n\n\n\n\n\nExamples\nAdding the following:\nif __name__ == \"__main__\" :\n    run_module_suite(argv=sys.argv)\n\n\nat the end of a test module will run the tests when that module is\ncalled in the python interpreter.\nAlternatively, calling:\n&gt;&gt;&gt; run_module_suite(file_to_run=\"numpy/tests/test_matlib.py\")  \n\n\nfrom an interpreter will run all the test routine in \u2018test_matlib.py\u2019.\n", "parameters": ["Parameters", "file_to_runstr, optional", "argvlist of strings"], "returns": [], "examples": ["; run_module_suite(file_to_run=\"numpy/tests/test_matlib.py\")  \n\n", "; run_module_suite(file_to_run=\"numpy/tests/test_matlib.py\")  \n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.rstrip", "code": "\nchararray.rstrip(self, chars=None)\u00b6", "description": "For each element in self, return a copy with the trailing\ncharacters removed.\n\nSee also\nchar.rstrip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.rstrip", "code": "\nnumpy.char.rstrip(a, chars=None)\u00b6", "description": "For each element in a, return a copy with the trailing\ncharacters removed.\nCalls str.rstrip element-wise.\n\nParameters\n\naarray-like of str or unicode\ncharsstr or unicode, optionalThe chars argument is a string specifying the set of\ncharacters to be removed. If omitted or None, the chars\nargument defaults to removing whitespace. The chars argument\nis not a suffix; rather, all combinations of its values are\nstripped.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.rstrip\n\nExamples\n&gt;&gt;&gt; c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c\narray(['aAaAaA', 'abBABba'],\n    dtype='|S7')\n&gt;&gt;&gt; np.char.rstrip(c, b'a')\narray(['aAaAaA', 'abBABb'],\n    dtype='|S7')\n&gt;&gt;&gt; np.char.rstrip(c, b'A')\narray(['aAaAa', 'abBABba'],\n    dtype='|S7')\n\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "charsstr or unicode, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": ["; c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c\narray(['aAaAaA', 'abBABba'],\n    dtype='|S7')\n; np.char.rstrip(c, b'a')\narray(['aAaAaA', 'abBABb'],\n    dtype='|S7')\n; np.char.rstrip(c, b'A')\narray(['aAaAa', 'abBABba'],\n    dtype='|S7')\n\n", "; c = np.array(['aAaAaA', 'abBABba'], dtype='S7'); c\narray(['aAaAaA', 'abBABba'],\n    dtype='|S7')\n; np.char.rstrip(c, b'a')\narray(['aAaAaA', 'abBABb'],\n    dtype='|S7')\n; np.char.rstrip(c, b'A')\narray(['aAaAa', 'abBABba'],\n    dtype='|S7')\n"]},
{"library": "numpy", "item_id": "numpy.chararray.rstrip", "code": "\nchararray.rstrip(self, chars=None)[source]\u00b6", "description": "For each element in self, return a copy with the trailing\ncharacters removed.\n\nSee also\nchar.rstrip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.rsplit", "code": "\nchararray.rsplit(self, sep=None, maxsplit=None)\u00b6", "description": "For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.\n\nSee also\nchar.rsplit\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.rsplit", "code": "\nchararray.rsplit(self, sep=None, maxsplit=None)[source]\u00b6", "description": "For each element in self, return a list of the words in\nthe string, using sep as the delimiter string.\n\nSee also\nchar.rsplit\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.rsplit", "code": "\nnumpy.char.rsplit(a, sep=None, maxsplit=None)\u00b6", "description": "For each element in a, return a list of the words in the\nstring, using sep as the delimiter string.\nCalls str.rsplit element-wise.\nExcept for splitting from the right, rsplit\nbehaves like split.\n\nParameters\n\naarray_like of str or unicode\nsepstr or unicode, optionalIf sep is not specified or None, any whitespace string\nis a separator.\n\nmaxsplitint, optionalIf maxsplit is given, at most maxsplit splits are done,\nthe rightmost ones.\n\n\n\nReturns\n\noutndarrayArray of list objects\n\n\n\n\n\nSee also\nstr.rsplit, split\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "sepstr or unicode, optional", "maxsplitint, optional", "Returns", "outndarray"], "returns": "outndarrayArray of list objects", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.rpartition", "code": "\nchararray.rpartition(self, sep)[source]\u00b6", "description": "Partition each element in self around sep.\n\nSee also\nrpartition\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.rpartition", "code": "\nchararray.rpartition(self, sep)\u00b6", "description": "Partition each element in self around sep.\n\nSee also\nrpartition\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.round", "code": "\nrecord.round()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.rpartition", "code": "\nnumpy.char.rpartition(a, sep)\u00b6", "description": "Partition (split) each element around the right-most separator.\nCalls str.rpartition element-wise.\nFor each element in a, split the element as the last\noccurrence of sep, and return 3 strings containing the part\nbefore the separator, the separator itself, and the part after\nthe separator. If the separator is not found, return 3 strings\ncontaining the string itself, followed by two empty strings.\n\nParameters\n\naarray_like of str or unicodeInput array\n\nsepstr or unicodeRight-most separator to split each element in array.\n\n\n\nReturns\n\noutndarrayOutput array of string or unicode, depending on input\ntype.  The output array will have an extra dimension with\n3 elements per input element.\n\n\n\n\n\nSee also\nstr.rpartition\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "sepstr or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of string or unicode, depending on inputtype.  The output array will have an extra dimension with3 elements per input element.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.row_stack", "code": "\nnumpy.ma.row_stack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nStack arrays in sequence vertically (row wise).\nThis is equivalent to concatenation along the first axis after 1-D arrays\nof shape (N,) have been reshaped to (1,N). Rebuilds arrays divided by\nvsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\n\nParameters\n\ntupsequence of ndarraysThe arrays must have the same shape along all but the first axis.\n1-D arrays must have the same length.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nhstackStack arrays in sequence horizontally (column wise).\n\ndstackStack arrays in sequence depth wise (along third dimension).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nvsplitSplit array into a list of multiple sub-arrays vertically.\n\nblockAssemble arrays from blocks.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; a = np.array([[1], [2], [3]])\n&gt;&gt;&gt; b = np.array([[2], [3], [4]])\n&gt;&gt;&gt; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n\n", "parameters": ["Parameters", "tupsequence of ndarrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays, will be at least 2-D.", "examples": ["; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.vstack((a,b))\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n\n", "; a = np.array([[1], [2], [3]])\n; b = np.array([[2], [3], [4]])\n; np.vstack((a,b))\narray([[1],\n       [2],\n       [3],\n       [2],\n       [3],\n       [4]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.round", "code": "\nndarray.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.round_", "code": "\nnumpy.round_(a, decimals=0, out=None)[source]\u00b6", "description": "Round an array to the given number of decimals.\n\nSee also\n\naroundequivalent function; see for details.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.round", "code": "\nrecarray.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.round", "code": "\nmemmap.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.round", "code": "\nMaskType.round()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.round", "code": "\nMaskedArray.round(self, decimals=0, out=None)[source]\u00b6", "description": "Return each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.ndarray.aroundcorresponding function for ndarrays\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.round", "code": "\nmasked_array.round(self, decimals=0, out=None)[source]\u00b6", "description": "Return each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.ndarray.aroundcorresponding function for ndarrays\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.round", "code": "\nmatrix.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.round", "code": "\ngeneric.round()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.round", "code": "\nchararray.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.round", "code": "\nchararray.round(decimals=0, out=None)\u00b6", "description": "Return a with each element rounded to the given number of decimals.\nRefer to numpy.around for full documentation.\n\nSee also\n\nnumpy.aroundequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.round", "code": "\nnumpy.ma.round(a, decimals=0, out=None)[source]\u00b6", "description": "Return a copy of a, rounded to \u2018decimals\u2019 places.\nWhen \u2018decimals\u2019 is negative, it specifies the number of positions\nto the left of the decimal point.  The real and imaginary parts of\ncomplex numbers are rounded separately. Nothing is done if the\narray is not of float type and \u2018decimals\u2019 is greater than or equal\nto 0.\n\nParameters\n\ndecimalsintNumber of decimals to round to. May be negative.\n\noutarray_likeExisting array to use for output.\nIf not given, returns a default copy of a.\n\n\n\n\nNotes\nIf out is given and does not have a mask attribute, the mask of a\nis lost!\n", "parameters": ["Parameters", "decimalsint", "outarray_like"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.rot90", "code": "\nnumpy.rot90(m, k=1, axes=(0, 1))[source]\u00b6", "description": "Rotate an array by 90 degrees in the plane specified by axes.\nRotation direction is from the first towards the second axis.\n\nParameters\n\nmarray_likeArray of two or more dimensions.\n\nkintegerNumber of times the array is rotated by 90 degrees.\n\naxes: (2,) array_likeThe array is rotated in the plane defined by the axes.\nAxes must be different.\n\nNew in version 1.12.0.\n\n\n\n\nReturns\n\nyndarrayA rotated view of m.\n\n\n\n\n\nSee also\n\nflipReverse the order of elements in an array along the given axis.\n\nfliplrFlip an array horizontally.\n\nflipudFlip an array vertically.\n\n\n\nNotes\nrot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))\nrot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))\nExamples\n&gt;&gt;&gt; m = np.array([[1,2],[3,4]], int)\n&gt;&gt;&gt; m\narray([[1, 2],\n       [3, 4]])\n&gt;&gt;&gt; np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n&gt;&gt;&gt; np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n&gt;&gt;&gt; m = np.arange(8).reshape((2,2,2))\n&gt;&gt;&gt; np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],\n       [[5, 7],\n        [4, 6]]])\n\n\n", "parameters": ["Parameters", "marray_like", "kinteger", "axes: (2,) array_like", "Returns", "yndarray"], "returns": "yndarrayA rotated view of m.", "examples": ["; m = np.array([[1,2],[3,4]], int)\n; m\narray([[1, 2],\n       [3, 4]])\n; np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n; np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n; m = np.arange(8).reshape((2,2,2))\n; np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],\n       [[5, 7],\n        [4, 6]]])\n\n", "; m = np.array([[1,2],[3,4]], int)\n; m\narray([[1, 2],\n       [3, 4]])\n; np.rot90(m)\narray([[2, 4],\n       [1, 3]])\n; np.rot90(m, 2)\narray([[4, 3],\n       [2, 1]])\n; m = np.arange(8).reshape((2,2,2))\n; np.rot90(m, 1, (1,2))\narray([[[1, 3],\n        [0, 2]],\n       [[5, 7],\n        [4, 6]]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.roots", "code": "\nPolynomial.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.roots", "code": "\nLegendre.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.roots", "code": "\nLaguerre.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.roots", "code": "\nHermiteE.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.roots", "code": "\nHermite.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.rollaxis", "code": "\nnumpy.rollaxis(a, axis, start=0)[source]\u00b6", "description": "Roll the specified axis backwards, until it lies in a given position.\nThis function continues to be supported for backward compatibility, but you\nshould prefer moveaxis. The moveaxis function was added in NumPy\n1.11.\n\nParameters\n\nandarrayInput array.\n\naxisintThe axis to roll backwards.  The positions of the other axes do not\nchange relative to one another.\n\nstartint, optionalThe axis is rolled until it lies before this position.  The default,\n0, results in a \u201ccomplete\u201d roll.\n\n\n\nReturns\n\nresndarrayFor NumPy &gt;= 1.10.0 a view of a is always returned. For earlier\nNumPy versions a view of a is returned only if the order of the\naxes is changed, otherwise the input array is returned.\n\n\n\n\n\nSee also\n\nmoveaxisMove array axes to new positions.\n\nrollRoll the elements of an array by a number of positions along a given axis.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ones((3,4,5,6))\n&gt;&gt;&gt; np.rollaxis(a, 3, 1).shape\n(3, 6, 4, 5)\n&gt;&gt;&gt; np.rollaxis(a, 2).shape\n(5, 3, 4, 6)\n&gt;&gt;&gt; np.rollaxis(a, 1, 4).shape\n(3, 5, 6, 4)\n\n\n", "parameters": ["Parameters", "andarray", "axisint", "startint, optional", "Returns", "resndarray"], "returns": "resndarrayFor NumPy &gt;= 1.10.0 a view of a is always returned. For earlierNumPy versions a view of a is returned only if the order of theaxes is changed, otherwise the input array is returned.", "examples": ["; a = np.ones((3,4,5,6))\n; np.rollaxis(a, 3, 1).shape\n(3, 6, 4, 5)\n; np.rollaxis(a, 2).shape\n(5, 3, 4, 6)\n; np.rollaxis(a, 1, 4).shape\n(3, 5, 6, 4)\n\n", "; a = np.ones((3,4,5,6))\n; np.rollaxis(a, 3, 1).shape\n(3, 6, 4, 5)\n; np.rollaxis(a, 2).shape\n(5, 3, 4, 6)\n; np.rollaxis(a, 1, 4).shape\n(3, 5, 6, 4)\n"]},
{"library": "numpy", "item_id": "numpy.chararray.rjust", "code": "\nchararray.rjust(self, width, fillchar=' ')[source]\u00b6", "description": "Return an array with the elements of self\nright-justified in a string of length width.\n\nSee also\nchar.rjust\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.roots", "code": "\nproperty poly1d.roots\u00b6", "description": "The roots of the polynomial, where self(x) == 0\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.roots", "code": "\nnumpy.roots(p)[source]\u00b6", "description": "Return the roots of a polynomial with coefficients given in p.\nThe values in the rank-1 array p are coefficients of a polynomial.\nIf the length of p is n+1 then the polynomial is described by:\np[0] * x**n + p[1] * x**(n-1) + ... + p[n-1]*x + p[n]\n\n\n\nParameters\n\nparray_likeRank-1 array of polynomial coefficients.\n\n\n\nReturns\n\noutndarrayAn array containing the roots of the polynomial.\n\n\n\nRaises\n\nValueErrorWhen p cannot be converted to a rank-1 array.\n\n\n\n\n\nSee also\n\npolyFind the coefficients of a polynomial with a given sequence of roots.\n\npolyvalCompute polynomial values.\n\npolyfitLeast squares polynomial fit.\n\npoly1dA one-dimensional polynomial class.\n\n\n\nNotes\nThe algorithm relies on computing the eigenvalues of the\ncompanion matrix [1].\nReferences\n\n1\nR. A. Horn &amp; C. R. Johnson, Matrix Analysis.  Cambridge, UK:\nCambridge University Press, 1999, pp. 146-7.\n\n\nExamples\n&gt;&gt;&gt; coeff = [3.2, 2, 1]\n&gt;&gt;&gt; np.roots(coeff)\narray([-0.3125+0.46351241j, -0.3125-0.46351241j])\n\n\n", "parameters": ["Parameters", "parray_like", "Returns", "outndarray", "Raises", "ValueError"], "returns": "outndarrayAn array containing the roots of the polynomial.", "examples": ["; coeff = [3.2, 2, 1]\n; np.roots(coeff)\narray([-0.3125+0.46351241j, -0.3125-0.46351241j])\n\n", "; coeff = [3.2, 2, 1]\n; np.roots(coeff)\narray([-0.3125+0.46351241j, -0.3125-0.46351241j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.roots", "code": "\nChebyshev.roots(self)[source]\u00b6", "description": "Return the roots of the series polynomial.\nCompute the roots for the series. Note that the accuracy of the\nroots decrease the further outside the domain they lie.\n\nReturns\n\nrootsndarrayArray containing the roots of the series.\n\n\n\n\n", "parameters": [], "returns": "rootsndarrayArray containing the roots of the series.", "examples": []},
{"library": "numpy", "item_id": "numpy.roll", "code": "\nnumpy.roll(a, shift, axis=None)[source]\u00b6", "description": "Roll array elements along a given axis.\nElements that roll beyond the last position are re-introduced at\nthe first.\n\nParameters\n\naarray_likeInput array.\n\nshiftint or tuple of intsThe number of places by which elements are shifted.  If a tuple,\nthen axis must be a tuple of the same size, and each of the\ngiven axes is shifted by the corresponding number.  If an int\nwhile axis is a tuple of ints, then the same value is used for\nall given axes.\n\naxisint or tuple of ints, optionalAxis or axes along which elements are shifted.  By default, the\narray is flattened before shifting, after which the original\nshape is restored.\n\n\n\nReturns\n\nresndarrayOutput array, with the same shape as a.\n\n\n\n\n\nSee also\n\nrollaxisRoll the specified axis backwards, until it lies in a given position.\n\n\n\nNotes\n\nNew in version 1.12.0.\n\nSupports rolling over multiple dimensions simultaneously.\nExamples\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; np.roll(x, 2)\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n&gt;&gt;&gt; np.roll(x, -2)\narray([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n\n\n&gt;&gt;&gt; x2 = np.reshape(x, (2,5))\n&gt;&gt;&gt; x2\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; np.roll(x2, 1)\narray([[9, 0, 1, 2, 3],\n       [4, 5, 6, 7, 8]])\n&gt;&gt;&gt; np.roll(x2, -1)\narray([[1, 2, 3, 4, 5],\n       [6, 7, 8, 9, 0]])\n&gt;&gt;&gt; np.roll(x2, 1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n&gt;&gt;&gt; np.roll(x2, -1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n&gt;&gt;&gt; np.roll(x2, 1, axis=1)\narray([[4, 0, 1, 2, 3],\n       [9, 5, 6, 7, 8]])\n&gt;&gt;&gt; np.roll(x2, -1, axis=1)\narray([[1, 2, 3, 4, 0],\n       [6, 7, 8, 9, 5]])\n\n\n", "parameters": ["Parameters", "aarray_like", "shiftint or tuple of ints", "axisint or tuple of ints, optional", "Returns", "resndarray"], "returns": "resndarrayOutput array, with the same shape as a.", "examples": ["; x = np.arange(10)\n; np.roll(x, 2)\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n; np.roll(x, -2)\narray([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n\n", "; x = np.arange(10)\n; np.roll(x, 2)\narray([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])\n; np.roll(x, -2)\narray([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])\n", "; x2 = np.reshape(x, (2,5))\n; x2\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n; np.roll(x2, 1)\narray([[9, 0, 1, 2, 3],\n       [4, 5, 6, 7, 8]])\n; np.roll(x2, -1)\narray([[1, 2, 3, 4, 5],\n       [6, 7, 8, 9, 0]])\n; np.roll(x2, 1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n; np.roll(x2, -1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n; np.roll(x2, 1, axis=1)\narray([[4, 0, 1, 2, 3],\n       [9, 5, 6, 7, 8]])\n; np.roll(x2, -1, axis=1)\narray([[1, 2, 3, 4, 0],\n       [6, 7, 8, 9, 5]])\n\n", "; x2 = np.reshape(x, (2,5))\n; x2\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n; np.roll(x2, 1)\narray([[9, 0, 1, 2, 3],\n       [4, 5, 6, 7, 8]])\n; np.roll(x2, -1)\narray([[1, 2, 3, 4, 5],\n       [6, 7, 8, 9, 0]])\n; np.roll(x2, 1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n; np.roll(x2, -1, axis=0)\narray([[5, 6, 7, 8, 9],\n       [0, 1, 2, 3, 4]])\n; np.roll(x2, 1, axis=1)\narray([[4, 0, 1, 2, 3],\n       [9, 5, 6, 7, 8]])\n; np.roll(x2, -1, axis=1)\narray([[1, 2, 3, 4, 0],\n       [6, 7, 8, 9, 5]])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.rjust", "code": "\nchararray.rjust(self, width, fillchar=' ')\u00b6", "description": "Return an array with the elements of self\nright-justified in a string of length width.\n\nSee also\nchar.rjust\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.rint", "code": "\nnumpy.rint(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'rint'&gt;\u00b6", "description": "Round elements of the array to the nearest integer.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array is same shape and type as x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nceil, floor, trunc\n\nExamples\n&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n&gt;&gt;&gt; np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array is same shape and type as x.This is a scalar if x is a scalar.", "examples": ["; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])\n\n", "; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.rint(a)\narray([-2., -2., -0.,  0.,  2.,  2.,  2.])\n"]},
{"library": "numpy", "item_id": "numpy.char.rjust", "code": "\nnumpy.char.rjust(a, width, fillchar=' ')\u00b6", "description": "Return an array with the elements of a right-justified in a\nstring of length width.\nCalls str.rjust element-wise.\n\nParameters\n\naarray_like of str or unicode\nwidthintThe length of the resulting strings\n\nfillcharstr or unicode, optionalThe character to use for padding\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.rjust\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "widthint", "fillcharstr or unicode, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.char.rindex", "code": "\nnumpy.char.rindex(a, sub, start=0, end=None)\u00b6", "description": "Like rfind, but raises ValueError when the substring sub is\nnot found.\nCalls str.rindex element-wise.\n\nParameters\n\naarray-like of str or unicode\nsubstr or unicode\nstart, endint, optional\n\n\nReturns\n\noutndarrayOutput array of ints.\n\n\n\n\n\nSee also\nrfind, str.rindex\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "substr or unicode", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of ints.", "examples": []},
{"library": "numpy", "item_id": "numpy.right_shift", "code": "\nnumpy.right_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'right_shift'&gt;\u00b6", "description": "Shift the bits of an integer to the right.\nBits are shifted to the right x2.  Because the internal\nrepresentation of numbers is in binary format, this operation is\nequivalent to dividing x1 by 2**x2.\n\nParameters\n\nx1array_like, intInput values.\n\nx2array_like, intNumber of bits to remove at the right of x1. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray, intReturn x1 with bits shifted x2 times to the right.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nleft_shiftShift the bits of an integer to the left.\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nExamples\n&gt;&gt;&gt; np.binary_repr(10)\n'1010'\n&gt;&gt;&gt; np.right_shift(10, 1)\n5\n&gt;&gt;&gt; np.binary_repr(5)\n'101'\n\n\n&gt;&gt;&gt; np.right_shift(10, [1,2,3])\narray([5, 2, 1])\n\n\n", "parameters": ["Parameters", "x1array_like, int", "x2array_like, int", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray, int"], "returns": "outndarray, intReturn x1 with bits shifted x2 times to the right.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.binary_repr(10)\n'1010'\n; np.right_shift(10, 1)\n5\n; np.binary_repr(5)\n'101'\n\n", "; np.binary_repr(10)\n'1010'\n; np.right_shift(10, 1)\n5\n; np.binary_repr(5)\n'101'\n", "; np.right_shift(10, [1,2,3])\narray([5, 2, 1])\n\n", "; np.right_shift(10, [1,2,3])\narray([5, 2, 1])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.rindex", "code": "\nchararray.rindex(self, sub, start=0, end=None)[source]\u00b6", "description": "Like rfind, but raises ValueError when the substring sub is\nnot found.\n\nSee also\nchar.rindex\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.rfind", "code": "\nnumpy.char.rfind(a, sub, start=0, end=None)\u00b6", "description": "For each element in a, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].\nCalls str.rfind element-wise.\n\nParameters\n\naarray-like of str or unicode\nsubstr or unicode\nstart, endint, optionalOptional arguments start and end are interpreted as in\nslice notation.\n\n\n\nReturns\n\noutndarrayOutput array of ints.  Return -1 on failure.\n\n\n\n\n\nSee also\nstr.rfind\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "substr or unicode", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of ints.  Return -1 on failure.", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.rindex", "code": "\nchararray.rindex(self, sub, start=0, end=None)\u00b6", "description": "Like rfind, but raises ValueError when the substring sub is\nnot found.\n\nSee also\nchar.rindex\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.rfind", "code": "\nchararray.rfind(self, sub, start=0, end=None)[source]\u00b6", "description": "For each element in self, return the highest index in the string\nwhere substring sub is found, such that sub is contained\nwithin [start, end].\n\nSee also\nchar.rfind\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fft.rfftn", "code": "\nnumpy.fft.rfftn(a, s=None, axes=None, norm=None)[source]\u00b6", "description": "Compute the N-dimensional discrete Fourier Transform for real input.\nThis function computes the N-dimensional discrete Fourier Transform over\nany number of axes in an M-dimensional real array by means of the Fast\nFourier Transform (FFT).  By default, all axes are transformed, with the\nreal transform performed over the last axis, while the remaining\ntransforms are complex.\n\nParameters\n\naarray_likeInput array, taken to be real.\n\nssequence of ints, optionalShape (length along each transformed axis) to use from the input.\n(s[0] refers to axis 0, s[1] to axis 1, etc.).\nThe final element of s corresponds to n for rfft(x, n), while\nfor the remaining axes, it corresponds to n for fft(x, n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nif s is not given, the shape of the input along the axes specified\nby axes is used.\n\naxessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last len(s)\naxes are used, or all axes if s is also not specified.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or by a combination of s and a,\nas explained in the parameters section above.\nThe length of the last axis transformed will be s[-1]//2+1,\nwhile the remaining transformed axes will have lengths according to\ns, or unchanged from the input.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nirfftnThe inverse of rfftn, i.e. the inverse of the n-dimensional FFT of real input.\n\nfftThe one-dimensional FFT, with definitions and conventions used.\n\nrfftThe one-dimensional FFT of real input.\n\nfftnThe n-dimensional FFT.\n\nrfft2The two-dimensional FFT of real input.\n\n\n\nNotes\nThe transform for real input is performed over the last transformation\naxis, as by rfft, then the transform over the remaining axes is\nperformed as by fftn.  The order of the output is as for rfft for the\nfinal transformation axis, and as for fftn for the remaining\ntransformation axes.\nSee fft for details, definitions and conventions used.\nExamples\n&gt;&gt;&gt; a = np.ones((2, 2, 2))\n&gt;&gt;&gt; np.fft.rfftn(a)\narray([[[8.+0.j,  0.+0.j], # may vary\n        [0.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n\n\n&gt;&gt;&gt; np.fft.rfftn(a, axes=(2, 0))\narray([[[4.+0.j,  0.+0.j], # may vary\n        [4.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "ValueError", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s and a,as explained in the parameters section above.The length of the last axis transformed will be s[-1]//2+1,while the remaining transformed axes will have lengths according tos, or unchanged from the input.", "examples": ["; a = np.ones((2, 2, 2))\n; np.fft.rfftn(a)\narray([[[8.+0.j,  0.+0.j], # may vary\n        [0.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n\n", "; a = np.ones((2, 2, 2))\n; np.fft.rfftn(a)\narray([[[8.+0.j,  0.+0.j], # may vary\n        [0.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n", "; np.fft.rfftn(a, axes=(2, 0))\narray([[[4.+0.j,  0.+0.j], # may vary\n        [4.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n\n", "; np.fft.rfftn(a, axes=(2, 0))\narray([[[4.+0.j,  0.+0.j], # may vary\n        [4.+0.j,  0.+0.j]],\n       [[0.+0.j,  0.+0.j],\n        [0.+0.j,  0.+0.j]]])\n"]},
{"library": "numpy", "item_id": "numpy.record.resize", "code": "\nrecord.resize()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fft.rfftfreq", "code": "\nnumpy.fft.rfftfreq(n, d=1.0)[source]\u00b6", "description": "Return the Discrete Fourier Transform sample frequencies\n(for usage with rfft, irfft).\nThe returned float array f contains the frequency bin centers in cycles\nper unit of the sample spacing (with zero at the start).  For instance, if\nthe sample spacing is in seconds, then the frequency unit is cycles/second.\nGiven a window length n and a sample spacing d:\nf = [0, 1, ...,     n/2-1,     n/2] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2-1, (n-1)/2] / (d*n)   if n is odd\n\n\nUnlike fftfreq (but like scipy.fftpack.rfftfreq)\nthe Nyquist frequency component is considered to be positive.\n\nParameters\n\nnintWindow length.\n\ndscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.\n\n\n\nReturns\n\nfndarrayArray of length n//2 + 1 containing the sample frequencies.\n\n\n\n\nExamples\n&gt;&gt;&gt; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)\n&gt;&gt;&gt; fourier = np.fft.rfft(signal)\n&gt;&gt;&gt; n = signal.size\n&gt;&gt;&gt; sample_rate = 100\n&gt;&gt;&gt; freq = np.fft.fftfreq(n, d=1./sample_rate)\n&gt;&gt;&gt; freq\narray([  0.,  10.,  20., ..., -30., -20., -10.])\n&gt;&gt;&gt; freq = np.fft.rfftfreq(n, d=1./sample_rate)\n&gt;&gt;&gt; freq\narray([  0.,  10.,  20.,  30.,  40.,  50.])\n\n\n", "parameters": ["Parameters", "nint", "dscalar, optional", "Returns", "fndarray"], "returns": "fndarrayArray of length n//2 + 1 containing the sample frequencies.", "examples": ["; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)\n; fourier = np.fft.rfft(signal)\n; n = signal.size\n; sample_rate = 100\n; freq = np.fft.fftfreq(n, d=1./sample_rate)\n; freq\narray([  0.,  10.,  20., ..., -30., -20., -10.])\n; freq = np.fft.rfftfreq(n, d=1./sample_rate)\n; freq\narray([  0.,  10.,  20.,  30.,  40.,  50.])\n\n", "; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5, -3, 4], dtype=float)\n; fourier = np.fft.rfft(signal)\n; n = signal.size\n; sample_rate = 100\n; freq = np.fft.fftfreq(n, d=1./sample_rate)\n; freq\narray([  0.,  10.,  20., ..., -30., -20., -10.])\n; freq = np.fft.rfftfreq(n, d=1./sample_rate)\n; freq\narray([  0.,  10.,  20.,  30.,  40.,  50.])\n"]},
{"library": "numpy", "item_id": "numpy.fft.rfft2", "code": "\nnumpy.fft.rfft2(a, s=None, axes=(-2, -1), norm=None)[source]\u00b6", "description": "Compute the 2-dimensional FFT of a real array.\n\nParameters\n\naarrayInput array, taken to be real.\n\nssequence of ints, optionalShape of the FFT.\n\naxessequence of ints, optionalAxes over which to compute the FFT.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutndarrayThe result of the real 2-D FFT.\n\n\n\n\n\nSee also\n\nrfftnCompute the N-dimensional discrete Fourier Transform for real input.\n\n\n\nNotes\nThis is really just rfftn with different default behavior.\nFor more details see rfftn.\n", "parameters": ["Parameters", "aarray", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outndarray"], "returns": "outndarrayThe result of the real 2-D FFT.", "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.resize", "code": "\nrecarray.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.fft.rfft", "code": "\nnumpy.fft.rfft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the one-dimensional discrete Fourier Transform for real input.\nThis function computes the one-dimensional n-point discrete Fourier\nTransform (DFT) of a real-valued array by means of an efficient algorithm\ncalled the Fast Fourier Transform (FFT).\n\nParameters\n\naarray_likeInput array\n\nnint, optionalNumber of points along transformation axis in the input to use.\nIf n is smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros. If n is not given,\nthe length of the input along the axis specified by axis is used.\n\naxisint, optionalAxis over which to compute the FFT. If not given, the last axis is\nused.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\nIf n is even, the length of the transformed axis is (n/2)+1.\nIf n is odd, the length is (n+1)/2.\n\n\n\nRaises\n\nIndexErrorIf axis is larger than the last axis of a.\n\n\n\n\n\nSee also\n\nnumpy.fftFor definition of the DFT and conventions used.\n\nirfftThe inverse of rfft.\n\nfftThe one-dimensional FFT of general (complex) input.\n\nfftnThe n-dimensional FFT.\n\nrfftnThe n-dimensional FFT of real input.\n\n\n\nNotes\nWhen the DFT is computed for purely real input, the output is\nHermitian-symmetric, i.e. the negative frequency terms are just the complex\nconjugates of the corresponding positive-frequency terms, and the\nnegative-frequency terms are therefore redundant.  This function does not\ncompute the negative frequency terms, and the length of the transformed\naxis of the output is therefore n//2 + 1.\nWhen A = rfft(a) and fs is the sampling frequency, A[0] contains\nthe zero-frequency term 0*fs, which is real due to Hermitian symmetry.\nIf n is even, A[-1] contains the term representing both positive\nand negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely\nreal. If n is odd, there is no term at fs/2; A[-1] contains\nthe largest positive frequency (fs/2*(n-1)/n), and is complex in the\ngeneral case.\nIf the input a contains an imaginary part, it is silently discarded.\nExamples\n&gt;&gt;&gt; np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary\n&gt;&gt;&gt; np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary\n\n\nNotice how the final element of the fft output is the complex conjugate\nof the second element, for real input. For rfft, this symmetry is\nexploited to compute only the non-negative frequency terms.\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.If n is even, the length of the transformed axis is (n/2)+1.If n is odd, the length is (n+1)/2.", "examples": ["; np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary\n; np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary\n\n", "; np.fft.fft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j,  0.+1.j]) # may vary\n; np.fft.rfft([0, 1, 0, 0])\narray([ 1.+0.j,  0.-1.j, -1.+0.j]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.resize", "code": "\nndarray.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.result_type", "code": "\nnumpy.result_type(*arrays_and_dtypes)\u00b6", "description": "Returns the type that results from applying the NumPy\ntype promotion rules to the arguments.\nType promotion in NumPy works similarly to the rules in languages\nlike C++, with some slight differences.  When both scalars and\narrays are used, the array\u2019s type takes precedence and the actual value\nof the scalar is taken into account.\nFor example, calculating 3*a, where a is an array of 32-bit floats,\nintuitively should result in a 32-bit float output.  If the 3 is a\n32-bit integer, the NumPy rules indicate it can\u2019t convert losslessly\ninto a 32-bit float, so a 64-bit float should be the result type.\nBy examining the value of the constant, \u20183\u2019, we see that it fits in\nan 8-bit integer, which can be cast losslessly into the 32-bit float.\n\nParameters\n\narrays_and_dtypeslist of arrays and dtypesThe operands of some operation whose result type is needed.\n\n\n\nReturns\n\noutdtypeThe result type.\n\n\n\n\n\nSee also\ndtype, promote_types, min_scalar_type, can_cast\n\nNotes\n\nNew in version 1.6.0.\n\nThe specific algorithm used is as follows.\nCategories are determined by first checking which of boolean,\ninteger (int/uint), or floating point (float/complex) the maximum\nkind of all the arrays and the scalars are.\nIf there are only scalars or the maximum category of the scalars\nis higher than the maximum category of the arrays,\nthe data types are combined with promote_types\nto produce the return value.\nOtherwise, min_scalar_type is called on each array, and\nthe resulting data types are all combined with promote_types\nto produce the return value.\nThe set of int values is not a subset of the uint values for types\nwith the same number of bits, something not reflected in\nmin_scalar_type, but handled as a special case in result_type.\nExamples\n&gt;&gt;&gt; np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')\n\n\n&gt;&gt;&gt; np.result_type('i4', 'c8')\ndtype('complex128')\n\n\n&gt;&gt;&gt; np.result_type(3.0, -2)\ndtype('float64')\n\n\n", "parameters": ["Parameters", "arrays_and_dtypeslist of arrays and dtypes", "Returns", "outdtype"], "returns": "outdtypeThe result type.", "examples": ["; np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')\n\n", "; np.result_type(3, np.arange(7, dtype='i1'))\ndtype('int8')\n", "; np.result_type('i4', 'c8')\ndtype('complex128')\n\n", "; np.result_type('i4', 'c8')\ndtype('complex128')\n", "; np.result_type(3.0, -2)\ndtype('float64')\n\n", "; np.result_type(3.0, -2)\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.memmap.resize", "code": "\nmemmap.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.resize", "code": "\nmatrix.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.resize", "code": "\nMaskType.resize()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.resize", "code": "\nMaskedArray.resize(self, newshape, refcheck=True, order=False)[source]\u00b6", "description": "\nWarning\nThis method does nothing, except raise a ValueError exception. A\nmasked array does not own its data and therefore cannot safely be\nresized in place. Use the numpy.ma.resize function instead.\n\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.resize", "code": "\nmasked_array.resize(self, newshape, refcheck=True, order=False)[source]\u00b6", "description": "\nWarning\nThis method does nothing, except raise a ValueError exception. A\nmasked array does not own its data and therefore cannot safely be\nresized in place. Use the numpy.ma.resize function instead.\n\nThis method is difficult to implement safely and may be deprecated in\nfuture releases of NumPy.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.resize", "code": "\ngeneric.resize()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.resize", "code": "\nchararray.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.resize", "code": "\nchararray.resize(new_shape, refcheck=True)\u00b6", "description": "Change shape and size of array in-place.\n\nParameters\n\nnew_shapetuple of ints, or n intsShape of resized array.\n\nrefcheckbool, optionalIf False, reference count will not be checked. Default is True.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nValueErrorIf a does not own its own data or references or views to it exist,\nand the data memory must be changed.\nPyPy only: will always raise if the data memory must be changed, since\nthere is no reliable way to determine if references or views to it\nexist.\n\nSystemErrorIf the order keyword argument is specified. This behaviour is a\nbug in NumPy.\n\n\n\n\n\nSee also\n\nresizeReturn a new array with the specified shape.\n\n\n\nNotes\nThis reallocates space for the data area if necessary.\nOnly contiguous arrays (data elements consecutive in memory) can be\nresized.\nThe purpose of the reference count check is to make sure you\ndo not use this array as a buffer for another Python object and then\nreallocate the memory. However, reference counts can increase in\nother ways so if you are sure that you have not shared the memory\nfor this array with another Python object, then you may safely set\nrefcheck to False.\nExamples\nShrinking an array: array is flattened (in the order that the data are\nstored in memory), resized, and reshaped:\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='C')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [1]])\n\n\n&gt;&gt;&gt; a = np.array([[0, 1], [2, 3]], order='F')\n&gt;&gt;&gt; a.resize((2, 1))\n&gt;&gt;&gt; a\narray([[0],\n       [2]])\n\n\nEnlarging an array: as above, but missing entries are filled with zeros:\n&gt;&gt;&gt; b = np.array([[0, 1], [2, 3]])\n&gt;&gt;&gt; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n&gt;&gt;&gt; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n\nReferencing an array prevents resizing\u2026\n&gt;&gt;&gt; c = a\n&gt;&gt;&gt; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n\nUnless refcheck is False:\n&gt;&gt;&gt; a.resize((1, 1), refcheck=False)\n&gt;&gt;&gt; a\narray([[0]])\n&gt;&gt;&gt; c\narray([[0]])\n\n\n", "parameters": ["Parameters", "new_shapetuple of ints, or n ints", "refcheckbool, optional", "Returns", "None", "Raises", "ValueError", "SystemError"], "returns": "None", "examples": ["; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='C')\n; a.resize((2, 1))\n; a\narray([[0],\n       [1]])\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n\n", "; a = np.array([[0, 1], [2, 3]], order='F')\n; a.resize((2, 1))\n; a\narray([[0],\n       [2]])\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n\n", "; b = np.array([[0, 1], [2, 3]])\n; b.resize(2, 3) # new_shape parameter doesn't have to be a tuple\n; b\narray([[0, 1, 2],\n       [3, 0, 0]])\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n\n", "; c = a\n; a.resize((1, 1))\nTraceback (most recent call last):\n...\nValueError: cannot resize an array that references or is referenced ...\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n\n", "; a.resize((1, 1), refcheck=False)\n; a\narray([[0]])\n; c\narray([[0]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.resize", "code": "\nnumpy.ma.resize(x, new_shape)[source]\u00b6", "description": "Return a new masked array with the specified size and shape.\nThis is the masked equivalent of the numpy.resize function. The new\narray is filled with repeated copies of x (in the order that the\ndata are stored in memory). If x is masked, the new array will be\nmasked, and the new mask will be a repetition of the old one.\n\nSee also\n\nnumpy.resizeEquivalent function in the top level NumPy module.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.array([[1, 2] ,[3, 4]])\n&gt;&gt;&gt; a[0, 1] = ma.masked\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=999999)\n&gt;&gt;&gt; np.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n&gt;&gt;&gt; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, --, 3],\n        [4, 1, --],\n        [3, 4, 1]],\n  mask=[[False,  True, False],\n        [False, False,  True],\n        [False, False, False]],\n  fill_value=999999)\n\n\nA MaskedArray is always returned, regardless of the input type.\n&gt;&gt;&gt; a = np.array([[1, 2] ,[3, 4]])\n&gt;&gt;&gt; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = ma.array([[1, 2] ,[3, 4]])\n; a[0, 1] = ma.masked\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=999999)\n; np.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, --, 3],\n        [4, 1, --],\n        [3, 4, 1]],\n  mask=[[False,  True, False],\n        [False, False,  True],\n        [False, False, False]],\n  fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = ma.array([[1, 2] ,[3, 4]])\n; a[0, 1] = ma.masked\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=999999)\n; np.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, --, 3],\n        [4, 1, --],\n        [3, 4, 1]],\n  mask=[[False,  True, False],\n        [False, False,  True],\n        [False, False, False]],\n  fill_value=999999)\n", "; a = np.array([[1, 2] ,[3, 4]])\n; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n\n", "; a = np.array([[1, 2] ,[3, 4]])\n; ma.resize(a, (3, 3))\nmasked_array(\n  data=[[1, 2, 3],\n        [4, 1, 2],\n        [3, 4, 1]],\n  mask=False,\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.resize", "code": "\nnumpy.resize(a, new_shape)[source]\u00b6", "description": "Return a new array with the specified shape.\nIf the new array is larger than the original array, then the new\narray is filled with repeated copies of a.  Note that this behavior\nis different from a.resize(new_shape) which fills with zeros instead\nof repeated copies of a.\n\nParameters\n\naarray_likeArray to be resized.\n\nnew_shapeint or tuple of intShape of resized array.\n\n\n\nReturns\n\nreshaped_arrayndarrayThe new array is formed from the data in the old array, repeated\nif necessary to fill out the required number of elements.  The\ndata are repeated in the order that they are stored in memory.\n\n\n\n\n\nSee also\n\nndarray.resizeresize an array in-place.\n\n\n\nNotes\nWarning: This functionality does not consider axes separately,\ni.e. it does not apply interpolation/extrapolation.\nIt fills the return array with the required number of elements, taken\nfrom a as they are laid out in memory, disregarding strides and axes.\n(This is in case the new shape is smaller. For larger, see above.)\nThis functionality is therefore not suitable to resize images,\nor data where each axis represents a separate and distinct entity.\nExamples\n&gt;&gt;&gt; a=np.array([[0,1],[2,3]])\n&gt;&gt;&gt; np.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\n&gt;&gt;&gt; np.resize(a,(1,4))\narray([[0, 1, 2, 3]])\n&gt;&gt;&gt; np.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])\n\n\n", "parameters": ["Parameters", "aarray_like", "new_shapeint or tuple of int", "Returns", "reshaped_arrayndarray"], "returns": "reshaped_arrayndarrayThe new array is formed from the data in the old array, repeatedif necessary to fill out the required number of elements.  Thedata are repeated in the order that they are stored in memory.", "examples": ["; a=np.array([[0,1],[2,3]])\n; np.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\n; np.resize(a,(1,4))\narray([[0, 1, 2, 3]])\n; np.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])\n\n", "; a=np.array([[0,1],[2,3]])\n; np.resize(a,(2,3))\narray([[0, 1, 2],\n       [3, 0, 1]])\n; np.resize(a,(1,4))\narray([[0, 1, 2, 3]])\n; np.resize(a,(2,4))\narray([[0, 1, 2, 3],\n       [0, 1, 2, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.record.reshape", "code": "\nrecord.reshape()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.reshape", "code": "\nrecarray.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.reshape", "code": "\nndarray.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.reshape", "code": "\nmemmap.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.reshape", "code": "\nmatrix.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.reshape", "code": "\nMaskType.reshape()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.reshape", "code": "\nMaskedArray.reshape(self, *s, **kwargs)[source]\u00b6", "description": "Give a new shape to the array without changing its data.\nReturns a masked array containing the same data, but with a new shape.\nThe result is a view on the original array; if this is not possible, a\nValueError is raised.\n\nParameters\n\nshapeint or tuple of intsThe new shape should be compatible with the original shape. If an\ninteger is supplied, then the result will be a 1-D array of that\nlength.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalDetermines whether the array data should be viewed as in C\n(row-major) or FORTRAN (column-major) order.\n\n\n\nReturns\n\nreshaped_arrayarrayA new view on the array.\n\n\n\n\n\nSee also\n\nreshapeEquivalent function in the masked array module.\n\nnumpy.ndarray.reshapeEquivalent method on ndarray object.\n\nnumpy.reshapeEquivalent function in the NumPy module.\n\n\n\nNotes\nThe reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use a.shape = s\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; x = x.reshape((4,1))\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "shapeint or tuple of ints", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "reshaped_arrayarray"], "returns": "reshaped_arrayarrayA new view on the array.", "examples": ["; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n; x = x.reshape((4,1))\n; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n\n", "; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n; x = x.reshape((4,1))\n; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.reshape", "code": "\nmasked_array.reshape(self, *s, **kwargs)[source]\u00b6", "description": "Give a new shape to the array without changing its data.\nReturns a masked array containing the same data, but with a new shape.\nThe result is a view on the original array; if this is not possible, a\nValueError is raised.\n\nParameters\n\nshapeint or tuple of intsThe new shape should be compatible with the original shape. If an\ninteger is supplied, then the result will be a 1-D array of that\nlength.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalDetermines whether the array data should be viewed as in C\n(row-major) or FORTRAN (column-major) order.\n\n\n\nReturns\n\nreshaped_arrayarrayA new view on the array.\n\n\n\n\n\nSee also\n\nreshapeEquivalent function in the masked array module.\n\nnumpy.ndarray.reshapeEquivalent method on ndarray object.\n\nnumpy.reshapeEquivalent function in the NumPy module.\n\n\n\nNotes\nThe reshaping operation cannot guarantee that a copy will not be made,\nto modify the shape in place, use a.shape = s\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; x = x.reshape((4,1))\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "shapeint or tuple of ints", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "reshaped_arrayarray"], "returns": "reshaped_arrayarrayA new view on the array.", "examples": ["; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n; x = x.reshape((4,1))\n; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n\n", "; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])\n; x\nmasked_array(\n  data=[[--, 2],\n        [3, --]],\n  mask=[[ True, False],\n        [False,  True]],\n  fill_value=999999)\n; x = x.reshape((4,1))\n; x\nmasked_array(\n  data=[[--],\n        [2],\n        [3],\n        [--]],\n  mask=[[ True],\n        [False],\n        [False],\n        [ True]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.generic.reshape", "code": "\ngeneric.reshape()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.reshape", "code": "\nchararray.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.reshape", "code": "\nchararray.reshape(shape, order='C')\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to numpy.reshape for full documentation.\n\nSee also\n\nnumpy.reshapeequivalent function\n\n\n\nNotes\nUnlike the free function numpy.reshape, this method on ndarray allows\nthe elements of the shape parameter to be passed in as separate arguments.\nFor example, a.reshape(10, 11) is equivalent to\na.reshape((10, 11)).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.reset", "code": "\nnditer.reset()\u00b6", "description": "Reset the iterator to its initial state.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.broadcast.reset", "code": "\nbroadcast.reset()\u00b6", "description": "Reset the broadcasted result\u2019s iterator(s).\n\nParameters\n\nNone\n\n\nReturns\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.index\n0\n&gt;&gt;&gt; next(b), next(b), next(b)\n((1, 4), (2, 4), (3, 4))\n&gt;&gt;&gt; b.index\n3\n&gt;&gt;&gt; b.reset()\n&gt;&gt;&gt; b.index\n0\n\n\n", "parameters": ["Parameters", "None", "Returns", "None"], "returns": "None", "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.index\n0\n; next(b), next(b), next(b)\n((1, 4), (2, 4), (3, 4))\n; b.index\n3\n; b.reset()\n; b.index\n0\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.index\n0\n; next(b), next(b), next(b)\n((1, 4), (2, 4), (3, 4))\n; b.index\n3\n; b.reset()\n; b.index\n0\n"]},
{"library": "numpy", "item_id": "numpy.ma.reshape", "code": "\nnumpy.ma.reshape(a, new_shape, order='C')[source]\u00b6", "description": "Returns an array containing the same data with a new shape.\nRefer to MaskedArray.reshape for full documentation.\n\nSee also\n\nMaskedArray.reshapeequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.reshape", "code": "\nnumpy.reshape(a, newshape, order='C')[source]\u00b6", "description": "Gives a new shape to an array without changing its data.\n\nParameters\n\naarray_likeArray to be reshaped.\n\nnewshapeint or tuple of intsThe new shape should be compatible with the original shape. If\nan integer, then the result will be a 1-D array of that length.\nOne shape dimension can be -1. In this case, the value is\ninferred from the length of the array and remaining dimensions.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optionalRead the elements of a using this index order, and place the\nelements into the reshaped array using this index order.  \u2018C\u2019\nmeans to read / write the elements using C-like index order,\nwith the last axis index changing fastest, back to the first\naxis index changing slowest. \u2018F\u2019 means to read / write the\nelements using Fortran-like index order, with the first index\nchanging fastest, and the last index changing slowest. Note that\nthe \u2018C\u2019 and \u2018F\u2019 options take no account of the memory layout of\nthe underlying array, and only refer to the order of indexing.\n\u2018A\u2019 means to read / write the elements in Fortran-like index\norder if a is Fortran contiguous in memory, C-like order\notherwise.\n\n\n\nReturns\n\nreshaped_arrayndarrayThis will be a new view object if possible; otherwise, it will\nbe a copy.  Note there is no guarantee of the memory layout (C- or\nFortran- contiguous) of the returned array.\n\n\n\n\n\nSee also\n\nndarray.reshapeEquivalent method.\n\n\n\nNotes\nIt is not always possible to change the shape of an array without\ncopying the data. If you want an error to be raised when the data is copied,\nyou should assign the new shape to the shape attribute of the array:\n&gt;&gt;&gt; a = np.zeros((10, 2))\n\n# A transpose makes the array non-contiguous\n&gt;&gt;&gt; b = a.T\n\n# Taking a view makes it possible to modify the shape without modifying\n# the initial object.\n&gt;&gt;&gt; c = b.view()\n&gt;&gt;&gt; c.shape = (20)\nTraceback (most recent call last):\n   ...\nAttributeError: incompatible shape for a non-contiguous array\n\n\nThe order keyword gives the index ordering both for fetching the values\nfrom a, and then placing the values into the output array.\nFor example, let\u2019s say you have an array:\n&gt;&gt;&gt; a = np.arange(6).reshape((3, 2))\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n\n\nYou can think of reshaping as first raveling the array (using the given\nindex order), then inserting the elements from the raveled array into the\nnew array using the same kind of index ordering as was used for the\nraveling.\n&gt;&gt;&gt; np.reshape(a, (2, 3)) # C-like index ordering\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.reshape(a, (2, 3), order='F') # Fortran-like index ordering\narray([[0, 4, 3],\n       [2, 1, 5]])\n&gt;&gt;&gt; np.reshape(np.ravel(a, order='F'), (2, 3), order='F')\narray([[0, 4, 3],\n       [2, 1, 5]])\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])\n&gt;&gt;&gt; np.reshape(a, 6)\narray([1, 2, 3, 4, 5, 6])\n&gt;&gt;&gt; np.reshape(a, 6, order='F')\narray([1, 4, 2, 5, 3, 6])\n\n\n&gt;&gt;&gt; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n\n", "parameters": ["Parameters", "aarray_like", "newshapeint or tuple of ints", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optional", "Returns", "reshaped_arrayndarray"], "returns": "reshaped_arrayndarrayThis will be a new view object if possible; otherwise, it willbe a copy.  Note there is no guarantee of the memory layout (C- orFortran- contiguous) of the returned array.", "examples": ["; a = np.array([[1,2,3], [4,5,6]])\n; np.reshape(a, 6)\narray([1, 2, 3, 4, 5, 6])\n; np.reshape(a, 6, order='F')\narray([1, 4, 2, 5, 3, 6])\n\n", "; a = np.array([[1,2,3], [4,5,6]])\n; np.reshape(a, 6)\narray([1, 2, 3, 4, 5, 6])\n; np.reshape(a, 6, order='F')\narray([1, 4, 2, 5, 3, 6])\n", "; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n\n", "; np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n"]},
{"library": "numpy", "item_id": "numpy.require", "code": "\nnumpy.require(a, dtype=None, requirements=None)[source]\u00b6", "description": "Return an ndarray of the provided type that satisfies requirements.\nThis function is useful to be sure that an array with the correct flags\nis returned for passing to compiled code (perhaps through ctypes).\n\nParameters\n\naarray_likeThe object to be converted to a type-and-requirement-satisfying array.\n\ndtypedata-typeThe required data-type. If None preserve the current dtype. If your\napplication requires the data to be in native byteorder, include\na byteorder specification as a part of the dtype specification.\n\nrequirementsstr or list of strThe requirements list can be any of the following\n\n\u2018F_CONTIGUOUS\u2019 (\u2018F\u2019) - ensure a Fortran-contiguous array\n\u2018C_CONTIGUOUS\u2019 (\u2018C\u2019) - ensure a C-contiguous array\n\u2018ALIGNED\u2019 (\u2018A\u2019)      - ensure a data-type aligned array\n\u2018WRITEABLE\u2019 (\u2018W\u2019)    - ensure a writable array\n\u2018OWNDATA\u2019 (\u2018O\u2019)      - ensure an array that owns its own data\n\u2018ENSUREARRAY\u2019, (\u2018E\u2019) - ensure a base array, instead of a subclass\n\n\n\n\nReturns\n\noutndarrayArray with specified requirements and type if given.\n\n\n\n\n\nSee also\n\nasarrayConvert input to an ndarray.\n\nasanyarrayConvert to an ndarray, but pass through ndarray subclasses.\n\nascontiguousarrayConvert input to a contiguous array.\n\nasfortranarrayConvert input to an ndarray with column-major memory order.\n\nndarray.flagsInformation about the memory layout of the array.\n\n\n\nNotes\nThe returned array will be guaranteed to have the listed requirements\nby making a copy if needed.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n&gt;&gt;&gt; y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n&gt;&gt;&gt; y.flags\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type", "requirementsstr or list of str", "Returns", "outndarray"], "returns": "outndarrayArray with specified requirements and type if given.", "examples": ["; x = np.arange(6).reshape(2,3)\n; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n", "; x = np.arange(6).reshape(2,3)\n; x.flags\n  C_CONTIGUOUS : True\n  F_CONTIGUOUS : False\n  OWNDATA : False\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n", "; y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n; y.flags\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n\n", "; y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])\n; y.flags\n  C_CONTIGUOUS : False\n  F_CONTIGUOUS : True\n  OWNDATA : True\n  WRITEABLE : True\n  ALIGNED : True\n  WRITEBACKIFCOPY : False\n  UPDATEIFCOPY : False\n"]},
{"library": "numpy", "item_id": "numpy.chararray.replace", "code": "\nchararray.replace(self, old, new, count=None)[source]\u00b6", "description": "For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.\n\nSee also\nchar.replace\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.replace", "code": "\nchararray.replace(self, old, new, count=None)\u00b6", "description": "For each element in self, return a copy of the string with all\noccurrences of substring old replaced by new.\n\nSee also\nchar.replace\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.replace", "code": "\nnumpy.char.replace(a, old, new, count=None)\u00b6", "description": "For each element in a, return a copy of the string with all\noccurrences of substring old replaced by new.\nCalls str.replace element-wise.\n\nParameters\n\naarray-like of str or unicode\nold, newstr or unicode\ncountint, optionalIf the optional argument count is given, only the first\ncount occurrences are replaced.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.replace\n\n", "parameters": ["Parameters", "aarray-like of str or unicode", "old, newstr or unicode", "countint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.matlib.repmat", "code": "\nnumpy.matlib.repmat(a, m, n)[source]\u00b6", "description": "Repeat a 0-D to 2-D array or matrix MxN times.\n\nParameters\n\naarray_likeThe array or matrix to be repeated.\n\nm, nintThe number of times a is repeated along the first and second axes.\n\n\n\nReturns\n\noutndarrayThe result of repeating a.\n\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; a0 = np.array(1)\n&gt;&gt;&gt; np.matlib.repmat(a0, 2, 3)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n\n&gt;&gt;&gt; a1 = np.arange(4)\n&gt;&gt;&gt; np.matlib.repmat(a1, 2, 2)\narray([[0, 1, 2, 3, 0, 1, 2, 3],\n       [0, 1, 2, 3, 0, 1, 2, 3]])\n\n\n&gt;&gt;&gt; a2 = np.asmatrix(np.arange(6).reshape(2, 3))\n&gt;&gt;&gt; np.matlib.repmat(a2, 2, 3)\nmatrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5],\n        [0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5]])\n\n\n", "parameters": ["Parameters", "aarray_like", "m, nint", "Returns", "outndarray"], "returns": "outndarrayThe result of repeating a.", "examples": ["; import numpy.matlib\n; a0 = np.array(1)\n; np.matlib.repmat(a0, 2, 3)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n", "; import numpy.matlib\n; a0 = np.array(1)\n; np.matlib.repmat(a0, 2, 3)\narray([[1, 1, 1],\n       [1, 1, 1]])\n", "; a1 = np.arange(4)\n; np.matlib.repmat(a1, 2, 2)\narray([[0, 1, 2, 3, 0, 1, 2, 3],\n       [0, 1, 2, 3, 0, 1, 2, 3]])\n\n", "; a1 = np.arange(4)\n; np.matlib.repmat(a1, 2, 2)\narray([[0, 1, 2, 3, 0, 1, 2, 3],\n       [0, 1, 2, 3, 0, 1, 2, 3]])\n", "; a2 = np.asmatrix(np.arange(6).reshape(2, 3))\n; np.matlib.repmat(a2, 2, 3)\nmatrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5],\n        [0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5]])\n\n", "; a2 = np.asmatrix(np.arange(6).reshape(2, 3))\n; np.matlib.repmat(a2, 2, 3)\nmatrix([[0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5],\n        [0, 1, 2, 0, 1, 2, 0, 1, 2],\n        [3, 4, 5, 3, 4, 5, 3, 4, 5]])\n"]},
{"library": "numpy", "item_id": "numpy.record.repeat", "code": "\nrecord.repeat()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.repeat", "code": "\nrecarray.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.repeat", "code": "\nndarray.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.repeat", "code": "\nMaskType.repeat()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.repeat", "code": "\nmemmap.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.repeat", "code": "\nmatrix.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.repeat", "code": "\nmasked_array.repeat(repeats, axis=None)[source]\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.repeat", "code": "\ngeneric.repeat()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.repeat", "code": "\nchararray.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.repeat", "code": "\nchararray.repeat(repeats, axis=None)\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.repeat", "code": "\nMaskedArray.repeat(repeats, axis=None)[source]\u00b6", "description": "Repeat elements of an array.\nRefer to numpy.repeat for full documentation.\n\nSee also\n\nnumpy.repeatequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.repeat", "code": "\nnumpy.repeat(a, repeats, axis=None)[source]\u00b6", "description": "Repeat elements of an array.\n\nParameters\n\naarray_likeInput array.\n\nrepeatsint or array of intsThe number of repetitions for each element.  repeats is broadcasted\nto fit the shape of the given axis.\n\naxisint, optionalThe axis along which to repeat values.  By default, use the\nflattened input array, and return a flat output array.\n\n\n\nReturns\n\nrepeated_arrayndarrayOutput array which has the same shape as a, except along\nthe given axis.\n\n\n\n\n\nSee also\n\ntileTile an array.\n\n\n\nExamples\n&gt;&gt;&gt; np.repeat(3, 4)\narray([3, 3, 3, 3])\n&gt;&gt;&gt; x = np.array([[1,2],[3,4]])\n&gt;&gt;&gt; np.repeat(x, 2)\narray([1, 1, 2, 2, 3, 3, 4, 4])\n&gt;&gt;&gt; np.repeat(x, 3, axis=1)\narray([[1, 1, 1, 2, 2, 2],\n       [3, 3, 3, 4, 4, 4]])\n&gt;&gt;&gt; np.repeat(x, [1, 2], axis=0)\narray([[1, 2],\n       [3, 4],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "aarray_like", "repeatsint or array of ints", "axisint, optional", "Returns", "repeated_arrayndarray"], "returns": "repeated_arrayndarrayOutput array which has the same shape as a, except alongthe given axis.", "examples": ["; np.repeat(3, 4)\narray([3, 3, 3, 3])\n; x = np.array([[1,2],[3,4]])\n; np.repeat(x, 2)\narray([1, 1, 2, 2, 3, 3, 4, 4])\n; np.repeat(x, 3, axis=1)\narray([[1, 1, 1, 2, 2, 2],\n       [3, 3, 3, 4, 4, 4]])\n; np.repeat(x, [1, 2], axis=0)\narray([[1, 2],\n       [3, 4],\n       [3, 4]])\n\n", "; np.repeat(3, 4)\narray([3, 3, 3, 3])\n; x = np.array([[1,2],[3,4]])\n; np.repeat(x, 2)\narray([1, 1, 2, 2, 3, 3, 4, 4])\n; np.repeat(x, 3, axis=1)\narray([[1, 1, 1, 2, 2, 2],\n       [3, 3, 3, 4, 4, 4]])\n; np.repeat(x, [1, 2], axis=0)\narray([[1, 2],\n       [3, 4],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.nditer.remove_multi_index", "code": "\nnditer.remove_multi_index()\u00b6", "description": "When the \u201cmulti_index\u201d flag was specified, this removes it, allowing\nthe internal iteration structure to be optimized further.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.remainder", "code": "\nnumpy.remainder(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'remainder'&gt;\u00b6", "description": "Return element-wise remainder of division.\nComputes the remainder complementary to the floor_divide function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor x2. The MATLAB function equivalent to np.remainder\nis mod.\n\nWarning\nThis should not be confused with:\n\nPython 3.7\u2019s math.remainder and C\u2019s remainder, which\ncomputes the IEEE remainder, which are the complement to\nround(x1 / x2).\nThe MATLAB rem function and or the C % operator which is the\ncomplement to int(x1 / x2).\n\n\n\nParameters\n\nx1array_likeDividend array.\n\nx2array_likeDivisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe element-wise remainder of the quotient floor_divide(x1, x2).\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfloor_divideEquivalent of Python // operator.\n\ndivmodSimultaneous floor division and remainder.\n\nfmodEquivalent of the MATLAB rem function.\n\n\ndivide, floor\n\nNotes\nReturns 0 when x2 is 0 and both x1 and x2 are (arrays of)\nintegers.\nmod is an alias of remainder.\nExamples\n&gt;&gt;&gt; np.remainder([4, 7], [2, 3])\narray([0, 1])\n&gt;&gt;&gt; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe element-wise remainder of the quotient floor_divide(x1, x2).This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.remainder([4, 7], [2, 3])\narray([0, 1])\n; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n", "; np.remainder([4, 7], [2, 3])\narray([0, 1])\n; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.nditer.remove_axis", "code": "\nnditer.remove_axis(i)\u00b6", "description": "Removes axis i from the iterator. Requires that the flag \u201cmulti_index\u201d\nbe enabled.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.real_if_close", "code": "\nnumpy.real_if_close(a, tol=100)[source]\u00b6", "description": "If complex input returns a real array if complex parts are close to zero.\n\u201cClose to zero\u201d is defined as tol * (machine epsilon of the type for\na).\n\nParameters\n\naarray_likeInput array.\n\ntolfloatTolerance in machine epsilons for the complex part of the elements\nin the array.\n\n\n\nReturns\n\noutndarrayIf a is real, the type of a is used for the output.  If a\nhas complex elements, the returned type is float.\n\n\n\n\n\nSee also\nreal, imag, angle\n\nNotes\nMachine epsilon varies from machine to machine and between data types\nbut Python floats on most platforms have a machine epsilon equal to\n2.2204460492503131e-16.  You can use \u2018np.finfo(float).eps\u2019 to print\nout the machine epsilon for floats.\nExamples\n&gt;&gt;&gt; np.finfo(float).eps\n2.2204460492503131e-16 # may vary\n\n\n&gt;&gt;&gt; np.real_if_close([2.1 + 4e-14j], tol=1000)\narray([2.1])\n&gt;&gt;&gt; np.real_if_close([2.1 + 4e-13j], tol=1000)\narray([2.1+4.e-13j])\n\n\n", "parameters": ["Parameters", "aarray_like", "tolfloat", "Returns", "outndarray"], "returns": "outndarrayIf a is real, the type of a is used for the output.  If ahas complex elements, the returned type is float.", "examples": ["; np.finfo(float).eps\n2.2204460492503131e-16 # may vary\n\n", "; np.finfo(float).eps\n2.2204460492503131e-16 # may vary\n", "; np.real_if_close([2.1 + 4e-14j], tol=1000)\narray([2.1])\n; np.real_if_close([2.1 + 4e-13j], tol=1000)\narray([2.1+4.e-13j])\n\n", "; np.real_if_close([2.1 + 4e-14j], tol=1000)\narray([2.1])\n; np.real_if_close([2.1 + 4e-13j], tol=1000)\narray([2.1+4.e-13j])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.real", "code": "\nproperty MaskedArray.real\u00b6", "description": "The real part of the masked array.\nThis property is a view on the real part of this MaskedArray.\n\nSee also\nimag\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.real", "code": "\nnumpy.real(val)[source]\u00b6", "description": "Return the real part of the complex argument.\n\nParameters\n\nvalarray_likeInput array.\n\n\n\nReturns\n\noutndarray or scalarThe real component of the complex argument. If val is real, the type\nof val is used for the output.  If val has complex elements, the\nreturned type is float.\n\n\n\n\n\nSee also\nreal_if_close, imag, angle\n\nExamples\n&gt;&gt;&gt; a = np.array([1+2j, 3+4j, 5+6j])\n&gt;&gt;&gt; a.real\narray([1.,  3.,  5.])\n&gt;&gt;&gt; a.real = 9\n&gt;&gt;&gt; a\narray([9.+2.j,  9.+4.j,  9.+6.j])\n&gt;&gt;&gt; a.real = np.array([9, 8, 7])\n&gt;&gt;&gt; a\narray([9.+2.j,  8.+4.j,  7.+6.j])\n&gt;&gt;&gt; np.real(1 + 1j)\n1.0\n\n\n", "parameters": ["Parameters", "valarray_like", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe real component of the complex argument. If val is real, the typeof val is used for the output.  If val has complex elements, thereturned type is float.", "examples": ["; a = np.array([1+2j, 3+4j, 5+6j])\n; a.real\narray([1.,  3.,  5.])\n; a.real = 9\n; a\narray([9.+2.j,  9.+4.j,  9.+6.j])\n; a.real = np.array([9, 8, 7])\n; a\narray([9.+2.j,  8.+4.j,  7.+6.j])\n; np.real(1 + 1j)\n1.0\n\n", "; a = np.array([1+2j, 3+4j, 5+6j])\n; a.real\narray([1.,  3.,  5.])\n; a.real = 9\n; a\narray([9.+2.j,  9.+4.j,  9.+6.j])\n; a.real = np.array([9, 8, 7])\n; a\narray([9.+2.j,  8.+4.j,  7.+6.j])\n; np.real(1 + 1j)\n1.0\n"]},
{"library": "numpy", "item_id": "numpy.record.real", "code": "\nrecord.real\u00b6", "description": "real part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.real", "code": "\nproperty masked_array.real\u00b6", "description": "The real part of the masked array.\nThis property is a view on the real part of this MaskedArray.\n\nSee also\nimag\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.recarray.real", "code": "\nrecarray.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.real", "code": "\nndarray.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.matrix.real", "code": "\nmatrix.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.real", "code": "\nMaskType.real\u00b6", "description": "real part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.real", "code": "\nmemmap.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.chararray.real", "code": "\nchararray.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.generic.real", "code": "\ngeneric.real\u00b6", "description": "real part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.rayleigh", "code": "\nRandomState.rayleigh(scale=1.0, size=None)\u00b6", "description": "Draw samples from a Rayleigh distribution.\nThe  and Weibull distributions are generalizations of the\nRayleigh.\n\nNote\nNew code should use the rayleigh method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nscalefloat or array_like of floats, optionalScale, also equals the mode. Must be non-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Rayleigh distribution.\n\n\n\n\n\nSee also\n\nGenerator.rayleighwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the Rayleigh distribution is\n\n\nThe Rayleigh distribution would arise, for example, if the East\nand North components of the wind velocity had identical zero-mean\nGaussian distributions.  Then the wind speed would have a Rayleigh\ndistribution.\nReferences\n\n1\nBrighton Webs Ltd., \u201cRayleigh Distribution,\u201d\nhttps://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp\n\n2\nWikipedia, \u201cRayleigh distribution\u201d\nhttps://en.wikipedia.org/wiki/Rayleigh_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n\n\nWave heights tend to follow a Rayleigh distribution. If the mean wave\nheight is 1 meter, what fraction of waves are likely to be larger than 3\nmeters?\n&gt;&gt;&gt; meanvalue = 1\n&gt;&gt;&gt; modevalue = np.sqrt(2 / np.pi) * meanvalue\n&gt;&gt;&gt; s = np.random.rayleigh(modevalue, 1000000)\n\n\nThe percentage of waves larger than 3 meters is:\n&gt;&gt;&gt; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Rayleigh distribution.", "examples": ["; from matplotlib.pyplot import hist\n; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n\n", "; from matplotlib.pyplot import hist\n; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = np.random.rayleigh(modevalue, 1000000)\n\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = np.random.rayleigh(modevalue, 1000000)\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.real", "code": "\nchararray.real\u00b6", "description": "The real part of the array.\n\nSee also\n\nnumpy.realequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.real\narray([ 1.        ,  0.70710678])\n&gt;&gt;&gt; x.real.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.real\narray([ 1.        ,  0.70710678])\n; x.real.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.ravel_multi_index", "code": "\nnumpy.ravel_multi_index(multi_index, dims, mode='raise', order='C')\u00b6", "description": "Converts a tuple of index arrays into an array of flat\nindices, applying boundary modes to the multi-index.\n\nParameters\n\nmulti_indextuple of array_likeA tuple of integer arrays, one array for each dimension.\n\ndimstuple of intsThe shape of array into which the indices from multi_index apply.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices are handled.  Can specify\neither one mode or a tuple of modes, one mode per index.\n\n\u2018raise\u2019 \u2013 raise an error (default)\n\u2018wrap\u2019 \u2013 wrap around\n\u2018clip\u2019 \u2013 clip to the range\n\nIn \u2018clip\u2019 mode, a negative index which would normally\nwrap will clip to 0 instead.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalDetermines whether the multi-index should be viewed as\nindexing in row-major (C-style) or column-major\n(Fortran-style) order.\n\n\n\nReturns\n\nraveled_indicesndarrayAn array of indices into the flattened version of an array\nof dimensions dims.\n\n\n\n\n\nSee also\nunravel_index\n\nNotes\n\nNew in version 1.6.0.\n\nExamples\n&gt;&gt;&gt; arr = np.array([[3,6,6],[4,5,1]])\n&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6))\narray([22, 41, 37])\n&gt;&gt;&gt; np.ravel_multi_index(arr, (7,6), order='F')\narray([31, 41, 13])\n&gt;&gt;&gt; np.ravel_multi_index(arr, (4,6), mode='clip')\narray([22, 23, 19])\n&gt;&gt;&gt; np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\narray([12, 13, 13])\n\n\n&gt;&gt;&gt; np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n1621\n\n\n", "parameters": ["Parameters", "multi_indextuple of array_like", "dimstuple of ints", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "raveled_indicesndarray"], "returns": "raveled_indicesndarrayAn array of indices into the flattened version of an arrayof dimensions dims.", "examples": ["; arr = np.array([[3,6,6],[4,5,1]])\n; np.ravel_multi_index(arr, (7,6))\narray([22, 41, 37])\n; np.ravel_multi_index(arr, (7,6), order='F')\narray([31, 41, 13])\n; np.ravel_multi_index(arr, (4,6), mode='clip')\narray([22, 23, 19])\n; np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\narray([12, 13, 13])\n\n", "; arr = np.array([[3,6,6],[4,5,1]])\n; np.ravel_multi_index(arr, (7,6))\narray([22, 41, 37])\n; np.ravel_multi_index(arr, (7,6), order='F')\narray([31, 41, 13])\n; np.ravel_multi_index(arr, (4,6), mode='clip')\narray([22, 23, 19])\n; np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))\narray([12, 13, 13])\n", "; np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n1621\n\n", "; np.ravel_multi_index((3,1,4,1), (6,7,8,9))\n1621\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.rayleigh", "code": "\nGenerator.rayleigh(scale=1.0, size=None)\u00b6", "description": "Draw samples from a Rayleigh distribution.\nThe  and Weibull distributions are generalizations of the\nRayleigh.\n\nParameters\n\nscalefloat or array_like of floats, optionalScale, also equals the mode. Must be non-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Rayleigh distribution.\n\n\n\n\nNotes\nThe probability density function for the Rayleigh distribution is\n\n\nThe Rayleigh distribution would arise, for example, if the East\nand North components of the wind velocity had identical zero-mean\nGaussian distributions.  Then the wind speed would have a Rayleigh\ndistribution.\nReferences\n\n1\nBrighton Webs Ltd., \u201cRayleigh Distribution,\u201d\nhttps://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp\n\n2\nWikipedia, \u201cRayleigh distribution\u201d\nhttps://en.wikipedia.org/wiki/Rayleigh_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; values = hist(rng.rayleigh(3, 100000), bins=200, density=True)\n\n\nWave heights tend to follow a Rayleigh distribution. If the mean wave\nheight is 1 meter, what fraction of waves are likely to be larger than 3\nmeters?\n&gt;&gt;&gt; meanvalue = 1\n&gt;&gt;&gt; modevalue = np.sqrt(2 / np.pi) * meanvalue\n&gt;&gt;&gt; s = rng.rayleigh(modevalue, 1000000)\n\n\nThe percentage of waves larger than 3 meters is:\n&gt;&gt;&gt; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Rayleigh distribution.", "examples": ["; from matplotlib.pyplot import hist\n; rng = np.random.default_rng()\n; values = hist(rng.rayleigh(3, 100000), bins=200, density=True)\n\n", "; from matplotlib.pyplot import hist\n; rng = np.random.default_rng()\n; values = hist(rng.rayleigh(3, 100000), bins=200, density=True)\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = rng.rayleigh(modevalue, 1000000)\n\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = rng.rayleigh(modevalue, 1000000)\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n"]},
{"library": "numpy", "item_id": "numpy.record.ravel", "code": "\nrecord.ravel()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.ravel", "code": "\nrecarray.ravel([order])\u00b6", "description": "Return a flattened array.\nRefer to numpy.ravel for full documentation.\n\nSee also\n\nnumpy.ravelequivalent function\n\nndarray.flata flat iterator on the array.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.rayleigh", "code": "\nnumpy.random.rayleigh(scale=1.0, size=None)\u00b6", "description": "Draw samples from a Rayleigh distribution.\nThe  and Weibull distributions are generalizations of the\nRayleigh.\n\nNote\nNew code should use the rayleigh method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nscalefloat or array_like of floats, optionalScale, also equals the mode. Must be non-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Rayleigh distribution.\n\n\n\n\n\nSee also\n\nGenerator.rayleighwhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the Rayleigh distribution is\n\n\nThe Rayleigh distribution would arise, for example, if the East\nand North components of the wind velocity had identical zero-mean\nGaussian distributions.  Then the wind speed would have a Rayleigh\ndistribution.\nReferences\n\n1\nBrighton Webs Ltd., \u201cRayleigh Distribution,\u201d\nhttps://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp\n\n2\nWikipedia, \u201cRayleigh distribution\u201d\nhttps://en.wikipedia.org/wiki/Rayleigh_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n\n\nWave heights tend to follow a Rayleigh distribution. If the mean wave\nheight is 1 meter, what fraction of waves are likely to be larger than 3\nmeters?\n&gt;&gt;&gt; meanvalue = 1\n&gt;&gt;&gt; modevalue = np.sqrt(2 / np.pi) * meanvalue\n&gt;&gt;&gt; s = np.random.rayleigh(modevalue, 1000000)\n\n\nThe percentage of waves larger than 3 meters is:\n&gt;&gt;&gt; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Rayleigh distribution.", "examples": ["; from matplotlib.pyplot import hist\n; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n\n", "; from matplotlib.pyplot import hist\n; values = hist(np.random.rayleigh(3, 100000), bins=200, density=True)\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = np.random.rayleigh(modevalue, 1000000)\n\n", "; meanvalue = 1\n; modevalue = np.sqrt(2 / np.pi) * meanvalue\n; s = np.random.rayleigh(modevalue, 1000000)\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n\n", "; 100.*sum(s&gt;3)/1000000.\n0.087300000000000003 # random\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.ravel", "code": "\nndarray.ravel([order])\u00b6", "description": "Return a flattened array.\nRefer to numpy.ravel for full documentation.\n\nSee also\n\nnumpy.ravelequivalent function\n\nndarray.flata flat iterator on the array.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.ravel", "code": "\nmemmap.ravel([order])\u00b6", "description": "Return a flattened array.\nRefer to numpy.ravel for full documentation.\n\nSee also\n\nnumpy.ravelequivalent function\n\nndarray.flata flat iterator on the array.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.ravel", "code": "\nmatrix.ravel(self, order='C')[source]\u00b6", "description": "Return a flattened matrix.\nRefer to numpy.ravel for more documentation.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalThe elements of m are read using this index order. \u2018C\u2019 means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n\u2018F\u2019 means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the \u2018C\u2019 and \u2018F\u2019 options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  \u2018A\u2019 means to read the elements in Fortran-like\nindex order if m is Fortran contiguous in memory, C-like order\notherwise.  \u2018K\u2019 means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, \u2018C\u2019 index order is used.\n\n\n\nReturns\n\nretmatrixReturn the matrix flattened to shape (1, N) where N\nis the number of elements in the original matrix.\nA copy is made only if necessary.\n\n\n\n\n\nSee also\n\nmatrix.flattenreturns a similar output matrix but always a copy\n\nmatrix.flata flat iterator on the array.\n\nnumpy.ravelrelated function which returns an ndarray\n\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "retmatrix"], "returns": "retmatrixReturn the matrix flattened to shape (1, N) where Nis the number of elements in the original matrix.A copy is made only if necessary.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.ravel", "code": "\nMaskType.ravel()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.ravel", "code": "\nMaskedArray.ravel(self, order='C')[source]\u00b6", "description": "Returns a 1D version of self, as a view.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalThe elements of a are read using this index order. \u2018C\u2019 means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n\u2018F\u2019 means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the \u2018C\u2019 and \u2018F\u2019 options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  \u2018A\u2019 means to read the elements in Fortran-like\nindex order if m is Fortran contiguous in memory, C-like order\notherwise.  \u2018K\u2019 means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, \u2018C\u2019 index order is used.\n\n\n\nReturns\n\nMaskedArrayOutput view is of shape (self.size,) (or\n(np.ma.product(self.shape),)).\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "MaskedArray"], "returns": "MaskedArrayOutput view is of shape (self.size,) (or(np.ma.product(self.shape),)).", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.ravel", "code": "\nmasked_array.ravel(self, order='C')[source]\u00b6", "description": "Returns a 1D version of self, as a view.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalThe elements of a are read using this index order. \u2018C\u2019 means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n\u2018F\u2019 means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the \u2018C\u2019 and \u2018F\u2019 options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  \u2018A\u2019 means to read the elements in Fortran-like\nindex order if m is Fortran contiguous in memory, C-like order\notherwise.  \u2018K\u2019 means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, \u2018C\u2019 index order is used.\n\n\n\nReturns\n\nMaskedArrayOutput view is of shape (self.size,) (or\n(np.ma.product(self.shape),)).\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "MaskedArray"], "returns": "MaskedArrayOutput view is of shape (self.size,) (or(np.ma.product(self.shape),)).", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.generic.ravel", "code": "\ngeneric.ravel()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.ravel", "code": "\nchararray.ravel([order])\u00b6", "description": "Return a flattened array.\nRefer to numpy.ravel for full documentation.\n\nSee also\n\nnumpy.ravelequivalent function\n\nndarray.flata flat iterator on the array.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ravel", "code": "\nnumpy.ravel(a, order='C')[source]\u00b6", "description": "Return a contiguous flattened array.\nA 1-D array, containing the elements of the input, is returned.  A copy is\nmade only if needed.\nAs of NumPy 1.10, the returned array will have the same type as the input\narray. (for example, a masked array will be returned for a masked array\ninput)\n\nParameters\n\naarray_likeInput array.  The elements in a are read in the order specified by\norder, and packed as a 1-D array.\n\norder{\u2018C\u2019,\u2019F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalThe elements of a are read using this index order. \u2018C\u2019 means\nto index the elements in row-major, C-style order,\nwith the last axis index changing fastest, back to the first\naxis index changing slowest.  \u2018F\u2019 means to index the elements\nin column-major, Fortran-style order, with the\nfirst index changing fastest, and the last index changing\nslowest. Note that the \u2018C\u2019 and \u2018F\u2019 options take no account of\nthe memory layout of the underlying array, and only refer to\nthe order of axis indexing.  \u2018A\u2019 means to read the elements in\nFortran-like index order if a is Fortran contiguous in\nmemory, C-like order otherwise.  \u2018K\u2019 means to read the\nelements in the order they occur in memory, except for\nreversing the data when strides are negative.  By default, \u2018C\u2019\nindex order is used.\n\n\n\nReturns\n\nyarray_likey is an array of the same subtype as a, with shape (a.size,).\nNote that matrices are special cased for backward compatibility, if a\nis a matrix, then y is a 1-D ndarray.\n\n\n\n\n\nSee also\n\nndarray.flat1-D iterator over an array.\n\nndarray.flatten1-D array copy of the elements of an array in row-major order.\n\nndarray.reshapeChange the shape of an array without changing its data.\n\n\n\nNotes\nIn row-major, C-style order, in two dimensions, the row index\nvaries the slowest, and the column index the quickest.  This can\nbe generalized to multiple dimensions, where row-major order\nimplies that the index along the first axis varies slowest, and\nthe index along the last quickest.  The opposite holds for\ncolumn-major, Fortran-style index ordering.\nWhen a view is desired in as many cases as possible, arr.reshape(-1)\nmay be preferable.\nExamples\nIt is equivalent to reshape(-1, order=order).\n&gt;&gt;&gt; x = np.array([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; np.ravel(x)\narray([1, 2, 3, 4, 5, 6])\n\n\n&gt;&gt;&gt; x.reshape(-1)\narray([1, 2, 3, 4, 5, 6])\n\n\n&gt;&gt;&gt; np.ravel(x, order='F')\narray([1, 4, 2, 5, 3, 6])\n\n\nWhen order is \u2018A\u2019, it will preserve the array\u2019s \u2018C\u2019 or \u2018F\u2019 ordering:\n&gt;&gt;&gt; np.ravel(x.T)\narray([1, 4, 2, 5, 3, 6])\n&gt;&gt;&gt; np.ravel(x.T, order='A')\narray([1, 2, 3, 4, 5, 6])\n\n\nWhen order is \u2018K\u2019, it will preserve orderings that are neither \u2018C\u2019\nnor \u2018F\u2019, but won\u2019t reverse axes:\n&gt;&gt;&gt; a = np.arange(3)[::-1]; a\narray([2, 1, 0])\n&gt;&gt;&gt; a.ravel(order='C')\narray([2, 1, 0])\n&gt;&gt;&gt; a.ravel(order='K')\narray([2, 1, 0])\n\n\n&gt;&gt;&gt; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\narray([[[ 0,  2,  4],\n        [ 1,  3,  5]],\n       [[ 6,  8, 10],\n        [ 7,  9, 11]]])\n&gt;&gt;&gt; a.ravel(order='C')\narray([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n&gt;&gt;&gt; a.ravel(order='K')\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n\n", "parameters": ["Parameters", "aarray_like", "order{\u2018C\u2019,\u2019F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yarray_like"], "returns": "yarray_likey is an array of the same subtype as a, with shape (a.size,).Note that matrices are special cased for backward compatibility, if ais a matrix, then y is a 1-D ndarray.", "examples": ["; x = np.array([[1, 2, 3], [4, 5, 6]])\n; np.ravel(x)\narray([1, 2, 3, 4, 5, 6])\n\n", "; x = np.array([[1, 2, 3], [4, 5, 6]])\n; np.ravel(x)\narray([1, 2, 3, 4, 5, 6])\n", "; x.reshape(-1)\narray([1, 2, 3, 4, 5, 6])\n\n", "; x.reshape(-1)\narray([1, 2, 3, 4, 5, 6])\n", "; np.ravel(x, order='F')\narray([1, 4, 2, 5, 3, 6])\n\n", "; np.ravel(x, order='F')\narray([1, 4, 2, 5, 3, 6])\n", "; np.ravel(x.T)\narray([1, 4, 2, 5, 3, 6])\n; np.ravel(x.T, order='A')\narray([1, 2, 3, 4, 5, 6])\n\n", "; np.ravel(x.T)\narray([1, 4, 2, 5, 3, 6])\n; np.ravel(x.T, order='A')\narray([1, 2, 3, 4, 5, 6])\n", "; a = np.arange(3)[::-1]; a\narray([2, 1, 0])\n; a.ravel(order='C')\narray([2, 1, 0])\n; a.ravel(order='K')\narray([2, 1, 0])\n\n", "; a = np.arange(3)[::-1]; a\narray([2, 1, 0])\n; a.ravel(order='C')\narray([2, 1, 0])\n; a.ravel(order='K')\narray([2, 1, 0])\n", "; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\narray([[[ 0,  2,  4],\n        [ 1,  3,  5]],\n       [[ 6,  8, 10],\n        [ 7,  9, 11]]])\n; a.ravel(order='C')\narray([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n; a.ravel(order='K')\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n\n", "; a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a\narray([[[ 0,  2,  4],\n        [ 1,  3,  5]],\n       [[ 6,  8, 10],\n        [ 7,  9, 11]]])\n; a.ravel(order='C')\narray([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])\n; a.ravel(order='K')\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])\n"]},
{"library": "numpy", "item_id": "numpy.rate", "code": "\nnumpy.rate(nper, pmt, pv, fv, when='end', guess=None, tol=None, maxiter=100)[source]\u00b6", "description": "Compute the rate of interest per period.\n\nDeprecated since version 1.18: rate is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nParameters\n\nnperarray_likeNumber of compounding periods\n\npmtarray_likePayment\n\npvarray_likePresent value\n\nfvarray_likeFuture value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optionalWhen payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0))\n\nguessNumber, optionalStarting guess for solving the rate of interest, default 0.1\n\ntolNumber, optionalRequired tolerance for the solution, default 1e-6\n\nmaxiterint, optionalMaximum iterations in finding the solution\n\n\n\n\nNotes\nThe rate of interest is computed by iteratively solving the\n(non-linear) equation:\nfv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0\n\n\nfor rate.\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nWheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\nOpen Document Format for Office Applications (OpenDocument)v1.2,\nPart 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\nPre-Draft 12. Organization for the Advancement of Structured Information\nStandards (OASIS). Billerica, MA, USA. [ODT Document].\nAvailable:\nhttp://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\nOpenDocument-formula-20090508.odt\n\n\n", "parameters": ["Parameters", "nperarray_like", "pmtarray_like", "pvarray_like", "fvarray_like", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optional", "guessNumber, optional", "tolNumber, optional", "maxiterint, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.ravel", "code": "\nnumpy.ma.ravel(self, order='C') = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns a 1D version of self, as a view.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalThe elements of a are read using this index order. \u2018C\u2019 means to\nindex the elements in C-like order, with the last axis index\nchanging fastest, back to the first axis index changing slowest.\n\u2018F\u2019 means to index the elements in Fortran-like index order, with\nthe first index changing fastest, and the last index changing\nslowest. Note that the \u2018C\u2019 and \u2018F\u2019 options take no account of the\nmemory layout of the underlying array, and only refer to the order\nof axis indexing.  \u2018A\u2019 means to read the elements in Fortran-like\nindex order if m is Fortran contiguous in memory, C-like order\notherwise.  \u2018K\u2019 means to read the elements in the order they occur\nin memory, except for reversing the data when strides are negative.\nBy default, \u2018C\u2019 index order is used.\n\n\n\nReturns\n\nMaskedArrayOutput view is of shape (self.size,) (or\n(np.ma.product(self.shape),)).\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "MaskedArray"], "returns": "MaskedArrayOutput view is of shape (self.size,) (or(np.ma.product(self.shape),)).", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.ravel()\nmasked_array(data=[1, --, 3, --, 5, --, 7, --, 9],\n             mask=[False,  True, False,  True, False,  True, False,  True,\n                   False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.ravel", "code": "\nchararray.ravel([order])\u00b6", "description": "Return a flattened array.\nRefer to numpy.ravel for full documentation.\n\nSee also\n\nnumpy.ravelequivalent function\n\nndarray.flata flat iterator on the array.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.ranf", "code": "\nnumpy.random.ranf()\u00b6", "description": "This is an alias of random_sample. See random_sample  for the complete\ndocumentation.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.RankWarning", "code": "\nexception numpy.polynomial.polyutils.RankWarning[source]\u00b6", "description": "Issued by chebfit when the design matrix is rank deficient.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState", "code": "\nclass numpy.random.RandomState(seed=None)\u00b6", "description": "Container for the slow Mersenne Twister pseudo-random number generator.\nConsider using a different BitGenerator with the Generator container\ninstead.\nRandomState and Generator expose a number of methods for generating\nrandom numbers drawn from a variety of probability distributions. In\naddition to the distribution-specific arguments, each method takes a\nkeyword argument size that defaults to None. If size is None,\nthen a single value is generated and returned. If size is an integer,\nthen a 1-D array filled with generated values is returned. If size is a\ntuple, then an array with that shape is filled and returned.\nCompatibility Guarantee\nA fixed bit generator using a fixed seed and a fixed series of calls to\n\u2018RandomState\u2019 methods using the same parameters will always produce the\nsame results up to roundoff error except when the values were incorrect.\nRandomState is effectively frozen and will only receive updates that\nare required by changes in the the internals of Numpy. More substantial\nchanges, including algorithmic improvements, are reserved for\nGenerator.\n\nParameters\n\nseed{None, int, array_like, BitGenerator}, optionalRandom seed used to initialize the pseudo-random number generator or\nan instantized BitGenerator.  If an integer or array, used as a seed for\nthe MT19937 BitGenerator. Values can be any integer between 0 and\n2**32 - 1 inclusive, an array (or other sequence) of such integers,\nor None (the default).  If seed is None, then the MT19937\nBitGenerator is initialized by reading data from /dev/urandom\n(or the Windows analogue) if available or seed from the clock\notherwise.\n\n\n\n\n\nSee also\nGenerator, MT19937, numpy.random.BitGenerator\n\nNotes\nThe Python stdlib module \u201crandom\u201d also contains a Mersenne Twister\npseudo-random number generator with a number of methods that are similar\nto the ones available in RandomState. RandomState, besides being\nNumPy-aware, has the advantage that it provides a much larger number\nof probability distributions to choose from.\n", "parameters": ["Parameters", "seed{None, int, array_like, BitGenerator}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.random_sample", "code": "\nRandomState.random_sample(size=None)\u00b6", "description": "Return random floats in the half-open interval [0.0, 1.0).\nResults are from the \u201ccontinuous uniform\u201d distribution over the\nstated interval.  To sample  multiply\nthe output of random_sample by (b-a) and add a:\n(b - a) * random_sample() + a\n\n\n\nNote\nNew code should use the random method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in which\ncase a single float is returned).\n\n\n\n\n\nSee also\n\nGenerator.randomwhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.random_sample()\n0.47108547995356098 # random\n&gt;&gt;&gt; type(np.random.random_sample())\n&lt;class 'float'&gt;\n&gt;&gt;&gt; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n\nThree-by-two array of random numbers from [-5, 0):\n&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray of floats"], "returns": "outfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in whichcase a single float is returned).", "examples": ["; np.random.random_sample()\n0.47108547995356098 # random\n; type(np.random.random_sample())\n&lt;class 'float'&gt;\n; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n", "; np.random.random_sample()\n0.47108547995356098 # random\n; type(np.random.random_sample())\n&lt;class 'float'&gt;\n; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n", "; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n", "; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n"]},
{"library": "numpy", "item_id": "numpy.RankWarning", "code": "\nexception numpy.RankWarning[source]\u00b6", "description": "Issued by polyfit when the Vandermonde matrix is rank deficient.\nFor more information, a way to suppress the warning, and an example of\nRankWarning being issued, see polyfit.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.random_sample", "code": "\nnumpy.random.random_sample(size=None)\u00b6", "description": "Return random floats in the half-open interval [0.0, 1.0).\nResults are from the \u201ccontinuous uniform\u201d distribution over the\nstated interval.  To sample  multiply\nthe output of random_sample by (b-a) and add a:\n(b - a) * random_sample() + a\n\n\n\nNote\nNew code should use the random method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in which\ncase a single float is returned).\n\n\n\n\n\nSee also\n\nGenerator.randomwhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.random_sample()\n0.47108547995356098 # random\n&gt;&gt;&gt; type(np.random.random_sample())\n&lt;class 'float'&gt;\n&gt;&gt;&gt; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n\nThree-by-two array of random numbers from [-5, 0):\n&gt;&gt;&gt; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "Returns", "outfloat or ndarray of floats"], "returns": "outfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in whichcase a single float is returned).", "examples": ["; np.random.random_sample()\n0.47108547995356098 # random\n; type(np.random.random_sample())\n&lt;class 'float'&gt;\n; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n", "; np.random.random_sample()\n0.47108547995356098 # random\n; type(np.random.random_sample())\n&lt;class 'float'&gt;\n; np.random.random_sample((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n", "; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n", "; 5 * np.random.random_sample((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n"]},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.random_raw", "code": "\nBitGenerator.random_raw(self, size=None)\u00b6", "description": "Return randoms as generated by the underlying BitGenerator\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\noutputbool, optionalOutput values.  Used for performance testing since the generated\nvalues are not returned.\n\n\n\nReturns\n\noutuint or ndarrayDrawn samples.\n\n\n\n\nNotes\nThis method directly exposes the the raw underlying pseudo-random\nnumber generator. All values are returned as unsigned 64-bit\nvalues irrespective of the number of bits produced by the PRNG.\nSee the class docstring for the number of bits returned.\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "outputbool, optional", "Returns", "outuint or ndarray"], "returns": "outuint or ndarrayDrawn samples.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.random_integers", "code": "\nRandomState.random_integers(low, high=None, size=None)\u00b6", "description": "Random integers of type np.int_ between low and high, inclusive.\nReturn random integers of type np.int_ from the \u201cdiscrete uniform\u201d\ndistribution in the closed interval [low, high].  If high is\nNone (the default), then results are from [1, low]. The np.int_\ntype translates to the C long integer type and its precision\nis platform dependent.\nThis function has been deprecated. Use randint instead.\n\nDeprecated since version 1.11.0.\n\n\nParameters\n\nlowintLowest (signed) integer to be drawn from the distribution (unless\nhigh=None, in which case this parameter is the highest such\ninteger).\n\nhighint, optionalIf provided, the largest (signed) integer to be drawn from the\ndistribution (see above for behavior if high=None).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutint or ndarray of intssize-shaped array of random integers from the appropriate\ndistribution, or a single such random int if size not provided.\n\n\n\n\n\nSee also\n\nrandintSimilar to random_integers, only for the half-open interval [low, high), and 0 is the lowest value if high is omitted.\n\n\n\nNotes\nTo sample from N evenly spaced floating-point numbers between a and b,\nuse:\na + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)\n\n\nExamples\n&gt;&gt;&gt; np.random.random_integers(5)\n4 # random\n&gt;&gt;&gt; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n&gt;&gt;&gt; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n\n\nChoose five random numbers from the set of five evenly-spaced\nnumbers between 0 and 2.5, inclusive (i.e., from the set\n):\n&gt;&gt;&gt; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n\n\nRoll two six sided dice 1000 times and sum the results:\n&gt;&gt;&gt; d1 = np.random.random_integers(1, 6, 1000)\n&gt;&gt;&gt; d2 = np.random.random_integers(1, 6, 1000)\n&gt;&gt;&gt; dsums = d1 + d2\n\n\nDisplay results as a histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(dsums, 11, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "lowint", "highint, optional", "sizeint or tuple of ints, optional", "Returns", "outint or ndarray of ints"], "returns": "outint or ndarray of intssize-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.", "examples": ["; np.random.random_integers(5)\n4 # random\n; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n\n", "; np.random.random_integers(5)\n4 # random\n; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n", "; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n\n", "; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n", "; d1 = np.random.random_integers(1, 6, 1000)\n; d2 = np.random.random_integers(1, 6, 1000)\n; dsums = d1 + d2\n\n", "; d1 = np.random.random_integers(1, 6, 1000)\n; d2 = np.random.random_integers(1, 6, 1000)\n; dsums = d1 + d2\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(dsums, 11, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(dsums, 11, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.random_integers", "code": "\nnumpy.random.random_integers(low, high=None, size=None)\u00b6", "description": "Random integers of type np.int_ between low and high, inclusive.\nReturn random integers of type np.int_ from the \u201cdiscrete uniform\u201d\ndistribution in the closed interval [low, high].  If high is\nNone (the default), then results are from [1, low]. The np.int_\ntype translates to the C long integer type and its precision\nis platform dependent.\nThis function has been deprecated. Use randint instead.\n\nDeprecated since version 1.11.0.\n\n\nParameters\n\nlowintLowest (signed) integer to be drawn from the distribution (unless\nhigh=None, in which case this parameter is the highest such\ninteger).\n\nhighint, optionalIf provided, the largest (signed) integer to be drawn from the\ndistribution (see above for behavior if high=None).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutint or ndarray of intssize-shaped array of random integers from the appropriate\ndistribution, or a single such random int if size not provided.\n\n\n\n\n\nSee also\n\nrandintSimilar to random_integers, only for the half-open interval [low, high), and 0 is the lowest value if high is omitted.\n\n\n\nNotes\nTo sample from N evenly spaced floating-point numbers between a and b,\nuse:\na + (b - a) * (np.random.random_integers(N) - 1) / (N - 1.)\n\n\nExamples\n&gt;&gt;&gt; np.random.random_integers(5)\n4 # random\n&gt;&gt;&gt; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n&gt;&gt;&gt; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n\n\nChoose five random numbers from the set of five evenly-spaced\nnumbers between 0 and 2.5, inclusive (i.e., from the set\n):\n&gt;&gt;&gt; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n\n\nRoll two six sided dice 1000 times and sum the results:\n&gt;&gt;&gt; d1 = np.random.random_integers(1, 6, 1000)\n&gt;&gt;&gt; d2 = np.random.random_integers(1, 6, 1000)\n&gt;&gt;&gt; dsums = d1 + d2\n\n\nDisplay results as a histogram:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(dsums, 11, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "lowint", "highint, optional", "sizeint or tuple of ints, optional", "Returns", "outint or ndarray of ints"], "returns": "outint or ndarray of intssize-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.", "examples": ["; np.random.random_integers(5)\n4 # random\n; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n\n", "; np.random.random_integers(5)\n4 # random\n; type(np.random.random_integers(5))\n&lt;class 'numpy.int64'&gt;\n; np.random.random_integers(5, size=(3,2))\narray([[5, 4], # random\n       [3, 3],\n       [4, 5]])\n", "; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n\n", "; 2.5 * (np.random.random_integers(5, size=(5,)) - 1) / 4.\narray([ 0.625,  1.25 ,  0.625,  0.625,  2.5  ]) # random\n", "; d1 = np.random.random_integers(1, 6, 1000)\n; d2 = np.random.random_integers(1, 6, 1000)\n; dsums = d1 + d2\n\n", "; d1 = np.random.random_integers(1, 6, 1000)\n; d2 = np.random.random_integers(1, 6, 1000)\n; dsums = d1 + d2\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(dsums, 11, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(dsums, 11, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.randn", "code": "\nRandomState.randn(d0, d1, ..., dn)\u00b6", "description": "Return a sample (or samples) from the \u201cstandard normal\u201d distribution.\n\nNote\nThis is a convenience function for users porting code from Matlab,\nand wraps standard_normal. That function takes a\ntuple to specify the size of the output, which is consistent with\nother NumPy functions like numpy.zeros and numpy.ones.\n\n\nNote\nNew code should use the standard_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\nIf positive int_like arguments are provided, randn generates an array\nof shape (d0, d1, ..., dn), filled\nwith random floats sampled from a univariate \u201cnormal\u201d (Gaussian)\ndistribution of mean 0 and variance 1. A single float randomly sampled\nfrom the distribution is returned if no argument is provided.\n\nParameters\n\nd0, d1, \u2026, dnint, optionalThe dimensions of the returned array, must be non-negative.\nIf no argument is given a single Python float is returned.\n\n\n\nReturns\n\nZndarray or floatA (d0, d1, ..., dn)-shaped array of floating-point samples from\nthe standard normal distribution, or a single such float if\nno parameters were supplied.\n\n\n\n\n\nSee also\n\nstandard_normalSimilar, but takes a tuple as its argument.\n\nnormalAlso accepts mu and sigma arguments.\n\nGenerator.standard_normalwhich should be used for new code.\n\n\n\nNotes\nFor random samples from , use:\nsigma * np.random.randn(...) + mu\nExamples\n&gt;&gt;&gt; np.random.randn()\n2.1923875335537315  # random\n\n\nTwo-by-four array of samples from N(3, 6.25):\n&gt;&gt;&gt; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "d0, d1, \u2026, dnint, optional", "Returns", "Zndarray or float"], "returns": "Zndarray or floatA (d0, d1, ..., dn)-shaped array of floating-point samples fromthe standard normal distribution, or a single such float ifno parameters were supplied.", "examples": ["; np.random.randn()\n2.1923875335537315  # random\n\n", "; np.random.randn()\n2.1923875335537315  # random\n", "; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.random", "code": "\nGenerator.random(size=None, dtype=np.float64, out=None)\u00b6", "description": "Return random floats in the half-open interval [0.0, 1.0).\nResults are from the \u201ccontinuous uniform\u201d distribution over the\nstated interval.  To sample  multiply\nthe output of random by (b-a) and add a:\n(b - a) * random() + a\n\n\n\nParameters\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result, only float64 and float32 are supported.\nByteorder must be native. The default value is np.float64.\n\noutndarray, optionalAlternative output array in which to place the result. If size is not None,\nit must have the same shape as the provided size and must match the type of\nthe output values.\n\n\n\nReturns\n\noutfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in which\ncase a single float is returned).\n\n\n\n\nExamples\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.random()\n0.47108547995356098 # random\n&gt;&gt;&gt; type(rng.random())\n&lt;class 'float'&gt;\n&gt;&gt;&gt; rng.random((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n\nThree-by-two array of random numbers from [-5, 0):\n&gt;&gt;&gt; 5 * rng.random((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n\n", "parameters": ["Parameters", "sizeint or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "outfloat or ndarray of floats"], "returns": "outfloat or ndarray of floatsArray of random floats of shape size (unless size=None, in whichcase a single float is returned).", "examples": ["; rng = np.random.default_rng()\n; rng.random()\n0.47108547995356098 # random\n; type(rng.random())\n&lt;class 'float'&gt;\n; rng.random((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n\n", "; rng = np.random.default_rng()\n; rng.random()\n0.47108547995356098 # random\n; type(rng.random())\n&lt;class 'float'&gt;\n; rng.random((5,))\narray([ 0.30220482,  0.86820401,  0.1654503 ,  0.11659149,  0.54323428]) # random\n", "; 5 * rng.random((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n\n", "; 5 * rng.random((3, 2)) - 5\narray([[-3.99149989, -0.52338984], # random\n       [-2.99091858, -0.79479508],\n       [-1.23204345, -1.75224494]])\n"]},
{"library": "numpy", "item_id": "numpy.random.randn", "code": "\nnumpy.random.randn(d0, d1, ..., dn)\u00b6", "description": "Return a sample (or samples) from the \u201cstandard normal\u201d distribution.\n\nNote\nThis is a convenience function for users porting code from Matlab,\nand wraps standard_normal. That function takes a\ntuple to specify the size of the output, which is consistent with\nother NumPy functions like numpy.zeros and numpy.ones.\n\n\nNote\nNew code should use the standard_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\nIf positive int_like arguments are provided, randn generates an array\nof shape (d0, d1, ..., dn), filled\nwith random floats sampled from a univariate \u201cnormal\u201d (Gaussian)\ndistribution of mean 0 and variance 1. A single float randomly sampled\nfrom the distribution is returned if no argument is provided.\n\nParameters\n\nd0, d1, \u2026, dnint, optionalThe dimensions of the returned array, must be non-negative.\nIf no argument is given a single Python float is returned.\n\n\n\nReturns\n\nZndarray or floatA (d0, d1, ..., dn)-shaped array of floating-point samples from\nthe standard normal distribution, or a single such float if\nno parameters were supplied.\n\n\n\n\n\nSee also\n\nstandard_normalSimilar, but takes a tuple as its argument.\n\nnormalAlso accepts mu and sigma arguments.\n\nGenerator.standard_normalwhich should be used for new code.\n\n\n\nNotes\nFor random samples from , use:\nsigma * np.random.randn(...) + mu\nExamples\n&gt;&gt;&gt; np.random.randn()\n2.1923875335537315  # random\n\n\nTwo-by-four array of samples from N(3, 6.25):\n&gt;&gt;&gt; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n\n", "parameters": ["Parameters", "d0, d1, \u2026, dnint, optional", "Returns", "Zndarray or float"], "returns": "Zndarray or floatA (d0, d1, ..., dn)-shaped array of floating-point samples fromthe standard normal distribution, or a single such float ifno parameters were supplied.", "examples": ["; np.random.randn()\n2.1923875335537315  # random\n\n", "; np.random.randn()\n2.1923875335537315  # random\n", "; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n\n", "; 3 + 2.5 * np.random.randn(2, 4)\narray([[-4.49401501,  4.00950034, -1.81814867,  7.29718677],   # random\n       [ 0.39924804,  4.68456316,  4.99394529,  4.84057254]])  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.random", "code": "\nnumpy.random.random(size=None)\u00b6", "description": "Return random floats in the half-open interval [0.0, 1.0). Alias for\nrandom_sample to ease forward-porting to the new random API.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.r_", "code": "\nnumpy.r_ = &lt;numpy.lib.index_tricks.RClass object&gt;\u00b6", "description": "Translates slice objects to concatenation along the first axis.\nThis is a simple way to build up arrays quickly. There are two use cases.\n\nIf the index expression contains comma separated arrays, then stack\nthem along their first axis.\nIf the index expression contains slice notation or scalars then create\na 1-D array with a range indicated by the slice notation.\n\nIf slice notation is used, the syntax start:stop:step is equivalent\nto np.arange(start, stop, step) inside of the brackets. However, if\nstep is an imaginary number (i.e. 100j) then its integer portion is\ninterpreted as a number-of-points desired and the start and stop are\ninclusive. In other words start:stop:stepj is interpreted as\nnp.linspace(start, stop, step, endpoint=1) inside of the brackets.\nAfter expansion of slice notation, all comma separated sequences are\nconcatenated together.\nOptional character strings placed as the first element of the index\nexpression can be used to change the output. The strings \u2018r\u2019 or \u2018c\u2019 result\nin matrix output. If the result is 1-D and \u2018r\u2019 is specified a 1 x N (row)\nmatrix is produced. If the result is 1-D and \u2018c\u2019 is specified, then a N x 1\n(column) matrix is produced. If the result is 2-D then both provide the\nsame matrix result.\nA string integer specifies which axis to stack multiple comma separated\narrays along. A string of two comma-separated integers allows indication\nof the minimum number of dimensions to force each entry into as the\nsecond integer (the axis to concatenate along is still the first integer).\nA string with three comma-separated integers allows specification of the\naxis to concatenate along, the minimum number of dimensions to force the\nentries to, and which axis should contain the start of the arrays which\nare less than the specified number of dimensions. In other words the third\ninteger allows you to specify where the 1\u2019s should be placed in the shape\nof the arrays that have their shapes upgraded. By default, they are placed\nin the front of the shape tuple. The third argument allows you to specify\nwhere the start of the array should be instead. Thus, a third argument of\n\u20180\u2019 would place the 1\u2019s at the end of the array shape. Negative integers\nspecify where in the new shape tuple the last dimension of upgraded arrays\nshould be placed, so the default is \u2018-1\u2019.\n\nParameters\n\nNot a function, so takes no parameters\n\n\nReturns\n\nA concatenated ndarray or matrix.\n\n\n\n\nSee also\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nc_Translates slice objects to concatenation along the second axis.\n\n\n\nExamples\n&gt;&gt;&gt; np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\narray([1, 2, 3, ..., 4, 5, 6])\n&gt;&gt;&gt; np.r_[-1:1:6j, [0]*3, 5, 6]\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])\n\n\nString integers specify the axis to concatenate along or the minimum\nnumber of dimensions to force entries into.\n&gt;&gt;&gt; a = np.array([[0, 1, 2], [3, 4, 5]])\n&gt;&gt;&gt; np.r_['-1', a, a] # concatenate along last axis\narray([[0, 1, 2, 0, 1, 2],\n       [3, 4, 5, 3, 4, 5]])\n&gt;&gt;&gt; np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim&gt;=2\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; np.r_['0,2,0', [1,2,3], [4,5,6]]\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])\n&gt;&gt;&gt; np.r_['1,2,0', [1,2,3], [4,5,6]]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n\n\nUsing \u2018r\u2019 or \u2018c\u2019 as a first string argument creates a matrix.\n&gt;&gt;&gt; np.r_['r',[1,2,3], [4,5,6]]\nmatrix([[1, 2, 3, 4, 5, 6]])\n\n\n", "parameters": ["Parameters", "Not a function, so takes no parameters", "Returns", "A concatenated ndarray or matrix."], "returns": "A concatenated ndarray or matrix.", "examples": ["; np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\narray([1, 2, 3, ..., 4, 5, 6])\n; np.r_[-1:1:6j, [0]*3, 5, 6]\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])\n\n", "; np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])]\narray([1, 2, 3, ..., 4, 5, 6])\n; np.r_[-1:1:6j, [0]*3, 5, 6]\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ,  0. ,  0. ,  0. ,  5. ,  6. ])\n", "; a = np.array([[0, 1, 2], [3, 4, 5]])\n; np.r_['-1', a, a] # concatenate along last axis\narray([[0, 1, 2, 0, 1, 2],\n       [3, 4, 5, 3, 4, 5]])\n; np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim&gt;=2\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; a = np.array([[0, 1, 2], [3, 4, 5]])\n; np.r_['-1', a, a] # concatenate along last axis\narray([[0, 1, 2, 0, 1, 2],\n       [3, 4, 5, 3, 4, 5]])\n; np.r_['0,2', [1,2,3], [4,5,6]] # concatenate along first axis, dim&gt;=2\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; np.r_['0,2,0', [1,2,3], [4,5,6]]\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])\n; np.r_['1,2,0', [1,2,3], [4,5,6]]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n\n", "; np.r_['0,2,0', [1,2,3], [4,5,6]]\narray([[1],\n       [2],\n       [3],\n       [4],\n       [5],\n       [6]])\n; np.r_['1,2,0', [1,2,3], [4,5,6]]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n", "; np.r_['r',[1,2,3], [4,5,6]]\nmatrix([[1, 2, 3, 4, 5, 6]])\n\n", "; np.r_['r',[1,2,3], [4,5,6]]\nmatrix([[1, 2, 3, 4, 5, 6]])\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.r", "code": "\nproperty poly1d.r\u00b6", "description": "The roots of the polynomial, where self(x) == 0\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.qr", "code": "\nnumpy.linalg.qr(a, mode='reduced')[source]\u00b6", "description": "Compute the qr factorization of a matrix.\nFactor the matrix a as qr, where q is orthonormal and r is\nupper-triangular.\n\nParameters\n\naarray_like, shape (M, N)Matrix to be factored.\n\nmode{\u2018reduced\u2019, \u2018complete\u2019, \u2018r\u2019, \u2018raw\u2019}, optionalIf K = min(M, N), then\n\n\u2018reduced\u2019  : returns q, r with dimensions (M, K), (K, N) (default)\n\u2018complete\u2019 : returns q, r with dimensions (M, M), (M, N)\n\u2018r\u2019        : returns r only with dimensions (K, N)\n\u2018raw\u2019      : returns h, tau with dimensions (N, M), (K,)\n\nThe options \u2018reduced\u2019, \u2018complete, and \u2018raw\u2019 are new in numpy 1.8,\nsee the notes for more information. The default is \u2018reduced\u2019, and to\nmaintain backward compatibility with earlier versions of numpy both\nit and the old default \u2018full\u2019 can be omitted. Note that array h\nreturned in \u2018raw\u2019 mode is transposed for calling Fortran. The\n\u2018economic\u2019 mode is deprecated.  The modes \u2018full\u2019 and \u2018economic\u2019 may\nbe passed using only the first letter for backwards compatibility,\nbut all others must be spelled out. See the Notes for more\nexplanation.\n\n\n\nReturns\n\nqndarray of float or complex, optionalA matrix with orthonormal columns. When mode = \u2018complete\u2019 the\nresult is an orthogonal/unitary matrix depending on whether or not\na is real/complex. The determinant may be either +/- 1 in that\ncase.\n\nrndarray of float or complex, optionalThe upper-triangular matrix.\n\n(h, tau)ndarrays of np.double or np.cdouble, optionalThe array h contains the Householder reflectors that generate q\nalong with r. The tau array contains scaling factors for the\nreflectors. In the deprecated  \u2018economic\u2019 mode only h is returned.\n\n\n\nRaises\n\nLinAlgErrorIf factoring fails.\n\n\n\n\nNotes\nThis is an interface to the LAPACK routines dgeqrf, zgeqrf,\ndorgqr, and zungqr.\nFor more information on the qr factorization, see for example:\nhttps://en.wikipedia.org/wiki/QR_factorization\nSubclasses of ndarray are preserved except for the \u2018raw\u2019 mode. So if\na is of type matrix, all the return values will be matrices too.\nNew \u2018reduced\u2019, \u2018complete\u2019, and \u2018raw\u2019 options for mode were added in\nNumPy 1.8.0 and the old option \u2018full\u2019 was made an alias of \u2018reduced\u2019.  In\naddition the options \u2018full\u2019 and \u2018economic\u2019 were deprecated.  Because\n\u2018full\u2019 was the previous default and \u2018reduced\u2019 is the new default,\nbackward compatibility can be maintained by letting mode default.\nThe \u2018raw\u2019 option was added so that LAPACK routines that can multiply\narrays by q using the Householder reflectors can be used. Note that in\nthis case the returned arrays are of type np.double or np.cdouble and\nthe h array is transposed to be FORTRAN compatible.  No routines using\nthe \u2018raw\u2019 return are currently exposed by numpy, but some are available\nin lapack_lite and just await the necessary work.\nExamples\n&gt;&gt;&gt; a = np.random.randn(9, 6)\n&gt;&gt;&gt; q, r = np.linalg.qr(a)\n&gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr\nTrue\n&gt;&gt;&gt; r2 = np.linalg.qr(a, mode='r')\n&gt;&gt;&gt; np.allclose(r, r2)  # mode='r' returns the same r as mode='full'\nTrue\n\n\nExample illustrating a common use of qr: solving of least squares\nproblems\nWhat are the least-squares-best m and y0 in y = y0 + mx for\nthe following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points\nand you\u2019ll see that it should be y0 = 0, m = 1.)  The answer is provided\nby solving the over-determined matrix equation Ax = b, where:\nA = array([[0, 1], [1, 1], [1, 1], [2, 1]])\nx = array([[y0], [m]])\nb = array([[1], [0], [2], [1]])\n\n\nIf A = qr such that q is orthonormal (which is always possible via\nGram-Schmidt), then x = inv(r) * (q.T) * b.  (In numpy practice,\nhowever, we simply use lstsq.)\n&gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])\n&gt;&gt;&gt; A\narray([[0, 1],\n       [1, 1],\n       [1, 1],\n       [2, 1]])\n&gt;&gt;&gt; b = np.array([1, 0, 2, 1])\n&gt;&gt;&gt; q, r = np.linalg.qr(A)\n&gt;&gt;&gt; p = np.dot(q.T, b)\n&gt;&gt;&gt; np.dot(np.linalg.inv(r), p)\narray([  1.1e-16,   1.0e+00])\n\n\n", "parameters": ["Parameters", "aarray_like, shape (M, N)", "mode{\u2018reduced\u2019, \u2018complete\u2019, \u2018r\u2019, \u2018raw\u2019}, optional", "Returns", "qndarray of float or complex, optional", "rndarray of float or complex, optional", "(h, tau)ndarrays of np.double or np.cdouble, optional", "Raises", "LinAlgError"], "returns": "qndarray of float or complex, optionalA matrix with orthonormal columns. When mode = \u2018complete\u2019 theresult is an orthogonal/unitary matrix depending on whether or nota is real/complex. The determinant may be either +/- 1 in thatcase.rndarray of float or complex, optionalThe upper-triangular matrix.(h, tau)ndarrays of np.double or np.cdouble, optionalThe array h contains the Householder reflectors that generate qalong with r. The tau array contains scaling factors for thereflectors. In the deprecated  \u2018economic\u2019 mode only h is returned.", "examples": ["; a = np.random.randn(9, 6)\n; q, r = np.linalg.qr(a)\n; np.allclose(a, np.dot(q, r))  # a does equal qr\nTrue\n; r2 = np.linalg.qr(a, mode='r')\n; np.allclose(r, r2)  # mode='r' returns the same r as mode='full'\nTrue\n\n", "; a = np.random.randn(9, 6)\n; q, r = np.linalg.qr(a)\n; np.allclose(a, np.dot(q, r))  # a does equal qr\nTrue\n; r2 = np.linalg.qr(a, mode='r')\n; np.allclose(r, r2)  # mode='r' returns the same r as mode='full'\nTrue\n", "; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])\n; A\narray([[0, 1],\n       [1, 1],\n       [1, 1],\n       [2, 1]])\n; b = np.array([1, 0, 2, 1])\n; q, r = np.linalg.qr(A)\n; p = np.dot(q.T, b)\n; np.dot(np.linalg.inv(r), p)\narray([  1.1e-16,   1.0e+00])\n\n", "; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])\n; A\narray([[0, 1],\n       [1, 1],\n       [1, 1],\n       [2, 1]])\n; b = np.array([1, 0, 2, 1])\n; q, r = np.linalg.qr(A)\n; p = np.dot(q.T, b)\n; np.dot(np.linalg.inv(r), p)\narray([  1.1e-16,   1.0e+00])\n"]},
{"library": "numpy", "item_id": "numpy.quantile", "code": "\nnumpy.quantile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=False)[source]\u00b6", "description": "Compute the q-th quantile of the data along the specified axis.\n\nNew in version 1.15.0.\n\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\nqarray_like of floatQuantile or sequence of quantiles to compute, which must be between\n0 and 1 inclusive.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the quantiles are computed. The\ndefault is to compute the quantile(s) along a flattened\nversion of the array.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow the input array a to be modified by intermediate\ncalculations, to save memory. In this case, the contents of the input\na after this function completes is undefined.\n\ninterpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}This optional parameter specifies the interpolation method to\nuse when the desired quantile lies between two data points\ni &lt; j:\n\n\nlinear: i + (j - i) * fraction, where fraction\nis the fractional part of the index surrounded by i\nand j.\nlower: i.\nhigher: j.\nnearest: i or j, whichever is nearest.\nmidpoint: (i + j) / 2.\n\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left in\nthe result as dimensions with size one. With this option, the\nresult will broadcast correctly against the original array a.\n\n\n\nReturns\n\nquantilescalar or ndarrayIf q is a single quantile and axis=None, then the result\nis a scalar. If multiple quantiles are given, first axis of\nthe result corresponds to the quantiles. The other axes are\nthe axes that remain after the reduction of a. If the input\ncontains integers or floats smaller than float64, the output\ndata-type is float64. Otherwise, the output data-type is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nmean\n\npercentileequivalent to quantile, but with q in the range [0, 100].\n\nmedianequivalent to quantile(..., 0.5)\n\n\nnanquantile\n\nNotes\nGiven a vector V of length N, the q-th quantile of\nV is the value q of the way from the minimum to the\nmaximum in a sorted copy of V. The values and distances of\nthe two nearest neighbors as well as the interpolation parameter\nwill determine the quantile if the normalized ranking does not\nmatch the location of q exactly. This function is the same as\nthe median if q=0.5, the same as the minimum if q=0.0 and the\nsame as the maximum if q=1.0.\nExamples\n&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])\n&gt;&gt;&gt; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n&gt;&gt;&gt; np.quantile(a, 0.5)\n3.5\n&gt;&gt;&gt; np.quantile(a, 0.5, axis=0)\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; np.quantile(a, 0.5, axis=1)\narray([7.,  2.])\n&gt;&gt;&gt; np.quantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n&gt;&gt;&gt; m = np.quantile(a, 0.5, axis=0)\n&gt;&gt;&gt; out = np.zeros_like(m)\n&gt;&gt;&gt; np.quantile(a, 0.5, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; m\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.quantile(b, 0.5, axis=1, overwrite_input=True)\narray([7.,  2.])\n&gt;&gt;&gt; assert not np.all(a == b)\n\n\n", "parameters": ["Parameters", "aarray_like", "qarray_like of float", "axis{int, tuple of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "interpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}", "keepdimsbool, optional", "Returns", "quantilescalar or ndarray"], "returns": "quantilescalar or ndarrayIf q is a single quantile and axis=None, then the resultis a scalar. If multiple quantiles are given, first axis ofthe result corresponds to the quantiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.quantile(a, 0.5)\n3.5\n; np.quantile(a, 0.5, axis=0)\narray([6.5, 4.5, 2.5])\n; np.quantile(a, 0.5, axis=1)\narray([7.,  2.])\n; np.quantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.quantile(a, 0.5, axis=0)\n; out = np.zeros_like(m)\n; np.quantile(a, 0.5, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n; m\narray([6.5, 4.5, 2.5])\n; b = a.copy()\n; np.quantile(b, 0.5, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a == b)\n\n", "; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.quantile(a, 0.5)\n3.5\n; np.quantile(a, 0.5, axis=0)\narray([6.5, 4.5, 2.5])\n; np.quantile(a, 0.5, axis=1)\narray([7.,  2.])\n; np.quantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.quantile(a, 0.5, axis=0)\n; out = np.zeros_like(m)\n; np.quantile(a, 0.5, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n; m\narray([6.5, 4.5, 2.5])\n; b = a.copy()\n; np.quantile(b, 0.5, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a == b)\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.product", "code": "\nMaskedArray.product(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.ndarray.prodcorresponding function for ndarrays\n\nnumpy.prodequivalent function\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.product", "code": "\nmasked_array.product(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.ndarray.prodcorresponding function for ndarrays\n\nnumpy.prodequivalent function\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.prod", "code": "\nrecord.prod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.prod", "code": "\nrecarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\u00b6", "description": "Return the product of the array elements over the given axis\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.prodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.prod", "code": "\nndarray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\u00b6", "description": "Return the product of the array elements over the given axis\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.prodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.prod", "code": "\nmemmap.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\u00b6", "description": "Return the product of the array elements over the given axis\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.prodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.prod", "code": "\nmatrix.prod(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the product of the array elements over the given axis.\nRefer to prod for full documentation.\n\nSee also\nprod, ndarray.prod\n\nNotes\nSame as ndarray.prod, except, where that returns an ndarray, this\nreturns a matrix object instead.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.prod()\n0\n&gt;&gt;&gt; x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n&gt;&gt;&gt; x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.prod()\n0\n; x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n; x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.prod()\n0\n; x.prod(0)\nmatrix([[  0,  45, 120, 231]])\n; x.prod(1)\nmatrix([[   0],\n        [ 840],\n        [7920]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.prod", "code": "\nMaskType.prod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.prod", "code": "\nMaskedArray.prod(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.ndarray.prodcorresponding function for ndarrays\n\nnumpy.prodequivalent function\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.prod", "code": "\nmasked_array.prod(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.ndarray.prodcorresponding function for ndarrays\n\nnumpy.prodequivalent function\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.prod", "code": "\ngeneric.prod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.prod", "code": "\nchararray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\u00b6", "description": "Return the product of the array elements over the given axis\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.prodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.prod", "code": "\nchararray.prod(axis=None, dtype=None, out=None, keepdims=False, initial=1, where=True)\u00b6", "description": "Return the product of the array elements over the given axis\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.prodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.prod", "code": "\nnumpy.prod(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of array elements over a given axis.\n\nParameters\n\naarray_likeInput data.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which a product is performed.  The default,\naxis=None, will calculate the product of all the elements in the\ninput array. If axis is negative it counts from the last to the\nfirst axis.\n\nNew in version 1.7.0.\n\nIf axis is a tuple of ints, a product is performed on all of the\naxes specified in the tuple instead of a single axis or all the\naxes as before.\n\ndtypedtype, optionalThe type of the returned array, as well as of the accumulator in\nwhich the elements are multiplied.  The dtype of a is used by\ndefault unless a has an integer dtype of less precision than the\ndefault platform integer.  In that case, if a is signed then the\nplatform integer is used while if a is unsigned then an unsigned\ninteger of the same precision as the platform integer is used.\n\noutndarray, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output, but the type of the output\nvalues will be cast if necessary.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left in the\nresult as dimensions with size one. With this option, the result\nwill broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the prod method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\ninitialscalar, optionalThe starting value for this product. See reduce for details.\n\nNew in version 1.15.0.\n\n\nwherearray_like of bool, optionalElements to include in the product. See reduce for details.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nproduct_along_axisndarray, see dtype parameter above.An array shaped as a but with the specified axis removed.\nReturns a reference to out if specified.\n\n\n\n\n\nSee also\n\nndarray.prodequivalent method\n\n\nufuncs-output-type\n\nNotes\nArithmetic is modular when using integer types, and no error is\nraised on overflow.  That means that, on a 32-bit platform:\n&gt;&gt;&gt; x = np.array([536870910, 536870910, 536870910, 536870910])\n&gt;&gt;&gt; np.prod(x)\n16 # may vary\n\n\nThe product of an empty array is the neutral element 1:\n&gt;&gt;&gt; np.prod([])\n1.0\n\n\nExamples\nBy default, calculate the product of all elements:\n&gt;&gt;&gt; np.prod([1.,2.])\n2.0\n\n\nEven when the input array is two-dimensional:\n&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])\n24.0\n\n\nBut we can also specify the axis over which to multiply:\n&gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)\narray([  2.,  12.])\n\n\nOr select specific elements to include:\n&gt;&gt;&gt; np.prod([1., np.nan, 3.], where=[True, False, True])\n3.0\n\n\nIf the type of x is unsigned, then the output type is\nthe unsigned platform integer:\n&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.uint8)\n&gt;&gt;&gt; np.prod(x).dtype == np.uint\nTrue\n\n\nIf x is of a signed integer type, then the output type\nis the default platform integer:\n&gt;&gt;&gt; x = np.array([1, 2, 3], dtype=np.int8)\n&gt;&gt;&gt; np.prod(x).dtype == int\nTrue\n\n\nYou can also start the product with a value other than one:\n&gt;&gt;&gt; np.prod([1, 2], initial=5)\n10\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedtype, optional", "outndarray, optional", "keepdimsbool, optional", "initialscalar, optional", "wherearray_like of bool, optional", "Returns", "product_along_axisndarray, see dtype parameter above."], "returns": "product_along_axisndarray, see dtype parameter above.An array shaped as a but with the specified axis removed.Returns a reference to out if specified.", "examples": ["; np.prod([1.,2.])\n2.0\n\n", "; np.prod([1.,2.])\n2.0\n", "; np.prod([[1.,2.],[3.,4.]])\n24.0\n\n", "; np.prod([[1.,2.],[3.,4.]])\n24.0\n", "; np.prod([[1.,2.],[3.,4.]], axis=1)\narray([  2.,  12.])\n\n", "; np.prod([[1.,2.],[3.,4.]], axis=1)\narray([  2.,  12.])\n", "; np.prod([1., np.nan, 3.], where=[True, False, True])\n3.0\n\n", "; np.prod([1., np.nan, 3.], where=[True, False, True])\n3.0\n", "; x = np.array([1, 2, 3], dtype=np.uint8)\n; np.prod(x).dtype == np.uint\nTrue\n\n", "; x = np.array([1, 2, 3], dtype=np.uint8)\n; np.prod(x).dtype == np.uint\nTrue\n", "; x = np.array([1, 2, 3], dtype=np.int8)\n; np.prod(x).dtype == int\nTrue\n\n", "; x = np.array([1, 2, 3], dtype=np.int8)\n; np.prod(x).dtype == int\nTrue\n", "; np.prod([1, 2], initial=5)\n10\n\n", "; np.prod([1, 2], initial=5)\n10\n"]},
{"library": "numpy", "item_id": "numpy.ma.prod", "code": "\nnumpy.ma.prod(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return the product of the array elements over the given axis.\nMasked elements are set to 1 internally for computation.\nRefer to numpy.prod for full documentation.\n\nSee also\n\nnumpy.ndarray.prodcorresponding function for ndarrays\n\nnumpy.prodequivalent function\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is raised\non overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.printoptions", "code": "\nnumpy.printoptions(*args, **kwargs)[source]\u00b6", "description": "Context manager for setting print options.\nSet print options for the scope of the with block, and restore the old\noptions at the end. See set_printoptions for the full description of\navailable options.\n\nSee also\nset_printoptions, get_printoptions\n\nExamples\n&gt;&gt;&gt; from numpy.testing import assert_equal\n&gt;&gt;&gt; with np.printoptions(precision=2):\n...     np.array([2.0]) / 3\narray([0.67])\n\n\nThe as-clause of the with-statement gives the current print options:\n&gt;&gt;&gt; with np.printoptions(precision=2) as opts:\n...      assert_equal(opts, np.get_printoptions())\n\n\n", "parameters": [], "returns": [], "examples": ["; from numpy.testing import assert_equal\n; with np.printoptions(precision=2):\n...     np.array([2.0]) / 3\narray([0.67])\n\n", "; from numpy.testing import assert_equal\n; with np.printoptions(precision=2):\n...     np.array([2.0]) / 3\narray([0.67])\n", "; with np.printoptions(precision=2) as opts:\n...      assert_equal(opts, np.get_printoptions())\n\n", "; with np.printoptions(precision=2) as opts:\n...      assert_equal(opts, np.get_printoptions())\n"]},
{"library": "numpy", "item_id": "numpy.testing.Tester.prepare_test_args", "code": "\nTester.prepare_test_args(self, label='fast', verbose=1, extra_argv=None, doctests=False, coverage=False, timer=False)[source]\u00b6", "description": "Run tests for module using nose.\nThis method does the heavy lifting for the test method. It takes all\nthe same arguments, for details see test.\n\nSee also\ntest\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ppmt", "code": "\nnumpy.ppmt(rate, per, nper, pv, fv=0, when='end')[source]\u00b6", "description": "Compute the payment against loan principal.\n\nDeprecated since version 1.18: ppmt is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nParameters\n\nratearray_likeRate of interest (per period)\n\nperarray_like, intAmount paid against the loan changes.  The per is the period of\ninterest.\n\nnperarray_likeNumber of compounding periods\n\npvarray_likePresent value\n\nfvarray_like, optionalFuture value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}When payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0))\n\n\n\n\n\nSee also\npmt, pv, ipmt\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n\n", "parameters": ["Parameters", "ratearray_like", "perarray_like, int", "nperarray_like", "pvarray_like", "fvarray_like, optional", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.pprint", "code": "\nrecord.pprint(self)[source]\u00b6", "description": "Pretty-print all fields.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.power", "code": "\nnumpy.random.power(a, size=None)\u00b6", "description": "Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.\nAlso known as the power function distribution.\n\nNote\nNew code should use the power method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsParameter of the distribution. Must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized power distribution.\n\n\n\nRaises\n\nValueErrorIf a &lt; 1.\n\n\n\n\n\nSee also\n\nGenerator.powerwhich should be used for new code.\n\n\n\nNotes\nThe probability density function is\n\n\nThe power function distribution is just the inverse of the Pareto\ndistribution. It may also be seen as a special case of the Beta\ndistribution.\nIt is used, for example, in modeling the over-reporting of insurance\nclaims.\nReferences\n\n1\nChristian Kleiber, Samuel Kotz, \u201cStatistical size distributions\nin economics and actuarial sciences\u201d, Wiley, 2003.\n\n2\nHeckert, N. A. and Filliben, James J. \u201cNIST Handbook 148:\nDataplot Reference Manual, Volume 2: Let Subcommands and Library\nFunctions\u201d, National Institute of Standards and Technology\nHandbook Series, June 2003.\nhttps://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; samples = 1000\n&gt;&gt;&gt; s = np.random.power(a, samples)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=30)\n&gt;&gt;&gt; x = np.linspace(0, 1, 100)\n&gt;&gt;&gt; y = a*x**(a-1.)\n&gt;&gt;&gt; normed_y = samples*np.diff(bins)[0]*y\n&gt;&gt;&gt; plt.plot(x, normed_y)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nCompare the power function distribution to the inverse of the Pareto.\n&gt;&gt;&gt; from scipy import stats \n&gt;&gt;&gt; rvs = np.random.power(5, 1000000)\n&gt;&gt;&gt; rvsp = np.random.pareto(5, 1000000)\n&gt;&gt;&gt; xx = np.linspace(0,1,100)\n&gt;&gt;&gt; powpdf = stats.powerlaw.pdf(xx,5)  \n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(rvs, bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('np.random.power(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of 1 + np.random.pareto(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of stats.pareto(5)')\n\n\n\n\n\n\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized power distribution.", "examples": ["; a = 5. # shape\n; samples = 1000\n; s = np.random.power(a, samples)\n\n", "; a = 5. # shape\n; samples = 1000\n; s = np.random.power(a, samples)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n", "; from scipy import stats \n; rvs = np.random.power(5, 1000000)\n; rvsp = np.random.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n\n", "; from scipy import stats \n; rvs = np.random.power(5, 1000000)\n; rvsp = np.random.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('np.random.power(5)')\n\n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('np.random.power(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + np.random.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + np.random.pareto(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.power", "code": "\nGenerator.power(a, size=None)\u00b6", "description": "Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.\nAlso known as the power function distribution.\n\nParameters\n\nafloat or array_like of floatsParameter of the distribution. Must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized power distribution.\n\n\n\nRaises\n\nValueErrorIf a &lt; 1.\n\n\n\n\nNotes\nThe probability density function is\n\n\nThe power function distribution is just the inverse of the Pareto\ndistribution. It may also be seen as a special case of the Beta\ndistribution.\nIt is used, for example, in modeling the over-reporting of insurance\nclaims.\nReferences\n\n1\nChristian Kleiber, Samuel Kotz, \u201cStatistical size distributions\nin economics and actuarial sciences\u201d, Wiley, 2003.\n\n2\nHeckert, N. A. and Filliben, James J. \u201cNIST Handbook 148:\nDataplot Reference Manual, Volume 2: Let Subcommands and Library\nFunctions\u201d, National Institute of Standards and Technology\nHandbook Series, June 2003.\nhttps://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; samples = 1000\n&gt;&gt;&gt; s = rng.power(a, samples)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=30)\n&gt;&gt;&gt; x = np.linspace(0, 1, 100)\n&gt;&gt;&gt; y = a*x**(a-1.)\n&gt;&gt;&gt; normed_y = samples*np.diff(bins)[0]*y\n&gt;&gt;&gt; plt.plot(x, normed_y)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nCompare the power function distribution to the inverse of the Pareto.\n&gt;&gt;&gt; from scipy import stats  \n&gt;&gt;&gt; rvs = rng.power(5, 1000000)\n&gt;&gt;&gt; rvsp = rng.pareto(5, 1000000)\n&gt;&gt;&gt; xx = np.linspace(0,1,100)\n&gt;&gt;&gt; powpdf = stats.powerlaw.pdf(xx,5)  \n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(rvs, bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('power(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of 1 + Generator.pareto(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of stats.pareto(5)')\n\n\n\n\n\n\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized power distribution.", "examples": ["; rng = np.random.default_rng()\n; a = 5. # shape\n; samples = 1000\n; s = rng.power(a, samples)\n\n", "; rng = np.random.default_rng()\n; a = 5. # shape\n; samples = 1000\n; s = rng.power(a, samples)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n", "; from scipy import stats  \n; rvs = rng.power(5, 1000000)\n; rvsp = rng.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n\n", "; from scipy import stats  \n; rvs = rng.power(5, 1000000)\n; rvsp = rng.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('power(5)')\n\n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('power(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + Generator.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + Generator.pareto(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n"]},
{"library": "numpy", "item_id": "numpy.ma.power", "code": "\nnumpy.ma.power(a, b, third=None)[source]\u00b6", "description": "Returns element-wise base array raised to power from second array.\nThis is the masked array version of numpy.power. For details see\nnumpy.power.\n\nSee also\nnumpy.power\n\nNotes\nThe out argument to numpy.power is not supported, third has to be\nNone.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.power", "code": "\nnumpy.power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'power'&gt;\u00b6", "description": "First array elements raised to powers from second array, element-wise.\nRaise each base in x1 to the positionally-corresponding power in\nx2.  x1 and x2 must be broadcastable to the same shape. Note that an\ninteger type raised to a negative integer power will raise a ValueError.\n\nParameters\n\nx1array_likeThe bases.\n\nx2array_likeThe exponents. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe bases in x1 raised to the exponents in x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfloat_powerpower function that promotes integers to float\n\n\n\nExamples\nCube each element in a list.\n&gt;&gt;&gt; x1 = range(6)\n&gt;&gt;&gt; x1\n[0, 1, 2, 3, 4, 5]\n&gt;&gt;&gt; np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n\n\nRaise the bases to different exponents.\n&gt;&gt;&gt; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n&gt;&gt;&gt; np.power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\n\nThe effect of broadcasting.\n&gt;&gt;&gt; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n&gt;&gt;&gt; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n&gt;&gt;&gt; np.power(x1, x2)\narray([[ 0,  1,  8, 27, 16,  5],\n       [ 0,  1,  8, 27, 16,  5]])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe bases in x1 raised to the exponents in x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; x1 = range(6)\n; x1\n[0, 1, 2, 3, 4, 5]\n; np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n\n", "; x1 = range(6)\n; x1\n[0, 1, 2, 3, 4, 5]\n; np.power(x1, 3)\narray([  0,   1,   8,  27,  64, 125])\n", "; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n; np.power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\n", "; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n; np.power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n", "; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n; np.power(x1, x2)\narray([[ 0,  1,  8, 27, 16,  5],\n       [ 0,  1,  8, 27, 16,  5]])\n\n", "; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n; np.power(x1, x2)\narray([[ 0,  1,  8, 27, 16,  5],\n       [ 0,  1,  8, 27, 16,  5]])\n"]},
{"library": "numpy", "item_id": "numpy.positive", "code": "\nnumpy.positive(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'positive'&gt;\u00b6", "description": "Numerical positive, element-wise.\n\nNew in version 1.13.0.\n\n\nParameters\n\nxarray_like or scalarInput array.\n\n\n\nReturns\n\nyndarray or scalarReturned array or scalar: y = +x.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nEquivalent to x.copy(), but only defined for types that support\narithmetic.\n", "parameters": ["Parameters", "xarray_like or scalar", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarReturned array or scalar: y = +x.This is a scalar if x is a scalar.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyzero", "code": "\nnumpy.polynomial.polynomial.polyzero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.power", "code": "\nRandomState.power(a, size=None)\u00b6", "description": "Draws samples in [0, 1] from a power distribution with positive\nexponent a - 1.\nAlso known as the power function distribution.\n\nNote\nNew code should use the power method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsParameter of the distribution. Must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized power distribution.\n\n\n\nRaises\n\nValueErrorIf a &lt; 1.\n\n\n\n\n\nSee also\n\nGenerator.powerwhich should be used for new code.\n\n\n\nNotes\nThe probability density function is\n\n\nThe power function distribution is just the inverse of the Pareto\ndistribution. It may also be seen as a special case of the Beta\ndistribution.\nIt is used, for example, in modeling the over-reporting of insurance\nclaims.\nReferences\n\n1\nChristian Kleiber, Samuel Kotz, \u201cStatistical size distributions\nin economics and actuarial sciences\u201d, Wiley, 2003.\n\n2\nHeckert, N. A. and Filliben, James J. \u201cNIST Handbook 148:\nDataplot Reference Manual, Volume 2: Let Subcommands and Library\nFunctions\u201d, National Institute of Standards and Technology\nHandbook Series, June 2003.\nhttps://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = 5. # shape\n&gt;&gt;&gt; samples = 1000\n&gt;&gt;&gt; s = np.random.power(a, samples)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=30)\n&gt;&gt;&gt; x = np.linspace(0, 1, 100)\n&gt;&gt;&gt; y = a*x**(a-1.)\n&gt;&gt;&gt; normed_y = samples*np.diff(bins)[0]*y\n&gt;&gt;&gt; plt.plot(x, normed_y)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nCompare the power function distribution to the inverse of the Pareto.\n&gt;&gt;&gt; from scipy import stats \n&gt;&gt;&gt; rvs = np.random.power(5, 1000000)\n&gt;&gt;&gt; rvsp = np.random.pareto(5, 1000000)\n&gt;&gt;&gt; xx = np.linspace(0,1,100)\n&gt;&gt;&gt; powpdf = stats.powerlaw.pdf(xx,5)  \n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(rvs, bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('np.random.power(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of 1 + np.random.pareto(5)')\n\n\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; plt.hist(1./(1.+rvsp), bins=50, density=True)\n&gt;&gt;&gt; plt.plot(xx,powpdf,'r-')  \n&gt;&gt;&gt; plt.title('inverse of stats.pareto(5)')\n\n\n\n\n\n\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized power distribution.", "examples": ["; a = 5. # shape\n; samples = 1000\n; s = np.random.power(a, samples)\n\n", "; a = 5. # shape\n; samples = 1000\n; s = np.random.power(a, samples)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=30)\n; x = np.linspace(0, 1, 100)\n; y = a*x**(a-1.)\n; normed_y = samples*np.diff(bins)[0]*y\n; plt.plot(x, normed_y)\n; plt.show()\n", "; from scipy import stats \n; rvs = np.random.power(5, 1000000)\n; rvsp = np.random.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n\n", "; from scipy import stats \n; rvs = np.random.power(5, 1000000)\n; rvsp = np.random.pareto(5, 1000000)\n; xx = np.linspace(0,1,100)\n; powpdf = stats.powerlaw.pdf(xx,5)  \n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('np.random.power(5)')\n\n", "; plt.figure()\n; plt.hist(rvs, bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('np.random.power(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + np.random.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of 1 + np.random.pareto(5)')\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n\n", "; plt.figure()\n; plt.hist(1./(1.+rvsp), bins=50, density=True)\n; plt.plot(xx,powpdf,'r-')  \n; plt.title('inverse of stats.pareto(5)')\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.pool_size", "code": "\nSeedSequence.pool_size\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyvander2d", "code": "\nnumpy.polynomial.polynomial.polyvander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the powers of\nx and y.\nIf V = polyvander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and polyval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D polynomials\nof the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to\n1-D arrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\npolyvander, polyvander3d, polyval2d, polyval3d\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.pool", "code": "\nSeedSequence.pool\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyx", "code": "\nnumpy.polynomial.polynomial.polyx = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyvander3d", "code": "\nnumpy.polynomial.polynomial.polyvander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe powers of x, y, and z.\nIf V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand  np.dot(V, c.flat) and polyval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D polynomials\nof the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\npolyvander, polyvander3d, polyval2d, polyval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyvander", "code": "\nnumpy.polynomial.polynomial.polyvander(x, deg)[source]\u00b6", "description": "Vandermonde matrix of given degree.\nReturns the Vandermonde matrix of degree deg and sample points\nx. The Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the power of x.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\nmatrix V = polyvander(x, n), then np.dot(V, c) and\npolyval(x, c) are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of polynomials of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarray.The Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where the last index is the power of x.\nThe dtype will be the same as the converted x.\n\n\n\n\n\nSee also\npolyvander2d, polyvander3d\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray."], "returns": "vanderndarray.The Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where the last index is the power of x.The dtype will be the same as the converted x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyval2d", "code": "\nnumpy.polynomial.polynomial.polyval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D polynomial at points (x, y).\nThis function returns the value\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than two the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points formed with\npairs of corresponding values from x and y.\n\n\n\n\n\nSee also\npolyval, polygrid2d, polyval3d, polygrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points formed withpairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyval", "code": "\nnumpy.polynomial.polynomial.polyval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate a polynomial at points x.\nIf c is of length n + 1, this function returns the value\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe shape of the returned array is described above.\n\n\n\n\n\nSee also\npolyval2d, polygrid2d, polyval3d, polygrid3d\n\nNotes\nThe evaluation uses Horner\u2019s method.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.polynomial import polyval\n&gt;&gt;&gt; polyval(1, [1,2,3])\n6.0\n&gt;&gt;&gt; a = np.arange(4).reshape(2,2)\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; polyval(a, [1,2,3])\narray([[ 1.,   6.],\n       [17.,  34.]])\n&gt;&gt;&gt; coef = np.arange(4).reshape(2,2) # multidimensional coefficients\n&gt;&gt;&gt; coef\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; polyval([1,2], coef, tensor=True)\narray([[2.,  4.],\n       [4.,  7.]])\n&gt;&gt;&gt; polyval([1,2], coef, tensor=False)\narray([2.,  7.])\n\n\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe shape of the returned array is described above.", "examples": ["; from numpy.polynomial.polynomial import polyval\n; polyval(1, [1,2,3])\n6.0\n; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; polyval(a, [1,2,3])\narray([[ 1.,   6.],\n       [17.,  34.]])\n; coef = np.arange(4).reshape(2,2) # multidimensional coefficients\n; coef\narray([[0, 1],\n       [2, 3]])\n; polyval([1,2], coef, tensor=True)\narray([[2.,  4.],\n       [4.,  7.]])\n; polyval([1,2], coef, tensor=False)\narray([2.,  7.])\n\n", "; from numpy.polynomial.polynomial import polyval\n; polyval(1, [1,2,3])\n6.0\n; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; polyval(a, [1,2,3])\narray([[ 1.,   6.],\n       [17.,  34.]])\n; coef = np.arange(4).reshape(2,2) # multidimensional coefficients\n; coef\narray([[0, 1],\n       [2, 3]])\n; polyval([1,2], coef, tensor=True)\narray([[2.,  4.],\n       [4.,  7.]])\n; polyval([1,2], coef, tensor=False)\narray([2.,  7.])\n"]},
{"library": "numpy", "item_id": "numpy.polysub", "code": "\nnumpy.polysub(a1, a2)[source]\u00b6", "description": "Difference (subtraction) of two polynomials.\nGiven two polynomials a1 and a2, returns a1 - a2.\na1 and a2 can be either array_like sequences of the polynomials\u2019\ncoefficients (including coefficients equal to zero), or poly1d objects.\n\nParameters\n\na1, a2array_like or poly1dMinuend and subtrahend polynomials, respectively.\n\n\n\nReturns\n\noutndarray or poly1dArray or poly1d object of the difference polynomial\u2019s coefficients.\n\n\n\n\n\nSee also\npolyval, polydiv, polymul, polyadd\n\nExamples\n\n\n&gt;&gt;&gt; np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])\n\n\n", "parameters": ["Parameters", "a1, a2array_like or poly1d", "Returns", "outndarray or poly1d"], "returns": "outndarray or poly1dArray or poly1d object of the difference polynomial\u2019s coefficients.", "examples": ["; np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])\n\n", "; np.polysub([2, 10, -2], [3, 10, -4])\narray([-1,  0,  2])\n"]},
{"library": "numpy", "item_id": "numpy.polyval", "code": "\nnumpy.polyval(p, x)[source]\u00b6", "description": "Evaluate a polynomial at specific values.\nIf p is of length N, this function returns the value:\n\np[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]\n\nIf x is a sequence, then p(x) is returned for each element of x.\nIf x is another polynomial then the composite polynomial p(x(t))\nis returned.\n\nParameters\n\nparray_like or poly1d object1D array of polynomial coefficients (including coefficients equal\nto zero) from highest degree to the constant term, or an\ninstance of poly1d.\n\nxarray_like or poly1d objectA number, an array of numbers, or an instance of poly1d, at\nwhich to evaluate p.\n\n\n\nReturns\n\nvaluesndarray or poly1dIf x is a poly1d instance, the result is the composition of the two\npolynomials, i.e., x is \u201csubstituted\u201d in p and the simplified\nresult is returned. In addition, the type of x - array_like or\npoly1d - governs the type of the output: x array_like =&gt; values\narray_like, x a poly1d object =&gt; values is also.\n\n\n\n\n\nSee also\n\npoly1dA polynomial class.\n\n\n\nNotes\nHorner\u2019s scheme [1] is used to evaluate the polynomial. Even so,\nfor polynomials of high degree the values may be inaccurate due to\nrounding errors. Use carefully.\nIf x is a subtype of ndarray the return value will be of the same type.\nReferences\n\n1\nI. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.\ntrans. Ed.), Handbook of Mathematics, New York, Van Nostrand\nReinhold Co., 1985, pg. 720.\n\n\nExamples\n&gt;&gt;&gt; np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n&gt;&gt;&gt; np.polyval([3,0,1], np.poly1d(5))\npoly1d([76.])\n&gt;&gt;&gt; np.polyval(np.poly1d([3,0,1]), 5)\n76\n&gt;&gt;&gt; np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([76.])\n\n\n", "parameters": ["Parameters", "parray_like or poly1d object", "xarray_like or poly1d object", "Returns", "valuesndarray or poly1d"], "returns": "valuesndarray or poly1dIf x is a poly1d instance, the result is the composition of the twopolynomials, i.e., x is \u201csubstituted\u201d in p and the simplifiedresult is returned. In addition, the type of x - array_like orpoly1d - governs the type of the output: x array_like =&gt; valuesarray_like, x a poly1d object =&gt; values is also.", "examples": ["; np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n; np.polyval([3,0,1], np.poly1d(5))\npoly1d([76.])\n; np.polyval(np.poly1d([3,0,1]), 5)\n76\n; np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([76.])\n\n", "; np.polyval([3,0,1], 5)  # 3 * 5**2 + 0 * 5**1 + 1\n76\n; np.polyval([3,0,1], np.poly1d(5))\npoly1d([76.])\n; np.polyval(np.poly1d([3,0,1]), 5)\n76\n; np.polyval(np.poly1d([3,0,1]), np.poly1d(5))\npoly1d([76.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyvalfromroots", "code": "\nnumpy.polynomial.polynomial.polyvalfromroots(x, r, tensor=True)[source]\u00b6", "description": "Evaluate a polynomial specified by its roots at points x.\nIf r is of length N, this function returns the value\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of r.\nIf r is a 1-D array, then p(x) will have the same shape as x.  If r\nis multidimensional, then the shape of the result depends on the value of\ntensor. If tensor is ``True` the shape will be r.shape[1:] + x.shape;\nthat is, each polynomial is evaluated at every value of x. If tensor is\nFalse, the shape will be r.shape[1:]; that is, each polynomial is\nevaluated only for the corresponding broadcast value of x. Note that\nscalars have shape (,).\n\nNew in version 1.12.\n\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of r.\n\nrarray_likeArray of roots. If r is multidimensional the first index is the\nroot index, while the remaining indices enumerate multiple\npolynomials. For instance, in the two dimensional case the roots\nof each polynomial may be thought of as stored in the columns of r.\n\ntensorboolean, optionalIf True, the shape of the roots array is extended with ones on the\nright, one for each dimension of x. Scalars have dimension 0 for this\naction. The result is that every column of coefficients in r is\nevaluated for every element of x. If False, x is broadcast over the\ncolumns of r for the evaluation.  This keyword is useful when r is\nmultidimensional. The default value is True.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe shape of the returned array is described above.\n\n\n\n\n\nSee also\npolyroots, polyfromroots, polyval\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.polynomial import polyvalfromroots\n&gt;&gt;&gt; polyvalfromroots(1, [1,2,3])\n0.0\n&gt;&gt;&gt; a = np.arange(4).reshape(2,2)\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; polyvalfromroots(a, [-1, 0, 1])\narray([[-0.,   0.],\n       [ 6.,  24.]])\n&gt;&gt;&gt; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients\n&gt;&gt;&gt; r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n&gt;&gt;&gt; b = [-2, 1]\n&gt;&gt;&gt; polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n&gt;&gt;&gt; polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])\n\n\n", "parameters": ["Parameters", "xarray_like, compatible object", "rarray_like", "tensorboolean, optional", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe shape of the returned array is described above.", "examples": ["; from numpy.polynomial.polynomial import polyvalfromroots\n; polyvalfromroots(1, [1,2,3])\n0.0\n; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; polyvalfromroots(a, [-1, 0, 1])\narray([[-0.,   0.],\n       [ 6.,  24.]])\n; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients\n; r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n; b = [-2, 1]\n; polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n; polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])\n\n", "; from numpy.polynomial.polynomial import polyvalfromroots\n; polyvalfromroots(1, [1,2,3])\n0.0\n; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; polyvalfromroots(a, [-1, 0, 1])\narray([[-0.,   0.],\n       [ 6.,  24.]])\n; r = np.arange(-2, 2).reshape(2,2) # multidimensional coefficients\n; r # each column of r defines one polynomial\narray([[-2, -1],\n       [ 0,  1]])\n; b = [-2, 1]\n; polyvalfromroots(b, r, tensor=True)\narray([[-0.,  3.],\n       [ 3., 0.]])\n; polyvalfromroots(b, r, tensor=False)\narray([-0.,  0.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyval3d", "code": "\nnumpy.polynomial.polynomial.polyval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D polynomial at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimensional polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\npolyval, polyval2d, polygrid2d, polygrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimensional polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polytrim", "code": "\nnumpy.polynomial.polynomial.polytrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polysub", "code": "\nnumpy.polynomial.polynomial.polysub(c1, c2)[source]\u00b6", "description": "Subtract one polynomial from another.\nReturns the difference of two polynomials c1 - c2.  The arguments\nare sequences of coefficients from lowest order term to highest, i.e.,\n[1,2,3] represents the polynomial 1 + 2*x + 3*x**2.\n\nParameters\n\nc1, c2array_like1-D arrays of polynomial coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf coefficients representing their difference.\n\n\n\n\n\nSee also\npolyadd, polymulx, polymul, polydiv, polypow\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n&gt;&gt;&gt; P.polysub(c2,c1) # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf coefficients representing their difference.", "examples": ["; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n; P.polysub(c2,c1) # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])\n\n", "; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polysub(c1,c2)\narray([-2.,  0.,  2.])\n; P.polysub(c2,c1) # -P.polysub(c1,c2)\narray([ 2.,  0., -2.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyone", "code": "\nnumpy.polynomial.polynomial.polyone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial", "code": "\nclass numpy.polynomial.polynomial.Polynomial(coef, domain=None, window=None)[source]\u00b6", "description": "A power series class.\nThe Polynomial class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nattributes and methods listed in the ABCPolyBase documentation.\n\nParameters\n\ncoefarray_likePolynomial coefficients in order of increasing degree, i.e.,\n(1, 2, 3) give 1 + 2*x + 3*x**2.\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [-1, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [-1, 1].\n\nNew in version 1.6.0.\n\n\n\n\nAttributes\n\nbasis_name\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional", "Attributes", "basis_name"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polymulx", "code": "\nnumpy.polynomial.polynomial.polymulx(c)[source]\u00b6", "description": "Multiply a polynomial by x.\nMultiply the polynomial c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of polynomial coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\n\nSee also\npolyadd, polysub, polymul, polydiv, polypow\n\nNotes\n\nNew in version 1.5.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyroots", "code": "\nnumpy.polynomial.polynomial.polyroots(c)[source]\u00b6", "description": "Compute the roots of a polynomial.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of polynomial coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the polynomial. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\nchebroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the power series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton\u2019s method.\nExamples\n&gt;&gt;&gt; import numpy.polynomial.polynomial as poly\n&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n&gt;&gt;&gt; j = complex(0,1)\n&gt;&gt;&gt; poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the polynomial. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; import numpy.polynomial.polynomial as poly\n; poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n; j = complex(0,1)\n; poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary\n\n", "; import numpy.polynomial.polynomial as poly\n; poly.polyroots(poly.polyfromroots((-1,0,1)))\narray([-1.,  0.,  1.])\n; poly.polyroots(poly.polyfromroots((-1,0,1))).dtype\ndtype('float64')\n; j = complex(0,1)\n; poly.polyroots(poly.polyfromroots((-j,0,j)))\narray([  0.00000000e+00+0.j,   0.00000000e+00+1.j,   2.77555756e-17-1.j]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polymul", "code": "\nnumpy.polymul(a1, a2)[source]\u00b6", "description": "Find the product of two polynomials.\nFinds the polynomial resulting from the multiplication of the two input\npolynomials. Each input must be either a poly1d object or a 1D sequence\nof polynomial coefficients, from highest to lowest degree.\n\nParameters\n\na1, a2array_like or poly1d objectInput polynomials.\n\n\n\nReturns\n\noutndarray or poly1d objectThe polynomial resulting from the multiplication of the inputs. If\neither inputs is a poly1d object, then the output is also a poly1d\nobject. Otherwise, it is a 1D array of polynomial coefficients from\nhighest to lowest degree.\n\n\n\n\n\nSee also\n\npoly1dA one-dimensional polynomial class.\n\n\npoly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\nconvolveArray convolution. Same output as polymul, but has parameter for overlap mode.\n\n\n\nExamples\n&gt;&gt;&gt; np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])\n\n\nUsing poly1d objects:\n&gt;&gt;&gt; p1 = np.poly1d([1, 2, 3])\n&gt;&gt;&gt; p2 = np.poly1d([9, 5, 1])\n&gt;&gt;&gt; print(p1)\n   2\n1 x + 2 x + 3\n&gt;&gt;&gt; print(p2)\n   2\n9 x + 5 x + 1\n&gt;&gt;&gt; print(np.polymul(p1, p2))\n   4      3      2\n9 x + 23 x + 38 x + 17 x + 3\n\n\n", "parameters": ["Parameters", "a1, a2array_like or poly1d object", "Returns", "outndarray or poly1d object"], "returns": "outndarray or poly1d objectThe polynomial resulting from the multiplication of the inputs. Ifeither inputs is a poly1d object, then the output is also a poly1dobject. Otherwise, it is a 1D array of polynomial coefficients fromhighest to lowest degree.", "examples": ["; np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])\n\n", "; np.polymul([1, 2, 3], [9, 5, 1])\narray([ 9, 23, 38, 17,  3])\n", "; p1 = np.poly1d([1, 2, 3])\n; p2 = np.poly1d([9, 5, 1])\n; print(p1)\n   2\n1 x + 2 x + 3\n; print(p2)\n   2\n9 x + 5 x + 1\n; print(np.polymul(p1, p2))\n   4      3      2\n9 x + 23 x + 38 x + 17 x + 3\n\n", "; p1 = np.poly1d([1, 2, 3])\n; p2 = np.poly1d([9, 5, 1])\n; print(p1)\n   2\n1 x + 2 x + 3\n; print(p2)\n   2\n9 x + 5 x + 1\n; print(np.polymul(p1, p2))\n   4      3      2\n9 x + 23 x + 38 x + 17 x + 3\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polypow", "code": "\nnumpy.polynomial.polynomial.polypow(c, pow, maxpower=None)[source]\u00b6", "description": "Raise a polynomial to a power.\nReturns the polynomial c raised to the power pow. The argument\nc is a sequence of coefficients ordered from low to high. i.e.,\n[1,2,3] is the series  1 + 2*x + 3*x**2.\n\nParameters\n\ncarray_like1-D array of array of series coefficients ordered from low to\nhigh degree.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayPower series of power.\n\n\n\n\n\nSee also\npolyadd, polysub, polymulx, polymul, polydiv\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; P.polypow([1,2,3], 2)\narray([ 1., 4., 10., 12., 9.])\n\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayPower series of power.", "examples": ["; from numpy.polynomial import polynomial as P\n; P.polypow([1,2,3], 2)\narray([ 1., 4., 10., 12., 9.])\n\n", "; from numpy.polynomial import polynomial as P\n; P.polypow([1,2,3], 2)\narray([ 1., 4., 10., 12., 9.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polymul", "code": "\nnumpy.polynomial.polynomial.polymul(c1, c2)[source]\u00b6", "description": "Multiply one polynomial by another.\nReturns the product of two polynomials c1 * c2.  The arguments are\nsequences of coefficients, from lowest order term to highest, e.g.,\n[1,2,3] represents the polynomial 1 + 2*x + 3*x**2.\n\nParameters\n\nc1, c2array_like1-D arrays of coefficients representing a polynomial, relative to the\n\u201cstandard\u201d basis, and ordered from lowest order term to highest.\n\n\n\nReturns\n\noutndarrayOf the coefficients of their product.\n\n\n\n\n\nSee also\npolyadd, polysub, polymulx, polydiv, polypow\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; P.polymul(c1,c2)\narray([  3.,   8.,  14.,   8.,   3.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf the coefficients of their product.", "examples": ["; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polymul(c1,c2)\narray([  3.,   8.,  14.,   8.,   3.])\n\n", "; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polymul(c1,c2)\narray([  3.,   8.,  14.,   8.,   3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyline", "code": "\nnumpy.polynomial.polynomial.polyline(off, scl)[source]\u00b6", "description": "Returns an array representing a linear polynomial.\n\nParameters\n\noff, sclscalarsThe \u201cy-intercept\u201d and \u201cslope\u201d of the line, respectively.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the linear polynomial off +\nscl*x.\n\n\n\n\n\nSee also\nchebline\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; P.polyline(1,-1)\narray([ 1, -1])\n&gt;&gt;&gt; P.polyval(1, P.polyline(1,-1)) # should be 0\n0.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the linear polynomial off +scl*x.", "examples": ["; from numpy.polynomial import polynomial as P\n; P.polyline(1,-1)\narray([ 1, -1])\n; P.polyval(1, P.polyline(1,-1)) # should be 0\n0.0\n\n", "; from numpy.polynomial import polynomial as P\n; P.polyline(1,-1)\narray([ 1, -1])\n; P.polyval(1, P.polyline(1,-1)) # should be 0\n0.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polygrid3d", "code": "\nnumpy.polynomial.polynomial.polygrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D polynomial on the Cartesian product of x, y and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\npolyval, polyval2d, polygrid2d, polyval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polygrid2d", "code": "\nnumpy.polynomial.polynomial.polygrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D polynomial on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\npolyval, polyval2d, polyval3d, polygrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyfromroots", "code": "\nnumpy.polynomial.polynomial.polyfromroots(roots)[source]\u00b6", "description": "Generate a monic polynomial with given roots.\nReturn the coefficients of the polynomial\n\n\nwhere the r_n are the roots specified in roots.  If a zero has\nmultiplicity n, then it must appear in roots n times. For instance,\nif 2 is a root of multiplicity three and 3 is a root of multiplicity 2,\nthen roots looks something like [2, 2, 2, 3, 3]. The roots can appear\nin any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is 1 for monic polynomials in this\nform.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of the polynomial\u2019s coefficients If all the roots are\nreal, then out is also real, otherwise it is complex.  (see\nExamples below).\n\n\n\n\n\nSee also\nchebfromroots, legfromroots, lagfromroots, hermfromroots, hermefromroots\n\nNotes\nThe coefficients are determined by multiplying together linear factors\nof the form (x - r_i), i.e.\n\n\nwhere n == len(roots) - 1; note that this implies that 1 is always\nreturned for .\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n&gt;&gt;&gt; j = complex(0,1)\n&gt;&gt;&gt; P.polyfromroots((-j,j)) # complex returned, though values are real\narray([1.+0.j,  0.+0.j,  1.+0.j])\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of the polynomial\u2019s coefficients If all the roots arereal, then out is also real, otherwise it is complex.  (seeExamples below).", "examples": ["; from numpy.polynomial import polynomial as P\n; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n; j = complex(0,1)\n; P.polyfromroots((-j,j)) # complex returned, though values are real\narray([1.+0.j,  0.+0.j,  1.+0.j])\n\n", "; from numpy.polynomial import polynomial as P\n; P.polyfromroots((-1,0,1)) # x(x - 1)(x + 1) = x^3 - x\narray([ 0., -1.,  0.,  1.])\n; j = complex(0,1)\n; P.polyfromroots((-j,j)) # complex returned, though values are real\narray([1.+0.j,  0.+0.j,  1.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyfit", "code": "\nnumpy.polynomial.polynomial.polyfit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least-squares fit of a polynomial to data.\nReturn the coefficients of a polynomial of degree deg that is the\nleast squares fit to the data values y given at points x. If y is\n1-D the returned coefficients will also be 1-D. If y is 2-D multiple\nfits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample (data) points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points.  Several sets of sample points\nsharing the same x-coordinates can be (independently) fit with one\ncall to polyfit by passing in for y a 2-D array that contains\none data set per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit.  Singular values smaller\nthan rcond, relative to the largest singular value, will be\nignored.  The default value is len(x)*eps, where eps is the\nrelative precision of the platform\u2019s float type, about 2e-16 in\nmost cases.\n\nfullbool, optionalSwitch determining the nature of the return value.  When False\n(the default) just the coefficients are returned; when True,\ndiagnostic information from the singular value decomposition (used\nto solve the fit\u2019s matrix equation) is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\nNew in version 1.5.0.\n\n\n\n\nReturns\n\ncoefndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients ordered from low to high.  If y was 2-D,\nthe coefficients in column k of coef represent the polynomial\nfit to the data in y\u2019s k-th column.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nRaises\n\nRankWarningRaised if the matrix in the least-squares fit is rank deficient.\nThe warning is only raised if full == False.  The warnings can\nbe turned off by:\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\nchebfit, legfit, lagfit, hermfit, hermefit\n\npolyvalEvaluates a polynomial.\n\npolyvanderVandermonde matrix for powers.\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the polynomial p that minimizes\nthe sum of the weighted squared errors\n\n\nwhere the  are the weights. This problem is solved by\nsetting up the (typically) over-determined matrix equation:\n\n\nwhere V is the weighted pseudo Vandermonde matrix of x, c are the\ncoefficients to be solved for, w are the weights, and y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected (and full == False), a RankWarning will be raised.\nThis means that the coefficient values may be poorly determined.\nFitting to a lower order polynomial will usually get rid of the warning\n(but may not be what you want, of course; if you have independent\nreason(s) for choosing the degree which isn\u2019t working, you may have to:\na) reconsider those reasons, and/or b) reconsider the quality of your\ndata).  The rcond parameter can also be set to a value smaller than\nits default, but the resulting fit may be spurious and have large\ncontributions from roundoff error.\nPolynomial fits using double precision tend to \u201cfail\u201d at about\n(polynomial) degree 20. Fits using Chebyshev or Legendre series are\ngenerally better conditioned, but much can still depend on the\ndistribution of the sample points and the smoothness of the data.  If\nthe quality of the fit is inadequate, splines may be a good\nalternative.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; x = np.linspace(-1,1,51) # x \"data\": [-1, -0.96, ..., 0.96, 1]\n&gt;&gt;&gt; y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) \"noise\"\n&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1\narray([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary\n&gt;&gt;&gt; stats # note the large SSR, explaining the rather poor results\n [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary\n          0.28853036]), 1.1324274851176597e-014]\n\n\nSame thing without the added noise\n&gt;&gt;&gt; y = x**3 - x\n&gt;&gt;&gt; c, stats = P.polyfit(x,y,3,full=True)\n&gt;&gt;&gt; c # c[0], c[2] should be \"very close to 0\", c[1] ~= -1, c[3] ~= 1\narray([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])\n&gt;&gt;&gt; stats # note the minuscule SSR\n[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary\n           0.50443316,  0.28853036]), 1.1324274851176597e-014]\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (deg + 1,) or (deg + 1, K)", "[residuals, rank, singular_values, rcond]list", "Raises", "RankWarning"], "returns": "coefndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients ordered from low to high.  If y was 2-D,the coefficients in column k of coef represent the polynomialfit to the data in y\u2019s k-th column.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": ["; np.random.seed(123)\n; from numpy.polynomial import polynomial as P\n; x = np.linspace(-1,1,51) # x \"data\": [-1, -0.96, ..., 0.96, 1]\n; y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) \"noise\"\n; c, stats = P.polyfit(x,y,3,full=True)\n; np.random.seed(123)\n; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1\narray([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary\n; stats # note the large SSR, explaining the rather poor results\n [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary\n          0.28853036]), 1.1324274851176597e-014]\n\n", "; np.random.seed(123)\n; from numpy.polynomial import polynomial as P\n; x = np.linspace(-1,1,51) # x \"data\": [-1, -0.96, ..., 0.96, 1]\n; y = x**3 - x + np.random.randn(len(x)) # x^3 - x + N(0,1) \"noise\"\n; c, stats = P.polyfit(x,y,3,full=True)\n; np.random.seed(123)\n; c # c[0], c[2] should be approx. 0, c[1] approx. -1, c[3] approx. 1\narray([ 0.01909725, -1.30598256, -0.00577963,  1.02644286]) # may vary\n; stats # note the large SSR, explaining the rather poor results\n [array([ 38.06116253]), 4, array([ 1.38446749,  1.32119158,  0.50443316, # may vary\n          0.28853036]), 1.1324274851176597e-014]\n", "; y = x**3 - x\n; c, stats = P.polyfit(x,y,3,full=True)\n; c # c[0], c[2] should be \"very close to 0\", c[1] ~= -1, c[3] ~= 1\narray([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])\n; stats # note the minuscule SSR\n[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary\n           0.50443316,  0.28853036]), 1.1324274851176597e-014]\n\n", "; y = x**3 - x\n; c, stats = P.polyfit(x,y,3,full=True)\n; c # c[0], c[2] should be \"very close to 0\", c[1] ~= -1, c[3] ~= 1\narray([-6.36925336e-18, -1.00000000e+00, -4.08053781e-16,  1.00000000e+00])\n; stats # note the minuscule SSR\n[array([  7.46346754e-31]), 4, array([ 1.38446749,  1.32119158, # may vary\n           0.50443316,  0.28853036]), 1.1324274851176597e-014]\n"]},
{"library": "numpy", "item_id": "numpy.ma.polyfit", "code": "\nnumpy.ma.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)[source]\u00b6", "description": "Least squares polynomial fit.\nFit a polynomial p(x) = p[0] * x**deg + ... + p[deg] of degree deg\nto points (x, y). Returns a vector of coefficients p that minimises\nthe squared error in the order deg, deg-1, \u2026 0.\nThe Polynomial.fit class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegintDegree of the fitting polynomial\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights to apply to the y-coordinates of the sample points. For\ngaussian uncertainties, use 1/sigma (not 1/sigma**2).\n\ncovbool or str, optionalIf given and not False, return not just the estimate but also its\ncovariance matrix. By default, the covariance are scaled by\nchi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable\nexcept in a relative sense and everything is scaled such that the\nreduced chi2 is unity. This scaling is omitted if cov='unscaled',\nas is relevant for the case that the weights are 1/sigma**2, with\nsigma known to be a reliable estimate of the uncertainty.\n\n\n\nReturns\n\npndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients, highest power first.  If y was 2-D, the\ncoefficients for k-th data set are in p[:,k].\n\nresiduals, rank, singular_values, rcondPresent only if full = True.  Residuals is sum of squared residuals\nof the least-squares fit, the effective rank of the scaled Vandermonde\ncoefficient matrix, its singular values, and the specified value of\nrcond. For more details, see linalg.lstsq.\n\nVndarray, shape (M,M) or (M,M,K)Present only if full = False and cov`=True.  The covariance\nmatrix of the polynomial coefficient estimates.  The diagonal of\nthis matrix are the variance estimates for each coefficient.  If y\nis a 2-D array, then the covariance matrix for the `k-th data set\nare in V[:,:,k]\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.\nThe warnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\n\npolyvalCompute polynomial values.\n\nlinalg.lstsqComputes a least-squares fit.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nAny masked values in x is propagated in y, and vice-versa.\nThe solution minimizes the squared error\n\n\nin the equations:\nx[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\nx[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n...\nx[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\n\n\nThe coefficient matrix of the coefficients p is a Vandermonde matrix.\npolyfit issues a RankWarning when the least-squares fit is badly\nconditioned. This implies that the best fit is not well-defined due\nto numerical error. The results may be improved by lowering the polynomial\ndegree or by replacing x by x - x.mean(). The rcond parameter\ncan also be set to a value smaller than its default, but the resulting\nfit may be spurious: including contributions from the small singular\nvalues can add numerical noise to the result.\nNote that fitting polynomial coefficients is inherently badly conditioned\nwhen the degree of the polynomial is large or the interval of sample points\nis badly centered. The quality of the fit should always be checked in these\ncases. When polynomial fits are not satisfactory, splines may be a good\nalternative.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n2\nWikipedia, \u201cPolynomial interpolation\u201d,\nhttps://en.wikipedia.org/wiki/Polynomial_interpolation\n\n\nExamples\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n&gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n&gt;&gt;&gt; z = np.polyfit(x, y, 3)\n&gt;&gt;&gt; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\n\nIt is convenient to use poly1d objects for dealing with polynomials:\n&gt;&gt;&gt; p = np.poly1d(z)\n&gt;&gt;&gt; p(0.5)\n0.6143849206349179 # may vary\n&gt;&gt;&gt; p(3.5)\n-0.34732142857143039 # may vary\n&gt;&gt;&gt; p(10)\n22.579365079365115 # may vary\n\n\nHigh-order polynomials may oscillate wildly:\n&gt;&gt;&gt; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n&gt;&gt;&gt; p30(4)\n-0.80000000000000204 # may vary\n&gt;&gt;&gt; p30(5)\n-0.99999999999999445 # may vary\n&gt;&gt;&gt; p30(4.5)\n-0.10547061179440398 # may vary\n\n\nIllustration:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; xp = np.linspace(-2, 6, 100)\n&gt;&gt;&gt; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n&gt;&gt;&gt; plt.ylim(-2,2)\n(-2, 2)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "covbool or str, optional", "Returns", "pndarray, shape (deg + 1,) or (deg + 1, K)", "residuals, rank, singular_values, rcond", "Vndarray, shape (M,M) or (M,M,K)", "Warns", "RankWarning"], "returns": "pndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients, highest power first.  If y was 2-D, thecoefficients for k-th data set are in p[:,k].residuals, rank, singular_values, rcondPresent only if full = True.  Residuals is sum of squared residualsof the least-squares fit, the effective rank of the scaled Vandermondecoefficient matrix, its singular values, and the specified value ofrcond. For more details, see linalg.lstsq.Vndarray, shape (M,M) or (M,M,K)Present only if full = False and cov`=True.  The covariancematrix of the polynomial coefficient estimates.  The diagonal ofthis matrix are the variance estimates for each coefficient.  If yis a 2-D array, then the covariance matrix for the `k-th data setare in V[:,:,k]", "examples": ["; import warnings\n; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n; z = np.polyfit(x, y, 3)\n; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\n", "; import warnings\n; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n; z = np.polyfit(x, y, 3)\n; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n", "; p = np.poly1d(z)\n; p(0.5)\n0.6143849206349179 # may vary\n; p(3.5)\n-0.34732142857143039 # may vary\n; p(10)\n22.579365079365115 # may vary\n\n", "; p = np.poly1d(z)\n; p(0.5)\n0.6143849206349179 # may vary\n; p(3.5)\n-0.34732142857143039 # may vary\n; p(10)\n22.579365079365115 # may vary\n", "; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n; p30(4)\n-0.80000000000000204 # may vary\n; p30(5)\n-0.99999999999999445 # may vary\n; p30(4.5)\n-0.10547061179440398 # may vary\n\n", "; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n; p30(4)\n-0.80000000000000204 # may vary\n; p30(5)\n-0.99999999999999445 # may vary\n; p30(4.5)\n-0.10547061179440398 # may vary\n", "; import matplotlib.pyplot as plt\n; xp = np.linspace(-2, 6, 100)\n; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n; plt.ylim(-2,2)\n(-2, 2)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; xp = np.linspace(-2, 6, 100)\n; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n; plt.ylim(-2,2)\n(-2, 2)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.polyfit", "code": "\nnumpy.polyfit(x, y, deg, rcond=None, full=False, w=None, cov=False)[source]\u00b6", "description": "Least squares polynomial fit.\nFit a polynomial p(x) = p[0] * x**deg + ... + p[deg] of degree deg\nto points (x, y). Returns a vector of coefficients p that minimises\nthe squared error in the order deg, deg-1, \u2026 0.\nThe Polynomial.fit class\nmethod is recommended for new code as it is more stable numerically. See\nthe documentation of the method for more information.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegintDegree of the fitting polynomial\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights to apply to the y-coordinates of the sample points. For\ngaussian uncertainties, use 1/sigma (not 1/sigma**2).\n\ncovbool or str, optionalIf given and not False, return not just the estimate but also its\ncovariance matrix. By default, the covariance are scaled by\nchi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable\nexcept in a relative sense and everything is scaled such that the\nreduced chi2 is unity. This scaling is omitted if cov='unscaled',\nas is relevant for the case that the weights are 1/sigma**2, with\nsigma known to be a reliable estimate of the uncertainty.\n\n\n\nReturns\n\npndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients, highest power first.  If y was 2-D, the\ncoefficients for k-th data set are in p[:,k].\n\nresiduals, rank, singular_values, rcondPresent only if full = True.  Residuals is sum of squared residuals\nof the least-squares fit, the effective rank of the scaled Vandermonde\ncoefficient matrix, its singular values, and the specified value of\nrcond. For more details, see linalg.lstsq.\n\nVndarray, shape (M,M) or (M,M,K)Present only if full = False and cov`=True.  The covariance\nmatrix of the polynomial coefficient estimates.  The diagonal of\nthis matrix are the variance estimates for each coefficient.  If y\nis a 2-D array, then the covariance matrix for the `k-th data set\nare in V[:,:,k]\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.\nThe warnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\n\npolyvalCompute polynomial values.\n\nlinalg.lstsqComputes a least-squares fit.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution minimizes the squared error\n\n\nin the equations:\nx[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]\nx[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]\n...\nx[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]\n\n\nThe coefficient matrix of the coefficients p is a Vandermonde matrix.\npolyfit issues a RankWarning when the least-squares fit is badly\nconditioned. This implies that the best fit is not well-defined due\nto numerical error. The results may be improved by lowering the polynomial\ndegree or by replacing x by x - x.mean(). The rcond parameter\ncan also be set to a value smaller than its default, but the resulting\nfit may be spurious: including contributions from the small singular\nvalues can add numerical noise to the result.\nNote that fitting polynomial coefficients is inherently badly conditioned\nwhen the degree of the polynomial is large or the interval of sample points\nis badly centered. The quality of the fit should always be checked in these\ncases. When polynomial fits are not satisfactory, splines may be a good\nalternative.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n2\nWikipedia, \u201cPolynomial interpolation\u201d,\nhttps://en.wikipedia.org/wiki/Polynomial_interpolation\n\n\nExamples\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n&gt;&gt;&gt; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n&gt;&gt;&gt; z = np.polyfit(x, y, 3)\n&gt;&gt;&gt; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\n\nIt is convenient to use poly1d objects for dealing with polynomials:\n&gt;&gt;&gt; p = np.poly1d(z)\n&gt;&gt;&gt; p(0.5)\n0.6143849206349179 # may vary\n&gt;&gt;&gt; p(3.5)\n-0.34732142857143039 # may vary\n&gt;&gt;&gt; p(10)\n22.579365079365115 # may vary\n\n\nHigh-order polynomials may oscillate wildly:\n&gt;&gt;&gt; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n&gt;&gt;&gt; p30(4)\n-0.80000000000000204 # may vary\n&gt;&gt;&gt; p30(5)\n-0.99999999999999445 # may vary\n&gt;&gt;&gt; p30(4.5)\n-0.10547061179440398 # may vary\n\n\nIllustration:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; xp = np.linspace(-2, 6, 100)\n&gt;&gt;&gt; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n&gt;&gt;&gt; plt.ylim(-2,2)\n(-2, 2)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "covbool or str, optional", "Returns", "pndarray, shape (deg + 1,) or (deg + 1, K)", "residuals, rank, singular_values, rcond", "Vndarray, shape (M,M) or (M,M,K)", "Warns", "RankWarning"], "returns": "pndarray, shape (deg + 1,) or (deg + 1, K)Polynomial coefficients, highest power first.  If y was 2-D, thecoefficients for k-th data set are in p[:,k].residuals, rank, singular_values, rcondPresent only if full = True.  Residuals is sum of squared residualsof the least-squares fit, the effective rank of the scaled Vandermondecoefficient matrix, its singular values, and the specified value ofrcond. For more details, see linalg.lstsq.Vndarray, shape (M,M) or (M,M,K)Present only if full = False and cov`=True.  The covariancematrix of the polynomial coefficient estimates.  The diagonal ofthis matrix are the variance estimates for each coefficient.  If yis a 2-D array, then the covariance matrix for the `k-th data setare in V[:,:,k]", "examples": ["; import warnings\n; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n; z = np.polyfit(x, y, 3)\n; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n\n", "; import warnings\n; x = np.array([0.0, 1.0, 2.0, 3.0,  4.0,  5.0])\n; y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0])\n; z = np.polyfit(x, y, 3)\n; z\narray([ 0.08703704, -0.81349206,  1.69312169, -0.03968254]) # may vary\n", "; p = np.poly1d(z)\n; p(0.5)\n0.6143849206349179 # may vary\n; p(3.5)\n-0.34732142857143039 # may vary\n; p(10)\n22.579365079365115 # may vary\n\n", "; p = np.poly1d(z)\n; p(0.5)\n0.6143849206349179 # may vary\n; p(3.5)\n-0.34732142857143039 # may vary\n; p(10)\n22.579365079365115 # may vary\n", "; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n; p30(4)\n-0.80000000000000204 # may vary\n; p30(5)\n-0.99999999999999445 # may vary\n; p30(4.5)\n-0.10547061179440398 # may vary\n\n", "; with warnings.catch_warnings():\n...     warnings.simplefilter('ignore', np.RankWarning)\n...     p30 = np.poly1d(np.polyfit(x, y, 30))\n...\n; p30(4)\n-0.80000000000000204 # may vary\n; p30(5)\n-0.99999999999999445 # may vary\n; p30(4.5)\n-0.10547061179440398 # may vary\n", "; import matplotlib.pyplot as plt\n; xp = np.linspace(-2, 6, 100)\n; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n; plt.ylim(-2,2)\n(-2, 2)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; xp = np.linspace(-2, 6, 100)\n; _ = plt.plot(x, y, '.', xp, p(xp), '-', xp, p30(xp), '--')\n; plt.ylim(-2,2)\n(-2, 2)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.PolyError", "code": "\nexception numpy.polynomial.polyutils.PolyError[source]\u00b6", "description": "Base class for errors in this module.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.PolyDomainError", "code": "\nexception numpy.polynomial.polyutils.PolyDomainError[source]\u00b6", "description": "Issued by the generic Poly class when two domains don\u2019t match.\nThis is raised when an binary operation is passed Poly objects with\ndifferent domains.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polydomain", "code": "\nnumpy.polynomial.polynomial.polydomain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polydiv", "code": "\nnumpy.polynomial.polynomial.polydiv(c1, c2)[source]\u00b6", "description": "Divide one polynomial by another.\nReturns the quotient-with-remainder of two polynomials c1 / c2.\nThe arguments are sequences of coefficients, from lowest order term\nto highest, e.g., [1,2,3] represents 1 + 2*x + 3*x**2.\n\nParameters\n\nc1, c2array_like1-D arrays of polynomial coefficients ordered from low to high.\n\n\n\nReturns\n\n[quo, rem]ndarraysOf coefficient series representing the quotient and remainder.\n\n\n\n\n\nSee also\npolyadd, polysub, polymulx, polymul, polypow\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; P.polydiv(c1,c2)\n(array([3.]), array([-8., -4.]))\n&gt;&gt;&gt; P.polydiv(c2,c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "[quo, rem]ndarrays"], "returns": "[quo, rem]ndarraysOf coefficient series representing the quotient and remainder.", "examples": ["; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polydiv(c1,c2)\n(array([3.]), array([-8., -4.]))\n; P.polydiv(c2,c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary\n\n", "; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; P.polydiv(c1,c2)\n(array([3.]), array([-8., -4.]))\n; P.polydiv(c2,c1)\n(array([ 0.33333333]), array([ 2.66666667,  1.33333333])) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polydiv", "code": "\nnumpy.polydiv(u, v)[source]\u00b6", "description": "Returns the quotient and remainder of polynomial division.\nThe input arrays are the coefficients (including any coefficients\nequal to zero) of the \u201cnumerator\u201d (dividend) and \u201cdenominator\u201d\n(divisor) polynomials, respectively.\n\nParameters\n\nuarray_like or poly1dDividend polynomial\u2019s coefficients.\n\nvarray_like or poly1dDivisor polynomial\u2019s coefficients.\n\n\n\nReturns\n\nqndarrayCoefficients, including those equal to zero, of the quotient.\n\nrndarrayCoefficients, including those equal to zero, of the remainder.\n\n\n\n\n\nSee also\npoly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub, polyval\n\nNotes\nBoth u and v must be 0-d or 1-d (ndim = 0 or 1), but u.ndim need\nnot equal v.ndim. In other words, all four possible combinations -\nu.ndim = v.ndim = 0, u.ndim = v.ndim = 1,\nu.ndim = 1, v.ndim = 0, and u.ndim = 0, v.ndim = 1 - work.\nExamples\n\n\n&gt;&gt;&gt; x = np.array([3.0, 5.0, 2.0])\n&gt;&gt;&gt; y = np.array([2.0, 1.0])\n&gt;&gt;&gt; np.polydiv(x, y)\n(array([1.5 , 1.75]), array([0.25]))\n\n\n", "parameters": ["Parameters", "uarray_like or poly1d", "varray_like or poly1d", "Returns", "qndarray", "rndarray"], "returns": "qndarrayCoefficients, including those equal to zero, of the quotient.rndarrayCoefficients, including those equal to zero, of the remainder.", "examples": ["; x = np.array([3.0, 5.0, 2.0])\n; y = np.array([2.0, 1.0])\n; np.polydiv(x, y)\n(array([1.5 , 1.75]), array([0.25]))\n\n", "; x = np.array([3.0, 5.0, 2.0])\n; y = np.array([2.0, 1.0])\n; np.polydiv(x, y)\n(array([1.5 , 1.75]), array([0.25]))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyder", "code": "\nnumpy.polynomial.polynomial.polyder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a polynomial.\nReturns the polynomial coefficients c differentiated m times along\naxis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable).  The\nargument c is an array of coefficients from low to high degree along\neach axis, e.g., [1,2,3] represents the polynomial 1 + 2*x + 3*x**2\nwhile [[1,2],[1,2]] represents 1 + 1*x + 2*y + 2*x*y if axis=0 is\nx and axis=1 is y.\n\nParameters\n\ncarray_likeArray of polynomial coefficients. If c is multidimensional the\ndifferent axis correspond to different variables with the degree\nin each axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change\nof variable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayPolynomial coefficients of the derivative.\n\n\n\n\n\nSee also\npolyint\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3\n&gt;&gt;&gt; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2\narray([  2.,   6.,  12.])\n&gt;&gt;&gt; P.polyder(c,3) # (d**3/dx**3)(c) = 24\narray([24.])\n&gt;&gt;&gt; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2\narray([ -2.,  -6., -12.])\n&gt;&gt;&gt; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x\narray([  6.,  24.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayPolynomial coefficients of the derivative.", "examples": ["; from numpy.polynomial import polynomial as P\n; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3\n; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2\narray([  2.,   6.,  12.])\n; P.polyder(c,3) # (d**3/dx**3)(c) = 24\narray([24.])\n; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2\narray([ -2.,  -6., -12.])\n; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x\narray([  6.,  24.])\n\n", "; from numpy.polynomial import polynomial as P\n; c = (1,2,3,4) # 1 + 2x + 3x**2 + 4x**3\n; P.polyder(c) # (d/dx)(c) = 2 + 6x + 12x**2\narray([  2.,   6.,  12.])\n; P.polyder(c,3) # (d**3/dx**3)(c) = 24\narray([24.])\n; P.polyder(c,scl=-1) # (d/d(-x))(c) = -2 - 6x - 12x**2\narray([ -2.,  -6., -12.])\n; P.polyder(c,2,-1) # (d**2/d(-x)**2)(c) = 6 + 24x\narray([  6.,  24.])\n"]},
{"library": "numpy", "item_id": "numpy.polyder", "code": "\nnumpy.polyder(p, m=1)[source]\u00b6", "description": "Return the derivative of the specified order of a polynomial.\n\nParameters\n\nppoly1d or sequencePolynomial to differentiate.\nA sequence is interpreted as polynomial coefficients, see poly1d.\n\nmint, optionalOrder of differentiation (default: 1)\n\n\n\nReturns\n\nderpoly1dA new polynomial representing the derivative.\n\n\n\n\n\nSee also\n\npolyintAnti-derivative of a polynomial.\n\npoly1dClass for one-dimensional polynomials.\n\n\n\nExamples\nThe derivative of the polynomial  is:\n&gt;&gt;&gt; p = np.poly1d([1,1,1,1])\n&gt;&gt;&gt; p2 = np.polyder(p)\n&gt;&gt;&gt; p2\npoly1d([3, 2, 1])\n\n\nwhich evaluates to:\n&gt;&gt;&gt; p2(2.)\n17.0\n\n\nWe can verify this, approximating the derivative with\n(f(x + h) - f(x))/h:\n&gt;&gt;&gt; (p(2. + 0.001) - p(2.)) / 0.001\n17.007000999997857\n\n\nThe fourth-order derivative of a 3rd-order polynomial is zero:\n&gt;&gt;&gt; np.polyder(p, 2)\npoly1d([6, 2])\n&gt;&gt;&gt; np.polyder(p, 3)\npoly1d([6])\n&gt;&gt;&gt; np.polyder(p, 4)\npoly1d([0.])\n\n\n", "parameters": ["Parameters", "ppoly1d or sequence", "mint, optional", "Returns", "derpoly1d"], "returns": "derpoly1dA new polynomial representing the derivative.", "examples": ["; p = np.poly1d([1,1,1,1])\n; p2 = np.polyder(p)\n; p2\npoly1d([3, 2, 1])\n\n", "; p = np.poly1d([1,1,1,1])\n; p2 = np.polyder(p)\n; p2\npoly1d([3, 2, 1])\n", "; p2(2.)\n17.0\n\n", "; p2(2.)\n17.0\n", "; (p(2. + 0.001) - p(2.)) / 0.001\n17.007000999997857\n\n", "; (p(2. + 0.001) - p(2.)) / 0.001\n17.007000999997857\n", "; np.polyder(p, 2)\npoly1d([6, 2])\n; np.polyder(p, 3)\npoly1d([6])\n; np.polyder(p, 4)\npoly1d([0.])\n\n", "; np.polyder(p, 2)\npoly1d([6, 2])\n; np.polyder(p, 3)\npoly1d([6])\n; np.polyder(p, 4)\npoly1d([0.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polycompanion", "code": "\nnumpy.polynomial.polynomial.polycompanion(c)[source]\u00b6", "description": "Return the companion matrix of c.\nThe companion matrix for power series cannot be made symmetric by\nscaling the basis, so this function differs from those for the\northogonal polynomials.\n\nParameters\n\ncarray_like1-D array of polynomial coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayCompanion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayCompanion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polyadd", "code": "\nnumpy.polyadd(a1, a2)[source]\u00b6", "description": "Find the sum of two polynomials.\nReturns the polynomial resulting from the sum of two input polynomials.\nEach input must be either a poly1d object or a 1D sequence of polynomial\ncoefficients, from highest to lowest degree.\n\nParameters\n\na1, a2array_like or poly1d objectInput polynomials.\n\n\n\nReturns\n\noutndarray or poly1d objectThe sum of the inputs. If either input is a poly1d object, then the\noutput is also a poly1d object. Otherwise, it is a 1D array of\npolynomial coefficients from highest to lowest degree.\n\n\n\n\n\nSee also\n\npoly1dA one-dimensional polynomial class.\n\n\npoly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval\n\nExamples\n&gt;&gt;&gt; np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])\n\n\nUsing poly1d objects:\n&gt;&gt;&gt; p1 = np.poly1d([1, 2])\n&gt;&gt;&gt; p2 = np.poly1d([9, 5, 4])\n&gt;&gt;&gt; print(p1)\n1 x + 2\n&gt;&gt;&gt; print(p2)\n   2\n9 x + 5 x + 4\n&gt;&gt;&gt; print(np.polyadd(p1, p2))\n   2\n9 x + 6 x + 6\n\n\n", "parameters": ["Parameters", "a1, a2array_like or poly1d object", "Returns", "outndarray or poly1d object"], "returns": "outndarray or poly1d objectThe sum of the inputs. If either input is a poly1d object, then theoutput is also a poly1d object. Otherwise, it is a 1D array ofpolynomial coefficients from highest to lowest degree.", "examples": ["; np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])\n\n", "; np.polyadd([1, 2], [9, 5, 4])\narray([9, 6, 6])\n", "; p1 = np.poly1d([1, 2])\n; p2 = np.poly1d([9, 5, 4])\n; print(p1)\n1 x + 2\n; print(p2)\n   2\n9 x + 5 x + 4\n; print(np.polyadd(p1, p2))\n   2\n9 x + 6 x + 6\n\n", "; p1 = np.poly1d([1, 2])\n; p2 = np.poly1d([9, 5, 4])\n; print(p1)\n1 x + 2\n; print(p2)\n   2\n9 x + 5 x + 4\n; print(np.polyadd(p1, p2))\n   2\n9 x + 6 x + 6\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.PolyBase", "code": "\nclass numpy.polynomial.polyutils.PolyBase[source]\u00b6", "description": "Base class for all polynomial types.\nDeprecated in numpy 1.9.0, use the abstract\nABCPolyBase class instead. Note that the latter\nrequires a number of virtual functions to be\nimplemented.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.polyadd", "code": "\nnumpy.polynomial.polynomial.polyadd(c1, c2)[source]\u00b6", "description": "Add one polynomial to another.\nReturns the sum of two polynomials c1 + c2.  The arguments are\nsequences of coefficients from lowest order term to highest, i.e.,\n[1,2,3] represents the polynomial 1 + 2*x + 3*x**2.\n\nParameters\n\nc1, c2array_like1-D arrays of polynomial coefficients ordered from low to high.\n\n\n\nReturns\n\noutndarrayThe coefficient array representing their sum.\n\n\n\n\n\nSee also\npolysub, polymulx, polymul, polydiv, polypow\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polynomial as P\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; sum = P.polyadd(c1,c2); sum\narray([4.,  4.,  4.])\n&gt;&gt;&gt; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)\n28.0\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayThe coefficient array representing their sum.", "examples": ["; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; sum = P.polyadd(c1,c2); sum\narray([4.,  4.,  4.])\n; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)\n28.0\n\n", "; from numpy.polynomial import polynomial as P\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; sum = P.polyadd(c1,c2); sum\narray([4.,  4.,  4.])\n; P.polyval(2, sum) # 4 + 4(2) + 4(2**2)\n28.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.poly2leg", "code": "\nnumpy.polynomial.legendre.poly2leg(pol)[source]\u00b6", "description": "Convert a polynomial to a Legendre series.\nConvert an array representing the coefficients of a polynomial (relative\nto the \u201cstandard\u201d basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Legendre series, ordered\nfrom lowest to highest degree.\n\nParameters\n\npolarray_like1-D array containing the polynomial coefficients\n\n\n\nReturns\n\ncndarray1-D array containing the coefficients of the equivalent Legendre\nseries.\n\n\n\n\n\nSee also\nleg2poly\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy import polynomial as P\n&gt;&gt;&gt; p = P.Polynomial(np.arange(4))\n&gt;&gt;&gt; p\nPolynomial([0.,  1.,  2.,  3.], domain=[-1,  1], window=[-1,  1])\n&gt;&gt;&gt; c = P.Legendre(P.legendre.poly2leg(p.coef))\n&gt;&gt;&gt; c\nLegendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary\n\n\n", "parameters": ["Parameters", "polarray_like", "Returns", "cndarray"], "returns": "cndarray1-D array containing the coefficients of the equivalent Legendreseries.", "examples": ["; from numpy import polynomial as P\n; p = P.Polynomial(np.arange(4))\n; p\nPolynomial([0.,  1.,  2.,  3.], domain=[-1,  1], window=[-1,  1])\n; c = P.Legendre(P.legendre.poly2leg(p.coef))\n; c\nLegendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary\n\n", "; from numpy import polynomial as P\n; p = P.Polynomial(np.arange(4))\n; p\nPolynomial([0.,  1.,  2.,  3.], domain=[-1,  1], window=[-1,  1])\n; c = P.Legendre(P.legendre.poly2leg(p.coef))\n; c\nLegendre([ 1.  ,  3.25,  1.  ,  0.75], domain=[-1,  1], window=[-1,  1]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.poly2cheb", "code": "\nnumpy.polynomial.chebyshev.poly2cheb(pol)[source]\u00b6", "description": "Convert a polynomial to a Chebyshev series.\nConvert an array representing the coefficients of a polynomial (relative\nto the \u201cstandard\u201d basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Chebyshev series, ordered\nfrom lowest to highest degree.\n\nParameters\n\npolarray_like1-D array containing the polynomial coefficients\n\n\n\nReturns\n\ncndarray1-D array containing the coefficients of the equivalent Chebyshev\nseries.\n\n\n\n\n\nSee also\ncheb2poly\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy import polynomial as P\n&gt;&gt;&gt; p = P.Polynomial(range(4))\n&gt;&gt;&gt; p\nPolynomial([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n&gt;&gt;&gt; c = p.convert(kind=P.Chebyshev)\n&gt;&gt;&gt; c\nChebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1.,  1.])\n&gt;&gt;&gt; P.chebyshev.poly2cheb(range(4))\narray([1.  , 3.25, 1.  , 0.75])\n\n\n", "parameters": ["Parameters", "polarray_like", "Returns", "cndarray"], "returns": "cndarray1-D array containing the coefficients of the equivalent Chebyshevseries.", "examples": ["; from numpy import polynomial as P\n; p = P.Polynomial(range(4))\n; p\nPolynomial([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; c = p.convert(kind=P.Chebyshev)\n; c\nChebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1.,  1.])\n; P.chebyshev.poly2cheb(range(4))\narray([1.  , 3.25, 1.  , 0.75])\n\n", "; from numpy import polynomial as P\n; p = P.Polynomial(range(4))\n; p\nPolynomial([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; c = p.convert(kind=P.Chebyshev)\n; c\nChebyshev([1.  , 3.25, 1.  , 0.75], domain=[-1.,  1.], window=[-1.,  1.])\n; P.chebyshev.poly2cheb(range(4))\narray([1.  , 3.25, 1.  , 0.75])\n"]},
{"library": "numpy", "item_id": "numpy.poly1d", "code": "\nclass numpy.poly1d(c_or_r, r=False, variable=None)[source]\u00b6", "description": "A one-dimensional polynomial class.\nA convenience class, used to encapsulate \u201cnatural\u201d operations on\npolynomials so that said operations may take on their customary\nform in code (see Examples).\n\nParameters\n\nc_or_rarray_likeThe polynomial\u2019s coefficients, in decreasing powers, or if\nthe value of the second parameter is True, the polynomial\u2019s\nroots (values where the polynomial evaluates to 0).  For example,\npoly1d([1, 2, 3]) returns an object that represents\n, whereas poly1d([1, 2, 3], True) returns\none that represents .\n\nrbool, optionalIf True, c_or_r specifies the polynomial\u2019s roots; the default\nis False.\n\nvariablestr, optionalChanges the variable used when printing p from x to variable\n(see Examples).\n\n\n\n\nExamples\nConstruct the polynomial :\n&gt;&gt;&gt; p = np.poly1d([1, 2, 3])\n&gt;&gt;&gt; print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n\n\nEvaluate the polynomial at :\n&gt;&gt;&gt; p(0.5)\n4.25\n\n\nFind the roots:\n&gt;&gt;&gt; p.r\narray([-1.+1.41421356j, -1.-1.41421356j])\n&gt;&gt;&gt; p(p.r)\narray([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n\n\nThese numbers in the previous line represent (0, 0) to machine precision\nShow the coefficients:\n&gt;&gt;&gt; p.c\narray([1, 2, 3])\n\n\nDisplay the order (the leading zero-coefficients are removed):\n&gt;&gt;&gt; p.order\n2\n\n\nShow the coefficient of the k-th power in the polynomial\n(which is equivalent to p.c[-(i+1)]):\n&gt;&gt;&gt; p[1]\n2\n\n\nPolynomials can be added, subtracted, multiplied, and divided\n(returns quotient and remainder):\n&gt;&gt;&gt; p * p\npoly1d([ 1,  4, 10, 12,  9])\n\n\n&gt;&gt;&gt; (p**3 + 4) / p\n(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n\n\nasarray(p) gives the coefficient array, so polynomials can be\nused in all functions that accept arrays:\n&gt;&gt;&gt; p**2 # square of polynomial\npoly1d([ 1,  4, 10, 12,  9])\n\n\n&gt;&gt;&gt; np.square(p) # square of individual coefficients\narray([1, 4, 9])\n\n\nThe variable used in the string representation of p can be modified,\nusing the variable parameter:\n&gt;&gt;&gt; p = np.poly1d([1,2,3], variable='z')\n&gt;&gt;&gt; print(p)\n   2\n1 z + 2 z + 3\n\n\nConstruct a polynomial from its roots:\n&gt;&gt;&gt; np.poly1d([1, 2], True)\npoly1d([ 1., -3.,  2.])\n\n\nThis is the same polynomial as obtained by:\n&gt;&gt;&gt; np.poly1d([1, -1]) * np.poly1d([1, -2])\npoly1d([ 1, -3,  2])\n\n\n\nAttributes\n\ncThe polynomial coefficients\n\ncoefThe polynomial coefficients\n\ncoefficientsThe polynomial coefficients\n\ncoeffsThe polynomial coefficients\n\noThe order or degree of the polynomial\n\norderThe order or degree of the polynomial\n\nrThe roots of the polynomial, where self(x) == 0\n\nrootsThe roots of the polynomial, where self(x) == 0\n\nvariableThe name of the polynomial variable\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0val)\nCall self as a function.\n\nderiv(self[,\u00a0m])\nReturn a derivative of this polynomial.\n\ninteg(self[,\u00a0m,\u00a0k])\nReturn an antiderivative (indefinite integral) of this polynomial.\n\n\n\n", "parameters": ["Parameters", "c_or_rarray_like", "rbool, optional", "variablestr, optional", "Attributes", "c", "coef", "coefficients", "coeffs", "o", "order", "r", "roots", "variable"], "returns": [], "examples": ["; p = np.poly1d([1, 2, 3])\n; print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n\n", "; p = np.poly1d([1, 2, 3])\n; print(np.poly1d(p))\n   2\n1 x + 2 x + 3\n", "; p(0.5)\n4.25\n\n", "; p(0.5)\n4.25\n", "; p.r\narray([-1.+1.41421356j, -1.-1.41421356j])\n; p(p.r)\narray([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n\n", "; p.r\narray([-1.+1.41421356j, -1.-1.41421356j])\n; p(p.r)\narray([ -4.44089210e-16+0.j,  -4.44089210e-16+0.j]) # may vary\n", "; p.c\narray([1, 2, 3])\n\n", "; p.c\narray([1, 2, 3])\n", "; p.order\n2\n\n", "; p.order\n2\n", "; p[1]\n2\n\n", "; p[1]\n2\n", "; p * p\npoly1d([ 1,  4, 10, 12,  9])\n\n", "; p * p\npoly1d([ 1,  4, 10, 12,  9])\n", "; (p**3 + 4) / p\n(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n\n", "; (p**3 + 4) / p\n(poly1d([ 1.,  4., 10., 12.,  9.]), poly1d([4.]))\n", "; p**2 # square of polynomial\npoly1d([ 1,  4, 10, 12,  9])\n\n", "; p**2 # square of polynomial\npoly1d([ 1,  4, 10, 12,  9])\n", "; np.square(p) # square of individual coefficients\narray([1, 4, 9])\n\n", "; np.square(p) # square of individual coefficients\narray([1, 4, 9])\n", "; p = np.poly1d([1,2,3], variable='z')\n; print(p)\n   2\n1 z + 2 z + 3\n\n", "; p = np.poly1d([1,2,3], variable='z')\n; print(p)\n   2\n1 z + 2 z + 3\n", "; np.poly1d([1, 2], True)\npoly1d([ 1., -3.,  2.])\n\n", "; np.poly1d([1, 2], True)\npoly1d([ 1., -3.,  2.])\n", "; np.poly1d([1, -1]) * np.poly1d([1, -2])\npoly1d([ 1, -3,  2])\n\n", "; np.poly1d([1, -1]) * np.poly1d([1, -2])\npoly1d([ 1, -3,  2])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.poly2lag", "code": "\nnumpy.polynomial.laguerre.poly2lag(pol)[source]\u00b6", "description": "Convert a polynomial to a Laguerre series.\nConvert an array representing the coefficients of a polynomial (relative\nto the \u201cstandard\u201d basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Laguerre series, ordered\nfrom lowest to highest degree.\n\nParameters\n\npolarray_like1-D array containing the polynomial coefficients\n\n\n\nReturns\n\ncndarray1-D array containing the coefficients of the equivalent Laguerre\nseries.\n\n\n\n\n\nSee also\nlag2poly\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import poly2lag\n&gt;&gt;&gt; poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])\n\n\n", "parameters": ["Parameters", "polarray_like", "Returns", "cndarray"], "returns": "cndarray1-D array containing the coefficients of the equivalent Laguerreseries.", "examples": ["; from numpy.polynomial.laguerre import poly2lag\n; poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])\n\n", "; from numpy.polynomial.laguerre import poly2lag\n; poly2lag(np.arange(4))\narray([ 23., -63.,  58., -18.])\n"]},
{"library": "numpy", "item_id": "numpy.poly", "code": "\nnumpy.poly(seq_of_zeros)[source]\u00b6", "description": "Find the coefficients of a polynomial with the given sequence of roots.\nReturns the coefficients of the polynomial whose leading coefficient\nis one for the given sequence of zeros (multiple roots must be included\nin the sequence as many times as their multiplicity; see Examples).\nA square matrix (or array, which will be treated as a matrix) can also\nbe given, in which case the coefficients of the characteristic polynomial\nof the matrix are returned.\n\nParameters\n\nseq_of_zerosarray_like, shape (N,) or (N, N)A sequence of polynomial roots, or a square array or matrix object.\n\n\n\nReturns\n\ncndarray1D array of polynomial coefficients from highest to lowest degree:\nc[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]\nwhere c[0] always equals 1.\n\n\n\nRaises\n\nValueErrorIf input is the wrong shape (the input must be a 1-D or square\n2-D array).\n\n\n\n\n\nSee also\n\npolyvalCompute polynomial values.\n\nrootsReturn the roots of a polynomial.\n\npolyfitLeast squares polynomial fit.\n\npoly1dA one-dimensional polynomial class.\n\n\n\nNotes\nSpecifying the roots of a polynomial still leaves one degree of\nfreedom, typically represented by an undetermined leading\ncoefficient. [1] In the case of this function, that coefficient -\nthe first one in the returned array - is always taken as one. (If\nfor some reason you have one other point, the only automatic way\npresently to leverage that information is to use polyfit.)\nThe characteristic polynomial, , of an n-by-n\nmatrix A is given by\n\n,\n\nwhere I is the n-by-n identity matrix. [2]\nReferences\n\n1\nM. Sullivan and M. Sullivan, III, \u201cAlgebra and Trignometry,\nEnhanced With Graphing Utilities,\u201d Prentice-Hall, pg. 318, 1996.\n\n2\nG. Strang, \u201cLinear Algebra and Its Applications, 2nd Edition,\u201d\nAcademic Press, pg. 182, 1980.\n\n\nExamples\nGiven a sequence of a polynomial\u2019s zeros:\n&gt;&gt;&gt; np.poly((0, 0, 0)) # Multiple root example\narray([1., 0., 0., 0.])\n\n\nThe line above represents z**3 + 0*z**2 + 0*z + 0.\n&gt;&gt;&gt; np.poly((-1./2, 0, 1./2))\narray([ 1.  ,  0.  , -0.25,  0.  ])\n\n\nThe line above represents z**3 - z/4\n&gt;&gt;&gt; np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))\narray([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random\n\n\nGiven a square array object:\n&gt;&gt;&gt; P = np.array([[0, 1./3], [-1./2, 0]])\n&gt;&gt;&gt; np.poly(P)\narray([1.        , 0.        , 0.16666667])\n\n\nNote how in all cases the leading coefficient is always 1.\n", "parameters": ["Parameters", "seq_of_zerosarray_like, shape (N,) or (N, N)", "Returns", "cndarray", "Raises", "ValueError"], "returns": "cndarray1D array of polynomial coefficients from highest to lowest degree:c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]where c[0] always equals 1.", "examples": ["; np.poly((0, 0, 0)) # Multiple root example\narray([1., 0., 0., 0.])\n\n", "; np.poly((0, 0, 0)) # Multiple root example\narray([1., 0., 0., 0.])\n", "; np.poly((-1./2, 0, 1./2))\narray([ 1.  ,  0.  , -0.25,  0.  ])\n\n", "; np.poly((-1./2, 0, 1./2))\narray([ 1.  ,  0.  , -0.25,  0.  ])\n", "; np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))\narray([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random\n\n", "; np.poly((np.random.random(1)[0], 0, np.random.random(1)[0]))\narray([ 1.        , -0.77086955,  0.08618131,  0.        ]) # random\n", "; P = np.array([[0, 1./3], [-1./2, 0]])\n; np.poly(P)\narray([1.        , 0.        , 0.16666667])\n\n", "; P = np.array([[0, 1./3], [-1./2, 0]])\n; np.poly(P)\narray([1.        , 0.        , 0.16666667])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.poly2herme", "code": "\nnumpy.polynomial.hermite_e.poly2herme(pol)[source]\u00b6", "description": "Convert a polynomial to a Hermite series.\nConvert an array representing the coefficients of a polynomial (relative\nto the \u201cstandard\u201d basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Hermite series, ordered\nfrom lowest to highest degree.\n\nParameters\n\npolarray_like1-D array containing the polynomial coefficients\n\n\n\nReturns\n\ncndarray1-D array containing the coefficients of the equivalent Hermite\nseries.\n\n\n\n\n\nSee also\nherme2poly\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import poly2herme\n&gt;&gt;&gt; poly2herme(np.arange(4))\narray([  2.,  10.,   2.,   3.])\n\n\n", "parameters": ["Parameters", "polarray_like", "Returns", "cndarray"], "returns": "cndarray1-D array containing the coefficients of the equivalent Hermiteseries.", "examples": ["; from numpy.polynomial.hermite_e import poly2herme\n; poly2herme(np.arange(4))\narray([  2.,  10.,   2.,   3.])\n\n", "; from numpy.polynomial.hermite_e import poly2herme\n; poly2herme(np.arange(4))\narray([  2.,  10.,   2.,   3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.poly2herm", "code": "\nnumpy.polynomial.hermite.poly2herm(pol)[source]\u00b6", "description": "Convert a polynomial to a Hermite series.\nConvert an array representing the coefficients of a polynomial (relative\nto the \u201cstandard\u201d basis) ordered from lowest degree to highest, to an\narray of the coefficients of the equivalent Hermite series, ordered\nfrom lowest to highest degree.\n\nParameters\n\npolarray_like1-D array containing the polynomial coefficients\n\n\n\nReturns\n\ncndarray1-D array containing the coefficients of the equivalent Hermite\nseries.\n\n\n\n\n\nSee also\nherm2poly\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import poly2herm\n&gt;&gt;&gt; poly2herm(np.arange(4))\narray([1.   ,  2.75 ,  0.5  ,  0.375])\n\n\n", "parameters": ["Parameters", "polarray_like", "Returns", "cndarray"], "returns": "cndarray1-D array containing the coefficients of the equivalent Hermiteseries.", "examples": ["; from numpy.polynomial.hermite import poly2herm\n; poly2herm(np.arange(4))\narray([1.   ,  2.75 ,  0.5  ,  0.375])\n\n", "; from numpy.polynomial.hermite import poly2herm\n; poly2herm(np.arange(4))\narray([1.   ,  2.75 ,  0.5  ,  0.375])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.poisson", "code": "\nRandomState.poisson(lam=1.0, size=None)\u00b6", "description": "Draw samples from a Poisson distribution.\nThe Poisson distribution is the limit of the binomial distribution\nfor large N.\n\nNote\nNew code should use the poisson method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlamfloat or array_like of floatsExpectation of interval, must be &gt;= 0. A sequence of expectation\nintervals must be broadcastable over the requested size.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if lam is a scalar. Otherwise,\nnp.array(lam).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Poisson distribution.\n\n\n\n\n\nSee also\n\nGenerator.poissonwhich should be used for new code.\n\n\n\nNotes\nThe Poisson distribution\n\n\nFor events with an expected separation  the Poisson\ndistribution  describes the probability of\n events occurring within the observed\ninterval .\nBecause the output is limited to the range of the C int64 type, a\nValueError is raised when lam is within 10 sigma of the maximum\nrepresentable value.\nReferences\n\n1\nWeisstein, Eric W. \u201cPoisson Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/PoissonDistribution.html\n\n2\nWikipedia, \u201cPoisson distribution\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = np.random.poisson(5, 10000)\n\n\nDisplay histogram of the sample:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 14, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw each 100 values for lambda 100 and 500:\n&gt;&gt;&gt; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n\n\n", "parameters": ["Parameters", "lamfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Poisson distribution.", "examples": ["; import numpy as np\n; s = np.random.poisson(5, 10000)\n\n", "; import numpy as np\n; s = np.random.poisson(5, 10000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n", "; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n\n", "; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.poisson", "code": "\nGenerator.poisson(lam=1.0, size=None)\u00b6", "description": "Draw samples from a Poisson distribution.\nThe Poisson distribution is the limit of the binomial distribution\nfor large N.\n\nParameters\n\nlamfloat or array_like of floatsExpectation of interval, must be &gt;= 0. A sequence of expectation\nintervals must be broadcastable over the requested size.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if lam is a scalar. Otherwise,\nnp.array(lam).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Poisson distribution.\n\n\n\n\nNotes\nThe Poisson distribution\n\n\nFor events with an expected separation  the Poisson\ndistribution  describes the probability of\n events occurring within the observed\ninterval .\nBecause the output is limited to the range of the C int64 type, a\nValueError is raised when lam is within 10 sigma of the maximum\nrepresentable value.\nReferences\n\n1\nWeisstein, Eric W. \u201cPoisson Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/PoissonDistribution.html\n\n2\nWikipedia, \u201cPoisson distribution\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; s = rng.poisson(5, 10000)\n\n\nDisplay histogram of the sample:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 14, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw each 100 values for lambda 100 and 500:\n&gt;&gt;&gt; s = rng.poisson(lam=(100., 500.), size=(100, 2))\n\n\n", "parameters": ["Parameters", "lamfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Poisson distribution.", "examples": ["; import numpy as np\n; rng = np.random.default_rng()\n; s = rng.poisson(5, 10000)\n\n", "; import numpy as np\n; rng = np.random.default_rng()\n; s = rng.poisson(5, 10000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n", "; s = rng.poisson(lam=(100., 500.), size=(100, 2))\n\n", "; s = rng.poisson(lam=(100., 500.), size=(100, 2))\n"]},
{"library": "numpy", "item_id": "numpy.random.poisson", "code": "\nnumpy.random.poisson(lam=1.0, size=None)\u00b6", "description": "Draw samples from a Poisson distribution.\nThe Poisson distribution is the limit of the binomial distribution\nfor large N.\n\nNote\nNew code should use the poisson method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlamfloat or array_like of floatsExpectation of interval, must be &gt;= 0. A sequence of expectation\nintervals must be broadcastable over the requested size.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if lam is a scalar. Otherwise,\nnp.array(lam).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Poisson distribution.\n\n\n\n\n\nSee also\n\nGenerator.poissonwhich should be used for new code.\n\n\n\nNotes\nThe Poisson distribution\n\n\nFor events with an expected separation  the Poisson\ndistribution  describes the probability of\n events occurring within the observed\ninterval .\nBecause the output is limited to the range of the C int64 type, a\nValueError is raised when lam is within 10 sigma of the maximum\nrepresentable value.\nReferences\n\n1\nWeisstein, Eric W. \u201cPoisson Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/PoissonDistribution.html\n\n2\nWikipedia, \u201cPoisson distribution\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; s = np.random.poisson(5, 10000)\n\n\nDisplay histogram of the sample:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 14, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw each 100 values for lambda 100 and 500:\n&gt;&gt;&gt; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n\n\n", "parameters": ["Parameters", "lamfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Poisson distribution.", "examples": ["; import numpy as np\n; s = np.random.poisson(5, 10000)\n\n", "; import numpy as np\n; s = np.random.poisson(5, 10000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 14, density=True)\n; plt.show()\n", "; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n\n", "; s = np.random.poisson(lam=(100., 500.), size=(100, 2))\n"]},
{"library": "numpy", "item_id": "numpy.pmt", "code": "\nnumpy.pmt(rate, nper, pv, fv=0, when='end')[source]\u00b6", "description": "Compute the payment against loan principal plus interest.\n\nDeprecated since version 1.18: pmt is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nGiven:\na present value, pv (e.g., an amount borrowed)\na future value, fv (e.g., 0)\nan interest rate compounded once per period, of which\nthere are\nnper total\nand (optional) specification of whether payment is made\nat the beginning (when = {\u2018begin\u2019, 1}) or the end\n(when = {\u2018end\u2019, 0}) of each period\n\n\nReturn:the (fixed) periodic payment.\n\n\n\nParameters\n\nratearray_likeRate of interest (per period)\n\nnperarray_likeNumber of compounding periods\n\npvarray_likePresent value\n\nfvarray_like,  optionalFuture value (default = 0)\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}When payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0))\n\n\n\nReturns\n\noutndarrayPayment against loan plus interest.  If all input is scalar, returns a\nscalar float.  If any input is array_like, returns payment for each\ninput element. If multiple inputs are array_like, they all must have\nthe same shape.\n\n\n\n\nNotes\nThe payment is computed by solving the equation:\nfv +\npv*(1 + rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n\nor, when rate == 0:\nfv + pv + pmt * nper == 0\n\n\nfor pmt.\nNote that computing a monthly mortgage payment is only\none use for this function.  For example, pmt returns the\nperiodic deposit one must make to achieve a specified\nfuture balance given an initial deposit, a fixed,\nperiodically compounded interest rate, and the total\nnumber of periods.\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nWheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\nOpen Document Format for Office Applications (OpenDocument)v1.2,\nPart 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\nPre-Draft 12. Organization for the Advancement of Structured Information\nStandards (OASIS). Billerica, MA, USA. [ODT Document].\nAvailable:\nhttp://www.oasis-open.org/committees/documents.php\n?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt\n\n\nExamples\nWhat is the monthly payment needed to pay off a $200,000 loan in 15\nyears at an annual interest rate of 7.5%?\n&gt;&gt;&gt; np.pmt(0.075/12, 12*15, 200000)\n-1854.0247200054619\n\n\nIn order to pay-off (i.e., have a future-value of 0) the $200,000 obtained\ntoday, a monthly payment of $1,854.02 would be required.  Note that this\nexample illustrates usage of fv having a default value of 0.\n", "parameters": ["Parameters", "ratearray_like", "nperarray_like", "pvarray_like", "fvarray_like,  optional", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}", "Returns", "outndarray"], "returns": "outndarrayPayment against loan plus interest.  If all input is scalar, returns ascalar float.  If any input is array_like, returns payment for eachinput element. If multiple inputs are array_like, they all must havethe same shape.", "examples": ["; np.pmt(0.075/12, 12*15, 200000)\n-1854.0247200054619\n\n", "; np.pmt(0.075/12, 12*15, 200000)\n-1854.0247200054619\n"]},
{"library": "numpy", "item_id": "numpy.place", "code": "\nnumpy.place(arr, mask, vals)[source]\u00b6", "description": "Change elements of an array based on conditional and input values.\nSimilar to np.copyto(arr, vals, where=mask), the difference is that\nplace uses the first N elements of vals, where N is the number of\nTrue values in mask, while copyto uses the elements where mask\nis True.\nNote that extract does the exact opposite of place.\n\nParameters\n\narrndarrayArray to put data into.\n\nmaskarray_likeBoolean mask array. Must have the same size as a.\n\nvals1-D sequenceValues to put into a. Only the first N elements are used, where\nN is the number of True values in mask. If vals is smaller\nthan N, it will be repeated, and if elements of a are to be masked,\nthis sequence must be non-empty.\n\n\n\n\n\nSee also\ncopyto, put, take, extract\n\nExamples\n&gt;&gt;&gt; arr = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; np.place(arr, arr&gt;2, [44, 55])\n&gt;&gt;&gt; arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])\n\n\n", "parameters": ["Parameters", "arrndarray", "maskarray_like", "vals1-D sequence"], "returns": [], "examples": ["; arr = np.arange(6).reshape(2, 3)\n; np.place(arr, arr&gt;2, [44, 55])\n; arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])\n\n", "; arr = np.arange(6).reshape(2, 3)\n; np.place(arr, arr&gt;2, [44, 55])\n; arr\narray([[ 0,  1,  2],\n       [44, 55, 44]])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.pinv", "code": "\nnumpy.linalg.pinv(a, rcond=1e-15, hermitian=False)[source]\u00b6", "description": "Compute the (Moore-Penrose) pseudo-inverse of a matrix.\nCalculate the generalized inverse of a matrix using its\nsingular-value decomposition (SVD) and including all\nlarge singular values.\n\nChanged in version 1.14: Can now operate on stacks of matrices\n\n\nParameters\n\na(\u2026, M, N) array_likeMatrix or stack of matrices to be pseudo-inverted.\n\nrcond(\u2026) array_like of floatCutoff for small singular values.\nSingular values less than or equal to\nrcond * largest_singular_value are set to zero.\nBroadcasts against the stack of matrices.\n\nhermitianbool, optionalIf True, a is assumed to be Hermitian (symmetric if real-valued),\nenabling a more efficient method for finding singular values.\nDefaults to False.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nB(\u2026, N, M) ndarrayThe pseudo-inverse of a. If a is a matrix instance, then so\nis B.\n\n\n\nRaises\n\nLinAlgErrorIf the SVD computation does not converge.\n\n\n\n\nNotes\nThe pseudo-inverse of a matrix A, denoted , is\ndefined as: \u201cthe matrix that \u2018solves\u2019 [the least-squares problem]\n,\u201d i.e., if  is said solution, then\n is that matrix such that .\nIt can be shown that if  is the singular\nvalue decomposition of A, then\n, where  are\northogonal matrices,  is a diagonal matrix consisting\nof A\u2019s so-called singular values, (followed, typically, by\nzeros), and then  is simply the diagonal matrix\nconsisting of the reciprocals of A\u2019s singular values\n(again, followed by zeros). [1]\nReferences\n\n1\nG. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando,\nFL, Academic Press, Inc., 1980, pp. 139-142.\n\n\nExamples\nThe following example checks that a * a+ * a == a and\na+ * a * a+ == a+:\n&gt;&gt;&gt; a = np.random.randn(9, 6)\n&gt;&gt;&gt; B = np.linalg.pinv(a)\n&gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n&gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue\n\n\n", "parameters": ["Parameters", "a(\u2026, M, N) array_like", "rcond(\u2026) array_like of float", "hermitianbool, optional", "Returns", "B(\u2026, N, M) ndarray", "Raises", "LinAlgError"], "returns": "B(\u2026, N, M) ndarrayThe pseudo-inverse of a. If a is a matrix instance, then sois B.", "examples": ["; a = np.random.randn(9, 6)\n; B = np.linalg.pinv(a)\n; np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n; np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue\n\n", "; a = np.random.randn(9, 6)\n; B = np.linalg.pinv(a)\n; np.allclose(a, np.dot(a, np.dot(B, a)))\nTrue\n; np.allclose(B, np.dot(B, np.dot(a, B)))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.piecewise", "code": "\nnumpy.piecewise(x, condlist, funclist, *args, **kw)[source]\u00b6", "description": "Evaluate a piecewise-defined function.\nGiven a set of conditions and corresponding functions, evaluate each\nfunction on the input data wherever its condition is true.\n\nParameters\n\nxndarray or scalarThe input domain.\n\ncondlistlist of bool arrays or bool scalarsEach boolean array corresponds to a function in funclist.  Wherever\ncondlist[i] is True, funclist[i](x) is used as the output value.\nEach boolean array in condlist selects a piece of x,\nand should therefore be of the same shape as x.\nThe length of condlist must correspond to that of funclist.\nIf one extra function is given, i.e. if\nlen(funclist) == len(condlist) + 1, then that extra function\nis the default value, used wherever all conditions are false.\n\nfunclistlist of callables, f(x,*args,**kw), or scalarsEach function is evaluated over x wherever its corresponding\ncondition is True.  It should take a 1d array as input and give an 1d\narray or a scalar value as output.  If, instead of a callable,\na scalar is provided then a constant function (lambda x: scalar) is\nassumed.\n\nargstuple, optionalAny further arguments given to piecewise are passed to the functions\nupon execution, i.e., if called piecewise(..., ..., 1, 'a'), then\neach function is called as f(x, 1, 'a').\n\nkwdict, optionalKeyword arguments used in calling piecewise are passed to the\nfunctions upon execution, i.e., if called\npiecewise(..., ..., alpha=1), then each function is called as\nf(x, alpha=1).\n\n\n\nReturns\n\noutndarrayThe output is the same shape and type as x and is found by\ncalling the functions in funclist on the appropriate portions of x,\nas defined by the boolean arrays in condlist.  Portions not covered\nby any condition have a default value of 0.\n\n\n\n\n\nSee also\nchoose, select, where\n\nNotes\nThis is similar to choose or select, except that functions are\nevaluated on elements of x that satisfy the corresponding condition from\ncondlist.\nThe result is:\n      |--\n      |funclist[0](x[condlist[0]])\nout = |funclist[1](x[condlist[1]])\n      |...\n      |funclist[n2](x[condlist[n2]])\n      |--\n\n\nExamples\nDefine the sigma function, which is -1 for x &lt; 0 and +1 for x &gt;= 0.\n&gt;&gt;&gt; x = np.linspace(-2.5, 2.5, 6)\n&gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])\narray([-1., -1., -1.,  1.,  1.,  1.])\n\n\nDefine the absolute value, which is -x for x &lt;0 and x for\nx &gt;= 0.\n&gt;&gt;&gt; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])\narray([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n\n\nApply the same function to a scalar value.\n&gt;&gt;&gt; y = -2\n&gt;&gt;&gt; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])\narray(2)\n\n\n", "parameters": ["Parameters", "xndarray or scalar", "condlistlist of bool arrays or bool scalars", "funclistlist of callables, f(x,*args,**kw), or scalars", "argstuple, optional", "kwdict, optional", "Returns", "outndarray"], "returns": "outndarrayThe output is the same shape and type as x and is found bycalling the functions in funclist on the appropriate portions of x,as defined by the boolean arrays in condlist.  Portions not coveredby any condition have a default value of 0.", "examples": ["; x = np.linspace(-2.5, 2.5, 6)\n; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])\narray([-1., -1., -1.,  1.,  1.,  1.])\n\n", "; x = np.linspace(-2.5, 2.5, 6)\n; np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1])\narray([-1., -1., -1.,  1.,  1.,  1.])\n", "; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])\narray([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n\n", "; np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x])\narray([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])\n", "; y = -2\n; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])\narray(2)\n\n", "; y = -2\n; np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x])\narray(2)\n"]},
{"library": "numpy", "item_id": "numpy.random.Philox", "code": "\nclass numpy.random.Philox(seed=None, counter=None, key=None)\u00b6", "description": "Container for the Philox (4x64) pseudo-random number generator.\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\nSeedSequence to derive the initial BitGenerator state. One may also\npass in a SeedSequence instance.\n\ncounter{None, int, array_like}, optionalCounter to use in the Philox state. Can be either\na Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array.\nIf not provided, the RNG is initialized at 0.\n\nkey{None, int, array_like}, optionalKey to use in the Philox state.  Unlike seed, the value in key is\ndirectly set. Can be either a Python int in [0, 2**128) or a 2-element\nuint64 array. key and seed cannot both be used.\n\n\n\n\nNotes\nPhilox is a 64-bit PRNG that uses a counter-based design based on weaker\n(and faster) versions of cryptographic functions [1]. Instances using\ndifferent values of the key produce independent sequences.  Philox has a\nperiod of  and supports arbitrary advancing and jumping\nthe sequence in increments of . These features allow\nmultiple non-overlapping sequences to be generated.\nPhilox provides a capsule containing function pointers that produce\ndoubles, and unsigned 32 and 64- bit integers. These are not\ndirectly consumable in Python and must be consumed by a Generator\nor similar object that supports low-level access.\nState and Seeding\nThe Philox state vector consists of a 256-bit value encoded as\na 4-element uint64 array and a 128-bit value encoded as a 2-element uint64\narray. The former is a counter which is incremented by 1 for every 4 64-bit\nrandoms produced. The second is a key which determined the sequence\nproduced. Using different keys produces independent sequences.\nThe input seed is processed by SeedSequence to generate the key. The\ncounter is set to 0.\nAlternately, one can omit the seed parameter and set the key and\ncounter directly.\nParallel Features\nThe preferred way to use a BitGenerator in parallel applications is to use\nthe SeedSequence.spawn method to obtain entropy values, and to use these\nto generate new BitGenerators:\n&gt;&gt;&gt; from numpy.random import Generator, Philox, SeedSequence\n&gt;&gt;&gt; sg = SeedSequence(1234)\n&gt;&gt;&gt; rg = [Generator(Philox(s)) for s in sg.spawn(10)]\n\n\nPhilox can be used in parallel applications by calling the jumped\nmethod  to advances the state as-if  random numbers have\nbeen generated. Alternatively, advance can be used to advance the\ncounter for any positive step in [0, 2**256). When using jumped, all\ngenerators should be chained to ensure that the segments come from the same\nsequence.\n&gt;&gt;&gt; from numpy.random import Generator, Philox\n&gt;&gt;&gt; bit_generator = Philox(1234)\n&gt;&gt;&gt; rg = []\n&gt;&gt;&gt; for _ in range(10):\n...    rg.append(Generator(bit_generator))\n...    bit_generator = bit_generator.jumped()\n\n\nAlternatively, Philox can be used in parallel applications by using\na sequence of distinct keys where each instance uses different key.\n&gt;&gt;&gt; key = 2**96 + 2**33 + 2**17 + 2**9\n&gt;&gt;&gt; rg = [Generator(Philox(key=key+i)) for i in range(10)]\n\n\nCompatibility Guarantee\nPhilox makes a guarantee that a fixed seed will always produce\nthe same random integer stream.\nReferences\n\n1\nJohn K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw,\n\u201cParallel Random Numbers: As Easy as 1, 2, 3,\u201d Proceedings of\nthe International Conference for High Performance Computing,\nNetworking, Storage and Analysis (SC11), New York, NY: ACM, 2011.\n\n\nExamples\n&gt;&gt;&gt; from numpy.random import Generator, Philox\n&gt;&gt;&gt; rg = Generator(Philox(1234))\n&gt;&gt;&gt; rg.standard_normal()\n0.123  # random\n\n\n\nAttributes\n\nlock: threading.LockLock instance that is shared so that the same bit git generator can\nbe used in multiple Generators without corrupting the state. Code that\ngenerates values from a bit generator should hold the bit generator\u2019s\nlock.\n\n\n\n\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence}, optional", "counter{None, int, array_like}, optional", "key{None, int, array_like}, optional", "Attributes", "lock: threading.Lock"], "returns": [], "examples": ["; from numpy.random import Generator, Philox\n; rg = Generator(Philox(1234))\n; rg.standard_normal()\n0.123  # random\n\n", "; from numpy.random import Generator, Philox\n; rg = Generator(Philox(1234))\n; rg.standard_normal()\n0.123  # random\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.permutation", "code": "\nRandomState.permutation(x)\u00b6", "description": "Randomly permute a sequence, or return a permuted range.\nIf x is a multi-dimensional array, it is only shuffled along its\nfirst index.\n\nNote\nNew code should use the permutation method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nxint or array_likeIf x is an integer, randomly permute np.arange(x).\nIf x is an array, make a copy and shuffle the elements\nrandomly.\n\n\n\nReturns\n\noutndarrayPermuted sequence or array range.\n\n\n\n\n\nSee also\n\nGenerator.permutationwhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n\n&gt;&gt;&gt; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n\n", "parameters": ["Parameters", "xint or array_like", "Returns", "outndarray"], "returns": "outndarrayPermuted sequence or array range.", "examples": ["; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n", "; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n", "; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n", "; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.permutation", "code": "\nGenerator.permutation(x, axis=0)\u00b6", "description": "Randomly permute a sequence, or return a permuted range.\n\nParameters\n\nxint or array_likeIf x is an integer, randomly permute np.arange(x).\nIf x is an array, make a copy and shuffle the elements\nrandomly.\n\naxisint, optionalThe axis which x is shuffled along. Default is 0.\n\n\n\nReturns\n\noutndarrayPermuted sequence or array range.\n\n\n\n\nExamples\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n\n&gt;&gt;&gt; rng.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; rng.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n\n&gt;&gt;&gt; rng.permutation(\"abc\")\nTraceback (most recent call last):\n    ...\nnumpy.AxisError: x must be an integer or at least 1-dimensional\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; rng.permutation(arr, axis=1)\narray([[0, 2, 1], # random\n       [3, 5, 4],\n       [6, 8, 7]])\n\n\n", "parameters": ["Parameters", "xint or array_like", "axisint, optional", "Returns", "outndarray"], "returns": "outndarrayPermuted sequence or array range.", "examples": ["; rng = np.random.default_rng()\n; rng.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n", "; rng = np.random.default_rng()\n; rng.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n", "; rng.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n", "; rng.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n", "; rng.permutation(\"abc\")\nTraceback (most recent call last):\n    ...\nnumpy.AxisError: x must be an integer or at least 1-dimensional\n\n", "; rng.permutation(\"abc\")\nTraceback (most recent call last):\n    ...\nnumpy.AxisError: x must be an integer or at least 1-dimensional\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.permutation(arr, axis=1)\narray([[0, 2, 1], # random\n       [3, 5, 4],\n       [6, 8, 7]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; rng.permutation(arr, axis=1)\narray([[0, 2, 1], # random\n       [3, 5, 4],\n       [6, 8, 7]])\n"]},
{"library": "numpy", "item_id": "numpy.random.permutation", "code": "\nnumpy.random.permutation(x)\u00b6", "description": "Randomly permute a sequence, or return a permuted range.\nIf x is a multi-dimensional array, it is only shuffled along its\nfirst index.\n\nNote\nNew code should use the permutation method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nxint or array_likeIf x is an integer, randomly permute np.arange(x).\nIf x is an array, make a copy and shuffle the elements\nrandomly.\n\n\n\nReturns\n\noutndarrayPermuted sequence or array range.\n\n\n\n\n\nSee also\n\nGenerator.permutationwhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n\n&gt;&gt;&gt; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n\n&gt;&gt;&gt; arr = np.arange(9).reshape((3, 3))\n&gt;&gt;&gt; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n\n", "parameters": ["Parameters", "xint or array_like", "Returns", "outndarray"], "returns": "outndarrayPermuted sequence or array range.", "examples": ["; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n\n", "; np.random.permutation(10)\narray([1, 7, 4, 3, 0, 9, 2, 5, 8, 6]) # random\n", "; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n\n", "; np.random.permutation([1, 4, 9, 12, 15])\narray([15,  1,  9,  4, 12]) # random\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n\n", "; arr = np.arange(9).reshape((3, 3))\n; np.random.permutation(arr)\narray([[6, 7, 8], # random\n       [0, 1, 2],\n       [3, 4, 5]])\n"]},
{"library": "numpy", "item_id": "numpy.random.PCG64", "code": "\nclass numpy.random.PCG64(seed_seq=None)\u00b6", "description": "BitGenerator for the PCG-64 pseudo-random number generator.\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\nSeedSequence to derive the initial BitGenerator state. One may also\npass in a SeedSequence instance.\n\n\n\n\nNotes\nPCG-64 is a 128-bit implementation of O\u2019Neill\u2019s permutation congruential\ngenerator ([1], [2]). PCG-64 has a period of  and supports\nadvancing an arbitrary number of steps as well as  streams.\nThe specific member of the PCG family that we use is PCG XSL RR 128/64\nas described in the paper ([2]).\nPCG64 provides a capsule containing function pointers that produce\ndoubles, and unsigned 32 and 64- bit integers. These are not\ndirectly consumable in Python and must be consumed by a Generator\nor similar object that supports low-level access.\nSupports the method advance to advance the RNG an arbitrary number of\nsteps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned\nintegers.\nState and Seeding\nThe PCG64 state vector consists of 2 unsigned 128-bit values,\nwhich are represented externally as Python ints. One is the state of the\nPRNG, which is advanced by a linear congruential generator (LCG). The\nsecond is a fixed odd increment used in the LCG.\nThe input seed is processed by SeedSequence to generate both values. The\nincrement is not independently settable.\nParallel Features\nThe preferred way to use a BitGenerator in parallel applications is to use\nthe SeedSequence.spawn method to obtain entropy values, and to use these\nto generate new BitGenerators:\n&gt;&gt;&gt; from numpy.random import Generator, PCG64, SeedSequence\n&gt;&gt;&gt; sg = SeedSequence(1234)\n&gt;&gt;&gt; rg = [Generator(PCG64(s)) for s in sg.spawn(10)]\n\n\nCompatibility Guarantee\nPCG64 makes a guarantee that a fixed seed and will always produce\nthe same random integer stream.\nReferences\n\n1\n\u201cPCG, A Family of Better Random Number Generators\u201d\n\n2(1,2)\nO\u2019Neill, Melissa E. \u201cPCG: A Family of Simple Fast Space-Efficient\nStatistically Good Algorithms for Random Number Generation\u201d\n\n\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.partition", "code": "\nrecarray.partition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Rearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\nkthint or sequence of intsElement index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.partitionReturn a parititioned copy of an array.\n\nargpartitionIndirect partition.\n\nsortFull sort.\n\n\n\nNotes\nSee np.partition for notes on the different algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; a.partition(3)\n&gt;&gt;&gt; a\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; a.partition((1, 3))\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "kthint or sequence of ints", "axisint, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.partition", "code": "\nmemmap.partition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Rearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\nkthint or sequence of intsElement index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.partitionReturn a parititioned copy of an array.\n\nargpartitionIndirect partition.\n\nsortFull sort.\n\n\n\nNotes\nSee np.partition for notes on the different algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; a.partition(3)\n&gt;&gt;&gt; a\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; a.partition((1, 3))\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "kthint or sequence of ints", "axisint, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.partition", "code": "\nmatrix.partition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Rearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\nkthint or sequence of intsElement index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.partitionReturn a parititioned copy of an array.\n\nargpartitionIndirect partition.\n\nsortFull sort.\n\n\n\nNotes\nSee np.partition for notes on the different algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; a.partition(3)\n&gt;&gt;&gt; a\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; a.partition((1, 3))\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "kthint or sequence of ints", "axisint, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.percentile", "code": "\nnumpy.percentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=False)[source]\u00b6", "description": "Compute the q-th percentile of the data along the specified axis.\nReturns the q-th percentile(s) of the array elements.\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\nqarray_like of floatPercentile or sequence of percentiles to compute, which must be between\n0 and 100 inclusive.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the percentiles are computed. The\ndefault is to compute the percentile(s) along a flattened\nversion of the array.\n\nChanged in version 1.9.0: A tuple of axes is supported\n\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow the input array a to be modified by intermediate\ncalculations, to save memory. In this case, the contents of the input\na after this function completes is undefined.\n\ninterpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}This optional parameter specifies the interpolation method to\nuse when the desired percentile lies between two data points\ni &lt; j:\n\n\u2018linear\u2019: i + (j - i) * fraction, where fraction\nis the fractional part of the index surrounded by i\nand j.\n\u2018lower\u2019: i.\n\u2018higher\u2019: j.\n\u2018nearest\u2019: i or j, whichever is nearest.\n\u2018midpoint\u2019: (i + j) / 2.\n\n\nNew in version 1.9.0.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left in\nthe result as dimensions with size one. With this option, the\nresult will broadcast correctly against the original array a.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\npercentilescalar or ndarrayIf q is a single percentile and axis=None, then the result\nis a scalar. If multiple percentiles are given, first axis of\nthe result corresponds to the percentiles. The other axes are\nthe axes that remain after the reduction of a. If the input\ncontains integers or floats smaller than float64, the output\ndata-type is float64. Otherwise, the output data-type is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nmean\n\nmedianequivalent to percentile(..., 50)\n\n\nnanpercentile\n\nquantileequivalent to percentile, except with q in the range [0, 1].\n\n\n\nNotes\nGiven a vector V of length N, the q-th percentile of\nV is the value q/100 of the way from the minimum to the\nmaximum in a sorted copy of V. The values and distances of\nthe two nearest neighbors as well as the interpolation parameter\nwill determine the percentile if the normalized ranking does not\nmatch the location of q exactly. This function is the same as\nthe median if q=50, the same as the minimum if q=0 and the\nsame as the maximum if q=100.\nExamples\n&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])\n&gt;&gt;&gt; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n&gt;&gt;&gt; np.percentile(a, 50)\n3.5\n&gt;&gt;&gt; np.percentile(a, 50, axis=0)\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; np.percentile(a, 50, axis=1)\narray([7.,  2.])\n&gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n\n\n&gt;&gt;&gt; m = np.percentile(a, 50, axis=0)\n&gt;&gt;&gt; out = np.zeros_like(m)\n&gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; m\narray([6.5, 4.5, 2.5])\n\n\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)\narray([7.,  2.])\n&gt;&gt;&gt; assert not np.all(a == b)\n\n\nThe different types of interpolation can be visualized graphically:\nimport matplotlib.pyplot as plt\n\na = np.arange(4)\np = np.linspace(0, 100, 6001)\nax = plt.gca()\nlines = [\n    ('linear', None),\n    ('higher', '--'),\n    ('lower', '--'),\n    ('nearest', '-.'),\n    ('midpoint', '-.'),\n]\nfor interpolation, style in lines:\n    ax.plot(\n        p, np.percentile(a, p, interpolation=interpolation),\n        label=interpolation, linestyle=style)\nax.set(\n    title='Interpolation methods for list: ' + str(a),\n    xlabel='Percentile',\n    ylabel='List item returned',\n    yticks=a)\nax.legend()\nplt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "qarray_like of float", "axis{int, tuple of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "interpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}", "keepdimsbool, optional", "Returns", "percentilescalar or ndarray"], "returns": "percentilescalar or ndarrayIf q is a single percentile and axis=None, then the resultis a scalar. If multiple percentiles are given, first axis ofthe result corresponds to the percentiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.percentile(a, 50)\n3.5\n; np.percentile(a, 50, axis=0)\narray([6.5, 4.5, 2.5])\n; np.percentile(a, 50, axis=1)\narray([7.,  2.])\n; np.percentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n\n", "; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.percentile(a, 50)\n3.5\n; np.percentile(a, 50, axis=0)\narray([6.5, 4.5, 2.5])\n; np.percentile(a, 50, axis=1)\narray([7.,  2.])\n; np.percentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n", "; m = np.percentile(a, 50, axis=0)\n; out = np.zeros_like(m)\n; np.percentile(a, 50, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n; m\narray([6.5, 4.5, 2.5])\n\n", "; m = np.percentile(a, 50, axis=0)\n; out = np.zeros_like(m)\n; np.percentile(a, 50, axis=0, out=out)\narray([6.5, 4.5, 2.5])\n; m\narray([6.5, 4.5, 2.5])\n", "; b = a.copy()\n; np.percentile(b, 50, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a == b)\n\n", "; b = a.copy()\n; np.percentile(b, 50, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a == b)\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.partition", "code": "\nndarray.partition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Rearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\nkthint or sequence of intsElement index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.partitionReturn a parititioned copy of an array.\n\nargpartitionIndirect partition.\n\nsortFull sort.\n\n\n\nNotes\nSee np.partition for notes on the different algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; a.partition(3)\n&gt;&gt;&gt; a\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; a.partition((1, 3))\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "kthint or sequence of ints", "axisint, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.partition", "code": "\nchararray.partition(self, sep)[source]\u00b6", "description": "Partition each element in self around sep.\n\nSee also\npartition\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.partition", "code": "\nmasked_array.partition(kth, axis=-1, kind='introselect', order=None)[source]\u00b6", "description": "Rearranges the elements in the array in such a way that the value of the\nelement in kth position is in the position it would be in a sorted array.\nAll elements smaller than the kth element are moved before this element and\nall equal or greater are moved behind it. The ordering of the elements in\nthe two partitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\nkthint or sequence of intsElement index to partition by. The kth element value will be in its\nfinal sorted position and all smaller elements will be moved before it\nand all equal or greater elements behind it.\nThe order of all elements in the partitions is undefined.\nIf provided with a sequence of kth it will partition all elements\nindexed by kth of them into their sorted position at once.\n\naxisint, optionalAxis along which to sort. Default is -1, which means sort along the\nlast axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc. A single field can\nbe specified as a string, and not all fields need to be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\n\n\nSee also\n\nnumpy.partitionReturn a parititioned copy of an array.\n\nargpartitionIndirect partition.\n\nsortFull sort.\n\n\n\nNotes\nSee np.partition for notes on the different algorithms.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; a.partition(3)\n&gt;&gt;&gt; a\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; a.partition((1, 3))\n&gt;&gt;&gt; a\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "kthint or sequence of ints", "axisint, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional"], "returns": [], "examples": ["; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; a.partition(3)\n; a\narray([2, 1, 3, 4])\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n\n", "; a.partition((1, 3))\n; a\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.partition", "code": "\nchararray.partition(self, sep)\u00b6", "description": "Partition each element in self around sep.\n\nSee also\npartition\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.partition", "code": "\nnumpy.char.partition(a, sep)\u00b6", "description": "Partition each element in a around sep.\nCalls str.partition element-wise.\nFor each element in a, split the element as the first\noccurrence of sep, and return 3 strings containing the part\nbefore the separator, the separator itself, and the part after\nthe separator. If the separator is not found, return 3 strings\ncontaining the string itself, followed by two empty strings.\n\nParameters\n\naarray_like, {str, unicode}Input array\n\nsep{str, unicode}Separator to split each string element in a.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type.\nThe output array will have an extra dimension with 3\nelements per input element.\n\n\n\n\n\nSee also\nstr.partition\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "sep{str, unicode}", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type.The output array will have an extra dimension with 3elements per input element.", "examples": []},
{"library": "numpy", "item_id": "numpy.partition", "code": "\nnumpy.partition(a, kth, axis=-1, kind='introselect', order=None)[source]\u00b6", "description": "Return a partitioned copy of an array.\nCreates a copy of the array with its elements rearranged in such a\nway that the value of the element in k-th position is in the\nposition it would be in a sorted array. All elements smaller than\nthe k-th element are moved before this element and all equal or\ngreater are moved behind it. The ordering of the elements in the two\npartitions is undefined.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeArray to be sorted.\n\nkthint or sequence of intsElement index to partition by. The k-th value of the element\nwill be in its final sorted position and all smaller elements\nwill be moved before it and all equal or greater elements behind\nit. The order of all elements in the partitions is undefined. If\nprovided with a sequence of k-th it will partition all elements\nindexed by k-th  of them into their sorted position at once.\n\naxisint or None, optionalAxis along which to sort. If None, the array is flattened before\nsorting. The default is -1, which sorts along the last axis.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019.\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument\nspecifies which fields to compare first, second, etc.  A single\nfield can be specified as a string.  Not all fields need be\nspecified, but unspecified fields will still be used, in the\norder in which they come up in the dtype, to break ties.\n\n\n\nReturns\n\npartitioned_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\n\nndarray.partitionMethod to sort an array in-place.\n\nargpartitionIndirect partition.\n\nsortFull sorting\n\n\n\nNotes\nThe various selection algorithms are characterized by their average\nspeed, worst case performance, work space size, and whether they are\nstable. A stable sort keeps items with the same key in the same\nrelative order. The available algorithms have the following\nproperties:\n\n\n\n\n\n\n\n\n\nkind\nspeed\nworst case\nwork space\nstable\n\n\n\n\u2018introselect\u2019\n1\nO(n)\n0\nno\n\n\n\nAll the partition algorithms make temporary copies of the data when\npartitioning along any but the last axis.  Consequently,\npartitioning along the last axis is faster and uses less space than\npartitioning along any other axis.\nThe sort order for complex numbers is lexicographic. If both the\nreal and imaginary parts are non-nan then the order is determined by\nthe real parts except when they are equal, in which case the order\nis determined by the imaginary parts.\nExamples\n&gt;&gt;&gt; a = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; np.partition(a, 3)\narray([2, 1, 3, 4])\n\n\n&gt;&gt;&gt; np.partition(a, (1, 3))\narray([1, 2, 3, 4])\n\n\n", "parameters": ["Parameters", "aarray_like", "kthint or sequence of ints", "axisint or None, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional", "Returns", "partitioned_arrayndarray"], "returns": "partitioned_arrayndarrayArray of the same type and shape as a.", "examples": ["; a = np.array([3, 4, 2, 1])\n; np.partition(a, 3)\narray([2, 1, 3, 4])\n\n", "; a = np.array([3, 4, 2, 1])\n; np.partition(a, 3)\narray([2, 1, 3, 4])\n", "; np.partition(a, (1, 3))\narray([1, 2, 3, 4])\n\n", "; np.partition(a, (1, 3))\narray([1, 2, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.pareto", "code": "\nRandomState.pareto(a, size=None)\u00b6", "description": "Draw samples from a Pareto II or Lomax distribution with\nspecified shape.\nThe Lomax or Pareto II distribution is a shifted Pareto\ndistribution. The classical Pareto distribution can be\nobtained from the Lomax distribution by adding 1 and\nmultiplying by the scale parameter m (see Notes).  The\nsmallest value of the Lomax distribution is zero while for the\nclassical Pareto distribution it is mu, where the standard\nPareto distribution has location mu = 1.  Lomax can also\nbe considered as a simplified version of the Generalized\nPareto distribution (available in SciPy), with the scale set\nto one and the location set to zero.\nThe Pareto distribution must be greater than zero, and is\nunbounded above.  It is also known as the \u201c80-20 rule\u201d.  In\nthis distribution, 80 percent of the weights are in the lowest\n20 percent of the range, while the other 20 percent fill the\nremaining 80 percent of the range.\n\nNote\nNew code should use the pareto method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsShape of the distribution. Must be positive.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Pareto distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lomaxprobability density function, distribution or cumulative density function, etc.\n\nscipy.stats.genparetoprobability density function, distribution or cumulative density function, etc.\n\nGenerator.paretowhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Pareto distribution is\n\n\nwhere  is the shape and  the scale.\nThe Pareto distribution, named after the Italian economist\nVilfredo Pareto, is a power law probability distribution\nuseful in many real world problems.  Outside the field of\neconomics it is generally referred to as the Bradford\ndistribution. Pareto developed the distribution to describe\nthe distribution of wealth in an economy.  It has also found\nuse in insurance, web page access statistics, oil field sizes,\nand many other problems, including the download frequency for\nprojects in Sourceforge [1].  It is one of the so-called\n\u201cfat-tailed\u201d distributions.\nReferences\n\n1\nFrancis Hunt and Paul Johnson, On the Pareto Distribution of\nSourceforge projects.\n\n2\nPareto, V. (1896). Course of Political Economy. Lausanne.\n\n3\nReiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\nValues, Birkhauser Verlag, Basel, pp 23-30.\n\n4\nWikipedia, \u201cPareto distribution\u201d,\nhttps://en.wikipedia.org/wiki/Pareto_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a, m = 3., 2.  # shape and mode\n&gt;&gt;&gt; s = (np.random.pareto(a, 1000) + 1) * m\n\n\nDisplay the histogram of the samples, along with the probability\ndensity function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, _ = plt.hist(s, 100, density=True)\n&gt;&gt;&gt; fit = a*m**a / bins**(a+1)\n&gt;&gt;&gt; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Pareto distribution.", "examples": ["; a, m = 3., 2.  # shape and mode\n; s = (np.random.pareto(a, 1000) + 1) * m\n\n", "; a, m = 3., 2.  # shape and mode\n; s = (np.random.pareto(a, 1000) + 1) * m\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.pareto", "code": "\nGenerator.pareto(a, size=None)\u00b6", "description": "Draw samples from a Pareto II or Lomax distribution with\nspecified shape.\nThe Lomax or Pareto II distribution is a shifted Pareto\ndistribution. The classical Pareto distribution can be\nobtained from the Lomax distribution by adding 1 and\nmultiplying by the scale parameter m (see Notes).  The\nsmallest value of the Lomax distribution is zero while for the\nclassical Pareto distribution it is mu, where the standard\nPareto distribution has location mu = 1.  Lomax can also\nbe considered as a simplified version of the Generalized\nPareto distribution (available in SciPy), with the scale set\nto one and the location set to zero.\nThe Pareto distribution must be greater than zero, and is\nunbounded above.  It is also known as the \u201c80-20 rule\u201d.  In\nthis distribution, 80 percent of the weights are in the lowest\n20 percent of the range, while the other 20 percent fill the\nremaining 80 percent of the range.\n\nParameters\n\nafloat or array_like of floatsShape of the distribution. Must be positive.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a is a scalar.  Otherwise,\nnp.array(a).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Pareto distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lomaxprobability density function, distribution or cumulative density function, etc.\n\nscipy.stats.genparetoprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Pareto distribution is\n\n\nwhere  is the shape and  the scale.\nThe Pareto distribution, named after the Italian economist\nVilfredo Pareto, is a power law probability distribution\nuseful in many real world problems.  Outside the field of\neconomics it is generally referred to as the Bradford\ndistribution. Pareto developed the distribution to describe\nthe distribution of wealth in an economy.  It has also found\nuse in insurance, web page access statistics, oil field sizes,\nand many other problems, including the download frequency for\nprojects in Sourceforge [1].  It is one of the so-called\n\u201cfat-tailed\u201d distributions.\nReferences\n\n1\nFrancis Hunt and Paul Johnson, On the Pareto Distribution of\nSourceforge projects.\n\n2\nPareto, V. (1896). Course of Political Economy. Lausanne.\n\n3\nReiss, R.D., Thomas, M.(2001), Statistical Analysis of Extreme\nValues, Birkhauser Verlag, Basel, pp 23-30.\n\n4\nWikipedia, \u201cPareto distribution\u201d,\nhttps://en.wikipedia.org/wiki/Pareto_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a, m = 3., 2.  # shape and mode\n&gt;&gt;&gt; s = (np.random.default_rng().pareto(a, 1000) + 1) * m\n\n\nDisplay the histogram of the samples, along with the probability\ndensity function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, _ = plt.hist(s, 100, density=True)\n&gt;&gt;&gt; fit = a*m**a / bins**(a+1)\n&gt;&gt;&gt; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Pareto distribution.", "examples": ["; a, m = 3., 2.  # shape and mode\n; s = (np.random.default_rng().pareto(a, 1000) + 1) * m\n\n", "; a, m = 3., 2.  # shape and mode\n; s = (np.random.default_rng().pareto(a, 1000) + 1) * m\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, _ = plt.hist(s, 100, density=True)\n; fit = a*m**a / bins**(a+1)\n; plt.plot(bins, max(count)*fit/max(fit), linewidth=2, color='r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ma.outer", "code": "\nnumpy.ma.outer(a, b)[source]\u00b6", "description": "Compute the outer product of two vectors.\nGiven two vectors, a = [a0, a1, ..., aM] and\nb = [b0, b1, ..., bN],\nthe outer product [1] is:\n[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n\n\nParameters\n\na(M,) array_likeFirst input vector.  Input is flattened if\nnot already 1-dimensional.\n\nb(N,) array_likeSecond input vector.  Input is flattened if\nnot already 1-dimensional.\n\nout(M, N) ndarray, optionalA location where the result is stored\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\nout(M, N) ndarrayout[i, j] = a[i] * b[j]\n\n\n\n\n\nSee also\ninner\n\neinsumeinsum('i,j-&gt;ij', a.ravel(), b.ravel()) is the equivalent.\n\nufunc.outerA generalization to N dimensions and other operations. np.multiply.outer(a.ravel(), b.ravel()) is the equivalent.\n\n\n\nNotes\nMasked values are replaced by 0.\nReferences\n\n1\n: G. H. Golub and C. F. Van Loan, Matrix Computations, 3rd\ned., Baltimore, MD, Johns Hopkins University Press, 1996,\npg. 8.\n\n\nExamples\nMake a (very coarse) grid for computing a Mandelbrot set:\n&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n&gt;&gt;&gt; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n&gt;&gt;&gt; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n&gt;&gt;&gt; grid = rl + im\n&gt;&gt;&gt; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n\nAn example using a \u201cvector\u201d of letters:\n&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)\n&gt;&gt;&gt; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n\n", "parameters": ["Parameters", "a(M,) array_like", "b(N,) array_like", "out(M, N) ndarray, optional", "Returns", "out(M, N) ndarray"], "returns": "out(M, N) ndarrayout[i, j] = a[i] * b[j]", "examples": ["; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n", "; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n"]},
{"library": "numpy", "item_id": "numpy.outer", "code": "\nnumpy.outer(a, b, out=None)[source]\u00b6", "description": "Compute the outer product of two vectors.\nGiven two vectors, a = [a0, a1, ..., aM] and\nb = [b0, b1, ..., bN],\nthe outer product [1] is:\n[[a0*b0  a0*b1 ... a0*bN ]\n [a1*b0    .\n [ ...          .\n [aM*b0            aM*bN ]]\n\n\n\nParameters\n\na(M,) array_likeFirst input vector.  Input is flattened if\nnot already 1-dimensional.\n\nb(N,) array_likeSecond input vector.  Input is flattened if\nnot already 1-dimensional.\n\nout(M, N) ndarray, optionalA location where the result is stored\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\nout(M, N) ndarrayout[i, j] = a[i] * b[j]\n\n\n\n\n\nSee also\ninner\n\neinsumeinsum('i,j-&gt;ij', a.ravel(), b.ravel()) is the equivalent.\n\nufunc.outerA generalization to N dimensions and other operations. np.multiply.outer(a.ravel(), b.ravel()) is the equivalent.\n\n\n\nReferences\n\n1\n: G. H. Golub and C. F. Van Loan, Matrix Computations, 3rd\ned., Baltimore, MD, Johns Hopkins University Press, 1996,\npg. 8.\n\n\nExamples\nMake a (very coarse) grid for computing a Mandelbrot set:\n&gt;&gt;&gt; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n&gt;&gt;&gt; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n&gt;&gt;&gt; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n&gt;&gt;&gt; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n&gt;&gt;&gt; grid = rl + im\n&gt;&gt;&gt; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n\nAn example using a \u201cvector\u201d of letters:\n&gt;&gt;&gt; x = np.array(['a', 'b', 'c'], dtype=object)\n&gt;&gt;&gt; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n\n", "parameters": ["Parameters", "a(M,) array_like", "b(N,) array_like", "out(M, N) ndarray, optional", "Returns", "out(M, N) ndarray"], "returns": "out(M, N) ndarrayout[i, j] = a[i] * b[j]", "examples": ["; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n\n", "; rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))\n; rl\narray([[-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.],\n       [-2., -1.,  0.,  1.,  2.]])\n; im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))\n; im\narray([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],\n       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],\n       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],\n       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])\n; grid = rl + im\n; grid\narray([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],\n       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],\n       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],\n       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],\n       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n\n", "; x = np.array(['a', 'b', 'c'], dtype=object)\n; np.outer(x, [1, 2, 3])\narray([['a', 'aa', 'aaa'],\n       ['b', 'bb', 'bbb'],\n       ['c', 'cc', 'ccc']], dtype=object)\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.order", "code": "\nproperty poly1d.order\u00b6", "description": "The order or degree of the polynomial\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.operands", "code": "\nnditer.operands\u00b6", "description": "operands[Slice]\nThe array(s) to be iterated over. Valid only before the iterator is closed.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.DataSource.open", "code": "\nDataSource.open(self, path, mode='r', encoding=None, newline=None)[source]\u00b6", "description": "Open and return file-like object.\nIf path is an URL, it will be downloaded, stored in the\nDataSource directory and opened from there.\n\nParameters\n\npathstrLocal file path or URL to open.\n\nmode{\u2018r\u2019, \u2018w\u2019, \u2018a\u2019}, optionalMode to open path.  Mode \u2018r\u2019 for reading, \u2018w\u2019 for writing,\n\u2018a\u2019 to append. Available modes depend on the type of object\nspecified by path. Default is \u2018r\u2019.\n\nencoding{None, str}, optionalOpen text file with given encoding. The default encoding will be\nwhat io.open uses.\n\nnewline{None, str}, optionalNewline to use when reading text file.\n\n\n\nReturns\n\noutfile objectFile object.\n\n\n\n\n", "parameters": ["Parameters", "pathstr", "mode{\u2018r\u2019, \u2018w\u2019, \u2018a\u2019}, optional", "encoding{None, str}, optional", "newline{None, str}, optional", "Returns", "outfile object"], "returns": "outfile objectFile object.", "examples": []},
{"library": "numpy", "item_id": "numpy.matlib.ones", "code": "\nnumpy.matlib.ones(shape, dtype=None, order='C')[source]\u00b6", "description": "Matrix of ones.\nReturn a matrix of given shape and type, filled with ones.\n\nParameters\n\nshape{sequence of ints, int}Shape of the matrix\n\ndtypedata-type, optionalThe desired data-type for the matrix, default is np.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to store matrix in C- or Fortran-contiguous order,\ndefault is \u2018C\u2019.\n\n\n\nReturns\n\noutmatrixMatrix of ones of given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nonesArray of ones.\n\nmatlib.zerosZero matrix.\n\n\n\nNotes\nIf shape has length one i.e. (N,), or is a scalar N,\nout becomes a single row matrix of shape (1,N).\nExamples\n&gt;&gt;&gt; np.matlib.ones((2,3))\nmatrix([[1.,  1.,  1.],\n        [1.,  1.,  1.]])\n\n\n&gt;&gt;&gt; np.matlib.ones(2)\nmatrix([[1.,  1.]])\n\n\n", "parameters": ["Parameters", "shape{sequence of ints, int}", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outmatrix"], "returns": "outmatrixMatrix of ones of given shape, dtype, and order.", "examples": ["; np.matlib.ones((2,3))\nmatrix([[1.,  1.,  1.],\n        [1.,  1.,  1.]])\n\n", "; np.matlib.ones((2,3))\nmatrix([[1.,  1.,  1.],\n        [1.,  1.,  1.]])\n", "; np.matlib.ones(2)\nmatrix([[1.,  1.]])\n\n", "; np.matlib.ones(2)\nmatrix([[1.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ones_like", "code": "\nnumpy.ones_like(a, dtype=None, order='K', subok=True, shape=None)[source]\u00b6", "description": "Return an array of ones with the same shape and type as a given array.\n\nParameters\n\naarray_likeThe shape and data-type of a define these same attributes of\nthe returned array.\n\ndtypedata-type, optionalOverrides the data type of the result.\n\nNew in version 1.6.0.\n\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optionalOverrides the memory layout of the result. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible.\n\nNew in version 1.6.0.\n\n\nsubokbool, optional.If True, then the newly created array will use the sub-class\ntype of \u2018a\u2019, otherwise it will be a base-class array. Defaults\nto True.\n\nshapeint or sequence of ints, optional.Overrides the shape of the result. If order=\u2019K\u2019 and the number of\ndimensions is unchanged, will try to keep order, otherwise,\norder=\u2019C\u2019 is implied.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\noutndarrayArray of ones with the same shape and type as a.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nfull_likeReturn a new array with shape of input filled with value.\n\nonesReturn a new array setting values to one.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(6)\n&gt;&gt;&gt; x = x.reshape((2, 3))\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n\n&gt;&gt;&gt; y = np.arange(3, dtype=float)\n&gt;&gt;&gt; y\narray([0., 1., 2.])\n&gt;&gt;&gt; np.ones_like(y)\narray([1.,  1.,  1.])\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optional", "subokbool, optional.", "shapeint or sequence of ints, optional.", "Returns", "outndarray"], "returns": "outndarrayArray of ones with the same shape and type as a.", "examples": ["; x = np.arange(6)\n; x = x.reshape((2, 3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])\n\n", "; x = np.arange(6)\n; x = x.reshape((2, 3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.ones_like(x)\narray([[1, 1, 1],\n       [1, 1, 1]])\n", "; y = np.arange(3, dtype=float)\n; y\narray([0., 1., 2.])\n; np.ones_like(y)\narray([1.,  1.,  1.])\n\n", "; y = np.arange(3, dtype=float)\n; y\narray([0., 1., 2.])\n; np.ones_like(y)\narray([1.,  1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.ones", "code": "\nnumpy.ones(shape, dtype=None, order='C')[source]\u00b6", "description": "Return a new array of given shape and type, filled with ones.\n\nParameters\n\nshapeint or sequence of intsShape of the new array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalThe desired data-type for the array, e.g., numpy.int8.  Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: CWhether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of ones with the given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nones_likeReturn an array of ones with shape and type of input.\n\nemptyReturn a new uninitialized array.\n\nzerosReturn a new array setting values to zero.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nExamples\n&gt;&gt;&gt; np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n\n&gt;&gt;&gt; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n\n&gt;&gt;&gt; np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n\n&gt;&gt;&gt; s = (2,2)\n&gt;&gt;&gt; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n\n\n", "parameters": ["Parameters", "shapeint or sequence of ints", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: C", "Returns", "outndarray"], "returns": "outndarrayArray of ones with the given shape, dtype, and order.", "examples": ["; np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n", "; np.ones(5)\narray([1., 1., 1., 1., 1.])\n", "; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n", "; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n", "; np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n", "; np.ones((2, 1))\narray([[1.],\n       [1.]])\n", "; s = (2,2)\n; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n\n", "; s = (2,2)\n; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.ones", "code": "\nnumpy.ma.ones(shape, dtype=None, order='C') = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return a new array of given shape and type, filled with ones.\n\nParameters\n\nshapeint or sequence of intsShape of the new array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalThe desired data-type for the array, e.g., numpy.int8.  Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: CWhether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of ones with the given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nones_likeReturn an array of ones with shape and type of input.\n\nemptyReturn a new uninitialized array.\n\nzerosReturn a new array setting values to zero.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nExamples\n&gt;&gt;&gt; np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n\n&gt;&gt;&gt; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n\n&gt;&gt;&gt; np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n\n&gt;&gt;&gt; s = (2,2)\n&gt;&gt;&gt; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n\n\n", "parameters": ["Parameters", "shapeint or sequence of ints", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: C", "Returns", "outndarray"], "returns": "outndarrayArray of ones with the given shape, dtype, and order.", "examples": ["; np.ones(5)\narray([1., 1., 1., 1., 1.])\n\n", "; np.ones(5)\narray([1., 1., 1., 1., 1.])\n", "; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n\n", "; np.ones((5,), dtype=int)\narray([1, 1, 1, 1, 1])\n", "; np.ones((2, 1))\narray([[1.],\n       [1.]])\n\n", "; np.ones((2, 1))\narray([[1.],\n       [1.]])\n", "; s = (2,2)\n; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n\n", "; s = (2,2)\n; np.ones(s)\narray([[1.,  1.],\n       [1.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ogrid", "code": "\nnumpy.ogrid = &lt;numpy.lib.index_tricks.OGridClass object&gt;\u00b6", "description": "nd_grid instance which returns an open multi-dimensional \u201cmeshgrid\u201d.\nAn instance of numpy.lib.index_tricks.nd_grid which returns an open\n(i.e. not fleshed out) mesh-grid when indexed, so that only one dimension\nof each returned array is greater than 1.  The dimension and number of the\noutput arrays are equal to the number of indexing dimensions.  If the step\nlength is not a complex number, then the stop is not inclusive.\nHowever, if the step length is a complex number (e.g. 5j), then\nthe integer part of its magnitude is interpreted as specifying the\nnumber of points to create between the start and stop values, where\nthe stop value is inclusive.\n\nReturns\n\nmesh-gridndarrays with only one dimension not equal to 1\n\n\n\n\n\nSee also\n\nnp.lib.index_tricks.nd_gridclass of ogrid and mgrid objects\n\nmgridlike ogrid but returns dense (or fleshed out) mesh grids\n\nr_array concatenator\n\n\n\nExamples\n&gt;&gt;&gt; from numpy import ogrid\n&gt;&gt;&gt; ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n&gt;&gt;&gt; ogrid[0:5,0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), array([[0, 1, 2, 3, 4]])]\n\n\n", "parameters": [], "returns": "mesh-gridndarrays with only one dimension not equal to 1", "examples": ["; from numpy import ogrid\n; ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n; ogrid[0:5,0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), array([[0, 1, 2, 3, 4]])]\n\n", "; from numpy import ogrid\n; ogrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n; ogrid[0:5,0:5]\n[array([[0],\n        [1],\n        [2],\n        [3],\n        [4]]), array([[0, 1, 2, 3, 4]])]\n"]},
{"library": "numpy", "item_id": "numpy.obj2sctype", "code": "\nnumpy.obj2sctype(rep, default=None)[source]\u00b6", "description": "Return the scalar dtype or NumPy equivalent of Python type of an object.\n\nParameters\n\nrepanyThe object of which the type is returned.\n\ndefaultany, optionalIf given, this is returned for objects whose types can not be\ndetermined. If not given, None is returned for those objects.\n\n\n\nReturns\n\ndtypedtype or Python typeThe data type of rep.\n\n\n\n\n\nSee also\nsctype2char, issctype, issubsctype, issubdtype, maximum_sctype\n\nExamples\n&gt;&gt;&gt; np.obj2sctype(np.int32)\n&lt;class 'numpy.int32'&gt;\n&gt;&gt;&gt; np.obj2sctype(np.array([1., 2.]))\n&lt;class 'numpy.float64'&gt;\n&gt;&gt;&gt; np.obj2sctype(np.array([1.j]))\n&lt;class 'numpy.complex128'&gt;\n\n\n&gt;&gt;&gt; np.obj2sctype(dict)\n&lt;class 'numpy.object_'&gt;\n&gt;&gt;&gt; np.obj2sctype('string')\n\n\n&gt;&gt;&gt; np.obj2sctype(1, default=list)\n&lt;class 'list'&gt;\n\n\n", "parameters": ["Parameters", "repany", "defaultany, optional", "Returns", "dtypedtype or Python type"], "returns": "dtypedtype or Python typeThe data type of rep.", "examples": ["; np.obj2sctype(np.int32)\n&lt;class 'numpy.int32'&gt;\n; np.obj2sctype(np.array([1., 2.]))\n&lt;class 'numpy.float64'&gt;\n; np.obj2sctype(np.array([1.j]))\n&lt;class 'numpy.complex128'&gt;\n\n", "; np.obj2sctype(np.int32)\n&lt;class 'numpy.int32'&gt;\n; np.obj2sctype(np.array([1., 2.]))\n&lt;class 'numpy.float64'&gt;\n; np.obj2sctype(np.array([1.j]))\n&lt;class 'numpy.complex128'&gt;\n", "; np.obj2sctype(dict)\n&lt;class 'numpy.object_'&gt;\n; np.obj2sctype('string')\n\n", "; np.obj2sctype(dict)\n&lt;class 'numpy.object_'&gt;\n; np.obj2sctype('string')\n", "; np.obj2sctype(1, default=list)\n&lt;class 'list'&gt;\n\n", "; np.obj2sctype(1, default=list)\n&lt;class 'list'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.o", "code": "\nproperty poly1d.o\u00b6", "description": "The order or degree of the polynomial\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.lib.NumpyVersion", "code": "\nclass numpy.lib.NumpyVersion(vstring)[source]\u00b6", "description": "Parse and compare numpy version strings.\nNumPy has the following versioning scheme (numbers given are examples; they\ncan be &gt; 9) in principle):\n\nReleased version: \u20181.8.0\u2019, \u20181.8.1\u2019, etc.\nAlpha: \u20181.8.0a1\u2019, \u20181.8.0a2\u2019, etc.\nBeta: \u20181.8.0b1\u2019, \u20181.8.0b2\u2019, etc.\nRelease candidates: \u20181.8.0rc1\u2019, \u20181.8.0rc2\u2019, etc.\nDevelopment versions: \u20181.8.0.dev-f1234afa\u2019 (git commit hash appended)\n\nDevelopment versions after a1: \u20181.8.0a1.dev-f1234afa\u2019,\u20181.8.0b2.dev-f1234afa\u2019,\n\u20181.8.1rc1.dev-f1234afa\u2019, etc.\n\n\n\nDevelopment versions (no git hash available): \u20181.8.0.dev-Unknown\u2019\n\nComparing needs to be done against a valid version string or other\nNumpyVersion instance. Note that all development versions of the same\n(pre-)release compare equal.\n\nNew in version 1.9.0.\n\n\nParameters\n\nvstringstrNumPy version string (np.__version__).\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.lib import NumpyVersion\n&gt;&gt;&gt; if NumpyVersion(np.__version__) &lt; '1.7.0':\n...     print('skip')\n&gt;&gt;&gt; # skip\n\n\n&gt;&gt;&gt; NumpyVersion('1.7')  # raises ValueError, add \".0\"\nTraceback (most recent call last):\n    ...\nValueError: Not a valid numpy version string\n\n\n", "parameters": ["Parameters", "vstringstr"], "returns": [], "examples": ["; from numpy.lib import NumpyVersion\n; if NumpyVersion(np.__version__) &lt; '1.7.0':\n...     print('skip')\n; # skip\n\n", "; from numpy.lib import NumpyVersion\n; if NumpyVersion(np.__version__) &lt; '1.7.0':\n...     print('skip')\n; # skip\n", "; NumpyVersion('1.7')  # raises ValueError, add \".0\"\nTraceback (most recent call last):\n    ...\nValueError: Not a valid numpy version string\n\n", "; NumpyVersion('1.7')  # raises ValueError, add \".0\"\nTraceback (most recent call last):\n    ...\nValueError: Not a valid numpy version string\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "rfb1dc64dd6a5-ct", "code": "CT", "description": "Cooley, James W., and John W. Tukey, 1965, \u201cAn algorithm for the\nmachine calculation of complex Fourier series,\u201d Math. Comput.\n19: 297-301.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": ["\nView casting\u00b6\nView casting is the standard ndarray mechanism by which you take an\nndarray of any subclass, and return a view of the array as another\n(specified) subclass:\n; import numpy as np\n; # create a completely useless ndarray subclass\n; class C(np.ndarray): pass\n; # create a standard ndarray\n; arr = np.zeros((3,))\n; # take a view of it, as our useless subclass\n; c_arr = arr.view(C)\n; type(c_arr)\n&lt;class 'C'&gt;\n\n\n", "; import numpy as np\n; # create a completely useless ndarray subclass\n; class C(np.ndarray): pass\n; # create a standard ndarray\n; arr = np.zeros((3,))\n; # take a view of it, as our useless subclass\n; c_arr = arr.view(C)\n; type(c_arr)\n&lt;class 'C'&gt;\n\n", "; import numpy as np\n; # create a completely useless ndarray subclass\n; class C(np.ndarray): pass\n; # create a standard ndarray\n; arr = np.zeros((3,))\n; # take a view of it, as our useless subclass\n; c_arr = arr.view(C)\n; type(c_arr)\n&lt;class 'C'&gt;\n", "\nCreating new from template\u00b6\nNew instances of an ndarray subclass can also come about by a very\nsimilar mechanism to View casting, when numpy finds it needs to\ncreate a new instance from a template instance.  The most obvious place\nthis has to happen is when you are taking slices of subclassed arrays.\nFor example:\n; v = c_arr[1:]\n; type(v) # the view is of type 'C'\n&lt;class 'C'&gt;\n; v is c_arr # but it's a new instance\nFalse\n\n\nThe slice is a view onto the original c_arr data.  So, when we\ntake a view from the ndarray, we return a new ndarray, of the same\nclass, that points to the data in the original.\nThere are other points in the use of ndarrays where we need such views,\nsuch as copying arrays (c_arr.copy()), creating ufunc output arrays\n(see also __array_wrap__ for ufuncs and other functions), and reducing methods (like\nc_arr.mean().\n", "; v = c_arr[1:]\n; type(v) # the view is of type 'C'\n&lt;class 'C'&gt;\n; v is c_arr # but it's a new instance\nFalse\n\n", "; v = c_arr[1:]\n; type(v) # the view is of type 'C'\n&lt;class 'C'&gt;\n; v is c_arr # but it's a new instance\nFalse\n", "\nImplications for subclassing\u00b6\nIf we subclass ndarray, we need to deal not only with explicit\nconstruction of our array type, but also View casting or\nCreating new from template.  NumPy has the machinery to do this, and this\nmachinery that makes subclassing slightly non-standard.\nThere are two aspects to the machinery that ndarray uses to support\nviews and new-from-template in subclasses.\nThe first is the use of the ndarray.__new__ method for the main work\nof object initialization, rather then the more usual __init__\nmethod.  The second is the use of the __array_finalize__ method to\nallow subclasses to clean up after the creation of views and new\ninstances from templates.\n\nA brief Python primer on __new__ and __init__\u00b6\n__new__ is a standard Python method, and, if present, is called\nbefore __init__ when we create a class instance. See the python\n__new__ documentation for more detail.\nFor example, consider the following Python code:\nclass C(object):\n    def __new__(cls, *args):\n        print('Cls in __new__:', cls)\n        print('Args in __new__:', args)\n        # The `object` type __new__ method takes a single argument.\n        return object.__new__(cls)\n\n    def __init__(self, *args):\n        print('type(self) in __init__:', type(self))\n        print('Args in __init__:', args)\n\n\nmeaning that we get:\n; c = C('hello')\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\ntype(self) in __init__: &lt;class 'C'&gt;\nArgs in __init__: ('hello',)\n\n\nWhen we call C('hello'), the __new__ method gets its own class\nas first argument, and the passed argument, which is the string\n'hello'.  After python calls __new__, it usually (see below)\ncalls our __init__ method, with the output of __new__ as the\nfirst argument (now a class instance), and the passed arguments\nfollowing.\nAs you can see, the object can be initialized in the __new__\nmethod or the __init__ method, or both, and in fact ndarray does\nnot have an __init__ method, because all the initialization is\ndone in the __new__ method.\nWhy use __new__ rather than just the usual __init__?  Because\nin some cases, as for ndarray, we want to be able to return an object\nof some other class.  Consider the following:\nclass D(C):\n    def __new__(cls, *args):\n        print('D cls is:', cls)\n        print('D args in __new__:', args)\n        return C.__new__(C, *args)\n\n    def __init__(self, *args):\n        # we never get here\n        print('In D __init__')\n\n\nmeaning that:\n; obj = D('hello')\nD cls is: &lt;class 'D'&gt;\nD args in __new__: ('hello',)\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\n; type(obj)\n&lt;class 'C'&gt;\n\n\nThe definition of C is the same as before, but for D, the\n__new__ method returns an instance of class C rather than\nD.  Note that the __init__ method of D does not get\ncalled.  In general, when the __new__ method returns an object of\nclass other than the class in which it is defined, the __init__\nmethod of that class is not called.\nThis is how subclasses of the ndarray class are able to return views\nthat preserve the class type.  When taking a view, the standard\nndarray machinery creates the new ndarray object with something\nlike:\nobj = ndarray.__new__(subtype, shape, ...\n\n\nwhere subdtype is the subclass.  Thus the returned view is of the\nsame class as the subclass, rather than being of class ndarray.\nThat solves the problem of returning views of the same type, but now\nwe have a new problem.  The machinery of ndarray can set the class\nthis way, in its standard methods for taking views, but the ndarray\n__new__ method knows nothing of what we have done in our own\n__new__ method in order to set attributes, and so on.  (Aside -\nwhy not call obj = subdtype.__new__(... then?  Because we may not\nhave a __new__ method with the same call signature).\n\n\nThe role of __array_finalize__\u00b6\n__array_finalize__ is the mechanism that numpy provides to allow\nsubclasses to handle the various ways that new instances get created.\nRemember that subclass instances can come about in these three ways:\n\nexplicit constructor call (obj = MySubClass(params)).  This will\ncall the usual sequence of MySubClass.__new__ then (if it exists)\nMySubClass.__init__.\nView casting\nCreating new from template\n\nOur MySubClass.__new__ method only gets called in the case of the\nexplicit constructor call, so we can\u2019t rely on MySubClass.__new__ or\nMySubClass.__init__ to deal with the view casting and\nnew-from-template.  It turns out that MySubClass.__array_finalize__\ndoes get called for all three methods of object creation, so this is\nwhere our object creation housekeeping usually goes.\n\nFor the explicit constructor call, our subclass will need to create a\nnew ndarray instance of its own class.  In practice this means that\nwe, the authors of the code, will need to make a call to\nndarray.__new__(MySubClass,...), a class-hierarchy prepared call to\nsuper(MySubClass, cls).__new__(cls, ...), or do view casting of an\nexisting array (see below)\nFor view casting and new-from-template, the equivalent of\nndarray.__new__(MySubClass,... is called, at the C level.\n\nThe arguments that __array_finalize__ receives differ for the three\nmethods of instance creation above.\nThe following code allows us to look at the call sequences and arguments:\nimport numpy as np\n\nclass C(np.ndarray):\n    def __new__(cls, *args, **kwargs):\n        print('In __new__ with class %s' % cls)\n        return super(C, cls).__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        # in practice you probably will not need or want an __init__\n        # method for your subclass\n        print('In __init__ with class %s' % self.__class__)\n\n    def __array_finalize__(self, obj):\n        print('In array_finalize:')\n        print('   self type is %s' % type(self))\n        print('   obj type is %s' % type(obj))\n\n\nNow:\n; # Explicit constructor\n; c = C((10,))\nIn __new__ with class &lt;class 'C'&gt;\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'NoneType'&gt;\nIn __init__ with class &lt;class 'C'&gt;\n; # View casting\n; a = np.arange(10)\n; cast_a = a.view(C)\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'numpy.ndarray'&gt;\n; # Slicing (example of new-from-template)\n; cv = c[:1]\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;class 'C'&gt;\n\n\nThe signature of __array_finalize__ is:\ndef __array_finalize__(self, obj):\n\n\nOne sees that the super call, which goes to\nndarray.__new__, passes __array_finalize__ the new object, of our\nown class (self) as well as the object from which the view has been\ntaken (obj).  As you can see from the output above, the self is\nalways a newly created instance of our subclass, and the type of obj\ndiffers for the three instance creation methods:\n\nWhen called from the explicit constructor, obj is None\nWhen called from view casting, obj can be an instance of any\nsubclass of ndarray, including our own.\nWhen called in new-from-template, obj is another instance of our\nown subclass, that we might use to update the new self instance.\n\nBecause __array_finalize__ is the only method that always sees new\ninstances being created, it is the sensible place to fill in instance\ndefaults for new object attributes, among other tasks.\nThis may be clearer with an example.\n\n", "\nA brief Python primer on __new__ and __init__\u00b6\n__new__ is a standard Python method, and, if present, is called\nbefore __init__ when we create a class instance. See the python\n__new__ documentation for more detail.\nFor example, consider the following Python code:\nclass C(object):\n    def __new__(cls, *args):\n        print('Cls in __new__:', cls)\n        print('Args in __new__:', args)\n        # The `object` type __new__ method takes a single argument.\n        return object.__new__(cls)\n\n    def __init__(self, *args):\n        print('type(self) in __init__:', type(self))\n        print('Args in __init__:', args)\n\n\nmeaning that we get:\n; c = C('hello')\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\ntype(self) in __init__: &lt;class 'C'&gt;\nArgs in __init__: ('hello',)\n\n\nWhen we call C('hello'), the __new__ method gets its own class\nas first argument, and the passed argument, which is the string\n'hello'.  After python calls __new__, it usually (see below)\ncalls our __init__ method, with the output of __new__ as the\nfirst argument (now a class instance), and the passed arguments\nfollowing.\nAs you can see, the object can be initialized in the __new__\nmethod or the __init__ method, or both, and in fact ndarray does\nnot have an __init__ method, because all the initialization is\ndone in the __new__ method.\nWhy use __new__ rather than just the usual __init__?  Because\nin some cases, as for ndarray, we want to be able to return an object\nof some other class.  Consider the following:\nclass D(C):\n    def __new__(cls, *args):\n        print('D cls is:', cls)\n        print('D args in __new__:', args)\n        return C.__new__(C, *args)\n\n    def __init__(self, *args):\n        # we never get here\n        print('In D __init__')\n\n\nmeaning that:\n; obj = D('hello')\nD cls is: &lt;class 'D'&gt;\nD args in __new__: ('hello',)\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\n; type(obj)\n&lt;class 'C'&gt;\n\n\nThe definition of C is the same as before, but for D, the\n__new__ method returns an instance of class C rather than\nD.  Note that the __init__ method of D does not get\ncalled.  In general, when the __new__ method returns an object of\nclass other than the class in which it is defined, the __init__\nmethod of that class is not called.\nThis is how subclasses of the ndarray class are able to return views\nthat preserve the class type.  When taking a view, the standard\nndarray machinery creates the new ndarray object with something\nlike:\nobj = ndarray.__new__(subtype, shape, ...\n\n\nwhere subdtype is the subclass.  Thus the returned view is of the\nsame class as the subclass, rather than being of class ndarray.\nThat solves the problem of returning views of the same type, but now\nwe have a new problem.  The machinery of ndarray can set the class\nthis way, in its standard methods for taking views, but the ndarray\n__new__ method knows nothing of what we have done in our own\n__new__ method in order to set attributes, and so on.  (Aside -\nwhy not call obj = subdtype.__new__(... then?  Because we may not\nhave a __new__ method with the same call signature).\n", "; c = C('hello')\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\ntype(self) in __init__: &lt;class 'C'&gt;\nArgs in __init__: ('hello',)\n\n", "; c = C('hello')\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\ntype(self) in __init__: &lt;class 'C'&gt;\nArgs in __init__: ('hello',)\n", "; obj = D('hello')\nD cls is: &lt;class 'D'&gt;\nD args in __new__: ('hello',)\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\n; type(obj)\n&lt;class 'C'&gt;\n\n", "; obj = D('hello')\nD cls is: &lt;class 'D'&gt;\nD args in __new__: ('hello',)\nCls in __new__: &lt;class 'C'&gt;\nArgs in __new__: ('hello',)\n; type(obj)\n&lt;class 'C'&gt;\n", "\nThe role of __array_finalize__\u00b6\n__array_finalize__ is the mechanism that numpy provides to allow\nsubclasses to handle the various ways that new instances get created.\nRemember that subclass instances can come about in these three ways:\n\nexplicit constructor call (obj = MySubClass(params)).  This will\ncall the usual sequence of MySubClass.__new__ then (if it exists)\nMySubClass.__init__.\nView casting\nCreating new from template\n\nOur MySubClass.__new__ method only gets called in the case of the\nexplicit constructor call, so we can\u2019t rely on MySubClass.__new__ or\nMySubClass.__init__ to deal with the view casting and\nnew-from-template.  It turns out that MySubClass.__array_finalize__\ndoes get called for all three methods of object creation, so this is\nwhere our object creation housekeeping usually goes.\n\nFor the explicit constructor call, our subclass will need to create a\nnew ndarray instance of its own class.  In practice this means that\nwe, the authors of the code, will need to make a call to\nndarray.__new__(MySubClass,...), a class-hierarchy prepared call to\nsuper(MySubClass, cls).__new__(cls, ...), or do view casting of an\nexisting array (see below)\nFor view casting and new-from-template, the equivalent of\nndarray.__new__(MySubClass,... is called, at the C level.\n\nThe arguments that __array_finalize__ receives differ for the three\nmethods of instance creation above.\nThe following code allows us to look at the call sequences and arguments:\nimport numpy as np\n\nclass C(np.ndarray):\n    def __new__(cls, *args, **kwargs):\n        print('In __new__ with class %s' % cls)\n        return super(C, cls).__new__(cls, *args, **kwargs)\n\n    def __init__(self, *args, **kwargs):\n        # in practice you probably will not need or want an __init__\n        # method for your subclass\n        print('In __init__ with class %s' % self.__class__)\n\n    def __array_finalize__(self, obj):\n        print('In array_finalize:')\n        print('   self type is %s' % type(self))\n        print('   obj type is %s' % type(obj))\n\n\nNow:\n; # Explicit constructor\n; c = C((10,))\nIn __new__ with class &lt;class 'C'&gt;\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'NoneType'&gt;\nIn __init__ with class &lt;class 'C'&gt;\n; # View casting\n; a = np.arange(10)\n; cast_a = a.view(C)\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'numpy.ndarray'&gt;\n; # Slicing (example of new-from-template)\n; cv = c[:1]\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;class 'C'&gt;\n\n\nThe signature of __array_finalize__ is:\ndef __array_finalize__(self, obj):\n\n\nOne sees that the super call, which goes to\nndarray.__new__, passes __array_finalize__ the new object, of our\nown class (self) as well as the object from which the view has been\ntaken (obj).  As you can see from the output above, the self is\nalways a newly created instance of our subclass, and the type of obj\ndiffers for the three instance creation methods:\n\nWhen called from the explicit constructor, obj is None\nWhen called from view casting, obj can be an instance of any\nsubclass of ndarray, including our own.\nWhen called in new-from-template, obj is another instance of our\nown subclass, that we might use to update the new self instance.\n\nBecause __array_finalize__ is the only method that always sees new\ninstances being created, it is the sensible place to fill in instance\ndefaults for new object attributes, among other tasks.\nThis may be clearer with an example.\n", "; # Explicit constructor\n; c = C((10,))\nIn __new__ with class &lt;class 'C'&gt;\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'NoneType'&gt;\nIn __init__ with class &lt;class 'C'&gt;\n; # View casting\n; a = np.arange(10)\n; cast_a = a.view(C)\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'numpy.ndarray'&gt;\n; # Slicing (example of new-from-template)\n; cv = c[:1]\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;class 'C'&gt;\n\n", "; # Explicit constructor\n; c = C((10,))\nIn __new__ with class &lt;class 'C'&gt;\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'NoneType'&gt;\nIn __init__ with class &lt;class 'C'&gt;\n; # View casting\n; a = np.arange(10)\n; cast_a = a.view(C)\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;type 'numpy.ndarray'&gt;\n; # Slicing (example of new-from-template)\n; cv = c[:1]\nIn array_finalize:\n   self type is &lt;class 'C'&gt;\n   obj type is &lt;class 'C'&gt;\n", "\nSimple example - adding an extra attribute to ndarray\u00b6\nimport numpy as np\n\nclass InfoArray(np.ndarray):\n\n    def __new__(subtype, shape, dtype=float, buffer=None, offset=0,\n                strides=None, order=None, info=None):\n        # Create the ndarray instance of our type, given the usual\n        # ndarray input arguments.  This will call the standard\n        # ndarray constructor, but return an object of our type.\n        # It also triggers a call to InfoArray.__array_finalize__\n        obj = super(InfoArray, subtype).__new__(subtype, shape, dtype,\n                                                buffer, offset, strides,\n                                                order)\n        # set the new 'info' attribute to the value passed\n        obj.info = info\n        # Finally, we must return the newly created object:\n        return obj\n\n    def __array_finalize__(self, obj):\n        # ``self`` is a new object resulting from\n        # ndarray.__new__(InfoArray, ...), therefore it only has\n        # attributes that the ndarray.__new__ constructor gave it -\n        # i.e. those of a standard ndarray.\n        #\n        # We could have got to the ndarray.__new__ call in 3 ways:\n        # From an explicit constructor - e.g. InfoArray():\n        #    obj is None\n        #    (we're in the middle of the InfoArray.__new__\n        #    constructor, and self.info will be set when we return to\n        #    InfoArray.__new__)\n        if obj is None: return\n        # From view casting - e.g arr.view(InfoArray):\n        #    obj is arr\n        #    (type(obj) can be InfoArray)\n        # From new-from-template - e.g infoarr[:3]\n        #    type(obj) is InfoArray\n        #\n        # Note that it is here, rather than in the __new__ method,\n        # that we set the default value for 'info', because this\n        # method sees all creation of default objects - with the\n        # InfoArray.__new__ constructor, but also with\n        # arr.view(InfoArray).\n        self.info = getattr(obj, 'info', None)\n        # We do not need to return anything\n\n\nUsing the object looks like this:\n; obj = InfoArray(shape=(3,)) # explicit constructor\n; type(obj)\n&lt;class 'InfoArray'&gt;\n; obj.info is None\nTrue\n; obj = InfoArray(shape=(3,), info='information')\n; obj.info\n'information'\n; v = obj[1:] # new-from-template - here - slicing\n; type(v)\n&lt;class 'InfoArray'&gt;\n; v.info\n'information'\n; arr = np.arange(10)\n; cast_arr = arr.view(InfoArray) # view casting\n; type(cast_arr)\n&lt;class 'InfoArray'&gt;\n; cast_arr.info is None\nTrue\n\n\nThis class isn\u2019t very useful, because it has the same constructor as the\nbare ndarray object, including passing in buffers and shapes and so on.\nWe would probably prefer the constructor to be able to take an already\nformed ndarray from the usual numpy calls to np.array and return an\nobject.\n", "; obj = InfoArray(shape=(3,)) # explicit constructor\n; type(obj)\n&lt;class 'InfoArray'&gt;\n; obj.info is None\nTrue\n; obj = InfoArray(shape=(3,), info='information')\n; obj.info\n'information'\n; v = obj[1:] # new-from-template - here - slicing\n; type(v)\n&lt;class 'InfoArray'&gt;\n; v.info\n'information'\n; arr = np.arange(10)\n; cast_arr = arr.view(InfoArray) # view casting\n; type(cast_arr)\n&lt;class 'InfoArray'&gt;\n; cast_arr.info is None\nTrue\n\n", "; obj = InfoArray(shape=(3,)) # explicit constructor\n; type(obj)\n&lt;class 'InfoArray'&gt;\n; obj.info is None\nTrue\n; obj = InfoArray(shape=(3,), info='information')\n; obj.info\n'information'\n; v = obj[1:] # new-from-template - here - slicing\n; type(v)\n&lt;class 'InfoArray'&gt;\n; v.info\n'information'\n; arr = np.arange(10)\n; cast_arr = arr.view(InfoArray) # view casting\n; type(cast_arr)\n&lt;class 'InfoArray'&gt;\n; cast_arr.info is None\nTrue\n", "\nSlightly more realistic example - attribute added to existing array\u00b6\nHere is a class that takes a standard ndarray that already exists, casts\nas our type, and adds an extra attribute.\nimport numpy as np\n\nclass RealisticInfoArray(np.ndarray):\n\n    def __new__(cls, input_array, info=None):\n        # Input array is an already formed ndarray instance\n        # We first cast to be our class type\n        obj = np.asarray(input_array).view(cls)\n        # add the new attribute to the created instance\n        obj.info = info\n        # Finally, we must return the newly created object:\n        return obj\n\n    def __array_finalize__(self, obj):\n        # see InfoArray.__array_finalize__ for comments\n        if obj is None: return\n        self.info = getattr(obj, 'info', None)\n\n\nSo:\n; arr = np.arange(5)\n; obj = RealisticInfoArray(arr, info='information')\n; type(obj)\n&lt;class 'RealisticInfoArray'&gt;\n; obj.info\n'information'\n; v = obj[1:]\n; type(v)\n&lt;class 'RealisticInfoArray'&gt;\n; v.info\n'information'\n\n\n", "; arr = np.arange(5)\n; obj = RealisticInfoArray(arr, info='information')\n; type(obj)\n&lt;class 'RealisticInfoArray'&gt;\n; obj.info\n'information'\n; v = obj[1:]\n; type(v)\n&lt;class 'RealisticInfoArray'&gt;\n; v.info\n'information'\n\n", "; arr = np.arange(5)\n; obj = RealisticInfoArray(arr, info='information')\n; type(obj)\n&lt;class 'RealisticInfoArray'&gt;\n; obj.info\n'information'\n; v = obj[1:]\n; type(v)\n&lt;class 'RealisticInfoArray'&gt;\n; v.info\n'information'\n", "\n__array_ufunc__ for ufuncs\u00b6\n\n\nNew in version 1.13.\n\n\nA subclass can override what happens when executing numpy ufuncs on it by\noverriding the default ndarray.__array_ufunc__ method. This method is\nexecuted instead of the ufunc and should return either the result of the\noperation, or NotImplemented if the operation requested is not\nimplemented.\nThe signature of __array_ufunc__ is:\ndef __array_ufunc__(ufunc, method, *inputs, **kwargs):\n\n- *ufunc* is the ufunc object that was called.\n- *method* is a string indicating how the Ufunc was called, either\n  ``\"__call__\"`` to indicate it was called directly, or one of its\n  :ref:`methods&lt;ufuncs.methods&gt;`: ``\"reduce\"``, ``\"accumulate\"``,\n  ``\"reduceat\"``, ``\"outer\"``, or ``\"at\"``.\n- *inputs* is a tuple of the input arguments to the ``ufunc``\n- *kwargs* contains any optional or keyword arguments passed to the\n  function. This includes any ``out`` arguments, which are always\n  contained in a tuple.\n\n\nA typical implementation would convert any inputs or outputs that are\ninstances of one\u2019s own class, pass everything on to a superclass using\nsuper(), and finally return the results after possible\nback-conversion. An example, taken from the test case\ntest_ufunc_override_with_super in core/tests/test_umath.py, is the\nfollowing.\ninput numpy as np\n\nclass A(np.ndarray):\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        args = []\n        in_no = []\n        for i, input_ in enumerate(inputs):\n            if isinstance(input_, A):\n                in_no.append(i)\n                args.append(input_.view(np.ndarray))\n            else:\n                args.append(input_)\n\n        outputs = kwargs.pop('out', None)\n        out_no = []\n        if outputs:\n            out_args = []\n            for j, output in enumerate(outputs):\n                if isinstance(output, A):\n                    out_no.append(j)\n                    out_args.append(output.view(np.ndarray))\n                else:\n                    out_args.append(output)\n            kwargs['out'] = tuple(out_args)\n        else:\n            outputs = (None,) * ufunc.nout\n\n        info = {}\n        if in_no:\n            info['inputs'] = in_no\n        if out_no:\n            info['outputs'] = out_no\n\n        results = super(A, self).__array_ufunc__(ufunc, method,\n                                                 *args, **kwargs)\n        if results is NotImplemented:\n            return NotImplemented\n\n        if method == 'at':\n            if isinstance(inputs[0], A):\n                inputs[0].info = info\n            return\n\n        if ufunc.nout == 1:\n            results = (results,)\n\n        results = tuple((np.asarray(result).view(A)\n                         if output is None else output)\n                        for result, output in zip(results, outputs))\n        if results and isinstance(results[0], A):\n            results[0].info = info\n\n        return results[0] if len(results) == 1 else results\n\n\nSo, this class does not actually do anything interesting: it just\nconverts any instances of its own to regular ndarray (otherwise, we\u2019d\nget infinite recursion!), and adds an info dictionary that tells\nwhich inputs and outputs it converted. Hence, e.g.,\n; a = np.arange(5.).view(A)\n; b = np.sin(a)\n; b.info\n{'inputs': [0]}\n; b = np.sin(np.arange(5.), out=(a,))\n; b.info\n{'outputs': [0]}\n; a = np.arange(5.).view(A)\n; b = np.ones(1).view(A)\n; c = a + b\n; c.info\n{'inputs': [0, 1]}\n; a += b\n; a.info\n{'inputs': [0, 1], 'outputs': [0]}\n\n\nNote that another approach would be to to use getattr(ufunc,\nmethods)(*inputs, **kwargs) instead of the super call. For this example,\nthe result would be identical, but there is a difference if another operand\nalso defines __array_ufunc__. E.g., lets assume that we evalulate\nnp.add(a, b), where b is an instance of another class B that has\nan override.  If you use super as in the example,\nndarray.__array_ufunc__ will notice that b has an override, which\nmeans it cannot evaluate the result itself. Thus, it will return\nNotImplemented and so will our class A. Then, control will be passed\nover to b, which either knows how to deal with us and produces a result,\nor does not and returns NotImplemented, raising a TypeError.\nIf instead, we replace our super call with getattr(ufunc, method), we\neffectively do np.add(a.view(np.ndarray), b). Again, B.__array_ufunc__\nwill be called, but now it sees an ndarray as the other argument. Likely,\nit will know how to handle this, and return a new instance of the B class\nto us. Our example class is not set up to handle this, but it might well be\nthe best approach if, e.g., one were to re-implement MaskedArray using\n__array_ufunc__.\nAs a final note: if the super route is suited to a given class, an\nadvantage of using it is that it helps in constructing class hierarchies.\nE.g., suppose that our other class B also used the super in its\n__array_ufunc__ implementation, and we created a class C that depended\non both, i.e., class C(A, B) (with, for simplicity, not another\n__array_ufunc__ override). Then any ufunc on an instance of C would\npass on to A.__array_ufunc__, the super call in A would go to\nB.__array_ufunc__, and the super call in B would go to\nndarray.__array_ufunc__, thus allowing A and B to collaborate.\n", "; a = np.arange(5.).view(A)\n; b = np.sin(a)\n; b.info\n{'inputs': [0]}\n; b = np.sin(np.arange(5.), out=(a,))\n; b.info\n{'outputs': [0]}\n; a = np.arange(5.).view(A)\n; b = np.ones(1).view(A)\n; c = a + b\n; c.info\n{'inputs': [0, 1]}\n; a += b\n; a.info\n{'inputs': [0, 1], 'outputs': [0]}\n\n", "; a = np.arange(5.).view(A)\n; b = np.sin(a)\n; b.info\n{'inputs': [0]}\n; b = np.sin(np.arange(5.), out=(a,))\n; b.info\n{'outputs': [0]}\n; a = np.arange(5.).view(A)\n; b = np.ones(1).view(A)\n; c = a + b\n; c.info\n{'inputs': [0, 1]}\n; a += b\n; a.info\n{'inputs': [0, 1], 'outputs': [0]}\n", "\n__array_wrap__ for ufuncs and other functions\u00b6\nPrior to numpy 1.13, the behaviour of ufuncs could only be tuned using\n__array_wrap__ and __array_prepare__. These two allowed one to\nchange the output type of a ufunc, but, in contrast to\n__array_ufunc__, did not allow one to make any changes to the inputs.\nIt is hoped to eventually deprecate these, but __array_wrap__ is also\nused by other numpy functions and methods, such as squeeze, so at the\npresent time is still needed for full functionality.\nConceptually, __array_wrap__ \u201cwraps up the action\u201d in the sense of\nallowing a subclass to set the type of the return value and update\nattributes and metadata.  Let\u2019s show how this works with an example.  First\nwe return to the simpler example subclass, but with a different name and\nsome print statements:\nimport numpy as np\n\nclass MySubClass(np.ndarray):\n\n    def __new__(cls, input_array, info=None):\n        obj = np.asarray(input_array).view(cls)\n        obj.info = info\n        return obj\n\n    def __array_finalize__(self, obj):\n        print('In __array_finalize__:')\n        print('   self is %s' % repr(self))\n        print('   obj is %s' % repr(obj))\n        if obj is None: return\n        self.info = getattr(obj, 'info', None)\n\n    def __array_wrap__(self, out_arr, context=None):\n        print('In __array_wrap__:')\n        print('   self is %s' % repr(self))\n        print('   arr is %s' % repr(out_arr))\n        # then just call the parent\n        return super(MySubClass, self).__array_wrap__(self, out_arr, context)\n\n\nWe run a ufunc on an instance of our new array:\n; obj = MySubClass(np.arange(5), info='spam')\nIn __array_finalize__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   obj is array([0, 1, 2, 3, 4])\n; arr2 = np.arange(5)+1\n; ret = np.add(arr2, obj)\nIn __array_wrap__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   arr is array([1, 3, 5, 7, 9])\nIn __array_finalize__:\n   self is MySubClass([1, 3, 5, 7, 9])\n   obj is MySubClass([0, 1, 2, 3, 4])\n; ret\nMySubClass([1, 3, 5, 7, 9])\n; ret.info\n'spam'\n\n\nNote that the ufunc (np.add) has called the __array_wrap__ method\nwith arguments self as obj, and out_arr as the (ndarray) result\nof the addition.  In turn, the default __array_wrap__\n(ndarray.__array_wrap__) has cast the result to class MySubClass,\nand called __array_finalize__ - hence the copying of the info\nattribute.  This has all happened at the C level.\nBut, we could do anything we wanted:\nclass SillySubClass(np.ndarray):\n\n    def __array_wrap__(self, arr, context=None):\n        return 'I lost your data'\n\n\n; arr1 = np.arange(5)\n; obj = arr1.view(SillySubClass)\n; arr2 = np.arange(5)\n; ret = np.multiply(obj, arr2)\n; ret\n'I lost your data'\n\n\nSo, by defining a specific __array_wrap__ method for our subclass,\nwe can tweak the output from ufuncs. The __array_wrap__ method\nrequires self, then an argument - which is the result of the ufunc -\nand an optional parameter context. This parameter is returned by\nufuncs as a 3-element tuple: (name of the ufunc, arguments of the ufunc,\ndomain of the ufunc), but is not set by other numpy functions. Though,\nas seen above, it is possible to do otherwise, __array_wrap__ should\nreturn an instance of its containing class.  See the masked array\nsubclass for an implementation.\nIn addition to __array_wrap__, which is called on the way out of the\nufunc, there is also an __array_prepare__ method which is called on\nthe way into the ufunc, after the output arrays are created but before any\ncomputation has been performed. The default implementation does nothing\nbut pass through the array. __array_prepare__ should not attempt to\naccess the array data or resize the array, it is intended for setting the\noutput array type, updating attributes and metadata, and performing any\nchecks based on the input that may be desired before computation begins.\nLike __array_wrap__, __array_prepare__ must return an ndarray or\nsubclass thereof or raise an error.\n", "; obj = MySubClass(np.arange(5), info='spam')\nIn __array_finalize__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   obj is array([0, 1, 2, 3, 4])\n; arr2 = np.arange(5)+1\n; ret = np.add(arr2, obj)\nIn __array_wrap__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   arr is array([1, 3, 5, 7, 9])\nIn __array_finalize__:\n   self is MySubClass([1, 3, 5, 7, 9])\n   obj is MySubClass([0, 1, 2, 3, 4])\n; ret\nMySubClass([1, 3, 5, 7, 9])\n; ret.info\n'spam'\n\n", "; obj = MySubClass(np.arange(5), info='spam')\nIn __array_finalize__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   obj is array([0, 1, 2, 3, 4])\n; arr2 = np.arange(5)+1\n; ret = np.add(arr2, obj)\nIn __array_wrap__:\n   self is MySubClass([0, 1, 2, 3, 4])\n   arr is array([1, 3, 5, 7, 9])\nIn __array_finalize__:\n   self is MySubClass([1, 3, 5, 7, 9])\n   obj is MySubClass([0, 1, 2, 3, 4])\n; ret\nMySubClass([1, 3, 5, 7, 9])\n; ret.info\n'spam'\n", "; arr1 = np.arange(5)\n; obj = arr1.view(SillySubClass)\n; arr2 = np.arange(5)\n; ret = np.multiply(obj, arr2)\n; ret\n'I lost your data'\n\n", "; arr1 = np.arange(5)\n; obj = arr1.view(SillySubClass)\n; arr2 = np.arange(5)\n; ret = np.multiply(obj, arr2)\n; ret\n'I lost your data'\n", "\nExtra gotchas - custom __del__ methods and ndarray.base\u00b6\nOne of the problems that ndarray solves is keeping track of memory\nownership of ndarrays and their views.  Consider the case where we have\ncreated an ndarray, arr and have taken a slice with v = arr[1:].\nThe two objects are looking at the same memory.  NumPy keeps track of\nwhere the data came from for a particular array or view, with the\nbase attribute:\n; # A normal ndarray, that owns its own data\n; arr = np.zeros((4,))\n; # In this case, base is None\n; arr.base is None\nTrue\n; # We take a view\n; v1 = arr[1:]\n; # base now points to the array that it derived from\n; v1.base is arr\nTrue\n; # Take a view of a view\n; v2 = v1[1:]\n; # base points to the view it derived from\n; v2.base is v1\nTrue\n\n\nIn general, if the array owns its own memory, as for arr in this\ncase, then arr.base will be None - there are some exceptions to this\n- see the numpy book for more details.\nThe base attribute is useful in being able to tell whether we have\na view or the original array.  This in turn can be useful if we need\nto know whether or not to do some specific cleanup when the subclassed\narray is deleted.  For example, we may only want to do the cleanup if\nthe original array is deleted, but not the views.  For an example of\nhow this can work, have a look at the memmap class in\nnumpy.core.\n", "; # A normal ndarray, that owns its own data\n; arr = np.zeros((4,))\n; # In this case, base is None\n; arr.base is None\nTrue\n; # We take a view\n; v1 = arr[1:]\n; # base now points to the array that it derived from\n; v1.base is arr\nTrue\n; # Take a view of a view\n; v2 = v1[1:]\n; # base points to the view it derived from\n; v2.base is v1\nTrue\n\n", "; # A normal ndarray, that owns its own data\n; arr = np.zeros((4,))\n; # In this case, base is None\n; arr.base is None\nTrue\n; # We take a view\n; v1 = arr[1:]\n; # base now points to the array that it derived from\n; v1.base is arr\nTrue\n; # Take a view of a view\n; v2 = v1[1:]\n; # base points to the view it derived from\n; v2.base is v1\nTrue\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": ["; x = np.array([2,3,1,0])\n; x = np.array([2, 3, 1, 0])\n; x = np.array([[1,2.0],[0,0],(1+1j,3.)]) # note mix of tuple and lists,\n    and types\n; x = np.array([[ 1.+0.j, 2.+0.j], [ 0.+0.j, 0.+0.j], [ 1.+1.j, 3.+0.j]])\n\n", "; x = np.array([2,3,1,0])\n; x = np.array([2, 3, 1, 0])\n; x = np.array([[1,2.0],[0,0],(1+1j,3.)]) # note mix of tuple and lists,\n    and types\n; x = np.array([[ 1.+0.j, 2.+0.j], [ 0.+0.j, 0.+0.j], [ 1.+1.j, 3.+0.j]])\n", "\nIntrinsic NumPy Array Creation\u00b6\nNumPy has built-in functions for creating arrays from scratch:\nzeros(shape) will create an array filled with 0 values with the specified\nshape. The default dtype is float64.\n; np.zeros((2, 3))\narray([[ 0., 0., 0.], [ 0., 0., 0.]])\n\n\nones(shape) will create an array filled with 1 values. It is identical to\nzeros in all other respects.\narange() will create arrays with regularly incrementing values. Check the\ndocstring for complete information on the various ways it can be used. A few\nexamples will be given here:\n; np.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.arange(2, 10, dtype=float)\narray([ 2., 3., 4., 5., 6., 7., 8., 9.])\n; np.arange(2, 3, 0.1)\narray([ 2. , 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9])\n\n\nNote that there are some subtleties regarding the last usage that the user\nshould be aware of that are described in the arange docstring.\nlinspace() will create arrays with a specified number of elements, and\nspaced equally between the specified beginning and end values. For\nexample:\n; np.linspace(1., 4., 6)\narray([ 1. ,  1.6,  2.2,  2.8,  3.4,  4. ])\n\n\nThe advantage of this creation function is that one can guarantee the\nnumber of elements and the starting and end point, which arange()\ngenerally will not do for arbitrary start, stop, and step values.\nindices() will create a set of arrays (stacked as a one-higher dimensioned\narray), one per dimension with each representing variation in that dimension.\nAn example illustrates much better than a verbal description:\n; np.indices((3,3))\narray([[[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]]])\n\n\nThis is particularly useful for evaluating functions of multiple dimensions on\na regular grid.\n", "; np.zeros((2, 3))\narray([[ 0., 0., 0.], [ 0., 0., 0.]])\n\n", "; np.zeros((2, 3))\narray([[ 0., 0., 0.], [ 0., 0., 0.]])\n", "; np.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.arange(2, 10, dtype=float)\narray([ 2., 3., 4., 5., 6., 7., 8., 9.])\n; np.arange(2, 3, 0.1)\narray([ 2. , 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9])\n\n", "; np.arange(10)\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.arange(2, 10, dtype=float)\narray([ 2., 3., 4., 5., 6., 7., 8., 9.])\n; np.arange(2, 3, 0.1)\narray([ 2. , 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7, 2.8, 2.9])\n", "; np.linspace(1., 4., 6)\narray([ 1. ,  1.6,  2.2,  2.8,  3.4,  4. ])\n\n", "; np.linspace(1., 4., 6)\narray([ 1. ,  1.6,  2.2,  2.8,  3.4,  4. ])\n", "; np.indices((3,3))\narray([[[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]]])\n\n", "; np.indices((3,3))\narray([[[0, 0, 0], [1, 1, 1], [2, 2, 2]], [[0, 1, 2], [0, 1, 2], [0, 1, 2]]])\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.broadcast.numiter", "code": "\nbroadcast.numiter\u00b6", "description": "Number of iterators possessed by the broadcasted result.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.numiter\n2\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.numiter\n2\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.numiter\n2\n"]},
{"library": "numpy", "item_id": "numpy.dtype.num", "code": "\ndtype.num\u00b6", "description": "A unique number for each of the 21 different built-in types.\nThese are roughly ordered from least-to-most precision.\nExamples\n&gt;&gt;&gt; dt = np.dtype(str)\n&gt;&gt;&gt; dt.num\n19\n\n\n&gt;&gt;&gt; dt = np.dtype(float)\n&gt;&gt;&gt; dt.num\n12\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype(str)\n; dt.num\n19\n\n", "; dt = np.dtype(str)\n; dt.num\n19\n", "; dt = np.dtype(float)\n; dt.num\n12\n\n", "; dt = np.dtype(float)\n; dt.num\n12\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.ntypes", "code": "\nufunc.ntypes\u00b6", "description": "The number of types.\nThe number of numerical NumPy types - of which there are 18 total - on which\nthe ufunc can operate.\n\nSee also\nnumpy.ufunc.types\n\nExamples\n&gt;&gt;&gt; np.add.ntypes\n18\n&gt;&gt;&gt; np.multiply.ntypes\n18\n&gt;&gt;&gt; np.power.ntypes\n17\n&gt;&gt;&gt; np.exp.ntypes\n7\n&gt;&gt;&gt; np.remainder.ntypes\n14\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.ntypes\n18\n; np.multiply.ntypes\n18\n; np.power.ntypes\n17\n; np.exp.ntypes\n7\n; np.remainder.ntypes\n14\n\n", "; np.add.ntypes\n18\n; np.multiply.ntypes\n18\n; np.power.ntypes\n17\n; np.exp.ntypes\n7\n; np.remainder.ntypes\n14\n"]},
{"library": "numpy", "item_id": "numpy.record.nonzero", "code": "\nrecord.nonzero()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.nonzero", "code": "\nrecarray.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.nonzero", "code": "\nmemmap.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.nonzero", "code": "\nmatrix.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.nonzero", "code": "\nndarray.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.nonzero", "code": "\ngeneric.nonzero()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.nonzero", "code": "\nMaskType.nonzero()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.nonzero", "code": "\nMaskedArray.nonzero(self)[source]\u00b6", "description": "Return the indices of unmasked elements that are not zero.\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with:\na[a.nonzero()]\n\n\nTo group the indices by element, rather than dimension, use\ninstead:\nnp.transpose(a.nonzero())\n\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n\nParameters\n\nNone\n\n\nReturns\n\ntuple_of_arraystupleIndices of elements that are non-zero.\n\n\n\n\n\nSee also\n\nnumpy.nonzeroFunction operating on ndarrays.\n\nflatnonzeroReturn indices that are non-zero in the flattened version of the input array.\n\nnumpy.ndarray.nonzeroEquivalent ndarray method.\n\ncount_nonzeroCounts the number of non-zero elements in the input array.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = ma.array(np.eye(3))\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n\nMasked elements are ignored.\n&gt;&gt;&gt; x[1, 1] = ma.masked\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n\nIndices can also be grouped by element.\n&gt;&gt;&gt; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n\nA common use for nonzero is to find the indices of an array, where\na condition is True.  Given an array a, the condition a &gt; 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)\nyields the indices of the a where the condition is true.\n&gt;&gt;&gt; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n&gt;&gt;&gt; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n&gt;&gt;&gt; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\nThe nonzero method of the condition array can also be called.\n&gt;&gt;&gt; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\n", "parameters": ["Parameters", "None", "Returns", "tuple_of_arraystuple"], "returns": "tuple_of_arraystupleIndices of elements that are non-zero.", "examples": ["; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n", "; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.nonzero", "code": "\nmasked_array.nonzero(self)[source]\u00b6", "description": "Return the indices of unmasked elements that are not zero.\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with:\na[a.nonzero()]\n\n\nTo group the indices by element, rather than dimension, use\ninstead:\nnp.transpose(a.nonzero())\n\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n\nParameters\n\nNone\n\n\nReturns\n\ntuple_of_arraystupleIndices of elements that are non-zero.\n\n\n\n\n\nSee also\n\nnumpy.nonzeroFunction operating on ndarrays.\n\nflatnonzeroReturn indices that are non-zero in the flattened version of the input array.\n\nnumpy.ndarray.nonzeroEquivalent ndarray method.\n\ncount_nonzeroCounts the number of non-zero elements in the input array.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = ma.array(np.eye(3))\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n\nMasked elements are ignored.\n&gt;&gt;&gt; x[1, 1] = ma.masked\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n\nIndices can also be grouped by element.\n&gt;&gt;&gt; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n\nA common use for nonzero is to find the indices of an array, where\na condition is True.  Given an array a, the condition a &gt; 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)\nyields the indices of the a where the condition is true.\n&gt;&gt;&gt; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n&gt;&gt;&gt; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n&gt;&gt;&gt; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\nThe nonzero method of the condition array can also be called.\n&gt;&gt;&gt; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\n", "parameters": ["Parameters", "None", "Returns", "tuple_of_arraystuple"], "returns": "tuple_of_arraystupleIndices of elements that are non-zero.", "examples": ["; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n", "; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n"]},
{"library": "numpy", "item_id": "numpy.chararray.nonzero", "code": "\nchararray.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.nonzero", "code": "\nchararray.nonzero()\u00b6", "description": "Return the indices of the elements that are non-zero.\nRefer to numpy.nonzero for full documentation.\n\nSee also\n\nnumpy.nonzeroequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nonzero", "code": "\nnumpy.nonzero(a)[source]\u00b6", "description": "Return the indices of the elements that are non-zero.\nReturns a tuple of arrays, one for each dimension of a,\ncontaining the indices of the non-zero elements in that\ndimension. The values in a are always tested and returned in\nrow-major, C-style order.\nTo group the indices by element, rather than dimension, use argwhere,\nwhich returns a row for each non-zero element.\n\nNote\nWhen called on a zero-d array or scalar, nonzero(a) is treated\nas nonzero(atleast1d(a)).\n\nDeprecated since version 1.17.0: Use atleast1d explicitly if this behavior is deliberate.\n\n\n\nParameters\n\naarray_likeInput array.\n\n\n\nReturns\n\ntuple_of_arraystupleIndices of elements that are non-zero.\n\n\n\n\n\nSee also\n\nflatnonzeroReturn indices that are non-zero in the flattened version of the input array.\n\nndarray.nonzeroEquivalent ndarray method.\n\ncount_nonzeroCounts the number of non-zero elements in the input array.\n\n\n\nNotes\nWhile the nonzero values can be obtained with a[nonzero(a)], it is\nrecommended to use x[x.astype(bool)] or x[x != 0] instead, which\nwill correctly handle 0-d arrays.\nExamples\n&gt;&gt;&gt; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])\n&gt;&gt;&gt; x\narray([[3, 0, 0],\n       [0, 4, 0],\n       [5, 6, 0]])\n&gt;&gt;&gt; np.nonzero(x)\n(array([0, 1, 2, 2]), array([0, 1, 0, 1]))\n\n\n&gt;&gt;&gt; x[np.nonzero(x)]\narray([3, 4, 5, 6])\n&gt;&gt;&gt; np.transpose(np.nonzero(x))\narray([[0, 0],\n       [1, 1],\n       [2, 0],\n       [2, 1]])\n\n\nA common use for nonzero is to find the indices of an array, where\na condition is True.  Given an array a, the condition a &gt; 3 is a\nboolean array and since False is interpreted as 0, np.nonzero(a &gt; 3)\nyields the indices of the a where the condition is true.\n&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n&gt;&gt;&gt; a &gt; 3\narray([[False, False, False],\n       [ True,  True,  True],\n       [ True,  True,  True]])\n&gt;&gt;&gt; np.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\nUsing this result to index a is equivalent to using the mask directly:\n&gt;&gt;&gt; a[np.nonzero(a &gt; 3)]\narray([4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; a[a &gt; 3]  # prefer this spelling\narray([4, 5, 6, 7, 8, 9])\n\n\nnonzero can also be called as a method of the array.\n&gt;&gt;&gt; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "tuple_of_arraystuple"], "returns": "tuple_of_arraystupleIndices of elements that are non-zero.", "examples": ["; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])\n; x\narray([[3, 0, 0],\n       [0, 4, 0],\n       [5, 6, 0]])\n; np.nonzero(x)\n(array([0, 1, 2, 2]), array([0, 1, 0, 1]))\n\n", "; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])\n; x\narray([[3, 0, 0],\n       [0, 4, 0],\n       [5, 6, 0]])\n; np.nonzero(x)\n(array([0, 1, 2, 2]), array([0, 1, 0, 1]))\n", "; x[np.nonzero(x)]\narray([3, 4, 5, 6])\n; np.transpose(np.nonzero(x))\narray([[0, 0],\n       [1, 1],\n       [2, 0],\n       [2, 1]])\n\n", "; x[np.nonzero(x)]\narray([3, 4, 5, 6])\n; np.transpose(np.nonzero(x))\narray([[0, 0],\n       [1, 1],\n       [2, 0],\n       [2, 1]])\n", "; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n; a &gt; 3\narray([[False, False, False],\n       [ True,  True,  True],\n       [ True,  True,  True]])\n; np.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n; a &gt; 3\narray([[False, False, False],\n       [ True,  True,  True],\n       [ True,  True,  True]])\n; np.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n", "; a[np.nonzero(a &gt; 3)]\narray([4, 5, 6, 7, 8, 9])\n; a[a &gt; 3]  # prefer this spelling\narray([4, 5, 6, 7, 8, 9])\n\n", "; a[np.nonzero(a &gt; 3)]\narray([4, 5, 6, 7, 8, 9])\n; a[a &gt; 3]  # prefer this spelling\narray([4, 5, 6, 7, 8, 9])\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n"]},
{"library": "numpy", "item_id": "numpy.ma.nonzero", "code": "\nnumpy.ma.nonzero(self) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return the indices of unmasked elements that are not zero.\nReturns a tuple of arrays, one for each dimension, containing the\nindices of the non-zero elements in that dimension. The corresponding\nnon-zero values can be obtained with:\na[a.nonzero()]\n\n\nTo group the indices by element, rather than dimension, use\ninstead:\nnp.transpose(a.nonzero())\n\n\nThe result of this is always a 2d array, with a row for each non-zero\nelement.\n\nParameters\n\nNone\n\n\nReturns\n\ntuple_of_arraystupleIndices of elements that are non-zero.\n\n\n\n\n\nSee also\n\nnumpy.nonzeroFunction operating on ndarrays.\n\nflatnonzeroReturn indices that are non-zero in the flattened version of the input array.\n\nnumpy.ndarray.nonzeroEquivalent ndarray method.\n\ncount_nonzeroCounts the number of non-zero elements in the input array.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = ma.array(np.eye(3))\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n\nMasked elements are ignored.\n&gt;&gt;&gt; x[1, 1] = ma.masked\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n&gt;&gt;&gt; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n\nIndices can also be grouped by element.\n&gt;&gt;&gt; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n\nA common use for nonzero is to find the indices of an array, where\na condition is True.  Given an array a, the condition a &gt; 3 is a\nboolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)\nyields the indices of the a where the condition is true.\n&gt;&gt;&gt; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n&gt;&gt;&gt; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n&gt;&gt;&gt; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\nThe nonzero method of the condition array can also be called.\n&gt;&gt;&gt; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n\n", "parameters": ["Parameters", "None", "Returns", "tuple_of_arraystuple"], "returns": "tuple_of_arraystupleIndices of elements that are non-zero.", "examples": ["; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n\n", "; import numpy.ma as ma\n; x = ma.array(np.eye(3))\n; x\nmasked_array(\n  data=[[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]],\n  mask=False,\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 1, 2]), array([0, 1, 2]))\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n\n", "; x[1, 1] = ma.masked\n; x\nmasked_array(\n  data=[[1.0, 0.0, 0.0],\n        [0.0, --, 0.0],\n        [0.0, 0.0, 1.0]],\n  mask=[[False, False, False],\n        [False,  True, False],\n        [False, False, False]],\n  fill_value=1e+20)\n; x.nonzero()\n(array([0, 2]), array([0, 2]))\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n\n", "; np.transpose(x.nonzero())\narray([[0, 0],\n       [2, 2]])\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])\n; a &gt; 3\nmasked_array(\n  data=[[False, False, False],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  mask=False,\n  fill_value=True)\n; ma.nonzero(a &gt; 3)\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n\n", "; (a &gt; 3).nonzero()\n(array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))\n"]},
{"library": "numpy", "item_id": "numpy.random.noncentral_f", "code": "\nnumpy.random.noncentral_f(dfnum, dfden, nonc, size=None)\u00b6", "description": "Draw samples from the noncentral F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters &gt; 1.\nnonc is the non-centrality parameter.\n\nNote\nNew code should use the noncentral_f method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndfnumfloat or array_like of floatsNumerator degrees of freedom, must be &gt; 0.\n\nChanged in version 1.14.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\ndfdenfloat or array_like of floatsDenominator degrees of freedom, must be &gt; 0.\n\nnoncfloat or array_like of floatsNon-centrality parameter, the sum of the squares of the numerator\nmeans, must be &gt;= 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum, dfden, and nonc\nare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.\n\n\n\n\n\nSee also\n\nGenerator.noncentral_fwhich should be used for new code.\n\n\n\nNotes\nWhen calculating the power of an experiment (power = probability of\nrejecting the null hypothesis when a specific alternative is true) the\nnon-central F statistic becomes important.  When the null hypothesis is\ntrue, the F statistic follows a central F distribution. When the null\nhypothesis is not true, then it follows a non-central F statistic.\nReferences\n\n1\nWeisstein, Eric W. \u201cNoncentral F-Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NoncentralF-Distribution.html\n\n2\nWikipedia, \u201cNoncentral F-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Noncentral_F-distribution\n\n\nExamples\nIn a study, testing for a specific alternative to the null hypothesis\nrequires use of the Noncentral F distribution. We need to calculate the\narea in the tail of the distribution that exceeds the value of the F\ndistribution for the null hypothesis.  We\u2019ll plot the two probability\ndistributions for comparison.\n&gt;&gt;&gt; dfnum = 3 # between group deg of freedom\n&gt;&gt;&gt; dfden = 20 # within groups degrees of freedom\n&gt;&gt;&gt; nonc = 3.0\n&gt;&gt;&gt; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n&gt;&gt;&gt; NF = np.histogram(nc_vals, bins=50, density=True)\n&gt;&gt;&gt; c_vals = np.random.f(dfnum, dfden, 1000000)\n&gt;&gt;&gt; F = np.histogram(c_vals, bins=50, density=True)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(F[1][1:], F[0])\n&gt;&gt;&gt; plt.plot(NF[1][1:], NF[0])\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.", "examples": ["; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = np.random.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n\n", "; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = np.random.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.noncentral_chisquare", "code": "\nRandomState.noncentral_chisquare(df, nonc, size=None)\u00b6", "description": "Draw samples from a noncentral chi-square distribution.\nThe noncentral  distribution is a generalization of\nthe  distribution.\n\nNote\nNew code should use the noncentral_chisquare method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nChanged in version 1.10.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\nnoncfloat or array_like of floatsNon-centrality, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df and nonc are both scalars.\nOtherwise, np.broadcast(df, nonc).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.\n\n\n\n\n\nSee also\n\nGenerator.noncentral_chisquarewhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the noncentral Chi-square\ndistribution is\n\n\nwhere  is the Chi-square with q degrees of freedom.\nReferences\n\n1\nWikipedia, \u201cNoncentral chi-squared distribution\u201d\nhttps://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw values from a noncentral chisquare with very small noncentrality,\nand compare to a chisquare.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate how large values of non-centrality lead to a more symmetric\ndistribution.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.", "examples": ["; import matplotlib.pyplot as plt\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.noncentral_chisquare", "code": "\nnumpy.random.noncentral_chisquare(df, nonc, size=None)\u00b6", "description": "Draw samples from a noncentral chi-square distribution.\nThe noncentral  distribution is a generalization of\nthe  distribution.\n\nNote\nNew code should use the noncentral_chisquare method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nChanged in version 1.10.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\nnoncfloat or array_like of floatsNon-centrality, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df and nonc are both scalars.\nOtherwise, np.broadcast(df, nonc).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.\n\n\n\n\n\nSee also\n\nGenerator.noncentral_chisquarewhich should be used for new code.\n\n\n\nNotes\nThe probability density function for the noncentral Chi-square\ndistribution is\n\n\nwhere  is the Chi-square with q degrees of freedom.\nReferences\n\n1\nWikipedia, \u201cNoncentral chi-squared distribution\u201d\nhttps://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw values from a noncentral chisquare with very small noncentrality,\nand compare to a chisquare.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate how large values of non-centrality lead to a more symmetric\ndistribution.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.", "examples": ["; import matplotlib.pyplot as plt\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(np.random.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(np.random.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.noncentral_f", "code": "\nRandomState.noncentral_f(dfnum, dfden, nonc, size=None)\u00b6", "description": "Draw samples from the noncentral F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters &gt; 1.\nnonc is the non-centrality parameter.\n\nNote\nNew code should use the noncentral_f method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndfnumfloat or array_like of floatsNumerator degrees of freedom, must be &gt; 0.\n\nChanged in version 1.14.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\ndfdenfloat or array_like of floatsDenominator degrees of freedom, must be &gt; 0.\n\nnoncfloat or array_like of floatsNon-centrality parameter, the sum of the squares of the numerator\nmeans, must be &gt;= 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum, dfden, and nonc\nare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.\n\n\n\n\n\nSee also\n\nGenerator.noncentral_fwhich should be used for new code.\n\n\n\nNotes\nWhen calculating the power of an experiment (power = probability of\nrejecting the null hypothesis when a specific alternative is true) the\nnon-central F statistic becomes important.  When the null hypothesis is\ntrue, the F statistic follows a central F distribution. When the null\nhypothesis is not true, then it follows a non-central F statistic.\nReferences\n\n1\nWeisstein, Eric W. \u201cNoncentral F-Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NoncentralF-Distribution.html\n\n2\nWikipedia, \u201cNoncentral F-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Noncentral_F-distribution\n\n\nExamples\nIn a study, testing for a specific alternative to the null hypothesis\nrequires use of the Noncentral F distribution. We need to calculate the\narea in the tail of the distribution that exceeds the value of the F\ndistribution for the null hypothesis.  We\u2019ll plot the two probability\ndistributions for comparison.\n&gt;&gt;&gt; dfnum = 3 # between group deg of freedom\n&gt;&gt;&gt; dfden = 20 # within groups degrees of freedom\n&gt;&gt;&gt; nonc = 3.0\n&gt;&gt;&gt; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n&gt;&gt;&gt; NF = np.histogram(nc_vals, bins=50, density=True)\n&gt;&gt;&gt; c_vals = np.random.f(dfnum, dfden, 1000000)\n&gt;&gt;&gt; F = np.histogram(c_vals, bins=50, density=True)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(F[1][1:], F[0])\n&gt;&gt;&gt; plt.plot(NF[1][1:], NF[0])\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.", "examples": ["; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = np.random.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n\n", "; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = np.random.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = np.random.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.noncentral_f", "code": "\nGenerator.noncentral_f(dfnum, dfden, nonc, size=None)\u00b6", "description": "Draw samples from the noncentral F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters &gt; 1.\nnonc is the non-centrality parameter.\n\nParameters\n\ndfnumfloat or array_like of floatsNumerator degrees of freedom, must be &gt; 0.\n\nChanged in version 1.14.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\ndfdenfloat or array_like of floatsDenominator degrees of freedom, must be &gt; 0.\n\nnoncfloat or array_like of floatsNon-centrality parameter, the sum of the squares of the numerator\nmeans, must be &gt;= 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum, dfden, and nonc\nare all scalars.  Otherwise, np.broadcast(dfnum, dfden, nonc).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.\n\n\n\n\nNotes\nWhen calculating the power of an experiment (power = probability of\nrejecting the null hypothesis when a specific alternative is true) the\nnon-central F statistic becomes important.  When the null hypothesis is\ntrue, the F statistic follows a central F distribution. When the null\nhypothesis is not true, then it follows a non-central F statistic.\nReferences\n\n1\nWeisstein, Eric W. \u201cNoncentral F-Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/NoncentralF-Distribution.html\n\n2\nWikipedia, \u201cNoncentral F-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Noncentral_F-distribution\n\n\nExamples\nIn a study, testing for a specific alternative to the null hypothesis\nrequires use of the Noncentral F distribution. We need to calculate the\narea in the tail of the distribution that exceeds the value of the F\ndistribution for the null hypothesis.  We\u2019ll plot the two probability\ndistributions for comparison.\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; dfnum = 3 # between group deg of freedom\n&gt;&gt;&gt; dfden = 20 # within groups degrees of freedom\n&gt;&gt;&gt; nonc = 3.0\n&gt;&gt;&gt; nc_vals = rng.noncentral_f(dfnum, dfden, nonc, 1000000)\n&gt;&gt;&gt; NF = np.histogram(nc_vals, bins=50, density=True)\n&gt;&gt;&gt; c_vals = rng.f(dfnum, dfden, 1000000)\n&gt;&gt;&gt; F = np.histogram(c_vals, bins=50, density=True)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(F[1][1:], F[0])\n&gt;&gt;&gt; plt.plot(NF[1][1:], NF[0])\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral Fisher distribution.", "examples": ["; rng = np.random.default_rng()\n; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = rng.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = rng.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n\n", "; rng = np.random.default_rng()\n; dfnum = 3 # between group deg of freedom\n; dfden = 20 # within groups degrees of freedom\n; nonc = 3.0\n; nc_vals = rng.noncentral_f(dfnum, dfden, nonc, 1000000)\n; NF = np.histogram(nc_vals, bins=50, density=True)\n; c_vals = rng.f(dfnum, dfden, 1000000)\n; F = np.histogram(c_vals, bins=50, density=True)\n; import matplotlib.pyplot as plt\n; plt.plot(F[1][1:], F[0])\n; plt.plot(NF[1][1:], NF[0])\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.nin", "code": "\nufunc.nin\u00b6", "description": "The number of inputs.\nData attribute containing the number of arguments the ufunc treats as input.\nExamples\n&gt;&gt;&gt; np.add.nin\n2\n&gt;&gt;&gt; np.multiply.nin\n2\n&gt;&gt;&gt; np.power.nin\n2\n&gt;&gt;&gt; np.exp.nin\n1\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.nin\n2\n; np.multiply.nin\n2\n; np.power.nin\n2\n; np.exp.nin\n1\n\n", "; np.add.nin\n2\n; np.multiply.nin\n2\n; np.power.nin\n2\n; np.exp.nin\n1\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.noncentral_chisquare", "code": "\nGenerator.noncentral_chisquare(df, nonc, size=None)\u00b6", "description": "Draw samples from a noncentral chi-square distribution.\nThe noncentral  distribution is a generalization of\nthe  distribution.\n\nParameters\n\ndffloat or array_like of floatsDegrees of freedom, must be &gt; 0.\n\nChanged in version 1.10.0: Earlier NumPy versions required dfnum &gt; 1.\n\n\nnoncfloat or array_like of floatsNon-centrality, must be non-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df and nonc are both scalars.\nOtherwise, np.broadcast(df, nonc).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.\n\n\n\n\nNotes\nThe probability density function for the noncentral Chi-square\ndistribution is\n\n\nwhere  is the Chi-square with q degrees of freedom.\nReferences\n\n1\nWikipedia, \u201cNoncentral chi-squared distribution\u201d\nhttps://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution\n\n\nExamples\nDraw values from the distribution and plot the histogram\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDraw values from a noncentral chisquare with very small noncentrality,\nand compare to a chisquare.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(rng.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; values2 = plt.hist(rng.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n&gt;&gt;&gt; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate how large values of non-centrality lead to a more symmetric\ndistribution.\n&gt;&gt;&gt; plt.figure()\n&gt;&gt;&gt; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "noncfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized noncentral chi-square distribution.", "examples": ["; rng = np.random.default_rng()\n; import matplotlib.pyplot as plt\n; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; rng = np.random.default_rng()\n; import matplotlib.pyplot as plt\n; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(rng.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(rng.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(rng.noncentral_chisquare(3, .0000001, 100000),\n...                   bins=np.arange(0., 25, .1), density=True)\n; values2 = plt.hist(rng.chisquare(3, 100000),\n...                    bins=np.arange(0., 25, .1), density=True)\n; plt.plot(values[1][0:-1], values[0]-values2[0], 'ob')\n; plt.show()\n", "; plt.figure()\n; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n\n", "; plt.figure()\n; values = plt.hist(rng.noncentral_chisquare(3, 20, 100000),\n...                   bins=200, density=True)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.nickname", "code": "\nLegendre.nickname = 'leg'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.nickname", "code": "\nHermiteE.nickname = 'herme'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.nickname", "code": "\nHermite.nickname = 'herm'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.nop", "code": "\nnditer.nop\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.nickname", "code": "\nPolynomial.nickname = 'poly'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nextafter", "code": "\nnumpy.nextafter(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'nextafter'&gt;\u00b6", "description": "Return the next floating-point value after x1 towards x2, element-wise.\n\nParameters\n\nx1array_likeValues to find the next representable value of.\n\nx2array_likeThe direction where to look for the next representable value of x1.\nIf x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThe next representable values of x1 in the direction of x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nExamples\n&gt;&gt;&gt; eps = np.finfo(np.float64).eps\n&gt;&gt;&gt; np.nextafter(1, 2) == eps + 1\nTrue\n&gt;&gt;&gt; np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\narray([ True,  True])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe next representable values of x1 in the direction of x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; eps = np.finfo(np.float64).eps\n; np.nextafter(1, 2) == eps + 1\nTrue\n; np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\narray([ True,  True])\n\n", "; eps = np.finfo(np.float64).eps\n; np.nextafter(1, 2) == eps + 1\nTrue\n; np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps]\narray([ True,  True])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.nickname", "code": "\nLaguerre.nickname = 'lag'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.nickname", "code": "\nChebyshev.nickname = 'cheb'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndindex.next", "code": "\nndindex.next(self)[source]\u00b6", "description": "Standard iterator method, updates the index and returns the index\ntuple.\n\nReturns\n\nvaltuple of intsReturns a tuple containing the indices of the current\niteration.\n\n\n\n\n", "parameters": [], "returns": "valtuple of intsReturns a tuple containing the indices of the currentiteration.", "examples": []},
{"library": "numpy", "item_id": "numpy.ndenumerate.next", "code": "\nndenumerate.next(self)[source]\u00b6", "description": "Standard iterator method, returns the index tuple and array value.\n\nReturns\n\ncoordstuple of intsThe indices of the current iteration.\n\nvalscalarThe array element of the current iteration.\n\n\n\n\n", "parameters": [], "returns": "coordstuple of intsThe indices of the current iteration.valscalarThe array element of the current iteration.", "examples": []},
{"library": "numpy", "item_id": "numpy.record.newbyteorder", "code": "\nrecord.newbyteorder(new_order='S')\u00b6", "description": "Return a new dtype with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe new_order code can be any from the following:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\n\nParameters\n\nnew_orderstr, optionalByte order to force; a value from the byte order specifications\nabove.  The default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_dtypedtypeNew dtype object with the given change to the byte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstr, optional", "Returns", "new_dtypedtype"], "returns": "new_dtypedtypeNew dtype object with the given change to the byte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.newbyteorder", "code": "\nrecarray.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.newbyteorder", "code": "\nndarray.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.newbyteorder", "code": "\nmemmap.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.newbyteorder", "code": "\nmatrix.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.newbyteorder", "code": "\nMaskType.newbyteorder(new_order='S')\u00b6", "description": "Return a new dtype with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe new_order code can be any from the following:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\n\nParameters\n\nnew_orderstr, optionalByte order to force; a value from the byte order specifications\nabove.  The default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_dtypedtypeNew dtype object with the given change to the byte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstr, optional", "Returns", "new_dtypedtype"], "returns": "new_dtypedtypeNew dtype object with the given change to the byte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.newbyteorder", "code": "\nmasked_array.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.newbyteorder", "code": "\nchararray.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.newbyteorder", "code": "\nchararray.newbyteorder(new_order='S')\u00b6", "description": "Return the array with the same data viewed with a different byte order.\nEquivalent to:\narr.view(arr.dtype.newbytorder(new_order))\n\n\nChanges are also made in all fields and sub-arrays of the array data\ntype.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow. new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_arrarrayNew array object with the dtype reflecting given change to the\nbyte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_arrarray"], "returns": "new_arrarrayNew array object with the dtype reflecting given change to thebyte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer", "code": "\nclass numpy.nditer[source]\u00b6", "description": "Efficient multi-dimensional iterator object to iterate over arrays.\nTo get started using this object, see the\nintroductory guide to array iteration.\n\nParameters\n\nopndarray or sequence of array_likeThe array(s) to iterate over.\n\nflagssequence of str, optionalFlags to control the behavior of the iterator.\n\nbuffered enables buffering when required.\nc_index causes a C-order index to be tracked.\nf_index causes a Fortran-order index to be tracked.\nmulti_index causes a multi-index, or a tuple of indices\nwith one per iteration dimension, to be tracked.\ncommon_dtype causes all the operands to be converted to\na common data type, with copying or buffering as necessary.\ncopy_if_overlap causes the iterator to determine if read\noperands have overlap with write operands, and make temporary\ncopies as necessary to avoid overlap. False positives (needless\ncopying) are possible in some cases.\ndelay_bufalloc delays allocation of the buffers until\na reset() call is made. Allows allocate operands to\nbe initialized before their values are copied into the buffers.\nexternal_loop causes the values given to be\none-dimensional arrays with multiple values instead of\nzero-dimensional arrays.\ngrow_inner allows the value array sizes to be made\nlarger than the buffer size when both buffered and\nexternal_loop is used.\nranged allows the iterator to be restricted to a sub-range\nof the iterindex values.\nrefs_ok enables iteration of reference types, such as\nobject arrays.\nreduce_ok enables iteration of readwrite operands\nwhich are broadcasted, also known as reduction operands.\nzerosize_ok allows itersize to be zero.\n\n\nop_flagslist of list of str, optionalThis is a list of flags for each operand. At minimum, one of\nreadonly, readwrite, or writeonly must be specified.\n\nreadonly indicates the operand will only be read from.\nreadwrite indicates the operand will be read from and written to.\nwriteonly indicates the operand will only be written to.\nno_broadcast prevents the operand from being broadcasted.\ncontig forces the operand data to be contiguous.\naligned forces the operand data to be aligned.\nnbo forces the operand data to be in native byte order.\ncopy allows a temporary read-only copy if required.\nupdateifcopy allows a temporary read-write copy if required.\nallocate causes the array to be allocated if it is None\nin the op parameter.\nno_subtype prevents an allocate operand from using a subtype.\narraymask indicates that this operand is the mask to use\nfor selecting elements when writing to operands with the\n\u2018writemasked\u2019 flag set. The iterator does not enforce this,\nbut when writing from a buffer back to the array, it only\ncopies those elements indicated by this mask.\nwritemasked indicates that only elements where the chosen\narraymask operand is True will be written to.\noverlap_assume_elementwise can be used to mark operands that are\naccessed only in the iterator order, to allow less conservative\ncopying when copy_if_overlap is present.\n\n\nop_dtypesdtype or tuple of dtype(s), optionalThe required data type(s) of the operands. If copying or buffering\nis enabled, the data will be converted to/from their original types.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the iteration order. \u2018C\u2019 means C order, \u2018F\u2019 means\nFortran order, \u2018A\u2019 means \u2018F\u2019 order if all the arrays are Fortran\ncontiguous, \u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible. This also\naffects the element memory order of allocate operands, as they\nare allocated to be compatible with iteration order.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur when making a copy\nor buffering.  Setting this to \u2018unsafe\u2019 is not recommended,\nas it can adversely affect accumulations.\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\nop_axeslist of list of ints, optionalIf provided, is a list of ints or None for each operands.\nThe list of axes for an operand is a mapping from the dimensions\nof the iterator to the dimensions of the operand. A value of\n-1 can be placed for entries, causing that dimension to be\ntreated as newaxis.\n\nitershapetuple of ints, optionalThe desired shape of the iterator. This allows allocate operands\nwith a dimension mapped by op_axes not corresponding to a dimension\nof a different operand to get a value not equal to 1 for that\ndimension.\n\nbuffersizeint, optionalWhen buffering is enabled, controls the size of the temporary\nbuffers. Set to 0 for the default value.\n\n\n\n\nNotes\nnditer supersedes flatiter.  The iterator implementation behind\nnditer is also exposed by the NumPy C API.\nThe Python exposure supplies two iteration interfaces, one which follows\nthe Python iterator protocol, and another which mirrors the C-style\ndo-while pattern.  The native Python approach is better in most cases, but\nif you need the coordinates or index of an iterator, use the C-style pattern.\nExamples\nHere is how we might write an iter_add function, using the\nPython iterator protocol:\n&gt;&gt;&gt; def iter_add_py(x, y, out=None):\n...     addop = np.add\n...     it = np.nditer([x, y, out], [],\n...                 [['readonly'], ['readonly'], ['writeonly','allocate']])\n...     with it:\n...         for (a, b, c) in it:\n...             addop(a, b, out=c)\n...     return it.operands[2]\n\n\nHere is the same function, but following the C-style pattern:\n&gt;&gt;&gt; def iter_add(x, y, out=None):\n...    addop = np.add\n...    it = np.nditer([x, y, out], [],\n...                [['readonly'], ['readonly'], ['writeonly','allocate']])\n...    with it:\n...        while not it.finished:\n...            addop(it[0], it[1], out=it[2])\n...            it.iternext()\n...        return it.operands[2]\n\n\nHere is an example outer product function:\n&gt;&gt;&gt; def outer_it(x, y, out=None):\n...     mulop = np.multiply\n...     it = np.nditer([x, y, out], ['external_loop'],\n...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n...                      [-1] * x.ndim + list(range(y.ndim)),\n...                      None])\n...     with it:\n...         for (a, b, c) in it:\n...             mulop(a, b, out=c)\n...         return it.operands[2]\n\n\n&gt;&gt;&gt; a = np.arange(2)+1\n&gt;&gt;&gt; b = np.arange(3)+1\n&gt;&gt;&gt; outer_it(a,b)\narray([[1, 2, 3],\n       [2, 4, 6]])\n\n\nHere is an example function which operates like a \u201clambda\u201d ufunc:\n&gt;&gt;&gt; def luf(lamdaexpr, *args, **kwargs):\n...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''\n...    nargs = len(args)\n...    op = (kwargs.get('out',None),) + args\n...    it = np.nditer(op, ['buffered','external_loop'],\n...            [['writeonly','allocate','no_broadcast']] +\n...                            [['readonly','nbo','aligned']]*nargs,\n...            order=kwargs.get('order','K'),\n...            casting=kwargs.get('casting','safe'),\n...            buffersize=kwargs.get('buffersize',0))\n...    while not it.finished:\n...        it[0] = lamdaexpr(*it[1:])\n...        it.iternext()\n...        return it.operands[0]\n\n\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; b = np.ones(5)\n&gt;&gt;&gt; luf(lambda i,j:i*i + j/2, a, b)\narray([  0.5,   1.5,   4.5,   9.5,  16.5])\n\n\nIf operand flags \u201cwriteonly\u201d or \u201creadwrite\u201d are used the\noperands may be views into the original data with the\nWRITEBACKIFCOPY flag. In this case nditer must be used as a\ncontext manager or the nditer.close method must be called before\nusing the result. The temporary data will be written back to the\noriginal data when the __exit__ function is called but not before:\n&gt;&gt;&gt; a = np.arange(6, dtype='i4')[::-2]\n&gt;&gt;&gt; with np.nditer(a, [],\n...        [['writeonly', 'updateifcopy']],\n...        casting='unsafe',\n...        op_dtypes=[np.dtype('f4')]) as i:\n...    x = i.operands[0]\n...    x[:] = [-1, -2, -3]\n...    # a still unchanged here\n&gt;&gt;&gt; a, x\n(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n\n\nIt is important to note that once the iterator is exited, dangling\nreferences (like x in the example) may or may not share data with\nthe original data a. If writeback semantics were active, i.e. if\nx.base.flags.writebackifcopy is True, then exiting the iterator\nwill sever the connection between x and a, writing to x will\nno longer write to a. If writeback semantics are not active, then\nx.data will still point at some part of a.data, and writing to\none will affect the other.\nContext management and the close method appeared in version 1.15.0.\n\nAttributes\n\ndtypestuple of dtype(s)The data types of the values provided in value. This may be\ndifferent from the operand data types if buffering is enabled.\nValid only before the iterator is closed.\n\nfinishedboolWhether the iteration over the operands is finished or not.\n\nhas_delayed_bufallocboolIf True, the iterator was created with the delay_bufalloc flag,\nand no reset() function was called on it yet.\n\nhas_indexboolIf True, the iterator was created with either the c_index or\nthe f_index flag, and the property index can be used to\nretrieve it.\n\nhas_multi_indexboolIf True, the iterator was created with the multi_index flag,\nand the property multi_index can be used to retrieve it.\n\nindexWhen the c_index or f_index flag was used, this property\nprovides access to the index. Raises a ValueError if accessed\nand has_index is False.\n\niterationneedsapiboolWhether iteration requires access to the Python API, for example\nif one of the operands is an object array.\n\niterindexintAn index which matches the order of iteration.\n\nitersizeintSize of the iterator.\n\nitviewsStructured view(s) of operands in memory, matching the reordered\nand optimized iterator access pattern. Valid only before the iterator\nis closed.\n\nmulti_indexWhen the multi_index flag was used, this property\nprovides access to the index. Raises a ValueError if accessed\naccessed and has_multi_index is False.\n\nndimintThe dimensions of the iterator.\n\nnopintThe number of iterator operands.\n\noperandstuple of operand(s)operands[Slice]\n\nshapetuple of intsShape tuple, the shape of the iterator.\n\nvalueValue of operands at current iteration. Normally, this is a\ntuple of array scalars, but if the flag external_loop is used,\nit is a tuple of one dimensional arrays.\n\n\n\n\nMethods\n\n\n\n\n\n\nclose()\nResolve all writeback semantics in writeable operands.\n\ncopy()\nGet a copy of the iterator in its current state.\n\ndebug_print()\nPrint the current state of the nditer instance and debug info to stdout.\n\nenable_external_loop()\nWhen the \u201cexternal_loop\u201d was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.\n\niternext()\nCheck whether iterations are left, and perform a single internal iteration without returning the result.\n\nremove_axis(i)\nRemoves axis i from the iterator.\n\nremove_multi_index()\nWhen the \u201cmulti_index\u201d flag was specified, this removes it, allowing the internal iteration structure to be optimized further.\n\nreset()\nReset the iterator to its initial state.\n\n\n\n", "parameters": ["Parameters", "opndarray or sequence of array_like", "flagssequence of str, optional", "op_flagslist of list of str, optional", "op_dtypesdtype or tuple of dtype(s), optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "op_axeslist of list of ints, optional", "itershapetuple of ints, optional", "buffersizeint, optional", "Attributes", "dtypestuple of dtype(s)", "finishedbool", "has_delayed_bufallocbool", "has_indexbool", "has_multi_indexbool", "index", "iterationneedsapibool", "iterindexint", "itersizeint", "itviews", "multi_index", "ndimint", "nopint", "operandstuple of operand(s)", "shapetuple of ints", "value"], "returns": [], "examples": ["; def iter_add_py(x, y, out=None):\n...     addop = np.add\n...     it = np.nditer([x, y, out], [],\n...                 [['readonly'], ['readonly'], ['writeonly','allocate']])\n...     with it:\n...         for (a, b, c) in it:\n...             addop(a, b, out=c)\n...     return it.operands[2]\n\n", "; def iter_add_py(x, y, out=None):\n...     addop = np.add\n...     it = np.nditer([x, y, out], [],\n...                 [['readonly'], ['readonly'], ['writeonly','allocate']])\n...     with it:\n...         for (a, b, c) in it:\n...             addop(a, b, out=c)\n...     return it.operands[2]\n", "; def iter_add(x, y, out=None):\n...    addop = np.add\n...    it = np.nditer([x, y, out], [],\n...                [['readonly'], ['readonly'], ['writeonly','allocate']])\n...    with it:\n...        while not it.finished:\n...            addop(it[0], it[1], out=it[2])\n...            it.iternext()\n...        return it.operands[2]\n\n", "; def iter_add(x, y, out=None):\n...    addop = np.add\n...    it = np.nditer([x, y, out], [],\n...                [['readonly'], ['readonly'], ['writeonly','allocate']])\n...    with it:\n...        while not it.finished:\n...            addop(it[0], it[1], out=it[2])\n...            it.iternext()\n...        return it.operands[2]\n", "; def outer_it(x, y, out=None):\n...     mulop = np.multiply\n...     it = np.nditer([x, y, out], ['external_loop'],\n...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n...                      [-1] * x.ndim + list(range(y.ndim)),\n...                      None])\n...     with it:\n...         for (a, b, c) in it:\n...             mulop(a, b, out=c)\n...         return it.operands[2]\n\n", "; def outer_it(x, y, out=None):\n...     mulop = np.multiply\n...     it = np.nditer([x, y, out], ['external_loop'],\n...             [['readonly'], ['readonly'], ['writeonly', 'allocate']],\n...             op_axes=[list(range(x.ndim)) + [-1] * y.ndim,\n...                      [-1] * x.ndim + list(range(y.ndim)),\n...                      None])\n...     with it:\n...         for (a, b, c) in it:\n...             mulop(a, b, out=c)\n...         return it.operands[2]\n", "; a = np.arange(2)+1\n; b = np.arange(3)+1\n; outer_it(a,b)\narray([[1, 2, 3],\n       [2, 4, 6]])\n\n", "; a = np.arange(2)+1\n; b = np.arange(3)+1\n; outer_it(a,b)\narray([[1, 2, 3],\n       [2, 4, 6]])\n", "; def luf(lamdaexpr, *args, **kwargs):\n...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''\n...    nargs = len(args)\n...    op = (kwargs.get('out',None),) + args\n...    it = np.nditer(op, ['buffered','external_loop'],\n...            [['writeonly','allocate','no_broadcast']] +\n...                            [['readonly','nbo','aligned']]*nargs,\n...            order=kwargs.get('order','K'),\n...            casting=kwargs.get('casting','safe'),\n...            buffersize=kwargs.get('buffersize',0))\n...    while not it.finished:\n...        it[0] = lamdaexpr(*it[1:])\n...        it.iternext()\n...        return it.operands[0]\n\n", "; def luf(lamdaexpr, *args, **kwargs):\n...    '''luf(lambdaexpr, op1, ..., opn, out=None, order='K', casting='safe', buffersize=0)'''\n...    nargs = len(args)\n...    op = (kwargs.get('out',None),) + args\n...    it = np.nditer(op, ['buffered','external_loop'],\n...            [['writeonly','allocate','no_broadcast']] +\n...                            [['readonly','nbo','aligned']]*nargs,\n...            order=kwargs.get('order','K'),\n...            casting=kwargs.get('casting','safe'),\n...            buffersize=kwargs.get('buffersize',0))\n...    while not it.finished:\n...        it[0] = lamdaexpr(*it[1:])\n...        it.iternext()\n...        return it.operands[0]\n", "; a = np.arange(5)\n; b = np.ones(5)\n; luf(lambda i,j:i*i + j/2, a, b)\narray([  0.5,   1.5,   4.5,   9.5,  16.5])\n\n", "; a = np.arange(5)\n; b = np.ones(5)\n; luf(lambda i,j:i*i + j/2, a, b)\narray([  0.5,   1.5,   4.5,   9.5,  16.5])\n", "; a = np.arange(6, dtype='i4')[::-2]\n; with np.nditer(a, [],\n...        [['writeonly', 'updateifcopy']],\n...        casting='unsafe',\n...        op_dtypes=[np.dtype('f4')]) as i:\n...    x = i.operands[0]\n...    x[:] = [-1, -2, -3]\n...    # a still unchanged here\n; a, x\n(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n\n", "; a = np.arange(6, dtype='i4')[::-2]\n; with np.nditer(a, [],\n...        [['writeonly', 'updateifcopy']],\n...        casting='unsafe',\n...        op_dtypes=[np.dtype('f4')]) as i:\n...    x = i.operands[0]\n...    x[:] = [-1, -2, -3]\n...    # a still unchanged here\n; a, x\n(array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))\n"]},
{"library": "numpy", "item_id": "numpy.generic.newbyteorder", "code": "\ngeneric.newbyteorder(new_order='S')\u00b6", "description": "Return a new dtype with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\nThe new_order code can be any from the following:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\n\nParameters\n\nnew_orderstr, optionalByte order to force; a value from the byte order specifications\nabove.  The default value (\u2018S\u2019) results in swapping the current\nbyte order. The code does a case-insensitive check on the first\nletter of new_order for the alternatives above.  For example,\nany of \u2018B\u2019 or \u2018b\u2019 or \u2018biggish\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_dtypedtypeNew dtype object with the given change to the byte order.\n\n\n\n\n", "parameters": ["Parameters", "new_orderstr, optional", "Returns", "new_dtypedtype"], "returns": "new_dtypedtypeNew dtype object with the given change to the byte order.", "examples": []},
{"library": "numpy", "item_id": "numpy.ndindex.ndincr", "code": "\nndindex.ndincr(self)[source]\u00b6", "description": "Increment the multi-dimensional index by one.\nThis method is for backward compatibility only: do not use.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.newbyteorder", "code": "\ndtype.newbyteorder(new_order='S')\u00b6", "description": "Return a new dtype with a different byte order.\nChanges are also made in all fields and sub-arrays of the data type.\n\nParameters\n\nnew_orderstring, optionalByte order to force; a value from the byte order specifications\nbelow.  The default value (\u2018S\u2019) results in swapping the current\nbyte order.  new_order codes can be any of:\n\n\u2018S\u2019 - swap dtype from current to opposite endian\n{\u2018&lt;\u2019, \u2018L\u2019} - little endian\n{\u2018&gt;\u2019, \u2018B\u2019} - big endian\n{\u2018=\u2019, \u2018N\u2019} - native order\n{\u2018|\u2019, \u2018I\u2019} - ignore (no change to byte order)\n\nThe code does a case-insensitive check on the first letter of\nnew_order for these alternatives.  For example, any of \u2018&gt;\u2019\nor \u2018B\u2019 or \u2018b\u2019 or \u2018brian\u2019 are valid to specify big-endian.\n\n\n\nReturns\n\nnew_dtypedtypeNew dtype object with the given change to the byte order.\n\n\n\n\nNotes\nChanges are also made in all fields and sub-arrays of the data type.\nExamples\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys_is_le = sys.byteorder == 'little'\n&gt;&gt;&gt; native_code = sys_is_le and '&lt;' or '&gt;'\n&gt;&gt;&gt; swapped_code = sys_is_le and '&gt;' or '&lt;'\n&gt;&gt;&gt; native_dt = np.dtype(native_code+'i2')\n&gt;&gt;&gt; swapped_dt = np.dtype(swapped_code+'i2')\n&gt;&gt;&gt; native_dt.newbyteorder('S') == swapped_dt\nTrue\n&gt;&gt;&gt; native_dt.newbyteorder() == swapped_dt\nTrue\n&gt;&gt;&gt; native_dt == swapped_dt.newbyteorder('S')\nTrue\n&gt;&gt;&gt; native_dt == swapped_dt.newbyteorder('=')\nTrue\n&gt;&gt;&gt; native_dt == swapped_dt.newbyteorder('N')\nTrue\n&gt;&gt;&gt; native_dt == native_dt.newbyteorder('|')\nTrue\n&gt;&gt;&gt; np.dtype('&lt;i2') == native_dt.newbyteorder('&lt;')\nTrue\n&gt;&gt;&gt; np.dtype('&lt;i2') == native_dt.newbyteorder('L')\nTrue\n&gt;&gt;&gt; np.dtype('&gt;i2') == native_dt.newbyteorder('&gt;')\nTrue\n&gt;&gt;&gt; np.dtype('&gt;i2') == native_dt.newbyteorder('B')\nTrue\n\n\n", "parameters": ["Parameters", "new_orderstring, optional", "Returns", "new_dtypedtype"], "returns": "new_dtypedtypeNew dtype object with the given change to the byte order.", "examples": ["; import sys\n; sys_is_le = sys.byteorder == 'little'\n; native_code = sys_is_le and '&lt;' or '&gt;'\n; swapped_code = sys_is_le and '&gt;' or '&lt;'\n; native_dt = np.dtype(native_code+'i2')\n; swapped_dt = np.dtype(swapped_code+'i2')\n; native_dt.newbyteorder('S') == swapped_dt\nTrue\n; native_dt.newbyteorder() == swapped_dt\nTrue\n; native_dt == swapped_dt.newbyteorder('S')\nTrue\n; native_dt == swapped_dt.newbyteorder('=')\nTrue\n; native_dt == swapped_dt.newbyteorder('N')\nTrue\n; native_dt == native_dt.newbyteorder('|')\nTrue\n; np.dtype('&lt;i2') == native_dt.newbyteorder('&lt;')\nTrue\n; np.dtype('&lt;i2') == native_dt.newbyteorder('L')\nTrue\n; np.dtype('&gt;i2') == native_dt.newbyteorder('&gt;')\nTrue\n; np.dtype('&gt;i2') == native_dt.newbyteorder('B')\nTrue\n\n", "; import sys\n; sys_is_le = sys.byteorder == 'little'\n; native_code = sys_is_le and '&lt;' or '&gt;'\n; swapped_code = sys_is_le and '&gt;' or '&lt;'\n; native_dt = np.dtype(native_code+'i2')\n; swapped_dt = np.dtype(swapped_code+'i2')\n; native_dt.newbyteorder('S') == swapped_dt\nTrue\n; native_dt.newbyteorder() == swapped_dt\nTrue\n; native_dt == swapped_dt.newbyteorder('S')\nTrue\n; native_dt == swapped_dt.newbyteorder('=')\nTrue\n; native_dt == swapped_dt.newbyteorder('N')\nTrue\n; native_dt == native_dt.newbyteorder('|')\nTrue\n; np.dtype('&lt;i2') == native_dt.newbyteorder('&lt;')\nTrue\n; np.dtype('&lt;i2') == native_dt.newbyteorder('L')\nTrue\n; np.dtype('&gt;i2') == native_dt.newbyteorder('&gt;')\nTrue\n; np.dtype('&gt;i2') == native_dt.newbyteorder('B')\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ndindex", "code": "\nclass numpy.ndindex(*shape)[source]\u00b6", "description": "An N-dimensional iterator object to index arrays.\nGiven the shape of an array, an ndindex instance iterates over\nthe N-dimensional index of the array. At each iteration a tuple\nof indices is returned, the last dimension is iterated over first.\n\nParameters\n\n`*args`intsThe size of each dimension of the array.\n\n\n\n\n\nSee also\nndenumerate, flatiter\n\nExamples\n&gt;&gt;&gt; for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)\n\n\nMethods\n\n\n\n\n\n\nndincr(self)\nIncrement the multi-dimensional index by one.\n\nnext(self)\nStandard iterator method, updates the index and returns the index tuple.\n\n\n\n", "parameters": ["Parameters", "`*args`ints"], "returns": [], "examples": ["; for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)\n\n", "; for index in np.ndindex(3, 2, 1):\n...     print(index)\n(0, 0, 0)\n(0, 1, 0)\n(1, 0, 0)\n(1, 1, 0)\n(2, 0, 0)\n(2, 1, 0)\n"]},
{"library": "numpy", "item_id": "numpy.record.ndim", "code": "\nrecord.ndim\u00b6", "description": "number of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.ndim", "code": "\nrecarray.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.matrix.ndim", "code": "\nmatrix.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.ndim", "code": "\nndarray.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.memmap.ndim", "code": "\nmemmap.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.ndim", "code": "\nMaskType.ndim\u00b6", "description": "number of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.ndim", "code": "\nnditer.ndim\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.ndim", "code": "\nMaskedArray.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.generic.ndim", "code": "\ngeneric.ndim\u00b6", "description": "number of array dimensions\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.ndim", "code": "\nmasked_array.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.chararray.ndim", "code": "\nchararray.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.dtype.ndim", "code": "\ndtype.ndim\u00b6", "description": "Number of dimensions of the sub-array if this data type describes a\nsub-array, and 0 otherwise.\n\nNew in version 1.13.0.\n\nExamples\n&gt;&gt;&gt; x = np.dtype(float)\n&gt;&gt;&gt; x.ndim\n0\n\n\n&gt;&gt;&gt; x = np.dtype((float, 8))\n&gt;&gt;&gt; x.ndim\n1\n\n\n&gt;&gt;&gt; x = np.dtype(('i4', (3, 4)))\n&gt;&gt;&gt; x.ndim\n2\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype(float)\n; x.ndim\n0\n\n", "; x = np.dtype(float)\n; x.ndim\n0\n", "; x = np.dtype((float, 8))\n; x.ndim\n1\n\n", "; x = np.dtype((float, 8))\n; x.ndim\n1\n", "; x = np.dtype(('i4', (3, 4)))\n; x.ndim\n2\n\n", "; x = np.dtype(('i4', (3, 4)))\n; x.ndim\n2\n"]},
{"library": "numpy", "item_id": "numpy.ndenumerate", "code": "\nclass numpy.ndenumerate(arr)[source]\u00b6", "description": "Multidimensional index iterator.\nReturn an iterator yielding pairs of array coordinates and values.\n\nParameters\n\narrndarrayInput array.\n\n\n\n\n\nSee also\nndindex, flatiter\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4\n\n\nMethods\n\n\n\n\n\n\nnext(self)\nStandard iterator method, returns the index tuple and array value.\n\n\n\n", "parameters": ["Parameters", "arrndarray"], "returns": [], "examples": ["; a = np.array([[1, 2], [3, 4]])\n; for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4\n\n", "; a = np.array([[1, 2], [3, 4]])\n; for index, x in np.ndenumerate(a):\n...     print(index, x)\n(0, 0) 1\n(0, 1) 2\n(1, 0) 3\n(1, 1) 4\n"]},
{"library": "numpy", "item_id": "numpy.lib.mixins.NDArrayOperatorsMixin", "code": "\nclass numpy.lib.mixins.NDArrayOperatorsMixin[source]\u00b6", "description": "Mixin defining all operator special methods using __array_ufunc__.\nThis class implements the special methods for almost all of Python\u2019s\nbuiltin operators defined in the operator module, including comparisons\n(==, &gt;, etc.) and arithmetic (+, *, -, etc.), by\ndeferring to the __array_ufunc__ method, which subclasses must\nimplement.\nIt is useful for writing classes that do not inherit from numpy.ndarray,\nbut that should support arithmetic and numpy universal functions like\narrays as described in A Mechanism for Overriding Ufuncs.\nAs an trivial example, consider this implementation of an ArrayLike\nclass that simply wraps a NumPy array and ensures that the result of any\narithmetic operation is also an ArrayLike object:\nclass ArrayLike(np.lib.mixins.NDArrayOperatorsMixin):\n    def __init__(self, value):\n        self.value = np.asarray(value)\n\n    # One might also consider adding the built-in list type to this\n    # list, to support operations like np.add(array_like, list)\n    _HANDLED_TYPES = (np.ndarray, numbers.Number)\n\n    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n        out = kwargs.get('out', ())\n        for x in inputs + out:\n            # Only support operations with instances of _HANDLED_TYPES.\n            # Use ArrayLike instead of type(self) for isinstance to\n            # allow subclasses that don't override __array_ufunc__ to\n            # handle ArrayLike objects.\n            if not isinstance(x, self._HANDLED_TYPES + (ArrayLike,)):\n                return NotImplemented\n\n        # Defer to the implementation of the ufunc on unwrapped values.\n        inputs = tuple(x.value if isinstance(x, ArrayLike) else x\n                       for x in inputs)\n        if out:\n            kwargs['out'] = tuple(\n                x.value if isinstance(x, ArrayLike) else x\n                for x in out)\n        result = getattr(ufunc, method)(*inputs, **kwargs)\n\n        if type(result) is tuple:\n            # multiple return values\n            return tuple(type(self)(x) for x in result)\n        elif method == 'at':\n            # no return value\n            return None\n        else:\n            # one return value\n            return type(self)(result)\n\n    def __repr__(self):\n        return '%s(%r)' % (type(self).__name__, self.value)\n\n\nIn interactions between ArrayLike objects and numbers or numpy arrays,\nthe result is always another ArrayLike:\n&gt;&gt;&gt; x = ArrayLike([1, 2, 3])\n&gt;&gt;&gt; x - 1\nArrayLike(array([0, 1, 2]))\n&gt;&gt;&gt; 1 - x\nArrayLike(array([ 0, -1, -2]))\n&gt;&gt;&gt; np.arange(3) - x\nArrayLike(array([-1, -1, -1]))\n&gt;&gt;&gt; x - np.arange(3)\nArrayLike(array([1, 1, 1]))\n\n\nNote that unlike numpy.ndarray, ArrayLike does not allow operations\nwith arbitrary, unrecognized types. This ensures that interactions with\nArrayLike preserve a well-defined casting hierarchy.\n\nNew in version 1.13.\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.ndim", "code": "\nchararray.ndim\u00b6", "description": "Number of array dimensions.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; x.ndim\n1\n&gt;&gt;&gt; y = np.zeros((2, 3, 4))\n&gt;&gt;&gt; y.ndim\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n\n", "; x = np.array([1, 2, 3])\n; x.ndim\n1\n; y = np.zeros((2, 3, 4))\n; y.ndim\n3\n"]},
{"library": "numpy", "item_id": "numpy.ndarray", "code": "\nclass numpy.ndarray(shape, dtype=float, buffer=None, offset=0, strides=None, order=None)[source]\u00b6", "description": "An array object represents a multidimensional, homogeneous array\nof fixed-size items.  An associated data-type object describes the\nformat of each element in the array (its byte-order, how many bytes it\noccupies in memory, whether it is an integer, a floating point number,\nor something else, etc.)\nArrays should be constructed using array, zeros or empty (refer\nto the See Also section below).  The parameters given here refer to\na low-level method (ndarray(\u2026)) for instantiating an array.\nFor more information, refer to the numpy module and examine the\nmethods and attributes of an array.\n\nParameters\n\n(for the __new__ method; see Notes below)\nshapetuple of intsShape of created array.\n\ndtypedata-type, optionalAny object that can be interpreted as a numpy data type.\n\nbufferobject exposing buffer interface, optionalUsed to fill the array with data.\n\noffsetint, optionalOffset of array data in buffer.\n\nstridestuple of ints, optionalStrides of data in memory.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalRow-major (C-style) or column-major (Fortran-style) order.\n\n\n\n\n\nSee also\n\narrayConstruct an array.\n\nzerosCreate an array, each element of which is zero.\n\nemptyCreate an array, but leave its allocated memory unchanged (i.e., it contains \u201cgarbage\u201d).\n\ndtypeCreate a data-type.\n\n\n\nNotes\nThere are two modes of creating an array using __new__:\n\nIf buffer is None, then only shape, dtype, and order\nare used.\nIf buffer is an object exposing the buffer interface, then\nall keywords are interpreted.\n\nNo __init__ method is needed because the array is fully initialized\nafter the __new__ method.\nExamples\nThese examples illustrate the low-level ndarray constructor.  Refer\nto the See Also section above for easier ways of constructing an\nndarray.\nFirst mode, buffer is None:\n&gt;&gt;&gt; np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\n\nSecond mode:\n&gt;&gt;&gt; np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])\n\n\n\nAttributes\n\nTndarrayThe transposed array.\n\ndatabufferPython buffer object pointing to the start of the array\u2019s data.\n\ndtypedtype objectData-type of the array\u2019s elements.\n\nflagsdictInformation about the memory layout of the array.\n\nflatnumpy.flatiter objectA 1-D iterator over the array.\n\nimagndarrayThe imaginary part of the array.\n\nrealndarrayThe real part of the array.\n\nsizeintNumber of elements in the array.\n\nitemsizeintLength of one array element in bytes.\n\nnbytesintTotal bytes consumed by the elements of the array.\n\nndimintNumber of array dimensions.\n\nshapetuple of intsTuple of array dimensions.\n\nstridestuple of intsTuple of bytes to step in each dimension when traversing an array.\n\nctypesctypes objectAn object to simplify the interaction of the array with the ctypes module.\n\nbasendarrayBase object if memory is from some other object.\n\n\n\n\nMethods\n\n\n\n\n\n\nall([axis,\u00a0out,\u00a0keepdims])\nReturns True if all elements evaluate to True.\n\nany([axis,\u00a0out,\u00a0keepdims])\nReturns True if any of the elements of a evaluate to True.\n\nargmax([axis,\u00a0out])\nReturn indices of the maximum values along the given axis.\n\nargmin([axis,\u00a0out])\nReturn indices of the minimum values along the given axis of a.\n\nargpartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nReturns the indices that would partition this array.\n\nargsort([axis,\u00a0kind,\u00a0order])\nReturns the indices that would sort this array.\n\nastype(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])\nCopy of the array, cast to a specified type.\n\nbyteswap([inplace])\nSwap the bytes of the array elements\n\nchoose(choices[,\u00a0out,\u00a0mode])\nUse an index array to construct a new array from a set of choices.\n\nclip([min,\u00a0max,\u00a0out])\nReturn an array whose values are limited to [min, max].\n\ncompress(condition[,\u00a0axis,\u00a0out])\nReturn selected slices of this array along given axis.\n\nconj()\nComplex-conjugate all elements.\n\nconjugate()\nReturn the complex conjugate, element-wise.\n\ncopy([order])\nReturn a copy of the array.\n\ncumprod([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative product of the elements along the given axis.\n\ncumsum([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative sum of the elements along the given axis.\n\ndiagonal([offset,\u00a0axis1,\u00a0axis2])\nReturn specified diagonals.\n\ndot(b[,\u00a0out])\nDot product of two arrays.\n\ndump(file)\nDump a pickle of the array to the specified file.\n\ndumps()\nReturns the pickle of the array as a string.\n\nfill(value)\nFill the array with a scalar value.\n\nflatten([order])\nReturn a copy of the array collapsed into one dimension.\n\ngetfield(dtype[,\u00a0offset])\nReturns a field of the given array as a certain type.\n\nitem(*args)\nCopy an element of an array to a standard Python scalar and return it.\n\nitemset(*args)\nInsert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\n\nmax([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the maximum along a given axis.\n\nmean([axis,\u00a0dtype,\u00a0out,\u00a0keepdims])\nReturns the average of the array elements along given axis.\n\nmin([axis,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the minimum along a given axis.\n\nnewbyteorder([new_order])\nReturn the array with the same data viewed with a different byte order.\n\nnonzero()\nReturn the indices of the elements that are non-zero.\n\npartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nRearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.\n\nprod([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0\u2026])\nReturn the product of the array elements over the given axis\n\nptp([axis,\u00a0out,\u00a0keepdims])\nPeak to peak (maximum - minimum) value along a given axis.\n\nput(indices,\u00a0values[,\u00a0mode])\nSet a.flat[n] = values[n] for all n in indices.\n\nravel([order])\nReturn a flattened array.\n\nrepeat(repeats[,\u00a0axis])\nRepeat elements of an array.\n\nreshape(shape[,\u00a0order])\nReturns an array containing the same data with a new shape.\n\nresize(new_shape[,\u00a0refcheck])\nChange shape and size of array in-place.\n\nround([decimals,\u00a0out])\nReturn a with each element rounded to the given number of decimals.\n\nsearchsorted(v[,\u00a0side,\u00a0sorter])\nFind indices where elements of v should be inserted in a to maintain order.\n\nsetfield(val,\u00a0dtype[,\u00a0offset])\nPut a value into a specified place in a field defined by a data-type.\n\nsetflags([write,\u00a0align,\u00a0uic])\nSet array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.\n\nsort([axis,\u00a0kind,\u00a0order])\nSort an array in-place.\n\nsqueeze([axis])\nRemove single-dimensional entries from the shape of a.\n\nstd([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])\nReturns the standard deviation of the array elements along given axis.\n\nsum([axis,\u00a0dtype,\u00a0out,\u00a0keepdims,\u00a0initial,\u00a0where])\nReturn the sum of the array elements over the given axis.\n\nswapaxes(axis1,\u00a0axis2)\nReturn a view of the array with axis1 and axis2 interchanged.\n\ntake(indices[,\u00a0axis,\u00a0out,\u00a0mode])\nReturn an array formed from the elements of a at the given indices.\n\ntobytes([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntofile(fid[,\u00a0sep,\u00a0format])\nWrite array to a file as text or binary (default).\n\ntolist()\nReturn the array as an a.ndim-levels deep nested list of Python scalars.\n\ntostring([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntrace([offset,\u00a0axis1,\u00a0axis2,\u00a0dtype,\u00a0out])\nReturn the sum along diagonals of the array.\n\ntranspose(*axes)\nReturns a view of the array with axes transposed.\n\nvar([axis,\u00a0dtype,\u00a0out,\u00a0ddof,\u00a0keepdims])\nReturns the variance of the array elements, along given axis.\n\nview([dtype,\u00a0type])\nNew view of array with the same data.\n\n\n\n", "parameters": ["Parameters", "(for the __new__ method; see Notes below)", "shapetuple of ints", "dtypedata-type, optional", "bufferobject exposing buffer interface, optional", "offsetint, optional", "stridestuple of ints, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Attributes", "Tndarray", "databuffer", "dtypedtype object", "flagsdict", "flatnumpy.flatiter object", "imagndarray", "realndarray", "sizeint", "itemsizeint", "nbytesint", "ndimint", "shapetuple of ints", "stridestuple of ints", "ctypesctypes object", "basendarray"], "returns": [], "examples": ["; np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n\n", "; np.ndarray(shape=(2,2), dtype=float, order='F')\narray([[0.0e+000, 0.0e+000], # random\n       [     nan, 2.5e-323]])\n", "; np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])\n\n", "; np.ndarray((2,), buffer=np.array([1,2,3]),\n...            offset=np.int_().itemsize,\n...            dtype=int) # offset = 1*itemsize, i.e. skip first element\narray([2, 3])\n"]},
{"library": "numpy", "item_id": "numpy.broadcast.ndim", "code": "\nbroadcast.ndim\u00b6", "description": "Number of dimensions of broadcasted result. Alias for nd.\n\nNew in version 1.12.0.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.ndim\n2\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.ndim\n2\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.ndim\n2\n"]},
{"library": "numpy", "item_id": "numpy.broadcast.nd", "code": "\nbroadcast.nd\u00b6", "description": "Number of dimensions of broadcasted result. For code intended for NumPy\n1.12.0 and later the more consistent ndim is preferred.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.nd\n2\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.nd\n2\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; b.nd\n2\n"]},
{"library": "numpy", "item_id": "numpy.record.nbytes", "code": "\nrecord.nbytes\u00b6", "description": "length of item in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.nbytes", "code": "\nrecarray.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.nbytes", "code": "\nndarray.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.memmap.nbytes", "code": "\nmemmap.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.nbytes", "code": "\nmasked_array.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.generic.nbytes", "code": "\ngeneric.nbytes\u00b6", "description": "length of item in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.nbytes", "code": "\nmatrix.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.chararray.nbytes", "code": "\nchararray.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.nbytes", "code": "\nMaskType.nbytes\u00b6", "description": "length of item in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.nbytes", "code": "\nMaskedArray.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.nbytes", "code": "\nchararray.nbytes\u00b6", "description": "Total bytes consumed by the elements of the array.\nNotes\nDoes not include memory consumed by non-element attributes of the\narray object.\nExamples\n&gt;&gt;&gt; x = np.zeros((3,5,2), dtype=np.complex128)\n&gt;&gt;&gt; x.nbytes\n480\n&gt;&gt;&gt; np.prod(x.shape) * x.itemsize\n480\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n\n", "; x = np.zeros((3,5,2), dtype=np.complex128)\n; x.nbytes\n480\n; np.prod(x.shape) * x.itemsize\n480\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.nargs", "code": "\nufunc.nargs\u00b6", "description": "The number of arguments.\nData attribute containing the number of arguments the ufunc takes, including\noptional ones.\nNotes\nTypically this value will be one more than what you might expect because all\nufuncs take  the optional \u201cout\u201d argument.\nExamples\n&gt;&gt;&gt; np.add.nargs\n3\n&gt;&gt;&gt; np.multiply.nargs\n3\n&gt;&gt;&gt; np.power.nargs\n3\n&gt;&gt;&gt; np.exp.nargs\n2\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.nargs\n3\n; np.multiply.nargs\n3\n; np.power.nargs\n3\n; np.exp.nargs\n2\n\n", "; np.add.nargs\n3\n; np.multiply.nargs\n3\n; np.power.nargs\n3\n; np.exp.nargs\n2\n"]},
{"library": "numpy", "item_id": "numpy.nanvar", "code": "\nnumpy.nanvar(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the variance along the specified axis, while ignoring NaNs.\nReturns the variance of the array elements, a measure of the spread of\na distribution.  The variance is computed for the flattened array by\ndefault, otherwise over the specified axis.\nFor all-NaN slices or slices with zero degrees of freedom, NaN is\nreturned and a RuntimeWarning is raised.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeArray containing numbers whose variance is desired.  If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the variance is computed.  The default is to compute\nthe variance of the flattened array.\n\ndtypedata-type, optionalType to use in computing the variance.  For arrays of integer type\nthe default is float64; for arrays of float types it is the same as\nthe array type.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output, but the type is cast if\nnecessary.\n\nddofint, optional\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is\nN - ddof, where N represents the number of non-NaN\nelements. By default ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\n\n\n\nReturns\n\nvariancendarray, see dtype parameter aboveIf out is None, return a new array containing the variance,\notherwise return a reference to the output array. If ddof is &gt;= the\nnumber of non-NaN elements in a slice or the slice contains only\nNaNs, then the result for that slice is NaN.\n\n\n\n\n\nSee also\n\nstdStandard deviation\n\nmeanAverage\n\nvarVariance while not ignoring NaNs\n\n\nnanstd, nanmean, ufuncs-output-type\n\nNotes\nThe variance is the average of the squared deviations from the mean,\ni.e.,  var = mean(abs(x - x.mean())**2).\nThe mean is normally calculated as x.sum() / N, where N = len(x).\nIf, however, ddof is specified, the divisor N - ddof is used\ninstead.  In standard statistical practice, ddof=1 provides an\nunbiased estimator of the variance of a hypothetical infinite\npopulation.  ddof=0 provides a maximum likelihood estimate of the\nvariance for normally distributed variables.\nNote that for complex numbers, the absolute value is taken before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the variance is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nFor this function to work on sub-classes of ndarray, they must define\nsum with the kwarg keepdims\nExamples\n&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])\n&gt;&gt;&gt; np.nanvar(a)\n1.5555555555555554\n&gt;&gt;&gt; np.nanvar(a, axis=0)\narray([1.,  0.])\n&gt;&gt;&gt; np.nanvar(a, axis=1)\narray([0.,  0.25])  # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "dtypedata-type, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "variancendarray, see dtype parameter above"], "returns": "variancendarray, see dtype parameter aboveIf out is None, return a new array containing the variance,otherwise return a reference to the output array. If ddof is &gt;= thenumber of non-NaN elements in a slice or the slice contains onlyNaNs, then the result for that slice is NaN.", "examples": ["; a = np.array([[1, np.nan], [3, 4]])\n; np.nanvar(a)\n1.5555555555555554\n; np.nanvar(a, axis=0)\narray([1.,  0.])\n; np.nanvar(a, axis=1)\narray([0.,  0.25])  # may vary\n\n", "; a = np.array([[1, np.nan], [3, 4]])\n; np.nanvar(a)\n1.5555555555555554\n; np.nanvar(a, axis=0)\narray([1.,  0.])\n; np.nanvar(a, axis=1)\narray([0.,  0.25])  # may vary\n"]},
{"library": "numpy", "item_id": "numpy.nanstd", "code": "\nnumpy.nanstd(a, axis=None, dtype=None, out=None, ddof=0, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the standard deviation along the specified axis, while\nignoring NaNs.\nReturns the standard deviation, a measure of the spread of a\ndistribution, of the non-NaN array elements. The standard deviation is\ncomputed for the flattened array by default, otherwise over the\nspecified axis.\nFor all-NaN slices or slices with zero degrees of freedom, NaN is\nreturned and a RuntimeWarning is raised.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeCalculate the standard deviation of the non-NaN values.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the standard deviation is computed. The default is\nto compute the standard deviation of the flattened array.\n\ndtypedtype, optionalType to use in computing the standard deviation. For arrays of\ninteger type the default is float64, for arrays of float types it\nis the same as the array type.\n\noutndarray, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output but the type (of the\ncalculated values) will be cast if necessary.\n\nddofint, optionalMeans Delta Degrees of Freedom.  The divisor used in calculations\nis N - ddof, where N represents the number of non-NaN\nelements.  By default ddof is zero.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf this value is anything but the default it is passed through\nas-is to the relevant functions of the sub-classes.  If these\nfunctions do not have a keepdims kwarg, a RuntimeError will\nbe raised.\n\n\n\nReturns\n\nstandard_deviationndarray, see dtype parameter above.If out is None, return a new array containing the standard\ndeviation, otherwise return a reference to the output array. If\nddof is &gt;= the number of non-NaN elements in a slice or the slice\ncontains only NaNs, then the result for that slice is NaN.\n\n\n\n\n\nSee also\nvar, mean, std, nanvar, nanmean, ufuncs-output-type\n\nNotes\nThe standard deviation is the square root of the average of the squared\ndeviations from the mean: std = sqrt(mean(abs(x - x.mean())**2)).\nThe average squared deviation is normally calculated as\nx.sum() / N, where N = len(x).  If, however, ddof is\nspecified, the divisor N - ddof is used instead. In standard\nstatistical practice, ddof=1 provides an unbiased estimator of the\nvariance of the infinite population. ddof=0 provides a maximum\nlikelihood estimate of the variance for normally distributed variables.\nThe standard deviation computed in this function is the square root of\nthe estimated variance, so even with ddof=1, it will not be an\nunbiased estimate of the standard deviation per se.\nNote that, for complex numbers, std takes the absolute value before\nsquaring, so that the result is always real and nonnegative.\nFor floating-point input, the std is computed using the same\nprecision the input has. Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32 (see example\nbelow).  Specifying a higher-accuracy accumulator using the dtype\nkeyword can alleviate this issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])\n&gt;&gt;&gt; np.nanstd(a)\n1.247219128924647\n&gt;&gt;&gt; np.nanstd(a, axis=0)\narray([1., 0.])\n&gt;&gt;&gt; np.nanstd(a, axis=1)\narray([0.,  0.5]) # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "dtypedtype, optional", "outndarray, optional", "ddofint, optional", "keepdimsbool, optional", "Returns", "standard_deviationndarray, see dtype parameter above."], "returns": "standard_deviationndarray, see dtype parameter above.If out is None, return a new array containing the standarddeviation, otherwise return a reference to the output array. Ifddof is &gt;= the number of non-NaN elements in a slice or the slicecontains only NaNs, then the result for that slice is NaN.", "examples": ["; a = np.array([[1, np.nan], [3, 4]])\n; np.nanstd(a)\n1.247219128924647\n; np.nanstd(a, axis=0)\narray([1., 0.])\n; np.nanstd(a, axis=1)\narray([0.,  0.5]) # may vary\n\n", "; a = np.array([[1, np.nan], [3, 4]])\n; np.nanstd(a)\n1.247219128924647\n; np.nanstd(a, axis=0)\narray([1., 0.])\n; np.nanstd(a, axis=1)\narray([0.,  0.5]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.nanquantile", "code": "\nnumpy.nanquantile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the qth quantile of the data along the specified axis,\nwhile ignoring nan values.\nReturns the qth quantile(s) of the array elements.\n\nNew in version 1.15.0.\n\n\nParameters\n\naarray_likeInput array or object that can be converted to an array, containing\nnan values to be ignored\n\nqarray_like of floatQuantile or sequence of quantiles to compute, which must be between\n0 and 1 inclusive.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the quantiles are computed. The\ndefault is to compute the quantile(s) along a flattened\nversion of the array.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow the input array a to be modified by intermediate\ncalculations, to save memory. In this case, the contents of the input\na after this function completes is undefined.\n\ninterpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}This optional parameter specifies the interpolation method to\nuse when the desired quantile lies between two data points\ni &lt; j:\n\nlinear: i + (j - i) * fraction, where fraction\nis the fractional part of the index surrounded by i\nand j.\nlower: i.\nhigher: j.\nnearest: i or j, whichever is nearest.\nmidpoint: (i + j) / 2.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left in\nthe result as dimensions with size one. With this option, the\nresult will broadcast correctly against the original array a.\nIf this is anything but the default value it will be passed\nthrough (in the special case of an empty array) to the\nmean function of the underlying array.  If the array is\na sub-class and mean does not have the kwarg keepdims this\nwill raise a RuntimeError.\n\n\n\nReturns\n\nquantilescalar or ndarrayIf q is a single percentile and axis=None, then the result\nis a scalar. If multiple quantiles are given, first axis of\nthe result corresponds to the quantiles. The other axes are\nthe axes that remain after the reduction of a. If the input\ncontains integers or floats smaller than float64, the output\ndata-type is float64. Otherwise, the output data-type is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nquantile, nanmean, nanmedian\n\nnanmedianequivalent to nanquantile(..., 0.5)\n\nnanpercentilesame as nanquantile, but with q in the range [0, 100].\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n&gt;&gt;&gt; a[0][1] = np.nan\n&gt;&gt;&gt; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n&gt;&gt;&gt; np.quantile(a, 0.5)\nnan\n&gt;&gt;&gt; np.nanquantile(a, 0.5)\n3.0\n&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0)\narray([6.5, 2. , 2.5])\n&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n&gt;&gt;&gt; m = np.nanquantile(a, 0.5, axis=0)\n&gt;&gt;&gt; out = np.zeros_like(m)\n&gt;&gt;&gt; np.nanquantile(a, 0.5, axis=0, out=out)\narray([6.5, 2. , 2.5])\n&gt;&gt;&gt; m\narray([6.5,  2. ,  2.5])\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)\narray([7., 2.])\n&gt;&gt;&gt; assert not np.all(a==b)\n\n\n", "parameters": ["Parameters", "aarray_like", "qarray_like of float", "axis{int, tuple of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "interpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}", "keepdimsbool, optional", "Returns", "quantilescalar or ndarray"], "returns": "quantilescalar or ndarrayIf q is a single percentile and axis=None, then the resultis a scalar. If multiple quantiles are given, first axis ofthe result corresponds to the quantiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n; a[0][1] = np.nan\n; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n; np.quantile(a, 0.5)\nnan\n; np.nanquantile(a, 0.5)\n3.0\n; np.nanquantile(a, 0.5, axis=0)\narray([6.5, 2. , 2.5])\n; np.nanquantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.nanquantile(a, 0.5, axis=0)\n; out = np.zeros_like(m)\n; np.nanquantile(a, 0.5, axis=0, out=out)\narray([6.5, 2. , 2.5])\n; m\narray([6.5,  2. ,  2.5])\n; b = a.copy()\n; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)\narray([7., 2.])\n; assert not np.all(a==b)\n\n", "; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n; a[0][1] = np.nan\n; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n; np.quantile(a, 0.5)\nnan\n; np.nanquantile(a, 0.5)\n3.0\n; np.nanquantile(a, 0.5, axis=0)\narray([6.5, 2. , 2.5])\n; np.nanquantile(a, 0.5, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.nanquantile(a, 0.5, axis=0)\n; out = np.zeros_like(m)\n; np.nanquantile(a, 0.5, axis=0, out=out)\narray([6.5, 2. , 2.5])\n; m\narray([6.5,  2. ,  2.5])\n; b = a.copy()\n; np.nanquantile(b, 0.5, axis=1, overwrite_input=True)\narray([7., 2.])\n; assert not np.all(a==b)\n"]},
{"library": "numpy", "item_id": "numpy.nanprod", "code": "\nnumpy.nanprod(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the product of array elements over a given axis treating Not a\nNumbers (NaNs) as ones.\nOne is returned for slices that are all-NaN or empty.\n\nNew in version 1.10.0.\n\n\nParameters\n\naarray_likeArray containing numbers whose product is desired. If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the product is computed. The default is to compute\nthe product of the flattened array.\n\ndtypedata-type, optionalThe type of the returned array and of the accumulator in which the\nelements are summed.  By default, the dtype of a is used.  An\nexception is when a has an integer type with less precision than\nthe platform (u)intp. In that case, the default will be either\n(u)int32 or (u)int64 depending on whether the platform is 32 or 64\nbits. For inexact inputs, dtype must be inexact.\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None. If provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary. See\nufuncs-output-type for more details. The casting of NaN to integer\ncan yield unexpected results.\n\nkeepdimsbool, optionalIf True, the axes which are reduced are left in the result as\ndimensions with size one. With this option, the result will\nbroadcast correctly against the original arr.\n\n\n\nReturns\n\nnanprodndarrayA new array holding the result is returned unless out is\nspecified, in which case it is returned.\n\n\n\n\n\nSee also\n\nnumpy.prodProduct across array propagating NaNs.\n\nisnanShow which elements are NaN.\n\n\n\nExamples\n&gt;&gt;&gt; np.nanprod(1)\n1\n&gt;&gt;&gt; np.nanprod([1])\n1\n&gt;&gt;&gt; np.nanprod([1, np.nan])\n1.0\n&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])\n&gt;&gt;&gt; np.nanprod(a)\n6.0\n&gt;&gt;&gt; np.nanprod(a, axis=0)\narray([3., 2.])\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "dtypedata-type, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "nanprodndarray"], "returns": "nanprodndarrayA new array holding the result is returned unless out isspecified, in which case it is returned.", "examples": ["; np.nanprod(1)\n1\n; np.nanprod([1])\n1\n; np.nanprod([1, np.nan])\n1.0\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nanprod(a)\n6.0\n; np.nanprod(a, axis=0)\narray([3., 2.])\n\n", "; np.nanprod(1)\n1\n; np.nanprod([1])\n1\n; np.nanprod([1, np.nan])\n1.0\n; a = np.array([[1, 2], [3, np.nan]])\n; np.nanprod(a)\n6.0\n; np.nanprod(a, axis=0)\narray([3., 2.])\n"]},
{"library": "numpy", "item_id": "numpy.nanpercentile", "code": "\nnumpy.nanpercentile(a, q, axis=None, out=None, overwrite_input=False, interpolation='linear', keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the qth percentile of the data along the specified axis,\nwhile ignoring nan values.\nReturns the qth percentile(s) of the array elements.\n\nNew in version 1.9.0.\n\n\nParameters\n\naarray_likeInput array or object that can be converted to an array, containing\nnan values to be ignored.\n\nqarray_like of floatPercentile or sequence of percentiles to compute, which must be between\n0 and 100 inclusive.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the percentiles are computed. The\ndefault is to compute the percentile(s) along a flattened\nversion of the array.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow the input array a to be modified by intermediate\ncalculations, to save memory. In this case, the contents of the input\na after this function completes is undefined.\n\ninterpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}This optional parameter specifies the interpolation method to\nuse when the desired percentile lies between two data points\ni &lt; j:\n\n\u2018linear\u2019: i + (j - i) * fraction, where fraction\nis the fractional part of the index surrounded by i\nand j.\n\u2018lower\u2019: i.\n\u2018higher\u2019: j.\n\u2018nearest\u2019: i or j, whichever is nearest.\n\u2018midpoint\u2019: (i + j) / 2.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left in\nthe result as dimensions with size one. With this option, the\nresult will broadcast correctly against the original array a.\nIf this is anything but the default value it will be passed\nthrough (in the special case of an empty array) to the\nmean function of the underlying array.  If the array is\na sub-class and mean does not have the kwarg keepdims this\nwill raise a RuntimeError.\n\n\n\nReturns\n\npercentilescalar or ndarrayIf q is a single percentile and axis=None, then the result\nis a scalar. If multiple percentiles are given, first axis of\nthe result corresponds to the percentiles. The other axes are\nthe axes that remain after the reduction of a. If the input\ncontains integers or floats smaller than float64, the output\ndata-type is float64. Otherwise, the output data-type is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nnanmean\n\nnanmedianequivalent to nanpercentile(..., 50)\n\n\npercentile, median, mean\n\nnanquantileequivalent to nanpercentile, but with q in the range [0, 1].\n\n\n\nNotes\nGiven a vector V of length N, the q-th percentile of\nV is the value q/100 of the way from the minimum to the\nmaximum in a sorted copy of V. The values and distances of\nthe two nearest neighbors as well as the interpolation parameter\nwill determine the percentile if the normalized ranking does not\nmatch the location of q exactly. This function is the same as\nthe median if q=50, the same as the minimum if q=0 and the\nsame as the maximum if q=100.\nExamples\n&gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n&gt;&gt;&gt; a[0][1] = np.nan\n&gt;&gt;&gt; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n&gt;&gt;&gt; np.percentile(a, 50)\nnan\n&gt;&gt;&gt; np.nanpercentile(a, 50)\n3.0\n&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)\narray([6.5, 2. , 2.5])\n&gt;&gt;&gt; np.nanpercentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n&gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)\n&gt;&gt;&gt; out = np.zeros_like(m)\n&gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=out)\narray([6.5, 2. , 2.5])\n&gt;&gt;&gt; m\narray([6.5,  2. ,  2.5])\n\n\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)\narray([7., 2.])\n&gt;&gt;&gt; assert not np.all(a==b)\n\n\n", "parameters": ["Parameters", "aarray_like", "qarray_like of float", "axis{int, tuple of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "interpolation{\u2018linear\u2019, \u2018lower\u2019, \u2018higher\u2019, \u2018midpoint\u2019, \u2018nearest\u2019}", "keepdimsbool, optional", "Returns", "percentilescalar or ndarray"], "returns": "percentilescalar or ndarrayIf q is a single percentile and axis=None, then the resultis a scalar. If multiple percentiles are given, first axis ofthe result corresponds to the percentiles. The other axes arethe axes that remain after the reduction of a. If the inputcontains integers or floats smaller than float64, the outputdata-type is float64. Otherwise, the output data-type is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n; a[0][1] = np.nan\n; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n; np.percentile(a, 50)\nnan\n; np.nanpercentile(a, 50)\n3.0\n; np.nanpercentile(a, 50, axis=0)\narray([6.5, 2. , 2.5])\n; np.nanpercentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.nanpercentile(a, 50, axis=0)\n; out = np.zeros_like(m)\n; np.nanpercentile(a, 50, axis=0, out=out)\narray([6.5, 2. , 2.5])\n; m\narray([6.5,  2. ,  2.5])\n\n", "; a = np.array([[10., 7., 4.], [3., 2., 1.]])\n; a[0][1] = np.nan\n; a\narray([[10.,  nan,   4.],\n      [ 3.,   2.,   1.]])\n; np.percentile(a, 50)\nnan\n; np.nanpercentile(a, 50)\n3.0\n; np.nanpercentile(a, 50, axis=0)\narray([6.5, 2. , 2.5])\n; np.nanpercentile(a, 50, axis=1, keepdims=True)\narray([[7.],\n       [2.]])\n; m = np.nanpercentile(a, 50, axis=0)\n; out = np.zeros_like(m)\n; np.nanpercentile(a, 50, axis=0, out=out)\narray([6.5, 2. , 2.5])\n; m\narray([6.5,  2. ,  2.5])\n", "; b = a.copy()\n; np.nanpercentile(b, 50, axis=1, overwrite_input=True)\narray([7., 2.])\n; assert not np.all(a==b)\n\n", "; b = a.copy()\n; np.nanpercentile(b, 50, axis=1, overwrite_input=True)\narray([7., 2.])\n; assert not np.all(a==b)\n"]},
{"library": "numpy", "item_id": "numpy.nanmin", "code": "\nnumpy.nanmin(a, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return minimum of an array or minimum along an axis, ignoring any NaNs.\nWhen all-NaN slices are encountered a RuntimeWarning is raised and\nNan is returned for that slice.\n\nParameters\n\naarray_likeArray containing numbers whose minimum is desired. If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the minimum is computed. The default is to compute\nthe minimum of the flattened array.\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None; if provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary. See\nufuncs-output-type for more details.\n\nNew in version 1.8.0.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf the value is anything but the default, then\nkeepdims will be passed through to the min method\nof sub-classes of ndarray.  If the sub-classes methods\ndoes not implement keepdims any exceptions will be raised.\n\nNew in version 1.8.0.\n\n\n\n\nReturns\n\nnanminndarrayAn array with the same shape as a, with the specified axis\nremoved.  If a is a 0-d array, or if axis is None, an ndarray\nscalar is returned.  The same dtype as a is returned.\n\n\n\n\n\nSee also\n\nnanmaxThe maximum value of an array along a given axis, ignoring any NaNs.\n\naminThe minimum value of an array along a given axis, propagating any NaNs.\n\nfminElement-wise minimum of two arrays, ignoring any NaNs.\n\nminimumElement-wise minimum of two arrays, propagating any NaNs.\n\nisnanShows which elements are Not a Number (NaN).\n\nisfiniteShows which elements are neither NaN nor infinity.\n\n\namax, fmax, maximum\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nPositive infinity is treated as a very large number and negative\ninfinity is treated as a very small (i.e. negative) number.\nIf the input has a integer type the function is equivalent to np.min.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])\n&gt;&gt;&gt; np.nanmin(a)\n1.0\n&gt;&gt;&gt; np.nanmin(a, axis=0)\narray([1.,  2.])\n&gt;&gt;&gt; np.nanmin(a, axis=1)\narray([1.,  3.])\n\n\nWhen positive infinity and negative infinity are present:\n&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])\n1.0\n&gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])\n-inf\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "nanminndarray"], "returns": "nanminndarrayAn array with the same shape as a, with the specified axisremoved.  If a is a 0-d array, or if axis is None, an ndarrayscalar is returned.  The same dtype as a is returned.", "examples": ["; a = np.array([[1, 2], [3, np.nan]])\n; np.nanmin(a)\n1.0\n; np.nanmin(a, axis=0)\narray([1.,  2.])\n; np.nanmin(a, axis=1)\narray([1.,  3.])\n\n", "; a = np.array([[1, 2], [3, np.nan]])\n; np.nanmin(a)\n1.0\n; np.nanmin(a, axis=0)\narray([1.,  2.])\n; np.nanmin(a, axis=1)\narray([1.,  3.])\n", "; np.nanmin([1, 2, np.nan, np.inf])\n1.0\n; np.nanmin([1, 2, np.nan, np.NINF])\n-inf\n\n", "; np.nanmin([1, 2, np.nan, np.inf])\n1.0\n; np.nanmin([1, 2, np.nan, np.NINF])\n-inf\n"]},
{"library": "numpy", "item_id": "numpy.nanmedian", "code": "\nnumpy.nanmedian(a, axis=None, out=None, overwrite_input=False, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the median along the specified axis, while ignoring NaNs.\nReturns the median of the array elements.\n\nNew in version 1.9.0.\n\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\naxis{int, sequence of int, None}, optionalAxis or axes along which the medians are computed. The default\nis to compute the median along a flattened version of the array.\nA sequence of axes is supported since version 1.9.0.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow use of memory of input array a for\ncalculations. The input array will be modified by the call to\nmedian. This will save memory when you do not need to preserve\nthe contents of the input array. Treat the input as undefined,\nbut it will probably be fully or partially sorted. Default is\nFalse. If overwrite_input is True and a is not already an\nndarray, an error will be raised.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf this is anything but the default value it will be passed\nthrough (in the special case of an empty array) to the\nmean function of the underlying array.  If the array is\na sub-class and mean does not have the kwarg keepdims this\nwill raise a RuntimeError.\n\n\n\nReturns\n\nmedianndarrayA new array holding the result. If the input contains integers\nor floats smaller than float64, then the output data-type is\nnp.float64.  Otherwise, the data-type of the output is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nmean, median, percentile\n\nNotes\nGiven a vector V of length N, the median of V is the\nmiddle value of a sorted copy of V, V_sorted - i.e.,\nV_sorted[(N-1)/2], when N is odd and the average of the two\nmiddle values of V_sorted when N is even.\nExamples\n&gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])\n&gt;&gt;&gt; a[0, 1] = np.nan\n&gt;&gt;&gt; a\narray([[10., nan,  4.],\n       [ 3.,  2.,  1.]])\n&gt;&gt;&gt; np.median(a)\nnan\n&gt;&gt;&gt; np.nanmedian(a)\n3.0\n&gt;&gt;&gt; np.nanmedian(a, axis=0)\narray([6.5, 2. , 2.5])\n&gt;&gt;&gt; np.median(a, axis=1)\narray([nan,  2.])\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n&gt;&gt;&gt; assert not np.all(a==b)\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)\n3.0\n&gt;&gt;&gt; assert not np.all(a==b)\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, sequence of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "keepdimsbool, optional", "Returns", "medianndarray"], "returns": "medianndarrayA new array holding the result. If the input contains integersor floats smaller than float64, then the output data-type isnp.float64.  Otherwise, the data-type of the output is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10.0, 7, 4], [3, 2, 1]])\n; a[0, 1] = np.nan\n; a\narray([[10., nan,  4.],\n       [ 3.,  2.,  1.]])\n; np.median(a)\nnan\n; np.nanmedian(a)\n3.0\n; np.nanmedian(a, axis=0)\narray([6.5, 2. , 2.5])\n; np.median(a, axis=1)\narray([nan,  2.])\n; b = a.copy()\n; np.nanmedian(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a==b)\n; b = a.copy()\n; np.nanmedian(b, axis=None, overwrite_input=True)\n3.0\n; assert not np.all(a==b)\n\n", "; a = np.array([[10.0, 7, 4], [3, 2, 1]])\n; a[0, 1] = np.nan\n; a\narray([[10., nan,  4.],\n       [ 3.,  2.,  1.]])\n; np.median(a)\nnan\n; np.nanmedian(a)\n3.0\n; np.nanmedian(a, axis=0)\narray([6.5, 2. , 2.5])\n; np.median(a, axis=1)\narray([nan,  2.])\n; b = a.copy()\n; np.nanmedian(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a==b)\n; b = a.copy()\n; np.nanmedian(b, axis=None, overwrite_input=True)\n3.0\n; assert not np.all(a==b)\n"]},
{"library": "numpy", "item_id": "numpy.nanmean", "code": "\nnumpy.nanmean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the arithmetic mean along the specified axis, ignoring NaNs.\nReturns the average of the array elements.  The average is taken over\nthe flattened array by default, otherwise over the specified axis.\nfloat64 intermediate and return values are used for integer inputs.\nFor all-NaN slices, NaN is returned and a RuntimeWarning is raised.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeArray containing numbers whose mean is desired. If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the means are computed. The default is to compute\nthe mean of the flattened array.\n\ndtypedata-type, optionalType to use in computing the mean.  For integer inputs, the default\nis float64; for inexact inputs, it is the same as the input\ndtype.\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None; if provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary. See\nufuncs-output-type for more details.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf the value is anything but the default, then\nkeepdims will be passed through to the mean or sum methods\nof sub-classes of ndarray.  If the sub-classes methods\ndoes not implement keepdims any exceptions will be raised.\n\n\n\nReturns\n\nmndarray, see dtype parameter aboveIf out=None, returns a new array containing the mean values,\notherwise a reference to the output array is returned. Nan is\nreturned for slices that contain only NaNs.\n\n\n\n\n\nSee also\n\naverageWeighted average\n\nmeanArithmetic mean taken while not ignoring NaNs\n\n\nvar, nanvar\n\nNotes\nThe arithmetic mean is the sum of the non-NaN elements along the axis\ndivided by the number of non-NaN elements.\nNote that for floating-point input, the mean is computed using the same\nprecision the input has.  Depending on the input data, this can cause\nthe results to be inaccurate, especially for float32.  Specifying a\nhigher-precision accumulator using the dtype keyword can alleviate\nthis issue.\nExamples\n&gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])\n&gt;&gt;&gt; np.nanmean(a)\n2.6666666666666665\n&gt;&gt;&gt; np.nanmean(a, axis=0)\narray([2.,  4.])\n&gt;&gt;&gt; np.nanmean(a, axis=1)\narray([1.,  3.5]) # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "dtypedata-type, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "mndarray, see dtype parameter above"], "returns": "mndarray, see dtype parameter aboveIf out=None, returns a new array containing the mean values,otherwise a reference to the output array is returned. Nan isreturned for slices that contain only NaNs.", "examples": ["; a = np.array([[1, np.nan], [3, 4]])\n; np.nanmean(a)\n2.6666666666666665\n; np.nanmean(a, axis=0)\narray([2.,  4.])\n; np.nanmean(a, axis=1)\narray([1.,  3.5]) # may vary\n\n", "; a = np.array([[1, np.nan], [3, 4]])\n; np.nanmean(a)\n2.6666666666666665\n; np.nanmean(a, axis=0)\narray([2.,  4.])\n; np.nanmean(a, axis=1)\narray([1.,  3.5]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.nanmax", "code": "\nnumpy.nanmax(a, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the maximum of an array or maximum along an axis, ignoring any\nNaNs.  When all-NaN slices are encountered a RuntimeWarning is\nraised and NaN is returned for that slice.\n\nParameters\n\naarray_likeArray containing numbers whose maximum is desired. If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the maximum is computed. The default is to compute\nthe maximum of the flattened array.\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None; if provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary. See\nufuncs-output-type for more details.\n\nNew in version 1.8.0.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf the value is anything but the default, then\nkeepdims will be passed through to the max method\nof sub-classes of ndarray.  If the sub-classes methods\ndoes not implement keepdims any exceptions will be raised.\n\nNew in version 1.8.0.\n\n\n\n\nReturns\n\nnanmaxndarrayAn array with the same shape as a, with the specified axis removed.\nIf a is a 0-d array, or if axis is None, an ndarray scalar is\nreturned.  The same dtype as a is returned.\n\n\n\n\n\nSee also\n\nnanminThe minimum value of an array along a given axis, ignoring any NaNs.\n\namaxThe maximum value of an array along a given axis, propagating any NaNs.\n\nfmaxElement-wise maximum of two arrays, ignoring any NaNs.\n\nmaximumElement-wise maximum of two arrays, propagating any NaNs.\n\nisnanShows which elements are Not a Number (NaN).\n\nisfiniteShows which elements are neither NaN nor infinity.\n\n\namin, fmin, minimum\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nPositive infinity is treated as a very large number and negative\ninfinity is treated as a very small (i.e. negative) number.\nIf the input has a integer type the function is equivalent to np.max.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])\n&gt;&gt;&gt; np.nanmax(a)\n3.0\n&gt;&gt;&gt; np.nanmax(a, axis=0)\narray([3.,  2.])\n&gt;&gt;&gt; np.nanmax(a, axis=1)\narray([2.,  3.])\n\n\nWhen positive infinity and negative infinity are present:\n&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])\n2.0\n&gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])\ninf\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "nanmaxndarray"], "returns": "nanmaxndarrayAn array with the same shape as a, with the specified axis removed.If a is a 0-d array, or if axis is None, an ndarray scalar isreturned.  The same dtype as a is returned.", "examples": ["; a = np.array([[1, 2], [3, np.nan]])\n; np.nanmax(a)\n3.0\n; np.nanmax(a, axis=0)\narray([3.,  2.])\n; np.nanmax(a, axis=1)\narray([2.,  3.])\n\n", "; a = np.array([[1, 2], [3, np.nan]])\n; np.nanmax(a)\n3.0\n; np.nanmax(a, axis=0)\narray([3.,  2.])\n; np.nanmax(a, axis=1)\narray([2.,  3.])\n", "; np.nanmax([1, 2, np.nan, np.NINF])\n2.0\n; np.nanmax([1, 2, np.nan, np.inf])\ninf\n\n", "; np.nanmax([1, 2, np.nan, np.NINF])\n2.0\n; np.nanmax([1, 2, np.nan, np.inf])\ninf\n"]},
{"library": "numpy", "item_id": "numpy.nansum", "code": "\nnumpy.nansum(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero.\nIn NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or\nempty. In later versions zero is returned.\n\nParameters\n\naarray_likeArray containing numbers whose sum is desired. If a is not an\narray, a conversion is attempted.\n\naxis{int, tuple of int, None}, optionalAxis or axes along which the sum is computed. The default is to compute the\nsum of the flattened array.\n\ndtypedata-type, optionalThe type of the returned array and of the accumulator in which the\nelements are summed.  By default, the dtype of a is used.  An\nexception is when a has an integer type with less precision than\nthe platform (u)intp. In that case, the default will be either\n(u)int32 or (u)int64 depending on whether the platform is 32 or 64\nbits. For inexact inputs, dtype must be inexact.\n\nNew in version 1.8.0.\n\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None. If provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary.  See\nufuncs-output-type for more details. The casting of NaN to integer\ncan yield unexpected results.\n\nNew in version 1.8.0.\n\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original a.\nIf the value is anything but the default, then\nkeepdims will be passed through to the mean or sum methods\nof sub-classes of ndarray.  If the sub-classes methods\ndoes not implement keepdims any exceptions will be raised.\n\nNew in version 1.8.0.\n\n\n\n\nReturns\n\nnansumndarray.A new array holding the result is returned unless out is\nspecified, in which it is returned. The result has the same\nsize as a, and the same shape as a if axis is not None\nor a is a 1-d array.\n\n\n\n\n\nSee also\n\nnumpy.sumSum across array propagating NaNs.\n\nisnanShow which elements are NaN.\n\nisfiniteShow which elements are not NaN or +/-inf.\n\n\n\nNotes\nIf both positive and negative infinity are present, the sum will be Not\nA Number (NaN).\nExamples\n&gt;&gt;&gt; np.nansum(1)\n1\n&gt;&gt;&gt; np.nansum([1])\n1\n&gt;&gt;&gt; np.nansum([1, np.nan])\n1.0\n&gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])\n&gt;&gt;&gt; np.nansum(a)\n3.0\n&gt;&gt;&gt; np.nansum(a, axis=0)\narray([2.,  1.])\n&gt;&gt;&gt; np.nansum([1, np.nan, np.inf])\ninf\n&gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])\n-inf\n&gt;&gt;&gt; from numpy.testing import suppress_warnings\n&gt;&gt;&gt; with suppress_warnings() as sup:\n...     sup.filter(RuntimeWarning)\n...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\nnan\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, tuple of int, None}, optional", "dtypedata-type, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "nansumndarray."], "returns": "nansumndarray.A new array holding the result is returned unless out isspecified, in which it is returned. The result has the samesize as a, and the same shape as a if axis is not Noneor a is a 1-d array.", "examples": ["; np.nansum(1)\n1\n; np.nansum([1])\n1\n; np.nansum([1, np.nan])\n1.0\n; a = np.array([[1, 1], [1, np.nan]])\n; np.nansum(a)\n3.0\n; np.nansum(a, axis=0)\narray([2.,  1.])\n; np.nansum([1, np.nan, np.inf])\ninf\n; np.nansum([1, np.nan, np.NINF])\n-inf\n; from numpy.testing import suppress_warnings\n; with suppress_warnings() as sup:\n...     sup.filter(RuntimeWarning)\n...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\nnan\n\n", "; np.nansum(1)\n1\n; np.nansum([1])\n1\n; np.nansum([1, np.nan])\n1.0\n; a = np.array([[1, 1], [1, np.nan]])\n; np.nansum(a)\n3.0\n; np.nansum(a, axis=0)\narray([2.,  1.])\n; np.nansum([1, np.nan, np.inf])\ninf\n; np.nansum([1, np.nan, np.NINF])\n-inf\n; from numpy.testing import suppress_warnings\n; with suppress_warnings() as sup:\n...     sup.filter(RuntimeWarning)\n...     np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present\nnan\n"]},
{"library": "numpy", "item_id": "numpy.nanargmax", "code": "\nnumpy.nanargmax(a, axis=None)[source]\u00b6", "description": "Return the indices of the maximum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the\nresults cannot be trusted if a slice contains only NaNs and -Infs.\n\nParameters\n\naarray_likeInput data.\n\naxisint, optionalAxis along which to operate.  By default flattened input is used.\n\n\n\nReturns\n\nindex_arrayndarrayAn array of indices or a single index value.\n\n\n\n\n\nSee also\nargmax, nanargmin\n\nExamples\n&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])\n&gt;&gt;&gt; np.argmax(a)\n0\n&gt;&gt;&gt; np.nanargmax(a)\n1\n&gt;&gt;&gt; np.nanargmax(a, axis=0)\narray([1, 0])\n&gt;&gt;&gt; np.nanargmax(a, axis=1)\narray([1, 1])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "Returns", "index_arrayndarray"], "returns": "index_arrayndarrayAn array of indices or a single index value.", "examples": ["; a = np.array([[np.nan, 4], [2, 3]])\n; np.argmax(a)\n0\n; np.nanargmax(a)\n1\n; np.nanargmax(a, axis=0)\narray([1, 0])\n; np.nanargmax(a, axis=1)\narray([1, 1])\n\n", "; a = np.array([[np.nan, 4], [2, 3]])\n; np.argmax(a)\n0\n; np.nanargmax(a)\n1\n; np.nanargmax(a, axis=0)\narray([1, 0])\n; np.nanargmax(a, axis=1)\narray([1, 1])\n"]},
{"library": "numpy", "item_id": "numpy.dtype.names", "code": "\ndtype.names\u00b6", "description": "Ordered list of field names, or None if there are no fields.\nThe names are ordered according to increasing byte offset. This can be\nused, for example, to walk through all of the named fields in offset order.\nExamples\n&gt;&gt;&gt; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n&gt;&gt;&gt; dt.names\n('name', 'grades')\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.names\n('name', 'grades')\n\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.names\n('name', 'grades')\n"]},
{"library": "numpy", "item_id": "numpy.nanargmin", "code": "\nnumpy.nanargmin(a, axis=None)[source]\u00b6", "description": "Return the indices of the minimum values in the specified axis ignoring\nNaNs. For all-NaN slices ValueError is raised. Warning: the results\ncannot be trusted if a slice contains only NaNs and Infs.\n\nParameters\n\naarray_likeInput data.\n\naxisint, optionalAxis along which to operate.  By default flattened input is used.\n\n\n\nReturns\n\nindex_arrayndarrayAn array of indices or a single index value.\n\n\n\n\n\nSee also\nargmin, nanargmax\n\nExamples\n&gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])\n&gt;&gt;&gt; np.argmin(a)\n0\n&gt;&gt;&gt; np.nanargmin(a)\n2\n&gt;&gt;&gt; np.nanargmin(a, axis=0)\narray([1, 1])\n&gt;&gt;&gt; np.nanargmin(a, axis=1)\narray([1, 0])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "Returns", "index_arrayndarray"], "returns": "index_arrayndarrayAn array of indices or a single index value.", "examples": ["; a = np.array([[np.nan, 4], [2, 3]])\n; np.argmin(a)\n0\n; np.nanargmin(a)\n2\n; np.nanargmin(a, axis=0)\narray([1, 1])\n; np.nanargmin(a, axis=1)\narray([1, 0])\n\n", "; a = np.array([[np.nan, 4], [2, 3]])\n; np.argmin(a)\n0\n; np.nanargmin(a)\n2\n; np.nanargmin(a, axis=0)\narray([1, 1])\n; np.nanargmin(a, axis=1)\narray([1, 0])\n"]},
{"library": "numpy", "item_id": "numpy.nan_to_num", "code": "\nnumpy.nan_to_num(x, copy=True, nan=0.0, posinf=None, neginf=None)[source]\u00b6", "description": "Replace NaN with zero and infinity with large finite numbers (default\nbehaviour) or with the numbers defined by the user using the nan, \nposinf and/or neginf keywords.\nIf x is inexact, NaN is replaced by zero or by the user defined value in\nnan keyword, infinity is replaced by the largest finite floating point \nvalues representable by x.dtype or by the user defined value in \nposinf keyword and -infinity is replaced by the most negative finite \nfloating point values representable by x.dtype or by the user defined \nvalue in neginf keyword.\nFor complex dtypes, the above is applied to each of the real and\nimaginary components of x separately.\nIf x is not inexact, then no replacements are made.\n\nParameters\n\nxscalar or array_likeInput data.\n\ncopybool, optionalWhether to create a copy of x (True) or to replace values\nin-place (False). The in-place operation only occurs if\ncasting to an array does not require a copy.\nDefault is True.\n\nNew in version 1.13.\n\n\nnanint, float, optionalValue to be used to fill NaN values. If no value is passed \nthen NaN values will be replaced with 0.0.\n\nNew in version 1.17.\n\n\nposinfint, float, optionalValue to be used to fill positive infinity values. If no value is \npassed then positive infinity values will be replaced with a very\nlarge number.\n\nNew in version 1.17.\n\n\nneginfint, float, optionalValue to be used to fill negative infinity values. If no value is \npassed then negative infinity values will be replaced with a very\nsmall (or negative) number.\n\nNew in version 1.17.\n\n\n\n\nReturns\n\noutndarrayx, with the non-finite values replaced. If copy is False, this may\nbe x itself.\n\n\n\n\n\nSee also\n\nisinfShows which elements are positive or negative infinity.\n\nisneginfShows which elements are negative infinity.\n\nisposinfShows which elements are positive infinity.\n\nisnanShows which elements are Not a Number (NaN).\n\nisfiniteShows which elements are finite (not NaN, not infinity)\n\n\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nExamples\n&gt;&gt;&gt; np.nan_to_num(np.inf)\n1.7976931348623157e+308\n&gt;&gt;&gt; np.nan_to_num(-np.inf)\n-1.7976931348623157e+308\n&gt;&gt;&gt; np.nan_to_num(np.nan)\n0.0\n&gt;&gt;&gt; x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n&gt;&gt;&gt; np.nan_to_num(x)\narray([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary\n       -1.28000000e+002,  1.28000000e+002])\n&gt;&gt;&gt; np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)\narray([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, \n       -1.2800000e+02,  1.2800000e+02])\n&gt;&gt;&gt; y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary\n     -1.28000000e+002,   1.28000000e+002])\n&gt;&gt;&gt; np.nan_to_num(y)\narray([  1.79769313e+308 +0.00000000e+000j, # may vary\n         0.00000000e+000 +0.00000000e+000j,\n         0.00000000e+000 +1.79769313e+308j])\n&gt;&gt;&gt; np.nan_to_num(y, nan=111111, posinf=222222)\narray([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])\n\n\n", "parameters": ["Parameters", "xscalar or array_like", "copybool, optional", "nanint, float, optional", "posinfint, float, optional", "neginfint, float, optional", "Returns", "outndarray"], "returns": "outndarrayx, with the non-finite values replaced. If copy is False, this maybe x itself.", "examples": ["; np.nan_to_num(np.inf)\n1.7976931348623157e+308\n; np.nan_to_num(-np.inf)\n-1.7976931348623157e+308\n; np.nan_to_num(np.nan)\n0.0\n; x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n; np.nan_to_num(x)\narray([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary\n       -1.28000000e+002,  1.28000000e+002])\n; np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)\narray([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, \n       -1.2800000e+02,  1.2800000e+02])\n; y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary\n     -1.28000000e+002,   1.28000000e+002])\n; np.nan_to_num(y)\narray([  1.79769313e+308 +0.00000000e+000j, # may vary\n         0.00000000e+000 +0.00000000e+000j,\n         0.00000000e+000 +1.79769313e+308j])\n; np.nan_to_num(y, nan=111111, posinf=222222)\narray([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])\n\n", "; np.nan_to_num(np.inf)\n1.7976931348623157e+308\n; np.nan_to_num(-np.inf)\n-1.7976931348623157e+308\n; np.nan_to_num(np.nan)\n0.0\n; x = np.array([np.inf, -np.inf, np.nan, -128, 128])\n; np.nan_to_num(x)\narray([ 1.79769313e+308, -1.79769313e+308,  0.00000000e+000, # may vary\n       -1.28000000e+002,  1.28000000e+002])\n; np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333)\narray([ 3.3333333e+07,  3.3333333e+07, -9.9990000e+03, \n       -1.2800000e+02,  1.2800000e+02])\n; y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)])\narray([  1.79769313e+308,  -1.79769313e+308,   0.00000000e+000, # may vary\n     -1.28000000e+002,   1.28000000e+002])\n; np.nan_to_num(y)\narray([  1.79769313e+308 +0.00000000e+000j, # may vary\n         0.00000000e+000 +0.00000000e+000j,\n         0.00000000e+000 +1.79769313e+308j])\n; np.nan_to_num(y, nan=111111, posinf=222222)\narray([222222.+111111.j, 111111.     +0.j, 111111.+222222.j])\n"]},
{"library": "numpy", "item_id": "numpy.dtype.name", "code": "\ndtype.name\u00b6", "description": "A bit-width name for this data-type.\nUn-sized flexible data-type objects do not have this attribute.\nExamples\n&gt;&gt;&gt; x = np.dtype(float)\n&gt;&gt;&gt; x.name\n'float64'\n&gt;&gt;&gt; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n&gt;&gt;&gt; x.name\n'void640'\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype(float)\n; x.name\n'float64'\n; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n; x.name\n'void640'\n\n", "; x = np.dtype(float)\n; x.name\n'float64'\n; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n; x.name\n'void640'\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.n_children_spawned", "code": "\nSeedSequence.n_children_spawned\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.multivariate_normal", "code": "\nGenerator.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)\u00b6", "description": "Draw random samples from a multivariate normal distribution.\nThe multivariate normal, multinormal or Gaussian distribution is a\ngeneralization of the one-dimensional normal distribution to higher\ndimensions.  Such a distribution is specified by its mean and\ncovariance matrix.  These parameters are analogous to the mean\n(average or \u201ccenter\u201d) and variance (standard deviation, or \u201cwidth,\u201d\nsquared) of the one-dimensional normal distribution.\n\nParameters\n\nmean1-D array_like, of length NMean of the N-dimensional distribution.\n\ncov2-D array_like, of shape (N, N)Covariance matrix of the distribution. It must be symmetric and\npositive-semidefinite for proper sampling.\n\nsizeint or tuple of ints, optionalGiven a shape of, for example, (m,n,k), m*n*k samples are\ngenerated, and packed in an m-by-n-by-k arrangement.  Because\neach sample is N-dimensional, the output shape is (m,n,k,N).\nIf no shape is specified, a single (N-D) sample is returned.\n\ncheck_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optionalBehavior when the covariance matrix is not positive semidefinite.\n\ntolfloat, optionalTolerance when checking the singular values in covariance matrix.\ncov is cast to double before the check.\n\nmethod{ \u2018svd\u2019, \u2018eigh\u2019, \u2018cholesky\u2019}, optionalThe cov input is used to compute a factor matrix A such that\nA @ A.T = cov. This argument is used to select the method\nused to compute the factor matrix A. The default method \u2018svd\u2019 is\nthe slowest, while \u2018cholesky\u2019 is the fastest but less robust than\nthe slowest method. The method eigh uses eigen decomposition to\ncompute A and is faster than svd but slower than cholesky.\n\nNew in version 1.18.0.\n\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\nNotes\nThe mean is a coordinate in N-dimensional space, which represents the\nlocation where samples are most likely to be generated.  This is\nanalogous to the peak of the bell curve for the one-dimensional or\nunivariate normal distribution.\nCovariance indicates the level to which two variables vary together.\nFrom the multivariate normal distribution, we draw N-dimensional\nsamples, .  The covariance matrix\nelement  is the covariance of  and .\nThe element  is the variance of  (i.e. its\n\u201cspread\u201d).\nInstead of specifying the full covariance matrix, popular\napproximations include:\n\n\nSpherical covariance (cov is a multiple of the identity matrix)\nDiagonal covariance (cov has non-negative elements, and only on\nthe diagonal)\n\n\nThis geometrical property can be seen in two dimensions by plotting\ngenerated data-points:\n&gt;&gt;&gt; mean = [0, 0]\n&gt;&gt;&gt; cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n\nDiagonal covariance means that points are oriented along x or y-axis:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x, y = np.random.default_rng().multivariate_normal(mean, cov, 5000).T\n&gt;&gt;&gt; plt.plot(x, y, 'x')\n&gt;&gt;&gt; plt.axis('equal')\n&gt;&gt;&gt; plt.show()\n\n\nNote that the covariance matrix must be positive semidefinite (a.k.a.\nnonnegative-definite). Otherwise, the behavior of this method is\nundefined and backwards compatibility is not guaranteed.\nReferences\n\n1\nPapoulis, A., \u201cProbability, Random Variables, and Stochastic\nProcesses,\u201d 3rd ed., New York: McGraw-Hill, 1991.\n\n2\nDuda, R. O., Hart, P. E., and Stork, D. G., \u201cPattern\nClassification,\u201d 2nd ed., New York: Wiley, 2001.\n\n\nExamples\n&gt;&gt;&gt; mean = (1, 2)\n&gt;&gt;&gt; cov = [[1, 0], [0, 1]]\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; x = rng.multivariate_normal(mean, cov, (3, 3))\n&gt;&gt;&gt; x.shape\n(3, 3, 2)\n\n\nWe can use a different method other than the default to factorize cov:\n&gt;&gt;&gt; y = rng.multivariate_normal(mean, cov, (3, 3), method=\u2019cholesky\u2019)\n&gt;&gt;&gt; y.shape\n(3, 3, 2)\nThe following is probably true, given that 0.6 is roughly twice the\nstandard deviation:\n&gt;&gt;&gt; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n\n", "parameters": ["Parameters", "mean1-D array_like, of length N", "cov2-D array_like, of shape (N, N)", "sizeint or tuple of ints, optional", "check_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optional", "tolfloat, optional", "method{ \u2018svd\u2019, \u2018eigh\u2019, \u2018cholesky\u2019}, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; rng = np.random.default_rng()\n; x = rng.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n\n", "; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; rng = np.random.default_rng()\n; x = rng.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n"]},
{"library": "numpy", "item_id": "numpy.char.multiply", "code": "\nnumpy.char.multiply(a, i)\u00b6", "description": "Return (a * i), that is string multiple concatenation,\nelement-wise.\nValues in i of less than 0 are treated as 0 (which yields an\nempty string).\n\nParameters\n\naarray_like of str or unicode\niarray_like of ints\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input types\n\n\n\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "iarray_like of ints", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input types", "examples": []},
{"library": "numpy", "item_id": "numpy.random.multivariate_normal", "code": "\nnumpy.random.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)\u00b6", "description": "Draw random samples from a multivariate normal distribution.\nThe multivariate normal, multinormal or Gaussian distribution is a\ngeneralization of the one-dimensional normal distribution to higher\ndimensions.  Such a distribution is specified by its mean and\ncovariance matrix.  These parameters are analogous to the mean\n(average or \u201ccenter\u201d) and variance (standard deviation, or \u201cwidth,\u201d\nsquared) of the one-dimensional normal distribution.\n\nNote\nNew code should use the multivariate_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmean1-D array_like, of length NMean of the N-dimensional distribution.\n\ncov2-D array_like, of shape (N, N)Covariance matrix of the distribution. It must be symmetric and\npositive-semidefinite for proper sampling.\n\nsizeint or tuple of ints, optionalGiven a shape of, for example, (m,n,k), m*n*k samples are\ngenerated, and packed in an m-by-n-by-k arrangement.  Because\neach sample is N-dimensional, the output shape is (m,n,k,N).\nIf no shape is specified, a single (N-D) sample is returned.\n\ncheck_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optionalBehavior when the covariance matrix is not positive semidefinite.\n\ntolfloat, optionalTolerance when checking the singular values in covariance matrix.\ncov is cast to double before the check.\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\n\nSee also\n\nGenerator.multivariate_normalwhich should be used for new code.\n\n\n\nNotes\nThe mean is a coordinate in N-dimensional space, which represents the\nlocation where samples are most likely to be generated.  This is\nanalogous to the peak of the bell curve for the one-dimensional or\nunivariate normal distribution.\nCovariance indicates the level to which two variables vary together.\nFrom the multivariate normal distribution, we draw N-dimensional\nsamples, .  The covariance matrix\nelement  is the covariance of  and .\nThe element  is the variance of  (i.e. its\n\u201cspread\u201d).\nInstead of specifying the full covariance matrix, popular\napproximations include:\n\n\nSpherical covariance (cov is a multiple of the identity matrix)\nDiagonal covariance (cov has non-negative elements, and only on\nthe diagonal)\n\n\nThis geometrical property can be seen in two dimensions by plotting\ngenerated data-points:\n&gt;&gt;&gt; mean = [0, 0]\n&gt;&gt;&gt; cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n\nDiagonal covariance means that points are oriented along x or y-axis:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x, y = np.random.multivariate_normal(mean, cov, 5000).T\n&gt;&gt;&gt; plt.plot(x, y, 'x')\n&gt;&gt;&gt; plt.axis('equal')\n&gt;&gt;&gt; plt.show()\n\n\nNote that the covariance matrix must be positive semidefinite (a.k.a.\nnonnegative-definite). Otherwise, the behavior of this method is\nundefined and backwards compatibility is not guaranteed.\nReferences\n\n1\nPapoulis, A., \u201cProbability, Random Variables, and Stochastic\nProcesses,\u201d 3rd ed., New York: McGraw-Hill, 1991.\n\n2\nDuda, R. O., Hart, P. E., and Stork, D. G., \u201cPattern\nClassification,\u201d 2nd ed., New York: Wiley, 2001.\n\n\nExamples\n&gt;&gt;&gt; mean = (1, 2)\n&gt;&gt;&gt; cov = [[1, 0], [0, 1]]\n&gt;&gt;&gt; x = np.random.multivariate_normal(mean, cov, (3, 3))\n&gt;&gt;&gt; x.shape\n(3, 3, 2)\n\n\nThe following is probably true, given that 0.6 is roughly twice the\nstandard deviation:\n&gt;&gt;&gt; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n\n", "parameters": ["Parameters", "mean1-D array_like, of length N", "cov2-D array_like, of shape (N, N)", "sizeint or tuple of ints, optional", "check_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optional", "tolfloat, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; x = np.random.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n\n", "; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; x = np.random.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n"]},
{"library": "numpy", "item_id": "numpy.multiply", "code": "\nnumpy.multiply(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'multiply'&gt;\u00b6", "description": "Multiply arguments element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays to be multiplied. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe product of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\nEquivalent to x1 * x2 in terms of array broadcasting.\nExamples\n&gt;&gt;&gt; np.multiply(2.0, 4.0)\n8.0\n\n\n&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))\n&gt;&gt;&gt; x2 = np.arange(3.0)\n&gt;&gt;&gt; np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe product of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.multiply(2.0, 4.0)\n8.0\n\n", "; np.multiply(2.0, 4.0)\n8.0\n", "; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])\n\n", "; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.multiply(x1, x2)\narray([[  0.,   1.,   4.],\n       [  0.,   4.,  10.],\n       [  0.,   7.,  16.]])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.multivariate_hypergeometric", "code": "\nGenerator.multivariate_hypergeometric(colors, nsample, size=None, method='marginals')\u00b6", "description": "Generate variates from a multivariate hypergeometric distribution.\nThe multivariate hypergeometric distribution is a generalization\nof the hypergeometric distribution.\nChoose nsample items at random without replacement from a\ncollection with N distinct types.  N is the length of\ncolors, and the values in colors are the number of occurrences\nof that type in the collection.  The total number of items in the\ncollection is sum(colors).  Each random variate generated by this\nfunction is a vector of length N holding the counts of the\ndifferent types that occurred in the nsample items.\nThe name colors comes from a common description of the\ndistribution: it is the probability distribution of the number of\nmarbles of each color selected without replacement from an urn\ncontaining marbles of different colors; colors[i] is the number\nof marbles in the urn with color i.\n\nParameters\n\ncolorssequence of integersThe number of each type of item in the collection from which\na sample is drawn.  The values in colors must be nonnegative.\nTo avoid loss of precision in the algorithm, sum(colors)\nmust be less than 10**9 when method is \u201cmarginals\u201d.\n\nnsampleintThe number of items selected.  nsample must not be greater\nthan sum(colors).\n\nsizeint or tuple of ints, optionalThe number of variates to generate, either an integer or a tuple\nholding the shape of the array of variates.  If the given size is,\ne.g., (k, m), then k * m variates are drawn, where one\nvariate is a vector of length len(colors), and the return value\nhas shape (k, m, len(colors)).  If size is an integer, the\noutput has shape (size, len(colors)).  Default is None, in\nwhich case a single variate is returned as an array with shape\n(len(colors),).\n\nmethodstring, optionalSpecify the algorithm that is used to generate the variates.\nMust be \u2018count\u2019 or \u2018marginals\u2019 (the default).  See the Notes\nfor a description of the methods.\n\n\n\nReturns\n\nvariatesndarrayArray of variates drawn from the multivariate hypergeometric\ndistribution.\n\n\n\n\n\nSee also\n\nhypergeometricDraw samples from the (univariate) hypergeometric distribution.\n\n\n\nNotes\nThe two methods do not return the same sequence of variates.\nThe \u201ccount\u201d algorithm is roughly equivalent to the following numpy\ncode:\nchoices = np.repeat(np.arange(len(colors)), colors)\nselection = np.random.choice(choices, nsample, replace=False)\nvariate = np.bincount(selection, minlength=len(colors))\n\n\nThe \u201ccount\u201d algorithm uses a temporary array of integers with length\nsum(colors).\nThe \u201cmarginals\u201d algorithm generates a variate by using repeated\ncalls to the univariate hypergeometric sampler.  It is roughly\nequivalent to:\nvariate = np.zeros(len(colors), dtype=np.int64)\n# `remaining` is the cumulative sum of `colors` from the last\n# element to the first; e.g. if `colors` is [3, 1, 5], then\n# `remaining` is [9, 6, 5].\nremaining = np.cumsum(colors[::-1])[::-1]\nfor i in range(len(colors)-1):\n    if nsample &lt; 1:\n        break\n    variate[i] = hypergeometric(colors[i], remaining[i+1],\n                               nsample)\n    nsample -= variate[i]\nvariate[-1] = nsample\n\n\nThe default method is \u201cmarginals\u201d.  For some cases (e.g. when\ncolors contains relatively small integers), the \u201ccount\u201d method\ncan be significantly faster than the \u201cmarginals\u201d method.  If\nperformance of the algorithm is important, test the two methods\nwith typical inputs to decide which works best.\n\nNew in version 1.18.0.\n\nExamples\n&gt;&gt;&gt; colors = [16, 8, 4]\n&gt;&gt;&gt; seed = 4861946401452\n&gt;&gt;&gt; gen = np.random.Generator(np.random.PCG64(seed))\n&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6)\narray([5, 0, 1])\n&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6, size=3)\narray([[5, 0, 1],\n       [2, 2, 2],\n       [3, 3, 0]])\n&gt;&gt;&gt; gen.multivariate_hypergeometric(colors, 6, size=(2, 2))\narray([[[3, 2, 1],\n        [3, 2, 1]],\n       [[4, 1, 1],\n        [3, 2, 1]]])\n\n\n", "parameters": ["Parameters", "colorssequence of integers", "nsampleint", "sizeint or tuple of ints, optional", "methodstring, optional", "Returns", "variatesndarray"], "returns": "variatesndarrayArray of variates drawn from the multivariate hypergeometricdistribution.", "examples": ["; colors = [16, 8, 4]\n; seed = 4861946401452\n; gen = np.random.Generator(np.random.PCG64(seed))\n; gen.multivariate_hypergeometric(colors, 6)\narray([5, 0, 1])\n; gen.multivariate_hypergeometric(colors, 6, size=3)\narray([[5, 0, 1],\n       [2, 2, 2],\n       [3, 3, 0]])\n; gen.multivariate_hypergeometric(colors, 6, size=(2, 2))\narray([[[3, 2, 1],\n        [3, 2, 1]],\n       [[4, 1, 1],\n        [3, 2, 1]]])\n\n", "; colors = [16, 8, 4]\n; seed = 4861946401452\n; gen = np.random.Generator(np.random.PCG64(seed))\n; gen.multivariate_hypergeometric(colors, 6)\narray([5, 0, 1])\n; gen.multivariate_hypergeometric(colors, 6, size=3)\narray([[5, 0, 1],\n       [2, 2, 2],\n       [3, 3, 0]])\n; gen.multivariate_hypergeometric(colors, 6, size=(2, 2))\narray([[[3, 2, 1],\n        [3, 2, 1]],\n       [[4, 1, 1],\n        [3, 2, 1]]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.multivariate_normal", "code": "\nRandomState.multivariate_normal(mean, cov, size=None, check_valid='warn', tol=1e-8)\u00b6", "description": "Draw random samples from a multivariate normal distribution.\nThe multivariate normal, multinormal or Gaussian distribution is a\ngeneralization of the one-dimensional normal distribution to higher\ndimensions.  Such a distribution is specified by its mean and\ncovariance matrix.  These parameters are analogous to the mean\n(average or \u201ccenter\u201d) and variance (standard deviation, or \u201cwidth,\u201d\nsquared) of the one-dimensional normal distribution.\n\nNote\nNew code should use the multivariate_normal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmean1-D array_like, of length NMean of the N-dimensional distribution.\n\ncov2-D array_like, of shape (N, N)Covariance matrix of the distribution. It must be symmetric and\npositive-semidefinite for proper sampling.\n\nsizeint or tuple of ints, optionalGiven a shape of, for example, (m,n,k), m*n*k samples are\ngenerated, and packed in an m-by-n-by-k arrangement.  Because\neach sample is N-dimensional, the output shape is (m,n,k,N).\nIf no shape is specified, a single (N-D) sample is returned.\n\ncheck_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optionalBehavior when the covariance matrix is not positive semidefinite.\n\ntolfloat, optionalTolerance when checking the singular values in covariance matrix.\ncov is cast to double before the check.\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\n\nSee also\n\nGenerator.multivariate_normalwhich should be used for new code.\n\n\n\nNotes\nThe mean is a coordinate in N-dimensional space, which represents the\nlocation where samples are most likely to be generated.  This is\nanalogous to the peak of the bell curve for the one-dimensional or\nunivariate normal distribution.\nCovariance indicates the level to which two variables vary together.\nFrom the multivariate normal distribution, we draw N-dimensional\nsamples, .  The covariance matrix\nelement  is the covariance of  and .\nThe element  is the variance of  (i.e. its\n\u201cspread\u201d).\nInstead of specifying the full covariance matrix, popular\napproximations include:\n\n\nSpherical covariance (cov is a multiple of the identity matrix)\nDiagonal covariance (cov has non-negative elements, and only on\nthe diagonal)\n\n\nThis geometrical property can be seen in two dimensions by plotting\ngenerated data-points:\n&gt;&gt;&gt; mean = [0, 0]\n&gt;&gt;&gt; cov = [[1, 0], [0, 100]]  # diagonal covariance\n\n\nDiagonal covariance means that points are oriented along x or y-axis:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x, y = np.random.multivariate_normal(mean, cov, 5000).T\n&gt;&gt;&gt; plt.plot(x, y, 'x')\n&gt;&gt;&gt; plt.axis('equal')\n&gt;&gt;&gt; plt.show()\n\n\nNote that the covariance matrix must be positive semidefinite (a.k.a.\nnonnegative-definite). Otherwise, the behavior of this method is\nundefined and backwards compatibility is not guaranteed.\nReferences\n\n1\nPapoulis, A., \u201cProbability, Random Variables, and Stochastic\nProcesses,\u201d 3rd ed., New York: McGraw-Hill, 1991.\n\n2\nDuda, R. O., Hart, P. E., and Stork, D. G., \u201cPattern\nClassification,\u201d 2nd ed., New York: Wiley, 2001.\n\n\nExamples\n&gt;&gt;&gt; mean = (1, 2)\n&gt;&gt;&gt; cov = [[1, 0], [0, 1]]\n&gt;&gt;&gt; x = np.random.multivariate_normal(mean, cov, (3, 3))\n&gt;&gt;&gt; x.shape\n(3, 3, 2)\n\n\nThe following is probably true, given that 0.6 is roughly twice the\nstandard deviation:\n&gt;&gt;&gt; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n\n", "parameters": ["Parameters", "mean1-D array_like, of length N", "cov2-D array_like, of shape (N, N)", "sizeint or tuple of ints, optional", "check_valid{ \u2018warn\u2019, \u2018raise\u2019, \u2018ignore\u2019 }, optional", "tolfloat, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; x = np.random.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n\n", "; mean = (1, 2)\n; cov = [[1, 0], [0, 1]]\n; x = np.random.multivariate_normal(mean, cov, (3, 3))\n; x.shape\n(3, 3, 2)\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n\n", "; list((x[0,0,:] - mean) &lt; 0.6)\n[True, True] # random\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.multinomial", "code": "\nRandomState.multinomial(n, pvals, size=None)\u00b6", "description": "Draw samples from a multinomial distribution.\nThe multinomial distribution is a multivariate generalization of the\nbinomial distribution.  Take an experiment with one of p\npossible outcomes.  An example of such an experiment is throwing a dice,\nwhere the outcome can be 1 through 6.  Each sample drawn from the\ndistribution represents n such experiments.  Its values,\nX_i = [X_0, X_1, ..., X_p], represent the number of times the\noutcome was i.\n\nNote\nNew code should use the multinomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnintNumber of experiments.\n\npvalssequence of floats, length pProbabilities of each of the p different outcomes.  These\nmust sum to 1 (however, the last element is always assumed to\naccount for the remaining probability, as long as\nsum(pvals[:-1]) &lt;= 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\n\nSee also\n\nGenerator.multinomialwhich should be used for new code.\n\n\n\nExamples\nThrow a dice 20 times:\n&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n\n\nIt landed 4 times on 1, once on 2, etc.\nNow, throw the dice 20 times, and 20 times again:\n&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n\n\nFor the first run, we threw 3 times 1, 4 times 2, etc.  For the second,\nwe threw 2 times 1, 4 times 2, etc.\nA loaded die is more likely to land on number 6:\n&gt;&gt;&gt; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n\n\nThe probability inputs should be normalized. As an implementation\ndetail, the value of the last entry is ignored and assumed to take\nup any leftover probability mass, but this should not be relied on.\nA biased coin which has twice as much weight on one side as on the\nother should be sampled like so:\n&gt;&gt;&gt; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n\n\nnot like:\n&gt;&gt;&gt; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n\n", "parameters": ["Parameters", "nint", "pvalssequence of floats, length p", "sizeint or tuple of ints, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n\n", "; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n", "; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n\n", "; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n", "; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n\n", "; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n", "; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n\n", "; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n", "; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n", "; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.multinomial", "code": "\nGenerator.multinomial(n, pvals, size=None)\u00b6", "description": "Draw samples from a multinomial distribution.\nThe multinomial distribution is a multivariate generalization of the\nbinomial distribution.  Take an experiment with one of p\npossible outcomes.  An example of such an experiment is throwing a dice,\nwhere the outcome can be 1 through 6.  Each sample drawn from the\ndistribution represents n such experiments.  Its values,\nX_i = [X_0, X_1, ..., X_p], represent the number of times the\noutcome was i.\n\nParameters\n\nnint or array-like of intsNumber of experiments.\n\npvalssequence of floats, length pProbabilities of each of the p different outcomes.  These\nmust sum to 1 (however, the last element is always assumed to\naccount for the remaining probability, as long as\nsum(pvals[:-1]) &lt;= 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\nExamples\nThrow a dice 20 times:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])  # random\n\n\nIt landed 4 times on 1, once on 2, etc.\nNow, throw the dice 20 times, and 20 times again:\n&gt;&gt;&gt; rng.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3],\n       [2, 4, 3, 4, 0, 7]])  # random\n\n\nFor the first run, we threw 3 times 1, 4 times 2, etc.  For the second,\nwe threw 2 times 1, 4 times 2, etc.\nNow, do one experiment throwing the dice 10 time, and 10 times again,\nand another throwing the dice 20 times, and 20 times again:\n&gt;&gt;&gt; rng.multinomial([[10], [20]], [1/6.]*6, size=2)\narray([[[2, 4, 0, 1, 2, 1],\n        [1, 3, 0, 3, 1, 2]],\n       [[1, 4, 4, 4, 4, 3],\n        [3, 3, 2, 5, 5, 2]]])  # random\n\n\nThe first array shows the outcomes of throwing the dice 10 times, and\nthe second shows the outcomes from throwing the dice 20 times.\nA loaded die is more likely to land on number 6:\n&gt;&gt;&gt; rng.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26])  # random\n\n\nThe probability inputs should be normalized. As an implementation\ndetail, the value of the last entry is ignored and assumed to take\nup any leftover probability mass, but this should not be relied on.\nA biased coin which has twice as much weight on one side as on the\nother should be sampled like so:\n&gt;&gt;&gt; rng.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62])  # random\n\n\nnot like:\n&gt;&gt;&gt; rng.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n\n", "parameters": ["Parameters", "nint or array-like of ints", "pvalssequence of floats, length p", "sizeint or tuple of ints, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; rng = np.random.default_rng()\n; rng.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])  # random\n\n", "; rng = np.random.default_rng()\n; rng.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]])  # random\n", "; rng.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3],\n       [2, 4, 3, 4, 0, 7]])  # random\n\n", "; rng.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3],\n       [2, 4, 3, 4, 0, 7]])  # random\n", "; rng.multinomial([[10], [20]], [1/6.]*6, size=2)\narray([[[2, 4, 0, 1, 2, 1],\n        [1, 3, 0, 3, 1, 2]],\n       [[1, 4, 4, 4, 4, 3],\n        [3, 3, 2, 5, 5, 2]]])  # random\n\n", "; rng.multinomial([[10], [20]], [1/6.]*6, size=2)\narray([[[2, 4, 0, 1, 2, 1],\n        [1, 3, 0, 3, 1, 2]],\n       [[1, 4, 4, 4, 4, 3],\n        [3, 3, 2, 5, 5, 2]]])  # random\n", "; rng.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26])  # random\n\n", "; rng.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26])  # random\n", "; rng.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62])  # random\n\n", "; rng.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62])  # random\n", "; rng.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n", "; rng.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n"]},
{"library": "numpy", "item_id": "numpy.random.multinomial", "code": "\nnumpy.random.multinomial(n, pvals, size=None)\u00b6", "description": "Draw samples from a multinomial distribution.\nThe multinomial distribution is a multivariate generalization of the\nbinomial distribution.  Take an experiment with one of p\npossible outcomes.  An example of such an experiment is throwing a dice,\nwhere the outcome can be 1 through 6.  Each sample drawn from the\ndistribution represents n such experiments.  Its values,\nX_i = [X_0, X_1, ..., X_p], represent the number of times the\noutcome was i.\n\nNote\nNew code should use the multinomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnintNumber of experiments.\n\npvalssequence of floats, length pProbabilities of each of the p different outcomes.  These\nmust sum to 1 (however, the last element is always assumed to\naccount for the remaining probability, as long as\nsum(pvals[:-1]) &lt;= 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\n\n\nReturns\n\noutndarrayThe drawn samples, of shape size, if that was provided.  If not,\nthe shape is (N,).\nIn other words, each entry out[i,j,...,:] is an N-dimensional\nvalue drawn from the distribution.\n\n\n\n\n\nSee also\n\nGenerator.multinomialwhich should be used for new code.\n\n\n\nExamples\nThrow a dice 20 times:\n&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n\n\nIt landed 4 times on 1, once on 2, etc.\nNow, throw the dice 20 times, and 20 times again:\n&gt;&gt;&gt; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n\n\nFor the first run, we threw 3 times 1, 4 times 2, etc.  For the second,\nwe threw 2 times 1, 4 times 2, etc.\nA loaded die is more likely to land on number 6:\n&gt;&gt;&gt; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n\n\nThe probability inputs should be normalized. As an implementation\ndetail, the value of the last entry is ignored and assumed to take\nup any leftover probability mass, but this should not be relied on.\nA biased coin which has twice as much weight on one side as on the\nother should be sampled like so:\n&gt;&gt;&gt; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n\n\nnot like:\n&gt;&gt;&gt; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n\n", "parameters": ["Parameters", "nint", "pvalssequence of floats, length p", "sizeint or tuple of ints, optional", "Returns", "outndarray"], "returns": "outndarrayThe drawn samples, of shape size, if that was provided.  If not,the shape is (N,).In other words, each entry out[i,j,...,:] is an N-dimensionalvalue drawn from the distribution.", "examples": ["; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n\n", "; np.random.multinomial(20, [1/6.]*6, size=1)\narray([[4, 1, 7, 5, 2, 1]]) # random\n", "; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n\n", "; np.random.multinomial(20, [1/6.]*6, size=2)\narray([[3, 4, 3, 3, 4, 3], # random\n       [2, 4, 3, 4, 0, 7]])\n", "; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n\n", "; np.random.multinomial(100, [1/7.]*5 + [2/7.])\narray([11, 16, 14, 17, 16, 26]) # random\n", "; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n\n", "; np.random.multinomial(100, [1.0 / 3, 2.0 / 3])  # RIGHT\narray([38, 62]) # random\n", "; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n\n", "; np.random.multinomial(100, [1.0, 2.0])  # WRONG\nTraceback (most recent call last):\nValueError: pvals &lt; 0, pvals &gt; 1 or pvals contains NaNs\n"]},
{"library": "numpy", "item_id": "numpy.nditer.multi_index", "code": "\nnditer.multi_index\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.multi_dot", "code": "\nnumpy.linalg.multi_dot(arrays)[source]\u00b6", "description": "Compute the dot product of two or more arrays in a single function call,\nwhile automatically selecting the fastest evaluation order.\nmulti_dot chains numpy.dot and uses optimal parenthesization\nof the matrices [1] [2]. Depending on the shapes of the matrices,\nthis can speed up the multiplication a lot.\nIf the first argument is 1-D it is treated as a row vector.\nIf the last argument is 1-D it is treated as a column vector.\nThe other arguments must be 2-D.\nThink of multi_dot as:\ndef multi_dot(arrays): return functools.reduce(np.dot, arrays)\n\n\n\nParameters\n\narrayssequence of array_likeIf the first argument is 1-D it is treated as row vector.\nIf the last argument is 1-D it is treated as column vector.\nThe other arguments must be 2-D.\n\n\n\nReturns\n\noutputndarrayReturns the dot product of the supplied arrays.\n\n\n\n\n\nSee also\n\ndotdot multiplication with two arguments.\n\n\n\nNotes\nThe cost for a matrix multiplication can be calculated with the\nfollowing function:\ndef cost(A, B):\n    return A.shape[0] * A.shape[1] * B.shape[1]\n\n\nAssume we have three matrices\n.\nThe costs for the two different parenthesizations are as follows:\ncost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500\ncost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000\n\n\nReferences\n\n1\nCormen, \u201cIntroduction to Algorithms\u201d, Chapter 15.2, p. 370-378\n\n2\nhttps://en.wikipedia.org/wiki/Matrix_chain_multiplication\n\n\nExamples\nmulti_dot allows you to write:\n&gt;&gt;&gt; from numpy.linalg import multi_dot\n&gt;&gt;&gt; # Prepare some data\n&gt;&gt;&gt; A = np.random.random((10000, 100))\n&gt;&gt;&gt; B = np.random.random((100, 1000))\n&gt;&gt;&gt; C = np.random.random((1000, 5))\n&gt;&gt;&gt; D = np.random.random((5, 333))\n&gt;&gt;&gt; # the actual dot multiplication\n&gt;&gt;&gt; _ = multi_dot([A, B, C, D])\n\n\ninstead of:\n&gt;&gt;&gt; _ = np.dot(np.dot(np.dot(A, B), C), D)\n&gt;&gt;&gt; # or\n&gt;&gt;&gt; _ = A.dot(B).dot(C).dot(D)\n\n\n", "parameters": ["Parameters", "arrayssequence of array_like", "Returns", "outputndarray"], "returns": "outputndarrayReturns the dot product of the supplied arrays.", "examples": ["; from numpy.linalg import multi_dot\n; # Prepare some data\n; A = np.random.random((10000, 100))\n; B = np.random.random((100, 1000))\n; C = np.random.random((1000, 5))\n; D = np.random.random((5, 333))\n; # the actual dot multiplication\n; _ = multi_dot([A, B, C, D])\n\n", "; from numpy.linalg import multi_dot\n; # Prepare some data\n; A = np.random.random((10000, 100))\n; B = np.random.random((100, 1000))\n; C = np.random.random((1000, 5))\n; D = np.random.random((5, 333))\n; # the actual dot multiplication\n; _ = multi_dot([A, B, C, D])\n", "; _ = np.dot(np.dot(np.dot(A, B), C), D)\n; # or\n; _ = A.dot(B).dot(C).dot(D)\n\n", "; _ = np.dot(np.dot(np.dot(A, B), C), D)\n; # or\n; _ = A.dot(B).dot(C).dot(D)\n"]},
{"library": "numpy", "item_id": "numpy.random.MT19937", "code": "\nclass numpy.random.MT19937(seed=None)\u00b6", "description": "Container for the Mersenne Twister pseudo-random number generator.\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\nSeedSequence to derive the initial BitGenerator state. One may also\npass in a SeedSequence instance.\n\n\n\n\nNotes\nMT19937 provides a capsule containing function pointers that produce\ndoubles, and unsigned 32 and 64- bit integers [1]. These are not\ndirectly consumable in Python and must be consumed by a Generator\nor similar object that supports low-level access.\nThe Python stdlib module \u201crandom\u201d also contains a Mersenne Twister\npseudo-random number generator.\nState and Seeding\nThe MT19937 state vector consists of a 624-element array of\n32-bit unsigned integers plus a single integer value between 0 and 624\nthat indexes the current position within the main array.\nThe input seed is processed by SeedSequence to fill the whole state. The\nfirst element is reset such that only its most significant bit is set.\nParallel Features\nThe preferred way to use a BitGenerator in parallel applications is to use\nthe SeedSequence.spawn method to obtain entropy values, and to use these\nto generate new BitGenerators:\n&gt;&gt;&gt; from numpy.random import Generator, MT19937, SeedSequence\n&gt;&gt;&gt; sg = SeedSequence(1234)\n&gt;&gt;&gt; rg = [Generator(MT19937(s)) for s in sg.spawn(10)]\n\n\nAnother method is to use MT19937.jumped which advances the state as-if\n random numbers have been generated ([1], [2]). This\nallows the original sequence to be split so that distinct segments can be\nused in each worker process. All generators should be chained to ensure\nthat the segments come from the same sequence.\n&gt;&gt;&gt; from numpy.random import Generator, MT19937, SeedSequence\n&gt;&gt;&gt; sg = SeedSequence(1234)\n&gt;&gt;&gt; bit_generator = MT19937(sg)\n&gt;&gt;&gt; rg = []\n&gt;&gt;&gt; for _ in range(10):\n...    rg.append(Generator(bit_generator))\n...    # Chain the BitGenerators\n...    bit_generator = bit_generator.jumped()\n\n\nCompatibility Guarantee\nMT19937 makes a guarantee that a fixed seed and will always produce\nthe same random integer stream.\nReferences\n\n1(1,2)\nHiroshi Haramoto, Makoto Matsumoto, and Pierre L\u2019Ecuyer, \u201cA Fast\nJump Ahead Algorithm for Linear Recurrences in a Polynomial Space\u201d,\nSequences and Their Applications - SETA, 290\u2013298, 2008.\n\n2\nHiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran\u00e7ois\nPanneton, Pierre L\u2019Ecuyer, \u201cEfficient Jump Ahead for F2-Linear\nRandom Number Generators\u201d, INFORMS JOURNAL ON COMPUTING, Vol. 20,\nNo. 3, Summer 2008, pp. 385-390.\n\n\n\nAttributes\n\nlock: threading.LockLock instance that is shared so that the same bit git generator can\nbe used in multiple Generators without corrupting the state. Code that\ngenerates values from a bit generator should hold the bit generator\u2019s\nlock.\n\n\n\n\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence}, optional", "Attributes", "lock: threading.Lock"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.msort", "code": "\nnumpy.msort(a)[source]\u00b6", "description": "Return a copy of an array sorted along the first axis.\n\nParameters\n\naarray_likeArray to be sorted.\n\n\n\nReturns\n\nsorted_arrayndarrayArray of the same type and shape as a.\n\n\n\n\n\nSee also\nsort\n\nNotes\nnp.msort(a) is equivalent to  np.sort(a, axis=0).\n", "parameters": ["Parameters", "aarray_like", "Returns", "sorted_arrayndarray"], "returns": "sorted_arrayndarrayArray of the same type and shape as a.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.mr_", "code": "\nnumpy.ma.mr_ = &lt;numpy.ma.extras.mr_class object&gt;\u00b6", "description": "Translate slice objects to concatenation along the first axis.\nThis is the masked array version of lib.index_tricks.RClass.\n\nSee also\nlib.index_tricks.RClass\n\nExamples\n&gt;&gt;&gt; np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\nmasked_array(data=[1, 2, 3, ..., 4, 5, 6],\n             mask=False,\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\nmasked_array(data=[1, 2, 3, ..., 4, 5, 6],\n             mask=False,\n       fill_value=999999)\n\n", "; np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]\nmasked_array(data=[1, 2, 3, ..., 4, 5, 6],\n             mask=False,\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.moveaxis", "code": "\nnumpy.moveaxis(a, source, destination)[source]\u00b6", "description": "Move axes of an array to new positions.\nOther axes remain in their original order.\n\nNew in version 1.11.0.\n\n\nParameters\n\nanp.ndarrayThe array whose axes should be reordered.\n\nsourceint or sequence of intOriginal positions of the axes to move. These must be unique.\n\ndestinationint or sequence of intDestination positions for each of the original axes. These must also be\nunique.\n\n\n\nReturns\n\nresultnp.ndarrayArray with moved axes. This array is a view of the input array.\n\n\n\n\n\nSee also\n\ntransposePermute the dimensions of an array.\n\nswapaxesInterchange two axes of an array.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.zeros((3, 4, 5))\n&gt;&gt;&gt; np.moveaxis(x, 0, -1).shape\n(4, 5, 3)\n&gt;&gt;&gt; np.moveaxis(x, -1, 0).shape\n(5, 3, 4)\n\n\nThese all achieve the same result:\n&gt;&gt;&gt; np.transpose(x).shape\n(5, 4, 3)\n&gt;&gt;&gt; np.swapaxes(x, 0, -1).shape\n(5, 4, 3)\n&gt;&gt;&gt; np.moveaxis(x, [0, 1], [-1, -2]).shape\n(5, 4, 3)\n&gt;&gt;&gt; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n(5, 4, 3)\n\n\n", "parameters": ["Parameters", "anp.ndarray", "sourceint or sequence of int", "destinationint or sequence of int", "Returns", "resultnp.ndarray"], "returns": "resultnp.ndarrayArray with moved axes. This array is a view of the input array.", "examples": ["; x = np.zeros((3, 4, 5))\n; np.moveaxis(x, 0, -1).shape\n(4, 5, 3)\n; np.moveaxis(x, -1, 0).shape\n(5, 3, 4)\n\n", "; x = np.zeros((3, 4, 5))\n; np.moveaxis(x, 0, -1).shape\n(4, 5, 3)\n; np.moveaxis(x, -1, 0).shape\n(5, 3, 4)\n", "; np.transpose(x).shape\n(5, 4, 3)\n; np.swapaxes(x, 0, -1).shape\n(5, 4, 3)\n; np.moveaxis(x, [0, 1], [-1, -2]).shape\n(5, 4, 3)\n; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n(5, 4, 3)\n\n", "; np.transpose(x).shape\n(5, 4, 3)\n; np.swapaxes(x, 0, -1).shape\n(5, 4, 3)\n; np.moveaxis(x, [0, 1], [-1, -2]).shape\n(5, 4, 3)\n; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape\n(5, 4, 3)\n"]},
{"library": "numpy", "item_id": "numpy.modf", "code": "\nnumpy.modf(x, [out1, out2, ]/, [out=(None, None), ]*, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'modf'&gt;\u00b6", "description": "Return the fractional and integral parts of an array, element-wise.\nThe fractional and integral parts are negative if the given number is\nnegative.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\ny1ndarrayFractional part of x.\nThis is a scalar if x is a scalar.\n\ny2ndarrayIntegral part of x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\ndivmoddivmod(x, 1) is equivalent to modf with the return values switched, except it always has a positive remainder.\n\n\n\nNotes\nFor integer input the return values are floats.\nExamples\n&gt;&gt;&gt; np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n&gt;&gt;&gt; np.modf(-0.5)\n(-0.5, -0)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "y1ndarray", "y2ndarray"], "returns": "y1ndarrayFractional part of x.This is a scalar if x is a scalar.y2ndarrayIntegral part of x.This is a scalar if x is a scalar.", "examples": ["; np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n; np.modf(-0.5)\n(-0.5, -0)\n\n", "; np.modf([0, 3.5])\n(array([ 0. ,  0.5]), array([ 0.,  3.]))\n; np.modf(-0.5)\n(-0.5, -0)\n"]},
{"library": "numpy", "item_id": "numpy.char.mod", "code": "\nnumpy.char.mod(a, values)\u00b6", "description": "Return (a % i), that is pre-Python 2.6 string formatting\n(iterpolation), element-wise for a pair of array_likes of str\nor unicode.\n\nParameters\n\naarray_like of str or unicode\nvaluesarray_like of valuesThese values will be element-wise interpolated into the string.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input types\n\n\n\n\n\nSee also\nstr.__mod__\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "valuesarray_like of values", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input types", "examples": []},
{"library": "numpy", "item_id": "numpy.mod", "code": "\nnumpy.mod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'remainder'&gt;\u00b6", "description": "Return element-wise remainder of division.\nComputes the remainder complementary to the floor_divide function.  It is\nequivalent to the Python modulus operator``x1 % x2`` and has the same sign\nas the divisor x2. The MATLAB function equivalent to np.remainder\nis mod.\n\nWarning\nThis should not be confused with:\n\nPython 3.7\u2019s math.remainder and C\u2019s remainder, which\ncomputes the IEEE remainder, which are the complement to\nround(x1 / x2).\nThe MATLAB rem function and or the C % operator which is the\ncomplement to int(x1 / x2).\n\n\n\nParameters\n\nx1array_likeDividend array.\n\nx2array_likeDivisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe element-wise remainder of the quotient floor_divide(x1, x2).\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfloor_divideEquivalent of Python // operator.\n\ndivmodSimultaneous floor division and remainder.\n\nfmodEquivalent of the MATLAB rem function.\n\n\ndivide, floor\n\nNotes\nReturns 0 when x2 is 0 and both x1 and x2 are (arrays of)\nintegers.\nmod is an alias of remainder.\nExamples\n&gt;&gt;&gt; np.remainder([4, 7], [2, 3])\narray([0, 1])\n&gt;&gt;&gt; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe element-wise remainder of the quotient floor_divide(x1, x2).This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.remainder([4, 7], [2, 3])\narray([0, 1])\n; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n\n", "; np.remainder([4, 7], [2, 3])\narray([0, 1])\n; np.remainder(np.arange(7), 5)\narray([0, 1, 2, 3, 4, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.mirr", "code": "\nnumpy.mirr(values, finance_rate, reinvest_rate)[source]\u00b6", "description": "Modified internal rate of return.\n\nDeprecated since version 1.18: mirr is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nParameters\n\nvaluesarray_likeCash flows (must contain at least one positive and one negative\nvalue) or nan is returned.  The first value is considered a sunk\ncost at time zero.\n\nfinance_ratescalarInterest rate paid on the cash flows\n\nreinvest_ratescalarInterest rate received on the cash flows upon reinvestment\n\n\n\nReturns\n\noutfloatModified internal rate of return\n\n\n\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n\n", "parameters": ["Parameters", "valuesarray_like", "finance_ratescalar", "reinvest_ratescalar", "Returns", "outfloat"], "returns": "outfloatModified internal rate of return", "examples": []},
{"library": "numpy", "item_id": "numpy.mintypecode", "code": "\nnumpy.mintypecode(typechars, typeset='GDFgdf', default='d')[source]\u00b6", "description": "Return the character for the minimum-size type to which given types can\nbe safely cast.\nThe returned type character must represent the smallest size dtype such\nthat an array of the returned type can handle the data from an array of\nall types in typechars (or if typechars is an array, then its\ndtype.char).\n\nParameters\n\ntypecharslist of str or array_likeIf a list of strings, each string should represent a dtype.\nIf array_like, the character representation of the array dtype is used.\n\ntypesetstr or list of str, optionalThe set of characters that the returned character is chosen from.\nThe default set is \u2018GDFgdf\u2019.\n\ndefaultstr, optionalThe default character, this is returned if none of the characters in\ntypechars matches a character in typeset.\n\n\n\nReturns\n\ntypecharstrThe character representing the minimum-size type that was found.\n\n\n\n\n\nSee also\ndtype, sctype2char, maximum_sctype\n\nExamples\n&gt;&gt;&gt; np.mintypecode(['d', 'f', 'S'])\n'd'\n&gt;&gt;&gt; x = np.array([1.1, 2-3.j])\n&gt;&gt;&gt; np.mintypecode(x)\n'D'\n\n\n&gt;&gt;&gt; np.mintypecode('abceh', default='G')\n'G'\n\n\n", "parameters": ["Parameters", "typecharslist of str or array_like", "typesetstr or list of str, optional", "defaultstr, optional", "Returns", "typecharstr"], "returns": "typecharstrThe character representing the minimum-size type that was found.", "examples": ["; np.mintypecode(['d', 'f', 'S'])\n'd'\n; x = np.array([1.1, 2-3.j])\n; np.mintypecode(x)\n'D'\n\n", "; np.mintypecode(['d', 'f', 'S'])\n'd'\n; x = np.array([1.1, 2-3.j])\n; np.mintypecode(x)\n'D'\n", "; np.mintypecode('abceh', default='G')\n'G'\n\n", "; np.mintypecode('abceh', default='G')\n'G'\n"]},
{"library": "numpy", "item_id": "numpy.minimum", "code": "\nnumpy.minimum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'minimum'&gt;\u00b6", "description": "Element-wise minimum of array elements.\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n\nx1, x2array_likeThe arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe minimum of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nmaximumElement-wise maximum of two arrays, propagates NaNs.\n\nfminElement-wise minimum of two arrays, ignores NaNs.\n\naminThe minimum value of an array along a given axis, propagates NaNs.\n\nnanminThe minimum value of an array along a given axis, ignores NaNs.\n\n\nfmax, amax, nanmax\n\nNotes\nThe minimum is equivalent to np.where(x1 &lt;= x2, x1, x2) when\nneither x1 nor x2 are NaNs, but it is faster and does proper\nbroadcasting.\nExamples\n&gt;&gt;&gt; np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n\n&gt;&gt;&gt; np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n\n&gt;&gt;&gt; np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n&gt;&gt;&gt; np.minimum(-np.Inf, 1)\n-inf\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe minimum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n", "; np.minimum([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n", "; np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n", "; np.minimum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n", "; np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n; np.minimum(-np.Inf, 1)\n-inf\n\n", "; np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([nan, nan, nan])\n; np.minimum(-np.Inf, 1)\n-inf\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.mini", "code": "\nmasked_array.mini(self, axis=None)[source]\u00b6", "description": "Return the array minimum along the specified axis.\n\nDeprecated since version 1.13.0: This function is identical to both:\n\n\nself.min(keepdims=True, axis=axis).squeeze(axis=axis)\nnp.ma.minimum.reduce(self, axis=axis)\n\n\nTypically though, self.min(axis=axis) is sufficient.\n\n\nParameters\n\naxisint, optionalThe axis along which to find the minima. Default is None, in which case\nthe minimum value in the whole array is returned.\n\n\n\nReturns\n\nminscalar or MaskedArrayIf axis is None, the result is a scalar. Otherwise, if axis is\ngiven and the array is at least 2-D, the result is a masked array with\ndimension one smaller than the array on which mini is called.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[0, --],\n        [2, 3],\n        [4, --]],\n  mask=[[False,  True],\n        [False, False],\n        [False,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; x.mini()\nmasked_array(data=0,\n             mask=False,\n       fill_value=999999)\n&gt;&gt;&gt; x.mini(axis=0)\nmasked_array(data=[0, 3],\n             mask=[False, False],\n       fill_value=999999)\n&gt;&gt;&gt; x.mini(axis=1)\nmasked_array(data=[0, 2, 4],\n             mask=[False, False, False],\n       fill_value=999999)\n\n\nThere is a small difference between mini and min:\n&gt;&gt;&gt; x[:,1].mini(axis=0)\nmasked_array(data=3,\n             mask=False,\n       fill_value=999999)\n&gt;&gt;&gt; x[:,1].min(axis=0)\n3\n\n\n", "parameters": ["Parameters", "axisint, optional", "Returns", "minscalar or MaskedArray"], "returns": "minscalar or MaskedArrayIf axis is None, the result is a scalar. Otherwise, if axis isgiven and the array is at least 2-D, the result is a masked array withdimension one smaller than the array on which mini is called.", "examples": ["; x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n; x\nmasked_array(\n  data=[[0, --],\n        [2, 3],\n        [4, --]],\n  mask=[[False,  True],\n        [False, False],\n        [False,  True]],\n  fill_value=999999)\n; x.mini()\nmasked_array(data=0,\n             mask=False,\n       fill_value=999999)\n; x.mini(axis=0)\nmasked_array(data=[0, 3],\n             mask=[False, False],\n       fill_value=999999)\n; x.mini(axis=1)\nmasked_array(data=[0, 2, 4],\n             mask=[False, False, False],\n       fill_value=999999)\n\n", "; x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)\n; x\nmasked_array(\n  data=[[0, --],\n        [2, 3],\n        [4, --]],\n  mask=[[False,  True],\n        [False, False],\n        [False,  True]],\n  fill_value=999999)\n; x.mini()\nmasked_array(data=0,\n             mask=False,\n       fill_value=999999)\n; x.mini(axis=0)\nmasked_array(data=[0, 3],\n             mask=[False, False],\n       fill_value=999999)\n; x.mini(axis=1)\nmasked_array(data=[0, 2, 4],\n             mask=[False, False, False],\n       fill_value=999999)\n", "; x[:,1].mini(axis=0)\nmasked_array(data=3,\n             mask=False,\n       fill_value=999999)\n; x[:,1].min(axis=0)\n3\n\n", "; x[:,1].mini(axis=0)\nmasked_array(data=3,\n             mask=False,\n       fill_value=999999)\n; x[:,1].min(axis=0)\n3\n"]},
{"library": "numpy", "item_id": "numpy.min_scalar_type", "code": "\nnumpy.min_scalar_type(a)\u00b6", "description": "For scalar a, returns the data type with the smallest size\nand smallest scalar kind which can hold its value.  For non-scalar\narray a, returns the vector\u2019s dtype unmodified.\nFloating point values are not demoted to integers,\nand complex values are not demoted to floats.\n\nParameters\n\nascalar or array_likeThe value whose minimal data type is to be found.\n\n\n\nReturns\n\noutdtypeThe minimal data type.\n\n\n\n\n\nSee also\nresult_type, promote_types, dtype, can_cast\n\nNotes\n\nNew in version 1.6.0.\n\nExamples\n&gt;&gt;&gt; np.min_scalar_type(10)\ndtype('uint8')\n\n\n&gt;&gt;&gt; np.min_scalar_type(-260)\ndtype('int16')\n\n\n&gt;&gt;&gt; np.min_scalar_type(3.1)\ndtype('float16')\n\n\n&gt;&gt;&gt; np.min_scalar_type(1e50)\ndtype('float64')\n\n\n&gt;&gt;&gt; np.min_scalar_type(np.arange(4,dtype='f8'))\ndtype('float64')\n\n\n", "parameters": ["Parameters", "ascalar or array_like", "Returns", "outdtype"], "returns": "outdtypeThe minimal data type.", "examples": ["; np.min_scalar_type(10)\ndtype('uint8')\n\n", "; np.min_scalar_type(10)\ndtype('uint8')\n", "; np.min_scalar_type(-260)\ndtype('int16')\n\n", "; np.min_scalar_type(-260)\ndtype('int16')\n", "; np.min_scalar_type(3.1)\ndtype('float16')\n\n", "; np.min_scalar_type(3.1)\ndtype('float16')\n", "; np.min_scalar_type(1e50)\ndtype('float64')\n\n", "; np.min_scalar_type(1e50)\ndtype('float64')\n", "; np.min_scalar_type(np.arange(4,dtype='f8'))\ndtype('float64')\n\n", "; np.min_scalar_type(np.arange(4,dtype='f8'))\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.record.min", "code": "\nrecord.min()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.min", "code": "\nrecarray.min(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the minimum along a given axis.\nRefer to numpy.amin for full documentation.\n\nSee also\n\nnumpy.aminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.min", "code": "\nndarray.min(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the minimum along a given axis.\nRefer to numpy.amin for full documentation.\n\nSee also\n\nnumpy.aminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.min", "code": "\nmemmap.min(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the minimum along a given axis.\nRefer to numpy.amin for full documentation.\n\nSee also\n\nnumpy.aminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.min", "code": "\nmatrix.min(self, axis=None, out=None)[source]\u00b6", "description": "Return the minimum value along an axis.\n\nParameters\n\nSee `amin` for complete descriptions.\n\n\n\n\nSee also\namin, ndarray.min\n\nNotes\nThis is the same as ndarray.min, but returns a matrix object\nwhere ndarray.min would return an ndarray.\nExamples\n&gt;&gt;&gt; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n&gt;&gt;&gt; x.min()\n-11\n&gt;&gt;&gt; x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n&gt;&gt;&gt; x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])\n\n\n", "parameters": ["Parameters", "See `amin` for complete descriptions."], "returns": [], "examples": ["; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n; x.min()\n-11\n; x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n; x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])\n\n", "; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n; x.min()\n-11\n; x.min(0)\nmatrix([[ -8,  -9, -10, -11]])\n; x.min(1)\nmatrix([[ -3],\n        [ -7],\n        [-11]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.min", "code": "\nMaskType.min()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.min", "code": "\nMaskedArray.min(self, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the minimum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of minimum_fill_value.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\naminarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nminimum_fill_valueReturns the minimum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "aminarray_like"], "returns": "aminarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.min", "code": "\nmasked_array.min(self, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the minimum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of minimum_fill_value.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\naminarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nminimum_fill_valueReturns the minimum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "aminarray_like"], "returns": "aminarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.iinfo.min", "code": "\nproperty iinfo.min\u00b6", "description": "Minimum value of given dtype.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.min", "code": "\ngeneric.min()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.min", "code": "\nchararray.min(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the minimum along a given axis.\nRefer to numpy.amin for full documentation.\n\nSee also\n\nnumpy.aminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.metadata", "code": "\ndtype.metadata\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.meshgrid", "code": "\nnumpy.meshgrid(*xi, **kwargs)[source]\u00b6", "description": "Return coordinate matrices from coordinate vectors.\nMake N-D coordinate arrays for vectorized evaluations of\nN-D scalar/vector fields over N-D grids, given\none-dimensional coordinate arrays x1, x2,\u2026, xn.\n\nChanged in version 1.9: 1-D and 0-D cases are allowed.\n\n\nParameters\n\nx1, x2,\u2026, xnarray_like1-D arrays representing the coordinates of a grid.\n\nindexing{\u2018xy\u2019, \u2018ij\u2019}, optionalCartesian (\u2018xy\u2019, default) or matrix (\u2018ij\u2019) indexing of output.\nSee Notes for more details.\n\nNew in version 1.7.0.\n\n\nsparsebool, optionalIf True a sparse grid is returned in order to conserve memory.\nDefault is False.\n\nNew in version 1.7.0.\n\n\ncopybool, optionalIf False, a view into the original arrays are returned in order to\nconserve memory.  Default is True.  Please note that\nsparse=False, copy=False will likely return non-contiguous\narrays.  Furthermore, more than one element of a broadcast array\nmay refer to a single memory location.  If you need to write to the\narrays, make copies first.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nX1, X2,\u2026, XNndarrayFor vectors x1, x2,\u2026, \u2018xn\u2019 with lengths Ni=len(xi) ,\nreturn (N1, N2, N3,...Nn) shaped arrays if indexing=\u2019ij\u2019\nor (N2, N1, N3,...Nn) shaped arrays if indexing=\u2019xy\u2019\nwith the elements of xi repeated to fill the matrix along\nthe first dimension for x1, the second for x2 and so on.\n\n\n\n\n\nSee also\n\nindex_tricks.mgridConstruct a multi-dimensional \u201cmeshgrid\u201d using indexing notation.\n\nindex_tricks.ogridConstruct an open multi-dimensional \u201cmeshgrid\u201d using indexing notation.\n\n\n\nNotes\nThis function supports both indexing conventions through the indexing\nkeyword argument.  Giving the string \u2018ij\u2019 returns a meshgrid with\nmatrix indexing, while \u2018xy\u2019 returns a meshgrid with Cartesian indexing.\nIn the 2-D case with inputs of length M and N, the outputs are of shape\n(N, M) for \u2018xy\u2019 indexing and (M, N) for \u2018ij\u2019 indexing.  In the 3-D case\nwith inputs of length M, N and P, outputs are of shape (N, M, P) for\n\u2018xy\u2019 indexing and (M, N, P) for \u2018ij\u2019 indexing.  The difference is\nillustrated by the following code snippet:\nxv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[i,j], yv[i,j]\n\nxv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')\nfor i in range(nx):\n    for j in range(ny):\n        # treat xv[j,i], yv[j,i]\n\n\nIn the 1-D and 0-D case, the indexing and sparse keywords have no effect.\nExamples\n&gt;&gt;&gt; nx, ny = (3, 2)\n&gt;&gt;&gt; x = np.linspace(0, 1, nx)\n&gt;&gt;&gt; y = np.linspace(0, 1, ny)\n&gt;&gt;&gt; xv, yv = np.meshgrid(x, y)\n&gt;&gt;&gt; xv\narray([[0. , 0.5, 1. ],\n       [0. , 0.5, 1. ]])\n&gt;&gt;&gt; yv\narray([[0.,  0.,  0.],\n       [1.,  1.,  1.]])\n&gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays\n&gt;&gt;&gt; xv\narray([[0. ,  0.5,  1. ]])\n&gt;&gt;&gt; yv\narray([[0.],\n       [1.]])\n\n\nmeshgrid is very useful to evaluate functions on a grid.\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.arange(-5, 5, 0.1)\n&gt;&gt;&gt; y = np.arange(-5, 5, 0.1)\n&gt;&gt;&gt; xx, yy = np.meshgrid(x, y, sparse=True)\n&gt;&gt;&gt; z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)\n&gt;&gt;&gt; h = plt.contourf(x,y,z)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "x1, x2,\u2026, xnarray_like", "indexing{\u2018xy\u2019, \u2018ij\u2019}, optional", "sparsebool, optional", "copybool, optional", "Returns", "X1, X2,\u2026, XNndarray"], "returns": "X1, X2,\u2026, XNndarrayFor vectors x1, x2,\u2026, \u2018xn\u2019 with lengths Ni=len(xi) ,return (N1, N2, N3,...Nn) shaped arrays if indexing=\u2019ij\u2019or (N2, N1, N3,...Nn) shaped arrays if indexing=\u2019xy\u2019with the elements of xi repeated to fill the matrix alongthe first dimension for x1, the second for x2 and so on.", "examples": ["; nx, ny = (3, 2)\n; x = np.linspace(0, 1, nx)\n; y = np.linspace(0, 1, ny)\n; xv, yv = np.meshgrid(x, y)\n; xv\narray([[0. , 0.5, 1. ],\n       [0. , 0.5, 1. ]])\n; yv\narray([[0.,  0.,  0.],\n       [1.,  1.,  1.]])\n; xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays\n; xv\narray([[0. ,  0.5,  1. ]])\n; yv\narray([[0.],\n       [1.]])\n\n", "; nx, ny = (3, 2)\n; x = np.linspace(0, 1, nx)\n; y = np.linspace(0, 1, ny)\n; xv, yv = np.meshgrid(x, y)\n; xv\narray([[0. , 0.5, 1. ],\n       [0. , 0.5, 1. ]])\n; yv\narray([[0.,  0.,  0.],\n       [1.,  1.,  1.]])\n; xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays\n; xv\narray([[0. ,  0.5,  1. ]])\n; yv\narray([[0.],\n       [1.]])\n", "; import matplotlib.pyplot as plt\n; x = np.arange(-5, 5, 0.1)\n; y = np.arange(-5, 5, 0.1)\n; xx, yy = np.meshgrid(x, y, sparse=True)\n; z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)\n; h = plt.contourf(x,y,z)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; x = np.arange(-5, 5, 0.1)\n; y = np.arange(-5, 5, 0.1)\n; xx, yy = np.meshgrid(x, y, sparse=True)\n; z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)\n; h = plt.contourf(x,y,z)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.min", "code": "\nchararray.min(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the minimum along a given axis.\nRefer to numpy.amin for full documentation.\n\nSee also\n\nnumpy.aminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.min", "code": "\nnumpy.ma.min(obj, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the minimum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must be of\nthe same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of minimum_fill_value.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\naminarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nminimum_fill_valueReturns the minimum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "aminarray_like"], "returns": "aminarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.mgrid", "code": "\nnumpy.mgrid = &lt;numpy.lib.index_tricks.MGridClass object&gt;\u00b6", "description": "nd_grid instance which returns a dense multi-dimensional \u201cmeshgrid\u201d.\nAn instance of numpy.lib.index_tricks.nd_grid which returns an dense\n(or fleshed out) mesh-grid when indexed, so that each returned argument\nhas the same shape.  The dimensions and number of the output arrays are\nequal to the number of indexing dimensions.  If the step length is not a\ncomplex number, then the stop is not inclusive.\nHowever, if the step length is a complex number (e.g. 5j), then\nthe integer part of its magnitude is interpreted as specifying the\nnumber of points to create between the start and stop values, where\nthe stop value is inclusive.\n\nReturns\n\nmesh-grid `ndarrays` all of the same dimensions\n\n\n\n\nSee also\n\nnumpy.lib.index_tricks.nd_gridclass of ogrid and mgrid objects\n\nogridlike mgrid but returns open (not fleshed out) mesh grids\n\nr_array concatenator\n\n\n\nExamples\n&gt;&gt;&gt; np.mgrid[0:5,0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n&gt;&gt;&gt; np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n\n\n", "parameters": [], "returns": "mesh-grid `ndarrays` all of the same dimensions", "examples": ["; np.mgrid[0:5,0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n; np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n\n", "; np.mgrid[0:5,0:5]\narray([[[0, 0, 0, 0, 0],\n        [1, 1, 1, 1, 1],\n        [2, 2, 2, 2, 2],\n        [3, 3, 3, 3, 3],\n        [4, 4, 4, 4, 4]],\n       [[0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4],\n        [0, 1, 2, 3, 4]]])\n; np.mgrid[-1:1:5j]\narray([-1. , -0.5,  0. ,  0.5,  1. ])\n"]},
{"library": "numpy", "item_id": "numpy.memmap", "code": "\nclass numpy.memmap[source]\u00b6", "description": "Create a memory-map to an array stored in a binary file on disk.\nMemory-mapped files are used for accessing small segments of large files\non disk, without reading the entire file into memory.  NumPy\u2019s\nmemmap\u2019s are array-like objects.  This differs from Python\u2019s mmap\nmodule, which uses file-like objects.\nThis subclass of ndarray has some unpleasant interactions with\nsome operations, because it doesn\u2019t quite fit properly as a subclass.\nAn alternative to using this subclass is to create the mmap\nobject yourself, then create an ndarray with ndarray.__new__ directly,\npassing the object created in its \u2018buffer=\u2019 parameter.\nThis class may at some point be turned into a factory function\nwhich returns a view into an mmap buffer.\nDelete the memmap instance to close the memmap file.\n\nParameters\n\nfilenamestr, file-like object, or pathlib.Path instanceThe file name or file object to be used as the array data buffer.\n\ndtypedata-type, optionalThe data-type used to interpret the file contents.\nDefault is uint8.\n\nmode{\u2018r+\u2019, \u2018r\u2019, \u2018w+\u2019, \u2018c\u2019}, optionalThe file is opened in this mode:\n\n\n\n\n\n\n\u2018r\u2019\nOpen existing file for reading only.\n\n\u2018r+\u2019\nOpen existing file for reading and writing.\n\n\u2018w+\u2019\nCreate or overwrite existing file for reading and writing.\n\n\u2018c\u2019\nCopy-on-write: assignments affect data in memory, but\nchanges are not saved to disk.  The file on disk is\nread-only.\n\n\n\nDefault is \u2018r+\u2019.\n\noffsetint, optionalIn the file, array data starts at this offset. Since offset is\nmeasured in bytes, it should normally be a multiple of the byte-size\nof dtype. When mode != 'r', even positive offsets beyond end of\nfile are valid; The file will be extended to accommodate the\nadditional data. By default, memmap will start at the beginning of\nthe file, even if filename is a file pointer fp and\nfp.tell() != 0.\n\nshapetuple, optionalThe desired shape of the array. If mode == 'r' and the number\nof remaining bytes after offset is not a multiple of the byte-size\nof dtype, you must specify shape. By default, the returned array\nwill be 1-D with the number of elements determined by file size\nand data-type.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalSpecify the order of the ndarray memory layout:\nrow-major, C-style or column-major,\nFortran-style.  This only has an effect if the shape is\ngreater than 1-D.  The default order is \u2018C\u2019.\n\n\n\n\n\nSee also\n\nlib.format.open_memmapCreate or load a memory-mapped .npy file.\n\n\n\nNotes\nThe memmap object can be used anywhere an ndarray is accepted.\nGiven a memmap fp, isinstance(fp, numpy.ndarray) returns\nTrue.\nMemory-mapped files cannot be larger than 2GB on 32-bit systems.\nWhen a memmap causes a file to be created or extended beyond its\ncurrent size in the filesystem, the contents of the new part are\nunspecified. On systems with POSIX filesystem semantics, the extended\npart will be filled with zero bytes.\nExamples\n&gt;&gt;&gt; data = np.arange(12, dtype='float32')\n&gt;&gt;&gt; data.resize((3,4))\n\n\nThis example uses a temporary file so that doctest doesn\u2019t write\nfiles to your directory. You would use a \u2018normal\u2019 filename.\n&gt;&gt;&gt; from tempfile import mkdtemp\n&gt;&gt;&gt; import os.path as path\n&gt;&gt;&gt; filename = path.join(mkdtemp(), 'newfile.dat')\n\n\nCreate a memmap with dtype and shape that matches our data:\n&gt;&gt;&gt; fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n&gt;&gt;&gt; fp\nmemmap([[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]], dtype=float32)\n\n\nWrite data to memmap array:\n&gt;&gt;&gt; fp[:] = data[:]\n&gt;&gt;&gt; fp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n\n&gt;&gt;&gt; fp.filename == path.abspath(filename)\nTrue\n\n\nDeletion flushes memory changes to disk before removing the object:\n&gt;&gt;&gt; del fp\n\n\nLoad the memmap and verify data was stored:\n&gt;&gt;&gt; newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n&gt;&gt;&gt; newfp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n\nRead-only memmap:\n&gt;&gt;&gt; fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n&gt;&gt;&gt; fpr.flags.writeable\nFalse\n\n\nCopy-on-write memmap:\n&gt;&gt;&gt; fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n&gt;&gt;&gt; fpc.flags.writeable\nTrue\n\n\nIt\u2019s possible to assign to copy-on-write array, but values are only\nwritten into the memory copy of the array, and not written to disk:\n&gt;&gt;&gt; fpc\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n&gt;&gt;&gt; fpc[0,:] = 0\n&gt;&gt;&gt; fpc\nmemmap([[  0.,   0.,   0.,   0.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n\nFile on disk is unchanged:\n&gt;&gt;&gt; fpr\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n\nOffset into a memmap:\n&gt;&gt;&gt; fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n&gt;&gt;&gt; fpo\nmemmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n\n\n\nAttributes\n\nfilenamestr or pathlib.Path instancePath to the mapped file.\n\noffsetintOffset position in the file.\n\nmodestrFile mode.\n\n\n\n\nMethods\n\n\n\n\n\n\nflush(self)\nWrite any changes in the array to the file on disk.\n\n\n\n", "parameters": ["Parameters", "filenamestr, file-like object, or pathlib.Path instance", "dtypedata-type, optional", "mode{\u2018r+\u2019, \u2018r\u2019, \u2018w+\u2019, \u2018c\u2019}, optional", "offsetint, optional", "shapetuple, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Attributes", "filenamestr or pathlib.Path instance", "offsetint", "modestr"], "returns": [], "examples": ["; data = np.arange(12, dtype='float32')\n; data.resize((3,4))\n\n", "; data = np.arange(12, dtype='float32')\n; data.resize((3,4))\n", "; from tempfile import mkdtemp\n; import os.path as path\n; filename = path.join(mkdtemp(), 'newfile.dat')\n\n", "; from tempfile import mkdtemp\n; import os.path as path\n; filename = path.join(mkdtemp(), 'newfile.dat')\n", "; fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n; fp\nmemmap([[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]], dtype=float32)\n\n", "; fp = np.memmap(filename, dtype='float32', mode='w+', shape=(3,4))\n; fp\nmemmap([[0., 0., 0., 0.],\n        [0., 0., 0., 0.],\n        [0., 0., 0., 0.]], dtype=float32)\n", "; fp[:] = data[:]\n; fp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n", "; fp[:] = data[:]\n; fp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n", "; fp.filename == path.abspath(filename)\nTrue\n\n", "; fp.filename == path.abspath(filename)\nTrue\n", "; del fp\n\n", "; del fp\n", "; newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n; newfp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n", "; newfp = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n; newfp\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n", "; fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n; fpr.flags.writeable\nFalse\n\n", "; fpr = np.memmap(filename, dtype='float32', mode='r', shape=(3,4))\n; fpr.flags.writeable\nFalse\n", "; fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n; fpc.flags.writeable\nTrue\n\n", "; fpc = np.memmap(filename, dtype='float32', mode='c', shape=(3,4))\n; fpc.flags.writeable\nTrue\n", "; fpc\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n; fpc[0,:] = 0\n; fpc\nmemmap([[  0.,   0.,   0.,   0.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n", "; fpc\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n; fpc[0,:] = 0\n; fpc\nmemmap([[  0.,   0.,   0.,   0.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n", "; fpr\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n\n", "; fpr\nmemmap([[  0.,   1.,   2.,   3.],\n        [  4.,   5.,   6.,   7.],\n        [  8.,   9.,  10.,  11.]], dtype=float32)\n", "; fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n; fpo\nmemmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n\n", "; fpo = np.memmap(filename, dtype='float32', mode='r', offset=16)\n; fpo\nmemmap([  4.,   5.,   6.,   7.,   8.,   9.,  10.,  11.], dtype=float32)\n"]},
{"library": "numpy", "item_id": "numpy.ma.median", "code": "\nnumpy.ma.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)[source]\u00b6", "description": "Compute the median along the specified axis.\nReturns the median of the array elements.\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\naxisint, optionalAxis along which the medians are computed. The default (None) is\nto compute the median along a flattened version of the array.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow use of memory of input array (a) for\ncalculations. The input array will be modified by the call to\nmedian. This will save memory when you do not need to preserve\nthe contents of the input array. Treat the input as undefined,\nbut it will probably be fully or partially sorted. Default is\nFalse. Note that, if overwrite_input is True, and the input\nis not already an ndarray, an error will be raised.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\nmedianndarrayA new array holding the result is returned unless out is\nspecified, in which case a reference to out is returned.\nReturn data-type is float64 for integers and floats smaller than\nfloat64, or the input data-type, otherwise.\n\n\n\n\n\nSee also\nmean\n\nNotes\nGiven a vector V with N non masked values, the median of V\nis the middle value of a sorted copy of V (Vs) - i.e.\nVs[(N-1)/2], when N is odd, or {Vs[N/2 - 1] + Vs[N/2]}/2\nwhen N is even.\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n&gt;&gt;&gt; np.ma.median(x)\n1.5\n\n\n&gt;&gt;&gt; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n&gt;&gt;&gt; np.ma.median(x)\n2.5\n&gt;&gt;&gt; np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\n             mask=[False, False],\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "outndarray, optional", "overwrite_inputbool, optional", "keepdimsbool, optional", "Returns", "medianndarray"], "returns": "medianndarrayA new array holding the result is returned unless out isspecified, in which case a reference to out is returned.Return data-type is float64 for integers and floats smaller thanfloat64, or the input data-type, otherwise.", "examples": ["; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n; np.ma.median(x)\n1.5\n\n", "; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)\n; np.ma.median(x)\n1.5\n", "; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n; np.ma.median(x)\n2.5\n; np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\n             mask=[False, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)\n; np.ma.median(x)\n2.5\n; np.ma.median(x, axis=-1, overwrite_input=True)\nmasked_array(data=[2.0, 5.0],\n             mask=[False, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.median", "code": "\nnumpy.median(a, axis=None, out=None, overwrite_input=False, keepdims=False)[source]\u00b6", "description": "Compute the median along the specified axis.\nReturns the median of the array elements.\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\naxis{int, sequence of int, None}, optionalAxis or axes along which the medians are computed. The default\nis to compute the median along a flattened version of the array.\nA sequence of axes is supported since version 1.9.0.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output,\nbut the type (of the output) will be cast if necessary.\n\noverwrite_inputbool, optionalIf True, then allow use of memory of input array a for\ncalculations. The input array will be modified by the call to\nmedian. This will save memory when you do not need to preserve\nthe contents of the input array. Treat the input as undefined,\nbut it will probably be fully or partially sorted. Default is\nFalse. If overwrite_input is True and a is not already an\nndarray, an error will be raised.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the original arr.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\nmedianndarrayA new array holding the result. If the input contains integers\nor floats smaller than float64, then the output data-type is\nnp.float64.  Otherwise, the data-type of the output is the\nsame as that of the input. If out is specified, that array is\nreturned instead.\n\n\n\n\n\nSee also\nmean, percentile\n\nNotes\nGiven a vector V of length N, the median of V is the\nmiddle value of a sorted copy of V, V_sorted - i\ne., V_sorted[(N-1)/2], when N is odd, and the average of the\ntwo middle values of V_sorted when N is even.\nExamples\n&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])\n&gt;&gt;&gt; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n&gt;&gt;&gt; np.median(a)\n3.5\n&gt;&gt;&gt; np.median(a, axis=0)\narray([6.5, 4.5, 2.5])\n&gt;&gt;&gt; np.median(a, axis=1)\narray([7.,  2.])\n&gt;&gt;&gt; m = np.median(a, axis=0)\n&gt;&gt;&gt; out = np.zeros_like(m)\n&gt;&gt;&gt; np.median(a, axis=0, out=m)\narray([6.5,  4.5,  2.5])\n&gt;&gt;&gt; m\narray([6.5,  4.5,  2.5])\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.median(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n&gt;&gt;&gt; assert not np.all(a==b)\n&gt;&gt;&gt; b = a.copy()\n&gt;&gt;&gt; np.median(b, axis=None, overwrite_input=True)\n3.5\n&gt;&gt;&gt; assert not np.all(a==b)\n\n\n", "parameters": ["Parameters", "aarray_like", "axis{int, sequence of int, None}, optional", "outndarray, optional", "overwrite_inputbool, optional", "keepdimsbool, optional", "Returns", "medianndarray"], "returns": "medianndarrayA new array holding the result. If the input contains integersor floats smaller than float64, then the output data-type isnp.float64.  Otherwise, the data-type of the output is thesame as that of the input. If out is specified, that array isreturned instead.", "examples": ["; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.median(a)\n3.5\n; np.median(a, axis=0)\narray([6.5, 4.5, 2.5])\n; np.median(a, axis=1)\narray([7.,  2.])\n; m = np.median(a, axis=0)\n; out = np.zeros_like(m)\n; np.median(a, axis=0, out=m)\narray([6.5,  4.5,  2.5])\n; m\narray([6.5,  4.5,  2.5])\n; b = a.copy()\n; np.median(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a==b)\n; b = a.copy()\n; np.median(b, axis=None, overwrite_input=True)\n3.5\n; assert not np.all(a==b)\n\n", "; a = np.array([[10, 7, 4], [3, 2, 1]])\n; a\narray([[10,  7,  4],\n       [ 3,  2,  1]])\n; np.median(a)\n3.5\n; np.median(a, axis=0)\narray([6.5, 4.5, 2.5])\n; np.median(a, axis=1)\narray([7.,  2.])\n; m = np.median(a, axis=0)\n; out = np.zeros_like(m)\n; np.median(a, axis=0, out=m)\narray([6.5,  4.5,  2.5])\n; m\narray([6.5,  4.5,  2.5])\n; b = a.copy()\n; np.median(b, axis=1, overwrite_input=True)\narray([7.,  2.])\n; assert not np.all(a==b)\n; b = a.copy()\n; np.median(b, axis=None, overwrite_input=True)\n3.5\n; assert not np.all(a==b)\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.mean", "code": "\nndarray.mean(axis=None, dtype=None, out=None, keepdims=False)\u00b6", "description": "Returns the average of the array elements along given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.meanequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.mean", "code": "\nrecord.mean()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.mean", "code": "\nrecarray.mean(axis=None, dtype=None, out=None, keepdims=False)\u00b6", "description": "Returns the average of the array elements along given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.meanequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.mean", "code": "\nmatrix.mean(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Returns the average of the matrix elements along the given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\nnumpy.mean\n\nNotes\nSame as ndarray.mean except that, where that returns an ndarray,\nthis returns a matrix object.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3, 4)))\n&gt;&gt;&gt; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.mean()\n5.5\n&gt;&gt;&gt; x.mean(0)\nmatrix([[4., 5., 6., 7.]])\n&gt;&gt;&gt; x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.mean()\n5.5\n; x.mean(0)\nmatrix([[4., 5., 6., 7.]])\n; x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])\n\n", "; x = np.matrix(np.arange(12).reshape((3, 4)))\n; x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.mean()\n5.5\n; x.mean(0)\nmatrix([[4., 5., 6., 7.]])\n; x.mean(1)\nmatrix([[ 1.5],\n        [ 5.5],\n        [ 9.5]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.mean", "code": "\nMaskType.mean()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.mean", "code": "\nmemmap.mean(axis=None, dtype=None, out=None, keepdims=False)\u00b6", "description": "Returns the average of the array elements along given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.meanequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.mean", "code": "\nmasked_array.mean(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns the average of the array elements along given axis.\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.ndarray.meancorresponding function for ndarrays\n\nnumpy.meanEquivalent function\n\nnumpy.ma.averageWeighted average.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.mean()\n1.5\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n\n", "; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.mean", "code": "\nMaskedArray.mean(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns the average of the array elements along given axis.\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.ndarray.meancorresponding function for ndarrays\n\nnumpy.meanEquivalent function\n\nnumpy.ma.averageWeighted average.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.mean()\n1.5\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n\n", "; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n"]},
{"library": "numpy", "item_id": "numpy.generic.mean", "code": "\ngeneric.mean()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.mean", "code": "\nnumpy.ma.mean(self, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns the average of the array elements along given axis.\nMasked entries are ignored, and result elements which are not\nfinite will be masked.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.ndarray.meancorresponding function for ndarrays\n\nnumpy.meanEquivalent function\n\nnumpy.ma.averageWeighted average.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.mean()\n1.5\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n\n", "; a = np.ma.array([1,2,3], mask=[False, False, True])\n; a\nmasked_array(data=[1, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.mean()\n1.5\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.mean", "code": "\nchararray.mean(axis=None, dtype=None, out=None, keepdims=False)\u00b6", "description": "Returns the average of the array elements along given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.meanequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.mean", "code": "\nnumpy.mean(a, axis=None, dtype=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Compute the arithmetic mean along the specified axis.\nReturns the average of the array elements.  The average is taken over\nthe flattened array by default, otherwise over the specified axis.\nfloat64 intermediate and return values are used for integer inputs.\n\nParameters\n\naarray_likeArray containing numbers whose mean is desired. If a is not an\narray, a conversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the means are computed. The default is to\ncompute the mean of the flattened array.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a mean is performed over multiple axes,\ninstead of a single axis or all the axes as before.\n\ndtypedata-type, optionalType to use in computing the mean.  For integer inputs, the default\nis float64; for floating point inputs, it is the same as the\ninput dtype.\n\noutndarray, optionalAlternate output array in which to place the result.  The default\nis None; if provided, it must have the same shape as the\nexpected output, but the type will be cast if necessary.\nSee ufuncs-output-type for more details.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the mean method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nmndarray, see dtype parameter aboveIf out=None, returns a new array containing the mean values,\notherwise a reference to the output array is returned.\n\n\n\n\n\nSee also\n\naverageWeighted average\n\n\nstd, var, nanmean, nanstd, nanvar\n\nNotes\nThe arithmetic mean is the sum of the elements along the axis divided\nby the number of elements.\nNote that for floating-point input, the mean is computed using the\nsame precision the input has.  Depending on the input data, this can\ncause the results to be inaccurate, especially for float32 (see\nexample below).  Specifying a higher-precision accumulator using the\ndtype keyword can alleviate this issue.\nBy default, float16 results are computed using float32 intermediates\nfor extra precision.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.mean(a)\n2.5\n&gt;&gt;&gt; np.mean(a, axis=0)\narray([2., 3.])\n&gt;&gt;&gt; np.mean(a, axis=1)\narray([1.5, 3.5])\n\n\nIn single precision, mean can be inaccurate:\n&gt;&gt;&gt; a = np.zeros((2, 512*512), dtype=np.float32)\n&gt;&gt;&gt; a[0, :] = 1.0\n&gt;&gt;&gt; a[1, :] = 0.1\n&gt;&gt;&gt; np.mean(a)\n0.54999924\n\n\nComputing the mean in float64 is more accurate:\n&gt;&gt;&gt; np.mean(a, dtype=np.float64)\n0.55000000074505806 # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "dtypedata-type, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "mndarray, see dtype parameter above"], "returns": "mndarray, see dtype parameter aboveIf out=None, returns a new array containing the mean values,otherwise a reference to the output array is returned.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.mean(a)\n2.5\n; np.mean(a, axis=0)\narray([2., 3.])\n; np.mean(a, axis=1)\narray([1.5, 3.5])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.mean(a)\n2.5\n; np.mean(a, axis=0)\narray([2., 3.])\n; np.mean(a, axis=1)\narray([1.5, 3.5])\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.mean(a)\n0.54999924\n\n", "; a = np.zeros((2, 512*512), dtype=np.float32)\n; a[0, :] = 1.0\n; a[1, :] = 0.1\n; np.mean(a)\n0.54999924\n", "; np.mean(a, dtype=np.float64)\n0.55000000074505806 # may vary\n\n", "; np.mean(a, dtype=np.float64)\n0.55000000074505806 # may vary\n"]},
{"library": "numpy", "item_id": "numpy.chararray.mean", "code": "\nchararray.mean(axis=None, dtype=None, out=None, keepdims=False)\u00b6", "description": "Returns the average of the array elements along given axis.\nRefer to numpy.mean for full documentation.\n\nSee also\n\nnumpy.meanequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.maxpower", "code": "\nLegendre.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.maxpower", "code": "\nPolynomial.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.may_share_memory", "code": "\nnumpy.may_share_memory(a, b, max_work=None)\u00b6", "description": "Determine if two arrays might share memory\nA return of True does not necessarily mean that the two arrays\nshare any element.  It just means that they might.\nOnly the memory bounds of a and b are checked by default.\n\nParameters\n\na, bndarrayInput arrays\n\nmax_workint, optionalEffort to spend on solving the overlap problem.  See\nshares_memory for details.  Default for may_share_memory\nis to do a bounds check.\n\n\n\nReturns\n\noutbool\n\n\n\n\nSee also\nshares_memory\n\nExamples\n&gt;&gt;&gt; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n&gt;&gt;&gt; x = np.zeros([3, 4])\n&gt;&gt;&gt; np.may_share_memory(x[:,0], x[:,1])\nTrue\n\n\n", "parameters": ["Parameters", "a, bndarray", "max_workint, optional", "Returns", "outbool"], "returns": "outbool", "examples": ["; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n; x = np.zeros([3, 4])\n; np.may_share_memory(x[:,0], x[:,1])\nTrue\n\n", "; np.may_share_memory(np.array([1,2]), np.array([5,8,9]))\nFalse\n; x = np.zeros([3, 4])\n; np.may_share_memory(x[:,0], x[:,1])\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.maxpower", "code": "\nLaguerre.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.maxpower", "code": "\nHermiteE.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.maxpower", "code": "\nHermite.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.maxpower", "code": "\nChebyshev.maxpower = 100\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.maximum_sctype", "code": "\nnumpy.maximum_sctype(t)[source]\u00b6", "description": "Return the scalar type of highest precision of the same kind as the input.\n\nParameters\n\ntdtype or dtype specifierThe input data type. This can be a dtype object or an object that\nis convertible to a dtype.\n\n\n\nReturns\n\noutdtypeThe highest precision data type of the same kind (dtype.kind) as t.\n\n\n\n\n\nSee also\nobj2sctype, mintypecode, sctype2char, dtype\n\nExamples\n&gt;&gt;&gt; np.maximum_sctype(int)\n&lt;class 'numpy.int64'&gt;\n&gt;&gt;&gt; np.maximum_sctype(np.uint8)\n&lt;class 'numpy.uint64'&gt;\n&gt;&gt;&gt; np.maximum_sctype(complex)\n&lt;class 'numpy.complex256'&gt; # may vary\n\n\n&gt;&gt;&gt; np.maximum_sctype(str)\n&lt;class 'numpy.str_'&gt;\n\n\n&gt;&gt;&gt; np.maximum_sctype('i2')\n&lt;class 'numpy.int64'&gt;\n&gt;&gt;&gt; np.maximum_sctype('f4')\n&lt;class 'numpy.float128'&gt; # may vary\n\n\n", "parameters": ["Parameters", "tdtype or dtype specifier", "Returns", "outdtype"], "returns": "outdtypeThe highest precision data type of the same kind (dtype.kind) as t.", "examples": ["; np.maximum_sctype(int)\n&lt;class 'numpy.int64'&gt;\n; np.maximum_sctype(np.uint8)\n&lt;class 'numpy.uint64'&gt;\n; np.maximum_sctype(complex)\n&lt;class 'numpy.complex256'&gt; # may vary\n\n", "; np.maximum_sctype(int)\n&lt;class 'numpy.int64'&gt;\n; np.maximum_sctype(np.uint8)\n&lt;class 'numpy.uint64'&gt;\n; np.maximum_sctype(complex)\n&lt;class 'numpy.complex256'&gt; # may vary\n", "; np.maximum_sctype(str)\n&lt;class 'numpy.str_'&gt;\n\n", "; np.maximum_sctype(str)\n&lt;class 'numpy.str_'&gt;\n", "; np.maximum_sctype('i2')\n&lt;class 'numpy.int64'&gt;\n; np.maximum_sctype('f4')\n&lt;class 'numpy.float128'&gt; # may vary\n\n", "; np.maximum_sctype('i2')\n&lt;class 'numpy.int64'&gt;\n; np.maximum_sctype('f4')\n&lt;class 'numpy.float128'&gt; # may vary\n"]},
{"library": "numpy", "item_id": "numpy.ma.maximum_fill_value", "code": "\nnumpy.ma.maximum_fill_value(obj)[source]\u00b6", "description": "Return the minimum value that can be represented by the dtype of an object.\nThis function is useful for calculating a fill value suitable for\ntaking the maximum of an array with a given dtype.\n\nParameters\n\nobjndarray, dtype or scalarAn object that can be queried for it\u2019s numeric type.\n\n\n\nReturns\n\nvalscalarThe minimum representable value.\n\n\n\nRaises\n\nTypeErrorIf obj isn\u2019t a suitable numeric type.\n\n\n\n\n\nSee also\n\nminimum_fill_valueThe inverse function.\n\nset_fill_valueSet the filling value of a masked array.\n\nMaskedArray.fill_valueReturn current fill value.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.int8()\n&gt;&gt;&gt; ma.maximum_fill_value(a)\n-128\n&gt;&gt;&gt; a = np.int32()\n&gt;&gt;&gt; ma.maximum_fill_value(a)\n-2147483648\n\n\nAn array of numeric data can also be passed.\n&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)\n&gt;&gt;&gt; ma.maximum_fill_value(a)\n-128\n&gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)\n&gt;&gt;&gt; ma.maximum_fill_value(a)\n-inf\n\n\n", "parameters": ["Parameters", "objndarray, dtype or scalar", "Returns", "valscalar", "Raises", "TypeError"], "returns": "valscalarThe minimum representable value.", "examples": ["; import numpy.ma as ma\n; a = np.int8()\n; ma.maximum_fill_value(a)\n-128\n; a = np.int32()\n; ma.maximum_fill_value(a)\n-2147483648\n\n", "; import numpy.ma as ma\n; a = np.int8()\n; ma.maximum_fill_value(a)\n-128\n; a = np.int32()\n; ma.maximum_fill_value(a)\n-2147483648\n", "; a = np.array([1, 2, 3], dtype=np.int8)\n; ma.maximum_fill_value(a)\n-128\n; a = np.array([1, 2, 3], dtype=np.float32)\n; ma.maximum_fill_value(a)\n-inf\n\n", "; a = np.array([1, 2, 3], dtype=np.int8)\n; ma.maximum_fill_value(a)\n-128\n; a = np.array([1, 2, 3], dtype=np.float32)\n; ma.maximum_fill_value(a)\n-inf\n"]},
{"library": "numpy", "item_id": "numpy.maximum", "code": "\nnumpy.maximum(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'maximum'&gt;\u00b6", "description": "Element-wise maximum of array elements.\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then that\nelement is returned. If both elements are NaNs then the first is\nreturned. The latter distinction is important for complex NaNs, which\nare defined as at least one of the real or imaginary parts being a NaN.\nThe net effect is that NaNs are propagated.\n\nParameters\n\nx1, x2array_likeThe arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe maximum of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nminimumElement-wise minimum of two arrays, propagates NaNs.\n\nfmaxElement-wise maximum of two arrays, ignores NaNs.\n\namaxThe maximum value of an array along a given axis, propagates NaNs.\n\nnanmaxThe maximum value of an array along a given axis, ignores NaNs.\n\n\nfmin, amin, nanmin\n\nNotes\nThe maximum is equivalent to np.where(x1 &gt;= x2, x1, x2) when\nneither x1 nor x2 are nans, but it is faster and does proper\nbroadcasting.\nExamples\n&gt;&gt;&gt; np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n\n&gt;&gt;&gt; np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n\n&gt;&gt;&gt; np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n&gt;&gt;&gt; np.maximum(np.Inf, 1)\ninf\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe maximum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n\n", "; np.maximum([2, 3, 4], [1, 5, 2])\narray([2, 5, 4])\n", "; np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n", "; np.maximum(np.eye(2), [0.5, 2]) # broadcasting\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n", "; np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n; np.maximum(np.Inf, 1)\ninf\n\n", "; np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan])\narray([nan, nan, nan])\n; np.maximum(np.Inf, 1)\ninf\n"]},
{"library": "numpy", "item_id": "numpy.record.max", "code": "\nrecord.max()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.max", "code": "\nrecarray.max(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the maximum along a given axis.\nRefer to numpy.amax for full documentation.\n\nSee also\n\nnumpy.amaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.max", "code": "\nndarray.max(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the maximum along a given axis.\nRefer to numpy.amax for full documentation.\n\nSee also\n\nnumpy.amaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.max", "code": "\nmemmap.max(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the maximum along a given axis.\nRefer to numpy.amax for full documentation.\n\nSee also\n\nnumpy.amaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.max", "code": "\nmatrix.max(self, axis=None, out=None)[source]\u00b6", "description": "Return the maximum value along an axis.\n\nParameters\n\nSee `amax` for complete descriptions\n\n\n\n\nSee also\namax, ndarray.max\n\nNotes\nThis is the same as ndarray.max, but returns a matrix object\nwhere ndarray.max would return an ndarray.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.max()\n11\n&gt;&gt;&gt; x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])\n\n\n", "parameters": ["Parameters", "See `amax` for complete descriptions"], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.max()\n11\n; x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n; x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.max()\n11\n; x.max(0)\nmatrix([[ 8,  9, 10, 11]])\n; x.max(1)\nmatrix([[ 3],\n        [ 7],\n        [11]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.max", "code": "\nMaskType.max()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.max", "code": "\nMaskedArray.max(self, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the maximum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of maximum_fill_value().\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\namaxarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nmaximum_fill_valueReturns the maximum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "amaxarray_like"], "returns": "amaxarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.max", "code": "\nmasked_array.max(self, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the maximum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of maximum_fill_value().\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\namaxarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nmaximum_fill_valueReturns the maximum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "amaxarray_like"], "returns": "amaxarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.iinfo.max", "code": "\nproperty iinfo.max\u00b6", "description": "Maximum value of given dtype.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.max", "code": "\ngeneric.max()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.max", "code": "\nchararray.max(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the maximum along a given axis.\nRefer to numpy.amax for full documentation.\n\nSee also\n\nnumpy.amaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.max", "code": "\nnumpy.ma.max(obj, axis=None, out=None, fill_value=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Return the maximum along a given axis.\n\nParameters\n\naxis{None, int}, optionalAxis along which to operate.  By default, axis is None and the\nflattened input is used.\n\noutarray_like, optionalAlternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output.\n\nfill_value{var}, optionalValue used to fill in the masked values.\nIf None, use the output of maximum_fill_value().\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\namaxarray_likeNew array holding the result.\nIf out was specified, out is returned.\n\n\n\n\n\nSee also\n\nmaximum_fill_valueReturns the maximum filling value for a given datatype.\n\n\n\n", "parameters": ["Parameters", "axis{None, int}, optional", "outarray_like, optional", "fill_value{var}, optional", "keepdimsbool, optional", "Returns", "amaxarray_like"], "returns": "amaxarray_likeNew array holding the result.If out was specified, out is returned.", "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.matrix_rank", "code": "\nnumpy.linalg.matrix_rank(M, tol=None, hermitian=False)[source]\u00b6", "description": "Return matrix rank of array using SVD method\nRank of the array is the number of singular values of the array that are\ngreater than tol.\n\nChanged in version 1.14: Can now operate on stacks of matrices\n\n\nParameters\n\nM{(M,), (\u2026, M, N)} array_likeInput vector or stack of matrices.\n\ntol(\u2026) array_like, float, optionalThreshold below which SVD values are considered zero. If tol is\nNone, and S is an array with singular values for M, and\neps is the epsilon value for datatype of S, then tol is\nset to S.max() * max(M.shape) * eps.\n\nChanged in version 1.14: Broadcasted against the stack of matrices\n\n\nhermitianbool, optionalIf True, M is assumed to be Hermitian (symmetric if real-valued),\nenabling a more efficient method for finding singular values.\nDefaults to False.\n\nNew in version 1.14.\n\n\n\n\nReturns\n\nrank(\u2026) array_likeRank of M.\n\n\n\n\nNotes\nThe default threshold to detect rank deficiency is a test on the magnitude\nof the singular values of M.  By default, we identify singular values less\nthan S.max() * max(M.shape) * eps as indicating rank deficiency (with\nthe symbols defined above). This is the algorithm MATLAB uses [1].  It also\nappears in Numerical recipes in the discussion of SVD solutions for linear\nleast squares [2].\nThis default threshold is designed to detect rank deficiency accounting for\nthe numerical errors of the SVD computation.  Imagine that there is a column\nin M that is an exact (in floating point) linear combination of other\ncolumns in M. Computing the SVD on M will not produce a singular value\nexactly equal to 0 in general: any difference of the smallest SVD value from\n0 will be caused by numerical imprecision in the calculation of the SVD.\nOur threshold for small SVD values takes this numerical imprecision into\naccount, and the default threshold will detect such numerical rank\ndeficiency.  The threshold may declare a matrix M rank deficient even if\nthe linear combination of some columns of M is not exactly equal to\nanother column of M but only numerically very close to another column of\nM.\nWe chose our default threshold because it is in wide use.  Other thresholds\nare possible.  For example, elsewhere in the 2007 edition of Numerical\nrecipes there is an alternative threshold of S.max() *\nnp.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.). The authors describe\nthis threshold as being based on \u201cexpected roundoff error\u201d (p 71).\nThe thresholds above deal with floating point roundoff error in the\ncalculation of the SVD.  However, you may have more information about the\nsources of error in M that would make you consider other tolerance values\nto detect effective rank deficiency.  The most useful measure of the\ntolerance depends on the operations you intend to use on your matrix.  For\nexample, if your data come from uncertain measurements with uncertainties\ngreater than floating point epsilon, choosing a tolerance near that\nuncertainty may be preferable.  The tolerance may be absolute if the\nuncertainties are absolute rather than relative.\nReferences\n\n1\nMATLAB reference documention, \u201cRank\u201d\nhttps://www.mathworks.com/help/techdoc/ref/rank.html\n\n2\nW. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,\n\u201cNumerical Recipes (3rd edition)\u201d, Cambridge University Press, 2007,\npage 795.\n\n\nExamples\n&gt;&gt;&gt; from numpy.linalg import matrix_rank\n&gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix\n4\n&gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix\n&gt;&gt;&gt; matrix_rank(I)\n3\n&gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0\n1\n&gt;&gt;&gt; matrix_rank(np.zeros((4,)))\n0\n\n\n", "parameters": ["Parameters", "M{(M,), (\u2026, M, N)} array_like", "tol(\u2026) array_like, float, optional", "hermitianbool, optional", "Returns", "rank(\u2026) array_like"], "returns": "rank(\u2026) array_likeRank of M.", "examples": ["; from numpy.linalg import matrix_rank\n; matrix_rank(np.eye(4)) # Full rank matrix\n4\n; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix\n; matrix_rank(I)\n3\n; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0\n1\n; matrix_rank(np.zeros((4,)))\n0\n\n", "; from numpy.linalg import matrix_rank\n; matrix_rank(np.eye(4)) # Full rank matrix\n4\n; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix\n; matrix_rank(I)\n3\n; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0\n1\n; matrix_rank(np.zeros((4,)))\n0\n"]},
{"library": "numpy", "item_id": "numpy.chararray.max", "code": "\nchararray.max(axis=None, out=None, keepdims=False, initial=&lt;no value&gt;, where=True)\u00b6", "description": "Return the maximum along a given axis.\nRefer to numpy.amax for full documentation.\n\nSee also\n\nnumpy.amaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.matrix_power", "code": "\nnumpy.linalg.matrix_power(a, n)[source]\u00b6", "description": "Raise a square matrix to the (integer) power n.\nFor positive integers n, the power is computed by repeated matrix\nsquarings and matrix multiplications. If n == 0, the identity matrix\nof the same shape as M is returned. If n &lt; 0, the inverse\nis computed and then raised to the abs(n).\n\nNote\nStacks of object matrices are not currently supported.\n\n\nParameters\n\na(\u2026, M, M) array_likeMatrix to be \u201cpowered\u201d.\n\nnintThe exponent can be any integer or long integer, positive,\nnegative, or zero.\n\n\n\nReturns\n\na**n(\u2026, M, M) ndarray or matrix objectThe return value is the same shape and type as M;\nif the exponent is positive or zero then the type of the\nelements is the same as those of M. If the exponent is\nnegative the elements are floating-point.\n\n\n\nRaises\n\nLinAlgErrorFor matrices that are not square or that (for negative powers) cannot\nbe inverted numerically.\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.linalg import matrix_power\n&gt;&gt;&gt; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit\n&gt;&gt;&gt; matrix_power(i, 3) # should = -i\narray([[ 0, -1],\n       [ 1,  0]])\n&gt;&gt;&gt; matrix_power(i, 0)\narray([[1, 0],\n       [0, 1]])\n&gt;&gt;&gt; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements\narray([[ 0.,  1.],\n       [-1.,  0.]])\n\n\nSomewhat more sophisticated example\n&gt;&gt;&gt; q = np.zeros((4, 4))\n&gt;&gt;&gt; q[0:2, 0:2] = -i\n&gt;&gt;&gt; q[2:4, 2:4] = i\n&gt;&gt;&gt; q # one of the three quaternion units not equal to 1\narray([[ 0., -1.,  0.,  0.],\n       [ 1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.],\n       [ 0.,  0., -1.,  0.]])\n&gt;&gt;&gt; matrix_power(q, 2) # = -np.eye(4)\narray([[-1.,  0.,  0.,  0.],\n       [ 0., -1.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  0.,  0., -1.]])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "nint", "Returns", "a**n(\u2026, M, M) ndarray or matrix object", "Raises", "LinAlgError"], "returns": "a**n(\u2026, M, M) ndarray or matrix objectThe return value is the same shape and type as M;if the exponent is positive or zero then the type of theelements is the same as those of M. If the exponent isnegative the elements are floating-point.", "examples": ["; from numpy.linalg import matrix_power\n; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit\n; matrix_power(i, 3) # should = -i\narray([[ 0, -1],\n       [ 1,  0]])\n; matrix_power(i, 0)\narray([[1, 0],\n       [0, 1]])\n; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements\narray([[ 0.,  1.],\n       [-1.,  0.]])\n\n", "; from numpy.linalg import matrix_power\n; i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit\n; matrix_power(i, 3) # should = -i\narray([[ 0, -1],\n       [ 1,  0]])\n; matrix_power(i, 0)\narray([[1, 0],\n       [0, 1]])\n; matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements\narray([[ 0.,  1.],\n       [-1.,  0.]])\n", "; q = np.zeros((4, 4))\n; q[0:2, 0:2] = -i\n; q[2:4, 2:4] = i\n; q # one of the three quaternion units not equal to 1\narray([[ 0., -1.,  0.,  0.],\n       [ 1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.],\n       [ 0.,  0., -1.,  0.]])\n; matrix_power(q, 2) # = -np.eye(4)\narray([[-1.,  0.,  0.,  0.],\n       [ 0., -1.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  0.,  0., -1.]])\n\n", "; q = np.zeros((4, 4))\n; q[0:2, 0:2] = -i\n; q[2:4, 2:4] = i\n; q # one of the three quaternion units not equal to 1\narray([[ 0., -1.,  0.,  0.],\n       [ 1.,  0.,  0.,  0.],\n       [ 0.,  0.,  0.,  1.],\n       [ 0.,  0., -1.,  0.]])\n; matrix_power(q, 2) # = -np.eye(4)\narray([[-1.,  0.,  0.,  0.],\n       [ 0., -1.,  0.,  0.],\n       [ 0.,  0., -1.,  0.],\n       [ 0.,  0.,  0., -1.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix", "code": "\nclass numpy.matrix(data, dtype=None, copy=True)[source]\u00b6", "description": "\nNote\nIt is no longer recommended to use this class, even for linear\nalgebra. Instead use regular arrays. The class may be removed\nin the future.\n\nReturns a matrix from an array-like object, or from a string of data.\nA matrix is a specialized 2-D array that retains its 2-D nature\nthrough operations.  It has certain special operators, such as *\n(matrix multiplication) and ** (matrix power).\n\nParameters\n\ndataarray_like or stringIf data is a string, it is interpreted as a matrix with commas\nor spaces separating columns, and semicolons separating rows.\n\ndtypedata-typeData-type of the output matrix.\n\ncopyboolIf data is already an ndarray, then this flag determines\nwhether the data is copied (the default), or whether a view is\nconstructed.\n\n\n\n\n\nSee also\narray\n\nExamples\n&gt;&gt;&gt; a = np.matrix('1 2; 3 4')\n&gt;&gt;&gt; a\nmatrix([[1, 2],\n        [3, 4]])\n\n\n&gt;&gt;&gt; np.matrix([[1, 2], [3, 4]])\nmatrix([[1, 2],\n        [3, 4]])\n\n\n\nAttributes\n\nAReturn self as an ndarray object.\n\nA1Return self as a flattened ndarray.\n\nHReturns the (complex) conjugate transpose of self.\n\nIReturns the (multiplicative) inverse of invertible self.\n\nTReturns the transpose of the matrix.\n\nbaseBase object if memory is from some other object.\n\nctypesAn object to simplify the interaction of the array with the ctypes module.\n\ndataPython buffer object pointing to the start of the array\u2019s data.\n\ndtypeData-type of the array\u2019s elements.\n\nflagsInformation about the memory layout of the array.\n\nflatA 1-D iterator over the array.\n\nimagThe imaginary part of the array.\n\nitemsizeLength of one array element in bytes.\n\nnbytesTotal bytes consumed by the elements of the array.\n\nndimNumber of array dimensions.\n\nrealThe real part of the array.\n\nshapeTuple of array dimensions.\n\nsizeNumber of elements in the array.\n\nstridesTuple of bytes to step in each dimension when traversing an array.\n\n\n\n\nMethods\n\n\n\n\n\n\nall(self[,\u00a0axis,\u00a0out])\nTest whether all matrix elements along a given axis evaluate to True.\n\nany(self[,\u00a0axis,\u00a0out])\nTest whether any array element along a given axis evaluates to True.\n\nargmax(self[,\u00a0axis,\u00a0out])\nIndexes of the maximum values along an axis.\n\nargmin(self[,\u00a0axis,\u00a0out])\nIndexes of the minimum values along an axis.\n\nargpartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nReturns the indices that would partition this array.\n\nargsort([axis,\u00a0kind,\u00a0order])\nReturns the indices that would sort this array.\n\nastype(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])\nCopy of the array, cast to a specified type.\n\nbyteswap([inplace])\nSwap the bytes of the array elements\n\nchoose(choices[,\u00a0out,\u00a0mode])\nUse an index array to construct a new array from a set of choices.\n\nclip([min,\u00a0max,\u00a0out])\nReturn an array whose values are limited to [min, max].\n\ncompress(condition[,\u00a0axis,\u00a0out])\nReturn selected slices of this array along given axis.\n\nconj()\nComplex-conjugate all elements.\n\nconjugate()\nReturn the complex conjugate, element-wise.\n\ncopy([order])\nReturn a copy of the array.\n\ncumprod([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative product of the elements along the given axis.\n\ncumsum([axis,\u00a0dtype,\u00a0out])\nReturn the cumulative sum of the elements along the given axis.\n\ndiagonal([offset,\u00a0axis1,\u00a0axis2])\nReturn specified diagonals.\n\ndot(b[,\u00a0out])\nDot product of two arrays.\n\ndump(file)\nDump a pickle of the array to the specified file.\n\ndumps()\nReturns the pickle of the array as a string.\n\nfill(value)\nFill the array with a scalar value.\n\nflatten(self[,\u00a0order])\nReturn a flattened copy of the matrix.\n\ngetA(self)\nReturn self as an ndarray object.\n\ngetA1(self)\nReturn self as a flattened ndarray.\n\ngetH(self)\nReturns the (complex) conjugate transpose of self.\n\ngetI(self)\nReturns the (multiplicative) inverse of invertible self.\n\ngetT(self)\nReturns the transpose of the matrix.\n\ngetfield(dtype[,\u00a0offset])\nReturns a field of the given array as a certain type.\n\nitem(*args)\nCopy an element of an array to a standard Python scalar and return it.\n\nitemset(*args)\nInsert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\n\nmax(self[,\u00a0axis,\u00a0out])\nReturn the maximum value along an axis.\n\nmean(self[,\u00a0axis,\u00a0dtype,\u00a0out])\nReturns the average of the matrix elements along the given axis.\n\nmin(self[,\u00a0axis,\u00a0out])\nReturn the minimum value along an axis.\n\nnewbyteorder([new_order])\nReturn the array with the same data viewed with a different byte order.\n\nnonzero()\nReturn the indices of the elements that are non-zero.\n\npartition(kth[,\u00a0axis,\u00a0kind,\u00a0order])\nRearranges the elements in the array in such a way that the value of the element in kth position is in the position it would be in a sorted array.\n\nprod(self[,\u00a0axis,\u00a0dtype,\u00a0out])\nReturn the product of the array elements over the given axis.\n\nptp(self[,\u00a0axis,\u00a0out])\nPeak-to-peak (maximum - minimum) value along the given axis.\n\nput(indices,\u00a0values[,\u00a0mode])\nSet a.flat[n] = values[n] for all n in indices.\n\nravel(self[,\u00a0order])\nReturn a flattened matrix.\n\nrepeat(repeats[,\u00a0axis])\nRepeat elements of an array.\n\nreshape(shape[,\u00a0order])\nReturns an array containing the same data with a new shape.\n\nresize(new_shape[,\u00a0refcheck])\nChange shape and size of array in-place.\n\nround([decimals,\u00a0out])\nReturn a with each element rounded to the given number of decimals.\n\nsearchsorted(v[,\u00a0side,\u00a0sorter])\nFind indices where elements of v should be inserted in a to maintain order.\n\nsetfield(val,\u00a0dtype[,\u00a0offset])\nPut a value into a specified place in a field defined by a data-type.\n\nsetflags([write,\u00a0align,\u00a0uic])\nSet array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.\n\nsort([axis,\u00a0kind,\u00a0order])\nSort an array in-place.\n\nsqueeze(self[,\u00a0axis])\nReturn a possibly reshaped matrix.\n\nstd(self[,\u00a0axis,\u00a0dtype,\u00a0out,\u00a0ddof])\nReturn the standard deviation of the array elements along the given axis.\n\nsum(self[,\u00a0axis,\u00a0dtype,\u00a0out])\nReturns the sum of the matrix elements, along the given axis.\n\nswapaxes(axis1,\u00a0axis2)\nReturn a view of the array with axis1 and axis2 interchanged.\n\ntake(indices[,\u00a0axis,\u00a0out,\u00a0mode])\nReturn an array formed from the elements of a at the given indices.\n\ntobytes([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntofile(fid[,\u00a0sep,\u00a0format])\nWrite array to a file as text or binary (default).\n\ntolist(self)\nReturn the matrix as a (possibly nested) list.\n\ntostring([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntrace([offset,\u00a0axis1,\u00a0axis2,\u00a0dtype,\u00a0out])\nReturn the sum along diagonals of the array.\n\ntranspose(*axes)\nReturns a view of the array with axes transposed.\n\nvar(self[,\u00a0axis,\u00a0dtype,\u00a0out,\u00a0ddof])\nReturns the variance of the matrix elements, along the given axis.\n\nview([dtype,\u00a0type])\nNew view of array with the same data.\n\n\n\n", "parameters": ["Parameters", "dataarray_like or string", "dtypedata-type", "copybool", "Attributes", "A", "A1", "H", "I", "T", "base", "ctypes", "data", "dtype", "flags", "flat", "imag", "itemsize", "nbytes", "ndim", "real", "shape", "size", "strides"], "returns": [], "examples": ["; a = np.matrix('1 2; 3 4')\n; a\nmatrix([[1, 2],\n        [3, 4]])\n\n", "; a = np.matrix('1 2; 3 4')\n; a\nmatrix([[1, 2],\n        [3, 4]])\n", "; np.matrix([[1, 2], [3, 4]])\nmatrix([[1, 2],\n        [3, 4]])\n\n", "; np.matrix([[1, 2], [3, 4]])\nmatrix([[1, 2],\n        [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.matmul", "code": "\nnumpy.matmul(x1, x2, /, out=None, *, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'matmul'&gt;\u00b6", "description": "Matrix product of two arrays.\n\nParameters\n\nx1, x2array_likeInput arrays, scalars not allowed.\n\noutndarray, optionalA location into which the result is stored. If provided, it must have\na shape that matches the signature (n,k),(k,m)-&gt;(n,m). If not\nprovided or None, a freshly-allocated array is returned.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\nNew in version 1.16: Now handles ufunc kwargs\n\n\n\n\nReturns\n\nyndarrayThe matrix product of the inputs.\nThis is a scalar only when both x1, x2 are 1-d vectors.\n\n\n\nRaises\n\nValueErrorIf the last dimension of a is not the same size as\nthe second-to-last dimension of b.\nIf a scalar value is passed in.\n\n\n\n\n\nSee also\n\nvdotComplex-conjugating dot product.\n\ntensordotSum products over arbitrary axes.\n\neinsumEinstein summation convention.\n\ndotalternative matrix product with different broadcasting rules.\n\n\n\nNotes\nThe behavior depends on the arguments in the following way.\n\nIf both arguments are 2-D they are multiplied like conventional\nmatrices.\nIf either argument is N-D, N &gt; 2, it is treated as a stack of\nmatrices residing in the last two indexes and broadcast accordingly.\nIf the first argument is 1-D, it is promoted to a matrix by\nprepending a 1 to its dimensions. After matrix multiplication\nthe prepended 1 is removed.\nIf the second argument is 1-D, it is promoted to a matrix by\nappending a 1 to its dimensions. After matrix multiplication\nthe appended 1 is removed.\n\nmatmul differs from dot in two important ways:\n\nMultiplication by scalars is not allowed, use * instead.\nStacks of matrices are broadcast together as if the matrices\nwere elements, respecting the signature (n,k),(k,m)-&gt;(n,m):\n&gt;&gt;&gt; a = np.ones([9, 5, 7, 4])\n&gt;&gt;&gt; c = np.ones([9, 5, 4, 3])\n&gt;&gt;&gt; np.dot(a, c).shape\n(9, 5, 7, 9, 5, 3)\n&gt;&gt;&gt; np.matmul(a, c).shape\n(9, 5, 7, 3)\n&gt;&gt;&gt; # n is 7, k is 4, m is 3\n\n\n\n\nThe matmul function implements the semantics of the @ operator introduced\nin Python 3.5 following PEP465.\nExamples\nFor 2-D arrays it is the matrix product:\n&gt;&gt;&gt; a = np.array([[1, 0],\n...               [0, 1]])\n&gt;&gt;&gt; b = np.array([[4, 1],\n...               [2, 2]])\n&gt;&gt;&gt; np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])\n\n\nFor 2-D mixed with 1-D, the result is the usual.\n&gt;&gt;&gt; a = np.array([[1, 0],\n...               [0, 1]])\n&gt;&gt;&gt; b = np.array([1, 2])\n&gt;&gt;&gt; np.matmul(a, b)\narray([1, 2])\n&gt;&gt;&gt; np.matmul(b, a)\narray([1, 2])\n\n\nBroadcasting is conventional for stacks of arrays\n&gt;&gt;&gt; a = np.arange(2 * 2 * 4).reshape((2, 2, 4))\n&gt;&gt;&gt; b = np.arange(2 * 2 * 4).reshape((2, 4, 2))\n&gt;&gt;&gt; np.matmul(a,b).shape\n(2, 2, 2)\n&gt;&gt;&gt; np.matmul(a, b)[0, 1, 1]\n98\n&gt;&gt;&gt; sum(a[0, 1, :] * b[0 , :, 1])\n98\n\n\nVector, vector returns the scalar inner product, but neither argument\nis complex-conjugated:\n&gt;&gt;&gt; np.matmul([2j, 3j], [2j, 3j])\n(-13+0j)\n\n\nScalar multiplication raises an error.\n&gt;&gt;&gt; np.matmul([1,2], 3)\nTraceback (most recent call last):\n...\nValueError: matmul: Input operand 1 does not have enough dimensions ...\n\n\n\nNew in version 1.10.0.\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, optional", "**kwargs", "Returns", "yndarray", "Raises", "ValueError"], "returns": "yndarrayThe matrix product of the inputs.This is a scalar only when both x1, x2 are 1-d vectors.", "examples": ["; a = np.array([[1, 0],\n...               [0, 1]])\n; b = np.array([[4, 1],\n...               [2, 2]])\n; np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])\n\n", "; a = np.array([[1, 0],\n...               [0, 1]])\n; b = np.array([[4, 1],\n...               [2, 2]])\n; np.matmul(a, b)\narray([[4, 1],\n       [2, 2]])\n", "; a = np.array([[1, 0],\n...               [0, 1]])\n; b = np.array([1, 2])\n; np.matmul(a, b)\narray([1, 2])\n; np.matmul(b, a)\narray([1, 2])\n\n", "; a = np.array([[1, 0],\n...               [0, 1]])\n; b = np.array([1, 2])\n; np.matmul(a, b)\narray([1, 2])\n; np.matmul(b, a)\narray([1, 2])\n", "; a = np.arange(2 * 2 * 4).reshape((2, 2, 4))\n; b = np.arange(2 * 2 * 4).reshape((2, 4, 2))\n; np.matmul(a,b).shape\n(2, 2, 2)\n; np.matmul(a, b)[0, 1, 1]\n98\n; sum(a[0, 1, :] * b[0 , :, 1])\n98\n\n", "; a = np.arange(2 * 2 * 4).reshape((2, 2, 4))\n; b = np.arange(2 * 2 * 4).reshape((2, 4, 2))\n; np.matmul(a,b).shape\n(2, 2, 2)\n; np.matmul(a, b)[0, 1, 1]\n98\n; sum(a[0, 1, :] * b[0 , :, 1])\n98\n", "; np.matmul([2j, 3j], [2j, 3j])\n(-13+0j)\n\n", "; np.matmul([2j, 3j], [2j, 3j])\n(-13+0j)\n", "; np.matmul([1,2], 3)\nTraceback (most recent call last):\n...\nValueError: matmul: Input operand 1 does not have enough dimensions ...\n\n", "; np.matmul([1,2], 3)\nTraceback (most recent call last):\n...\nValueError: matmul: Input operand 1 does not have enough dimensions ...\n"]},
{"library": "numpy", "item_id": "numpy.mat", "code": "\nnumpy.mat(data, dtype=None)[source]\u00b6", "description": "Interpret the input as a matrix.\nUnlike matrix, asmatrix does not make a copy if the input is already\na matrix or an ndarray.  Equivalent to matrix(data, copy=False).\n\nParameters\n\ndataarray_likeInput data.\n\ndtypedata-typeData-type of the output matrix.\n\n\n\nReturns\n\nmatmatrixdata interpreted as a matrix.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])\n\n\n&gt;&gt;&gt; m = np.asmatrix(x)\n\n\n&gt;&gt;&gt; x[0,0] = 5\n\n\n&gt;&gt;&gt; m\nmatrix([[5, 2],\n        [3, 4]])\n\n\n", "parameters": ["Parameters", "dataarray_like", "dtypedata-type", "Returns", "matmatrix"], "returns": "matmatrixdata interpreted as a matrix.", "examples": ["; x = np.array([[1, 2], [3, 4]])\n\n", "; x = np.array([[1, 2], [3, 4]])\n", "; m = np.asmatrix(x)\n\n", "; m = np.asmatrix(x)\n", "; x[0,0] = 5\n\n", "; x[0,0] = 5\n", "; m\nmatrix([[5, 2],\n        [3, 4]])\n\n", "; m\nmatrix([[5, 2],\n        [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType", "code": "\nnumpy.ma.MaskType[source]\u00b6", "description": "alias of numpy.bool_\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_where", "code": "\nnumpy.ma.masked_where(condition, a, copy=True)[source]\u00b6", "description": "Mask an array where a condition is met.\nReturn a as an array masked where condition is True.\nAny masked values of a or condition are also masked in the output.\n\nParameters\n\nconditionarray_likeMasking condition.  When condition tests floating point values for\nequality, consider using masked_values instead.\n\naarray_likeArray to mask.\n\ncopyboolIf True (default) make a copy of a in the result.  If False modify\na in place and return a view.\n\n\n\nReturns\n\nresultMaskedArrayThe result of masking a where condition is True.\n\n\n\n\n\nSee also\n\nmasked_valuesMask using floating point equality.\n\nmasked_equalMask where equal to a given value.\n\nmasked_not_equalMask where not equal to a given value.\n\nmasked_less_equalMask where less than or equal to a given value.\n\nmasked_greater_equalMask where greater than or equal to a given value.\n\nmasked_lessMask where less than a given value.\n\nmasked_greaterMask where greater than a given value.\n\nmasked_insideMask inside a given interval.\n\nmasked_outsideMask outside a given interval.\n\nmasked_invalidMask invalid values (NaNs or infs).\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_where(a &lt;= 2, a)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n\n\nMask array b conditional on a.\n&gt;&gt;&gt; b = ['a', 'b', 'c', 'd']\n&gt;&gt;&gt; ma.masked_where(a == 2, b)\nmasked_array(data=['a', 'b', --, 'd'],\n             mask=[False, False,  True, False],\n       fill_value='N/A',\n            dtype='&lt;U1')\n\n\nEffect of the copy argument.\n&gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a)\n&gt;&gt;&gt; c\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; c[0] = 99\n&gt;&gt;&gt; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a, copy=False)\n&gt;&gt;&gt; c[0] = 99\n&gt;&gt;&gt; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; a\narray([99,  1,  2,  3])\n\n\nWhen condition or a contain masked values.\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a = ma.masked_where(a == 2, a)\n&gt;&gt;&gt; a\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; b = np.arange(4)\n&gt;&gt;&gt; b = ma.masked_where(b == 0, b)\n&gt;&gt;&gt; b\nmasked_array(data=[--, 1, 2, 3],\n             mask=[ True, False, False, False],\n       fill_value=999999)\n&gt;&gt;&gt; ma.masked_where(a == 3, b)\nmasked_array(data=[--, 1, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "conditionarray_like", "aarray_like", "copybool", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayThe result of masking a where condition is True.", "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_where(a &lt;= 2, a)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_where(a &lt;= 2, a)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n", "; b = ['a', 'b', 'c', 'd']\n; ma.masked_where(a == 2, b)\nmasked_array(data=['a', 'b', --, 'd'],\n             mask=[False, False,  True, False],\n       fill_value='N/A',\n            dtype='&lt;U1')\n\n", "; b = ['a', 'b', 'c', 'd']\n; ma.masked_where(a == 2, b)\nmasked_array(data=['a', 'b', --, 'd'],\n             mask=[False, False,  True, False],\n       fill_value='N/A',\n            dtype='&lt;U1')\n", "; c = ma.masked_where(a &lt;= 2, a)\n; c\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n; c[0] = 99\n; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n; a\narray([0, 1, 2, 3])\n; c = ma.masked_where(a &lt;= 2, a, copy=False)\n; c[0] = 99\n; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n; a\narray([99,  1,  2,  3])\n\n", "; c = ma.masked_where(a &lt;= 2, a)\n; c\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n; c[0] = 99\n; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n; a\narray([0, 1, 2, 3])\n; c = ma.masked_where(a &lt;= 2, a, copy=False)\n; c[0] = 99\n; c\nmasked_array(data=[99, --, --, 3],\n             mask=[False,  True,  True, False],\n       fill_value=999999)\n; a\narray([99,  1,  2,  3])\n", "; a = np.arange(4)\n; a = ma.masked_where(a == 2, a)\n; a\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=999999)\n; b = np.arange(4)\n; b = ma.masked_where(b == 0, b)\n; b\nmasked_array(data=[--, 1, 2, 3],\n             mask=[ True, False, False, False],\n       fill_value=999999)\n; ma.masked_where(a == 3, b)\nmasked_array(data=[--, 1, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=999999)\n\n", "; a = np.arange(4)\n; a = ma.masked_where(a == 2, a)\n; a\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=999999)\n; b = np.arange(4)\n; b = ma.masked_where(b == 0, b)\n; b\nmasked_array(data=[--, 1, 2, 3],\n             mask=[ True, False, False, False],\n       fill_value=999999)\n; ma.masked_where(a == 3, b)\nmasked_array(data=[--, 1, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_values", "code": "\nnumpy.ma.masked_values(x, value, rtol=1e-05, atol=1e-08, copy=True, shrink=True)[source]\u00b6", "description": "Mask using floating point equality.\nReturn a MaskedArray, masked where the data in array x are approximately\nequal to value, determined using isclose. The default tolerances for\nmasked_values are the same as those for isclose.\nFor integer types, exact equality is used, in the same way as\nmasked_equal.\nThe fill_value is set to value and the mask is set to nomask if\npossible.\n\nParameters\n\nxarray_likeArray to mask.\n\nvaluefloatMasking value.\n\nrtol, atolfloat, optionalTolerance parameters passed on to isclose\n\ncopybool, optionalWhether to return a copy of x.\n\nshrinkbool, optionalWhether to collapse a mask full of False to nomask.\n\n\n\nReturns\n\nresultMaskedArrayThe result of masking x where approximately equal to value.\n\n\n\n\n\nSee also\n\nmasked_whereMask where a condition is met.\n\nmasked_equalMask where equal to a given value (integers).\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = np.array([1, 1.1, 2, 1.1, 3])\n&gt;&gt;&gt; ma.masked_values(x, 1.1)\nmasked_array(data=[1.0, --, 2.0, --, 3.0],\n             mask=[False,  True, False,  True, False],\n       fill_value=1.1)\n\n\nNote that mask is set to nomask if possible.\n&gt;&gt;&gt; ma.masked_values(x, 1.5)\nmasked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n             mask=False,\n       fill_value=1.5)\n\n\nFor integers, the fill value will be different in general to the\nresult of masked_equal.\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; x\narray([0, 1, 2, 3, 4])\n&gt;&gt;&gt; ma.masked_values(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n&gt;&gt;&gt; ma.masked_equal(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n\n\n", "parameters": ["Parameters", "xarray_like", "valuefloat", "rtol, atolfloat, optional", "copybool, optional", "shrinkbool, optional", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayThe result of masking x where approximately equal to value.", "examples": ["; import numpy.ma as ma\n; x = np.array([1, 1.1, 2, 1.1, 3])\n; ma.masked_values(x, 1.1)\nmasked_array(data=[1.0, --, 2.0, --, 3.0],\n             mask=[False,  True, False,  True, False],\n       fill_value=1.1)\n\n", "; import numpy.ma as ma\n; x = np.array([1, 1.1, 2, 1.1, 3])\n; ma.masked_values(x, 1.1)\nmasked_array(data=[1.0, --, 2.0, --, 3.0],\n             mask=[False,  True, False,  True, False],\n       fill_value=1.1)\n", "; ma.masked_values(x, 1.5)\nmasked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n             mask=False,\n       fill_value=1.5)\n\n", "; ma.masked_values(x, 1.5)\nmasked_array(data=[1. , 1.1, 2. , 1.1, 3. ],\n             mask=False,\n       fill_value=1.5)\n", "; x = np.arange(5)\n; x\narray([0, 1, 2, 3, 4])\n; ma.masked_values(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n; ma.masked_equal(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n\n", "; x = np.arange(5)\n; x\narray([0, 1, 2, 3, 4])\n; ma.masked_values(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n; ma.masked_equal(x, 2)\nmasked_array(data=[0, 1, --, 3, 4],\n             mask=[False, False,  True, False, False],\n       fill_value=2)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_object", "code": "\nnumpy.ma.masked_object(x, value, copy=True, shrink=True)[source]\u00b6", "description": "Mask the array x where the data are exactly equal to value.\nThis function is similar to masked_values, but only suitable\nfor object arrays: for floating point, use masked_values instead.\n\nParameters\n\nxarray_likeArray to mask\n\nvalueobjectComparison value\n\ncopy{True, False}, optionalWhether to return a copy of x.\n\nshrink{True, False}, optionalWhether to collapse a mask full of False to nomask\n\n\n\nReturns\n\nresultMaskedArrayThe result of masking x where equal to value.\n\n\n\n\n\nSee also\n\nmasked_whereMask where a condition is met.\n\nmasked_equalMask where equal to a given value (integers).\n\nmasked_valuesMask using floating point equality.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; food = np.array(['green_eggs', 'ham'], dtype=object)\n&gt;&gt;&gt; # don't eat spoiled food\n&gt;&gt;&gt; eat = ma.masked_object(food, 'green_eggs')\n&gt;&gt;&gt; eat\nmasked_array(data=[--, 'ham'],\n             mask=[ True, False],\n       fill_value='green_eggs',\n            dtype=object)\n&gt;&gt;&gt; # plain ol` ham is boring\n&gt;&gt;&gt; fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n&gt;&gt;&gt; eat = ma.masked_object(fresh_food, 'green_eggs')\n&gt;&gt;&gt; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n\n\nNote that mask is set to nomask if possible.\n&gt;&gt;&gt; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n\n\n", "parameters": ["Parameters", "xarray_like", "valueobject", "copy{True, False}, optional", "shrink{True, False}, optional", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayThe result of masking x where equal to value.", "examples": ["; import numpy.ma as ma\n; food = np.array(['green_eggs', 'ham'], dtype=object)\n; # don't eat spoiled food\n; eat = ma.masked_object(food, 'green_eggs')\n; eat\nmasked_array(data=[--, 'ham'],\n             mask=[ True, False],\n       fill_value='green_eggs',\n            dtype=object)\n; # plain ol` ham is boring\n; fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n; eat = ma.masked_object(fresh_food, 'green_eggs')\n; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n\n", "; import numpy.ma as ma\n; food = np.array(['green_eggs', 'ham'], dtype=object)\n; # don't eat spoiled food\n; eat = ma.masked_object(food, 'green_eggs')\n; eat\nmasked_array(data=[--, 'ham'],\n             mask=[ True, False],\n       fill_value='green_eggs',\n            dtype=object)\n; # plain ol` ham is boring\n; fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)\n; eat = ma.masked_object(fresh_food, 'green_eggs')\n; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n", "; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n\n", "; eat\nmasked_array(data=['cheese', 'ham', 'pineapple'],\n             mask=False,\n       fill_value='green_eggs',\n            dtype=object)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_outside", "code": "\nnumpy.ma.masked_outside(x, v1, v2, copy=True)[source]\u00b6", "description": "Mask an array outside a given interval.\nShortcut to masked_where, where condition is True for x outside\nthe interval [v1,v2] (x &lt; v1)|(x &gt; v2).\nThe boundaries v1 and v2 can be given in either order.\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nNotes\nThe array x is prefilled with its filling value.\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n&gt;&gt;&gt; ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n\n\nThe order of v1 and v2 doesn\u2019t matter.\n&gt;&gt;&gt; ma.masked_outside(x, 0.3, -0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n; ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n\n", "; import numpy.ma as ma\n; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n; ma.masked_outside(x, -0.3, 0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n", "; ma.masked_outside(x, 0.3, -0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n\n", "; ma.masked_outside(x, 0.3, -0.3)\nmasked_array(data=[--, --, 0.01, 0.2, --, --],\n             mask=[ True,  True, False, False,  True,  True],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_not_equal", "code": "\nnumpy.ma.masked_not_equal(x, value, copy=True)[source]\u00b6", "description": "Mask an array where not equal to a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x != value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_not_equal(a, 2)\nmasked_array(data=[--, --, 2, --],\n             mask=[ True,  True, False,  True],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_not_equal(a, 2)\nmasked_array(data=[--, --, 2, --],\n             mask=[ True,  True, False,  True],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_not_equal(a, 2)\nmasked_array(data=[--, --, 2, --],\n             mask=[ True,  True, False,  True],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_less", "code": "\nnumpy.ma.masked_less(x, value, copy=True)[source]\u00b6", "description": "Mask an array where less than a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x &lt; value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_less(a, 2)\nmasked_array(data=[--, --, 2, 3],\n             mask=[ True,  True, False, False],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_less(a, 2)\nmasked_array(data=[--, --, 2, 3],\n             mask=[ True,  True, False, False],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_less(a, 2)\nmasked_array(data=[--, --, 2, 3],\n             mask=[ True,  True, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_less_equal", "code": "\nnumpy.ma.masked_less_equal(x, value, copy=True)[source]\u00b6", "description": "Mask an array where less than or equal to a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x &lt;= value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_less_equal(a, 2)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_less_equal(a, 2)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_less_equal(a, 2)\nmasked_array(data=[--, --, --, 3],\n             mask=[ True,  True,  True, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_invalid", "code": "\nnumpy.ma.masked_invalid(a, copy=True)[source]\u00b6", "description": "Mask an array where invalid values occur (NaNs or infs).\nThis function is a shortcut to masked_where, with\ncondition = ~(np.isfinite(a)). Any pre-existing mask is conserved.\nOnly applies to arrays with a dtype where NaNs or infs make sense\n(i.e. floating point types), but accepts any array_like object.\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(5, dtype=float)\n&gt;&gt;&gt; a[2] = np.NaN\n&gt;&gt;&gt; a[3] = np.PINF\n&gt;&gt;&gt; a\narray([ 0.,  1., nan, inf,  4.])\n&gt;&gt;&gt; ma.masked_invalid(a)\nmasked_array(data=[0.0, 1.0, --, --, 4.0],\n             mask=[False, False,  True,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(5, dtype=float)\n; a[2] = np.NaN\n; a[3] = np.PINF\n; a\narray([ 0.,  1., nan, inf,  4.])\n; ma.masked_invalid(a)\nmasked_array(data=[0.0, 1.0, --, --, 4.0],\n             mask=[False, False,  True,  True, False],\n       fill_value=1e+20)\n\n", "; import numpy.ma as ma\n; a = np.arange(5, dtype=float)\n; a[2] = np.NaN\n; a[3] = np.PINF\n; a\narray([ 0.,  1., nan, inf,  4.])\n; ma.masked_invalid(a)\nmasked_array(data=[0.0, 1.0, --, --, 4.0],\n             mask=[False, False,  True,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_inside", "code": "\nnumpy.ma.masked_inside(x, v1, v2, copy=True)[source]\u00b6", "description": "Mask an array inside a given interval.\nShortcut to masked_where, where condition is True for x inside\nthe interval [v1,v2] (v1 &lt;= x &lt;= v2).  The boundaries v1 and v2\ncan be given in either order.\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nNotes\nThe array x is prefilled with its filling value.\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n&gt;&gt;&gt; ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n\n\nThe order of v1 and v2 doesn\u2019t matter.\n&gt;&gt;&gt; ma.masked_inside(x, 0.3, -0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n; ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n\n", "; import numpy.ma as ma\n; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]\n; ma.masked_inside(x, -0.3, 0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n", "; ma.masked_inside(x, 0.3, -0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n\n", "; ma.masked_inside(x, 0.3, -0.3)\nmasked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],\n             mask=[False, False,  True,  True, False, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_greater_equal", "code": "\nnumpy.ma.masked_greater_equal(x, value, copy=True)[source]\u00b6", "description": "Mask an array where greater than or equal to a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x &gt;= value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_greater_equal(a, 2)\nmasked_array(data=[0, 1, --, --],\n             mask=[False, False,  True,  True],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_greater_equal(a, 2)\nmasked_array(data=[0, 1, --, --],\n             mask=[False, False,  True,  True],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_greater_equal(a, 2)\nmasked_array(data=[0, 1, --, --],\n             mask=[False, False,  True,  True],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_greater", "code": "\nnumpy.ma.masked_greater(x, value, copy=True)[source]\u00b6", "description": "Mask an array where greater than a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x &gt; value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_greater(a, 2)\nmasked_array(data=[0, 1, 2, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_greater(a, 2)\nmasked_array(data=[0, 1, 2, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_greater(a, 2)\nmasked_array(data=[0, 1, 2, --],\n             mask=[False, False, False,  True],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array", "code": "\nnumpy.ma.masked_array[source]\u00b6", "description": "alias of numpy.ma.core.MaskedArray\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_equal", "code": "\nnumpy.ma.masked_equal(x, value, copy=True)[source]\u00b6", "description": "Mask an array where equal to a given value.\nThis function is a shortcut to masked_where, with\ncondition = (x == value).  For floating point arrays,\nconsider using masked_values(x, value).\n\nSee also\n\nmasked_whereMask where a condition is met.\n\nmasked_valuesMask using floating point equality.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3])\n&gt;&gt;&gt; ma.masked_equal(a, 2)\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=2)\n\n\n", "parameters": [], "returns": [], "examples": ["; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_equal(a, 2)\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=2)\n\n", "; import numpy.ma as ma\n; a = np.arange(4)\n; a\narray([0, 1, 2, 3])\n; ma.masked_equal(a, 2)\nmasked_array(data=[0, 1, --, 3],\n             mask=[False, False,  True, False],\n       fill_value=2)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_all_like", "code": "\nnumpy.ma.masked_all_like(arr)[source]\u00b6", "description": "Empty masked array with the properties of an existing array.\nReturn an empty masked array of the same shape and dtype as\nthe array arr, where all the data are masked.\n\nParameters\n\narrndarrayAn array describing the shape and dtype of the required MaskedArray.\n\n\n\nReturns\n\naMaskedArrayA masked array with all data masked.\n\n\n\nRaises\n\nAttributeErrorIf arr doesn\u2019t have a shape attribute (i.e. not an ndarray)\n\n\n\n\n\nSee also\n\nmasked_allEmpty masked array with all elements masked.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; arr = np.zeros((2, 3), dtype=np.float32)\n&gt;&gt;&gt; arr\narray([[0., 0., 0.],\n       [0., 0., 0.]], dtype=float32)\n&gt;&gt;&gt; ma.masked_all_like(arr)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float32)\n\n\nThe dtype of the masked array matches the dtype of arr.\n&gt;&gt;&gt; arr.dtype\ndtype('float32')\n&gt;&gt;&gt; ma.masked_all_like(arr).dtype\ndtype('float32')\n\n\n", "parameters": ["Parameters", "arrndarray", "Returns", "aMaskedArray", "Raises", "AttributeError"], "returns": "aMaskedArrayA masked array with all data masked.", "examples": ["; import numpy.ma as ma\n; arr = np.zeros((2, 3), dtype=np.float32)\n; arr\narray([[0., 0., 0.],\n       [0., 0., 0.]], dtype=float32)\n; ma.masked_all_like(arr)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float32)\n\n", "; import numpy.ma as ma\n; arr = np.zeros((2, 3), dtype=np.float32)\n; arr\narray([[0., 0., 0.],\n       [0., 0., 0.]], dtype=float32)\n; ma.masked_all_like(arr)\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float32)\n", "; arr.dtype\ndtype('float32')\n; ma.masked_all_like(arr).dtype\ndtype('float32')\n\n", "; arr.dtype\ndtype('float32')\n; ma.masked_all_like(arr).dtype\ndtype('float32')\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_all", "code": "\nnumpy.ma.masked_all(shape, dtype=&lt;class 'float'&gt;)[source]\u00b6", "description": "Empty masked array with all elements masked.\nReturn an empty masked array of the given shape and dtype, where all the\ndata are masked.\n\nParameters\n\nshapetupleShape of the required MaskedArray.\n\ndtypedtype, optionalData type of the output.\n\n\n\nReturns\n\naMaskedArrayA masked array with all data masked.\n\n\n\n\n\nSee also\n\nmasked_all_likeEmpty masked array modelled on an existing array.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; ma.masked_all((3, 3))\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float64)\n\n\nThe dtype parameter defines the underlying data type.\n&gt;&gt;&gt; a = ma.masked_all((3, 3))\n&gt;&gt;&gt; a.dtype\ndtype('float64')\n&gt;&gt;&gt; a = ma.masked_all((3, 3), dtype=np.int32)\n&gt;&gt;&gt; a.dtype\ndtype('int32')\n\n\n", "parameters": ["Parameters", "shapetuple", "dtypedtype, optional", "Returns", "aMaskedArray"], "returns": "aMaskedArrayA masked array with all data masked.", "examples": ["; import numpy.ma as ma\n; ma.masked_all((3, 3))\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float64)\n\n", "; import numpy.ma as ma\n; ma.masked_all((3, 3))\nmasked_array(\n  data=[[--, --, --],\n        [--, --, --],\n        [--, --, --]],\n  mask=[[ True,  True,  True],\n        [ True,  True,  True],\n        [ True,  True,  True]],\n  fill_value=1e+20,\n  dtype=float64)\n", "; a = ma.masked_all((3, 3))\n; a.dtype\ndtype('float64')\n; a = ma.masked_all((3, 3), dtype=np.int32)\n; a.dtype\ndtype('int32')\n\n", "; a = ma.masked_all((3, 3))\n; a.dtype\ndtype('float64')\n; a = ma.masked_all((3, 3), dtype=np.int32)\n; a.dtype\ndtype('int32')\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.mapparms", "code": "\nPolynomial.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.mapparms", "code": "\nLegendre.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.mapparms", "code": "\nLaguerre.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.mapparms", "code": "\nHermiteE.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.mapparms", "code": "\nHermite.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.mapparms", "code": "\nChebyshev.mapparms(self)[source]\u00b6", "description": "Return the mapping parameters.\nThe returned values define a linear map off + scl*x that is\napplied to the input arguments before the series is evaluated. The\nmap depends on the domain and window; if the current\ndomain is equal to the window the resulting map is the\nidentity.  If the coefficients of the series instance are to be\nused by themselves outside this class, then the linear function\nmust be substituted for the x in the standard representation of\nthe base polynomials.\n\nReturns\n\noff, sclfloat or complexThe mapping function is defined by off + scl*x.\n\n\n\n\nNotes\nIf the current domain is the interval [l1, r1] and the window\nis [l2, r2], then the linear mapping function L is\ndefined by the equations:\nL(l1) = l2\nL(r1) = r2\n\n\n", "parameters": [], "returns": "off, sclfloat or complexThe mapping function is defined by off + scl*x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.mapparms", "code": "\nnumpy.polynomial.polyutils.mapparms(old, new)[source]\u00b6", "description": "Linear map parameters between domains.\nReturn the parameters of the linear map offset + scale*x that maps\nold to new such that old[i] -&gt; new[i], i = 0, 1.\n\nParameters\n\nold, newarray_likeDomains. Each domain must (successfully) convert to a 1-d array\ncontaining precisely two values.\n\n\n\nReturns\n\noffset, scalescalarsThe map L(x) = offset + scale*x maps the first domain to the\nsecond.\n\n\n\n\n\nSee also\ngetdomain, mapdomain\n\nNotes\nAlso works for complex numbers, and thus can be used to calculate the\nparameters required to map any line in the complex plane to any other\nline therein.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.mapparms((-1,1),(-1,1))\n(0.0, 1.0)\n&gt;&gt;&gt; pu.mapparms((1,-1),(-1,1))\n(-0.0, -1.0)\n&gt;&gt;&gt; i = complex(0,1)\n&gt;&gt;&gt; pu.mapparms((-i,-1),(1,i))\n((1+1j), (1-0j))\n\n\n", "parameters": ["Parameters", "old, newarray_like", "Returns", "offset, scalescalars"], "returns": "offset, scalescalarsThe map L(x) = offset + scale*x maps the first domain to thesecond.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.mapparms((-1,1),(-1,1))\n(0.0, 1.0)\n; pu.mapparms((1,-1),(-1,1))\n(-0.0, -1.0)\n; i = complex(0,1)\n; pu.mapparms((-i,-1),(1,i))\n((1+1j), (1-0j))\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.mapparms((-1,1),(-1,1))\n(0.0, 1.0)\n; pu.mapparms((1,-1),(-1,1))\n(-0.0, -1.0)\n; i = complex(0,1)\n; pu.mapparms((-i,-1),(1,i))\n((1+1j), (1-0j))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.mapdomain", "code": "\nnumpy.polynomial.polyutils.mapdomain(x, old, new)[source]\u00b6", "description": "Apply linear map to input points.\nThe linear map offset + scale*x that maps the domain old to\nthe domain new is applied to the points x.\n\nParameters\n\nxarray_likePoints to be mapped. If x is a subtype of ndarray the subtype\nwill be preserved.\n\nold, newarray_likeThe two domains that determine the map.  Each must (successfully)\nconvert to 1-d arrays containing precisely two values.\n\n\n\nReturns\n\nx_outndarrayArray of points of the same shape as x, after application of the\nlinear map between the two domains.\n\n\n\n\n\nSee also\ngetdomain, mapparms\n\nNotes\nEffectively, this implements:\n\n\nwhere\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; old_domain = (-1,1)\n&gt;&gt;&gt; new_domain = (0,2*np.pi)\n&gt;&gt;&gt; x = np.linspace(-1,1,6); x\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])\n&gt;&gt;&gt; x_out = pu.mapdomain(x, old_domain, new_domain); x_out\narray([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary\n        6.28318531])\n&gt;&gt;&gt; x - pu.mapdomain(x_out, new_domain, old_domain)\narray([0., 0., 0., 0., 0., 0.])\n\n\nAlso works for complex numbers (and thus can be used to map any line in\nthe complex plane to any other line therein).\n&gt;&gt;&gt; i = complex(0,1)\n&gt;&gt;&gt; old = (-1 - i, 1 + i)\n&gt;&gt;&gt; new = (-1 + i, 1 - i)\n&gt;&gt;&gt; z = np.linspace(old[0], old[1], 6); z\narray([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])\n&gt;&gt;&gt; new_z = pu.mapdomain(z, old, new); new_z\narray([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary\n\n\n", "parameters": ["Parameters", "xarray_like", "old, newarray_like", "Returns", "x_outndarray"], "returns": "x_outndarrayArray of points of the same shape as x, after application of thelinear map between the two domains.", "examples": ["; from numpy.polynomial import polyutils as pu\n; old_domain = (-1,1)\n; new_domain = (0,2*np.pi)\n; x = np.linspace(-1,1,6); x\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])\n; x_out = pu.mapdomain(x, old_domain, new_domain); x_out\narray([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary\n        6.28318531])\n; x - pu.mapdomain(x_out, new_domain, old_domain)\narray([0., 0., 0., 0., 0., 0.])\n\n", "; from numpy.polynomial import polyutils as pu\n; old_domain = (-1,1)\n; new_domain = (0,2*np.pi)\n; x = np.linspace(-1,1,6); x\narray([-1. , -0.6, -0.2,  0.2,  0.6,  1. ])\n; x_out = pu.mapdomain(x, old_domain, new_domain); x_out\narray([ 0.        ,  1.25663706,  2.51327412,  3.76991118,  5.02654825, # may vary\n        6.28318531])\n; x - pu.mapdomain(x_out, new_domain, old_domain)\narray([0., 0., 0., 0., 0., 0.])\n", "; i = complex(0,1)\n; old = (-1 - i, 1 + i)\n; new = (-1 + i, 1 - i)\n; z = np.linspace(old[0], old[1], 6); z\narray([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])\n; new_z = pu.mapdomain(z, old, new); new_z\narray([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary\n\n", "; i = complex(0,1)\n; old = (-1 - i, 1 + i)\n; new = (-1 + i, 1 - i)\n; z = np.linspace(old[0], old[1], 6); z\narray([-1. -1.j , -0.6-0.6j, -0.2-0.2j,  0.2+0.2j,  0.6+0.6j,  1. +1.j ])\n; new_z = pu.mapdomain(z, old, new); new_z\narray([-1.0+1.j , -0.6+0.6j, -0.2+0.2j,  0.2-0.2j,  0.6-0.6j,  1.0-1.j ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.ma.make_mask_none", "code": "\nnumpy.ma.make_mask_none(newshape, dtype=None)[source]\u00b6", "description": "Return a boolean mask of the given shape, filled with False.\nThis function returns a boolean ndarray with all entries False, that can\nbe used in common mask manipulations. If a complex dtype is specified, the\ntype of each field is converted to a boolean type.\n\nParameters\n\nnewshapetupleA tuple indicating the shape of the mask.\n\ndtype{None, dtype}, optionalIf None, use a MaskType instance. Otherwise, use a new datatype with\nthe same fields as dtype, converted to boolean types.\n\n\n\nReturns\n\nresultndarrayAn ndarray of appropriate shape and dtype, filled with False.\n\n\n\n\n\nSee also\n\nmake_maskCreate a boolean mask from an array.\n\nmake_mask_descrConstruct a dtype description list from a given dtype.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; ma.make_mask_none((3,))\narray([False, False, False])\n\n\nDefining a more complex dtype.\n&gt;&gt;&gt; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n&gt;&gt;&gt; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n&gt;&gt;&gt; ma.make_mask_none((3,), dtype=dtype)\narray([(False, False), (False, False), (False, False)],\n      dtype=[('foo', '|b1'), ('bar', '|b1')])\n\n\n", "parameters": ["Parameters", "newshapetuple", "dtype{None, dtype}, optional", "Returns", "resultndarray"], "returns": "resultndarrayAn ndarray of appropriate shape and dtype, filled with False.", "examples": ["; import numpy.ma as ma\n; ma.make_mask_none((3,))\narray([False, False, False])\n\n", "; import numpy.ma as ma\n; ma.make_mask_none((3,))\narray([False, False, False])\n", "; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n; ma.make_mask_none((3,), dtype=dtype)\narray([(False, False), (False, False), (False, False)],\n      dtype=[('foo', '|b1'), ('bar', '|b1')])\n\n", "; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n; ma.make_mask_none((3,), dtype=dtype)\narray([(False, False), (False, False), (False, False)],\n      dtype=[('foo', '|b1'), ('bar', '|b1')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.make_mask_descr", "code": "\nnumpy.ma.make_mask_descr(ndtype)[source]\u00b6", "description": "Construct a dtype description list from a given dtype.\nReturns a new dtype object, with the type of all fields in ndtype to a\nboolean type. Field names are not altered.\n\nParameters\n\nndtypedtypeThe dtype to convert.\n\n\n\nReturns\n\nresultdtypeA dtype that looks like ndtype, the type of all fields is boolean.\n\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n&gt;&gt;&gt; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n&gt;&gt;&gt; ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n&gt;&gt;&gt; ma.make_mask_descr(np.float32)\ndtype('bool')\n\n\n", "parameters": ["Parameters", "ndtypedtype", "Returns", "resultdtype"], "returns": "resultdtypeA dtype that looks like ndtype, the type of all fields is boolean.", "examples": ["; import numpy.ma as ma\n; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n; ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n; ma.make_mask_descr(np.float32)\ndtype('bool')\n\n", "; import numpy.ma as ma\n; dtype = np.dtype({'names':['foo', 'bar'],\n...                   'formats':[np.float32, np.int64]})\n; dtype\ndtype([('foo', '&lt;f4'), ('bar', '&lt;i8')])\n; ma.make_mask_descr(dtype)\ndtype([('foo', '|b1'), ('bar', '|b1')])\n; ma.make_mask_descr(np.float32)\ndtype('bool')\n"]},
{"library": "numpy", "item_id": "numpy.MachAr", "code": "\nclass numpy.MachAr(float_conv=&lt;class 'float'&gt;, int_conv=&lt;class 'int'&gt;, float_to_float=&lt;class 'float'&gt;, float_to_str=&lt;function MachAr.&lt;lambda&gt;&gt;, title='Python floating point number')[source]\u00b6", "description": "Diagnosing machine parameters.\n\nParameters\n\nfloat_convfunction, optionalFunction that converts an integer or integer array to a float\nor float array. Default is float.\n\nint_convfunction, optionalFunction that converts a float or float array to an integer or\ninteger array. Default is int.\n\nfloat_to_floatfunction, optionalFunction that converts a float array to float. Default is float.\nNote that this does not seem to do anything useful in the current\nimplementation.\n\nfloat_to_strfunction, optionalFunction that converts a single float to a string. Default is\nlambda v:'%24.16e' %v.\n\ntitlestr, optionalTitle that is printed in the string representation of MachAr.\n\n\n\n\n\nSee also\n\nfinfoMachine limits for floating point types.\n\niinfoMachine limits for integer types.\n\n\n\nReferences\n\nRe860718f5533-1\nPress, Teukolsky, Vetterling and Flannery,\n\u201cNumerical Recipes in C++,\u201d 2nd ed,\nCambridge University Press, 2002, p. 31.\n\n\n\nAttributes\n\nibetaintRadix in which numbers are represented.\n\nitintNumber of base-ibeta digits in the floating point mantissa M.\n\nmachepintExponent of the smallest (most negative) power of ibeta that,\nadded to 1.0, gives something different from 1.0\n\nepsfloatFloating-point number beta**machep (floating point precision)\n\nnegepintExponent of the smallest power of ibeta that, subtracted\nfrom 1.0, gives something different from 1.0.\n\nepsnegfloatFloating-point number beta**negep.\n\niexpintNumber of bits in the exponent (including its sign and bias).\n\nminexpintSmallest (most negative) power of ibeta consistent with there\nbeing no leading zeros in the mantissa.\n\nxminfloatFloating point number beta**minexp (the smallest [in\nmagnitude] usable floating value).\n\nmaxexpintSmallest (positive) power of ibeta that causes overflow.\n\nxmaxfloat(1-epsneg) * beta**maxexp (the largest [in magnitude]\nusable floating value).\n\nirndintIn range(6), information on what kind of rounding is done\nin addition, and on how underflow is handled.\n\nngrdintNumber of \u2018guard digits\u2019 used when truncating the product\nof two mantissas to fit the representation.\n\nepsilonfloatSame as eps.\n\ntinyfloatSame as xmin.\n\nhugefloatSame as xmax.\n\nprecisionfloat- int(-log10(eps))\n\nresolutionfloat- 10**(-precision)\n\n\n\n\n", "parameters": ["Parameters", "float_convfunction, optional", "int_convfunction, optional", "float_to_floatfunction, optional", "float_to_strfunction, optional", "titlestr, optional", "Attributes", "ibetaint", "itint", "machepint", "epsfloat", "negepint", "epsnegfloat", "iexpint", "minexpint", "xminfloat", "maxexpint", "xmaxfloat", "irndint", "ngrdint", "epsilonfloat", "tinyfloat", "hugefloat", "precisionfloat", "resolutionfloat"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.lstsq", "code": "\nnumpy.linalg.lstsq(a, b, rcond='warn')[source]\u00b6", "description": "Return the least-squares solution to a linear matrix equation.\nSolves the equation  by computing a vector x that\nminimizes the squared Euclidean 2-norm .\nThe equation may be under-, well-, or over-determined (i.e., the\nnumber of linearly independent rows of a can be less than, equal\nto, or greater than its number of linearly independent columns).\nIf a is square and of full rank, then x (but for round-off error)\nis the \u201cexact\u201d solution of the equation.\n\nParameters\n\na(M, N) array_like\u201cCoefficient\u201d matrix.\n\nb{(M,), (M, K)} array_likeOrdinate or \u201cdependent variable\u201d values. If b is two-dimensional,\nthe least-squares solution is calculated for each of the K columns\nof b.\n\nrcondfloat, optionalCut-off ratio for small singular values of a.\nFor the purposes of rank determination, singular values are treated\nas zero if they are smaller than rcond times the largest singular\nvalue of a.\n\nChanged in version 1.14.0: If not set, a FutureWarning is given. The previous default\nof -1 will use the machine precision as rcond parameter,\nthe new default will use the machine precision times max(M, N).\nTo silence the warning and use the new default, use rcond=None,\nto keep using the old behavior, use rcond=-1.\n\n\n\n\nReturns\n\nx{(N,), (N, K)} ndarrayLeast-squares solution. If b is two-dimensional,\nthe solutions are in the K columns of x.\n\nresiduals{(1,), (K,), (0,)} ndarraySums of residuals; squared Euclidean 2-norm for each column in\nb - a*x.\nIf the rank of a is &lt; N or M &lt;= N, this is an empty array.\nIf b is 1-dimensional, this is a (1,) shape array.\nOtherwise the shape is (K,).\n\nrankintRank of matrix a.\n\ns(min(M, N),) ndarraySingular values of a.\n\n\n\nRaises\n\nLinAlgErrorIf computation does not converge.\n\n\n\n\nNotes\nIf b is a matrix, then all array results are returned as matrices.\nExamples\nFit a line, y = mx + c, through some noisy data-points:\n&gt;&gt;&gt; x = np.array([0, 1, 2, 3])\n&gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])\n\n\nBy examining the coefficients, we see that the line should have a\ngradient of roughly 1 and cut the y-axis at, more or less, -1.\nWe can rewrite the line equation as y = Ap, where A = [[x 1]]\nand p = [[m], [c]].  Now use lstsq to solve for p:\n&gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T\n&gt;&gt;&gt; A\narray([[ 0.,  1.],\n       [ 1.,  1.],\n       [ 2.,  1.],\n       [ 3.,  1.]])\n\n\n&gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]\n&gt;&gt;&gt; m, c\n(1.0 -0.95) # may vary\n\n\nPlot the data along with the fitted line:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; _ = plt.plot(x, y, 'o', label='Original data', markersize=10)\n&gt;&gt;&gt; _ = plt.plot(x, m*x + c, 'r', label='Fitted line')\n&gt;&gt;&gt; _ = plt.legend()\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "a(M, N) array_like", "b{(M,), (M, K)} array_like", "rcondfloat, optional", "Returns", "x{(N,), (N, K)} ndarray", "residuals{(1,), (K,), (0,)} ndarray", "rankint", "s(min(M, N),) ndarray", "Raises", "LinAlgError"], "returns": "x{(N,), (N, K)} ndarrayLeast-squares solution. If b is two-dimensional,the solutions are in the K columns of x.residuals{(1,), (K,), (0,)} ndarraySums of residuals; squared Euclidean 2-norm for each column inb - a*x.If the rank of a is &lt; N or M &lt;= N, this is an empty array.If b is 1-dimensional, this is a (1,) shape array.Otherwise the shape is (K,).rankintRank of matrix a.s(min(M, N),) ndarraySingular values of a.", "examples": ["; x = np.array([0, 1, 2, 3])\n; y = np.array([-1, 0.2, 0.9, 2.1])\n\n", "; x = np.array([0, 1, 2, 3])\n; y = np.array([-1, 0.2, 0.9, 2.1])\n", "; A = np.vstack([x, np.ones(len(x))]).T\n; A\narray([[ 0.,  1.],\n       [ 1.,  1.],\n       [ 2.,  1.],\n       [ 3.,  1.]])\n\n", "; A = np.vstack([x, np.ones(len(x))]).T\n; A\narray([[ 0.,  1.],\n       [ 1.,  1.],\n       [ 2.,  1.],\n       [ 3.,  1.]])\n", "; m, c = np.linalg.lstsq(A, y, rcond=None)[0]\n; m, c\n(1.0 -0.95) # may vary\n\n", "; m, c = np.linalg.lstsq(A, y, rcond=None)[0]\n; m, c\n(1.0 -0.95) # may vary\n", "; import matplotlib.pyplot as plt\n; _ = plt.plot(x, y, 'o', label='Original data', markersize=10)\n; _ = plt.plot(x, m*x + c, 'r', label='Fitted line')\n; _ = plt.legend()\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; _ = plt.plot(x, y, 'o', label='Original data', markersize=10)\n; _ = plt.plot(x, m*x + c, 'r', label='Fitted line')\n; _ = plt.legend()\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.chararray.lstrip", "code": "\nchararray.lstrip(self, chars=None)[source]\u00b6", "description": "For each element in self, return a copy with the leading characters\nremoved.\n\nSee also\nchar.lstrip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.make_mask", "code": "\nnumpy.ma.make_mask(m, copy=False, shrink=True, dtype=&lt;class 'numpy.bool_'&gt;)[source]\u00b6", "description": "Create a boolean mask from an array.\nReturn m as a boolean mask, creating a copy if necessary or requested.\nThe function can accept any sequence that is convertible to integers,\nor nomask.  Does not require that contents must be 0s and 1s, values\nof 0 are interpreted as False, everything else as True.\n\nParameters\n\nmarray_likePotential mask.\n\ncopybool, optionalWhether to return a copy of m (True) or m itself (False).\n\nshrinkbool, optionalWhether to shrink m to nomask if all its values are False.\n\ndtypedtype, optionalData-type of the output mask. By default, the output mask has a\ndtype of MaskType (bool). If the dtype is flexible, each field has\na boolean dtype. This is ignored when m is nomask, in which\ncase nomask is always returned.\n\n\n\nReturns\n\nresultndarrayA boolean mask derived from m.\n\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; m = [True, False, True, True]\n&gt;&gt;&gt; ma.make_mask(m)\narray([ True, False,  True,  True])\n&gt;&gt;&gt; m = [1, 0, 1, 1]\n&gt;&gt;&gt; ma.make_mask(m)\narray([ True, False,  True,  True])\n&gt;&gt;&gt; m = [1, 0, 2, -3]\n&gt;&gt;&gt; ma.make_mask(m)\narray([ True, False,  True,  True])\n\n\nEffect of the shrink parameter.\n&gt;&gt;&gt; m = np.zeros(4)\n&gt;&gt;&gt; m\narray([0., 0., 0., 0.])\n&gt;&gt;&gt; ma.make_mask(m)\nFalse\n&gt;&gt;&gt; ma.make_mask(m, shrink=False)\narray([False, False, False, False])\n\n\nUsing a flexible dtype.\n&gt;&gt;&gt; m = [1, 0, 1, 1]\n&gt;&gt;&gt; n = [0, 1, 0, 0]\n&gt;&gt;&gt; arr = []\n&gt;&gt;&gt; for man, mouse in zip(m, n):\n...     arr.append((man, mouse))\n&gt;&gt;&gt; arr\n[(1, 0), (0, 1), (1, 0), (1, 0)]\n&gt;&gt;&gt; dtype = np.dtype({'names':['man', 'mouse'],\n...                   'formats':[np.int64, np.int64]})\n&gt;&gt;&gt; arr = np.array(arr, dtype=dtype)\n&gt;&gt;&gt; arr\narray([(1, 0), (0, 1), (1, 0), (1, 0)],\n      dtype=[('man', '&lt;i8'), ('mouse', '&lt;i8')])\n&gt;&gt;&gt; ma.make_mask(arr, dtype=dtype)\narray([(True, False), (False, True), (True, False), (True, False)],\n      dtype=[('man', '|b1'), ('mouse', '|b1')])\n\n\n", "parameters": ["Parameters", "marray_like", "copybool, optional", "shrinkbool, optional", "dtypedtype, optional", "Returns", "resultndarray"], "returns": "resultndarrayA boolean mask derived from m.", "examples": ["; import numpy.ma as ma\n; m = [True, False, True, True]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n; m = [1, 0, 1, 1]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n; m = [1, 0, 2, -3]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n\n", "; import numpy.ma as ma\n; m = [True, False, True, True]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n; m = [1, 0, 1, 1]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n; m = [1, 0, 2, -3]\n; ma.make_mask(m)\narray([ True, False,  True,  True])\n", "; m = np.zeros(4)\n; m\narray([0., 0., 0., 0.])\n; ma.make_mask(m)\nFalse\n; ma.make_mask(m, shrink=False)\narray([False, False, False, False])\n\n", "; m = np.zeros(4)\n; m\narray([0., 0., 0., 0.])\n; ma.make_mask(m)\nFalse\n; ma.make_mask(m, shrink=False)\narray([False, False, False, False])\n", "; m = [1, 0, 1, 1]\n; n = [0, 1, 0, 0]\n; arr = []\n; for man, mouse in zip(m, n):\n...     arr.append((man, mouse))\n; arr\n[(1, 0), (0, 1), (1, 0), (1, 0)]\n; dtype = np.dtype({'names':['man', 'mouse'],\n...                   'formats':[np.int64, np.int64]})\n; arr = np.array(arr, dtype=dtype)\n; arr\narray([(1, 0), (0, 1), (1, 0), (1, 0)],\n      dtype=[('man', '&lt;i8'), ('mouse', '&lt;i8')])\n; ma.make_mask(arr, dtype=dtype)\narray([(True, False), (False, True), (True, False), (True, False)],\n      dtype=[('man', '|b1'), ('mouse', '|b1')])\n\n", "; m = [1, 0, 1, 1]\n; n = [0, 1, 0, 0]\n; arr = []\n; for man, mouse in zip(m, n):\n...     arr.append((man, mouse))\n; arr\n[(1, 0), (0, 1), (1, 0), (1, 0)]\n; dtype = np.dtype({'names':['man', 'mouse'],\n...                   'formats':[np.int64, np.int64]})\n; arr = np.array(arr, dtype=dtype)\n; arr\narray([(1, 0), (0, 1), (1, 0), (1, 0)],\n      dtype=[('man', '&lt;i8'), ('mouse', '&lt;i8')])\n; ma.make_mask(arr, dtype=dtype)\narray([(True, False), (False, True), (True, False), (True, False)],\n      dtype=[('man', '|b1'), ('mouse', '|b1')])\n"]},
{"library": "numpy", "item_id": "numpy.char.lstrip", "code": "\nnumpy.char.lstrip(a, chars=None)\u00b6", "description": "For each element in a, return a copy with the leading characters\nremoved.\nCalls str.lstrip element-wise.\n\nParameters\n\naarray-like, {str, unicode}Input array.\n\nchars{str, unicode}, optionalThe chars argument is a string specifying the set of\ncharacters to be removed. If omitted or None, the chars\nargument defaults to removing whitespace. The chars argument\nis not a prefix; rather, all combinations of its values are\nstripped.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.lstrip\n\nExamples\n&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n&gt;&gt;&gt; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n\n\nThe \u2018a\u2019 variable is unstripped from c[1] because whitespace leading.\n&gt;&gt;&gt; np.char.lstrip(c, 'a')\narray(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7')\n\n\n&gt;&gt;&gt; np.char.lstrip(c, 'A') # leaves c unchanged\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n&gt;&gt;&gt; (np.char.lstrip(c, ' ') == np.char.lstrip(c, '')).all()\n... # XXX: is this a regression? This used to return True\n... # np.char.lstrip(c,'') does not modify c at all.\nFalse\n&gt;&gt;&gt; (np.char.lstrip(c, ' ') == np.char.lstrip(c, None)).all()\nTrue\n\n\n", "parameters": ["Parameters", "aarray-like, {str, unicode}", "chars{str, unicode}, optional", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type", "examples": ["; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n\n", "; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n", "; np.char.lstrip(c, 'a')\narray(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7')\n\n", "; np.char.lstrip(c, 'a')\narray(['AaAaA', '  aA  ', 'bBABba'], dtype='&lt;U7')\n", "; np.char.lstrip(c, 'A') # leaves c unchanged\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; (np.char.lstrip(c, ' ') == np.char.lstrip(c, '')).all()\n... # XXX: is this a regression? This used to return True\n... # np.char.lstrip(c,'') does not modify c at all.\nFalse\n; (np.char.lstrip(c, ' ') == np.char.lstrip(c, None)).all()\nTrue\n\n", "; np.char.lstrip(c, 'A') # leaves c unchanged\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; (np.char.lstrip(c, ' ') == np.char.lstrip(c, '')).all()\n... # XXX: is this a regression? This used to return True\n... # np.char.lstrip(c,'') does not modify c at all.\nFalse\n; (np.char.lstrip(c, ' ') == np.char.lstrip(c, None)).all()\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.lstrip", "code": "\nchararray.lstrip(self, chars=None)\u00b6", "description": "For each element in self, return a copy with the leading characters\nremoved.\n\nSee also\nchar.lstrip\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.lower", "code": "\nchararray.lower(self)[source]\u00b6", "description": "Return an array with the elements of self converted to\nlowercase.\n\nSee also\nchar.lower\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.lookfor", "code": "\nnumpy.lookfor(what, module=None, import_modules=True, regenerate=False, output=None)[source]\u00b6", "description": "Do a keyword search on docstrings.\nA list of objects that matched the search is displayed,\nsorted by relevance. All given keywords need to be found in the\ndocstring for it to be returned as a result, but the order does\nnot matter.\n\nParameters\n\nwhatstrString containing words to look for.\n\nmodulestr or list, optionalName of module(s) whose docstrings to go through.\n\nimport_modulesbool, optionalWhether to import sub-modules in packages. Default is True.\n\nregeneratebool, optionalWhether to re-generate the docstring cache. Default is False.\n\noutputfile-like, optionalFile-like object to write the output to. If omitted, use a pager.\n\n\n\n\n\nSee also\nsource, info\n\nNotes\nRelevance is determined only roughly, by checking if the keywords occur\nin the function name, at the start of a docstring, etc.\nExamples\n&gt;&gt;&gt; np.lookfor('binary representation') \nSearch results for 'binary representation'\n------------------------------------------\nnumpy.binary_repr\n    Return the binary representation of the input number as a string.\nnumpy.core.setup_common.long_double_representation\n    Given a binary dump as given by GNU od -b, look for long double\nnumpy.base_repr\n    Return a string representation of a number in the given base system.\n...\n\n\n", "parameters": ["Parameters", "whatstr", "modulestr or list, optional", "import_modulesbool, optional", "regeneratebool, optional", "outputfile-like, optional"], "returns": [], "examples": ["; np.lookfor('binary representation') \nSearch results for 'binary representation'\n------------------------------------------\nnumpy.binary_repr\n    Return the binary representation of the input number as a string.\nnumpy.core.setup_common.long_double_representation\n    Given a binary dump as given by GNU od -b, look for long double\nnumpy.base_repr\n    Return a string representation of a number in the given base system.\n...\n\n", "; np.lookfor('binary representation') \nSearch results for 'binary representation'\n------------------------------------------\nnumpy.binary_repr\n    Return the binary representation of the input number as a string.\nnumpy.core.setup_common.long_double_representation\n    Given a binary dump as given by GNU od -b, look for long double\nnumpy.base_repr\n    Return a string representation of a number in the given base system.\n...\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.lower", "code": "\nchararray.lower(self)\u00b6", "description": "Return an array with the elements of self converted to\nlowercase.\n\nSee also\nchar.lower\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.lower", "code": "\nnumpy.char.lower(a)\u00b6", "description": "Return an array with the elements converted to lowercase.\nCall str.lower element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like, {str, unicode}Input array.\n\n\n\nReturns\n\noutndarray, {str, unicode}Output array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.lower\n\nExamples\n&gt;&gt;&gt; c = np.array(['A1B C', '1BCA', 'BCA1']); c\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n&gt;&gt;&gt; np.char.lower(c)\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n\n\n", "parameters": ["Parameters", "aarray_like, {str, unicode}", "Returns", "outndarray, {str, unicode}"], "returns": "outndarray, {str, unicode}Output array of str or unicode, depending on input type", "examples": ["; c = np.array(['A1B C', '1BCA', 'BCA1']); c\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n; np.char.lower(c)\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n\n", "; c = np.array(['A1B C', '1BCA', 'BCA1']); c\narray(['A1B C', '1BCA', 'BCA1'], dtype='&lt;U5')\n; np.char.lower(c)\narray(['a1b c', '1bca', 'bca1'], dtype='&lt;U5')\n"]},
{"library": "numpy", "item_id": "numpy.logspace", "code": "\nnumpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None, axis=0)[source]\u00b6", "description": "Return numbers spaced evenly on a log scale.\nIn linear space, the sequence starts at base ** start\n(base to the power of start) and ends with base ** stop\n(see endpoint below).\n\nChanged in version 1.16.0: Non-scalar start and stop are now supported.\n\n\nParameters\n\nstartarray_likebase ** start is the starting value of the sequence.\n\nstoparray_likebase ** stop is the final value of the sequence, unless endpoint\nis False.  In that case, num + 1 values are spaced over the\ninterval in log-space, of which all but the last (a sequence of\nlength num) are returned.\n\nnuminteger, optionalNumber of samples to generate.  Default is 50.\n\nendpointboolean, optionalIf true, stop is the last sample. Otherwise, it is not included.\nDefault is True.\n\nbasefloat, optionalThe base of the log space. The step size between the elements in\nln(samples) / ln(base) (or log_base(samples)) is uniform.\nDefault is 10.0.\n\ndtypedtypeThe type of the output array.  If dtype is not given, infer the data\ntype from the other input arguments.\n\naxisint, optionalThe axis in the result to store the samples.  Relevant only if start\nor stop are array-like.  By default (0), the samples will be along a\nnew axis inserted at the beginning. Use -1 to get an axis at the end.\n\nNew in version 1.16.0.\n\n\n\n\nReturns\n\nsamplesndarraynum samples, equally spaced on a log scale.\n\n\n\n\n\nSee also\n\narangeSimilar to linspace, with the step size specified instead of the number of samples. Note that, when used with a float endpoint, the endpoint may or may not be included.\n\nlinspaceSimilar to logspace, but with the samples uniformly distributed in linear space, instead of log space.\n\ngeomspaceSimilar to logspace, but with endpoints specified directly.\n\n\n\nNotes\nLogspace is equivalent to the code\n&gt;&gt;&gt; y = np.linspace(start, stop, num=num, endpoint=endpoint)\n... \n&gt;&gt;&gt; power(base, y).astype(dtype)\n... \n\n\nExamples\n&gt;&gt;&gt; np.logspace(2.0, 3.0, num=4)\narray([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])\n&gt;&gt;&gt; np.logspace(2.0, 3.0, num=4, endpoint=False)\narray([100.        ,  177.827941  ,  316.22776602,  562.34132519])\n&gt;&gt;&gt; np.logspace(2.0, 3.0, num=4, base=2.0)\narray([4.        ,  5.0396842 ,  6.34960421,  8.        ])\n\n\nGraphical illustration:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; N = 10\n&gt;&gt;&gt; x1 = np.logspace(0.1, 1, N, endpoint=True)\n&gt;&gt;&gt; x2 = np.logspace(0.1, 1, N, endpoint=False)\n&gt;&gt;&gt; y = np.zeros(N)\n&gt;&gt;&gt; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.ylim([-0.5, 1])\n(-0.5, 1)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "startarray_like", "stoparray_like", "numinteger, optional", "endpointboolean, optional", "basefloat, optional", "dtypedtype", "axisint, optional", "Returns", "samplesndarray"], "returns": "samplesndarraynum samples, equally spaced on a log scale.", "examples": ["; np.logspace(2.0, 3.0, num=4)\narray([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])\n; np.logspace(2.0, 3.0, num=4, endpoint=False)\narray([100.        ,  177.827941  ,  316.22776602,  562.34132519])\n; np.logspace(2.0, 3.0, num=4, base=2.0)\narray([4.        ,  5.0396842 ,  6.34960421,  8.        ])\n\n", "; np.logspace(2.0, 3.0, num=4)\narray([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])\n; np.logspace(2.0, 3.0, num=4, endpoint=False)\narray([100.        ,  177.827941  ,  316.22776602,  562.34132519])\n; np.logspace(2.0, 3.0, num=4, base=2.0)\narray([4.        ,  5.0396842 ,  6.34960421,  8.        ])\n", "; import matplotlib.pyplot as plt\n; N = 10\n; x1 = np.logspace(0.1, 1, N, endpoint=True)\n; x2 = np.logspace(0.1, 1, N, endpoint=False)\n; y = np.zeros(N)\n; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.ylim([-0.5, 1])\n(-0.5, 1)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; N = 10\n; x1 = np.logspace(0.1, 1, N, endpoint=True)\n; x2 = np.logspace(0.1, 1, N, endpoint=False)\n; y = np.zeros(N)\n; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.ylim([-0.5, 1])\n(-0.5, 1)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.logseries", "code": "\nRandomState.logseries(p, size=None)\u00b6", "description": "Draw samples from a logarithmic series distribution.\nSamples are drawn from a log series distribution with specified\nshape parameter, 0 &lt; p &lt; 1.\n\nNote\nNew code should use the logseries method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\npfloat or array_like of floatsShape parameter for the distribution.  Must be in the range (0, 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logarithmic series distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logserprobability density function, distribution or cumulative density function, etc.\n\nGenerator.logserieswhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Log Series distribution is\n\n\nwhere p = probability.\nThe log series distribution is frequently used to represent species\nrichness and occurrence, first proposed by Fisher, Corbet, and\nWilliams in 1943 [2].  It may also be used to model the numbers of\noccupants seen in cars [3].\nReferences\n\n1\nBuzas, Martin A.; Culver, Stephen J.,  Understanding regional\nspecies diversity through the log series distribution of\noccurrences: BIODIVERSITY RESEARCH Diversity &amp; Distributions,\nVolume 5, Number 5, September 1999 , pp. 187-195(9).\n\n2\nFisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\nrelation between the number of species and the number of\nindividuals in a random sample of an animal population.\nJournal of Animal Ecology, 12:42-58.\n\n3\nD. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\nData Sets, CRC Press, 1994.\n\n4\nWikipedia, \u201cLogarithmic distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logarithmic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = .6\n&gt;&gt;&gt; s = np.random.logseries(a, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n&gt;&gt;&gt; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logarithmic series distribution.", "examples": ["; a = .6\n; s = np.random.logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n\n", "; a = .6\n; s = np.random.logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.logseries", "code": "\nGenerator.logseries(p, size=None)\u00b6", "description": "Draw samples from a logarithmic series distribution.\nSamples are drawn from a log series distribution with specified\nshape parameter, 0 &lt; p &lt; 1.\n\nParameters\n\npfloat or array_like of floatsShape parameter for the distribution.  Must be in the range (0, 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logarithmic series distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logserprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability mass function for the Log Series distribution is\n\n\nwhere p = probability.\nThe log series distribution is frequently used to represent species\nrichness and occurrence, first proposed by Fisher, Corbet, and\nWilliams in 1943 [2].  It may also be used to model the numbers of\noccupants seen in cars [3].\nReferences\n\n1\nBuzas, Martin A.; Culver, Stephen J.,  Understanding regional\nspecies diversity through the log series distribution of\noccurrences: BIODIVERSITY RESEARCH Diversity &amp; Distributions,\nVolume 5, Number 5, September 1999 , pp. 187-195(9).\n\n2\nFisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\nrelation between the number of species and the number of\nindividuals in a random sample of an animal population.\nJournal of Animal Ecology, 12:42-58.\n\n3\nD. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\nData Sets, CRC Press, 1994.\n\n4\nWikipedia, \u201cLogarithmic distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logarithmic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = .6\n&gt;&gt;&gt; s = np.random.default_rng().logseries(a, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n&gt;&gt;&gt; plt.plot(bins, logseries(bins, a) * count.max()/\n...          logseries(bins, a).max(), 'r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logarithmic series distribution.", "examples": ["; a = .6\n; s = np.random.default_rng().logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n\n", "; a = .6\n; s = np.random.default_rng().logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a) * count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a) * count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.logseries", "code": "\nnumpy.random.logseries(p, size=None)\u00b6", "description": "Draw samples from a logarithmic series distribution.\nSamples are drawn from a log series distribution with specified\nshape parameter, 0 &lt; p &lt; 1.\n\nNote\nNew code should use the logseries method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\npfloat or array_like of floatsShape parameter for the distribution.  Must be in the range (0, 1).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logarithmic series distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logserprobability density function, distribution or cumulative density function, etc.\n\nGenerator.logserieswhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Log Series distribution is\n\n\nwhere p = probability.\nThe log series distribution is frequently used to represent species\nrichness and occurrence, first proposed by Fisher, Corbet, and\nWilliams in 1943 [2].  It may also be used to model the numbers of\noccupants seen in cars [3].\nReferences\n\n1\nBuzas, Martin A.; Culver, Stephen J.,  Understanding regional\nspecies diversity through the log series distribution of\noccurrences: BIODIVERSITY RESEARCH Diversity &amp; Distributions,\nVolume 5, Number 5, September 1999 , pp. 187-195(9).\n\n2\nFisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The\nrelation between the number of species and the number of\nindividuals in a random sample of an animal population.\nJournal of Animal Ecology, 12:42-58.\n\n3\nD. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small\nData Sets, CRC Press, 1994.\n\n4\nWikipedia, \u201cLogarithmic distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logarithmic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; a = .6\n&gt;&gt;&gt; s = np.random.logseries(a, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n&gt;&gt;&gt; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logarithmic series distribution.", "examples": ["; a = .6\n; s = np.random.logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n\n", "; a = .6\n; s = np.random.logseries(a, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s)\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n\n", "; def logseries(k, p):\n...     return -p**k/(k*np.log(1-p))\n; plt.plot(bins, logseries(bins, a)*count.max()/\n...          logseries(bins, a).max(), 'r')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.lognormal", "code": "\nRandomState.lognormal(mean=0.0, sigma=1.0, size=None)\u00b6", "description": "Draw samples from a log-normal distribution.\nDraw samples from a log-normal distribution with specified mean,\nstandard deviation, and array shape.  Note that the mean and standard\ndeviation are not the values for the distribution itself, but of the\nunderlying normal distribution it is derived from.\n\nNote\nNew code should use the lognormal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmeanfloat or array_like of floats, optionalMean value of the underlying normal distribution. Default is 0.\n\nsigmafloat or array_like of floats, optionalStandard deviation of the underlying normal distribution. Must be\nnon-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and sigma are both scalars.\nOtherwise, np.broadcast(mean, sigma).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized log-normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lognormprobability density function, distribution, cumulative density function, etc.\n\nGenerator.lognormalwhich should be used for new code.\n\n\n\nNotes\nA variable x has a log-normal distribution if log(x) is normally\ndistributed.  The probability density function for the log-normal\ndistribution is:\n\n\nwhere  is the mean and  is the standard\ndeviation of the normally distributed logarithm of the variable.\nA log-normal distribution results if a random variable is the product\nof a large number of independent, identically-distributed variables in\nthe same way that a normal distribution results if the variable is the\nsum of a large number of independent, identically-distributed\nvariables.\nReferences\n\n1\nLimpert, E., Stahel, W. A., and Abbt, M., \u201cLog-normal\nDistributions across the Sciences: Keys and Clues,\u201d\nBioScience, Vol. 51, No. 5, May, 2001.\nhttps://stat.ethz.ch/~stahel/lognormal/bioscience.pdf\n\n2\nReiss, R.D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues,\u201d Basel: Birkhauser Verlag, 2001, pp. 31-32.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, sigma = 3., 1. # mean and standard deviation\n&gt;&gt;&gt; s = np.random.lognormal(mu, sigma, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, linewidth=2, color='r')\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate that taking the products of random samples from a uniform\ndistribution can be fit well by a log-normal probability density\nfunction.\n&gt;&gt;&gt; # Generate a thousand samples: each is the product of 100 random\n&gt;&gt;&gt; # values, drawn from a normal distribution.\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n\n\n&gt;&gt;&gt; b = np.array(b) / np.min(b) # scale values to be positive\n&gt;&gt;&gt; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n&gt;&gt;&gt; sigma = np.std(np.log(b))\n&gt;&gt;&gt; mu = np.mean(np.log(b))\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, color='r', linewidth=2)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats, optional", "sigmafloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized log-normal distribution.", "examples": ["; mu, sigma = 3., 1. # mean and standard deviation\n; s = np.random.lognormal(mu, sigma, 1000)\n\n", "; mu, sigma = 3., 1. # mean and standard deviation\n; s = np.random.lognormal(mu, sigma, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; b = []\n; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; b = []\n; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.lognormal", "code": "\nGenerator.lognormal(mean=0.0, sigma=1.0, size=None)\u00b6", "description": "Draw samples from a log-normal distribution.\nDraw samples from a log-normal distribution with specified mean,\nstandard deviation, and array shape.  Note that the mean and standard\ndeviation are not the values for the distribution itself, but of the\nunderlying normal distribution it is derived from.\n\nParameters\n\nmeanfloat or array_like of floats, optionalMean value of the underlying normal distribution. Default is 0.\n\nsigmafloat or array_like of floats, optionalStandard deviation of the underlying normal distribution. Must be\nnon-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and sigma are both scalars.\nOtherwise, np.broadcast(mean, sigma).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized log-normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lognormprobability density function, distribution, cumulative density function, etc.\n\n\n\nNotes\nA variable x has a log-normal distribution if log(x) is normally\ndistributed.  The probability density function for the log-normal\ndistribution is:\n\n\nwhere  is the mean and  is the standard\ndeviation of the normally distributed logarithm of the variable.\nA log-normal distribution results if a random variable is the product\nof a large number of independent, identically-distributed variables in\nthe same way that a normal distribution results if the variable is the\nsum of a large number of independent, identically-distributed\nvariables.\nReferences\n\n1\nLimpert, E., Stahel, W. A., and Abbt, M., \u201cLog-normal\nDistributions across the Sciences: Keys and Clues,\u201d\nBioScience, Vol. 51, No. 5, May, 2001.\nhttps://stat.ethz.ch/~stahel/lognormal/bioscience.pdf\n\n2\nReiss, R.D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues,\u201d Basel: Birkhauser Verlag, 2001, pp. 31-32.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; mu, sigma = 3., 1. # mean and standard deviation\n&gt;&gt;&gt; s = rng.lognormal(mu, sigma, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, linewidth=2, color='r')\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate that taking the products of random samples from a uniform\ndistribution can be fit well by a log-normal probability density\nfunction.\n&gt;&gt;&gt; # Generate a thousand samples: each is the product of 100 random\n&gt;&gt;&gt; # values, drawn from a normal distribution.\n&gt;&gt;&gt; rng = rng\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; for i in range(1000):\n...    a = 10. + rng.standard_normal(100)\n...    b.append(np.product(a))\n\n\n&gt;&gt;&gt; b = np.array(b) / np.min(b) # scale values to be positive\n&gt;&gt;&gt; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n&gt;&gt;&gt; sigma = np.std(np.log(b))\n&gt;&gt;&gt; mu = np.mean(np.log(b))\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, color='r', linewidth=2)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats, optional", "sigmafloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized log-normal distribution.", "examples": ["; rng = np.random.default_rng()\n; mu, sigma = 3., 1. # mean and standard deviation\n; s = rng.lognormal(mu, sigma, 1000)\n\n", "; rng = np.random.default_rng()\n; mu, sigma = 3., 1. # mean and standard deviation\n; s = rng.lognormal(mu, sigma, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; rng = rng\n; b = []\n; for i in range(1000):\n...    a = 10. + rng.standard_normal(100)\n...    b.append(np.product(a))\n\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; rng = rng\n; b = []\n; for i in range(1000):\n...    a = 10. + rng.standard_normal(100)\n...    b.append(np.product(a))\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.logistic", "code": "\nRandomState.logistic(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a logistic distribution.\nSamples are drawn from a logistic distribution with specified\nparameters, loc (location or mean, also median), and scale (&gt;0).\n\nNote\nNew code should use the logistic method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalParameter of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalParameter of the distribution. Must be non-negative.\nDefault is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logistic distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logisticprobability density function, distribution or cumulative density function, etc.\n\nGenerator.logisticwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Logistic distribution is\n\n\nwhere  = location and  = scale.\nThe Logistic distribution is used in Extreme Value problems where it\ncan act as a mixture of Gumbel distributions, in Epidemiology, and by\nthe World Chess Federation (FIDE) where it is used in the Elo ranking\nsystem, assuming the performance of each player is a logistically\ndistributed random variable.\nReferences\n\n1\nReiss, R.-D. and Thomas M. (2001), \u201cStatistical Analysis of\nExtreme Values, from Insurance, Finance, Hydrology and Other\nFields,\u201d Birkhauser Verlag, Basel, pp 132-133.\n\n2\nWeisstein, Eric W. \u201cLogistic Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LogisticDistribution.html\n\n3\nWikipedia, \u201cLogistic-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logistic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; loc, scale = 10, 1\n&gt;&gt;&gt; s = np.random.logistic(loc, scale, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=50)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n&gt;&gt;&gt; lgst_val = logist(bins, loc, scale)\n&gt;&gt;&gt; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logistic distribution.", "examples": ["; loc, scale = 10, 1\n; s = np.random.logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n\n", "; loc, scale = 10, 1\n; s = np.random.logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.lognormal", "code": "\nnumpy.random.lognormal(mean=0.0, sigma=1.0, size=None)\u00b6", "description": "Draw samples from a log-normal distribution.\nDraw samples from a log-normal distribution with specified mean,\nstandard deviation, and array shape.  Note that the mean and standard\ndeviation are not the values for the distribution itself, but of the\nunderlying normal distribution it is derived from.\n\nNote\nNew code should use the lognormal method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nmeanfloat or array_like of floats, optionalMean value of the underlying normal distribution. Default is 0.\n\nsigmafloat or array_like of floats, optionalStandard deviation of the underlying normal distribution. Must be\nnon-negative. Default is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if mean and sigma are both scalars.\nOtherwise, np.broadcast(mean, sigma).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized log-normal distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.lognormprobability density function, distribution, cumulative density function, etc.\n\nGenerator.lognormalwhich should be used for new code.\n\n\n\nNotes\nA variable x has a log-normal distribution if log(x) is normally\ndistributed.  The probability density function for the log-normal\ndistribution is:\n\n\nwhere  is the mean and  is the standard\ndeviation of the normally distributed logarithm of the variable.\nA log-normal distribution results if a random variable is the product\nof a large number of independent, identically-distributed variables in\nthe same way that a normal distribution results if the variable is the\nsum of a large number of independent, identically-distributed\nvariables.\nReferences\n\n1\nLimpert, E., Stahel, W. A., and Abbt, M., \u201cLog-normal\nDistributions across the Sciences: Keys and Clues,\u201d\nBioScience, Vol. 51, No. 5, May, 2001.\nhttps://stat.ethz.ch/~stahel/lognormal/bioscience.pdf\n\n2\nReiss, R.D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues,\u201d Basel: Birkhauser Verlag, 2001, pp. 31-32.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, sigma = 3., 1. # mean and standard deviation\n&gt;&gt;&gt; s = np.random.lognormal(mu, sigma, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, linewidth=2, color='r')\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nDemonstrate that taking the products of random samples from a uniform\ndistribution can be fit well by a log-normal probability density\nfunction.\n&gt;&gt;&gt; # Generate a thousand samples: each is the product of 100 random\n&gt;&gt;&gt; # values, drawn from a normal distribution.\n&gt;&gt;&gt; b = []\n&gt;&gt;&gt; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n\n\n&gt;&gt;&gt; b = np.array(b) / np.min(b) # scale values to be positive\n&gt;&gt;&gt; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n&gt;&gt;&gt; sigma = np.std(np.log(b))\n&gt;&gt;&gt; mu = np.mean(np.log(b))\n\n\n&gt;&gt;&gt; x = np.linspace(min(bins), max(bins), 10000)\n&gt;&gt;&gt; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n\n&gt;&gt;&gt; plt.plot(x, pdf, color='r', linewidth=2)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "meanfloat or array_like of floats, optional", "sigmafloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized log-normal distribution.", "examples": ["; mu, sigma = 3., 1. # mean and standard deviation\n; s = np.random.lognormal(mu, sigma, 1000)\n\n", "; mu, sigma = 3., 1. # mean and standard deviation\n; s = np.random.lognormal(mu, sigma, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 100, density=True, align='mid')\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n\n", "; plt.plot(x, pdf, linewidth=2, color='r')\n; plt.axis('tight')\n; plt.show()\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; b = []\n; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n\n", "; # Generate a thousand samples: each is the product of 100 random\n; # values, drawn from a normal distribution.\n; b = []\n; for i in range(1000):\n...    a = 10. + np.random.standard_normal(100)\n...    b.append(np.product(a))\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n\n", "; b = np.array(b) / np.min(b) # scale values to be positive\n; count, bins, ignored = plt.hist(b, 100, density=True, align='mid')\n; sigma = np.std(np.log(b))\n; mu = np.mean(np.log(b))\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n\n", "; x = np.linspace(min(bins), max(bins), 10000)\n; pdf = (np.exp(-(np.log(x) - mu)**2 / (2 * sigma**2))\n...        / (x * sigma * np.sqrt(2 * np.pi)))\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n\n", "; plt.plot(x, pdf, color='r', linewidth=2)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.logical_not", "code": "\nnumpy.logical_not(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logical_not'&gt;\u00b6", "description": "Compute the truth value of NOT x element-wise.\n\nParameters\n\nxarray_likeLogical NOT is applied to the elements of x.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nybool or ndarray of boolBoolean result with the same shape as x of the NOT operation\non elements of x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nlogical_and, logical_or, logical_xor\n\nExamples\n&gt;&gt;&gt; np.logical_not(3)\nFalse\n&gt;&gt;&gt; np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.logical_not(x&lt;3)\narray([False, False, False,  True,  True])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "ybool or ndarray of bool"], "returns": "ybool or ndarray of boolBoolean result with the same shape as x of the NOT operationon elements of x.This is a scalar if x is a scalar.", "examples": ["; np.logical_not(3)\nFalse\n; np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n\n", "; np.logical_not(3)\nFalse\n; np.logical_not([True, False, 0, 1])\narray([False,  True,  True, False])\n", "; x = np.arange(5)\n; np.logical_not(x&lt;3)\narray([False, False, False,  True,  True])\n\n", "; x = np.arange(5)\n; np.logical_not(x&lt;3)\narray([False, False, False,  True,  True])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.logistic", "code": "\nGenerator.logistic(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a logistic distribution.\nSamples are drawn from a logistic distribution with specified\nparameters, loc (location or mean, also median), and scale (&gt;0).\n\nParameters\n\nlocfloat or array_like of floats, optionalParameter of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalParameter of the distribution. Must be non-negative.\nDefault is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logistic distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logisticprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Logistic distribution is\n\n\nwhere  = location and  = scale.\nThe Logistic distribution is used in Extreme Value problems where it\ncan act as a mixture of Gumbel distributions, in Epidemiology, and by\nthe World Chess Federation (FIDE) where it is used in the Elo ranking\nsystem, assuming the performance of each player is a logistically\ndistributed random variable.\nReferences\n\n1\nReiss, R.-D. and Thomas M. (2001), \u201cStatistical Analysis of\nExtreme Values, from Insurance, Finance, Hydrology and Other\nFields,\u201d Birkhauser Verlag, Basel, pp 132-133.\n\n2\nWeisstein, Eric W. \u201cLogistic Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LogisticDistribution.html\n\n3\nWikipedia, \u201cLogistic-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logistic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; loc, scale = 10, 1\n&gt;&gt;&gt; s = np.random.default_rng().logistic(loc, scale, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=50)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n&gt;&gt;&gt; lgst_val = logist(bins, loc, scale)\n&gt;&gt;&gt; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logistic distribution.", "examples": ["; loc, scale = 10, 1\n; s = np.random.default_rng().logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n\n", "; loc, scale = 10, 1\n; s = np.random.default_rng().logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.logistic", "code": "\nnumpy.random.logistic(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a logistic distribution.\nSamples are drawn from a logistic distribution with specified\nparameters, loc (location or mean, also median), and scale (&gt;0).\n\nNote\nNew code should use the logistic method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalParameter of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalParameter of the distribution. Must be non-negative.\nDefault is 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized logistic distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.logisticprobability density function, distribution or cumulative density function, etc.\n\nGenerator.logisticwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Logistic distribution is\n\n\nwhere  = location and  = scale.\nThe Logistic distribution is used in Extreme Value problems where it\ncan act as a mixture of Gumbel distributions, in Epidemiology, and by\nthe World Chess Federation (FIDE) where it is used in the Elo ranking\nsystem, assuming the performance of each player is a logistically\ndistributed random variable.\nReferences\n\n1\nReiss, R.-D. and Thomas M. (2001), \u201cStatistical Analysis of\nExtreme Values, from Insurance, Finance, Hydrology and Other\nFields,\u201d Birkhauser Verlag, Basel, pp 132-133.\n\n2\nWeisstein, Eric W. \u201cLogistic Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LogisticDistribution.html\n\n3\nWikipedia, \u201cLogistic-distribution\u201d,\nhttps://en.wikipedia.org/wiki/Logistic_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; loc, scale = 10, 1\n&gt;&gt;&gt; s = np.random.logistic(loc, scale, 10000)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, bins=50)\n\n\n#   plot against distribution\n&gt;&gt;&gt; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n&gt;&gt;&gt; lgst_val = logist(bins, loc, scale)\n&gt;&gt;&gt; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized logistic distribution.", "examples": ["; loc, scale = 10, 1\n; s = np.random.logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n\n", "; loc, scale = 10, 1\n; s = np.random.logistic(loc, scale, 10000)\n; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, bins=50)\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n\n", "; def logist(x, loc, scale):\n...     return np.exp((loc-x)/scale)/(scale*(1+np.exp((loc-x)/scale))**2)\n; lgst_val = logist(bins, loc, scale)\n; plt.plot(bins, lgst_val * count.max() / lgst_val.max())\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.logical_xor", "code": "\nnumpy.logical_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logical_xor'&gt;\u00b6", "description": "Compute the truth value of x1 XOR x2, element-wise.\n\nParameters\n\nx1, x2array_likeLogical XOR is applied to the elements of x1 and x2. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nybool or ndarray of boolBoolean result of the logical XOR operation applied to the elements\nof x1 and x2; the shape is determined by broadcasting.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_and, logical_or, logical_not, bitwise_xor\n\nExamples\n&gt;&gt;&gt; np.logical_xor(True, False)\nTrue\n&gt;&gt;&gt; np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.logical_xor(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n\n\nSimple example showing support of broadcasting\n&gt;&gt;&gt; np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "ybool or ndarray of bool"], "returns": "ybool or ndarray of boolBoolean result of the logical XOR operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.logical_xor(True, False)\nTrue\n; np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n\n", "; np.logical_xor(True, False)\nTrue\n; np.logical_xor([True, True, False, False], [True, False, True, False])\narray([False,  True,  True, False])\n", "; x = np.arange(5)\n; np.logical_xor(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n\n", "; x = np.arange(5)\n; np.logical_xor(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n", "; np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])\n\n", "; np.logical_xor(0, np.eye(2))\narray([[ True, False],\n       [False,  True]])\n"]},
{"library": "numpy", "item_id": "numpy.logical_or", "code": "\nnumpy.logical_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logical_or'&gt;\u00b6", "description": "Compute the truth value of x1 OR x2 element-wise.\n\nParameters\n\nx1, x2array_likeLogical OR is applied to the elements of x1 and x2.\nIf x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or boolBoolean result of the logical OR operation applied to the elements\nof x1 and x2; the shape is determined by broadcasting.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_and, logical_not, logical_xor, bitwise_or\n\nExamples\n&gt;&gt;&gt; np.logical_or(True, False)\nTrue\n&gt;&gt;&gt; np.logical_or([True, False], [False, False])\narray([ True, False])\n\n\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.logical_or(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or bool"], "returns": "yndarray or boolBoolean result of the logical OR operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.logical_or(True, False)\nTrue\n; np.logical_or([True, False], [False, False])\narray([ True, False])\n\n", "; np.logical_or(True, False)\nTrue\n; np.logical_or([True, False], [False, False])\narray([ True, False])\n", "; x = np.arange(5)\n; np.logical_or(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n\n", "; x = np.arange(5)\n; np.logical_or(x &lt; 1, x &gt; 3)\narray([ True, False, False, False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.logical_and", "code": "\nnumpy.logical_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logical_and'&gt;\u00b6", "description": "Compute the truth value of x1 AND x2 element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or boolBoolean result of the logical AND operation applied to the elements\nof x1 and x2; the shape is determined by broadcasting.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_or, logical_not, logical_xor, bitwise_and\n\nExamples\n&gt;&gt;&gt; np.logical_and(True, False)\nFalse\n&gt;&gt;&gt; np.logical_and([True, False], [False, False])\narray([False, False])\n\n\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.logical_and(x&gt;1, x&lt;4)\narray([False, False,  True,  True, False])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or bool"], "returns": "yndarray or boolBoolean result of the logical AND operation applied to the elementsof x1 and x2; the shape is determined by broadcasting.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.logical_and(True, False)\nFalse\n; np.logical_and([True, False], [False, False])\narray([False, False])\n\n", "; np.logical_and(True, False)\nFalse\n; np.logical_and([True, False], [False, False])\narray([False, False])\n", "; x = np.arange(5)\n; np.logical_and(x&gt;1, x&lt;4)\narray([False, False,  True,  True, False])\n\n", "; x = np.arange(5)\n; np.logical_and(x&gt;1, x&lt;4)\narray([False, False,  True,  True, False])\n"]},
{"library": "numpy", "item_id": "numpy.logaddexp2", "code": "\nnumpy.logaddexp2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logaddexp2'&gt;\u00b6", "description": "Logarithm of the sum of exponentiations of the inputs in base-2.\nCalculates log2(2**x1 + 2**x2). This function is useful in machine\nlearning when the calculated probabilities of events may be so small as\nto exceed the range of normal floating point numbers.  In such cases\nthe base-2 logarithm of the calculated probability can be used instead.\nThis function allows adding probabilities stored in such a fashion.\n\nParameters\n\nx1, x2array_likeInput values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nresultndarrayBase-2 logarithm of 2**x1 + 2**x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nlogaddexpLogarithm of the sum of exponentiations of the inputs.\n\n\n\nNotes\n\nNew in version 1.3.0.\n\nExamples\n&gt;&gt;&gt; prob1 = np.log2(1e-50)\n&gt;&gt;&gt; prob2 = np.log2(2.5e-50)\n&gt;&gt;&gt; prob12 = np.logaddexp2(prob1, prob2)\n&gt;&gt;&gt; prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n&gt;&gt;&gt; 2**prob12\n3.4999999999999914e-50\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "resultndarray"], "returns": "resultndarrayBase-2 logarithm of 2**x1 + 2**x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; prob1 = np.log2(1e-50)\n; prob2 = np.log2(2.5e-50)\n; prob12 = np.logaddexp2(prob1, prob2)\n; prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n; 2**prob12\n3.4999999999999914e-50\n\n", "; prob1 = np.log2(1e-50)\n; prob2 = np.log2(2.5e-50)\n; prob12 = np.logaddexp2(prob1, prob2)\n; prob1, prob2, prob12\n(-166.09640474436813, -164.77447664948076, -164.28904982231052)\n; 2**prob12\n3.4999999999999914e-50\n"]},
{"library": "numpy", "item_id": "numpy.log10", "code": "\nnumpy.log10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'log10'&gt;\u00b6", "description": "Return the base 10 logarithm of the input array, element-wise.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe logarithm to the base 10 of x, element-wise. NaNs are\nreturned where x is negative.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nemath.log10\n\nNotes\nLogarithm is a multivalued function: for each x there is an infinite\nnumber of z such that 10**z = x. The convention is to return the\nz whose imaginary part lies in [-pi, pi].\nFor real-valued input data types, log10 always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, log10 is a complex analytical function that\nhas a branch cut [-inf, 0] and is continuous from above on it.\nlog10 handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cLogarithm\u201d. https://en.wikipedia.org/wiki/Logarithm\n\n\nExamples\n&gt;&gt;&gt; np.log10([1e-15, -3.])\narray([-15.,  nan])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe logarithm to the base 10 of x, element-wise. NaNs arereturned where x is negative.This is a scalar if x is a scalar.", "examples": ["; np.log10([1e-15, -3.])\narray([-15.,  nan])\n\n", "; np.log10([1e-15, -3.])\narray([-15.,  nan])\n"]},
{"library": "numpy", "item_id": "numpy.log", "code": "\nnumpy.log(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'log'&gt;\u00b6", "description": "Natural logarithm, element-wise.\nThe natural logarithm log is the inverse of the exponential function,\nso that log(exp(x)) = x. The natural logarithm is logarithm in base\ne.\n\nParameters\n\nxarray_likeInput value.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe natural logarithm of x, element-wise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nlog10, log2, log1p, emath.log\n\nNotes\nLogarithm is a multivalued function: for each x there is an infinite\nnumber of z such that exp(z) = x. The convention is to return the\nz whose imaginary part lies in [-pi, pi].\nFor real-valued input data types, log always returns real output. For\neach value that cannot be expressed as a real number or infinity, it\nyields nan and sets the invalid floating point error flag.\nFor complex-valued input, log is a complex analytical function that\nhas a branch cut [-inf, 0] and is continuous from above on it. log\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cLogarithm\u201d. https://en.wikipedia.org/wiki/Logarithm\n\n\nExamples\n&gt;&gt;&gt; np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe natural logarithm of x, element-wise.This is a scalar if x is a scalar.", "examples": ["; np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])\n\n", "; np.log([1, np.e, np.e**2, 0])\narray([  0.,   1.,   2., -Inf])\n"]},
{"library": "numpy", "item_id": "numpy.log2", "code": "\nnumpy.log2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'log2'&gt;\u00b6", "description": "Base-2 logarithm of x.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayBase-2 logarithm of x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nlog, log10, log1p, emath.log2\n\nNotes\n\nNew in version 1.3.0.\n\nLogarithm is a multivalued function: for each x there is an infinite\nnumber of z such that 2**z = x. The convention is to return the z\nwhose imaginary part lies in [-pi, pi].\nFor real-valued input data types, log2 always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, log2 is a complex analytical function that\nhas a branch cut [-inf, 0] and is continuous from above on it. log2\nhandles the floating-point negative zero as an infinitesimal negative\nnumber, conforming to the C99 standard.\nExamples\n&gt;&gt;&gt; x = np.array([0, 1, 2, 2**4])\n&gt;&gt;&gt; np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n\n&gt;&gt;&gt; xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n&gt;&gt;&gt; np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayBase-2 logarithm of x.This is a scalar if x is a scalar.", "examples": ["; x = np.array([0, 1, 2, 2**4])\n; np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n\n", "; x = np.array([0, 1, 2, 2**4])\n; np.log2(x)\narray([-Inf,   0.,   1.,   4.])\n", "; xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n; np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])\n\n", "; xi = np.array([0+1.j, 1, 2+0.j, 4.j])\n; np.log2(xi)\narray([ 0.+2.26618007j,  0.+0.j        ,  1.+0.j        ,  2.+2.26618007j])\n"]},
{"library": "numpy", "item_id": "numpy.logaddexp", "code": "\nnumpy.logaddexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'logaddexp'&gt;\u00b6", "description": "Logarithm of the sum of exponentiations of the inputs.\nCalculates log(exp(x1) + exp(x2)). This function is useful in\nstatistics where the calculated probabilities of events may be so small\nas to exceed the range of normal floating point numbers.  In such cases\nthe logarithm of the calculated probability is stored. This function\nallows adding probabilities stored in such a fashion.\n\nParameters\n\nx1, x2array_likeInput values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nresultndarrayLogarithm of exp(x1) + exp(x2).\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nlogaddexp2Logarithm of the sum of exponentiations of inputs in base 2.\n\n\n\nNotes\n\nNew in version 1.3.0.\n\nExamples\n&gt;&gt;&gt; prob1 = np.log(1e-50)\n&gt;&gt;&gt; prob2 = np.log(2.5e-50)\n&gt;&gt;&gt; prob12 = np.logaddexp(prob1, prob2)\n&gt;&gt;&gt; prob12\n-113.87649168120691\n&gt;&gt;&gt; np.exp(prob12)\n3.5000000000000057e-50\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "resultndarray"], "returns": "resultndarrayLogarithm of exp(x1) + exp(x2).This is a scalar if both x1 and x2 are scalars.", "examples": ["; prob1 = np.log(1e-50)\n; prob2 = np.log(2.5e-50)\n; prob12 = np.logaddexp(prob1, prob2)\n; prob12\n-113.87649168120691\n; np.exp(prob12)\n3.5000000000000057e-50\n\n", "; prob1 = np.log(1e-50)\n; prob2 = np.log(2.5e-50)\n; prob12 = np.logaddexp(prob1, prob2)\n; prob12\n-113.87649168120691\n; np.exp(prob12)\n3.5000000000000057e-50\n"]},
{"library": "numpy", "item_id": "numpy.log1p", "code": "\nnumpy.log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'log1p'&gt;\u00b6", "description": "Return the natural logarithm of one plus the input array, element-wise.\nCalculates log(1 + x).\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayNatural logarithm of 1 + x, element-wise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nexpm1exp(x) - 1, the inverse of log1p.\n\n\n\nNotes\nFor real-valued input, log1p is accurate also for x so small\nthat 1 + x == 1 in floating-point accuracy.\nLogarithm is a multivalued function: for each x there is an infinite\nnumber of z such that exp(z) = 1 + x. The convention is to return\nthe z whose imaginary part lies in [-pi, pi].\nFor real-valued input data types, log1p always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, log1p is a complex analytical function that\nhas a branch cut [-inf, -1] and is continuous from above on it.\nlog1p handles the floating-point negative zero as an infinitesimal\nnegative number, conforming to the C99 standard.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 67. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cLogarithm\u201d. https://en.wikipedia.org/wiki/Logarithm\n\n\nExamples\n&gt;&gt;&gt; np.log1p(1e-99)\n1e-99\n&gt;&gt;&gt; np.log(1 + 1e-99)\n0.0\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayNatural logarithm of 1 + x, element-wise.This is a scalar if x is a scalar.", "examples": ["; np.log1p(1e-99)\n1e-99\n; np.log(1 + 1e-99)\n0.0\n\n", "; np.log1p(1e-99)\n1e-99\n; np.log(1 + 1e-99)\n0.0\n"]},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.lock", "code": "\nBitGenerator.lock\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.load", "code": "\nnumpy.load(file, mmap_mode=None, allow_pickle=False, fix_imports=True, encoding='ASCII')[source]\u00b6", "description": "Load arrays or pickled objects from .npy, .npz or pickled files.\n\nWarning\nLoading files that contain object arrays uses the pickle\nmodule, which is not secure against erroneous or maliciously\nconstructed data. Consider passing allow_pickle=False to\nload data that is known not to contain object arrays for the\nsafer handling of untrusted sources.\n\n\nParameters\n\nfilefile-like object, string, or pathlib.PathThe file to read. File-like objects must support the\nseek() and read() methods. Pickled files require that the\nfile-like object support the readline() method as well.\n\nmmap_mode{None, \u2018r+\u2019, \u2018r\u2019, \u2018w+\u2019, \u2018c\u2019}, optionalIf not None, then memory-map the file, using the given mode (see\nnumpy.memmap for a detailed description of the modes).  A\nmemory-mapped array is kept on disk. However, it can be accessed\nand sliced like any ndarray.  Memory mapping is especially useful\nfor accessing small fragments of large files without reading the\nentire file into memory.\n\nallow_picklebool, optionalAllow loading pickled object arrays stored in npy files. Reasons for\ndisallowing pickles include security, as loading pickled data can\nexecute arbitrary code. If pickles are disallowed, loading object\narrays will fail. Default: False\n\nChanged in version 1.16.3: Made default False in response to CVE-2019-6446.\n\n\nfix_importsbool, optionalOnly useful when loading Python 2 generated pickled files on Python 3,\nwhich includes npy/npz files containing object arrays. If fix_imports\nis True, pickle will try to map the old Python 2 names to the new names\nused in Python 3.\n\nencodingstr, optionalWhat encoding to use when reading Python 2 strings. Only useful when\nloading Python 2 generated pickled files in Python 3, which includes\nnpy/npz files containing object arrays. Values other than \u2018latin1\u2019,\n\u2018ASCII\u2019, and \u2018bytes\u2019 are not allowed, as they can corrupt numerical\ndata. Default: \u2018ASCII\u2019\n\n\n\nReturns\n\nresultarray, tuple, dict, etc.Data stored in the file. For .npz files, the returned instance\nof NpzFile class must be closed to avoid leaking file descriptors.\n\n\n\nRaises\n\nIOErrorIf the input file does not exist or cannot be read.\n\nValueErrorThe file contains an object array, but allow_pickle=False given.\n\n\n\n\n\nSee also\nsave, savez, savez_compressed, loadtxt\n\nmemmapCreate a memory-map to an array stored in a file on disk.\n\nlib.format.open_memmapCreate or load a memory-mapped .npy file.\n\n\n\nNotes\n\nIf the file contains pickle data, then whatever object is stored\nin the pickle is returned.\nIf the file is a .npy file, then a single array is returned.\nIf the file is a .npz file, then a dictionary-like object is\nreturned, containing {filename: array} key-value pairs, one for\neach file in the archive.\nIf the file is a .npz file, the returned value supports the\ncontext manager protocol in a similar fashion to the open function:\nwith load('foo.npz') as data:\n    a = data['a']\n\n\nThe underlying file descriptor is closed when exiting the \u2018with\u2019\nblock.\n\n\nExamples\nStore data to disk, and load it again:\n&gt;&gt;&gt; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n&gt;&gt;&gt; np.load('/tmp/123.npy')\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nStore compressed data to disk, and load it again:\n&gt;&gt;&gt; a=np.array([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; b=np.array([1, 2])\n&gt;&gt;&gt; np.savez('/tmp/123.npz', a=a, b=b)\n&gt;&gt;&gt; data = np.load('/tmp/123.npz')\n&gt;&gt;&gt; data['a']\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; data['b']\narray([1, 2])\n&gt;&gt;&gt; data.close()\n\n\nMem-map the stored array, and then access the second row\ndirectly from disk:\n&gt;&gt;&gt; X = np.load('/tmp/123.npy', mmap_mode='r')\n&gt;&gt;&gt; X[1, :]\nmemmap([4, 5, 6])\n\n\n", "parameters": ["Parameters", "filefile-like object, string, or pathlib.Path", "mmap_mode{None, \u2018r+\u2019, \u2018r\u2019, \u2018w+\u2019, \u2018c\u2019}, optional", "allow_picklebool, optional", "fix_importsbool, optional", "encodingstr, optional", "Returns", "resultarray, tuple, dict, etc.", "Raises", "IOError", "ValueError"], "returns": "resultarray, tuple, dict, etc.Data stored in the file. For .npz files, the returned instanceof NpzFile class must be closed to avoid leaking file descriptors.", "examples": ["; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n; np.load('/tmp/123.npy')\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; np.save('/tmp/123', np.array([[1, 2, 3], [4, 5, 6]]))\n; np.load('/tmp/123.npy')\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; a=np.array([[1, 2, 3], [4, 5, 6]])\n; b=np.array([1, 2])\n; np.savez('/tmp/123.npz', a=a, b=b)\n; data = np.load('/tmp/123.npz')\n; data['a']\narray([[1, 2, 3],\n       [4, 5, 6]])\n; data['b']\narray([1, 2])\n; data.close()\n\n", "; a=np.array([[1, 2, 3], [4, 5, 6]])\n; b=np.array([1, 2])\n; np.savez('/tmp/123.npz', a=a, b=b)\n; data = np.load('/tmp/123.npz')\n; data['a']\narray([[1, 2, 3],\n       [4, 5, 6]])\n; data['b']\narray([1, 2])\n; data.close()\n", "; X = np.load('/tmp/123.npy', mmap_mode='r')\n; X[1, :]\nmemmap([4, 5, 6])\n\n", "; X = np.load('/tmp/123.npy', mmap_mode='r')\n; X[1, :]\nmemmap([4, 5, 6])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.ljust", "code": "\nchararray.ljust(self, width, fillchar=' ')[source]\u00b6", "description": "Return an array with the elements of self left-justified in a\nstring of length width.\n\nSee also\nchar.ljust\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.ljust", "code": "\nchararray.ljust(self, width, fillchar=' ')\u00b6", "description": "Return an array with the elements of self left-justified in a\nstring of length width.\n\nSee also\nchar.ljust\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.loadtxt", "code": "\nnumpy.loadtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding='bytes', max_rows=None)[source]\u00b6", "description": "Load data from a text file.\nEach row in the text file must have the same number of values.\n\nParameters\n\nfnamefile, str, or pathlib.PathFile, filename, or generator to read.  If the filename extension is\n.gz or .bz2, the file is first decompressed. Note that\ngenerators should return byte strings.\n\ndtypedata-type, optionalData-type of the resulting array; default: float.  If this is a\nstructured data-type, the resulting array will be 1-dimensional, and\neach row will be interpreted as an element of the array.  In this\ncase, the number of columns used must match the number of fields in\nthe data-type.\n\ncommentsstr or sequence of str, optionalThe characters or list of characters used to indicate the start of a\ncomment. None implies no comments. For backwards compatibility, byte\nstrings will be decoded as \u2018latin1\u2019. The default is \u2018#\u2019.\n\ndelimiterstr, optionalThe string used to separate values. For backwards compatibility, byte\nstrings will be decoded as \u2018latin1\u2019. The default is whitespace.\n\nconvertersdict, optionalA dictionary mapping column number to a function that will parse the\ncolumn string into the desired value.  E.g., if column 0 is a date\nstring: converters = {0: datestr2num}.  Converters can also be\nused to provide a default value for missing data (but see also\ngenfromtxt): converters = {3: lambda s: float(s.strip() or 0)}.\nDefault: None.\n\nskiprowsint, optionalSkip the first skiprows lines, including comments; default: 0.\n\nusecolsint or sequence, optionalWhich columns to read, with 0 being the first. For example,\nusecols = (1,4,5) will extract the 2nd, 5th and 6th columns.\nThe default, None, results in all columns being read.\n\nChanged in version 1.11.0: When a single column has to be read it is possible to use\nan integer instead of a tuple. E.g usecols = 3 reads the\nfourth column the same way as usecols = (3,) would.\n\n\nunpackbool, optionalIf True, the returned array is transposed, so that arguments may be\nunpacked using x, y, z = loadtxt(...).  When used with a structured\ndata-type, arrays are returned for each field.  Default is False.\n\nndminint, optionalThe returned array will have at least ndmin dimensions.\nOtherwise mono-dimensional axes will be squeezed.\nLegal values: 0 (default), 1 or 2.\n\nNew in version 1.6.0.\n\n\nencodingstr, optionalEncoding used to decode the inputfile. Does not apply to input streams.\nThe special value \u2018bytes\u2019 enables backward compatibility workarounds\nthat ensures you receive byte arrays as results if possible and passes\n\u2018latin1\u2019 encoded strings to converters. Override this value to receive\nunicode arrays and pass strings as input to converters.  If set to None\nthe system default is used. The default value is \u2018bytes\u2019.\n\nNew in version 1.14.0.\n\n\nmax_rowsint, optionalRead max_rows lines of content after skiprows lines. The default\nis to read all the lines.\n\nNew in version 1.16.0.\n\n\n\n\nReturns\n\noutndarrayData read from the text file.\n\n\n\n\n\nSee also\nload, fromstring, fromregex\n\ngenfromtxtLoad data with missing values handled as specified.\n\nscipy.io.loadmatreads MATLAB data files\n\n\n\nNotes\nThis function aims to be a fast reader for simply formatted files.  The\ngenfromtxt function provides more sophisticated handling of, e.g.,\nlines with missing values.\n\nNew in version 1.10.0.\n\nThe strings produced by the Python float.hex method can be used as\ninput for floats.\nExamples\n&gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object\n&gt;&gt;&gt; c = StringIO(u\"0 1\\n2 3\")\n&gt;&gt;&gt; np.loadtxt(c)\narray([[0., 1.],\n       [2., 3.]])\n\n\n&gt;&gt;&gt; d = StringIO(u\"M 21 72\\nF 35 58\")\n&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n...                      'formats': ('S1', 'i4', 'f4')})\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\n      dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])\n\n\n&gt;&gt;&gt; c = StringIO(u\"1,0,2\\n3,0,4\")\n&gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n&gt;&gt;&gt; x\narray([1., 3.])\n&gt;&gt;&gt; y\narray([2., 4.])\n\n\n", "parameters": ["Parameters", "fnamefile, str, or pathlib.Path", "dtypedata-type, optional", "commentsstr or sequence of str, optional", "delimiterstr, optional", "convertersdict, optional", "skiprowsint, optional", "usecolsint or sequence, optional", "unpackbool, optional", "ndminint, optional", "encodingstr, optional", "max_rowsint, optional", "Returns", "outndarray"], "returns": "outndarrayData read from the text file.", "examples": ["; from io import StringIO   # StringIO behaves like a file object\n; c = StringIO(u\"0 1\\n2 3\")\n; np.loadtxt(c)\narray([[0., 1.],\n       [2., 3.]])\n\n", "; from io import StringIO   # StringIO behaves like a file object\n; c = StringIO(u\"0 1\\n2 3\")\n; np.loadtxt(c)\narray([[0., 1.],\n       [2., 3.]])\n", "; d = StringIO(u\"M 21 72\\nF 35 58\")\n; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n...                      'formats': ('S1', 'i4', 'f4')})\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\n      dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])\n\n", "; d = StringIO(u\"M 21 72\\nF 35 58\")\n; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),\n...                      'formats': ('S1', 'i4', 'f4')})\narray([(b'M', 21, 72.), (b'F', 35, 58.)],\n      dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])\n", "; c = StringIO(u\"1,0,2\\n3,0,4\")\n; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n; x\narray([1., 3.])\n; y\narray([2., 4.])\n\n", "; c = StringIO(u\"1,0,2\\n3,0,4\")\n; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)\n; x\narray([1., 3.])\n; y\narray([2., 4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.linspace", "code": "\nPolynomial.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.linspace", "code": "\nLegendre.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.char.ljust", "code": "\nnumpy.char.ljust(a, width, fillchar=' ')\u00b6", "description": "Return an array with the elements of a left-justified in a\nstring of length width.\nCalls str.ljust element-wise.\n\nParameters\n\naarray_like of str or unicode\nwidthintThe length of the resulting strings\n\nfillcharstr or unicode, optionalThe character to use for padding\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.ljust\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "widthint", "fillcharstr or unicode, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.linspace", "code": "\nHermiteE.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.linspace", "code": "\nHermite.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.linspace", "code": "\nnumpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None, axis=0)[source]\u00b6", "description": "Return evenly spaced numbers over a specified interval.\nReturns num evenly spaced samples, calculated over the\ninterval [start, stop].\nThe endpoint of the interval can optionally be excluded.\n\nChanged in version 1.16.0: Non-scalar start and stop are now supported.\n\n\nParameters\n\nstartarray_likeThe starting value of the sequence.\n\nstoparray_likeThe end value of the sequence, unless endpoint is set to False.\nIn that case, the sequence consists of all but the last of num + 1\nevenly spaced samples, so that stop is excluded.  Note that the step\nsize changes when endpoint is False.\n\nnumint, optionalNumber of samples to generate. Default is 50. Must be non-negative.\n\nendpointbool, optionalIf True, stop is the last sample. Otherwise, it is not included.\nDefault is True.\n\nretstepbool, optionalIf True, return (samples, step), where step is the spacing\nbetween samples.\n\ndtypedtype, optionalThe type of the output array.  If dtype is not given, infer the data\ntype from the other input arguments.\n\nNew in version 1.9.0.\n\n\naxisint, optionalThe axis in the result to store the samples.  Relevant only if start\nor stop are array-like.  By default (0), the samples will be along a\nnew axis inserted at the beginning. Use -1 to get an axis at the end.\n\nNew in version 1.16.0.\n\n\n\n\nReturns\n\nsamplesndarrayThere are num equally spaced samples in the closed interval\n[start, stop] or the half-open interval [start, stop)\n(depending on whether endpoint is True or False).\n\nstepfloat, optionalOnly returned if retstep is True\nSize of spacing between samples.\n\n\n\n\n\nSee also\n\narangeSimilar to linspace, but uses a step size (instead of the number of samples).\n\ngeomspaceSimilar to linspace, but with numbers spaced evenly on a log scale (a geometric progression).\n\nlogspaceSimilar to geomspace, but with the end points specified as logarithms.\n\n\n\nExamples\n&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5)\narray([2.  , 2.25, 2.5 , 2.75, 3.  ])\n&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([2. ,  2.2,  2.4,  2.6,  2.8])\n&gt;&gt;&gt; np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n\nGraphical illustration:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; N = 8\n&gt;&gt;&gt; y = np.zeros(N)\n&gt;&gt;&gt; x1 = np.linspace(0, 10, N, endpoint=True)\n&gt;&gt;&gt; x2 = np.linspace(0, 10, N, endpoint=False)\n&gt;&gt;&gt; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.ylim([-0.5, 1])\n(-0.5, 1)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "startarray_like", "stoparray_like", "numint, optional", "endpointbool, optional", "retstepbool, optional", "dtypedtype, optional", "axisint, optional", "Returns", "samplesndarray", "stepfloat, optional"], "returns": "samplesndarrayThere are num equally spaced samples in the closed interval[start, stop] or the half-open interval [start, stop)(depending on whether endpoint is True or False).stepfloat, optionalOnly returned if retstep is TrueSize of spacing between samples.", "examples": ["; np.linspace(2.0, 3.0, num=5)\narray([2.  , 2.25, 2.5 , 2.75, 3.  ])\n; np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([2. ,  2.2,  2.4,  2.6,  2.8])\n; np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n\n", "; np.linspace(2.0, 3.0, num=5)\narray([2.  , 2.25, 2.5 , 2.75, 3.  ])\n; np.linspace(2.0, 3.0, num=5, endpoint=False)\narray([2. ,  2.2,  2.4,  2.6,  2.8])\n; np.linspace(2.0, 3.0, num=5, retstep=True)\n(array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)\n", "; import matplotlib.pyplot as plt\n; N = 8\n; y = np.zeros(N)\n; x1 = np.linspace(0, 10, N, endpoint=True)\n; x2 = np.linspace(0, 10, N, endpoint=False)\n; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.ylim([-0.5, 1])\n(-0.5, 1)\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; N = 8\n; y = np.zeros(N)\n; x1 = np.linspace(0, 10, N, endpoint=True)\n; x2 = np.linspace(0, 10, N, endpoint=False)\n; plt.plot(x1, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(x2, y + 0.5, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.ylim([-0.5, 1])\n(-0.5, 1)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.linalg.LinAlgError", "code": "\nexception numpy.linalg.LinAlgError[source]\u00b6", "description": "Generic Python-exception-derived object raised by linalg functions.\nGeneral purpose exception class, derived from Python\u2019s exception.Exception\nclass, programmatically raised in linalg functions when a Linear\nAlgebra-related condition would prevent further correct execution of the\nfunction.\n\nParameters\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"...linalg.py\", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File \"...linalg.py\", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": ["; from numpy import linalg as LA\n; LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"...linalg.py\", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File \"...linalg.py\", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix\n\n", "; from numpy import linalg as LA\n; LA.inv(np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n  File \"...linalg.py\", line 350,\n    in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))\n  File \"...linalg.py\", line 249,\n    in solve\n    raise LinAlgError('Singular matrix')\nnumpy.linalg.LinAlgError: Singular matrix\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.linspace", "code": "\nLaguerre.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.linspace", "code": "\nChebyshev.linspace(self, n=100, domain=None)[source]\u00b6", "description": "Return x, y values at equally spaced points in domain.\nReturns the x, y values at n linearly spaced points across the\ndomain.  Here y is the value of the polynomial at the points x. By\ndefault the domain is the same as that of the series instance.\nThis method is intended mostly as a plotting aid.\n\nNew in version 1.5.0.\n\n\nParameters\n\nnint, optionalNumber of point pairs to return. The default value is 100.\n\ndomain{None, array_like}, optionalIf not None, the specified domain is used instead of that of\nthe calling instance. It should be of the form [beg,end].\nThe default is None which case the class domain is used.\n\n\n\nReturns\n\nx, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) and\ny is the series evaluated at element of x.\n\n\n\n\n", "parameters": ["Parameters", "nint, optional", "domain{None, array_like}, optional", "Returns", "x, yndarray"], "returns": "x, yndarrayx is equal to linspace(self.domain[0], self.domain[1], n) andy is the series evaluated at element of x.", "examples": []},
{"library": "numpy", "item_id": "numpy.lexsort", "code": "\nnumpy.lexsort(keys, axis=-1)\u00b6", "description": "Perform an indirect stable sort using a sequence of keys.\nGiven multiple sorting keys, which can be interpreted as columns in a\nspreadsheet, lexsort returns an array of integer indices that describes\nthe sort order by multiple columns. The last key in the sequence is used\nfor the primary sort order, the second-to-last key for the secondary sort\norder, and so on. The keys argument must be a sequence of objects that\ncan be converted to arrays of the same shape. If a 2D array is provided\nfor the keys argument, it\u2019s rows are interpreted as the sorting keys and\nsorting is according to the last row, second last row etc.\n\nParameters\n\nkeys(k, N) array or tuple containing k (N,)-shaped sequencesThe k different \u201ccolumns\u201d to be sorted.  The last column (or row if\nkeys is a 2D array) is the primary sort key.\n\naxisint, optionalAxis to be indirectly sorted.  By default, sort over the last axis.\n\n\n\nReturns\n\nindices(N,) ndarray of intsArray of indices that sort the keys along the specified axis.\n\n\n\n\n\nSee also\n\nargsortIndirect sort.\n\nndarray.sortIn-place sort.\n\nsortReturn a sorted copy of an array.\n\n\n\nExamples\nSort names: first by surname, then by name.\n&gt;&gt;&gt; surnames =    ('Hertz',    'Galilei', 'Hertz')\n&gt;&gt;&gt; first_names = ('Heinrich', 'Galileo', 'Gustav')\n&gt;&gt;&gt; ind = np.lexsort((first_names, surnames))\n&gt;&gt;&gt; ind\narray([1, 2, 0])\n\n\n&gt;&gt;&gt; [surnames[i] + \", \" + first_names[i] for i in ind]\n['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n\nSort two columns of numbers:\n&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column\n&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column\n&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b\n&gt;&gt;&gt; ind\narray([2, 0, 4, 6, 5, 3, 1])\n\n\n&gt;&gt;&gt; [(a[i],b[i]) for i in ind]\n[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]\n\n\nNote that sorting is first according to the elements of a.\nSecondary sorting is according to the elements of b.\nA normal argsort would have yielded:\n&gt;&gt;&gt; [(a[i],b[i]) for i in np.argsort(a)]\n[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n\nStructured arrays are sorted lexically by argsort:\n&gt;&gt;&gt; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n...              dtype=np.dtype([('x', int), ('y', int)]))\n\n\n&gt;&gt;&gt; np.argsort(x) # or np.argsort(x, order=('x', 'y'))\narray([2, 0, 4, 6, 5, 3, 1])\n\n\n", "parameters": ["Parameters", "keys(k, N) array or tuple containing k (N,)-shaped sequences", "axisint, optional", "Returns", "indices(N,) ndarray of ints"], "returns": "indices(N,) ndarray of intsArray of indices that sort the keys along the specified axis.", "examples": ["; surnames =    ('Hertz',    'Galilei', 'Hertz')\n; first_names = ('Heinrich', 'Galileo', 'Gustav')\n; ind = np.lexsort((first_names, surnames))\n; ind\narray([1, 2, 0])\n\n", "; surnames =    ('Hertz',    'Galilei', 'Hertz')\n; first_names = ('Heinrich', 'Galileo', 'Gustav')\n; ind = np.lexsort((first_names, surnames))\n; ind\narray([1, 2, 0])\n", "; [surnames[i] + \", \" + first_names[i] for i in ind]\n['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n\n", "; [surnames[i] + \", \" + first_names[i] for i in ind]\n['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']\n", "; a = [1,5,1,4,3,4,4] # First column\n; b = [9,4,0,4,0,2,1] # Second column\n; ind = np.lexsort((b,a)) # Sort by a, then by b\n; ind\narray([2, 0, 4, 6, 5, 3, 1])\n\n", "; a = [1,5,1,4,3,4,4] # First column\n; b = [9,4,0,4,0,2,1] # Second column\n; ind = np.lexsort((b,a)) # Sort by a, then by b\n; ind\narray([2, 0, 4, 6, 5, 3, 1])\n", "; [(a[i],b[i]) for i in ind]\n[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]\n\n", "; [(a[i],b[i]) for i in ind]\n[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]\n", "; [(a[i],b[i]) for i in np.argsort(a)]\n[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n\n", "; [(a[i],b[i]) for i in np.argsort(a)]\n[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]\n", "; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n...              dtype=np.dtype([('x', int), ('y', int)]))\n\n", "; x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],\n...              dtype=np.dtype([('x', int), ('y', int)]))\n", "; np.argsort(x) # or np.argsort(x, order=('x', 'y'))\narray([2, 0, 4, 6, 5, 3, 1])\n\n", "; np.argsort(x) # or np.argsort(x, order=('x', 'y'))\narray([2, 0, 4, 6, 5, 3, 1])\n"]},
{"library": "numpy", "item_id": "numpy.char.less_equal", "code": "\nnumpy.char.less_equal(x1, x2)\u00b6", "description": "Return (x1 &lt;= x2) element-wise.\nUnlike numpy.less_equal, this comparison is performed by first\nstripping whitespace characters from the end of the string.  This\nbehavior is provided for backward-compatibility with numarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, not_equal, greater_equal, greater, less\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.char.less", "code": "\nnumpy.char.less(x1, x2)\u00b6", "description": "Return (x1 &lt; x2) element-wise.\nUnlike numpy.greater, this comparison is performed by first\nstripping whitespace characters from the end of the string.  This\nbehavior is provided for backward-compatibility with numarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, not_equal, greater_equal, less_equal, greater\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legx", "code": "\nnumpy.polynomial.legendre.legx = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legweight", "code": "\nnumpy.polynomial.legendre.legweight(x)[source]\u00b6", "description": "Weight function of the Legendre polynomials.\nThe weight function is  and the interval of integration is\n. The Legendre polynomials are orthogonal, but not\nnormalized, with respect to this weight function.\n\nParameters\n\nxarray_likeValues at which the weight function will be computed.\n\n\n\nReturns\n\nwndarrayThe weight function at x.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "wndarray"], "returns": "wndarrayThe weight function at x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legvander3d", "code": "\nnumpy.polynomial.legendre.legvander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe degrees of the Legendre polynomials.\nIf V = legvander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand np.dot(V, c.flat) and legval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D Legendre\nseries of the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\nlegvander, legvander3d, legval2d, legval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.less_equal", "code": "\nnumpy.less_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'less_equal'&gt;\u00b6", "description": "Return the truth value of (x1 =&lt; x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\ngreater, less, greater_equal, equal, not_equal\n\nExamples\n&gt;&gt;&gt; np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])\n\n", "; np.less_equal([4, 2, 1], [2, 2, 2])\narray([False,  True,  True])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legvander", "code": "\nnumpy.polynomial.legendre.legvander(x, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degree.\nReturns the pseudo-Vandermonde matrix of degree deg and sample points\nx. The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the degree of the Legendre polynomial.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\narray V = legvander(x, n), then np.dot(V, c) and\nlegval(x, c) are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of Legendre series of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where The last index is the degree of the\ncorresponding Legendre polynomial.  The dtype will be the same as\nthe converted x.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray"], "returns": "vanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where The last index is the degree of thecorresponding Legendre polynomial.  The dtype will be the same asthe converted x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legvander2d", "code": "\nnumpy.polynomial.legendre.legvander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the degrees of\nthe Legendre polynomials.\nIf V = legvander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and legval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D Legendre\nseries of the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to\n1-D arrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\nlegvander, legvander3d, legval2d, legval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legval3d", "code": "\nnumpy.polynomial.legendre.legval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Legendre series at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimensional polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\nlegval, legval2d, leggrid2d, leggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimensional polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legroots", "code": "\nnumpy.polynomial.legendre.legroots(c)[source]\u00b6", "description": "Compute the roots of a Legendre series.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the series. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\npolyroots, chebroots, lagroots, hermroots, hermeroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such values.\nRoots with multiplicity greater than 1 will also show larger errors as\nthe value of the series near such points is relatively insensitive to\nerrors in the roots. Isolated roots near the origin can be improved by\na few iterations of Newton\u2019s method.\nThe Legendre series basis polynomials aren\u2019t powers of x so the\nresults of this function may seem unintuitive.\nExamples\n&gt;&gt;&gt; import numpy.polynomial.legendre as leg\n&gt;&gt;&gt; leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\narray([-0.85099543, -0.11407192,  0.51506735]) # may vary\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the series. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; import numpy.polynomial.legendre as leg\n; leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\narray([-0.85099543, -0.11407192,  0.51506735]) # may vary\n\n", "; import numpy.polynomial.legendre as leg\n; leg.legroots((1, 2, 3, 4)) # 4L_3 + 3L_2 + 2L_1 + 1L_0, all real roots\narray([-0.85099543, -0.11407192,  0.51506735]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legval2d", "code": "\nnumpy.polynomial.legendre.legval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Legendre series at points (x, y).\nThis function returns the values:\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and if it isn\u2019t an ndarray it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than two the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional Legendre series at points formed\nfrom pairs of corresponding values from x and y.\n\n\n\n\n\nSee also\nlegval, leggrid2d, legval3d, leggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional Legendre series at points formedfrom pairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legpow", "code": "\nnumpy.polynomial.legendre.legpow(c, pow, maxpower=16)[source]\u00b6", "description": "Raise a Legendre series to a power.\nReturns the Legendre series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\ncarray_like1-D array of Legendre series coefficients ordered from low to\nhigh.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayLegendre series of power.\n\n\n\n\n\nSee also\nlegadd, legsub, legmulx, legmul, legdiv\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayLegendre series of power.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legval", "code": "\nnumpy.polynomial.legendre.legval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate a Legendre series at points x.\nIf c is of length n + 1, this function returns the value:\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, algebra_likeThe shape of the return value is described above.\n\n\n\n\n\nSee also\nlegval2d, leggrid2d, legval3d, leggrid3d\n\nNotes\nThe evaluation uses Clenshaw recursion, aka synthetic division.\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, algebra_like"], "returns": "valuesndarray, algebra_likeThe shape of the return value is described above.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legtrim", "code": "\nnumpy.polynomial.legendre.legtrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legmulx", "code": "\nnumpy.polynomial.legendre.legmulx(c)[source]\u00b6", "description": "Multiply a Legendre series by x.\nMultiply the Legendre series c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of Legendre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\n\nSee also\nlegadd, legmul, legmul, legdiv, legpow\n\nNotes\nThe multiplication uses the recursion relationship for Legendre\npolynomials in the form\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; L.legmulx([1,2,3])\narray([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": ["; from numpy.polynomial import legendre as L\n; L.legmulx([1,2,3])\narray([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary\n\n", "; from numpy.polynomial import legendre as L\n; L.legmulx([1,2,3])\narray([ 0.66666667, 2.2, 1.33333333, 1.8]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legsub", "code": "\nnumpy.polynomial.legendre.legsub(c1, c2)[source]\u00b6", "description": "Subtract one Legendre series from another.\nReturns the difference of two Legendre series c1 - c2.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Legendre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Legendre series coefficients representing their difference.\n\n\n\n\n\nSee also\nlegadd, legmulx, legmul, legdiv, legpow\n\nNotes\nUnlike multiplication, division, etc., the difference of two Legendre\nseries is a Legendre series (without having to \u201creproject\u201d the result\nonto the basis set) so subtraction, just like that of \u201cstandard\u201d\npolynomials, is simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; L.legsub(c1,c2)\narray([-2.,  0.,  2.])\n&gt;&gt;&gt; L.legsub(c2,c1) # -C.legsub(c1,c2)\narray([ 2.,  0., -2.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Legendre series coefficients representing their difference.", "examples": ["; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legsub(c1,c2)\narray([-2.,  0.,  2.])\n; L.legsub(c2,c1) # -C.legsub(c1,c2)\narray([ 2.,  0., -2.])\n\n", "; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legsub(c1,c2)\narray([-2.,  0.,  2.])\n; L.legsub(c2,c1) # -C.legsub(c1,c2)\narray([ 2.,  0., -2.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legone", "code": "\nnumpy.polynomial.legendre.legone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legmul", "code": "\nnumpy.polynomial.legendre.legmul(c1, c2)[source]\u00b6", "description": "Multiply one Legendre series by another.\nReturns the product of two Legendre series c1 * c2.  The arguments\nare sequences of coefficients, from lowest order \u201cterm\u201d to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Legendre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Legendre series coefficients representing their product.\n\n\n\n\n\nSee also\nlegadd, legsub, legmulx, legdiv, legpow\n\nNotes\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Legendre polynomial basis set.  Thus, to express\nthe product as a Legendre series, it is necessary to \u201creproject\u201d the\nproduct onto said basis set, which may produce \u201cunintuitive\u201d (but\ncorrect) results; see Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2)\n&gt;&gt;&gt; L.legmul(c1,c2) # multiplication requires \"reprojection\"\narray([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Legendre series coefficients representing their product.", "examples": ["; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2)\n; L.legmul(c1,c2) # multiplication requires \"reprojection\"\narray([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary\n\n", "; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2)\n; L.legmul(c1,c2) # multiplication requires \"reprojection\"\narray([  4.33333333,  10.4       ,  11.66666667,   3.6       ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legline", "code": "\nnumpy.polynomial.legendre.legline(off, scl)[source]\u00b6", "description": "Legendre series whose graph is a straight line.\n\nParameters\n\noff, sclscalarsThe specified line is given by off + scl*x.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the Legendre series for\noff + scl*x.\n\n\n\n\n\nSee also\npolyline, chebline\n\nExamples\n&gt;&gt;&gt; import numpy.polynomial.legendre as L\n&gt;&gt;&gt; L.legline(3,2)\narray([3, 2])\n&gt;&gt;&gt; L.legval(-3, L.legline(3,2)) # should be -3\n-3.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the Legendre series foroff + scl*x.", "examples": ["; import numpy.polynomial.legendre as L\n; L.legline(3,2)\narray([3, 2])\n; L.legval(-3, L.legline(3,2)) # should be -3\n-3.0\n\n", "; import numpy.polynomial.legendre as L\n; L.legline(3,2)\narray([3, 2])\n; L.legval(-3, L.legline(3,2)) # should be -3\n-3.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legint", "code": "\nnumpy.polynomial.legendre.legint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a Legendre series.\nReturns the Legendre series coefficients c integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument c is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series L_0 + 2*L_1 + 3*L_2 while [[1,2],[1,2]]\nrepresents 1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +\n2*L_1(x)*L_1(y) if axis=0 is x and axis=1 is y.\n\nParameters\n\ncarray_likeArray of Legendre series coefficients. If c is multidimensional the\ndifferent axis correspond to different variables with the degree in\neach axis given by the corresponding index.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at\nlbnd is the first value in the list, the value of the second\nintegral at lbnd is the second value, etc.  If k == [] (the\ndefault), all constants are set to zero.  If m == 1, a single\nscalar can be given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayLegendre series coefficient array of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 0, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\nlegder\n\nNotes\nNote that the result of each integration is multiplied by scl.\nWhy is this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x.  Then\n, so one will need to set scl equal to\n - perhaps not what one would have first thought.\nAlso note that, in general, the result of integrating a C-series needs\nto be \u201creprojected\u201d onto the C-series basis set.  Thus, typically,\nthe result of this function is \u201cunintuitive,\u201d albeit correct; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c = (1,2,3)\n&gt;&gt;&gt; L.legint(c)\narray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n&gt;&gt;&gt; L.legint(c, 3)\narray([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary\n         -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\n&gt;&gt;&gt; L.legint(c, k=3)\n array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n&gt;&gt;&gt; L.legint(c, lbnd=-2)\narray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n&gt;&gt;&gt; L.legint(c, scl=2)\narray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayLegendre series coefficient array of the integral.", "examples": ["; from numpy.polynomial import legendre as L\n; c = (1,2,3)\n; L.legint(c)\narray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, 3)\narray([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary\n         -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\n; L.legint(c, k=3)\n array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, lbnd=-2)\narray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, scl=2)\narray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary\n\n", "; from numpy.polynomial import legendre as L\n; c = (1,2,3)\n; L.legint(c)\narray([ 0.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, 3)\narray([  1.66666667e-02,  -1.78571429e-02,   4.76190476e-02, # may vary\n         -1.73472348e-18,   1.90476190e-02,   9.52380952e-03])\n; L.legint(c, k=3)\n array([ 3.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, lbnd=-2)\narray([ 7.33333333,  0.4       ,  0.66666667,  0.6       ]) # may vary\n; L.legint(c, scl=2)\narray([ 0.66666667,  0.8       ,  1.33333333,  1.2       ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.leggrid3d", "code": "\nnumpy.polynomial.legendre.leggrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nlegval, legval2d, leggrid2d, legval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.leggauss", "code": "\nnumpy.polynomial.legendre.leggauss(deg)[source]\u00b6", "description": "Gauss-Legendre quadrature.\nComputes the sample points and weights for Gauss-Legendre quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree  or less over the interval  with\nthe weight function .\n\nParameters\n\ndegintNumber of sample points and weights. It must be &gt;= 1.\n\n\n\nReturns\n\nxndarray1-D ndarray containing the sample points.\n\nyndarray1-D ndarray containing the weights.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nThe results have only been tested up to degree 100, higher degrees may\nbe problematic. The weights are determined by using the fact that\n\n\nwhere  is a constant independent of  and \nis the k\u2019th root of , and then scaling the results to get\nthe right value when integrating 1.\n", "parameters": ["Parameters", "degint", "Returns", "xndarray", "yndarray"], "returns": "xndarray1-D ndarray containing the sample points.yndarray1-D ndarray containing the weights.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.leggrid2d", "code": "\nnumpy.polynomial.legendre.leggrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Legendre series on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j is contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in the\nCartesian product of x and y.\n\n\n\n\n\nSee also\nlegval, legval2d, legval3d, leggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in theCartesian product of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legfromroots", "code": "\nnumpy.polynomial.legendre.legfromroots(roots)[source]\u00b6", "description": "Generate a Legendre series with given roots.\nThe function returns the coefficients of the polynomial\n\n\nin Legendre form, where the r_n are the roots specified in roots.\nIf a zero has multiplicity n, then it must appear in roots n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then roots looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in Legendre form.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of coefficients.  If all roots are real then out is a\nreal array, if some of the roots are complex, then out is complex\neven if all the coefficients in the result are real (see Examples\nbelow).\n\n\n\n\n\nSee also\npolyfromroots, chebfromroots, lagfromroots, hermfromroots, hermefromroots\n\nExamples\n&gt;&gt;&gt; import numpy.polynomial.legendre as L\n&gt;&gt;&gt; L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0. , -0.4,  0. ,  0.4])\n&gt;&gt;&gt; j = complex(0,1)\n&gt;&gt;&gt; L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j]) # may vary\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of coefficients.  If all roots are real then out is areal array, if some of the roots are complex, then out is complexeven if all the coefficients in the result are real (see Examplesbelow).", "examples": ["; import numpy.polynomial.legendre as L\n; L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0. , -0.4,  0. ,  0.4])\n; j = complex(0,1)\n; L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j]) # may vary\n\n", "; import numpy.polynomial.legendre as L\n; L.legfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0. , -0.4,  0. ,  0.4])\n; j = complex(0,1)\n; L.legfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([ 1.33333333+0.j,  0.00000000+0.j,  0.66666667+0.j]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legfit", "code": "\nnumpy.polynomial.legendre.legfit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least squares fit of Legendre series to data.\nReturn the coefficients of a Legendre series of degree deg that is the\nleast squares fit to the data values y given at points x. If y is\n1-D the returned coefficients will also be 1-D. If y is 2-D multiple\nfits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\nNew in version 1.5.0.\n\n\n\n\nReturns\n\ncoefndarray, shape (M,) or (M, K)Legendre coefficients ordered from low to high. If y was\n2-D, the coefficients for the data in column k of y are in\ncolumn k. If deg is specified as a list, coefficients for\nterms not included in the fit are set equal to zero in the\nreturned coef.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.  The\nwarnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\nchebfit, polyfit, lagfit, hermfit, hermefit\n\nlegvalEvaluates a Legendre series.\n\nlegvanderVandermonde matrix of Legendre series.\n\nlegweightLegendre weight function (= 1).\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the Legendre series p that\nminimizes the sum of the weighted squared errors\n\n\nwhere  are the weights. This problem is solved by setting up\nas the (typically) overdetermined matrix equation\n\n\nwhere V is the weighted pseudo Vandermonde matrix of x, c are the\ncoefficients to be solved for, w are the weights, and y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected, then a RankWarning will be issued. This means that the\ncoefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The rcond parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\nFits using Legendre series are usually better conditioned than fits\nusing power series, but much can depend on the distribution of the\nsample points and the smoothness of the data. If the quality of the fit\nis inadequate splines may be a good alternative.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (M,) or (M, K)", "[residuals, rank, singular_values, rcond]list", "Warns", "RankWarning"], "returns": "coefndarray, shape (M,) or (M, K)Legendre coefficients ordered from low to high. If y was2-D, the coefficients for the data in column k of y are incolumn k. If deg is specified as a list, coefficients forterms not included in the fit are set equal to zero in thereturned coef.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legdomain", "code": "\nnumpy.polynomial.legendre.legdomain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre", "code": "\nclass numpy.polynomial.legendre.Legendre(coef, domain=None, window=None)[source]\u00b6", "description": "A Legendre series class.\nThe Legendre class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nattributes and methods listed in the ABCPolyBase documentation.\n\nParameters\n\ncoefarray_likeLegendre coefficients in order of increasing degree, i.e.,\n(1, 2, 3) gives 1*P_0(x) + 2*P_1(x) + 3*P_2(x).\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [-1, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [-1, 1].\n\nNew in version 1.6.0.\n\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legdiv", "code": "\nnumpy.polynomial.legendre.legdiv(c1, c2)[source]\u00b6", "description": "Divide one Legendre series by another.\nReturns the quotient-with-remainder of two Legendre series\nc1 / c2.  The arguments are sequences of coefficients from lowest\norder \u201cterm\u201d to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Legendre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\nquo, remndarraysOf Legendre series coefficients representing the quotient and\nremainder.\n\n\n\n\n\nSee also\nlegadd, legsub, legmulx, legmul, legpow\n\nNotes\nIn general, the (polynomial) division of one Legendre series by another\nresults in quotient and remainder terms that are not in the Legendre\npolynomial basis set.  Thus, to express these results as a Legendre\nseries, it is necessary to \u201creproject\u201d the results onto the Legendre\nbasis set, which may produce \u201cunintuitive\u201d (but correct) results; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; L.legdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n&gt;&gt;&gt; c2 = (0,1,2,3)\n&gt;&gt;&gt; L.legdiv(c2,c1) # neither \"intuitive\"\n(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "quo, remndarrays"], "returns": "quo, remndarraysOf Legendre series coefficients representing the quotient andremainder.", "examples": ["; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n; c2 = (0,1,2,3)\n; L.legdiv(c2,c1) # neither \"intuitive\"\n(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary\n\n", "; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n; c2 = (0,1,2,3)\n; L.legdiv(c2,c1) # neither \"intuitive\"\n(array([-0.07407407,  1.66666667]), array([-1.03703704, -2.51851852])) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legder", "code": "\nnumpy.polynomial.legendre.legder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a Legendre series.\nReturns the Legendre series coefficients c differentiated m times\nalong axis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable). The argument\nc is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series 1*L_0 + 2*L_1 + 3*L_2\nwhile [[1,2],[1,2]] represents 1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +\n2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y) if axis=0 is x and axis=1 is\ny.\n\nParameters\n\ncarray_likeArray of Legendre series coefficients. If c is multidimensional the\ndifferent axis correspond to different variables with the degree in\neach axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change of\nvariable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayLegendre series of the derivative.\n\n\n\n\n\nSee also\nlegint\n\nNotes\nIn general, the result of differentiating a Legendre series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \u201cunintuitive,\u201d albeit correct; see Examples section\nbelow.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c = (1,2,3,4)\n&gt;&gt;&gt; L.legder(c)\narray([  6.,   9.,  20.])\n&gt;&gt;&gt; L.legder(c, 3)\narray([60.])\n&gt;&gt;&gt; L.legder(c, scl=-1)\narray([ -6.,  -9., -20.])\n&gt;&gt;&gt; L.legder(c, 2,-1)\narray([  9.,  60.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayLegendre series of the derivative.", "examples": ["; from numpy.polynomial import legendre as L\n; c = (1,2,3,4)\n; L.legder(c)\narray([  6.,   9.,  20.])\n; L.legder(c, 3)\narray([60.])\n; L.legder(c, scl=-1)\narray([ -6.,  -9., -20.])\n; L.legder(c, 2,-1)\narray([  9.,  60.])\n\n", "; from numpy.polynomial import legendre as L\n; c = (1,2,3,4)\n; L.legder(c)\narray([  6.,   9.,  20.])\n; L.legder(c, 3)\narray([60.])\n; L.legder(c, scl=-1)\narray([ -6.,  -9., -20.])\n; L.legder(c, 2,-1)\narray([  9.,  60.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legcompanion", "code": "\nnumpy.polynomial.legendre.legcompanion(c)[source]\u00b6", "description": "Return the scaled companion matrix of c.\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is an Legendre basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters\n\ncarray_like1-D array of Legendre series coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayScaled companion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayScaled companion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.legadd", "code": "\nnumpy.polynomial.legendre.legadd(c1, c2)[source]\u00b6", "description": "Add one Legendre series to another.\nReturns the sum of two Legendre series c1 + c2.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Legendre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the Legendre series of their sum.\n\n\n\n\n\nSee also\nlegsub, legmulx, legmul, legdiv, legpow\n\nNotes\nUnlike multiplication, division, etc., the sum of two Legendre series\nis a Legendre series (without having to \u201creproject\u201d the result onto\nthe basis set) so addition, just like that of \u201cstandard\u201d polynomials,\nis simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial import legendre as L\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; L.legadd(c1,c2)\narray([4.,  4.,  4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the Legendre series of their sum.", "examples": ["; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legadd(c1,c2)\narray([4.,  4.,  4.])\n\n", "; from numpy.polynomial import legendre as L\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; L.legadd(c1,c2)\narray([4.,  4.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.left_shift", "code": "\nnumpy.left_shift(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'left_shift'&gt;\u00b6", "description": "Shift the bits of an integer to the left.\nBits are shifted to the left by appending x2 0s at the right of x1.\nSince the internal representation of numbers is in binary format, this\noperation is equivalent to multiplying x1 by 2**x2.\n\nParameters\n\nx1array_like of integer typeInput values.\n\nx2array_like of integer typeNumber of zeros to append to x1. Has to be non-negative.\nIf x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutarray of integer typeReturn x1 with bits shifted x2 times to the left.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nright_shiftShift the bits of an integer to the right.\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nExamples\n&gt;&gt;&gt; np.binary_repr(5)\n'101'\n&gt;&gt;&gt; np.left_shift(5, 2)\n20\n&gt;&gt;&gt; np.binary_repr(20)\n'10100'\n\n\n&gt;&gt;&gt; np.left_shift(5, [1,2,3])\narray([10, 20, 40])\n\n\n", "parameters": ["Parameters", "x1array_like of integer type", "x2array_like of integer type", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outarray of integer type"], "returns": "outarray of integer typeReturn x1 with bits shifted x2 times to the left.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.binary_repr(5)\n'101'\n; np.left_shift(5, 2)\n20\n; np.binary_repr(20)\n'10100'\n\n", "; np.binary_repr(5)\n'101'\n; np.left_shift(5, 2)\n20\n; np.binary_repr(20)\n'10100'\n", "; np.left_shift(5, [1,2,3])\narray([10, 20, 40])\n\n", "; np.left_shift(5, [1,2,3])\narray([10, 20, 40])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.leg2poly", "code": "\nnumpy.polynomial.legendre.leg2poly(c)[source]\u00b6", "description": "Convert a Legendre series to a polynomial.\nConvert an array representing the coefficients of a Legendre series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \u201cstandard\u201d basis) ordered\nfrom lowest to highest degree.\n\nParameters\n\ncarray_like1-D array containing the Legendre series coefficients, ordered\nfrom lowest order term to highest.\n\n\n\nReturns\n\npolndarray1-D array containing the coefficients of the equivalent polynomial\n(relative to the \u201cstandard\u201d basis) ordered from lowest order term\nto highest.\n\n\n\n\n\nSee also\npoly2leg\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy import polynomial as P\n&gt;&gt;&gt; c = P.Legendre(range(4))\n&gt;&gt;&gt; c\nLegendre([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n&gt;&gt;&gt; p = c.convert(kind=P.Polynomial)\n&gt;&gt;&gt; p\nPolynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1.,  1.])\n&gt;&gt;&gt; P.leg2poly(range(4))\narray([-1. , -3.5,  3. ,  7.5])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "polndarray"], "returns": "polndarray1-D array containing the coefficients of the equivalent polynomial(relative to the \u201cstandard\u201d basis) ordered from lowest order termto highest.", "examples": ["; from numpy import polynomial as P\n; c = P.Legendre(range(4))\n; c\nLegendre([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; p = c.convert(kind=P.Polynomial)\n; p\nPolynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1.,  1.])\n; P.leg2poly(range(4))\narray([-1. , -3.5,  3. ,  7.5])\n\n", "; from numpy import polynomial as P\n; c = P.Legendre(range(4))\n; c\nLegendre([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; p = c.convert(kind=P.Polynomial)\n; p\nPolynomial([-1. , -3.5,  3. ,  7.5], domain=[-1.,  1.], window=[-1.,  1.])\n; P.leg2poly(range(4))\narray([-1. , -3.5,  3. ,  7.5])\n"]},
{"library": "numpy", "item_id": "numpy.ldexp", "code": "\nnumpy.ldexp(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'ldexp'&gt;\u00b6", "description": "Returns x1 * 2**x2, element-wise.\nThe mantissas x1 and twos exponents x2 are used to construct\nfloating point numbers x1 * 2**x2.\n\nParameters\n\nx1array_likeArray of multipliers.\n\nx2array_like, intArray of twos exponents. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe result of x1 * 2**x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfrexpReturn (y1, y2) from x = y1 * 2**y2, inverse to ldexp.\n\n\n\nNotes\nComplex dtypes are not supported, they will raise a TypeError.\nldexp is useful as the inverse of frexp, if used by itself it is\nmore clear to simply use the expression x1 * 2**x2.\nExamples\n&gt;&gt;&gt; np.ldexp(5, np.arange(4))\narray([ 5., 10., 20., 40.], dtype=float16)\n\n\n&gt;&gt;&gt; x = np.arange(6)\n&gt;&gt;&gt; np.ldexp(*np.frexp(x))\narray([ 0.,  1.,  2.,  3.,  4.,  5.])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like, int", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe result of x1 * 2**x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.ldexp(5, np.arange(4))\narray([ 5., 10., 20., 40.], dtype=float16)\n\n", "; np.ldexp(5, np.arange(4))\narray([ 5., 10., 20., 40.], dtype=float16)\n", "; x = np.arange(6)\n; np.ldexp(*np.frexp(x))\narray([ 0.,  1.,  2.,  3.,  4.,  5.])\n\n", "; x = np.arange(6)\n; np.ldexp(*np.frexp(x))\narray([ 0.,  1.,  2.,  3.,  4.,  5.])\n"]},
{"library": "numpy", "item_id": "numpy.lcm", "code": "\nnumpy.lcm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'lcm'&gt;\u00b6", "description": "Returns the lowest common multiple of |x1| and |x2|\n\nParameters\n\nx1, x2array_like, intArrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\n\n\nReturns\n\nyndarray or scalarThe lowest common multiple of the absolute value of the inputs\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\ngcdThe greatest common divisor\n\n\n\nExamples\n&gt;&gt;&gt; np.lcm(12, 20)\n60\n&gt;&gt;&gt; np.lcm.reduce([3, 12, 20])\n60\n&gt;&gt;&gt; np.lcm.reduce([40, 12, 20])\n120\n&gt;&gt;&gt; np.lcm(np.arange(6), 20)\narray([ 0, 20, 20, 60, 20, 20])\n\n\n", "parameters": ["Parameters", "x1, x2array_like, int", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe lowest common multiple of the absolute value of the inputsThis is a scalar if both x1 and x2 are scalars.", "examples": ["; np.lcm(12, 20)\n60\n; np.lcm.reduce([3, 12, 20])\n60\n; np.lcm.reduce([40, 12, 20])\n120\n; np.lcm(np.arange(6), 20)\narray([ 0, 20, 20, 60, 20, 20])\n\n", "; np.lcm(12, 20)\n60\n; np.lcm.reduce([3, 12, 20])\n60\n; np.lcm.reduce([40, 12, 20])\n120\n; np.lcm(np.arange(6), 20)\narray([ 0, 20, 20, 60, 20, 20])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.laplace", "code": "\nRandomState.laplace(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).\nThe Laplace distribution is similar to the Gaussian/normal distribution,\nbut is sharper at the peak and has fatter tails. It represents the\ndifference between two independent, identically distributed exponential\nrandom variables.\n\nNote\nNew code should use the laplace method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalThe position, , of the distribution peak. Default is 0.\n\nscalefloat or array_like of floats, optional, the exponential decay. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Laplace distribution.\n\n\n\n\n\nSee also\n\nGenerator.laplacewhich should be used for new code.\n\n\n\nNotes\nIt has the probability density function\n\n\nThe first law of Laplace, from 1774, states that the frequency\nof an error can be expressed as an exponential function of the\nabsolute magnitude of the error, which leads to the Laplace\ndistribution. For many problems in economics and health\nsciences, this distribution seems to model the data better\nthan the standard Gaussian distribution.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nKotz, Samuel, et. al. \u201cThe Laplace Distribution and\nGeneralizations, \u201d Birkhauser, 2001.\n\n3\nWeisstein, Eric W. \u201cLaplace Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LaplaceDistribution.html\n\n4\nWikipedia, \u201cLaplace distribution\u201d,\nhttps://en.wikipedia.org/wiki/Laplace_distribution\n\n\nExamples\nDraw samples from the distribution\n&gt;&gt;&gt; loc, scale = 0., 1.\n&gt;&gt;&gt; s = np.random.laplace(loc, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; x = np.arange(-8., 8., .01)\n&gt;&gt;&gt; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n&gt;&gt;&gt; plt.plot(x, pdf)\n\n\nPlot Gaussian for comparison:\n&gt;&gt;&gt; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n&gt;&gt;&gt; plt.plot(x,g)\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Laplace distribution.", "examples": ["; loc, scale = 0., 1.\n; s = np.random.laplace(loc, scale, 1000)\n\n", "; loc, scale = 0., 1.\n; s = np.random.laplace(loc, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.laplace", "code": "\nGenerator.laplace(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).\nThe Laplace distribution is similar to the Gaussian/normal distribution,\nbut is sharper at the peak and has fatter tails. It represents the\ndifference between two independent, identically distributed exponential\nrandom variables.\n\nParameters\n\nlocfloat or array_like of floats, optionalThe position, , of the distribution peak. Default is 0.\n\nscalefloat or array_like of floats, optional, the exponential decay. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Laplace distribution.\n\n\n\n\nNotes\nIt has the probability density function\n\n\nThe first law of Laplace, from 1774, states that the frequency\nof an error can be expressed as an exponential function of the\nabsolute magnitude of the error, which leads to the Laplace\ndistribution. For many problems in economics and health\nsciences, this distribution seems to model the data better\nthan the standard Gaussian distribution.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nKotz, Samuel, et. al. \u201cThe Laplace Distribution and\nGeneralizations, \u201d Birkhauser, 2001.\n\n3\nWeisstein, Eric W. \u201cLaplace Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LaplaceDistribution.html\n\n4\nWikipedia, \u201cLaplace distribution\u201d,\nhttps://en.wikipedia.org/wiki/Laplace_distribution\n\n\nExamples\nDraw samples from the distribution\n&gt;&gt;&gt; loc, scale = 0., 1.\n&gt;&gt;&gt; s = np.random.default_rng().laplace(loc, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; x = np.arange(-8., 8., .01)\n&gt;&gt;&gt; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n&gt;&gt;&gt; plt.plot(x, pdf)\n\n\nPlot Gaussian for comparison:\n&gt;&gt;&gt; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n&gt;&gt;&gt; plt.plot(x,g)\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Laplace distribution.", "examples": ["; loc, scale = 0., 1.\n; s = np.random.default_rng().laplace(loc, scale, 1000)\n\n", "; loc, scale = 0., 1.\n; s = np.random.default_rng().laplace(loc, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagx", "code": "\nnumpy.polynomial.laguerre.lagx = array([ 1, -1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagvander3d", "code": "\nnumpy.polynomial.laguerre.lagvander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe degrees of the Laguerre polynomials.\nIf V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand  np.dot(V, c.flat) and lagval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D Laguerre\nseries of the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\nlagvander, lagvander3d, lagval2d, lagval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagzero", "code": "\nnumpy.polynomial.laguerre.lagzero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.laplace", "code": "\nnumpy.random.laplace(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).\nThe Laplace distribution is similar to the Gaussian/normal distribution,\nbut is sharper at the peak and has fatter tails. It represents the\ndifference between two independent, identically distributed exponential\nrandom variables.\n\nNote\nNew code should use the laplace method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalThe position, , of the distribution peak. Default is 0.\n\nscalefloat or array_like of floats, optional, the exponential decay. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Laplace distribution.\n\n\n\n\n\nSee also\n\nGenerator.laplacewhich should be used for new code.\n\n\n\nNotes\nIt has the probability density function\n\n\nThe first law of Laplace, from 1774, states that the frequency\nof an error can be expressed as an exponential function of the\nabsolute magnitude of the error, which leads to the Laplace\ndistribution. For many problems in economics and health\nsciences, this distribution seems to model the data better\nthan the standard Gaussian distribution.\nReferences\n\n1\nAbramowitz, M. and Stegun, I. A. (Eds.). \u201cHandbook of\nMathematical Functions with Formulas, Graphs, and Mathematical\nTables, 9th printing,\u201d New York: Dover, 1972.\n\n2\nKotz, Samuel, et. al. \u201cThe Laplace Distribution and\nGeneralizations, \u201d Birkhauser, 2001.\n\n3\nWeisstein, Eric W. \u201cLaplace Distribution.\u201d\nFrom MathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/LaplaceDistribution.html\n\n4\nWikipedia, \u201cLaplace distribution\u201d,\nhttps://en.wikipedia.org/wiki/Laplace_distribution\n\n\nExamples\nDraw samples from the distribution\n&gt;&gt;&gt; loc, scale = 0., 1.\n&gt;&gt;&gt; s = np.random.laplace(loc, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; x = np.arange(-8., 8., .01)\n&gt;&gt;&gt; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n&gt;&gt;&gt; plt.plot(x, pdf)\n\n\nPlot Gaussian for comparison:\n&gt;&gt;&gt; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n&gt;&gt;&gt; plt.plot(x,g)\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Laplace distribution.", "examples": ["; loc, scale = 0., 1.\n; s = np.random.laplace(loc, scale, 1000)\n\n", "; loc, scale = 0., 1.\n; s = np.random.laplace(loc, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; x = np.arange(-8., 8., .01)\n; pdf = np.exp(-abs(x-loc)/scale)/(2.*scale)\n; plt.plot(x, pdf)\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n\n", "; g = (1/(scale * np.sqrt(2 * np.pi)) *\n...      np.exp(-(x - loc)**2 / (2 * scale**2)))\n; plt.plot(x,g)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagweight", "code": "\nnumpy.polynomial.laguerre.lagweight(x)[source]\u00b6", "description": "Weight function of the Laguerre polynomials.\nThe weight function is  and the interval of integration\nis . The Laguerre polynomials are orthogonal, but not\nnormalized, with respect to this weight function.\n\nParameters\n\nxarray_likeValues at which the weight function will be computed.\n\n\n\nReturns\n\nwndarrayThe weight function at x.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "wndarray"], "returns": "wndarrayThe weight function at x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagval3d", "code": "\nnumpy.polynomial.laguerre.lagval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Laguerre series at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimension polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\nlagval, lagval2d, laggrid2d, laggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimension polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagval2d", "code": "\nnumpy.polynomial.laguerre.lagval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Laguerre series at points (x, y).\nThis function returns the values:\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and if it isn\u2019t an ndarray it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than two the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points formed with\npairs of corresponding values from x and y.\n\n\n\n\n\nSee also\nlagval, laggrid2d, lagval3d, laggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points formed withpairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagvander", "code": "\nnumpy.polynomial.laguerre.lagvander(x, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degree.\nReturns the pseudo-Vandermonde matrix of degree deg and sample points\nx. The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the degree of the Laguerre polynomial.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\narray V = lagvander(x, n), then np.dot(V, c) and\nlagval(x, c) are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of Laguerre series of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where The last index is the degree of the\ncorresponding Laguerre polynomial.  The dtype will be the same as\nthe converted x.\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagvander\n&gt;&gt;&gt; x = np.array([0, 1, 2])\n&gt;&gt;&gt; lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])\n\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray"], "returns": "vanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where The last index is the degree of thecorresponding Laguerre polynomial.  The dtype will be the same asthe converted x.", "examples": ["; from numpy.polynomial.laguerre import lagvander\n; x = np.array([0, 1, 2])\n; lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])\n\n", "; from numpy.polynomial.laguerre import lagvander\n; x = np.array([0, 1, 2])\n; lagvander(x, 3)\narray([[ 1.        ,  1.        ,  1.        ,  1.        ],\n       [ 1.        ,  0.        , -0.5       , -0.66666667],\n       [ 1.        , -1.        , -1.        , -0.33333333]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagvander2d", "code": "\nnumpy.polynomial.laguerre.lagvander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the degrees of\nthe Laguerre polynomials.\nIf V = lagvander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and lagval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D Laguerre\nseries of the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to\n1-D arrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\nlagvander, lagvander3d, lagval2d, lagval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagval", "code": "\nnumpy.polynomial.laguerre.lagval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate a Laguerre series at points x.\nIf c is of length n + 1, this function returns the value:\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, algebra_likeThe shape of the return value is described above.\n\n\n\n\n\nSee also\nlagval2d, laggrid2d, lagval3d, laggrid3d\n\nNotes\nThe evaluation uses Clenshaw recursion, aka synthetic division.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagval\n&gt;&gt;&gt; coef = [1,2,3]\n&gt;&gt;&gt; lagval(1, coef)\n-0.5\n&gt;&gt;&gt; lagval([[1,2],[3,4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])\n\n\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, algebra_like"], "returns": "valuesndarray, algebra_likeThe shape of the return value is described above.", "examples": ["; from numpy.polynomial.laguerre import lagval\n; coef = [1,2,3]\n; lagval(1, coef)\n-0.5\n; lagval([[1,2],[3,4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])\n\n", "; from numpy.polynomial.laguerre import lagval\n; coef = [1,2,3]\n; lagval(1, coef)\n-0.5\n; lagval([[1,2],[3,4]], coef)\narray([[-0.5, -4. ],\n       [-4.5, -2. ]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre", "code": "\nclass numpy.polynomial.laguerre.Laguerre(coef, domain=None, window=None)[source]\u00b6", "description": "A Laguerre series class.\nThe Laguerre class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nattributes and methods listed in the ABCPolyBase documentation.\n\nParameters\n\ncoefarray_likeLaguerre coefficients in order of increasing degree, i.e,\n(1, 2, 3) gives 1*L_0(x) + 2*L_1(X) + 3*L_2(x).\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [0, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [0, 1].\n\nNew in version 1.6.0.\n\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagtrim", "code": "\nnumpy.polynomial.laguerre.lagtrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagsub", "code": "\nnumpy.polynomial.laguerre.lagsub(c1, c2)[source]\u00b6", "description": "Subtract one Laguerre series from another.\nReturns the difference of two Laguerre series c1 - c2.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Laguerre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Laguerre series coefficients representing their difference.\n\n\n\n\n\nSee also\nlagadd, lagmulx, lagmul, lagdiv, lagpow\n\nNotes\nUnlike multiplication, division, etc., the difference of two Laguerre\nseries is a Laguerre series (without having to \u201creproject\u201d the result\nonto the basis set) so subtraction, just like that of \u201cstandard\u201d\npolynomials, is simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagsub\n&gt;&gt;&gt; lagsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Laguerre series coefficients representing their difference.", "examples": ["; from numpy.polynomial.laguerre import lagsub\n; lagsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n\n", "; from numpy.polynomial.laguerre import lagsub\n; lagsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagone", "code": "\nnumpy.polynomial.laguerre.lagone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagmul", "code": "\nnumpy.polynomial.laguerre.lagmul(c1, c2)[source]\u00b6", "description": "Multiply one Laguerre series by another.\nReturns the product of two Laguerre series c1 * c2.  The arguments\nare sequences of coefficients, from lowest order \u201cterm\u201d to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Laguerre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Laguerre series coefficients representing their product.\n\n\n\n\n\nSee also\nlagadd, lagsub, lagmulx, lagdiv, lagpow\n\nNotes\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Laguerre polynomial basis set.  Thus, to express\nthe product as a Laguerre series, it is necessary to \u201creproject\u201d the\nproduct onto said basis set, which may produce \u201cunintuitive\u201d (but\ncorrect) results; see Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagmul\n&gt;&gt;&gt; lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Laguerre series coefficients representing their product.", "examples": ["; from numpy.polynomial.laguerre import lagmul\n; lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])\n\n", "; from numpy.polynomial.laguerre import lagmul\n; lagmul([1, 2, 3], [0, 1, 2])\narray([  8., -13.,  38., -51.,  36.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagroots", "code": "\nnumpy.polynomial.laguerre.lagroots(c)[source]\u00b6", "description": "Compute the roots of a Laguerre series.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the series. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\npolyroots, legroots, chebroots, hermroots, hermeroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton\u2019s method.\nThe Laguerre series basis polynomials aren\u2019t powers of x so the\nresults of this function may seem unintuitive.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagroots, lagfromroots\n&gt;&gt;&gt; coef = lagfromroots([0, 1, 2])\n&gt;&gt;&gt; coef\narray([  2.,  -8.,  12.,  -6.])\n&gt;&gt;&gt; lagroots(coef)\narray([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the series. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; from numpy.polynomial.laguerre import lagroots, lagfromroots\n; coef = lagfromroots([0, 1, 2])\n; coef\narray([  2.,  -8.,  12.,  -6.])\n; lagroots(coef)\narray([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])\n\n", "; from numpy.polynomial.laguerre import lagroots, lagfromroots\n; coef = lagfromroots([0, 1, 2])\n; coef\narray([  2.,  -8.,  12.,  -6.])\n; lagroots(coef)\narray([-4.4408921e-16,  1.0000000e+00,  2.0000000e+00])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagline", "code": "\nnumpy.polynomial.laguerre.lagline(off, scl)[source]\u00b6", "description": "Laguerre series whose graph is a straight line.\n\nParameters\n\noff, sclscalarsThe specified line is given by off + scl*x.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the Laguerre series for\noff + scl*x.\n\n\n\n\n\nSee also\npolyline, chebline\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagline, lagval\n&gt;&gt;&gt; lagval(0,lagline(3, 2))\n3.0\n&gt;&gt;&gt; lagval(1,lagline(3, 2))\n5.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the Laguerre series foroff + scl*x.", "examples": ["; from numpy.polynomial.laguerre import lagline, lagval\n; lagval(0,lagline(3, 2))\n3.0\n; lagval(1,lagline(3, 2))\n5.0\n\n", "; from numpy.polynomial.laguerre import lagline, lagval\n; lagval(0,lagline(3, 2))\n3.0\n; lagval(1,lagline(3, 2))\n5.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagint", "code": "\nnumpy.polynomial.laguerre.lagint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a Laguerre series.\nReturns the Laguerre series coefficients c integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument c is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series L_0 + 2*L_1 + 3*L_2 while [[1,2],[1,2]]\nrepresents 1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) + 2*L_0(x)*L_1(y) +\n2*L_1(x)*L_1(y) if axis=0 is x and axis=1 is y.\n\nParameters\n\ncarray_likeArray of Laguerre series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at\nlbnd is the first value in the list, the value of the second\nintegral at lbnd is the second value, etc.  If k == [] (the\ndefault), all constants are set to zero.  If m == 1, a single\nscalar can be given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayLaguerre series coefficients of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 0, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\nlagder\n\nNotes\nNote that the result of each integration is multiplied by scl.\nWhy is this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x.  Then\n, so one will need to set scl equal to\n - perhaps not what one would have first thought.\nAlso note that, in general, the result of integrating a C-series needs\nto be \u201creprojected\u201d onto the C-series basis set.  Thus, typically,\nthe result of this function is \u201cunintuitive,\u201d albeit correct; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagint\n&gt;&gt;&gt; lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n&gt;&gt;&gt; lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n&gt;&gt;&gt; lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n&gt;&gt;&gt; lagint([1,2,3], lbnd=-1)\narray([11.5,  1. ,  1. , -3. ])\n&gt;&gt;&gt; lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayLaguerre series coefficients of the integral.", "examples": ["; from numpy.polynomial.laguerre import lagint\n; lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n; lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n; lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n; lagint([1,2,3], lbnd=-1)\narray([11.5,  1. ,  1. , -3. ])\n; lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary\n\n", "; from numpy.polynomial.laguerre import lagint\n; lagint([1,2,3])\narray([ 1.,  1.,  1., -3.])\n; lagint([1,2,3], m=2)\narray([ 1.,  0.,  0., -4.,  3.])\n; lagint([1,2,3], k=1)\narray([ 2.,  1.,  1., -3.])\n; lagint([1,2,3], lbnd=-1)\narray([11.5,  1. ,  1. , -3. ])\n; lagint([1,2], m=2, k=[1,2], lbnd=-1)\narray([ 11.16666667,  -5.        ,  -3.        ,   2.        ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.laggrid3d", "code": "\nnumpy.polynomial.laguerre.laggrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nlagval, lagval2d, laggrid2d, lagval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagpow", "code": "\nnumpy.polynomial.laguerre.lagpow(c, pow, maxpower=16)[source]\u00b6", "description": "Raise a Laguerre series to a power.\nReturns the Laguerre series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\ncarray_like1-D array of Laguerre series coefficients ordered from low to\nhigh.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayLaguerre series of power.\n\n\n\n\n\nSee also\nlagadd, lagsub, lagmulx, lagmul, lagdiv\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagpow\n&gt;&gt;&gt; lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])\n\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayLaguerre series of power.", "examples": ["; from numpy.polynomial.laguerre import lagpow\n; lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])\n\n", "; from numpy.polynomial.laguerre import lagpow\n; lagpow([1, 2, 3], 2)\narray([ 14., -16.,  56., -72.,  54.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagmulx", "code": "\nnumpy.polynomial.laguerre.lagmulx(c)[source]\u00b6", "description": "Multiply a Laguerre series by x.\nMultiply the Laguerre series c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of Laguerre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\n\nSee also\nlagadd, lagsub, lagmul, lagdiv, lagpow\n\nNotes\nThe multiplication uses the recursion relationship for Laguerre\npolynomials in the form\n\n\nxP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagmulx\n&gt;&gt;&gt; lagmulx([1, 2, 3])\narray([-1.,  -1.,  11.,  -9.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": ["; from numpy.polynomial.laguerre import lagmulx\n; lagmulx([1, 2, 3])\narray([-1.,  -1.,  11.,  -9.])\n\n", "; from numpy.polynomial.laguerre import lagmulx\n; lagmulx([1, 2, 3])\narray([-1.,  -1.,  11.,  -9.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagfromroots", "code": "\nnumpy.polynomial.laguerre.lagfromroots(roots)[source]\u00b6", "description": "Generate a Laguerre series with given roots.\nThe function returns the coefficients of the polynomial\n\n\nin Laguerre form, where the r_n are the roots specified in roots.\nIf a zero has multiplicity n, then it must appear in roots n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then roots looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in Laguerre form.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of coefficients.  If all roots are real then out is a\nreal array, if some of the roots are complex, then out is complex\neven if all the coefficients in the result are real (see Examples\nbelow).\n\n\n\n\n\nSee also\npolyfromroots, legfromroots, chebfromroots, hermfromroots, hermefromroots\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagfromroots, lagval\n&gt;&gt;&gt; coef = lagfromroots((-1, 0, 1))\n&gt;&gt;&gt; lagval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n&gt;&gt;&gt; coef = lagfromroots((-1j, 1j))\n&gt;&gt;&gt; lagval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of coefficients.  If all roots are real then out is areal array, if some of the roots are complex, then out is complexeven if all the coefficients in the result are real (see Examplesbelow).", "examples": ["; from numpy.polynomial.laguerre import lagfromroots, lagval\n; coef = lagfromroots((-1, 0, 1))\n; lagval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n; coef = lagfromroots((-1j, 1j))\n; lagval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n", "; from numpy.polynomial.laguerre import lagfromroots, lagval\n; coef = lagfromroots((-1, 0, 1))\n; lagval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n; coef = lagfromroots((-1j, 1j))\n; lagval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.laggrid2d", "code": "\nnumpy.polynomial.laguerre.laggrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Laguerre series on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j is contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in the\nCartesian product of x and y.\n\n\n\n\n\nSee also\nlagval, lagval2d, lagval3d, laggrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in theCartesian product of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.laggauss", "code": "\nnumpy.polynomial.laguerre.laggauss(deg)[source]\u00b6", "description": "Gauss-Laguerre quadrature.\nComputes the sample points and weights for Gauss-Laguerre quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree  or less over the interval \nwith the weight function .\n\nParameters\n\ndegintNumber of sample points and weights. It must be &gt;= 1.\n\n\n\nReturns\n\nxndarray1-D ndarray containing the sample points.\n\nyndarray1-D ndarray containing the weights.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nThe results have only been tested up to degree 100 higher degrees may\nbe problematic. The weights are determined by using the fact that\n\n\nwhere  is a constant independent of  and \nis the k\u2019th root of , and then scaling the results to get\nthe right value when integrating 1.\n", "parameters": ["Parameters", "degint", "Returns", "xndarray", "yndarray"], "returns": "xndarray1-D ndarray containing the sample points.yndarray1-D ndarray containing the weights.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagfit", "code": "\nnumpy.polynomial.laguerre.lagfit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least squares fit of Laguerre series to data.\nReturn the coefficients of a Laguerre series of degree deg that is the\nleast squares fit to the data values y given at points x. If y is\n1-D the returned coefficients will also be 1-D. If y is 2-D multiple\nfits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\n\n\nReturns\n\ncoefndarray, shape (M,) or (M, K)Laguerre coefficients ordered from low to high. If y was 2-D,\nthe coefficients for the data in column k  of y are in column\nk.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.  The\nwarnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\nchebfit, legfit, polyfit, hermfit, hermefit\n\nlagvalEvaluates a Laguerre series.\n\nlagvanderpseudo Vandermonde matrix of Laguerre series.\n\nlagweightLaguerre weight function.\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the Laguerre series p that\nminimizes the sum of the weighted squared errors\n\n\nwhere the  are the weights. This problem is solved by\nsetting up as the (typically) overdetermined matrix equation\n\n\nwhere V is the weighted pseudo Vandermonde matrix of x, c are the\ncoefficients to be solved for, w are the weights, and y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected, then a RankWarning will be issued. This means that the\ncoefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The rcond parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\nFits using Laguerre series are probably most useful when the data can\nbe approximated by sqrt(w(x)) * p(x), where w(x) is the Laguerre\nweight. In that case the weight sqrt(w(x[i]) should be used\ntogether with data values y[i]/sqrt(w(x[i]). The weight function is\navailable as lagweight.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagfit, lagval\n&gt;&gt;&gt; x = np.linspace(0, 10)\n&gt;&gt;&gt; err = np.random.randn(len(x))/10\n&gt;&gt;&gt; y = lagval(x, [1, 2, 3]) + err\n&gt;&gt;&gt; lagfit(x, y, 2)\narray([ 0.96971004,  2.00193749,  3.00288744]) # may vary\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (M,) or (M, K)", "[residuals, rank, singular_values, rcond]list", "Warns", "RankWarning"], "returns": "coefndarray, shape (M,) or (M, K)Laguerre coefficients ordered from low to high. If y was 2-D,the coefficients for the data in column k  of y are in columnk.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": ["; from numpy.polynomial.laguerre import lagfit, lagval\n; x = np.linspace(0, 10)\n; err = np.random.randn(len(x))/10\n; y = lagval(x, [1, 2, 3]) + err\n; lagfit(x, y, 2)\narray([ 0.96971004,  2.00193749,  3.00288744]) # may vary\n\n", "; from numpy.polynomial.laguerre import lagfit, lagval\n; x = np.linspace(0, 10)\n; err = np.random.randn(len(x))/10\n; y = lagval(x, [1, 2, 3]) + err\n; lagfit(x, y, 2)\narray([ 0.96971004,  2.00193749,  3.00288744]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagdomain", "code": "\nnumpy.polynomial.laguerre.lagdomain = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagdiv", "code": "\nnumpy.polynomial.laguerre.lagdiv(c1, c2)[source]\u00b6", "description": "Divide one Laguerre series by another.\nReturns the quotient-with-remainder of two Laguerre series\nc1 / c2.  The arguments are sequences of coefficients from lowest\norder \u201cterm\u201d to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Laguerre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\n[quo, rem]ndarraysOf Laguerre series coefficients representing the quotient and\nremainder.\n\n\n\n\n\nSee also\nlagadd, lagsub, lagmulx, lagmul, lagpow\n\nNotes\nIn general, the (polynomial) division of one Laguerre series by another\nresults in quotient and remainder terms that are not in the Laguerre\npolynomial basis set.  Thus, to express these results as a Laguerre\nseries, it is necessary to \u201creproject\u201d the results onto the Laguerre\nbasis set, which may produce \u201cunintuitive\u201d (but correct) results; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagdiv\n&gt;&gt;&gt; lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n&gt;&gt;&gt; lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "[quo, rem]ndarrays"], "returns": "[quo, rem]ndarraysOf Laguerre series coefficients representing the quotient andremainder.", "examples": ["; from numpy.polynomial.laguerre import lagdiv\n; lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n\n", "; from numpy.polynomial.laguerre import lagdiv\n; lagdiv([  8., -13.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; lagdiv([  9., -12.,  38., -51.,  36.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagder", "code": "\nnumpy.polynomial.laguerre.lagder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a Laguerre series.\nReturns the Laguerre series coefficients c differentiated m times\nalong axis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable). The argument\nc is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series 1*L_0 + 2*L_1 + 3*L_2\nwhile [[1,2],[1,2]] represents 1*L_0(x)*L_0(y) + 1*L_1(x)*L_0(y) +\n2*L_0(x)*L_1(y) + 2*L_1(x)*L_1(y) if axis=0 is x and axis=1 is\ny.\n\nParameters\n\ncarray_likeArray of Laguerre series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change of\nvariable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayLaguerre series of the derivative.\n\n\n\n\n\nSee also\nlagint\n\nNotes\nIn general, the result of differentiating a Laguerre series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \u201cunintuitive,\u201d albeit correct; see Examples section\nbelow.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagder\n&gt;&gt;&gt; lagder([ 1.,  1.,  1., -3.])\narray([1.,  2.,  3.])\n&gt;&gt;&gt; lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([1.,  2.,  3.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayLaguerre series of the derivative.", "examples": ["; from numpy.polynomial.laguerre import lagder\n; lagder([ 1.,  1.,  1., -3.])\narray([1.,  2.,  3.])\n; lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([1.,  2.,  3.])\n\n", "; from numpy.polynomial.laguerre import lagder\n; lagder([ 1.,  1.,  1., -3.])\narray([1.,  2.,  3.])\n; lagder([ 1.,  0.,  0., -4.,  3.], m=2)\narray([1.,  2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagcompanion", "code": "\nnumpy.polynomial.laguerre.lagcompanion(c)[source]\u00b6", "description": "Return the companion matrix of c.\nThe usual companion matrix of the Laguerre polynomials is already\nsymmetric when c is a basis Laguerre polynomial, so no scaling is\napplied.\n\nParameters\n\ncarray_like1-D array of Laguerre series coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayCompanion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayCompanion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lagadd", "code": "\nnumpy.polynomial.laguerre.lagadd(c1, c2)[source]\u00b6", "description": "Add one Laguerre series to another.\nReturns the sum of two Laguerre series c1 + c2.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Laguerre series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the Laguerre series of their sum.\n\n\n\n\n\nSee also\nlagsub, lagmulx, lagmul, lagdiv, lagpow\n\nNotes\nUnlike multiplication, division, etc., the sum of two Laguerre series\nis a Laguerre series (without having to \u201creproject\u201d the result onto\nthe basis set) so addition, just like that of \u201cstandard\u201d polynomials,\nis simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lagadd\n&gt;&gt;&gt; lagadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the Laguerre series of their sum.", "examples": ["; from numpy.polynomial.laguerre import lagadd\n; lagadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n\n", "; from numpy.polynomial.laguerre import lagadd\n; lagadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.lag2poly", "code": "\nnumpy.polynomial.laguerre.lag2poly(c)[source]\u00b6", "description": "Convert a Laguerre series to a polynomial.\nConvert an array representing the coefficients of a Laguerre series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \u201cstandard\u201d basis) ordered\nfrom lowest to highest degree.\n\nParameters\n\ncarray_like1-D array containing the Laguerre series coefficients, ordered\nfrom lowest order term to highest.\n\n\n\nReturns\n\npolndarray1-D array containing the coefficients of the equivalent polynomial\n(relative to the \u201cstandard\u201d basis) ordered from lowest order term\nto highest.\n\n\n\n\n\nSee also\npoly2lag\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.laguerre import lag2poly\n&gt;&gt;&gt; lag2poly([ 23., -63.,  58., -18.])\narray([0., 1., 2., 3.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "polndarray"], "returns": "polndarray1-D array containing the coefficients of the equivalent polynomial(relative to the \u201cstandard\u201d basis) ordered from lowest order termto highest.", "examples": ["; from numpy.polynomial.laguerre import lag2poly\n; lag2poly([ 23., -63.,  58., -18.])\narray([0., 1., 2., 3.])\n\n", "; from numpy.polynomial.laguerre import lag2poly\n; lag2poly([ 23., -63.,  58., -18.])\narray([0., 1., 2., 3.])\n"]},
{"library": "numpy", "item_id": "numpy.kron", "code": "\nnumpy.kron(a, b)[source]\u00b6", "description": "Kronecker product of two arrays.\nComputes the Kronecker product, a composite array made of blocks of the\nsecond array scaled by the first.\n\nParameters\n\na, barray_like\n\n\nReturns\n\noutndarray\n\n\n\n\nSee also\n\nouterThe outer product\n\n\n\nNotes\nThe function assumes that the number of dimensions of a and b\nare the same, if necessary prepending the smallest with ones.\nIf a.shape = (r0,r1,..,rN) and b.shape = (s0,s1,\u2026,sN),\nthe Kronecker product has shape (r0*s0, r1*s1, \u2026, rN*SN).\nThe elements are products of elements from a and b, organized\nexplicitly by:\nkron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]\n\n\nwhere:\nkt = it * st + jt,  t = 0,...,N\n\n\nIn the common 2-D case (N=1), the block structure can be visualized:\n[[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],\n [  ...                              ...   ],\n [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]\n\n\nExamples\n&gt;&gt;&gt; np.kron([1,10,100], [5,6,7])\narray([  5,   6,   7, ..., 500, 600, 700])\n&gt;&gt;&gt; np.kron([5,6,7], [1,10,100])\narray([  5,  50, 500, ...,   7,  70, 700])\n\n\n&gt;&gt;&gt; np.kron(np.eye(2), np.ones((2,2)))\narray([[1.,  1.,  0.,  0.],\n       [1.,  1.,  0.,  0.],\n       [0.,  0.,  1.,  1.],\n       [0.,  0.,  1.,  1.]])\n\n\n&gt;&gt;&gt; a = np.arange(100).reshape((2,5,2,5))\n&gt;&gt;&gt; b = np.arange(24).reshape((2,3,4))\n&gt;&gt;&gt; c = np.kron(a,b)\n&gt;&gt;&gt; c.shape\n(2, 10, 6, 20)\n&gt;&gt;&gt; I = (1,3,0,2)\n&gt;&gt;&gt; J = (0,2,1)\n&gt;&gt;&gt; J1 = (0,) + J             # extend to ndim=4\n&gt;&gt;&gt; S1 = (1,) + b.shape\n&gt;&gt;&gt; K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n&gt;&gt;&gt; c[K] == a[I]*b[J]\nTrue\n\n\n", "parameters": ["Parameters", "a, barray_like", "Returns", "outndarray"], "returns": "outndarray", "examples": ["; np.kron([1,10,100], [5,6,7])\narray([  5,   6,   7, ..., 500, 600, 700])\n; np.kron([5,6,7], [1,10,100])\narray([  5,  50, 500, ...,   7,  70, 700])\n\n", "; np.kron([1,10,100], [5,6,7])\narray([  5,   6,   7, ..., 500, 600, 700])\n; np.kron([5,6,7], [1,10,100])\narray([  5,  50, 500, ...,   7,  70, 700])\n", "; np.kron(np.eye(2), np.ones((2,2)))\narray([[1.,  1.,  0.,  0.],\n       [1.,  1.,  0.,  0.],\n       [0.,  0.,  1.,  1.],\n       [0.,  0.,  1.,  1.]])\n\n", "; np.kron(np.eye(2), np.ones((2,2)))\narray([[1.,  1.,  0.,  0.],\n       [1.,  1.,  0.,  0.],\n       [0.,  0.,  1.,  1.],\n       [0.,  0.,  1.,  1.]])\n", "; a = np.arange(100).reshape((2,5,2,5))\n; b = np.arange(24).reshape((2,3,4))\n; c = np.kron(a,b)\n; c.shape\n(2, 10, 6, 20)\n; I = (1,3,0,2)\n; J = (0,2,1)\n; J1 = (0,) + J             # extend to ndim=4\n; S1 = (1,) + b.shape\n; K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n; c[K] == a[I]*b[J]\nTrue\n\n", "; a = np.arange(100).reshape((2,5,2,5))\n; b = np.arange(24).reshape((2,3,4))\n; c = np.kron(a,b)\n; c.shape\n(2, 10, 6, 20)\n; I = (1,3,0,2)\n; J = (0,2,1)\n; J1 = (0,) + J             # extend to ndim=4\n; S1 = (1,) + b.shape\n; K = tuple(np.array(I) * np.array(S1) + np.array(J1))\n; c[K] == a[I]*b[J]\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.testing.dec.knownfailureif", "code": "\nnumpy.testing.dec.knownfailureif(fail_condition, msg=None)\u00b6", "description": "Make function raise KnownFailureException exception if given condition is true.\nIf the condition is a callable, it is used at runtime to dynamically\nmake the decision. This is useful for tests that may require costly\nimports, to delay the cost until the test suite is actually executed.\n\nParameters\n\nfail_conditionbool or callableFlag to determine whether to mark the decorated test as a known\nfailure (if True) or not (if False).\n\nmsgstr, optionalMessage to give on raising a KnownFailureException exception.\nDefault is None.\n\n\n\nReturns\n\ndecoratorfunctionDecorator, which, when applied to a function, causes\nKnownFailureException to be raised when fail_condition is True,\nand the function to be called normally otherwise.\n\n\n\n\nNotes\nThe decorator itself is decorated with the nose.tools.make_decorator\nfunction in order to transmit function name, and various other metadata.\n", "parameters": ["Parameters", "fail_conditionbool or callable", "msgstr, optional", "Returns", "decoratorfunction"], "returns": "decoratorfunctionDecorator, which, when applied to a function, causesKnownFailureException to be raised when fail_condition is True,and the function to be called normally otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.kind", "code": "\ndtype.kind\u00b6", "description": "A character code (one of \u2018biufcmMOSUV\u2019) identifying the general kind of data.\n\n\n\n\n\n\nb\nboolean\n\ni\nsigned integer\n\nu\nunsigned integer\n\nf\nfloating-point\n\nc\ncomplex floating-point\n\nm\ntimedelta\n\nM\ndatetime\n\nO\nobject\n\nS\n(byte-)string\n\nU\nUnicode\n\nV\nvoid\n\n\n\nExamples\n&gt;&gt;&gt; dt = np.dtype('i4')\n&gt;&gt;&gt; dt.kind\n'i'\n&gt;&gt;&gt; dt = np.dtype('f8')\n&gt;&gt;&gt; dt.kind\n'f'\n&gt;&gt;&gt; dt = np.dtype([('field1', 'f8')])\n&gt;&gt;&gt; dt.kind\n'V'\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype('i4')\n; dt.kind\n'i'\n; dt = np.dtype('f8')\n; dt.kind\n'f'\n; dt = np.dtype([('field1', 'f8')])\n; dt.kind\n'V'\n\n", "; dt = np.dtype('i4')\n; dt.kind\n'i'\n; dt = np.dtype('f8')\n; dt.kind\n'f'\n; dt = np.dtype([('field1', 'f8')])\n; dt.kind\n'V'\n"]},
{"library": "numpy", "item_id": "numpy.kaiser", "code": "\nnumpy.kaiser(M, beta)[source]\u00b6", "description": "Return the Kaiser window.\nThe Kaiser window is a taper formed by using a Bessel function.\n\nParameters\n\nMintNumber of points in the output window. If zero or less, an\nempty array is returned.\n\nbetafloatShape parameter for window.\n\n\n\nReturns\n\noutarrayThe window, with the maximum value normalized to one (the value\none appears only if the number of samples is odd).\n\n\n\n\n\nSee also\nbartlett, blackman, hamming, hanning\n\nNotes\nThe Kaiser window is defined as\n\n\nwith\n\n\nwhere  is the modified zeroth-order Bessel function.\nThe Kaiser was named for Jim Kaiser, who discovered a simple\napproximation to the DPSS window based on Bessel functions.  The Kaiser\nwindow is a very good approximation to the Digital Prolate Spheroidal\nSequence, or Slepian window, which is the transform which maximizes the\nenergy in the main lobe of the window relative to total energy.\nThe Kaiser can approximate many other windows by varying the beta\nparameter.\n\n\n\n\n\n\nbeta\nWindow shape\n\n\n\n0\nRectangular\n\n5\nSimilar to a Hamming\n\n6\nSimilar to a Hanning\n\n8.6\nSimilar to a Blackman\n\n\n\nA beta value of 14 is probably a good starting point. Note that as beta\ngets large, the window narrows, and so the number of samples needs to be\nlarge enough to sample the increasingly narrow spike, otherwise NaNs will\nget returned.\nMost references to the Kaiser window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\u201cremoving the foot\u201d, i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\nReferences\n\n1\nJ. F. Kaiser, \u201cDigital Filters\u201d - Ch 7 in \u201cSystems analysis by\ndigital computer\u201d, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.\nJohn Wiley and Sons, New York, (1966).\n\n2\nE.R. Kanasewich, \u201cTime Sequence Analysis in Geophysics\u201d, The\nUniversity of Alberta Press, 1975, pp. 177-178.\n\n3\nWikipedia, \u201cWindow function\u201d,\nhttps://en.wikipedia.org/wiki/Window_function\n\n\nExamples\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; np.kaiser(12, 14)\n array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n\nPlot the window and the frequency response:\n&gt;&gt;&gt; from numpy.fft import fft, fftshift\n&gt;&gt;&gt; window = np.kaiser(51, 14)\n&gt;&gt;&gt; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Kaiser window\")\nText(0.5, 1.0, 'Kaiser window')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n&gt;&gt;&gt; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n&gt;&gt;&gt; A = fft(window, 2048) / 25.5\n&gt;&gt;&gt; mag = np.abs(fftshift(A))\n&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))\n&gt;&gt;&gt; response = 20 * np.log10(mag)\n&gt;&gt;&gt; response = np.clip(response, -100, 100)\n&gt;&gt;&gt; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Frequency response of Kaiser window\")\nText(0.5, 1.0, 'Frequency response of Kaiser window')\n&gt;&gt;&gt; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n&gt;&gt;&gt; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n&gt;&gt;&gt; plt.axis('tight')\n(-0.5, 0.5, -100.0, ...) # may vary\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "Mint", "betafloat", "Returns", "outarray"], "returns": "outarrayThe window, with the maximum value normalized to one (the valueone appears only if the number of samples is odd).", "examples": ["; import matplotlib.pyplot as plt\n; np.kaiser(12, 14)\n array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n\n", "; import matplotlib.pyplot as plt\n; np.kaiser(12, 14)\n array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary\n        2.29737120e-01, 5.99885316e-01, 9.45674898e-01,\n        9.45674898e-01, 5.99885316e-01, 2.29737120e-01,\n        4.65200189e-02, 3.46009194e-03, 7.72686684e-06])\n", "; from numpy.fft import fft, fftshift\n; window = np.kaiser(51, 14)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Kaiser window\")\nText(0.5, 1.0, 'Kaiser window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n\n", "; from numpy.fft import fft, fftshift\n; window = np.kaiser(51, 14)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Kaiser window\")\nText(0.5, 1.0, 'Kaiser window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; response = 20 * np.log10(mag)\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Kaiser window\")\nText(0.5, 1.0, 'Frequency response of Kaiser window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n(-0.5, 0.5, -100.0, ...) # may vary\n; plt.show()\n\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; response = 20 * np.log10(mag)\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Kaiser window\")\nText(0.5, 1.0, 'Frequency response of Kaiser window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n(-0.5, 0.5, -100.0, ...) # may vary\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Philox.jumped", "code": "\nPhilox.jumped(jumps=1)\u00b6", "description": "Returns a new bit generator with the state jumped\nThe state of the returned big generator is jumped as-if\n2**(128 * jumps) random numbers have been generated.\n\nParameters\n\njumpsinteger, positiveNumber of times to jump the state of the bit generator returned\n\n\n\nReturns\n\nbit_generatorPhiloxNew instance of generator jumped iter times\n\n\n\n\n", "parameters": ["Parameters", "jumpsinteger, positive", "Returns", "bit_generatorPhilox"], "returns": "bit_generatorPhiloxNew instance of generator jumped iter times", "examples": []},
{"library": "numpy", "item_id": "numpy.random.PCG64.jumped", "code": "\nPCG64.jumped(jumps=1)\u00b6", "description": "Returns a new bit generator with the state jumped.\nJumps the state as-if jumps * 210306068529402873165736369884012333109\nrandom numbers have been generated.\n\nParameters\n\njumpsinteger, positiveNumber of times to jump the state of the bit generator returned\n\n\n\nReturns\n\nbit_generatorPCG64New instance of generator jumped iter times\n\n\n\n\nNotes\nThe step size is phi-1 when multiplied by 2**128 where phi is the\ngolden ratio.\n", "parameters": ["Parameters", "jumpsinteger, positive", "Returns", "bit_generatorPCG64"], "returns": "bit_generatorPCG64New instance of generator jumped iter times", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.join", "code": "\nchararray.join(self, seq)[source]\u00b6", "description": "Return a string which is the concatenation of the strings in the\nsequence seq.\n\nSee also\nchar.join\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.MT19937.jumped", "code": "\nMT19937.jumped(jumps=1)\u00b6", "description": "Returns a new bit generator with the state jumped\nThe state of the returned big generator is jumped as-if\n2**(128 * jumps) random numbers have been generated.\n\nParameters\n\njumpsinteger, positiveNumber of times to jump the state of the bit generator returned\n\n\n\nReturns\n\nbit_generatorMT19937New instance of generator jumped iter times\n\n\n\n\n", "parameters": ["Parameters", "jumpsinteger, positive", "Returns", "bit_generatorMT19937"], "returns": "bit_generatorMT19937New instance of generator jumped iter times", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.join", "code": "\nchararray.join(self, seq)\u00b6", "description": "Return a string which is the concatenation of the strings in the\nsequence seq.\n\nSee also\nchar.join\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.itviews", "code": "\nnditer.itviews\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.itersize", "code": "\nnditer.itersize\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.broadcast.iters", "code": "\nbroadcast.iters\u00b6", "description": "tuple of iterators along self\u2019s \u201ccomponents.\u201d\nReturns a tuple of numpy.flatiter objects, one for each \u201ccomponent\u201d\nof self.\n\nSee also\nnumpy.flatiter\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = np.array([[4], [5], [6]])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; row, col = b.iters\n&gt;&gt;&gt; next(row), next(col)\n(1, 4)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; row, col = b.iters\n; next(row), next(col)\n(1, 4)\n\n", "; x = np.array([1, 2, 3])\n; y = np.array([[4], [5], [6]])\n; b = np.broadcast(x, y)\n; row, col = b.iters\n; next(row), next(col)\n(1, 4)\n"]},
{"library": "numpy", "item_id": "numpy.char.join", "code": "\nnumpy.char.join(sep, seq)\u00b6", "description": "Return a string which is the concatenation of the strings in the\nsequence seq.\nCalls str.join element-wise.\n\nParameters\n\nseparray_like of str or unicode\nseqarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input types\n\n\n\n\n\nSee also\nstr.join\n\n", "parameters": ["Parameters", "separray_like of str or unicode", "seqarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input types", "examples": []},
{"library": "numpy", "item_id": "numpy.ix_", "code": "\nnumpy.ix_(*args)[source]\u00b6", "description": "Construct an open mesh from multiple sequences.\nThis function takes N 1-D sequences and returns N outputs with N\ndimensions each, such that the shape is 1 in all but one dimension\nand the dimension with the non-unit shape value cycles through all\nN dimensions.\nUsing ix_ one can quickly construct index arrays that will index\nthe cross product. a[np.ix_([1,3],[2,5])] returns the array\n[[a[1,2] a[1,5]], [a[3,2] a[3,5]]].\n\nParameters\n\nargs1-D sequencesEach sequence should be of integer or boolean type.\nBoolean sequences will be interpreted as boolean masks for the\ncorresponding dimension (equivalent to passing in\nnp.nonzero(boolean_sequence)).\n\n\n\nReturns\n\nouttuple of ndarraysN arrays with N dimensions each, with N the number of input\nsequences. Together these arrays form an open mesh.\n\n\n\n\n\nSee also\nogrid, mgrid, meshgrid\n\nExamples\n&gt;&gt;&gt; a = np.arange(10).reshape(2, 5)\n&gt;&gt;&gt; a\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n&gt;&gt;&gt; ixgrid = np.ix_([0, 1], [2, 4])\n&gt;&gt;&gt; ixgrid\n(array([[0],\n       [1]]), array([[2, 4]]))\n&gt;&gt;&gt; ixgrid[0].shape, ixgrid[1].shape\n((2, 1), (1, 2))\n&gt;&gt;&gt; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n\n\n&gt;&gt;&gt; ixgrid = np.ix_([True, True], [2, 4])\n&gt;&gt;&gt; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n&gt;&gt;&gt; ixgrid = np.ix_([True, True], [False, False, True, False, True])\n&gt;&gt;&gt; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n\n\n", "parameters": ["Parameters", "args1-D sequences", "Returns", "outtuple of ndarrays"], "returns": "outtuple of ndarraysN arrays with N dimensions each, with N the number of inputsequences. Together these arrays form an open mesh.", "examples": ["; a = np.arange(10).reshape(2, 5)\n; a\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n; ixgrid = np.ix_([0, 1], [2, 4])\n; ixgrid\n(array([[0],\n       [1]]), array([[2, 4]]))\n; ixgrid[0].shape, ixgrid[1].shape\n((2, 1), (1, 2))\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n\n", "; a = np.arange(10).reshape(2, 5)\n; a\narray([[0, 1, 2, 3, 4],\n       [5, 6, 7, 8, 9]])\n; ixgrid = np.ix_([0, 1], [2, 4])\n; ixgrid\n(array([[0],\n       [1]]), array([[2, 4]]))\n; ixgrid[0].shape, ixgrid[1].shape\n((2, 1), (1, 2))\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n", "; ixgrid = np.ix_([True, True], [2, 4])\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n; ixgrid = np.ix_([True, True], [False, False, True, False, True])\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n\n", "; ixgrid = np.ix_([True, True], [2, 4])\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n; ixgrid = np.ix_([True, True], [False, False, True, False, True])\n; a[ixgrid]\narray([[2, 4],\n       [7, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.nditer.iterrange", "code": "\nnditer.iterrange\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.iternext", "code": "\nnditer.iternext()\u00b6", "description": "Check whether iterations are left, and perform a single internal iteration\nwithout returning the result.  Used in the C-style pattern do-while\npattern.  For an example, see nditer.\n\nReturns\n\niternextboolWhether or not there are iterations left.\n\n\n\n\n", "parameters": [], "returns": "iternextboolWhether or not there are iterations left.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.iterindex", "code": "\nnditer.iterindex\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.itemsize", "code": "\nrecord.itemsize\u00b6", "description": "length of one element in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.iterationneedsapi", "code": "\nnditer.iterationneedsapi\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.itemsize", "code": "\nrecarray.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.itemsize", "code": "\nndarray.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.memmap.itemsize", "code": "\nmemmap.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.matrix.itemsize", "code": "\nmatrix.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.itemsize", "code": "\nMaskType.itemsize\u00b6", "description": "length of one element in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.itemsize", "code": "\nmasked_array.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.generic.itemsize", "code": "\ngeneric.itemsize\u00b6", "description": "length of one element in bytes\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.itemsize", "code": "\ndtype.itemsize\u00b6", "description": "The element size of this data-type object.\nFor 18 of the 21 types this number is fixed by the data-type.\nFor the flexible data-types, this number can be anything.\nExamples\n&gt;&gt;&gt; arr = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; arr.dtype\ndtype('int64')\n&gt;&gt;&gt; arr.itemsize\n8\n\n\n&gt;&gt;&gt; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n&gt;&gt;&gt; dt.itemsize\n80\n\n\n", "parameters": [], "returns": [], "examples": ["; arr = np.array([[1, 2], [3, 4]])\n; arr.dtype\ndtype('int64')\n; arr.itemsize\n8\n\n", "; arr = np.array([[1, 2], [3, 4]])\n; arr.dtype\ndtype('int64')\n; arr.itemsize\n8\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.itemsize\n80\n\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.itemsize\n80\n"]},
{"library": "numpy", "item_id": "numpy.chararray.itemsize", "code": "\nchararray.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.itemsize", "code": "\nchararray.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.record.itemset", "code": "\nrecord.itemset()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.itemset", "code": "\nrecarray.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.itemset", "code": "\nndarray.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.itemset", "code": "\nmatrix.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.itemsize", "code": "\nMaskedArray.itemsize\u00b6", "description": "Length of one array element in bytes.\nExamples\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.float64)\n&gt;&gt;&gt; x.itemsize\n8\n&gt;&gt;&gt; x = np.array([1,2,3], dtype=np.complex128)\n&gt;&gt;&gt; x.itemsize\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n\n", "; x = np.array([1,2,3], dtype=np.float64)\n; x.itemsize\n8\n; x = np.array([1,2,3], dtype=np.complex128)\n; x.itemsize\n16\n"]},
{"library": "numpy", "item_id": "numpy.memmap.itemset", "code": "\nmemmap.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.generic.itemset", "code": "\ngeneric.itemset()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.itemset", "code": "\nMaskType.itemset()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.itemset", "code": "\nchararray.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.itemset", "code": "\nmasked_array.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.itemset", "code": "\nchararray.itemset(*args)\u00b6", "description": "Insert scalar into an array (scalar is cast to array\u2019s dtype, if possible)\nThere must be at least 1 argument, and define the last argument\nas item.  Then, a.itemset(*args) is equivalent to but faster\nthan a[args] = item.  The item should be a scalar value and args\nmust select a single item in the array a.\n\nParameters\n\n*argsArgumentsIf one argument: a scalar, only used in case a is of size 1.\nIf two arguments: the last argument is the value to be set\nand must be a scalar, the first argument specifies a single array\nelement location. It is either an int or a tuple.\n\n\n\n\nNotes\nCompared to indexing syntax, itemset provides some speed increase\nfor placing a scalar into a particular location in an ndarray,\nif you must do this.  However, generally this is discouraged:\namong other problems, it complicates the appearance of the code.\nAlso, when using itemset (and item) inside a loop, be sure\nto assign the methods to a local variable to avoid the attribute\nlook-up at each loop iteration.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.itemset(4, 0)\n&gt;&gt;&gt; x.itemset((2, 2), 9)\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n\n", "parameters": ["Parameters", "*argsArguments"], "returns": [], "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.itemset(4, 0)\n; x.itemset((2, 2), 9)\n; x\narray([[2, 2, 6],\n       [1, 0, 6],\n       [1, 0, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.record.item", "code": "\nrecord.item()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.item", "code": "\nrecarray.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.item", "code": "\nndarray.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.item", "code": "\nMaskType.item()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.item", "code": "\nmemmap.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.generic.item", "code": "\ngeneric.item()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.item", "code": "\nmatrix.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.chararray.item", "code": "\nchararray.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.item", "code": "\nMaskedArray.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.item", "code": "\nmasked_array.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.item", "code": "\nchararray.item(*args)\u00b6", "description": "Copy an element of an array to a standard Python scalar and return it.\n\nParameters\n\n*argsArguments (variable number and type)\nnone: in this case, the method only works for arrays\nwith one element (a.size == 1), which element is\ncopied into a standard Python scalar object and returned.\nint_type: this argument is interpreted as a flat index into\nthe array, specifying which element to copy and return.\ntuple of int_types: functions as does a single int_type argument,\nexcept that the argument is interpreted as an nd-index into the\narray.\n\n\n\n\nReturns\n\nzStandard Python scalar objectA copy of the specified element of the array as a suitable\nPython scalar\n\n\n\n\nNotes\nWhen the data type of a is longdouble or clongdouble, item() returns\na scalar array object because there is no available Python scalar that\nwould not lose information. Void arrays return a buffer object for item(),\nunless fields are defined, in which case a tuple is returned.\nitem is very similar to a[args], except, instead of an array scalar,\na standard Python scalar is returned. This can be useful for speeding up\naccess to elements of the array and doing arithmetic on elements of the\narray using Python\u2019s optimized math.\nExamples\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; x = np.random.randint(9, size=(3, 3))\n&gt;&gt;&gt; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n&gt;&gt;&gt; x.item(3)\n1\n&gt;&gt;&gt; x.item(7)\n0\n&gt;&gt;&gt; x.item((0, 1))\n2\n&gt;&gt;&gt; x.item((2, 2))\n1\n\n\n", "parameters": ["Parameters", "*argsArguments (variable number and type)", "Returns", "zStandard Python scalar object"], "returns": "zStandard Python scalar objectA copy of the specified element of the array as a suitablePython scalar", "examples": ["; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n\n", "; np.random.seed(123)\n; x = np.random.randint(9, size=(3, 3))\n; x\narray([[2, 2, 6],\n       [1, 3, 6],\n       [1, 0, 1]])\n; x.item(3)\n1\n; x.item(7)\n0\n; x.item((0, 1))\n2\n; x.item((2, 2))\n1\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isupper", "code": "\nchararray.isupper(self)[source]\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.\n\nSee also\nchar.isupper\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.isupper", "code": "\nchararray.isupper(self)\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.\n\nSee also\nchar.isupper\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.isupper", "code": "\nnumpy.char.isupper(a)\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are uppercase and there is at least one character, false\notherwise.\nCall str.isupper element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.isupper\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.istitle", "code": "\nchararray.istitle(self)\u00b6", "description": "Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.\n\nSee also\nchar.istitle\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.istitle", "code": "\nnumpy.char.istitle(a)\u00b6", "description": "Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.\nCall str.istitle element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.istitle\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.istitle", "code": "\nchararray.istitle(self)[source]\u00b6", "description": "Returns true for each element if the element is a titlecased\nstring and there is at least one character, false otherwise.\n\nSee also\nchar.istitle\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.issubsctype", "code": "\nnumpy.issubsctype(arg1, arg2)[source]\u00b6", "description": "Determine if the first argument is a subclass of the second argument.\n\nParameters\n\narg1, arg2dtype or dtype specifierData-types.\n\n\n\nReturns\n\noutboolThe result.\n\n\n\n\n\nSee also\nissctype, issubdtype, obj2sctype\n\nExamples\n&gt;&gt;&gt; np.issubsctype('S8', str)\nFalse\n&gt;&gt;&gt; np.issubsctype(np.array([1]), int)\nTrue\n&gt;&gt;&gt; np.issubsctype(np.array([1]), float)\nFalse\n\n\n", "parameters": ["Parameters", "arg1, arg2dtype or dtype specifier", "Returns", "outbool"], "returns": "outboolThe result.", "examples": ["; np.issubsctype('S8', str)\nFalse\n; np.issubsctype(np.array([1]), int)\nTrue\n; np.issubsctype(np.array([1]), float)\nFalse\n\n", "; np.issubsctype('S8', str)\nFalse\n; np.issubsctype(np.array([1]), int)\nTrue\n; np.issubsctype(np.array([1]), float)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.issubdtype", "code": "\nnumpy.issubdtype(arg1, arg2)[source]\u00b6", "description": "Returns True if first argument is a typecode lower/equal in type hierarchy.\n\nParameters\n\narg1, arg2dtype_likedtype or string representing a typecode.\n\n\n\nReturns\n\noutbool\n\n\n\n\nSee also\nissubsctype, issubclass_\n\nnumpy.core.numerictypesOverview of numpy type hierarchy.\n\n\n\nExamples\n&gt;&gt;&gt; np.issubdtype('S1', np.string_)\nTrue\n&gt;&gt;&gt; np.issubdtype(np.float64, np.float32)\nFalse\n\n\n", "parameters": ["Parameters", "arg1, arg2dtype_like", "Returns", "outbool"], "returns": "outbool", "examples": ["; np.issubdtype('S1', np.string_)\nTrue\n; np.issubdtype(np.float64, np.float32)\nFalse\n\n", "; np.issubdtype('S1', np.string_)\nTrue\n; np.issubdtype(np.float64, np.float32)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.issubclass_", "code": "\nnumpy.issubclass_(arg1, arg2)[source]\u00b6", "description": "Determine if a class is a subclass of a second class.\nissubclass_ is equivalent to the Python built-in issubclass,\nexcept that it returns False instead of raising a TypeError if one\nof the arguments is not a class.\n\nParameters\n\narg1classInput class. True is returned if arg1 is a subclass of arg2.\n\narg2class or tuple of classes.Input class. If a tuple of classes, True is returned if arg1 is a\nsubclass of any of the tuple elements.\n\n\n\nReturns\n\noutboolWhether arg1 is a subclass of arg2 or not.\n\n\n\n\n\nSee also\nissubsctype, issubdtype, issctype\n\nExamples\n&gt;&gt;&gt; np.issubclass_(np.int32, int)\nFalse # True on Python 2.7\n&gt;&gt;&gt; np.issubclass_(np.int32, float)\nFalse\n\n\n", "parameters": ["Parameters", "arg1class", "arg2class or tuple of classes.", "Returns", "outbool"], "returns": "outboolWhether arg1 is a subclass of arg2 or not.", "examples": ["; np.issubclass_(np.int32, int)\nFalse # True on Python 2.7\n; np.issubclass_(np.int32, float)\nFalse\n\n", "; np.issubclass_(np.int32, int)\nFalse # True on Python 2.7\n; np.issubclass_(np.int32, float)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isspace", "code": "\nchararray.isspace(self)[source]\u00b6", "description": "Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.\n\nSee also\nchar.isspace\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.isspace", "code": "\nchararray.isspace(self)\u00b6", "description": "Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.\n\nSee also\nchar.isspace\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.isscalar", "code": "\nnumpy.isscalar(element)[source]\u00b6", "description": "Returns True if the type of element is a scalar type.\n\nParameters\n\nelementanyInput argument, can be of any type and shape.\n\n\n\nReturns\n\nvalboolTrue if element is a scalar type, False if it is not.\n\n\n\n\n\nSee also\n\nndimGet the number of dimensions of an array\n\n\n\nNotes\nIf you need a stricter way to identify a numerical scalar, use\nisinstance(x, numbers.Number), as that returns False for most\nnon-numerical elements such as strings.\nIn most cases np.ndim(x) == 0 should be used instead of this function,\nas that will also return true for 0d arrays. This is how numpy overloads\nfunctions in the style of the dx arguments to gradient and the bins\nargument to histogram. Some key differences:\n\n\n\n\n\n\n\nx\nisscalar(x)\nnp.ndim(x) == 0\n\n\n\nPEP 3141 numeric objects (including\nbuiltins)\nTrue\nTrue\n\nbuiltin string and buffer objects\nTrue\nTrue\n\nother builtin objects, like\npathlib.Path, Exception,\nthe result of re.compile\nFalse\nTrue\n\nthird-party objects like\nmatplotlib.figure.Figure\nFalse\nTrue\n\nzero-dimensional numpy arrays\nFalse\nTrue\n\nother numpy arrays\nFalse\nFalse\n\nlist, tuple, and other sequence\nobjects\nFalse\nFalse\n\n\n\nExamples\n&gt;&gt;&gt; np.isscalar(3.1)\nTrue\n&gt;&gt;&gt; np.isscalar(np.array(3.1))\nFalse\n&gt;&gt;&gt; np.isscalar([3.1])\nFalse\n&gt;&gt;&gt; np.isscalar(False)\nTrue\n&gt;&gt;&gt; np.isscalar('numpy')\nTrue\n\n\nNumPy supports PEP 3141 numbers:\n&gt;&gt;&gt; from fractions import Fraction\n&gt;&gt;&gt; np.isscalar(Fraction(5, 17))\nTrue\n&gt;&gt;&gt; from numbers import Number\n&gt;&gt;&gt; np.isscalar(Number())\nTrue\n\n\n", "parameters": ["Parameters", "elementany", "Returns", "valbool"], "returns": "valboolTrue if element is a scalar type, False if it is not.", "examples": ["; np.isscalar(3.1)\nTrue\n; np.isscalar(np.array(3.1))\nFalse\n; np.isscalar([3.1])\nFalse\n; np.isscalar(False)\nTrue\n; np.isscalar('numpy')\nTrue\n\n", "; np.isscalar(3.1)\nTrue\n; np.isscalar(np.array(3.1))\nFalse\n; np.isscalar([3.1])\nFalse\n; np.isscalar(False)\nTrue\n; np.isscalar('numpy')\nTrue\n", "; from fractions import Fraction\n; np.isscalar(Fraction(5, 17))\nTrue\n; from numbers import Number\n; np.isscalar(Number())\nTrue\n\n", "; from fractions import Fraction\n; np.isscalar(Fraction(5, 17))\nTrue\n; from numbers import Number\n; np.isscalar(Number())\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.char.isspace", "code": "\nnumpy.char.isspace(a)\u00b6", "description": "Returns true for each element if there are only whitespace\ncharacters in the string and there is at least one character,\nfalse otherwise.\nCalls str.isspace element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.isspace\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.issctype", "code": "\nnumpy.issctype(rep)[source]\u00b6", "description": "Determines whether the given object represents a scalar data-type.\n\nParameters\n\nrepanyIf rep is an instance of a scalar dtype, True is returned. If not,\nFalse is returned.\n\n\n\nReturns\n\noutboolBoolean result of check whether rep is a scalar dtype.\n\n\n\n\n\nSee also\nissubsctype, issubdtype, obj2sctype, sctype2char\n\nExamples\n&gt;&gt;&gt; np.issctype(np.int32)\nTrue\n&gt;&gt;&gt; np.issctype(list)\nFalse\n&gt;&gt;&gt; np.issctype(1.1)\nFalse\n\n\nStrings are also a scalar type:\n&gt;&gt;&gt; np.issctype(np.dtype('str'))\nTrue\n\n\n", "parameters": ["Parameters", "repany", "Returns", "outbool"], "returns": "outboolBoolean result of check whether rep is a scalar dtype.", "examples": ["; np.issctype(np.int32)\nTrue\n; np.issctype(list)\nFalse\n; np.issctype(1.1)\nFalse\n\n", "; np.issctype(np.int32)\nTrue\n; np.issctype(list)\nFalse\n; np.issctype(1.1)\nFalse\n", "; np.issctype(np.dtype('str'))\nTrue\n\n", "; np.issctype(np.dtype('str'))\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.isreal", "code": "\nnumpy.isreal(x)[source]\u00b6", "description": "Returns a bool array, where True if input element is real.\nIf element has complex type with zero complex part, the return value\nfor that element is True.\n\nParameters\n\nxarray_likeInput array.\n\n\n\nReturns\n\noutndarray, boolBoolean array of same shape as x.\n\n\n\n\n\nSee also\niscomplex\n\nisrealobjReturn True if x is not a complex type.\n\n\n\nExamples\n&gt;&gt;&gt; np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False])\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "outndarray, bool"], "returns": "outndarray, boolBoolean array of same shape as x.", "examples": ["; np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False])\n\n", "; np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([False,  True,  True,  True,  True, False])\n"]},
{"library": "numpy", "item_id": "numpy.isrealobj", "code": "\nnumpy.isrealobj(x)[source]\u00b6", "description": "Return True if x is a not complex type or an array of complex numbers.\nThe type of the input is checked, not the value. So even if the input\nhas an imaginary part equal to zero, isrealobj evaluates to False\nif the data type is complex.\n\nParameters\n\nxanyThe input can be of any type and shape.\n\n\n\nReturns\n\nyboolThe return value, False if x is of a complex type.\n\n\n\n\n\nSee also\niscomplexobj, isreal\n\nExamples\n&gt;&gt;&gt; np.isrealobj(1)\nTrue\n&gt;&gt;&gt; np.isrealobj(1+0j)\nFalse\n&gt;&gt;&gt; np.isrealobj([3, 1+0j, True])\nFalse\n\n\n", "parameters": ["Parameters", "xany", "Returns", "ybool"], "returns": "yboolThe return value, False if x is of a complex type.", "examples": ["; np.isrealobj(1)\nTrue\n; np.isrealobj(1+0j)\nFalse\n; np.isrealobj([3, 1+0j, True])\nFalse\n\n", "; np.isrealobj(1)\nTrue\n; np.isrealobj(1+0j)\nFalse\n; np.isrealobj([3, 1+0j, True])\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.isposinf", "code": "\nnumpy.isposinf(x, out=None)[source]\u00b6", "description": "Test element-wise for positive infinity, return result as bool array.\n\nParameters\n\nxarray_likeThe input array.\n\nyarray_like, optionalA boolean array with the same shape as x to store the result.\n\n\n\nReturns\n\noutndarrayA boolean array with the same dimensions as the input.\nIf second argument is not supplied then a boolean array is returned\nwith values True where the corresponding element of the input is\npositive infinity and values False where the element of the input is\nnot positive infinity.\nIf a second argument is supplied the result is stored there. If the\ntype of that array is a numeric type the result is represented as zeros\nand ones, if the type is boolean then as False and True.\nThe return value out is then a reference to that array.\n\n\n\n\n\nSee also\nisinf, isneginf, isfinite, isnan\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\nErrors result if the second argument is also supplied when x is a scalar\ninput, if first and second arguments have different shapes, or if the\nfirst argument has complex values\nExamples\n&gt;&gt;&gt; np.isposinf(np.PINF)\nTrue\n&gt;&gt;&gt; np.isposinf(np.inf)\nTrue\n&gt;&gt;&gt; np.isposinf(np.NINF)\nFalse\n&gt;&gt;&gt; np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True])\n\n\n&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])\n&gt;&gt;&gt; y = np.array([2, 2, 2])\n&gt;&gt;&gt; np.isposinf(x, y)\narray([0, 0, 1])\n&gt;&gt;&gt; y\narray([0, 0, 1])\n\n\n", "parameters": ["Parameters", "xarray_like", "yarray_like, optional", "Returns", "outndarray"], "returns": "outndarrayA boolean array with the same dimensions as the input.If second argument is not supplied then a boolean array is returnedwith values True where the corresponding element of the input ispositive infinity and values False where the element of the input isnot positive infinity.If a second argument is supplied the result is stored there. If thetype of that array is a numeric type the result is represented as zerosand ones, if the type is boolean then as False and True.The return value out is then a reference to that array.", "examples": ["; np.isposinf(np.PINF)\nTrue\n; np.isposinf(np.inf)\nTrue\n; np.isposinf(np.NINF)\nFalse\n; np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True])\n\n", "; np.isposinf(np.PINF)\nTrue\n; np.isposinf(np.inf)\nTrue\n; np.isposinf(np.NINF)\nFalse\n; np.isposinf([-np.inf, 0., np.inf])\narray([False, False,  True])\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isposinf(x, y)\narray([0, 0, 1])\n; y\narray([0, 0, 1])\n\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isposinf(x, y)\narray([0, 0, 1])\n; y\narray([0, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.char.islower", "code": "\nnumpy.char.islower(a)\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.\nCalls str.islower element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.islower\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.isnan", "code": "\nnumpy.isnan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'isnan'&gt;\u00b6", "description": "Test element-wise for NaN and return result as a boolean array.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or boolTrue where x is NaN, false otherwise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nisinf, isneginf, isposinf, isfinite, isnat\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nExamples\n&gt;&gt;&gt; np.isnan(np.nan)\nTrue\n&gt;&gt;&gt; np.isnan(np.inf)\nFalse\n&gt;&gt;&gt; np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or bool"], "returns": "yndarray or boolTrue where x is NaN, false otherwise.This is a scalar if x is a scalar.", "examples": ["; np.isnan(np.nan)\nTrue\n; np.isnan(np.inf)\nFalse\n; np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])\n\n", "; np.isnan(np.nan)\nTrue\n; np.isnan(np.inf)\nFalse\n; np.isnan([np.log(-1.),1.,np.log(0)])\narray([ True, False, False])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.islower", "code": "\nchararray.islower(self)[source]\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.\n\nSee also\nchar.islower\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.islower", "code": "\nchararray.islower(self)\u00b6", "description": "Returns true for each element if all cased characters in the\nstring are lowercase and there is at least one cased character,\nfalse otherwise.\n\nSee also\nchar.islower\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.isinf", "code": "\nnumpy.isinf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'isinf'&gt;\u00b6", "description": "Test element-wise for positive or negative infinity.\nReturns a boolean array of the same shape as x, True where x ==\n+/-inf, otherwise False.\n\nParameters\n\nxarray_likeInput values\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nybool (scalar) or boolean ndarrayTrue where x is positive or negative infinity, false otherwise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nisneginf, isposinf, isnan, isfinite\n\nNotes\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754).\nErrors result if the second argument is supplied when the first\nargument is a scalar, or if the first and second arguments have\ndifferent shapes.\nExamples\n&gt;&gt;&gt; np.isinf(np.inf)\nTrue\n&gt;&gt;&gt; np.isinf(np.nan)\nFalse\n&gt;&gt;&gt; np.isinf(np.NINF)\nTrue\n&gt;&gt;&gt; np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n\n\n&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])\n&gt;&gt;&gt; y = np.array([2, 2, 2])\n&gt;&gt;&gt; np.isinf(x, y)\narray([1, 0, 1])\n&gt;&gt;&gt; y\narray([1, 0, 1])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "ybool (scalar) or boolean ndarray"], "returns": "ybool (scalar) or boolean ndarrayTrue where x is positive or negative infinity, false otherwise.This is a scalar if x is a scalar.", "examples": ["; np.isinf(np.inf)\nTrue\n; np.isinf(np.nan)\nFalse\n; np.isinf(np.NINF)\nTrue\n; np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n\n", "; np.isinf(np.inf)\nTrue\n; np.isinf(np.nan)\nFalse\n; np.isinf(np.NINF)\nTrue\n; np.isinf([np.inf, -np.inf, 1.0, np.nan])\narray([ True,  True, False, False])\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isinf(x, y)\narray([1, 0, 1])\n; y\narray([1, 0, 1])\n\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isinf(x, y)\narray([1, 0, 1])\n; y\narray([1, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.isfinite", "code": "\nnumpy.isfinite(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'isfinite'&gt;\u00b6", "description": "Test element-wise for finiteness (not infinity or not Not a Number).\nThe result is returned as a boolean array.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray, boolTrue where x is not positive infinity, negative infinity,\nor NaN; false otherwise.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nisinf, isneginf, isposinf, isnan\n\nNotes\nNot a Number, positive infinity and negative infinity are considered\nto be non-finite.\nNumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic\n(IEEE 754). This means that Not a Number is not equivalent to infinity.\nAlso that positive infinity is not equivalent to negative infinity. But\ninfinity is equivalent to positive infinity.  Errors result if the\nsecond argument is also supplied when x is a scalar input, or if\nfirst and second arguments have different shapes.\nExamples\n&gt;&gt;&gt; np.isfinite(1)\nTrue\n&gt;&gt;&gt; np.isfinite(0)\nTrue\n&gt;&gt;&gt; np.isfinite(np.nan)\nFalse\n&gt;&gt;&gt; np.isfinite(np.inf)\nFalse\n&gt;&gt;&gt; np.isfinite(np.NINF)\nFalse\n&gt;&gt;&gt; np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n\n\n&gt;&gt;&gt; x = np.array([-np.inf, 0., np.inf])\n&gt;&gt;&gt; y = np.array([2, 2, 2])\n&gt;&gt;&gt; np.isfinite(x, y)\narray([0, 1, 0])\n&gt;&gt;&gt; y\narray([0, 1, 0])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray, bool"], "returns": "yndarray, boolTrue where x is not positive infinity, negative infinity,or NaN; false otherwise.This is a scalar if x is a scalar.", "examples": ["; np.isfinite(1)\nTrue\n; np.isfinite(0)\nTrue\n; np.isfinite(np.nan)\nFalse\n; np.isfinite(np.inf)\nFalse\n; np.isfinite(np.NINF)\nFalse\n; np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n\n", "; np.isfinite(1)\nTrue\n; np.isfinite(0)\nTrue\n; np.isfinite(np.nan)\nFalse\n; np.isfinite(np.inf)\nFalse\n; np.isfinite(np.NINF)\nFalse\n; np.isfinite([np.log(-1.),1.,np.log(0)])\narray([False,  True, False])\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isfinite(x, y)\narray([0, 1, 0])\n; y\narray([0, 1, 0])\n\n", "; x = np.array([-np.inf, 0., np.inf])\n; y = np.array([2, 2, 2])\n; np.isfinite(x, y)\narray([0, 1, 0])\n; y\narray([0, 1, 0])\n"]},
{"library": "numpy", "item_id": "numpy.isin", "code": "\nnumpy.isin(element, test_elements, assume_unique=False, invert=False)[source]\u00b6", "description": "Calculates element in test_elements, broadcasting over element only.\nReturns a boolean array of the same shape as element that is True\nwhere an element of element is in test_elements and False otherwise.\n\nParameters\n\nelementarray_likeInput array.\n\ntest_elementsarray_likeThe values against which to test each value of element.\nThis argument is flattened if it is an array or array_like.\nSee notes for behavior with non-array-like parameters.\n\nassume_uniquebool, optionalIf True, the input arrays are both assumed to be unique, which\ncan speed up the calculation.  Default is False.\n\ninvertbool, optionalIf True, the values in the returned array are inverted, as if\ncalculating element not in test_elements. Default is False.\nnp.isin(a, b, invert=True) is equivalent to (but faster\nthan) np.invert(np.isin(a, b)).\n\n\n\nReturns\n\nisinndarray, boolHas the same shape as element. The values element[isin]\nare in test_elements.\n\n\n\n\n\nSee also\n\nin1dFlattened version of this function.\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nNotes\nisin is an element-wise function version of the python keyword in.\nisin(a, b) is roughly equivalent to\nnp.array([item in b for item in a]) if a and b are 1-D sequences.\nelement and test_elements are converted to arrays if they are not\nalready. If test_elements is a set (or other non-sequence collection)\nit will be converted to an object array with one element, rather than an\narray of the values contained in test_elements. This is a consequence\nof the array constructor\u2019s way of handling non-sequence collections.\nConverting the set to a list usually gives the desired behavior.\n\nNew in version 1.13.0.\n\nExamples\n&gt;&gt;&gt; element = 2*np.arange(4).reshape((2, 2))\n&gt;&gt;&gt; element\narray([[0, 2],\n       [4, 6]])\n&gt;&gt;&gt; test_elements = [1, 2, 4, 8]\n&gt;&gt;&gt; mask = np.isin(element, test_elements)\n&gt;&gt;&gt; mask\narray([[False,  True],\n       [ True, False]])\n&gt;&gt;&gt; element[mask]\narray([2, 4])\n\n\nThe indices of the matched values can be obtained with nonzero:\n&gt;&gt;&gt; np.nonzero(mask)\n(array([0, 1]), array([1, 0]))\n\n\nThe test can also be inverted:\n&gt;&gt;&gt; mask = np.isin(element, test_elements, invert=True)\n&gt;&gt;&gt; mask\narray([[ True, False],\n       [False,  True]])\n&gt;&gt;&gt; element[mask]\narray([0, 6])\n\n\nBecause of how array handles sets, the following does not\nwork as expected:\n&gt;&gt;&gt; test_set = {1, 2, 4, 8}\n&gt;&gt;&gt; np.isin(element, test_set)\narray([[False, False],\n       [False, False]])\n\n\nCasting the set to a list gives the expected result:\n&gt;&gt;&gt; np.isin(element, list(test_set))\narray([[False,  True],\n       [ True, False]])\n\n\n", "parameters": ["Parameters", "elementarray_like", "test_elementsarray_like", "assume_uniquebool, optional", "invertbool, optional", "Returns", "isinndarray, bool"], "returns": "isinndarray, boolHas the same shape as element. The values element[isin]are in test_elements.", "examples": ["; element = 2*np.arange(4).reshape((2, 2))\n; element\narray([[0, 2],\n       [4, 6]])\n; test_elements = [1, 2, 4, 8]\n; mask = np.isin(element, test_elements)\n; mask\narray([[False,  True],\n       [ True, False]])\n; element[mask]\narray([2, 4])\n\n", "; element = 2*np.arange(4).reshape((2, 2))\n; element\narray([[0, 2],\n       [4, 6]])\n; test_elements = [1, 2, 4, 8]\n; mask = np.isin(element, test_elements)\n; mask\narray([[False,  True],\n       [ True, False]])\n; element[mask]\narray([2, 4])\n", "; np.nonzero(mask)\n(array([0, 1]), array([1, 0]))\n\n", "; np.nonzero(mask)\n(array([0, 1]), array([1, 0]))\n", "; mask = np.isin(element, test_elements, invert=True)\n; mask\narray([[ True, False],\n       [False,  True]])\n; element[mask]\narray([0, 6])\n\n", "; mask = np.isin(element, test_elements, invert=True)\n; mask\narray([[ True, False],\n       [False,  True]])\n; element[mask]\narray([0, 6])\n", "; test_set = {1, 2, 4, 8}\n; np.isin(element, test_set)\narray([[False, False],\n       [False, False]])\n\n", "; test_set = {1, 2, 4, 8}\n; np.isin(element, test_set)\narray([[False, False],\n       [False, False]])\n", "; np.isin(element, list(test_set))\narray([[False,  True],\n       [ True, False]])\n\n", "; np.isin(element, list(test_set))\narray([[False,  True],\n       [ True, False]])\n"]},
{"library": "numpy", "item_id": "numpy.isfortran", "code": "\nnumpy.isfortran(a)[source]\u00b6", "description": "Check if the array is Fortran contiguous but not C contiguous.\nThis function is obsolete and, because of changes due to relaxed stride\nchecking, its return value for the same array may differ for versions\nof NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an\narray is Fortran contiguous use a.flags.f_contiguous instead.\n\nParameters\n\nandarrayInput array.\n\n\n\nReturns\n\nisfortranboolReturns True if the array is Fortran contiguous but not C contiguous.\n\n\n\n\nExamples\nnp.array allows to specify whether the array is written in C-contiguous\norder (last index varies the fastest), or FORTRAN-contiguous order in\nmemory (first index varies the fastest).\n&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n&gt;&gt;&gt; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; np.isfortran(a)\nFalse\n\n\n&gt;&gt;&gt; b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n&gt;&gt;&gt; b\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; np.isfortran(b)\nTrue\n\n\nThe transpose of a C-ordered array is a FORTRAN-ordered array.\n&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n&gt;&gt;&gt; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; np.isfortran(a)\nFalse\n&gt;&gt;&gt; b = a.T\n&gt;&gt;&gt; b\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; np.isfortran(b)\nTrue\n\n\nC-ordered arrays evaluate as False even if they are also FORTRAN-ordered.\n&gt;&gt;&gt; np.isfortran(np.array([1, 2], order='F'))\nFalse\n\n\n", "parameters": ["Parameters", "andarray", "Returns", "isfortranbool"], "returns": "isfortranboolReturns True if the array is Fortran contiguous but not C contiguous.", "examples": ["; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(a)\nFalse\n\n", "; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(a)\nFalse\n", "; b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n; b\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(b)\nTrue\n\n", "; b = np.array([[1, 2, 3], [4, 5, 6]], order='F')\n; b\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(b)\nTrue\n", "; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(a)\nFalse\n; b = a.T\n; b\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; np.isfortran(b)\nTrue\n\n", "; a = np.array([[1, 2, 3], [4, 5, 6]], order='C')\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.isfortran(a)\nFalse\n; b = a.T\n; b\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; np.isfortran(b)\nTrue\n", "; np.isfortran(np.array([1, 2], order='F'))\nFalse\n\n", "; np.isfortran(np.array([1, 2], order='F'))\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isdigit", "code": "\nchararray.isdigit(self)[source]\u00b6", "description": "Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.\n\nSee also\nchar.isdigit\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.isdigit", "code": "\nchararray.isdigit(self)\u00b6", "description": "Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.\n\nSee also\nchar.isdigit\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.isdecimal", "code": "\nchararray.isdecimal(self)[source]\u00b6", "description": "For each element in self, return True if there are only\ndecimal characters in the element.\n\nSee also\nchar.isdecimal\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.isdecimal", "code": "\nchararray.isdecimal(self)\u00b6", "description": "For each element in self, return True if there are only\ndecimal characters in the element.\n\nSee also\nchar.isdecimal\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.isdigit", "code": "\nnumpy.char.isdigit(a)\u00b6", "description": "Returns true for each element if all characters in the string are\ndigits and there is at least one character, false otherwise.\nCalls str.isdigit element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.isdigit\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.char.isdecimal", "code": "\nnumpy.char.isdecimal(a)\u00b6", "description": "For each element, return True if there are only decimal\ncharacters in the element.\nCalls unicode.isdecimal element-wise.\nDecimal characters include digit characters, and all characters\nthat that can be used to form decimal-radix numbers,\ne.g. U+0660, ARABIC-INDIC DIGIT ZERO.\n\nParameters\n\naarray_like, unicodeInput array.\n\n\n\nReturns\n\noutndarray, boolArray of booleans identical in shape to a.\n\n\n\n\n\nSee also\nunicode.isdecimal\n\n", "parameters": ["Parameters", "aarray_like, unicode", "Returns", "outndarray, bool"], "returns": "outndarray, boolArray of booleans identical in shape to a.", "examples": []},
{"library": "numpy", "item_id": "numpy.iscomplexobj", "code": "\nnumpy.iscomplexobj(x)[source]\u00b6", "description": "Check for a complex type or an array of complex numbers.\nThe type of the input is checked, not the value. Even if the input\nhas an imaginary part equal to zero, iscomplexobj evaluates to True.\n\nParameters\n\nxanyThe input can be of any type and shape.\n\n\n\nReturns\n\niscomplexobjboolThe return value, True if x is of a complex type or has at least\none complex element.\n\n\n\n\n\nSee also\nisrealobj, iscomplex\n\nExamples\n&gt;&gt;&gt; np.iscomplexobj(1)\nFalse\n&gt;&gt;&gt; np.iscomplexobj(1+0j)\nTrue\n&gt;&gt;&gt; np.iscomplexobj([3, 1+0j, True])\nTrue\n\n\n", "parameters": ["Parameters", "xany", "Returns", "iscomplexobjbool"], "returns": "iscomplexobjboolThe return value, True if x is of a complex type or has at leastone complex element.", "examples": ["; np.iscomplexobj(1)\nFalse\n; np.iscomplexobj(1+0j)\nTrue\n; np.iscomplexobj([3, 1+0j, True])\nTrue\n\n", "; np.iscomplexobj(1)\nFalse\n; np.iscomplexobj(1+0j)\nTrue\n; np.iscomplexobj([3, 1+0j, True])\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.iscomplex", "code": "\nnumpy.iscomplex(x)[source]\u00b6", "description": "Returns a bool array, where True if input element is complex.\nWhat is tested is whether the input has a non-zero imaginary part, not if\nthe input type is complex.\n\nParameters\n\nxarray_likeInput array.\n\n\n\nReturns\n\noutndarray of boolsOutput array.\n\n\n\n\n\nSee also\nisreal\n\niscomplexobjReturn True if x is a complex type or an array of complex numbers.\n\n\n\nExamples\n&gt;&gt;&gt; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True])\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "outndarray of bools"], "returns": "outndarray of boolsOutput array.", "examples": ["; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True])\n\n", "; np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j])\narray([ True, False, False, False, False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.dtype.isbuiltin", "code": "\ndtype.isbuiltin\u00b6", "description": "Integer indicating how this dtype relates to the built-in dtypes.\nRead-only.\n\n\n\n\n\n\n0\nif this is a structured array type, with fields\n\n1\nif this is a dtype compiled into numpy (such as ints, floats etc)\n\n2\nif the dtype is for a user-defined numpy type\nA user-defined type uses the numpy C-API machinery to extend\nnumpy to handle a new array type. See\nUser-defined data-types in the NumPy manual.\n\n\n\nExamples\n&gt;&gt;&gt; dt = np.dtype('i2')\n&gt;&gt;&gt; dt.isbuiltin\n1\n&gt;&gt;&gt; dt = np.dtype('f8')\n&gt;&gt;&gt; dt.isbuiltin\n1\n&gt;&gt;&gt; dt = np.dtype([('field1', 'f8')])\n&gt;&gt;&gt; dt.isbuiltin\n0\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype('i2')\n; dt.isbuiltin\n1\n; dt = np.dtype('f8')\n; dt.isbuiltin\n1\n; dt = np.dtype([('field1', 'f8')])\n; dt.isbuiltin\n0\n\n", "; dt = np.dtype('i2')\n; dt.isbuiltin\n1\n; dt = np.dtype('f8')\n; dt.isbuiltin\n1\n; dt = np.dtype([('field1', 'f8')])\n; dt.isbuiltin\n0\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isalpha", "code": "\nchararray.isalpha(self)[source]\u00b6", "description": "Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.\n\nSee also\nchar.isalpha\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.isclose", "code": "\nnumpy.isclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)[source]\u00b6", "description": "Returns a boolean array where two arrays are element-wise equal within a\ntolerance.\nThe tolerance values are positive, typically very small numbers.  The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\n\nWarning\nThe default atol is not appropriate for comparing numbers\nthat are much smaller than one (see Notes).\n\n\nParameters\n\na, barray_likeInput arrays to compare.\n\nrtolfloatThe relative tolerance parameter (see Notes).\n\natolfloatThe absolute tolerance parameter (see Notes).\n\nequal_nanboolWhether to compare NaN\u2019s as equal.  If True, NaN\u2019s in a will be\nconsidered equal to NaN\u2019s in b in the output array.\n\n\n\nReturns\n\nyarray_likeReturns a boolean array of where a and b are equal within the\ngiven tolerance. If both a and b are scalars, returns a single\nboolean value.\n\n\n\n\n\nSee also\nallclose\n\nNotes\n\nNew in version 1.7.0.\n\nFor finite values, isclose uses the following equation to test whether\ntwo floating point values are equivalent.\n\nabsolute(a - b) &lt;= (atol + rtol * absolute(b))\n\nUnlike the built-in math.isclose, the above equation is not symmetric\nin a and b \u2013 it assumes b is the reference value \u2013 so that\nisclose(a, b) might be different from isclose(b, a). Furthermore,\nthe default value of atol is not zero, and is used to determine what\nsmall values should be considered close to zero. The default value is\nappropriate for expected values of order unity: if the expected values\nare significantly smaller than one, it can result in false positives.\natol should be carefully selected for the use case at hand. A zero value\nfor atol will result in False if either a or b is zero.\nExamples\n&gt;&gt;&gt; np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([ True, False])\n&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([ True, True])\n&gt;&gt;&gt; np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False,  True])\n&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan])\narray([ True, False])\n&gt;&gt;&gt; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([ True, True])\n&gt;&gt;&gt; np.isclose([1e-8, 1e-7], [0.0, 0.0])\narray([ True, False])\n&gt;&gt;&gt; np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\narray([False, False])\n&gt;&gt;&gt; np.isclose([1e-10, 1e-10], [1e-20, 0.0])\narray([ True,  True])\n&gt;&gt;&gt; np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\narray([False,  True])\n\n\n", "parameters": ["Parameters", "a, barray_like", "rtolfloat", "atolfloat", "equal_nanbool", "Returns", "yarray_like"], "returns": "yarray_likeReturns a boolean array of where a and b are equal within thegiven tolerance. If both a and b are scalars, returns a singleboolean value.", "examples": ["; np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([ True, False])\n; np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([ True, True])\n; np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False,  True])\n; np.isclose([1.0, np.nan], [1.0, np.nan])\narray([ True, False])\n; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([ True, True])\n; np.isclose([1e-8, 1e-7], [0.0, 0.0])\narray([ True, False])\n; np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\narray([False, False])\n; np.isclose([1e-10, 1e-10], [1e-20, 0.0])\narray([ True,  True])\n; np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\narray([False,  True])\n\n", "; np.isclose([1e10,1e-7], [1.00001e10,1e-8])\narray([ True, False])\n; np.isclose([1e10,1e-8], [1.00001e10,1e-9])\narray([ True, True])\n; np.isclose([1e10,1e-8], [1.0001e10,1e-9])\narray([False,  True])\n; np.isclose([1.0, np.nan], [1.0, np.nan])\narray([ True, False])\n; np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\narray([ True, True])\n; np.isclose([1e-8, 1e-7], [0.0, 0.0])\narray([ True, False])\n; np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)\narray([False, False])\n; np.isclose([1e-10, 1e-10], [1e-20, 0.0])\narray([ True,  True])\n; np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)\narray([False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.isalpha", "code": "\nchararray.isalpha(self)\u00b6", "description": "Returns true for each element if all characters in the string\nare alphabetic and there is at least one character, false\notherwise.\n\nSee also\nchar.isalpha\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.isalignedstruct", "code": "\ndtype.isalignedstruct\u00b6", "description": "Boolean indicating whether the dtype is a struct which maintains\nfield alignment. This flag is sticky, so when combining multiple\nstructs together, it is preserved and produces new dtypes which\nare also aligned.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.isalpha", "code": "\nnumpy.char.isalpha(a)\u00b6", "description": "Returns true for each element if all characters in the string are\nalphabetic and there is at least one character, false otherwise.\nCalls str.isalpha element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of bools\n\n\n\n\n\nSee also\nstr.isalpha\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of bools", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.is_masked", "code": "\nnumpy.ma.is_masked(x)[source]\u00b6", "description": "Determine whether input has masked values.\nAccepts any object as input, but always returns False unless the\ninput is a MaskedArray containing masked values.\n\nParameters\n\nxarray_likeArray to check for masked values.\n\n\n\nReturns\n\nresultboolTrue if x is a MaskedArray with masked values, False otherwise.\n\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n&gt;&gt;&gt; x\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n&gt;&gt;&gt; ma.is_masked(x)\nTrue\n&gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n&gt;&gt;&gt; x\nmasked_array(data=[0, 1, 0, 2, 3],\n             mask=False,\n       fill_value=42)\n&gt;&gt;&gt; ma.is_masked(x)\nFalse\n\n\nAlways returns False if x isn\u2019t a MaskedArray.\n&gt;&gt;&gt; x = [False, True, False]\n&gt;&gt;&gt; ma.is_masked(x)\nFalse\n&gt;&gt;&gt; x = 'a string'\n&gt;&gt;&gt; ma.is_masked(x)\nFalse\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "resultbool"], "returns": "resultboolTrue if x is a MaskedArray with masked values, False otherwise.", "examples": ["; import numpy.ma as ma\n; x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n; x\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n; ma.is_masked(x)\nTrue\n; x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n; x\nmasked_array(data=[0, 1, 0, 2, 3],\n             mask=False,\n       fill_value=42)\n; ma.is_masked(x)\nFalse\n\n", "; import numpy.ma as ma\n; x = ma.masked_equal([0, 1, 0, 2, 3], 0)\n; x\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n; ma.is_masked(x)\nTrue\n; x = ma.masked_equal([0, 1, 0, 2, 3], 42)\n; x\nmasked_array(data=[0, 1, 0, 2, 3],\n             mask=False,\n       fill_value=42)\n; ma.is_masked(x)\nFalse\n", "; x = [False, True, False]\n; ma.is_masked(x)\nFalse\n; x = 'a string'\n; ma.is_masked(x)\nFalse\n\n", "; x = [False, True, False]\n; ma.is_masked(x)\nFalse\n; x = 'a string'\n; ma.is_masked(x)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.ma.is_mask", "code": "\nnumpy.ma.is_mask(m)[source]\u00b6", "description": "Return True if m is a valid, standard mask.\nThis function does not check the contents of the input, only that the\ntype is MaskType. In particular, this function returns False if the\nmask has a flexible dtype.\n\nParameters\n\nmarray_likeArray to test.\n\n\n\nReturns\n\nresultboolTrue if m.dtype.type is MaskType, False otherwise.\n\n\n\n\n\nSee also\n\nisMaskedArrayTest whether input is an instance of MaskedArray.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n&gt;&gt;&gt; m\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n&gt;&gt;&gt; ma.is_mask(m)\nFalse\n&gt;&gt;&gt; ma.is_mask(m.mask)\nTrue\n\n\nInput must be an ndarray (or have similar attributes)\nfor it to be considered a valid mask.\n&gt;&gt;&gt; m = [False, True, False]\n&gt;&gt;&gt; ma.is_mask(m)\nFalse\n&gt;&gt;&gt; m = np.array([False, True, False])\n&gt;&gt;&gt; m\narray([False,  True, False])\n&gt;&gt;&gt; ma.is_mask(m)\nTrue\n\n\nArrays with complex dtypes don\u2019t return True.\n&gt;&gt;&gt; dtype = np.dtype({'names':['monty', 'pithon'],\n...                   'formats':[bool, bool]})\n&gt;&gt;&gt; dtype\ndtype([('monty', '|b1'), ('pithon', '|b1')])\n&gt;&gt;&gt; m = np.array([(True, False), (False, True), (True, False)],\n...              dtype=dtype)\n&gt;&gt;&gt; m\narray([( True, False), (False,  True), ( True, False)],\n      dtype=[('monty', '?'), ('pithon', '?')])\n&gt;&gt;&gt; ma.is_mask(m)\nFalse\n\n\n", "parameters": ["Parameters", "marray_like", "Returns", "resultbool"], "returns": "resultboolTrue if m.dtype.type is MaskType, False otherwise.", "examples": ["; import numpy.ma as ma\n; m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n; m\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n; ma.is_mask(m)\nFalse\n; ma.is_mask(m.mask)\nTrue\n\n", "; import numpy.ma as ma\n; m = ma.masked_equal([0, 1, 0, 2, 3], 0)\n; m\nmasked_array(data=[--, 1, --, 2, 3],\n             mask=[ True, False,  True, False, False],\n       fill_value=0)\n; ma.is_mask(m)\nFalse\n; ma.is_mask(m.mask)\nTrue\n", "; m = [False, True, False]\n; ma.is_mask(m)\nFalse\n; m = np.array([False, True, False])\n; m\narray([False,  True, False])\n; ma.is_mask(m)\nTrue\n\n", "; m = [False, True, False]\n; ma.is_mask(m)\nFalse\n; m = np.array([False, True, False])\n; m\narray([False,  True, False])\n; ma.is_mask(m)\nTrue\n", "; dtype = np.dtype({'names':['monty', 'pithon'],\n...                   'formats':[bool, bool]})\n; dtype\ndtype([('monty', '|b1'), ('pithon', '|b1')])\n; m = np.array([(True, False), (False, True), (True, False)],\n...              dtype=dtype)\n; m\narray([( True, False), (False,  True), ( True, False)],\n      dtype=[('monty', '?'), ('pithon', '?')])\n; ma.is_mask(m)\nFalse\n\n", "; dtype = np.dtype({'names':['monty', 'pithon'],\n...                   'formats':[bool, bool]})\n; dtype\ndtype([('monty', '|b1'), ('pithon', '|b1')])\n; m = np.array([(True, False), (False, True), (True, False)],\n...              dtype=dtype)\n; m\narray([( True, False), (False,  True), ( True, False)],\n      dtype=[('monty', '?'), ('pithon', '?')])\n; ma.is_mask(m)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.chararray.isalnum", "code": "\nchararray.isalnum(self)[source]\u00b6", "description": "Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.\n\nSee also\nchar.isalnum\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.is_busday", "code": "\nnumpy.is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)\u00b6", "description": "Calculates which of the given dates are valid days, and which are not.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndatesarray_like of datetime64[D]The array of dates to process.\n\nweekmaskstr or array_like of bool, optionalA seven-element array indicating which of Monday through Sunday are\nvalid days. May be specified as a length-seven list or array, like\n[1,1,1,1,1,0,0]; a length-seven string, like \u20181111100\u2019; or a string\nlike \u201cMon Tue Wed Thu Fri\u201d, made up of 3-character abbreviations for\nweekdays, optionally separated by white space. Valid abbreviations\nare: Mon Tue Wed Thu Fri Sat Sun\n\nholidaysarray_like of datetime64[D], optionalAn array of dates to consider as invalid dates.  They may be\nspecified in any order, and NaT (not-a-time) dates are ignored.\nThis list is saved in a normalized form that is suited for\nfast calculations of valid days.\n\nbusdaycalbusdaycalendar, optionalA busdaycalendar object which specifies the valid days. If this\nparameter is provided, neither weekmask nor holidays may be\nprovided.\n\noutarray of bool, optionalIf provided, this array is filled with the result.\n\n\n\nReturns\n\noutarray of boolAn array with the same shape as dates, containing True for\neach valid day, and False for each invalid day.\n\n\n\n\n\nSee also\n\nbusdaycalendarAn object that specifies a custom set of valid days.\n\nbusday_offsetApplies an offset counted in valid days.\n\nbusday_countCounts how many valid days are in a half-open date range.\n\n\n\nExamples\n&gt;&gt;&gt; # The weekdays are Friday, Saturday, and Monday\n... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\narray([False, False,  True])\n\n\n", "parameters": ["Parameters", "datesarray_like of datetime64[D]", "weekmaskstr or array_like of bool, optional", "holidaysarray_like of datetime64[D], optional", "busdaycalbusdaycalendar, optional", "outarray of bool, optional", "Returns", "outarray of bool"], "returns": "outarray of boolAn array with the same shape as dates, containing True foreach valid day, and False for each invalid day.", "examples": ["; # The weekdays are Friday, Saturday, and Monday\n... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\narray([False, False,  True])\n\n", "; # The weekdays are Friday, Saturday, and Monday\n... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],\n...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\narray([False, False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.isalnum", "code": "\nchararray.isalnum(self)\u00b6", "description": "Returns true for each element if all characters in the string\nare alphanumeric and there is at least one character, false\notherwise.\n\nSee also\nchar.isalnum\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.isalnum", "code": "\nnumpy.char.isalnum(a)\u00b6", "description": "Returns true for each element if all characters in the string are\nalphanumeric and there is at least one character, false otherwise.\nCalls str.isalnum element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicode\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.isalnum\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.fft.irfft2", "code": "\nnumpy.fft.irfft2(a, s=None, axes=(-2, -1), norm=None)[source]\u00b6", "description": "Compute the 2-dimensional inverse FFT of a real array.\n\nParameters\n\naarray_likeThe input array\n\nssequence of ints, optionalShape of the real output to the inverse FFT.\n\naxessequence of ints, optionalThe axes over which to compute the inverse fft.\nDefault is the last two axes.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutndarrayThe result of the inverse real 2-D FFT.\n\n\n\n\n\nSee also\n\nirfftnCompute the inverse of the N-dimensional FFT of real input.\n\n\n\nNotes\nThis is really irfftn with different defaults.\nFor more details see irfftn.\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outndarray"], "returns": "outndarrayThe result of the inverse real 2-D FFT.", "examples": []},
{"library": "numpy", "item_id": "numpy.fft.irfftn", "code": "\nnumpy.fft.irfftn(a, s=None, axes=None, norm=None)[source]\u00b6", "description": "Compute the inverse of the N-dimensional FFT of real input.\nThis function computes the inverse of the N-dimensional discrete\nFourier Transform for real input over any number of axes in an\nM-dimensional array by means of the Fast Fourier Transform (FFT).  In\nother words, irfftn(rfftn(a), a.shape) == a to within numerical\naccuracy. (The a.shape is necessary like len(a) is for irfft,\nand for the same reason.)\nThe input should be ordered in the same way as is returned by rfftn,\ni.e. as for irfft for the final transformation axis, and as for ifftn\nalong all the other axes.\n\nParameters\n\naarray_likeInput array.\n\nssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0] refers to axis 0, s[1] to axis 1, etc.). s is also the\nnumber of input points used along this axis, except for the last axis,\nwhere s[-1]//2+1 points of the input are used.\nAlong any axis, if the shape indicated by s is smaller than that of\nthe input, the input is cropped.  If it is larger, the input is padded\nwith zeros. If s is not given, the shape of the input along the axes\nspecified by axes is used. Except for the last axis which is taken to be\n2*(m-1) where m is the length of the input along that axis.\n\naxessequence of ints, optionalAxes over which to compute the inverse FFT. If not given, the last\nlen(s) axes are used, or all axes if s is also not specified.\nRepeated indices in axes means that the inverse transform over that\naxis is performed multiple times.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or by a combination of s or a,\nas explained in the parameters section above.\nThe length of each transformed axis is as given by the corresponding\nelement of s, or the length of the input in every axis except for the\nlast one if s is not given.  In the final transformed axis the length\nof the output when s is not given is 2*(m-1) where m is the\nlength of the final transformed axis of the input.  To get an odd\nnumber of output points in the final axis, s must be specified.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nrfftnThe forward n-dimensional FFT of real input, of which ifftn is the inverse.\n\nfftThe one-dimensional FFT, with definitions and conventions used.\n\nirfftThe inverse of the one-dimensional FFT of real input.\n\nirfft2The inverse of the two-dimensional FFT of real input.\n\n\n\nNotes\nSee fft for definitions and conventions used.\nSee rfft for definitions and conventions used for real input.\nThe correct interpretation of the hermitian input depends on the shape of\nthe original data, as given by s. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, irfftn\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. When performing the\nfinal complex to real transform, the last value is thus treated as purely\nreal. To avoid losing information, the correct shape of the real input\nmust be given.\nExamples\n&gt;&gt;&gt; a = np.zeros((3, 2, 2))\n&gt;&gt;&gt; a[0, 0, 0] = 3 * 2 * 2\n&gt;&gt;&gt; np.fft.irfftn(a)\narray([[[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]]])\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outndarray", "Raises", "ValueError", "IndexError"], "returns": "outndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s or a,as explained in the parameters section above.The length of each transformed axis is as given by the correspondingelement of s, or the length of the input in every axis except for thelast one if s is not given.  In the final transformed axis the lengthof the output when s is not given is 2*(m-1) where m is thelength of the final transformed axis of the input.  To get an oddnumber of output points in the final axis, s must be specified.", "examples": ["; a = np.zeros((3, 2, 2))\n; a[0, 0, 0] = 3 * 2 * 2\n; np.fft.irfftn(a)\narray([[[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]]])\n\n", "; a = np.zeros((3, 2, 2))\n; a[0, 0, 0] = 3 * 2 * 2\n; np.fft.irfftn(a)\narray([[[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]],\n       [[1.,  1.],\n        [1.,  1.]]])\n"]},
{"library": "numpy", "item_id": "numpy.fft.irfft", "code": "\nnumpy.fft.irfft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the inverse of the n-point DFT for real input.\nThis function computes the inverse of the one-dimensional n-point\ndiscrete Fourier Transform of real input computed by rfft.\nIn other words, irfft(rfft(a), len(a)) == a to within numerical\naccuracy. (See Notes below for why len(a) is necessary here.)\nThe input is expected to be in the form returned by rfft, i.e. the\nreal zero-frequency term followed by the complex positive frequency terms\nin order of increasing frequency.  Since the discrete Fourier Transform of\nreal input is Hermitian-symmetric, the negative frequency terms are taken\nto be the complex conjugates of the corresponding positive frequency terms.\n\nParameters\n\naarray_likeThe input array.\n\nnint, optionalLength of the transformed axis of the output.\nFor n output points, n//2+1 input points are necessary.  If the\ninput is longer than this, it is cropped.  If it is shorter than this,\nit is padded with zeros.  If n is not given, it is taken to be\n2*(m-1) where m is the length of the input along the axis\nspecified by axis.\n\naxisint, optionalAxis over which to compute the inverse FFT. If not given, the last\naxis is used.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\nThe length of the transformed axis is n, or, if n is not given,\n2*(m-1) where m is the length of the transformed axis of the\ninput. To get an odd number of output points, n must be specified.\n\n\n\nRaises\n\nIndexErrorIf axis is larger than the last axis of a.\n\n\n\n\n\nSee also\n\nnumpy.fftFor definition of the DFT and conventions used.\n\nrfftThe one-dimensional FFT of real input, of which irfft is inverse.\n\nfftThe one-dimensional FFT.\n\nirfft2The inverse of the two-dimensional FFT of real input.\n\nirfftnThe inverse of the n-dimensional FFT of real input.\n\n\n\nNotes\nReturns the real valued n-point inverse discrete Fourier transform\nof a, where a contains the non-negative frequency terms of a\nHermitian-symmetric sequence. n is the length of the result, not the\ninput.\nIf you specify an n such that a must be zero-padded or truncated, the\nextra/removed values will be added/removed at high frequencies. One can\nthus resample a series to m points via Fourier interpolation by:\na_resamp = irfft(rfft(a), m).\nThe correct interpretation of the hermitian input depends on the length of\nthe original data, as given by n. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, irfft\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\ncorrect length of the real input must be given.\nExamples\n&gt;&gt;&gt; np.fft.ifft([1, -1j, -1, 1j])\narray([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary\n&gt;&gt;&gt; np.fft.irfft([1, -1j, -1])\narray([0.,  1.,  0.,  0.])\n\n\nNotice how the last term in the input to the ordinary ifft is the\ncomplex conjugate of the second term, and the output has zero imaginary\npart everywhere.  When calling irfft, the negative frequencies are not\nspecified, and the output array is purely real.\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outndarray", "Raises", "IndexError"], "returns": "outndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n, or, if n is not given,2*(m-1) where m is the length of the transformed axis of theinput. To get an odd number of output points, n must be specified.", "examples": ["; np.fft.ifft([1, -1j, -1, 1j])\narray([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary\n; np.fft.irfft([1, -1j, -1])\narray([0.,  1.,  0.,  0.])\n\n", "; np.fft.ifft([1, -1j, -1, 1j])\narray([0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]) # may vary\n; np.fft.irfft([1, -1j, -1])\narray([0.,  1.,  0.,  0.])\n"]},
{"library": "numpy", "item_id": "numpy.invert", "code": "\nnumpy.invert(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'invert'&gt;\u00b6", "description": "Compute bit-wise inversion, or bit-wise NOT, element-wise.\nComputes the bit-wise NOT of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ~.\nFor signed integer inputs, the two\u2019s complement is returned.  In a\ntwo\u2019s-complement system negative numbers are represented by the two\u2019s\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]. A N-bit\ntwo\u2019s-complement system can represent every integer in the range\n to .\n\nParameters\n\nxarray_likeOnly integer and boolean types are handled.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarResult.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nbitwise_and, bitwise_or, bitwise_xor, logical_not\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nNotes\nbitwise_not is an alias for invert:\n&gt;&gt;&gt; np.bitwise_not is np.invert\nTrue\n\n\nReferences\n\n1\nWikipedia, \u201cTwo\u2019s complement\u201d,\nhttps://en.wikipedia.org/wiki/Two\u2019s_complement\n\n\nExamples\nWe\u2019ve seen that 13 is represented by 00001101.\nThe invert or bit-wise NOT of 13 is then:\n&gt;&gt;&gt; x = np.invert(np.array(13, dtype=np.uint8))\n&gt;&gt;&gt; x\n242\n&gt;&gt;&gt; np.binary_repr(x, width=8)\n'11110010'\n\n\nThe result depends on the bit-width:\n&gt;&gt;&gt; x = np.invert(np.array(13, dtype=np.uint16))\n&gt;&gt;&gt; x\n65522\n&gt;&gt;&gt; np.binary_repr(x, width=16)\n'1111111111110010'\n\n\nWhen using signed integer types the result is the two\u2019s complement of\nthe result for the unsigned type:\n&gt;&gt;&gt; np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n&gt;&gt;&gt; np.binary_repr(-14, width=8)\n'11110010'\n\n\nBooleans are accepted as well:\n&gt;&gt;&gt; np.invert(np.array([True, False]))\narray([False,  True])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarResult.This is a scalar if x is a scalar.", "examples": ["; x = np.invert(np.array(13, dtype=np.uint8))\n; x\n242\n; np.binary_repr(x, width=8)\n'11110010'\n\n", "; x = np.invert(np.array(13, dtype=np.uint8))\n; x\n242\n; np.binary_repr(x, width=8)\n'11110010'\n", "; x = np.invert(np.array(13, dtype=np.uint16))\n; x\n65522\n; np.binary_repr(x, width=16)\n'1111111111110010'\n\n", "; x = np.invert(np.array(13, dtype=np.uint16))\n; x\n65522\n; np.binary_repr(x, width=16)\n'1111111111110010'\n", "; np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n; np.binary_repr(-14, width=8)\n'11110010'\n\n", "; np.invert(np.array([13], dtype=np.int8))\narray([-14], dtype=int8)\n; np.binary_repr(-14, width=8)\n'11110010'\n", "; np.invert(np.array([True, False]))\narray([False,  True])\n\n", "; np.invert(np.array([True, False]))\narray([False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.inv", "code": "\nnumpy.linalg.inv(a)[source]\u00b6", "description": "Compute the (multiplicative) inverse of a matrix.\nGiven a square matrix a, return the matrix ainv satisfying\ndot(a, ainv) = dot(ainv, a) = eye(a.shape[0]).\n\nParameters\n\na(\u2026, M, M) array_likeMatrix to be inverted.\n\n\n\nReturns\n\nainv(\u2026, M, M) ndarray or matrix(Multiplicative) inverse of the matrix a.\n\n\n\nRaises\n\nLinAlgErrorIf a is not square or inversion fails.\n\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nExamples\n&gt;&gt;&gt; from numpy.linalg import inv\n&gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])\n&gt;&gt;&gt; ainv = inv(a)\n&gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))\nTrue\n&gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))\nTrue\n\n\nIf a is a matrix object, then the return value is a matrix as well:\n&gt;&gt;&gt; ainv = inv(np.matrix(a))\n&gt;&gt;&gt; ainv\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n\n\nInverses of several matrices can be computed at once:\n&gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])\n&gt;&gt;&gt; inv(a)\narray([[[-2.  ,  1.  ],\n        [ 1.5 , -0.5 ]],\n       [[-1.25,  0.75],\n        [ 0.75, -0.25]]])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "Returns", "ainv(\u2026, M, M) ndarray or matrix", "Raises", "LinAlgError"], "returns": "ainv(\u2026, M, M) ndarray or matrix(Multiplicative) inverse of the matrix a.", "examples": ["; from numpy.linalg import inv\n; a = np.array([[1., 2.], [3., 4.]])\n; ainv = inv(a)\n; np.allclose(np.dot(a, ainv), np.eye(2))\nTrue\n; np.allclose(np.dot(ainv, a), np.eye(2))\nTrue\n\n", "; from numpy.linalg import inv\n; a = np.array([[1., 2.], [3., 4.]])\n; ainv = inv(a)\n; np.allclose(np.dot(a, ainv), np.eye(2))\nTrue\n; np.allclose(np.dot(ainv, a), np.eye(2))\nTrue\n", "; ainv = inv(np.matrix(a))\n; ainv\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n\n", "; ainv = inv(np.matrix(a))\n; ainv\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n", "; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])\n; inv(a)\narray([[[-2.  ,  1.  ],\n        [ 1.5 , -0.5 ]],\n       [[-1.25,  0.75],\n        [ 0.75, -0.25]]])\n\n", "; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])\n; inv(a)\narray([[[-2.  ,  1.  ],\n        [ 1.5 , -0.5 ]],\n       [[-1.25,  0.75],\n        [ 0.75, -0.25]]])\n"]},
{"library": "numpy", "item_id": "numpy.intersect1d", "code": "\nnumpy.intersect1d(ar1, ar2, assume_unique=False, return_indices=False)[source]\u00b6", "description": "Find the intersection of two arrays.\nReturn the sorted, unique values that are in both of the input arrays.\n\nParameters\n\nar1, ar2array_likeInput arrays. Will be flattened if not already 1D.\n\nassume_uniqueboolIf True, the input arrays are both assumed to be unique, which\ncan speed up the calculation.  Default is False.\n\nreturn_indicesboolIf True, the indices which correspond to the intersection of the two\narrays are returned. The first instance of a value is used if there are\nmultiple. Default is False.\n\nNew in version 1.15.0.\n\n\n\n\nReturns\n\nintersect1dndarraySorted 1D array of common and unique elements.\n\ncomm1ndarrayThe indices of the first occurrences of the common values in ar1.\nOnly provided if return_indices is True.\n\ncomm2ndarrayThe indices of the first occurrences of the common values in ar2.\nOnly provided if return_indices is True.\n\n\n\n\n\nSee also\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nExamples\n&gt;&gt;&gt; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\narray([1, 3])\n\n\nTo intersect more than two arrays, use functools.reduce:\n&gt;&gt;&gt; from functools import reduce\n&gt;&gt;&gt; reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([3])\n\n\nTo return the indices of the values common to the input arrays\nalong with the intersected values:\n&gt;&gt;&gt; x = np.array([1, 1, 2, 3, 4])\n&gt;&gt;&gt; y = np.array([2, 1, 4, 6])\n&gt;&gt;&gt; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)\n&gt;&gt;&gt; x_ind, y_ind\n(array([0, 2, 4]), array([1, 0, 2]))\n&gt;&gt;&gt; xy, x[x_ind], y[y_ind]\n(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\n\n\n", "parameters": ["Parameters", "ar1, ar2array_like", "assume_uniquebool", "return_indicesbool", "Returns", "intersect1dndarray", "comm1ndarray", "comm2ndarray"], "returns": "intersect1dndarraySorted 1D array of common and unique elements.comm1ndarrayThe indices of the first occurrences of the common values in ar1.Only provided if return_indices is True.comm2ndarrayThe indices of the first occurrences of the common values in ar2.Only provided if return_indices is True.", "examples": ["; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\narray([1, 3])\n\n", "; np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1])\narray([1, 3])\n", "; from functools import reduce\n; reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([3])\n\n", "; from functools import reduce\n; reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2]))\narray([3])\n", "; x = np.array([1, 1, 2, 3, 4])\n; y = np.array([2, 1, 4, 6])\n; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)\n; x_ind, y_ind\n(array([0, 2, 4]), array([1, 0, 2]))\n; xy, x[x_ind], y[y_ind]\n(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\n\n", "; x = np.array([1, 1, 2, 3, 4])\n; y = np.array([2, 1, 4, 6])\n; xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True)\n; x_ind, y_ind\n(array([0, 2, 4]), array([1, 0, 2]))\n; xy, x[x_ind], y[y_ind]\n(array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))\n"]},
{"library": "numpy", "item_id": "numpy.irr", "code": "\nnumpy.irr(values)[source]\u00b6", "description": "Return the Internal Rate of Return (IRR).\n\nDeprecated since version 1.18: irr is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\nThis is the \u201caverage\u201d periodically compounded rate of return\nthat gives a net present value of 0.0; for a more complete explanation,\nsee Notes below.\ndecimal.Decimal type is not supported.\n\nParameters\n\nvaluesarray_like, shape(N,)Input cash flows per time period.  By convention, net \u201cdeposits\u201d\nare negative and net \u201cwithdrawals\u201d are positive.  Thus, for\nexample, at least the first element of values, which represents\nthe initial investment, will typically be negative.\n\n\n\nReturns\n\noutfloatInternal Rate of Return for periodic input values.\n\n\n\n\nNotes\nThe IRR is perhaps best understood through an example (illustrated\nusing np.irr in the Examples section below).  Suppose one invests 100\nunits and then makes the following withdrawals at regular (fixed)\nintervals: 39, 59, 55, 20.  Assuming the ending value is 0, one\u2019s 100\nunit investment yields 173 units; however, due to the combination of\ncompounding and the periodic withdrawals, the \u201caverage\u201d rate of return\nis neither simply 0.73/4 nor (1.73)^0.25-1.  Rather, it is the solution\n(for ) of the equation:\n\n\nIn general, for values ,\nirr is the solution of the equation: [2]\n\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nL. J. Gitman, \u201cPrinciples of Managerial Finance, Brief,\u201d 3rd ed.,\nAddison-Wesley, 2003, pg. 348.\n\n\nExamples\n&gt;&gt;&gt; round(np.irr([-100, 39, 59, 55, 20]), 5)\n0.28095\n&gt;&gt;&gt; round(np.irr([-100, 0, 0, 74]), 5)\n-0.0955\n&gt;&gt;&gt; round(np.irr([-100, 100, 0, -7]), 5)\n-0.0833\n&gt;&gt;&gt; round(np.irr([-100, 100, 0, 7]), 5)\n0.06206\n&gt;&gt;&gt; round(np.irr([-5, 10.5, 1, -8, 1]), 5)\n0.0886\n\n\n", "parameters": ["Parameters", "valuesarray_like, shape(N,)", "Returns", "outfloat"], "returns": "outfloatInternal Rate of Return for periodic input values.", "examples": ["; round(np.irr([-100, 39, 59, 55, 20]), 5)\n0.28095\n; round(np.irr([-100, 0, 0, 74]), 5)\n-0.0955\n; round(np.irr([-100, 100, 0, -7]), 5)\n-0.0833\n; round(np.irr([-100, 100, 0, 7]), 5)\n0.06206\n; round(np.irr([-5, 10.5, 1, -8, 1]), 5)\n0.0886\n\n", "; round(np.irr([-100, 39, 59, 55, 20]), 5)\n0.28095\n; round(np.irr([-100, 0, 0, 74]), 5)\n-0.0955\n; round(np.irr([-100, 100, 0, -7]), 5)\n-0.0833\n; round(np.irr([-100, 100, 0, 7]), 5)\n0.06206\n; round(np.irr([-5, 10.5, 1, -8, 1]), 5)\n0.0886\n"]},
{"library": "numpy", "item_id": "numpy.ipmt", "code": "\nnumpy.ipmt(rate, per, nper, pv, fv=0, when='end')[source]\u00b6", "description": "Compute the interest portion of a payment.\n\nDeprecated since version 1.18: ipmt is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nParameters\n\nratescalar or array_like of shape(M, )Rate of interest as decimal (not per cent) per period\n\nperscalar or array_like of shape(M, )Interest paid against the loan changes during the life or the loan.\nThe per is the payment period to calculate the interest amount.\n\nnperscalar or array_like of shape(M, )Number of compounding periods\n\npvscalar or array_like of shape(M, )Present value\n\nfvscalar or array_like of shape(M, ), optionalFuture value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optionalWhen payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0)).\nDefaults to {\u2018end\u2019, 0}.\n\n\n\nReturns\n\noutndarrayInterest portion of payment.  If all input is scalar, returns a scalar\nfloat.  If any input is array_like, returns interest payment for each\ninput element. If multiple inputs are array_like, they all must have\nthe same shape.\n\n\n\n\n\nSee also\nppmt, pmt, pv\n\nNotes\nThe total payment is made up of payment against principal plus interest.\npmt = ppmt + ipmt\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n\nExamples\nWhat is the amortization schedule for a 1 year loan of $2500 at\n8.24% interest per year compounded monthly?\n&gt;&gt;&gt; principal = 2500.00\n\n\nThe \u2018per\u2019 variable represents the periods of the loan.  Remember that\nfinancial equations start the period count at 1!\n&gt;&gt;&gt; per = np.arange(1*12) + 1\n&gt;&gt;&gt; ipmt = np.ipmt(0.0824/12, per, 1*12, principal)\n&gt;&gt;&gt; ppmt = np.ppmt(0.0824/12, per, 1*12, principal)\n\n\nEach element of the sum of the \u2018ipmt\u2019 and \u2018ppmt\u2019 arrays should equal\n\u2018pmt\u2019.\n&gt;&gt;&gt; pmt = np.pmt(0.0824/12, 1*12, principal)\n&gt;&gt;&gt; np.allclose(ipmt + ppmt, pmt)\nTrue\n\n\n&gt;&gt;&gt; fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'\n&gt;&gt;&gt; for payment in per:\n...     index = payment - 1\n...     principal = principal + ppmt[index]\n...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))\n 1  -200.58   -17.17  2299.42\n 2  -201.96   -15.79  2097.46\n 3  -203.35   -14.40  1894.11\n 4  -204.74   -13.01  1689.37\n 5  -206.15   -11.60  1483.22\n 6  -207.56   -10.18  1275.66\n 7  -208.99    -8.76  1066.67\n 8  -210.42    -7.32   856.25\n 9  -211.87    -5.88   644.38\n10  -213.32    -4.42   431.05\n11  -214.79    -2.96   216.26\n12  -216.26    -1.49    -0.00\n\n\n&gt;&gt;&gt; interestpd = np.sum(ipmt)\n&gt;&gt;&gt; np.round(interestpd, 2)\n-112.98\n\n\n", "parameters": ["Parameters", "ratescalar or array_like of shape(M, )", "perscalar or array_like of shape(M, )", "nperscalar or array_like of shape(M, )", "pvscalar or array_like of shape(M, )", "fvscalar or array_like of shape(M, ), optional", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optional", "Returns", "outndarray"], "returns": "outndarrayInterest portion of payment.  If all input is scalar, returns a scalarfloat.  If any input is array_like, returns interest payment for eachinput element. If multiple inputs are array_like, they all must havethe same shape.", "examples": ["; principal = 2500.00\n\n", "; principal = 2500.00\n", "; per = np.arange(1*12) + 1\n; ipmt = np.ipmt(0.0824/12, per, 1*12, principal)\n; ppmt = np.ppmt(0.0824/12, per, 1*12, principal)\n\n", "; per = np.arange(1*12) + 1\n; ipmt = np.ipmt(0.0824/12, per, 1*12, principal)\n; ppmt = np.ppmt(0.0824/12, per, 1*12, principal)\n", "; pmt = np.pmt(0.0824/12, 1*12, principal)\n; np.allclose(ipmt + ppmt, pmt)\nTrue\n\n", "; pmt = np.pmt(0.0824/12, 1*12, principal)\n; np.allclose(ipmt + ppmt, pmt)\nTrue\n", "; fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'\n; for payment in per:\n...     index = payment - 1\n...     principal = principal + ppmt[index]\n...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))\n 1  -200.58   -17.17  2299.42\n 2  -201.96   -15.79  2097.46\n 3  -203.35   -14.40  1894.11\n 4  -204.74   -13.01  1689.37\n 5  -206.15   -11.60  1483.22\n 6  -207.56   -10.18  1275.66\n 7  -208.99    -8.76  1066.67\n 8  -210.42    -7.32   856.25\n 9  -211.87    -5.88   644.38\n10  -213.32    -4.42   431.05\n11  -214.79    -2.96   216.26\n12  -216.26    -1.49    -0.00\n\n", "; fmt = '{0:2d} {1:8.2f} {2:8.2f} {3:8.2f}'\n; for payment in per:\n...     index = payment - 1\n...     principal = principal + ppmt[index]\n...     print(fmt.format(payment, ppmt[index], ipmt[index], principal))\n 1  -200.58   -17.17  2299.42\n 2  -201.96   -15.79  2097.46\n 3  -203.35   -14.40  1894.11\n 4  -204.74   -13.01  1689.37\n 5  -206.15   -11.60  1483.22\n 6  -207.56   -10.18  1275.66\n 7  -208.99    -8.76  1066.67\n 8  -210.42    -7.32   856.25\n 9  -211.87    -5.88   644.38\n10  -213.32    -4.42   431.05\n11  -214.79    -2.96   216.26\n12  -216.26    -1.49    -0.00\n", "; interestpd = np.sum(ipmt)\n; np.round(interestpd, 2)\n-112.98\n\n", "; interestpd = np.sum(ipmt)\n; np.round(interestpd, 2)\n-112.98\n"]},
{"library": "numpy", "item_id": "numpy.interp", "code": "\nnumpy.interp(x, xp, fp, left=None, right=None, period=None)[source]\u00b6", "description": "One-dimensional linear interpolation.\nReturns the one-dimensional piecewise linear interpolant to a function\nwith given discrete data points (xp, fp), evaluated at x.\n\nParameters\n\nxarray_likeThe x-coordinates at which to evaluate the interpolated values.\n\nxp1-D sequence of floatsThe x-coordinates of the data points, must be increasing if argument\nperiod is not specified. Otherwise, xp is internally sorted after\nnormalizing the periodic boundaries with xp = xp % period.\n\nfp1-D sequence of float or complexThe y-coordinates of the data points, same length as xp.\n\nleftoptional float or complex corresponding to fpValue to return for x &lt; xp[0], default is fp[0].\n\nrightoptional float or complex corresponding to fpValue to return for x &gt; xp[-1], default is fp[-1].\n\nperiodNone or float, optionalA period for the x-coordinates. This parameter allows the proper\ninterpolation of angular x-coordinates. Parameters left and right\nare ignored if period is specified.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\nyfloat or complex (corresponding to fp) or ndarrayThe interpolated values, same shape as x.\n\n\n\nRaises\n\nValueErrorIf xp and fp have different length\nIf xp or fp are not 1-D sequences\nIf period == 0\n\n\n\n\nNotes\nThe x-coordinate sequence is expected to be increasing, but this is not\nexplicitly enforced.  However, if the sequence xp is non-increasing,\ninterpolation results are meaningless.\nNote that, since NaN is unsortable, xp also cannot contain NaNs.\nA simple check for xp being strictly increasing is:\nnp.all(np.diff(xp) &gt; 0)\n\n\nExamples\n&gt;&gt;&gt; xp = [1, 2, 3]\n&gt;&gt;&gt; fp = [3, 2, 0]\n&gt;&gt;&gt; np.interp(2.5, xp, fp)\n1.0\n&gt;&gt;&gt; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\narray([3.  , 3.  , 2.5 , 0.56, 0.  ])\n&gt;&gt;&gt; UNDEF = -99.0\n&gt;&gt;&gt; np.interp(3.14, xp, fp, right=UNDEF)\n-99.0\n\n\nPlot an interpolant to the sine function:\n&gt;&gt;&gt; x = np.linspace(0, 2*np.pi, 10)\n&gt;&gt;&gt; y = np.sin(x)\n&gt;&gt;&gt; xvals = np.linspace(0, 2*np.pi, 50)\n&gt;&gt;&gt; yinterp = np.interp(xvals, x, y)\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.plot(x, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.plot(xvals, yinterp, '-x')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nInterpolation with periodic x-coordinates:\n&gt;&gt;&gt; x = [-180, -170, -185, 185, -10, -5, 0, 365]\n&gt;&gt;&gt; xp = [190, -190, 350, -350]\n&gt;&gt;&gt; fp = [5, 10, 3, 4]\n&gt;&gt;&gt; np.interp(x, xp, fp, period=360)\narray([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n\n\nComplex interpolation:\n&gt;&gt;&gt; x = [1.5, 4.0]\n&gt;&gt;&gt; xp = [2,3,5]\n&gt;&gt;&gt; fp = [1.0j, 0, 2+3j]\n&gt;&gt;&gt; np.interp(x, xp, fp)\narray([0.+1.j , 1.+1.5j])\n\n\n", "parameters": ["Parameters", "xarray_like", "xp1-D sequence of floats", "fp1-D sequence of float or complex", "leftoptional float or complex corresponding to fp", "rightoptional float or complex corresponding to fp", "periodNone or float, optional", "Returns", "yfloat or complex (corresponding to fp) or ndarray", "Raises", "ValueError"], "returns": "yfloat or complex (corresponding to fp) or ndarrayThe interpolated values, same shape as x.", "examples": ["; xp = [1, 2, 3]\n; fp = [3, 2, 0]\n; np.interp(2.5, xp, fp)\n1.0\n; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\narray([3.  , 3.  , 2.5 , 0.56, 0.  ])\n; UNDEF = -99.0\n; np.interp(3.14, xp, fp, right=UNDEF)\n-99.0\n\n", "; xp = [1, 2, 3]\n; fp = [3, 2, 0]\n; np.interp(2.5, xp, fp)\n1.0\n; np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)\narray([3.  , 3.  , 2.5 , 0.56, 0.  ])\n; UNDEF = -99.0\n; np.interp(3.14, xp, fp, right=UNDEF)\n-99.0\n", "; x = np.linspace(0, 2*np.pi, 10)\n; y = np.sin(x)\n; xvals = np.linspace(0, 2*np.pi, 50)\n; yinterp = np.interp(xvals, x, y)\n; import matplotlib.pyplot as plt\n; plt.plot(x, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(xvals, yinterp, '-x')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.show()\n\n", "; x = np.linspace(0, 2*np.pi, 10)\n; y = np.sin(x)\n; xvals = np.linspace(0, 2*np.pi, 50)\n; yinterp = np.interp(xvals, x, y)\n; import matplotlib.pyplot as plt\n; plt.plot(x, y, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.plot(xvals, yinterp, '-x')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.show()\n", "; x = [-180, -170, -185, 185, -10, -5, 0, 365]\n; xp = [190, -190, 350, -350]\n; fp = [5, 10, 3, 4]\n; np.interp(x, xp, fp, period=360)\narray([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n\n", "; x = [-180, -170, -185, 185, -10, -5, 0, 365]\n; xp = [190, -190, 350, -350]\n; fp = [5, 10, 3, 4]\n; np.interp(x, xp, fp, period=360)\narray([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])\n", "; x = [1.5, 4.0]\n; xp = [2,3,5]\n; fp = [1.0j, 0, 2+3j]\n; np.interp(x, xp, fp)\narray([0.+1.j , 1.+1.5j])\n\n", "; x = [1.5, 4.0]\n; xp = [2,3,5]\n; fp = [1.0j, 0, 2+3j]\n; np.interp(x, xp, fp)\narray([0.+1.j , 1.+1.5j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.interpolate", "code": "\nclassmethod Chebyshev.interpolate(func, deg, domain=None, args=())[source]\u00b6", "description": "Interpolate a function at the Chebyshev points of the first kind.\nReturns the series that interpolates func at the Chebyshev points of\nthe first kind scaled and shifted to the domain. The resulting series\ntends to a minmax approximation of func when the function is\ncontinuous in the domain.\n\nNew in version 1.14.0.\n\n\nParameters\n\nfuncfunctionThe function to be interpolated. It must be a function of a single\nvariable of the form f(x, a, b, c...), where a, b, c... are\nextra arguments passed in the args parameter.\n\ndegintDegree of the interpolating polynomial.\n\ndomain{None, [beg, end]}, optionalDomain over which func is interpolated. The default is None, in\nwhich case the domain is [-1, 1].\n\nargstuple, optionalExtra arguments to be used in the function call. Default is no\nextra arguments.\n\n\n\nReturns\n\npolynomialChebyshev instanceInterpolating Chebyshev instance.\n\n\n\n\nNotes\nSee numpy.polynomial.chebfromfunction for more details.\n", "parameters": ["Parameters", "funcfunction", "degint", "domain{None, [beg, end]}, optional", "argstuple, optional", "Returns", "polynomialChebyshev instance"], "returns": "polynomialChebyshev instanceInterpolating Chebyshev instance.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.integ", "code": "\nHermiteE.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.integ", "code": "\nHermite.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.integers", "code": "\nGenerator.integers(low, high=None, size=None, dtype=np.int64, endpoint=False)\u00b6", "description": "Return random integers from low (inclusive) to high (exclusive), or\nif endpoint=True, low (inclusive) to high (inclusive). Replaces\nRandomState.randint (with endpoint=False) and\nRandomState.random_integers (with endpoint=True)\nReturn random integers from the \u201cdiscrete uniform\u201d distribution of\nthe specified dtype. If high is None (the default), then results are\nfrom 0 to low.\n\nParameters\n\nlowint or array-like of intsLowest (signed) integers to be drawn from the distribution (unless\nhigh=None, in which case this parameter is 0 and this value is\nused for high).\n\nhighint or array-like of ints, optionalIf provided, one above the largest (signed) integer to be drawn\nfrom the distribution (see above for behavior if high=None).\nIf array-like, must contain integer values\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\ndtypedtype, optionalDesired dtype of the result. Byteorder must be native.\nThe default value is np.int64.\n\nendpointbool, optionalIf true, sample from the interval [low, high] instead of the\ndefault [low, high)\nDefaults to False\n\n\n\nReturns\n\noutint or ndarray of intssize-shaped array of random integers from the appropriate\ndistribution, or a single such random int if size not provided.\n\n\n\n\nNotes\nWhen using broadcasting with uint64 dtypes, the maximum value (2**64)\ncannot be represented as a standard integer type. The high array (or\nlow if high is None) must have object dtype, e.g., array([2**64]).\nReferences\n\n1\nDaniel Lemire., \u201cFast Random Integer Generation in an Interval\u201d,\nACM Transactions on Modeling and Computer Simulation 29 (1), 2019,\nhttp://arxiv.org/abs/1805.10941.\n\n\nExamples\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.integers(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])  # random\n&gt;&gt;&gt; rng.integers(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n\nGenerate a 2 x 4 array of ints between 0 and 4, inclusive:\n&gt;&gt;&gt; rng.integers(5, size=(2, 4))\narray([[4, 0, 2, 1],\n       [3, 2, 2, 0]])  # random\n\n\nGenerate a 1 x 3 array with 3 different upper bounds\n&gt;&gt;&gt; rng.integers(1, [3, 5, 10])\narray([2, 2, 9])  # random\n\n\nGenerate a 1 by 3 array with 3 different lower bounds\n&gt;&gt;&gt; rng.integers([1, 5, 7], 10)\narray([9, 8, 7])  # random\n\n\nGenerate a 2 by 4 array using broadcasting with dtype of uint8\n&gt;&gt;&gt; rng.integers([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7],\n       [ 1, 16,  9, 12]], dtype=uint8)  # random\n\n\n", "parameters": ["Parameters", "lowint or array-like of ints", "highint or array-like of ints, optional", "sizeint or tuple of ints, optional", "dtypedtype, optional", "endpointbool, optional", "Returns", "outint or ndarray of ints"], "returns": "outint or ndarray of intssize-shaped array of random integers from the appropriatedistribution, or a single such random int if size not provided.", "examples": ["; rng = np.random.default_rng()\n; rng.integers(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])  # random\n; rng.integers(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n\n", "; rng = np.random.default_rng()\n; rng.integers(2, size=10)\narray([1, 0, 0, 0, 1, 1, 0, 0, 1, 0])  # random\n; rng.integers(1, size=10)\narray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n", "; rng.integers(5, size=(2, 4))\narray([[4, 0, 2, 1],\n       [3, 2, 2, 0]])  # random\n\n", "; rng.integers(5, size=(2, 4))\narray([[4, 0, 2, 1],\n       [3, 2, 2, 0]])  # random\n", "; rng.integers(1, [3, 5, 10])\narray([2, 2, 9])  # random\n\n", "; rng.integers(1, [3, 5, 10])\narray([2, 2, 9])  # random\n", "; rng.integers([1, 5, 7], 10)\narray([9, 8, 7])  # random\n\n", "; rng.integers([1, 5, 7], 10)\narray([9, 8, 7])  # random\n", "; rng.integers([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7],\n       [ 1, 16,  9, 12]], dtype=uint8)  # random\n\n", "; rng.integers([1, 3, 5, 7], [[10], [20]], dtype=np.uint8)\narray([[ 8,  6,  9,  7],\n       [ 1, 16,  9, 12]], dtype=uint8)  # random\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.integ", "code": "\nPolynomial.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.integ", "code": "\nLegendre.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.integ", "code": "\nLaguerre.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.integ", "code": "\nChebyshev.integ(self, m=1, k=[], lbnd=None)[source]\u00b6", "description": "Integrate.\nReturn a series instance that is the definite integral of the\ncurrent series.\n\nParameters\n\nmnon-negative intThe number of integrations to perform.\n\nkarray_likeIntegration constants. The first constant is applied to the\nfirst integration, the second to the second, and so on. The\nlist of values must less than or equal to m in length and any\nmissing values are set to zero.\n\nlbndScalarThe lower bound of the definite integral.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the integral. The domain is the same\nas the domain of the integrated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "karray_like", "lbndScalar", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the integral. The domain is the sameas the domain of the integrated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.integ", "code": "\npoly1d.integ(self, m=1, k=0)[source]\u00b6", "description": "Return an antiderivative (indefinite integral) of this polynomial.\nRefer to polyint for full documentation.\n\nSee also\n\npolyintequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.indices", "code": "\nnumpy.ma.indices(dimensions, dtype=&lt;class 'int'&gt;, sparse=False)[source]\u00b6", "description": "Return an array representing the indices of a grid.\nCompute an array where the subarrays contain index values 0, 1, \u2026\nvarying only along the corresponding axis.\n\nParameters\n\ndimensionssequence of intsThe shape of the grid.\n\ndtypedtype, optionalData type of the result.\n\nsparseboolean, optionalReturn a sparse representation of the grid instead of a dense\nrepresentation. Default is False.\n\nNew in version 1.17.\n\n\n\n\nReturns\n\ngridone ndarray or tuple of ndarrays\nIf sparse is False:Returns one array of grid indices,\ngrid.shape = (len(dimensions),) + tuple(dimensions).\n\nIf sparse is True:Returns a tuple of arrays, with\ngrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) with\ndimensions[i] in the ith place\n\n\n\n\n\n\n\nSee also\nmgrid, ogrid, meshgrid\n\nNotes\nThe output shape in the dense case is obtained by prepending the number\nof dimensions in front of the tuple of dimensions, i.e. if dimensions\nis a tuple (r0, ..., rN-1) of length N, the output shape is\n(N, r0, ..., rN-1).\nThe subarrays grid[k] contains the N-D array of indices along the\nk-th axis. Explicitly:\ngrid[k, i0, i1, ..., iN-1] = ik\n\n\nExamples\n&gt;&gt;&gt; grid = np.indices((2, 3))\n&gt;&gt;&gt; grid.shape\n(2, 2, 3)\n&gt;&gt;&gt; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n&gt;&gt;&gt; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n\n\nThe indices can be used as an index into an array.\n&gt;&gt;&gt; x = np.arange(20).reshape(5, 4)\n&gt;&gt;&gt; row, col = np.indices((2, 3))\n&gt;&gt;&gt; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n\n\nNote that it would be more straightforward in the above example to\nextract the required elements directly with x[:2, :3].\nIf sparse is set to true, the grid will be returned in a sparse\nrepresentation.\n&gt;&gt;&gt; i, j = np.indices((2, 3), sparse=True)\n&gt;&gt;&gt; i.shape\n(2, 1)\n&gt;&gt;&gt; j.shape\n(1, 3)\n&gt;&gt;&gt; i        # row indices\narray([[0],\n       [1]])\n&gt;&gt;&gt; j        # column indices\narray([[0, 1, 2]])\n\n\n", "parameters": ["Parameters", "dimensionssequence of ints", "dtypedtype, optional", "sparseboolean, optional", "Returns", "gridone ndarray or tuple of ndarrays", "If sparse is False:", "If sparse is True:"], "returns": "gridone ndarray or tuple of ndarraysIf sparse is False:Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).If sparse is True:Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place", "examples": ["; grid = np.indices((2, 3))\n; grid.shape\n(2, 2, 3)\n; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n\n", "; grid = np.indices((2, 3))\n; grid.shape\n(2, 2, 3)\n; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n", "; x = np.arange(20).reshape(5, 4)\n; row, col = np.indices((2, 3))\n; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n\n", "; x = np.arange(20).reshape(5, 4)\n; row, col = np.indices((2, 3))\n; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n", "; i, j = np.indices((2, 3), sparse=True)\n; i.shape\n(2, 1)\n; j.shape\n(1, 3)\n; i        # row indices\narray([[0],\n       [1]])\n; j        # column indices\narray([[0, 1, 2]])\n\n", "; i, j = np.indices((2, 3), sparse=True)\n; i.shape\n(2, 1)\n; j.shape\n(1, 3)\n; i        # row indices\narray([[0],\n       [1]])\n; j        # column indices\narray([[0, 1, 2]])\n"]},
{"library": "numpy", "item_id": "numpy.insert", "code": "\nnumpy.insert(arr, obj, values, axis=None)[source]\u00b6", "description": "Insert values along the given axis before the given indices.\n\nParameters\n\narrarray_likeInput array.\n\nobjint, slice or sequence of intsObject that defines the index or indices before which values is\ninserted.\n\nNew in version 1.8.0.\n\nSupport for multiple insertions when obj is a single scalar or a\nsequence with one element (similar to calling insert multiple\ntimes).\n\nvaluesarray_likeValues to insert into arr. If the type of values is different\nfrom that of arr, values is converted to the type of arr.\nvalues should be shaped so that arr[...,obj,...] = values\nis legal.\n\naxisint, optionalAxis along which to insert values.  If axis is None then arr\nis flattened first.\n\n\n\nReturns\n\noutndarrayA copy of arr with values inserted.  Note that insert\ndoes not occur in-place: a new array is returned. If\naxis is None, out is a flattened array.\n\n\n\n\n\nSee also\n\nappendAppend elements at the end of an array.\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\ndeleteDelete elements from an array.\n\n\n\nNotes\nNote that for higher dimensional inserts obj=0 behaves very different\nfrom obj=[0] just like arr[:,0,:] = values is different from\narr[:,[0],:] = values.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 1], [2, 2], [3, 3]])\n&gt;&gt;&gt; a\narray([[1, 1],\n       [2, 2],\n       [3, 3]])\n&gt;&gt;&gt; np.insert(a, 1, 5)\narray([1, 5, 1, ..., 2, 3, 3])\n&gt;&gt;&gt; np.insert(a, 1, 5, axis=1)\narray([[1, 5, 1],\n       [2, 5, 2],\n       [3, 5, 3]])\n\n\nDifference between sequence and scalars:\n&gt;&gt;&gt; np.insert(a, [1], [[1],[2],[3]], axis=1)\narray([[1, 1, 1],\n       [2, 2, 2],\n       [3, 3, 3]])\n&gt;&gt;&gt; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),\n...                np.insert(a, [1], [[1],[2],[3]], axis=1))\nTrue\n\n\n&gt;&gt;&gt; b = a.flatten()\n&gt;&gt;&gt; b\narray([1, 1, 2, 2, 3, 3])\n&gt;&gt;&gt; np.insert(b, [2, 2], [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n\n\n&gt;&gt;&gt; np.insert(b, slice(2, 4), [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n\n\n&gt;&gt;&gt; np.insert(b, [2, 2], [7.13, False]) # type casting\narray([1, 1, 7, ..., 2, 3, 3])\n\n\n&gt;&gt;&gt; x = np.arange(8).reshape(2, 4)\n&gt;&gt;&gt; idx = (1, 3)\n&gt;&gt;&gt; np.insert(x, idx, 999, axis=1)\narray([[  0, 999,   1,   2, 999,   3],\n       [  4, 999,   5,   6, 999,   7]])\n\n\n", "parameters": ["Parameters", "arrarray_like", "objint, slice or sequence of ints", "valuesarray_like", "axisint, optional", "Returns", "outndarray"], "returns": "outndarrayA copy of arr with values inserted.  Note that insertdoes not occur in-place: a new array is returned. Ifaxis is None, out is a flattened array.", "examples": ["; a = np.array([[1, 1], [2, 2], [3, 3]])\n; a\narray([[1, 1],\n       [2, 2],\n       [3, 3]])\n; np.insert(a, 1, 5)\narray([1, 5, 1, ..., 2, 3, 3])\n; np.insert(a, 1, 5, axis=1)\narray([[1, 5, 1],\n       [2, 5, 2],\n       [3, 5, 3]])\n\n", "; a = np.array([[1, 1], [2, 2], [3, 3]])\n; a\narray([[1, 1],\n       [2, 2],\n       [3, 3]])\n; np.insert(a, 1, 5)\narray([1, 5, 1, ..., 2, 3, 3])\n; np.insert(a, 1, 5, axis=1)\narray([[1, 5, 1],\n       [2, 5, 2],\n       [3, 5, 3]])\n", "; np.insert(a, [1], [[1],[2],[3]], axis=1)\narray([[1, 1, 1],\n       [2, 2, 2],\n       [3, 3, 3]])\n; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),\n...                np.insert(a, [1], [[1],[2],[3]], axis=1))\nTrue\n\n", "; np.insert(a, [1], [[1],[2],[3]], axis=1)\narray([[1, 1, 1],\n       [2, 2, 2],\n       [3, 3, 3]])\n; np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),\n...                np.insert(a, [1], [[1],[2],[3]], axis=1))\nTrue\n", "; b = a.flatten()\n; b\narray([1, 1, 2, 2, 3, 3])\n; np.insert(b, [2, 2], [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n\n", "; b = a.flatten()\n; b\narray([1, 1, 2, 2, 3, 3])\n; np.insert(b, [2, 2], [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n", "; np.insert(b, slice(2, 4), [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n\n", "; np.insert(b, slice(2, 4), [5, 6])\narray([1, 1, 5, ..., 2, 3, 3])\n", "; np.insert(b, [2, 2], [7.13, False]) # type casting\narray([1, 1, 7, ..., 2, 3, 3])\n\n", "; np.insert(b, [2, 2], [7.13, False]) # type casting\narray([1, 1, 7, ..., 2, 3, 3])\n", "; x = np.arange(8).reshape(2, 4)\n; idx = (1, 3)\n; np.insert(x, idx, 999, axis=1)\narray([[  0, 999,   1,   2, 999,   3],\n       [  4, 999,   5,   6, 999,   7]])\n\n", "; x = np.arange(8).reshape(2, 4)\n; idx = (1, 3)\n; np.insert(x, idx, 999, axis=1)\narray([[  0, 999,   1,   2, 999,   3],\n       [  4, 999,   5,   6, 999,   7]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.innerproduct", "code": "\nnumpy.ma.innerproduct(a, b)[source]\u00b6", "description": "Inner product of two arrays.\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.\n\nParameters\n\na, barray_likeIf a and b are nonscalar, their last dimensions must match.\n\n\n\nReturns\n\noutndarrayout.shape = a.shape[:-1] + b.shape[:-1]\n\n\n\nRaises\n\nValueErrorIf the last dimension of a and b has different size.\n\n\n\n\n\nSee also\n\ntensordotSum products over arbitrary axes.\n\ndotGeneralised matrix product, using second last dimension of b.\n\neinsumEinstein summation convention.\n\n\n\nNotes\nMasked values are replaced by 0.\nFor vectors (1-D arrays) it computes the ordinary inner-product:\nnp.inner(a, b) = sum(a[:]*b[:])\n\n\nMore generally, if ndim(a) = r &gt; 0 and ndim(b) = s &gt; 0:\nnp.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n\nor explicitly:\nnp.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n     = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n\nIn addition a or b may be scalars, in which case:\nnp.inner(a,b) = a*b\n\n\nExamples\nOrdinary inner product for vectors:\n&gt;&gt;&gt; a = np.array([1,2,3])\n&gt;&gt;&gt; b = np.array([0,1,0])\n&gt;&gt;&gt; np.inner(a, b)\n2\n\n\nA multidimensional example:\n&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))\n&gt;&gt;&gt; b = np.arange(4)\n&gt;&gt;&gt; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n\nAn example where b is a scalar:\n&gt;&gt;&gt; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n\n", "parameters": ["Parameters", "a, barray_like", "Returns", "outndarray", "Raises", "ValueError"], "returns": "outndarrayout.shape = a.shape[:-1] + b.shape[:-1]", "examples": ["; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n\n", "; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.inner", "code": "\nnumpy.ma.inner(a, b)[source]\u00b6", "description": "Inner product of two arrays.\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.\n\nParameters\n\na, barray_likeIf a and b are nonscalar, their last dimensions must match.\n\n\n\nReturns\n\noutndarrayout.shape = a.shape[:-1] + b.shape[:-1]\n\n\n\nRaises\n\nValueErrorIf the last dimension of a and b has different size.\n\n\n\n\n\nSee also\n\ntensordotSum products over arbitrary axes.\n\ndotGeneralised matrix product, using second last dimension of b.\n\neinsumEinstein summation convention.\n\n\n\nNotes\nMasked values are replaced by 0.\nFor vectors (1-D arrays) it computes the ordinary inner-product:\nnp.inner(a, b) = sum(a[:]*b[:])\n\n\nMore generally, if ndim(a) = r &gt; 0 and ndim(b) = s &gt; 0:\nnp.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n\nor explicitly:\nnp.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n     = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n\nIn addition a or b may be scalars, in which case:\nnp.inner(a,b) = a*b\n\n\nExamples\nOrdinary inner product for vectors:\n&gt;&gt;&gt; a = np.array([1,2,3])\n&gt;&gt;&gt; b = np.array([0,1,0])\n&gt;&gt;&gt; np.inner(a, b)\n2\n\n\nA multidimensional example:\n&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))\n&gt;&gt;&gt; b = np.arange(4)\n&gt;&gt;&gt; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n\nAn example where b is a scalar:\n&gt;&gt;&gt; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n\n", "parameters": ["Parameters", "a, barray_like", "Returns", "outndarray", "Raises", "ValueError"], "returns": "outndarrayout.shape = a.shape[:-1] + b.shape[:-1]", "examples": ["; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n\n", "; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n"]},
{"library": "numpy", "item_id": "numpy.inner", "code": "\nnumpy.inner(a, b)\u00b6", "description": "Inner product of two arrays.\nOrdinary inner product of vectors for 1-D arrays (without complex\nconjugation), in higher dimensions a sum product over the last axes.\n\nParameters\n\na, barray_likeIf a and b are nonscalar, their last dimensions must match.\n\n\n\nReturns\n\noutndarrayout.shape = a.shape[:-1] + b.shape[:-1]\n\n\n\nRaises\n\nValueErrorIf the last dimension of a and b has different size.\n\n\n\n\n\nSee also\n\ntensordotSum products over arbitrary axes.\n\ndotGeneralised matrix product, using second last dimension of b.\n\neinsumEinstein summation convention.\n\n\n\nNotes\nFor vectors (1-D arrays) it computes the ordinary inner-product:\nnp.inner(a, b) = sum(a[:]*b[:])\n\n\nMore generally, if ndim(a) = r &gt; 0 and ndim(b) = s &gt; 0:\nnp.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))\n\n\nor explicitly:\nnp.inner(a, b)[i0,...,ir-1,j0,...,js-1]\n     = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])\n\n\nIn addition a or b may be scalars, in which case:\nnp.inner(a,b) = a*b\n\n\nExamples\nOrdinary inner product for vectors:\n&gt;&gt;&gt; a = np.array([1,2,3])\n&gt;&gt;&gt; b = np.array([0,1,0])\n&gt;&gt;&gt; np.inner(a, b)\n2\n\n\nA multidimensional example:\n&gt;&gt;&gt; a = np.arange(24).reshape((2,3,4))\n&gt;&gt;&gt; b = np.arange(4)\n&gt;&gt;&gt; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n\nAn example where b is a scalar:\n&gt;&gt;&gt; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n\n", "parameters": ["Parameters", "a, barray_like", "Returns", "outndarray", "Raises", "ValueError"], "returns": "outndarrayout.shape = a.shape[:-1] + b.shape[:-1]", "examples": ["; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n\n", "; a = np.array([1,2,3])\n; b = np.array([0,1,0])\n; np.inner(a, b)\n2\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n\n", "; a = np.arange(24).reshape((2,3,4))\n; b = np.arange(4)\n; np.inner(a, b)\narray([[ 14,  38,  62],\n       [ 86, 110, 134]])\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n\n", "; np.inner(np.eye(2), 7)\narray([[7., 0.],\n       [0., 7.]])\n"]},
{"library": "numpy", "item_id": "numpy.info", "code": "\nnumpy.info(object=None, maxwidth=76, output=&lt;_io.TextIOWrapper name='&lt;stdout&gt;' mode='w' encoding='utf-8'&gt;, toplevel='numpy')[source]\u00b6", "description": "Get help information for a function, class, or module.\n\nParameters\n\nobjectobject or str, optionalInput object or name to get information about. If object is a\nnumpy object, its docstring is given. If it is a string, available\nmodules are searched for matching objects.  If None, information\nabout info itself is returned.\n\nmaxwidthint, optionalPrinting width.\n\noutputfile like object, optionalFile like object that the output is written to, default is\nstdout.  The object has to be opened in \u2018w\u2019 or \u2018a\u2019 mode.\n\ntoplevelstr, optionalStart search at this level.\n\n\n\n\n\nSee also\nsource, lookfor\n\nNotes\nWhen used interactively with an object, np.info(obj) is equivalent\nto help(obj) on the Python prompt or obj? on the IPython\nprompt.\nExamples\n&gt;&gt;&gt; np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...\n\n\nWhen using a string for object it is possible to get multiple results.\n&gt;&gt;&gt; np.info('fft') \n     *** Found in numpy ***\nCore FFT routines\n...\n     *** Found in numpy.fft ***\n fft(a, n=None, axis=-1)\n...\n     *** Repeat reference found in numpy.fft.fftpack ***\n     *** Total of 3 references found. ***\n\n\n", "parameters": ["Parameters", "objectobject or str, optional", "maxwidthint, optional", "outputfile like object, optional", "toplevelstr, optional"], "returns": [], "examples": ["; np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...\n\n", "; np.info(np.polyval) \n   polyval(p, x)\n     Evaluate the polynomial p at x.\n     ...\n", "; np.info('fft') \n     *** Found in numpy ***\nCore FFT routines\n...\n     *** Found in numpy.fft ***\n fft(a, n=None, axis=-1)\n...\n     *** Repeat reference found in numpy.fft.fftpack ***\n     *** Total of 3 references found. ***\n\n", "; np.info('fft') \n     *** Found in numpy ***\nCore FFT routines\n...\n     *** Found in numpy.fft ***\n fft(a, n=None, axis=-1)\n...\n     *** Repeat reference found in numpy.fft.fftpack ***\n     *** Total of 3 references found. ***\n"]},
{"library": "numpy", "item_id": "numpy.char.index", "code": "\nnumpy.char.index(a, sub, start=0, end=None)\u00b6", "description": "Like find, but raises ValueError when the substring is not found.\nCalls str.index element-wise.\n\nParameters\n\naarray_like of str or unicode\nsubstr or unicode\nstart, endint, optional\n\n\nReturns\n\noutndarrayOutput array of ints.  Returns -1 if sub is not found.\n\n\n\n\n\nSee also\nfind, str.find\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "substr or unicode", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of ints.  Returns -1 if sub is not found.", "examples": []},
{"library": "numpy", "item_id": "numpy.indices", "code": "\nnumpy.indices(dimensions, dtype=&lt;class 'int'&gt;, sparse=False)[source]\u00b6", "description": "Return an array representing the indices of a grid.\nCompute an array where the subarrays contain index values 0, 1, \u2026\nvarying only along the corresponding axis.\n\nParameters\n\ndimensionssequence of intsThe shape of the grid.\n\ndtypedtype, optionalData type of the result.\n\nsparseboolean, optionalReturn a sparse representation of the grid instead of a dense\nrepresentation. Default is False.\n\nNew in version 1.17.\n\n\n\n\nReturns\n\ngridone ndarray or tuple of ndarrays\nIf sparse is False:Returns one array of grid indices,\ngrid.shape = (len(dimensions),) + tuple(dimensions).\n\nIf sparse is True:Returns a tuple of arrays, with\ngrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) with\ndimensions[i] in the ith place\n\n\n\n\n\n\n\nSee also\nmgrid, ogrid, meshgrid\n\nNotes\nThe output shape in the dense case is obtained by prepending the number\nof dimensions in front of the tuple of dimensions, i.e. if dimensions\nis a tuple (r0, ..., rN-1) of length N, the output shape is\n(N, r0, ..., rN-1).\nThe subarrays grid[k] contains the N-D array of indices along the\nk-th axis. Explicitly:\ngrid[k, i0, i1, ..., iN-1] = ik\n\n\nExamples\n&gt;&gt;&gt; grid = np.indices((2, 3))\n&gt;&gt;&gt; grid.shape\n(2, 2, 3)\n&gt;&gt;&gt; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n&gt;&gt;&gt; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n\n\nThe indices can be used as an index into an array.\n&gt;&gt;&gt; x = np.arange(20).reshape(5, 4)\n&gt;&gt;&gt; row, col = np.indices((2, 3))\n&gt;&gt;&gt; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n\n\nNote that it would be more straightforward in the above example to\nextract the required elements directly with x[:2, :3].\nIf sparse is set to true, the grid will be returned in a sparse\nrepresentation.\n&gt;&gt;&gt; i, j = np.indices((2, 3), sparse=True)\n&gt;&gt;&gt; i.shape\n(2, 1)\n&gt;&gt;&gt; j.shape\n(1, 3)\n&gt;&gt;&gt; i        # row indices\narray([[0],\n       [1]])\n&gt;&gt;&gt; j        # column indices\narray([[0, 1, 2]])\n\n\n", "parameters": ["Parameters", "dimensionssequence of ints", "dtypedtype, optional", "sparseboolean, optional", "Returns", "gridone ndarray or tuple of ndarrays", "If sparse is False:", "If sparse is True:"], "returns": "gridone ndarray or tuple of ndarraysIf sparse is False:Returns one array of grid indices,grid.shape = (len(dimensions),) + tuple(dimensions).If sparse is True:Returns a tuple of arrays, withgrid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1) withdimensions[i] in the ith place", "examples": ["; grid = np.indices((2, 3))\n; grid.shape\n(2, 2, 3)\n; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n\n", "; grid = np.indices((2, 3))\n; grid.shape\n(2, 2, 3)\n; grid[0]        # row indices\narray([[0, 0, 0],\n       [1, 1, 1]])\n; grid[1]        # column indices\narray([[0, 1, 2],\n       [0, 1, 2]])\n", "; x = np.arange(20).reshape(5, 4)\n; row, col = np.indices((2, 3))\n; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n\n", "; x = np.arange(20).reshape(5, 4)\n; row, col = np.indices((2, 3))\n; x[row, col]\narray([[0, 1, 2],\n       [4, 5, 6]])\n", "; i, j = np.indices((2, 3), sparse=True)\n; i.shape\n(2, 1)\n; j.shape\n(1, 3)\n; i        # row indices\narray([[0],\n       [1]])\n; j        # column indices\narray([[0, 1, 2]])\n\n", "; i, j = np.indices((2, 3), sparse=True)\n; i.shape\n(2, 1)\n; j.shape\n(1, 3)\n; i        # row indices\narray([[0],\n       [1]])\n; j        # column indices\narray([[0, 1, 2]])\n"]},
{"library": "numpy", "item_id": "numpy.broadcast.index", "code": "\nbroadcast.index\u00b6", "description": "current index in broadcasted result\nExamples\n&gt;&gt;&gt; x = np.array([[1], [2], [3]])\n&gt;&gt;&gt; y = np.array([4, 5, 6])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n&gt;&gt;&gt; b.index\n0\n&gt;&gt;&gt; next(b), next(b), next(b)\n((1, 4), (1, 5), (1, 6))\n&gt;&gt;&gt; b.index\n3\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([[1], [2], [3]])\n; y = np.array([4, 5, 6])\n; b = np.broadcast(x, y)\n; b.index\n0\n; next(b), next(b), next(b)\n((1, 4), (1, 5), (1, 6))\n; b.index\n3\n\n", "; x = np.array([[1], [2], [3]])\n; y = np.array([4, 5, 6])\n; b = np.broadcast(x, y)\n; b.index\n0\n; next(b), next(b), next(b)\n((1, 4), (1, 5), (1, 6))\n; b.index\n3\n"]},
{"library": "numpy", "item_id": "numpy.chararray.index", "code": "\nchararray.index(self, sub, start=0, end=None)[source]\u00b6", "description": "Like find, but raises ValueError when the substring is not found.\n\nSee also\nchar.index\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.index", "code": "\nchararray.index(self, sub, start=0, end=None)\u00b6", "description": "Like find, but raises ValueError when the substring is not found.\n\nSee also\nchar.index\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.index", "code": "\nnditer.index\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.flatiter.index", "code": "\nflatiter.index\u00b6", "description": "Current flat index into the array.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; fl = x.flat\n&gt;&gt;&gt; fl.index\n0\n&gt;&gt;&gt; next(fl)\n0\n&gt;&gt;&gt; fl.index\n1\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; fl.index\n0\n; next(fl)\n0\n; fl.index\n1\n\n", "; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; fl.index\n0\n; next(fl)\n0\n; fl.index\n1\n"]},
{"library": "numpy", "item_id": "numpy.in1d", "code": "\nnumpy.in1d(ar1, ar2, assume_unique=False, invert=False)[source]\u00b6", "description": "Test whether each element of a 1-D array is also present in a second array.\nReturns a boolean array the same length as ar1 that is True\nwhere an element of ar1 is in ar2 and False otherwise.\nWe recommend using isin instead of in1d for new code.\n\nParameters\n\nar1(M,) array_likeInput array.\n\nar2array_likeThe values against which to test each value of ar1.\n\nassume_uniquebool, optionalIf True, the input arrays are both assumed to be unique, which\ncan speed up the calculation.  Default is False.\n\ninvertbool, optionalIf True, the values in the returned array are inverted (that is,\nFalse where an element of ar1 is in ar2 and True otherwise).\nDefault is False. np.in1d(a, b, invert=True) is equivalent\nto (but is faster than) np.invert(in1d(a, b)).\n\nNew in version 1.8.0.\n\n\n\n\nReturns\n\nin1d(M,) ndarray, boolThe values ar1[in1d] are in ar2.\n\n\n\n\n\nSee also\n\nisinVersion of this function that preserves the shape of ar1.\n\nnumpy.lib.arraysetopsModule with a number of other functions for performing set operations on arrays.\n\n\n\nNotes\nin1d can be considered as an element-wise function version of the\npython keyword in, for 1-D sequences. in1d(a, b) is roughly\nequivalent to np.array([item in b for item in a]).\nHowever, this idea fails if ar2 is a set, or similar (non-sequence)\ncontainer:  As ar2 is converted to an array, in those cases\nasarray(ar2) is an object array rather than the expected array of\ncontained values.\n\nNew in version 1.4.0.\n\nExamples\n&gt;&gt;&gt; test = np.array([0, 1, 2, 5, 0])\n&gt;&gt;&gt; states = [0, 2]\n&gt;&gt;&gt; mask = np.in1d(test, states)\n&gt;&gt;&gt; mask\narray([ True, False,  True, False,  True])\n&gt;&gt;&gt; test[mask]\narray([0, 2, 0])\n&gt;&gt;&gt; mask = np.in1d(test, states, invert=True)\n&gt;&gt;&gt; mask\narray([False,  True, False,  True, False])\n&gt;&gt;&gt; test[mask]\narray([1, 5])\n\n\n", "parameters": ["Parameters", "ar1(M,) array_like", "ar2array_like", "assume_uniquebool, optional", "invertbool, optional", "Returns", "in1d(M,) ndarray, bool"], "returns": "in1d(M,) ndarray, boolThe values ar1[in1d] are in ar2.", "examples": ["; test = np.array([0, 1, 2, 5, 0])\n; states = [0, 2]\n; mask = np.in1d(test, states)\n; mask\narray([ True, False,  True, False,  True])\n; test[mask]\narray([0, 2, 0])\n; mask = np.in1d(test, states, invert=True)\n; mask\narray([False,  True, False,  True, False])\n; test[mask]\narray([1, 5])\n\n", "; test = np.array([0, 1, 2, 5, 0])\n; states = [0, 2]\n; mask = np.in1d(test, states)\n; mask\narray([ True, False,  True, False,  True])\n; test[mask]\narray([0, 2, 0])\n; mask = np.in1d(test, states, invert=True)\n; mask\narray([False,  True, False,  True, False])\n; test[mask]\narray([1, 5])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.imag", "code": "\nndarray.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.memmap.imag", "code": "\nmemmap.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.matrix.imag", "code": "\nmatrix.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.imag", "code": "\nMaskType.imag\u00b6", "description": "imaginary part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.imag", "code": "\ngeneric.imag\u00b6", "description": "imaginary part of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.imag", "code": "\nchararray.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.imag", "code": "\nchararray.imag\u00b6", "description": "The imaginary part of the array.\nExamples\n&gt;&gt;&gt; x = np.sqrt([1+0j, 0+1j])\n&gt;&gt;&gt; x.imag\narray([ 0.        ,  0.70710678])\n&gt;&gt;&gt; x.imag.dtype\ndtype('float64')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n\n", "; x = np.sqrt([1+0j, 0+1j])\n; x.imag\narray([ 0.        ,  0.70710678])\n; x.imag.dtype\ndtype('float64')\n"]},
{"library": "numpy", "item_id": "numpy.iinfo", "code": "\nclass numpy.iinfo(type)[source]\u00b6", "description": "Machine limits for integer types.\n\nParameters\n\nint_typeinteger type, dtype, or instanceThe kind of integer data type to get information about.\n\n\n\n\n\nSee also\n\nfinfoThe equivalent for floating point data types.\n\n\n\nExamples\nWith types:\n&gt;&gt;&gt; ii16 = np.iinfo(np.int16)\n&gt;&gt;&gt; ii16.min\n-32768\n&gt;&gt;&gt; ii16.max\n32767\n&gt;&gt;&gt; ii32 = np.iinfo(np.int32)\n&gt;&gt;&gt; ii32.min\n-2147483648\n&gt;&gt;&gt; ii32.max\n2147483647\n\n\nWith instances:\n&gt;&gt;&gt; ii32 = np.iinfo(np.int32(10))\n&gt;&gt;&gt; ii32.min\n-2147483648\n&gt;&gt;&gt; ii32.max\n2147483647\n\n\n\nAttributes\n\nbitsintThe number of bits occupied by the type.\n\nminintMinimum value of given dtype.\n\nmaxintMaximum value of given dtype.\n\n\n\n\n", "parameters": ["Parameters", "int_typeinteger type, dtype, or instance", "Attributes", "bitsint", "minint", "maxint"], "returns": [], "examples": ["; ii16 = np.iinfo(np.int16)\n; ii16.min\n-32768\n; ii16.max\n32767\n; ii32 = np.iinfo(np.int32)\n; ii32.min\n-2147483648\n; ii32.max\n2147483647\n\n", "; ii16 = np.iinfo(np.int16)\n; ii16.min\n-32768\n; ii16.max\n32767\n; ii32 = np.iinfo(np.int32)\n; ii32.min\n-2147483648\n; ii32.max\n2147483647\n", "; ii32 = np.iinfo(np.int32(10))\n; ii32.min\n-2147483648\n; ii32.max\n2147483647\n\n", "; ii32 = np.iinfo(np.int32(10))\n; ii32.min\n-2147483648\n; ii32.max\n2147483647\n"]},
{"library": "numpy", "item_id": "numpy.fft.ihfft", "code": "\nnumpy.fft.ihfft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the inverse FFT of a signal that has Hermitian symmetry.\n\nParameters\n\naarray_likeInput array.\n\nnint, optionalLength of the inverse FFT, the number of points along\ntransformation axis in the input to use.  If n is smaller than\nthe length of the input, the input is cropped.  If it is larger,\nthe input is padded with zeros. If n is not given, the length of\nthe input along the axis specified by axis is used.\n\naxisint, optionalAxis over which to compute the inverse FFT. If not given, the last\naxis is used.\n\nnorm{None, \u201cortho\u201d}, optionalNormalization mode (see numpy.fft). Default is None.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\nThe length of the transformed axis is n//2 + 1.\n\n\n\n\n\nSee also\nhfft, irfft\n\nNotes\nhfft/ihfft are a pair analogous to rfft/irfft, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it\u2019s hfft for\nwhich you must supply the length of the result if it is to be odd:\n\neven: ihfft(hfft(a, 2*len(a) - 2) == a, within roundoff error,\nodd: ihfft(hfft(a, 2*len(a) - 1) == a, within roundoff error.\n\nExamples\n&gt;&gt;&gt; spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n&gt;&gt;&gt; np.fft.ifft(spectrum)\narray([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary\n&gt;&gt;&gt; np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n//2 + 1.", "examples": ["; spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n; np.fft.ifft(spectrum)\narray([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary\n; np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary\n\n", "; spectrum = np.array([ 15, -4, 0, -1, 0, -4])\n; np.fft.ifft(spectrum)\narray([1.+0.j,  2.+0.j,  3.+0.j,  4.+0.j,  3.+0.j,  2.+0.j]) # may vary\n; np.fft.ihfft(spectrum)\narray([ 1.-0.j,  2.-0.j,  3.-0.j,  4.-0.j]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.fft.ifftshift", "code": "\nnumpy.fft.ifftshift(x, axes=None)[source]\u00b6", "description": "The inverse of fftshift. Although identical for even-length x, the\nfunctions differ by one sample for odd-length x.\n\nParameters\n\nxarray_likeInput array.\n\naxesint or shape tuple, optionalAxes over which to calculate.  Defaults to None, which shifts all axes.\n\n\n\nReturns\n\nyndarrayThe shifted array.\n\n\n\n\n\nSee also\n\nfftshiftShift zero-frequency component to the center of the spectrum.\n\n\n\nExamples\n&gt;&gt;&gt; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n&gt;&gt;&gt; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n&gt;&gt;&gt; np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n\n\n", "parameters": ["Parameters", "xarray_like", "axesint or shape tuple, optional", "Returns", "yndarray"], "returns": "yndarrayThe shifted array.", "examples": ["; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n; np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n\n", "; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n; np.fft.ifftshift(np.fft.fftshift(freqs))\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n"]},
{"library": "numpy", "item_id": "numpy.fft.ifft2", "code": "\nnumpy.fft.ifft2(a, s=None, axes=(-2, -1), norm=None)[source]\u00b6", "description": "Compute the 2-dimensional inverse discrete Fourier Transform.\nThis function computes the inverse of the 2-dimensional discrete Fourier\nTransform over any number of axes in an M-dimensional array by means of\nthe Fast Fourier Transform (FFT).  In other words, ifft2(fft2(a)) == a\nto within numerical accuracy.  By default, the inverse transform is\ncomputed over the last two axes of the input array.\nThe input, analogously to ifft, should be ordered in the same way as is\nreturned by fft2, i.e. it should have the term for zero frequency\nin the low-order corner of the two axes, the positive frequency terms in\nthe first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nboth axes, in order of decreasingly negative frequency.\n\nParameters\n\naarray_likeInput array, can be complex.\n\nssequence of ints, optionalShape (length of each axis) of the output (s[0] refers to axis 0,\ns[1] to axis 1, etc.).  This corresponds to n for ifft(x, n).\nAlong each axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nif s is not given, the shape of the input along the axes specified\nby axes is used.  See notes for issue on ifft zero padding.\n\naxessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two\naxes are used.  A repeated index in axes means the transform over\nthat axis is performed multiple times.  A one-element sequence means\nthat a one-dimensional FFT is performed.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or the last two axes if axes is not given.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length, or axes not given and\nlen(s) != 2.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nnumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.\n\nfft2The forward 2-dimensional FFT, of which ifft2 is the inverse.\n\nifftnThe inverse of the n-dimensional FFT.\n\nfftThe one-dimensional FFT.\n\nifftThe one-dimensional inverse FFT.\n\n\n\nNotes\nifft2 is just ifftn with a different default for axes.\nSee ifftn for details and a plotting example, and numpy.fft for\ndefinition and conventions used.\nZero-padding, analogously with ifft, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed before ifft2 is called.\nExamples\n&gt;&gt;&gt; a = 4 * np.eye(4)\n&gt;&gt;&gt; np.fft.ifft2(a)\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "ValueError", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or the last two axes if axes is not given.", "examples": ["; a = 4 * np.eye(4)\n; np.fft.ifft2(a)\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])\n\n", "; a = 4 * np.eye(4)\n; np.fft.ifft2(a)\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j]])\n"]},
{"library": "numpy", "item_id": "numpy.fft.ifft", "code": "\nnumpy.fft.ifft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the one-dimensional inverse discrete Fourier Transform.\nThis function computes the inverse of the one-dimensional n-point\ndiscrete Fourier transform computed by fft.  In other words,\nifft(fft(a)) == a to within numerical accuracy.\nFor a general description of the algorithm and definitions,\nsee numpy.fft.\nThe input should be ordered in the same way as is returned by fft,\ni.e.,\n\na[0] should contain the zero frequency term,\na[1:n//2] should contain the positive-frequency terms,\na[n//2 + 1:] should contain the negative-frequency terms, in\nincreasing order starting from the most negative frequency.\n\nFor an even number of input points, A[n//2] represents the sum of\nthe values at the positive and negative Nyquist frequencies, as the two\nare aliased together. See numpy.fft for details.\n\nParameters\n\naarray_likeInput array, can be complex.\n\nnint, optionalLength of the transformed axis of the output.\nIf n is smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros.  If n is not given,\nthe length of the input along the axis specified by axis is used.\nSee notes about padding issues.\n\naxisint, optionalAxis over which to compute the inverse DFT.  If not given, the last\naxis is used.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\n\n\n\nRaises\n\nIndexErrorIf axes is larger than the last axis of a.\n\n\n\n\n\nSee also\n\nnumpy.fftAn introduction, with definitions and general explanations.\n\nfftThe one-dimensional (forward) FFT, of which ifft is the inverse\n\nifft2The two-dimensional inverse FFT.\n\nifftnThe n-dimensional inverse FFT.\n\n\n\nNotes\nIf the input parameter n is larger than the size of the input, the input\nis padded by appending zeros at the end.  Even though this is the common\napproach, it might lead to surprising results.  If a different padding is\ndesired, it must be performed before calling ifft.\nExamples\n&gt;&gt;&gt; np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary\n\n\nCreate and plot a band-limited signal with random phases:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; t = np.arange(400)\n&gt;&gt;&gt; n = np.zeros((400,), dtype=complex)\n&gt;&gt;&gt; n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))\n&gt;&gt;&gt; s = np.fft.ifft(n)\n&gt;&gt;&gt; plt.plot(t, s.real, 'b-', t, s.imag, 'r--')\n[&lt;matplotlib.lines.Line2D object at ...&gt;, &lt;matplotlib.lines.Line2D object at ...&gt;]\n&gt;&gt;&gt; plt.legend(('real', 'imaginary'))\n&lt;matplotlib.legend.Legend object at ...&gt;\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.", "examples": ["; np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary\n\n", "; np.fft.ifft([0, 4, 0, 0])\narray([ 1.+0.j,  0.+1.j, -1.+0.j,  0.-1.j]) # may vary\n", "; import matplotlib.pyplot as plt\n; t = np.arange(400)\n; n = np.zeros((400,), dtype=complex)\n; n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))\n; s = np.fft.ifft(n)\n; plt.plot(t, s.real, 'b-', t, s.imag, 'r--')\n[&lt;matplotlib.lines.Line2D object at ...&gt;, &lt;matplotlib.lines.Line2D object at ...&gt;]\n; plt.legend(('real', 'imaginary'))\n&lt;matplotlib.legend.Legend object at ...&gt;\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; t = np.arange(400)\n; n = np.zeros((400,), dtype=complex)\n; n[40:60] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20,)))\n; s = np.fft.ifft(n)\n; plt.plot(t, s.real, 'b-', t, s.imag, 'r--')\n[&lt;matplotlib.lines.Line2D object at ...&gt;, &lt;matplotlib.lines.Line2D object at ...&gt;]\n; plt.legend(('real', 'imaginary'))\n&lt;matplotlib.legend.Legend object at ...&gt;\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.fft.ifftn", "code": "\nnumpy.fft.ifftn(a, s=None, axes=None, norm=None)[source]\u00b6", "description": "Compute the N-dimensional inverse discrete Fourier Transform.\nThis function computes the inverse of the N-dimensional discrete\nFourier Transform over any number of axes in an M-dimensional array by\nmeans of the Fast Fourier Transform (FFT).  In other words,\nifftn(fftn(a)) == a to within numerical accuracy.\nFor a description of the definitions and conventions used, see numpy.fft.\nThe input, analogously to ifft, should be ordered in the same way as is\nreturned by fftn, i.e. it should have the term for zero frequency\nin all axes in the low-order corner, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.\n\nParameters\n\naarray_likeInput array, can be complex.\n\nssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0] refers to axis 0, s[1] to axis 1, etc.).\nThis corresponds to n for ifft(x, n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nif s is not given, the shape of the input along the axes specified\nby axes is used.  See notes for issue on ifft zero padding.\n\naxessequence of ints, optionalAxes over which to compute the IFFT.  If not given, the last len(s)\naxes are used, or all axes if s is also not specified.\nRepeated indices in axes means that the inverse transform over that\naxis is performed multiple times.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or by a combination of s or a,\nas explained in the parameters section above.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nnumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.\n\nfftnThe forward n-dimensional FFT, of which ifftn is the inverse.\n\nifftThe one-dimensional inverse FFT.\n\nifft2The two-dimensional inverse FFT.\n\nifftshiftUndoes fftshift, shifts zero-frequency terms to beginning of array.\n\n\n\nNotes\nSee numpy.fft for definitions and conventions used.\nZero-padding, analogously with ifft, is performed by appending zeros to\nthe input along the specified dimension.  Although this is the common\napproach, it might lead to surprising results.  If another form of zero\npadding is desired, it must be performed before ifftn is called.\nExamples\n&gt;&gt;&gt; a = np.eye(4)\n&gt;&gt;&gt; np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n\n\nCreate and plot an image with band-limited frequency content:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; n = np.zeros((200,200), dtype=complex)\n&gt;&gt;&gt; n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))\n&gt;&gt;&gt; im = np.fft.ifftn(n).real\n&gt;&gt;&gt; plt.imshow(im)\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "ValueError", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s or a,as explained in the parameters section above.", "examples": ["; a = np.eye(4)\n; np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n\n", "; a = np.eye(4)\n; np.fft.ifftn(np.fft.fftn(a, axes=(0,)), axes=(1,))\narray([[1.+0.j,  0.+0.j,  0.+0.j,  0.+0.j], # may vary\n       [0.+0.j,  1.+0.j,  0.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  1.+0.j,  0.+0.j],\n       [0.+0.j,  0.+0.j,  0.+0.j,  1.+0.j]])\n", "; import matplotlib.pyplot as plt\n; n = np.zeros((200,200), dtype=complex)\n; n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))\n; im = np.fft.ifftn(n).real\n; plt.imshow(im)\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; n = np.zeros((200,200), dtype=complex)\n; n[60:80, 20:40] = np.exp(1j*np.random.uniform(0, 2*np.pi, (20, 20)))\n; im = np.fft.ifftn(n).real\n; plt.imshow(im)\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.ids", "code": "\nMaskedArray.ids(self)[source]\u00b6", "description": "Return the addresses of the data and mask areas.\n\nParameters\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n&gt;&gt;&gt; x.ids()\n(166670640, 166659832) # may vary\n\n\nIf the array has no mask, the address of nomask is returned. This address\nis typically not close to the data in memory:\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3])\n&gt;&gt;&gt; x.ids()\n(166691080, 3083169284L) # may vary\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": ["; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n; x.ids()\n(166670640, 166659832) # may vary\n\n", "; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n; x.ids()\n(166670640, 166659832) # may vary\n", "; x = np.ma.array([1, 2, 3])\n; x.ids()\n(166691080, 3083169284L) # may vary\n\n", "; x = np.ma.array([1, 2, 3])\n; x.ids()\n(166691080, 3083169284L) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.identity", "code": "\nclassmethod Polynomial.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.ids", "code": "\nmasked_array.ids(self)[source]\u00b6", "description": "Return the addresses of the data and mask areas.\n\nParameters\n\nNone\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n&gt;&gt;&gt; x.ids()\n(166670640, 166659832) # may vary\n\n\nIf the array has no mask, the address of nomask is returned. This address\nis typically not close to the data in memory:\n&gt;&gt;&gt; x = np.ma.array([1, 2, 3])\n&gt;&gt;&gt; x.ids()\n(166691080, 3083169284L) # may vary\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": ["; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n; x.ids()\n(166670640, 166659832) # may vary\n\n", "; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])\n; x.ids()\n(166670640, 166659832) # may vary\n", "; x = np.ma.array([1, 2, 3])\n; x.ids()\n(166691080, 3083169284L) # may vary\n\n", "; x = np.ma.array([1, 2, 3])\n; x.ids()\n(166691080, 3083169284L) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.identity", "code": "\nclassmethod Legendre.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.identity", "code": "\nclassmethod Laguerre.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.identity", "code": "\nclassmethod HermiteE.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.identity", "code": "\nclassmethod Hermite.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.identity", "code": "\nclassmethod Chebyshev.identity(domain=None, window=None)[source]\u00b6", "description": "Identity function.\nIf p is the returned series, then p(x) == x for all\nvalues of x.\n\nParameters\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries of representing the identity.\n\n\n\n\n", "parameters": ["Parameters", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries of representing the identity.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.identity", "code": "\nnumpy.ma.identity(n, dtype=None) = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return the identity array.\nThe identity array is a square array with ones on\nthe main diagonal.\n\nParameters\n\nnintNumber of rows (and columns) in n x n output.\n\ndtypedata-type, optionalData-type of the output.  Defaults to float.\n\n\n\nReturns\n\noutndarrayn x n array with its main diagonal set to one,\nand all other elements 0.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "nint", "dtypedata-type, optional", "Returns", "outndarray"], "returns": "outndarrayn x n array with its main diagonal set to one,and all other elements 0.", "examples": ["; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.i0", "code": "\nnumpy.i0(x)[source]\u00b6", "description": "Modified Bessel function of the first kind, order 0.\nUsually denoted .  This function does broadcast, but will not\n\u201cup-cast\u201d int dtype arguments unless accompanied by at least one float or\ncomplex dtype argument (see Raises below).\n\nParameters\n\nxarray_like, dtype float or complexArgument of the Bessel function.\n\n\n\nReturns\n\noutndarray, shape = x.shape, dtype = x.dtypeThe modified Bessel function evaluated at each of the elements of x.\n\n\n\nRaises\n\nTypeError: array cannot be safely cast to required typeIf argument consists exclusively of int dtypes.\n\n\n\n\n\nSee also\nscipy.special.i0, scipy.special.iv, scipy.special.ive\n\nNotes\nThe scipy implementation is recommended over this function: it is a\nproper ufunc written in C, and more than an order of magnitude faster.\nWe use the algorithm published by Clenshaw [1] and referenced by\nAbramowitz and Stegun [2], for which the function domain is\npartitioned into the two intervals [0,8] and (8,inf), and Chebyshev\npolynomial expansions are employed in each interval. Relative error on\nthe domain [0,30] using IEEE arithmetic is documented [3] as having a\npeak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).\nReferences\n\n1\nC. W. Clenshaw, \u201cChebyshev series for mathematical functions\u201d, in\nNational Physical Laboratory Mathematical Tables, vol. 5, London:\nHer Majesty\u2019s Stationery Office, 1962.\n\n2\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical\nFunctions, 10th printing, New York: Dover, 1964, pp. 379.\nhttp://www.math.sfu.ca/~cbm/aands/page_379.htm\n\n3\nhttp://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html\n\n\nExamples\n&gt;&gt;&gt; np.i0(0.)\narray(1.0)  # may vary\n&gt;&gt;&gt; np.i0([0., 1. + 2j])\narray([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary\n\n\n", "parameters": ["Parameters", "xarray_like, dtype float or complex", "Returns", "outndarray, shape = x.shape, dtype = x.dtype", "Raises", "TypeError: array cannot be safely cast to required type"], "returns": "outndarray, shape = x.shape, dtype = x.dtypeThe modified Bessel function evaluated at each of the elements of x.", "examples": ["; np.i0(0.)\narray(1.0)  # may vary\n; np.i0([0., 1. + 2j])\narray([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary\n\n", "; np.i0(0.)\narray(1.0)  # may vary\n; np.i0([0., 1. + 2j])\narray([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary\n"]},
{"library": "numpy", "item_id": "numpy.matlib.identity", "code": "\nnumpy.matlib.identity(n, dtype=None)[source]\u00b6", "description": "Returns the square identity matrix of given size.\n\nParameters\n\nnintSize of the returned identity matrix.\n\ndtypedata-type, optionalData-type of the output. Defaults to float.\n\n\n\nReturns\n\noutmatrixn x n matrix with its main diagonal set to one,\nand all other elements zero.\n\n\n\n\n\nSee also\n\nnumpy.identityEquivalent array function.\n\nmatlib.eyeMore general matrix identity function.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.identity(3, dtype=int)\nmatrix([[1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n\n\n", "parameters": ["Parameters", "nint", "dtypedata-type, optional", "Returns", "outmatrix"], "returns": "outmatrixn x n matrix with its main diagonal set to one,and all other elements zero.", "examples": ["; import numpy.matlib\n; np.matlib.identity(3, dtype=int)\nmatrix([[1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n\n", "; import numpy.matlib\n; np.matlib.identity(3, dtype=int)\nmatrix([[1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1]])\n"]},
{"library": "numpy", "item_id": "numpy.identity", "code": "\nnumpy.identity(n, dtype=None)[source]\u00b6", "description": "Return the identity array.\nThe identity array is a square array with ones on\nthe main diagonal.\n\nParameters\n\nnintNumber of rows (and columns) in n x n output.\n\ndtypedata-type, optionalData-type of the output.  Defaults to float.\n\n\n\nReturns\n\noutndarrayn x n array with its main diagonal set to one,\nand all other elements 0.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n\n", "parameters": ["Parameters", "nint", "dtypedata-type, optional", "Returns", "outndarray"], "returns": "outndarrayn x n array with its main diagonal set to one,and all other elements 0.", "examples": ["; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n\n", "; np.identity(3)\narray([[1.,  0.,  0.],\n       [0.,  1.,  0.],\n       [0.,  0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.I", "code": "\nproperty matrix.I\u00b6", "description": "Returns the (multiplicative) inverse of invertible self.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectIf self is non-singular, ret is such that ret * self ==\nself * ret == np.matrix(np.eye(self[0,:].size) all return\nTrue.\n\n\n\nRaises\n\nnumpy.linalg.LinAlgError: Singular matrixIf self is singular.\n\n\n\n\n\nSee also\nlinalg.inv\n\nExamples\n&gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n&gt;&gt;&gt; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n&gt;&gt;&gt; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object", "Raises", "numpy.linalg.LinAlgError: Singular matrix"], "returns": "retmatrix objectIf self is non-singular, ret is such that ret * self ==self * ret == np.matrix(np.eye(self[0,:].size) all returnTrue.", "examples": ["; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n\n", "; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.identity", "code": "\nufunc.identity\u00b6", "description": "The identity value.\nData attribute containing the identity element for the ufunc, if it has one.\nIf it does not, the attribute value is None.\nExamples\n&gt;&gt;&gt; np.add.identity\n0\n&gt;&gt;&gt; np.multiply.identity\n1\n&gt;&gt;&gt; np.power.identity\n1\n&gt;&gt;&gt; print(np.exp.identity)\nNone\n\n\n", "parameters": [], "returns": [], "examples": ["; np.add.identity\n0\n; np.multiply.identity\n1\n; np.power.identity\n1\n; print(np.exp.identity)\nNone\n\n", "; np.add.identity\n0\n; np.multiply.identity\n1\n; np.power.identity\n1\n; print(np.exp.identity)\nNone\n"]},
{"library": "numpy", "item_id": "numpy.hypot", "code": "\nnumpy.hypot(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'hypot'&gt;\u00b6", "description": "Given the \u201clegs\u201d of a right triangle, return its hypotenuse.\nEquivalent to sqrt(x1**2 + x2**2), element-wise.  If x1 or\nx2 is scalar_like (i.e., unambiguously cast-able to a scalar type),\nit is broadcast for use with each element of the other argument.\n(See Examples)\n\nParameters\n\nx1, x2array_likeLeg of the triangle(s). If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nzndarrayThe hypotenuse of the triangle(s).\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\n\nExample showing broadcast of scalar_like argument:\n&gt;&gt;&gt; np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "zndarray"], "returns": "zndarrayThe hypotenuse of the triangle(s).This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\n", "; np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3)))\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n", "; np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n\n", "; np.hypot(3*np.ones((3, 3)), [4])\narray([[ 5.,  5.,  5.],\n       [ 5.,  5.,  5.],\n       [ 5.,  5.,  5.]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.hypergeometric", "code": "\nRandomState.hypergeometric(ngood, nbad, nsample, size=None)\u00b6", "description": "Draw samples from a Hypergeometric distribution.\nSamples are drawn from a hypergeometric distribution with specified\nparameters, ngood (ways to make a good selection), nbad (ways to make\na bad selection), and nsample (number of items sampled, which is less\nthan or equal to the sum ngood + nbad).\n\nNote\nNew code should use the hypergeometric method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nngoodint or array_like of intsNumber of ways to make a good selection.  Must be nonnegative.\n\nnbadint or array_like of intsNumber of ways to make a bad selection.  Must be nonnegative.\n\nnsampleint or array_like of intsNumber of items sampled.  Must be at least 1 and at most\nngood + nbad.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if ngood, nbad, and nsample\nare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Each\nsample is the number of good items within a randomly selected subset of\nsize nsample taken from a set of ngood good items and nbad bad items.\n\n\n\n\n\nSee also\n\nscipy.stats.hypergeomprobability density function, distribution or cumulative density function, etc.\n\nGenerator.hypergeometricwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Hypergeometric distribution is\n\n\nwhere  and \nfor P(x) the probability of x good results in the drawn sample,\ng = ngood, b = nbad, and n = nsample.\nConsider an urn with black and white marbles in it, ngood of them\nare black and nbad are white. If you draw nsample balls without\nreplacement, then the hypergeometric distribution describes the\ndistribution of black balls in the drawn sample.\nNote that this distribution is very similar to the binomial\ndistribution, except that in this case, samples are drawn without\nreplacement, whereas in the Binomial case samples are drawn with\nreplacement (or the sample space is infinite). As the sample space\nbecomes large, this distribution approaches the binomial.\nReferences\n\n1\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n2\nWeisstein, Eric W. \u201cHypergeometric Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/HypergeometricDistribution.html\n\n3\nWikipedia, \u201cHypergeometric distribution\u201d,\nhttps://en.wikipedia.org/wiki/Hypergeometric_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n&gt;&gt;&gt; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n\nSuppose you have an urn with 15 white and 15 black marbles.\nIf you pull 15 marbles at random, how likely is it that\n12 or more of them are one color?\n&gt;&gt;&gt; s = np.random.hypergeometric(15, 15, 15, 100000)\n&gt;&gt;&gt; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n\n", "parameters": ["Parameters", "ngoodint or array_like of ints", "nbadint or array_like of ints", "nsampleint or array_like of ints", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.", "examples": ["; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n", "; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n", "; s = np.random.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n", "; s = np.random.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.hypergeometric", "code": "\nGenerator.hypergeometric(ngood, nbad, nsample, size=None)\u00b6", "description": "Draw samples from a Hypergeometric distribution.\nSamples are drawn from a hypergeometric distribution with specified\nparameters, ngood (ways to make a good selection), nbad (ways to make\na bad selection), and nsample (number of items sampled, which is less\nthan or equal to the sum ngood + nbad).\n\nParameters\n\nngoodint or array_like of intsNumber of ways to make a good selection.  Must be nonnegative and\nless than 10**9.\n\nnbadint or array_like of intsNumber of ways to make a bad selection.  Must be nonnegative and\nless than 10**9.\n\nnsampleint or array_like of intsNumber of items sampled.  Must be nonnegative and less than\nngood + nbad.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if ngood, nbad, and nsample\nare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Each\nsample is the number of good items within a randomly selected subset of\nsize nsample taken from a set of ngood good items and nbad bad items.\n\n\n\n\n\nSee also\n\nmultivariate_hypergeometricDraw samples from the multivariate hypergeometric distribution.\n\nscipy.stats.hypergeomprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Hypergeometric distribution is\n\n\nwhere  and \nfor P(x) the probability of x good results in the drawn sample,\ng = ngood, b = nbad, and n = nsample.\nConsider an urn with black and white marbles in it, ngood of them\nare black and nbad are white. If you draw nsample balls without\nreplacement, then the hypergeometric distribution describes the\ndistribution of black balls in the drawn sample.\nNote that this distribution is very similar to the binomial\ndistribution, except that in this case, samples are drawn without\nreplacement, whereas in the Binomial case samples are drawn with\nreplacement (or the sample space is infinite). As the sample space\nbecomes large, this distribution approaches the binomial.\nThe arguments ngood and nbad each must be less than 10**9. For\nextremely large arguments, the algorithm that is used to compute the\nsamples [4] breaks down because of loss of precision in floating point\ncalculations.  For such large values, if nsample is not also large,\nthe distribution can be approximated with the binomial distribution,\nbinomial(n=nsample, p=ngood/(ngood + nbad)).\nReferences\n\n1\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n2\nWeisstein, Eric W. \u201cHypergeometric Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/HypergeometricDistribution.html\n\n3\nWikipedia, \u201cHypergeometric distribution\u201d,\nhttps://en.wikipedia.org/wiki/Hypergeometric_distribution\n\n4\nStadlober, Ernst, \u201cThe ratio of uniforms approach for generating\ndiscrete random variates\u201d, Journal of Computational and Applied\nMathematics, 31, pp. 181-189 (1990).\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n&gt;&gt;&gt; s = rng.hypergeometric(ngood, nbad, nsamp, 1000)\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n\nSuppose you have an urn with 15 white and 15 black marbles.\nIf you pull 15 marbles at random, how likely is it that\n12 or more of them are one color?\n&gt;&gt;&gt; s = rng.hypergeometric(15, 15, 15, 100000)\n&gt;&gt;&gt; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n\n", "parameters": ["Parameters", "ngoodint or array_like of ints", "nbadint or array_like of ints", "nsampleint or array_like of ints", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.", "examples": ["; rng = np.random.default_rng()\n; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = rng.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n", "; rng = np.random.default_rng()\n; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = rng.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n", "; s = rng.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n", "; s = rng.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n"]},
{"library": "numpy", "item_id": "numpy.hstack", "code": "\nnumpy.hstack(tup)[source]\u00b6", "description": "Stack arrays in sequence horizontally (column wise).\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby hsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\nParameters\n\ntupsequence of ndarraysThe arrays must have the same shape along all but the second axis,\nexcept 1-D arrays which can be any length.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nvstackStack arrays in sequence vertically (row wise).\n\ndstackStack arrays in sequence depth wise (along third axis).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nhsplitSplit array along second axis.\n\nblockAssemble arrays from blocks.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n&gt;&gt;&gt; a = np.array([[1],[2],[3]])\n&gt;&gt;&gt; b = np.array([[2],[3],[4]])\n&gt;&gt;&gt; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "tupsequence of ndarrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.hstack", "code": "\nnumpy.ma.hstack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nStack arrays in sequence horizontally (column wise).\nThis is equivalent to concatenation along the second axis, except for 1-D\narrays where it concatenates along the first axis. Rebuilds arrays divided\nby hsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\n\nParameters\n\ntupsequence of ndarraysThe arrays must have the same shape along all but the second axis,\nexcept 1-D arrays which can be any length.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nvstackStack arrays in sequence vertically (row wise).\n\ndstackStack arrays in sequence depth wise (along third axis).\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\nhsplitSplit array along second axis.\n\nblockAssemble arrays from blocks.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n&gt;&gt;&gt; a = np.array([[1],[2],[3]])\n&gt;&gt;&gt; b = np.array([[2],[3],[4]])\n&gt;&gt;&gt; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "tupsequence of ndarrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.hstack((a,b))\narray([1, 2, 3, 2, 3, 4])\n; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.hstack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.hsplit", "code": "\nnumpy.hsplit(ary, indices_or_sections)[source]\u00b6", "description": "Split an array into multiple sub-arrays horizontally (column-wise).\nPlease refer to the split documentation.  hsplit is equivalent\nto split with axis=1, the array is always split along the second\naxis regardless of the array dimension.\n\nSee also\n\nsplitSplit an array into multiple sub-arrays of equal size.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)\n&gt;&gt;&gt; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n&gt;&gt;&gt; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n&gt;&gt;&gt; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\n\nWith a higher dimensional array the split is still along the second axis.\n&gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)\n&gt;&gt;&gt; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n&gt;&gt;&gt; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\n", "; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n"]},
{"library": "numpy", "item_id": "numpy.ma.hsplit", "code": "\nnumpy.ma.hsplit(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_single object&gt;\u00b6", "description": "\nSplit an array into multiple sub-arrays horizontally (column-wise).\nPlease refer to the split documentation.  hsplit is equivalent\nto split with axis=1, the array is always split along the second\naxis regardless of the array dimension.\n\n\nSee also\n\nsplitSplit an array into multiple sub-arrays of equal size.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; x = np.arange(16.0).reshape(4, 4)\n&gt;&gt;&gt; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n&gt;&gt;&gt; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n&gt;&gt;&gt; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\n\nWith a higher dimensional array the split is still along the second axis.\n&gt;&gt;&gt; x = np.arange(8.0).reshape(2, 2, 2)\n&gt;&gt;&gt; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n&gt;&gt;&gt; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n\n", "; x = np.arange(16.0).reshape(4, 4)\n; x\narray([[ 0.,   1.,   2.,   3.],\n       [ 4.,   5.,   6.,   7.],\n       [ 8.,   9.,  10.,  11.],\n       [12.,  13.,  14.,  15.]])\n; np.hsplit(x, 2)\n[array([[  0.,   1.],\n       [  4.,   5.],\n       [  8.,   9.],\n       [12.,  13.]]),\n array([[  2.,   3.],\n       [  6.,   7.],\n       [10.,  11.],\n       [14.,  15.]])]\n; np.hsplit(x, np.array([3, 6]))\n[array([[ 0.,   1.,   2.],\n       [ 4.,   5.,   6.],\n       [ 8.,   9.,  10.],\n       [12.,  13.,  14.]]),\n array([[ 3.],\n       [ 7.],\n       [11.],\n       [15.]]),\n array([], shape=(4, 0), dtype=float64)]\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n\n", "; x = np.arange(8.0).reshape(2, 2, 2)\n; x\narray([[[0.,  1.],\n        [2.,  3.]],\n       [[4.,  5.],\n        [6.,  7.]]])\n; np.hsplit(x, 2)\n[array([[[0.,  1.]],\n       [[4.,  5.]]]),\n array([[[2.,  3.]],\n       [[6.,  7.]]])]\n"]},
{"library": "numpy", "item_id": "numpy.busdaycalendar.holidays", "code": "\nbusdaycalendar.holidays\u00b6", "description": "A copy of the holiday array indicating additional invalid days.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.hypergeometric", "code": "\nnumpy.random.hypergeometric(ngood, nbad, nsample, size=None)\u00b6", "description": "Draw samples from a Hypergeometric distribution.\nSamples are drawn from a hypergeometric distribution with specified\nparameters, ngood (ways to make a good selection), nbad (ways to make\na bad selection), and nsample (number of items sampled, which is less\nthan or equal to the sum ngood + nbad).\n\nNote\nNew code should use the hypergeometric method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nngoodint or array_like of intsNumber of ways to make a good selection.  Must be nonnegative.\n\nnbadint or array_like of intsNumber of ways to make a bad selection.  Must be nonnegative.\n\nnsampleint or array_like of intsNumber of items sampled.  Must be at least 1 and at most\nngood + nbad.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if ngood, nbad, and nsample\nare all scalars.  Otherwise, np.broadcast(ngood, nbad, nsample).size\nsamples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Each\nsample is the number of good items within a randomly selected subset of\nsize nsample taken from a set of ngood good items and nbad bad items.\n\n\n\n\n\nSee also\n\nscipy.stats.hypergeomprobability density function, distribution or cumulative density function, etc.\n\nGenerator.hypergeometricwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Hypergeometric distribution is\n\n\nwhere  and \nfor P(x) the probability of x good results in the drawn sample,\ng = ngood, b = nbad, and n = nsample.\nConsider an urn with black and white marbles in it, ngood of them\nare black and nbad are white. If you draw nsample balls without\nreplacement, then the hypergeometric distribution describes the\ndistribution of black balls in the drawn sample.\nNote that this distribution is very similar to the binomial\ndistribution, except that in this case, samples are drawn without\nreplacement, whereas in the Binomial case samples are drawn with\nreplacement (or the sample space is infinite). As the sample space\nbecomes large, this distribution approaches the binomial.\nReferences\n\n1\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n2\nWeisstein, Eric W. \u201cHypergeometric Distribution.\u201d From\nMathWorld\u2013A Wolfram Web Resource.\nhttp://mathworld.wolfram.com/HypergeometricDistribution.html\n\n3\nWikipedia, \u201cHypergeometric distribution\u201d,\nhttps://en.wikipedia.org/wiki/Hypergeometric_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n&gt;&gt;&gt; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n&gt;&gt;&gt; from matplotlib.pyplot import hist\n&gt;&gt;&gt; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n\nSuppose you have an urn with 15 white and 15 black marbles.\nIf you pull 15 marbles at random, how likely is it that\n12 or more of them are one color?\n&gt;&gt;&gt; s = np.random.hypergeometric(15, 15, 15, 100000)\n&gt;&gt;&gt; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n\n", "parameters": ["Parameters", "ngoodint or array_like of ints", "nbadint or array_like of ints", "nsampleint or array_like of ints", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized hypergeometric distribution. Eachsample is the number of good items within a randomly selected subset ofsize nsample taken from a set of ngood good items and nbad bad items.", "examples": ["; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n\n", "; ngood, nbad, nsamp = 100, 2, 10\n# number of good, number of bad, and number of samples\n; s = np.random.hypergeometric(ngood, nbad, nsamp, 1000)\n; from matplotlib.pyplot import hist\n; hist(s)\n#   note that it is very unlikely to grab both bad items\n", "; s = np.random.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n\n", "; s = np.random.hypergeometric(15, 15, 15, 100000)\n; sum(s&gt;=12)/100000. + sum(s&lt;=3)/100000.\n#   answer = 0.003 ... pretty unlikely!\n"]},
{"library": "numpy", "item_id": "numpy.histogramdd", "code": "\nnumpy.histogramdd(sample, bins=10, range=None, normed=None, weights=None, density=None)[source]\u00b6", "description": "Compute the multidimensional histogram of some data.\n\nParameters\n\nsample(N, D) array, or (D, N) array_likeThe data to be histogrammed.\nNote the unusual interpretation of sample when an array_like:\n\nWhen an array, each row is a coordinate in a D-dimensional space -\nsuch as histogramgramdd(np.array([p1, p2, p3])).\nWhen an array_like, each element is the list of values for single\ncoordinate - such as histogramgramdd((X, Y, Z)).\n\nThe first form should be preferred.\n\nbinssequence or int, optionalThe bin specification:\n\nA sequence of arrays describing the monotonically increasing bin\nedges along each dimension.\nThe number of bins for each dimension (nx, ny, \u2026 =bins)\nThe number of bins for all dimensions (nx=ny=\u2026=bins).\n\n\nrangesequence, optionalA sequence of length D, each an optional (lower, upper) tuple giving\nthe outer bin edges to be used if the edges are not given explicitly in\nbins.\nAn entry of None in the sequence results in the minimum and maximum\nvalues being used for the corresponding dimension.\nThe default, None, is equivalent to passing a tuple of D None values.\n\ndensitybool, optionalIf False, the default, returns the number of samples in each bin.\nIf True, returns the probability density function at the bin,\nbin_count / sample_count / bin_volume.\n\nnormedbool, optionalAn alias for the density argument that behaves identically. To avoid\nconfusion with the broken normed argument to histogram, density\nshould be preferred.\n\nweights(N,) array_like, optionalAn array of values w_i weighing each sample (x_i, y_i, z_i, \u2026).\nWeights are normalized to 1 if normed is True. If normed is False,\nthe values of the returned histogram are equal to the sum of the\nweights belonging to the samples falling into each bin.\n\n\n\nReturns\n\nHndarrayThe multidimensional histogram of sample x. See normed and weights\nfor the different possible semantics.\n\nedgeslistA list of D arrays describing the bin edges for each dimension.\n\n\n\n\n\nSee also\n\nhistogram1-D histogram\n\nhistogram2d2-D histogram\n\n\n\nExamples\n&gt;&gt;&gt; r = np.random.randn(100,3)\n&gt;&gt;&gt; H, edges = np.histogramdd(r, bins = (5, 8, 4))\n&gt;&gt;&gt; H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)\n\n\n", "parameters": ["Parameters", "sample(N, D) array, or (D, N) array_like", "binssequence or int, optional", "rangesequence, optional", "densitybool, optional", "normedbool, optional", "weights(N,) array_like, optional", "Returns", "Hndarray", "edgeslist"], "returns": "HndarrayThe multidimensional histogram of sample x. See normed and weightsfor the different possible semantics.edgeslistA list of D arrays describing the bin edges for each dimension.", "examples": ["; r = np.random.randn(100,3)\n; H, edges = np.histogramdd(r, bins = (5, 8, 4))\n; H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)\n\n", "; r = np.random.randn(100,3)\n; H, edges = np.histogramdd(r, bins = (5, 8, 4))\n; H.shape, edges[0].size, edges[1].size, edges[2].size\n((5, 8, 4), 6, 9, 5)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermx", "code": "\nnumpy.polynomial.hermite.hermx = array([0. , 0.5])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.histogram_bin_edges", "code": "\nnumpy.histogram_bin_edges(a, bins=10, range=None, weights=None)[source]\u00b6", "description": "Function to calculate only the edges of the bins used by the histogram\nfunction.\n\nParameters\n\naarray_likeInput data. The histogram is computed over the flattened array.\n\nbinsint or sequence of scalars or str, optionalIf bins is an int, it defines the number of equal-width\nbins in the given range (10, by default). If bins is a\nsequence, it defines the bin edges, including the rightmost\nedge, allowing for non-uniform bin widths.\nIf bins is a string from the list below, histogram_bin_edges will use\nthe method chosen to calculate the optimal bin width and\nconsequently the number of bins (see Notes for more detail on\nthe estimators) from the data that falls within the requested\nrange. While the bin width will be optimal for the actual data\nin the range, the number of bins will be computed to fill the\nentire range, including the empty portions. For visualisation,\nusing the \u2018auto\u2019 option is suggested. Weighted data is not\nsupported for automated bin size selection.\n\n\u2018auto\u2019Maximum of the \u2018sturges\u2019 and \u2018fd\u2019 estimators. Provides good\nall around performance.\n\n\u2018fd\u2019 (Freedman Diaconis Estimator)Robust (resilient to outliers) estimator that takes into\naccount data variability and data size.\n\n\u2018doane\u2019An improved version of Sturges\u2019 estimator that works better\nwith non-normal datasets.\n\n\u2018scott\u2019Less robust estimator that that takes into account data\nvariability and data size.\n\n\u2018stone\u2019Estimator based on leave-one-out cross-validation estimate of\nthe integrated squared error. Can be regarded as a generalization\nof Scott\u2019s rule.\n\n\u2018rice\u2019Estimator does not take variability into account, only data\nsize. Commonly overestimates number of bins required.\n\n\u2018sturges\u2019R\u2019s default method, only accounts for data size. Only\noptimal for gaussian data and underestimates number of bins\nfor large non-gaussian datasets.\n\n\u2018sqrt\u2019Square root (of data size) estimator, used by Excel and\nother programs for its speed and simplicity.\n\n\n\nrange(float, float), optionalThe lower and upper range of the bins.  If not provided, range\nis simply (a.min(), a.max()).  Values outside the range are\nignored. The first element of the range must be less than or\nequal to the second. range affects the automatic bin\ncomputation as well. While bin width is computed to be optimal\nbased on the actual data within range, the bin count will fill\nthe entire range including portions containing no data.\n\nweightsarray_like, optionalAn array of weights, of the same shape as a.  Each value in\na only contributes its associated weight towards the bin count\n(instead of 1). This is currently not used by any of the bin estimators,\nbut may be in the future.\n\n\n\nReturns\n\nbin_edgesarray of dtype floatThe edges to pass into histogram\n\n\n\n\n\nSee also\nhistogram\n\nNotes\nThe methods to estimate the optimal number of bins are well founded\nin literature, and are inspired by the choices R provides for\nhistogram visualisation. Note that having the number of bins\nproportional to  is asymptotically optimal, which is\nwhy it appears in most estimators. These are simply plug-in methods\nthat give good starting points for number of bins. In the equations\nbelow,  is the binwidth and  is the number of\nbins. All estimators that compute bin counts are recast to bin width\nusing the ptp of the data. The final bin count is obtained from\nnp.round(np.ceil(range / h)).\n\n\u2018auto\u2019 (maximum of the \u2018sturges\u2019 and \u2018fd\u2019 estimators)A compromise to get a good value. For small datasets the Sturges\nvalue will usually be chosen, while larger datasets will usually\ndefault to FD.  Avoids the overly conservative behaviour of FD\nand Sturges for small and large datasets respectively.\nSwitchover point is usually .\n\n\u2018fd\u2019 (Freedman Diaconis Estimator)\n\nThe binwidth is proportional to the interquartile range (IQR)\nand inversely proportional to cube root of a.size. Can be too\nconservative for small datasets, but is quite good for large\ndatasets. The IQR is very robust to outliers.\n\n\u2018scott\u2019\n\nThe binwidth is proportional to the standard deviation of the\ndata and inversely proportional to cube root of x.size. Can\nbe too conservative for small datasets, but is quite good for\nlarge datasets. The standard deviation is not very robust to\noutliers. Values are very similar to the Freedman-Diaconis\nestimator in the absence of outliers.\n\n\u2018rice\u2019\n\nThe number of bins is only proportional to cube root of\na.size. It tends to overestimate the number of bins and it\ndoes not take into account data variability.\n\n\u2018sturges\u2019\n\nThe number of bins is the base 2 log of a.size.  This\nestimator assumes normality of data and is too conservative for\nlarger, non-normal datasets. This is the default method in R\u2019s\nhist method.\n\n\u2018doane\u2019\n\nAn improved version of Sturges\u2019 formula that produces better\nestimates for non-normal datasets. This estimator attempts to\naccount for the skew of the data.\n\n\u2018sqrt\u2019\n\nThe simplest and fastest estimator. Only takes into account the\ndata size.\n\n\nExamples\n&gt;&gt;&gt; arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])\n&gt;&gt;&gt; np.histogram_bin_edges(arr, bins='auto', range=(0, 1))\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n&gt;&gt;&gt; np.histogram_bin_edges(arr, bins=2)\narray([0. , 2.5, 5. ])\n\n\nFor consistency with histogram, an array of pre-computed bins is\npassed through unmodified:\n&gt;&gt;&gt; np.histogram_bin_edges(arr, [1, 2])\narray([1, 2])\n\n\nThis function allows one set of bins to be computed, and reused across\nmultiple histograms:\n&gt;&gt;&gt; shared_bins = np.histogram_bin_edges(arr, bins='auto')\n&gt;&gt;&gt; shared_bins\narray([0., 1., 2., 3., 4., 5.])\n\n\n&gt;&gt;&gt; group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])\n&gt;&gt;&gt; hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)\n&gt;&gt;&gt; hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)\n\n\n&gt;&gt;&gt; hist_0; hist_1\narray([1, 1, 0, 1, 0])\narray([2, 0, 1, 1, 2])\n\n\nWhich gives more easily comparable results than using separate bins for\neach histogram:\n&gt;&gt;&gt; hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')\n&gt;&gt;&gt; hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')\n&gt;&gt;&gt; hist_0; hist_1\narray([1, 1, 1])\narray([2, 1, 1, 2])\n&gt;&gt;&gt; bins_0; bins_1\narray([0., 1., 2., 3.])\narray([0.  , 1.25, 2.5 , 3.75, 5.  ])\n\n\n", "parameters": ["Parameters", "aarray_like", "binsint or sequence of scalars or str, optional", "\u2018auto\u2019", "\u2018fd\u2019 (Freedman Diaconis Estimator)", "\u2018doane\u2019", "\u2018scott\u2019", "\u2018stone\u2019", "\u2018rice\u2019", "\u2018sturges\u2019", "\u2018sqrt\u2019", "range(float, float), optional", "weightsarray_like, optional", "Returns", "bin_edgesarray of dtype float"], "returns": "bin_edgesarray of dtype floatThe edges to pass into histogram", "examples": ["; arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])\n; np.histogram_bin_edges(arr, bins='auto', range=(0, 1))\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n; np.histogram_bin_edges(arr, bins=2)\narray([0. , 2.5, 5. ])\n\n", "; arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5])\n; np.histogram_bin_edges(arr, bins='auto', range=(0, 1))\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n; np.histogram_bin_edges(arr, bins=2)\narray([0. , 2.5, 5. ])\n", "; np.histogram_bin_edges(arr, [1, 2])\narray([1, 2])\n\n", "; np.histogram_bin_edges(arr, [1, 2])\narray([1, 2])\n", "; shared_bins = np.histogram_bin_edges(arr, bins='auto')\n; shared_bins\narray([0., 1., 2., 3., 4., 5.])\n\n", "; shared_bins = np.histogram_bin_edges(arr, bins='auto')\n; shared_bins\narray([0., 1., 2., 3., 4., 5.])\n", "; group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])\n; hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)\n; hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)\n\n", "; group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1])\n; hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins)\n; hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)\n", "; hist_0; hist_1\narray([1, 1, 0, 1, 0])\narray([2, 0, 1, 1, 2])\n\n", "; hist_0; hist_1\narray([1, 1, 0, 1, 0])\narray([2, 0, 1, 1, 2])\n", "; hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')\n; hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')\n; hist_0; hist_1\narray([1, 1, 1])\narray([2, 1, 1, 2])\n; bins_0; bins_1\narray([0., 1., 2., 3.])\narray([0.  , 1.25, 2.5 , 3.75, 5.  ])\n\n", "; hist_0, bins_0 = np.histogram(arr[group_id == 0], bins='auto')\n; hist_1, bins_1 = np.histogram(arr[group_id == 1], bins='auto')\n; hist_0; hist_1\narray([1, 1, 1])\narray([2, 1, 1, 2])\n; bins_0; bins_1\narray([0., 1., 2., 3.])\narray([0.  , 1.25, 2.5 , 3.75, 5.  ])\n"]},
{"library": "numpy", "item_id": "numpy.histogram2d", "code": "\nnumpy.histogram2d(x, y, bins=10, range=None, normed=None, weights=None, density=None)[source]\u00b6", "description": "Compute the bi-dimensional histogram of two data samples.\n\nParameters\n\nxarray_like, shape (N,)An array containing the x coordinates of the points to be\nhistogrammed.\n\nyarray_like, shape (N,)An array containing the y coordinates of the points to be\nhistogrammed.\n\nbinsint or array_like or [int, int] or [array, array], optionalThe bin specification:\n\n\nIf int, the number of bins for the two dimensions (nx=ny=bins).\nIf array_like, the bin edges for the two dimensions\n(x_edges=y_edges=bins).\nIf [int, int], the number of bins in each dimension\n(nx, ny = bins).\nIf [array, array], the bin edges in each dimension\n(x_edges, y_edges = bins).\nA combination [int, array] or [array, int], where int\nis the number of bins and array is the bin edges.\n\n\n\nrangearray_like, shape(2,2), optionalThe leftmost and rightmost edges of the bins along each dimension\n(if not specified explicitly in the bins parameters):\n[[xmin, xmax], [ymin, ymax]]. All values outside of this range\nwill be considered outliers and not tallied in the histogram.\n\ndensitybool, optionalIf False, the default, returns the number of samples in each bin.\nIf True, returns the probability density function at the bin,\nbin_count / sample_count / bin_area.\n\nnormedbool, optionalAn alias for the density argument that behaves identically. To avoid\nconfusion with the broken normed argument to histogram, density\nshould be preferred.\n\nweightsarray_like, shape(N,), optionalAn array of values w_i weighing each sample (x_i, y_i).\nWeights are normalized to 1 if normed is True. If normed is\nFalse, the values of the returned histogram are equal to the sum of\nthe weights belonging to the samples falling into each bin.\n\n\n\nReturns\n\nHndarray, shape(nx, ny)The bi-dimensional histogram of samples x and y. Values in x\nare histogrammed along the first dimension and values in y are\nhistogrammed along the second dimension.\n\nxedgesndarray, shape(nx+1,)The bin edges along the first dimension.\n\nyedgesndarray, shape(ny+1,)The bin edges along the second dimension.\n\n\n\n\n\nSee also\n\nhistogram1D histogram\n\nhistogramddMultidimensional histogram\n\n\n\nNotes\nWhen normed is True, then the returned histogram is the sample\ndensity, defined such that the sum over bins of the product\nbin_value * bin_area is 1.\nPlease note that the histogram does not follow the Cartesian convention\nwhere x values are on the abscissa and y values on the ordinate\naxis.  Rather, x is histogrammed along the first dimension of the\narray (vertical), and y along the second dimension of the array\n(horizontal).  This ensures compatibility with histogramdd.\nExamples\n&gt;&gt;&gt; from matplotlib.image import NonUniformImage\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n\n\nConstruct a 2-D histogram with variable bin width. First define the bin\nedges:\n&gt;&gt;&gt; xedges = [0, 1, 3, 5]\n&gt;&gt;&gt; yedges = [0, 2, 3, 4, 6]\n\n\nNext we create a histogram H with random bin content:\n&gt;&gt;&gt; x = np.random.normal(2, 1, 100)\n&gt;&gt;&gt; y = np.random.normal(1, 1, 100)\n&gt;&gt;&gt; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))\n&gt;&gt;&gt; H = H.T  # Let each row list bins with common y range.\n\n\nimshow can only display square bins:\n&gt;&gt;&gt; fig = plt.figure(figsize=(7, 3))\n&gt;&gt;&gt; ax = fig.add_subplot(131, title='imshow: square bins')\n&gt;&gt;&gt; plt.imshow(H, interpolation='nearest', origin='low',\n...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n\n\npcolormesh can display actual edges:\n&gt;&gt;&gt; ax = fig.add_subplot(132, title='pcolormesh: actual edges',\n...         aspect='equal')\n&gt;&gt;&gt; X, Y = np.meshgrid(xedges, yedges)\n&gt;&gt;&gt; ax.pcolormesh(X, Y, H)\n&lt;matplotlib.collections.QuadMesh object at 0x...&gt;\n\n\nNonUniformImage can be used to\ndisplay actual bin edges with interpolation:\n&gt;&gt;&gt; ax = fig.add_subplot(133, title='NonUniformImage: interpolated',\n...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])\n&gt;&gt;&gt; im = NonUniformImage(ax, interpolation='bilinear')\n&gt;&gt;&gt; xcenters = (xedges[:-1] + xedges[1:]) / 2\n&gt;&gt;&gt; ycenters = (yedges[:-1] + yedges[1:]) / 2\n&gt;&gt;&gt; im.set_data(xcenters, ycenters, H)\n&gt;&gt;&gt; ax.images.append(im)\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (N,)", "yarray_like, shape (N,)", "binsint or array_like or [int, int] or [array, array], optional", "rangearray_like, shape(2,2), optional", "densitybool, optional", "normedbool, optional", "weightsarray_like, shape(N,), optional", "Returns", "Hndarray, shape(nx, ny)", "xedgesndarray, shape(nx+1,)", "yedgesndarray, shape(ny+1,)"], "returns": "Hndarray, shape(nx, ny)The bi-dimensional histogram of samples x and y. Values in xare histogrammed along the first dimension and values in y arehistogrammed along the second dimension.xedgesndarray, shape(nx+1,)The bin edges along the first dimension.yedgesndarray, shape(ny+1,)The bin edges along the second dimension.", "examples": ["; from matplotlib.image import NonUniformImage\n; import matplotlib.pyplot as plt\n\n", "; from matplotlib.image import NonUniformImage\n; import matplotlib.pyplot as plt\n", "; xedges = [0, 1, 3, 5]\n; yedges = [0, 2, 3, 4, 6]\n\n", "; xedges = [0, 1, 3, 5]\n; yedges = [0, 2, 3, 4, 6]\n", "; x = np.random.normal(2, 1, 100)\n; y = np.random.normal(1, 1, 100)\n; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))\n; H = H.T  # Let each row list bins with common y range.\n\n", "; x = np.random.normal(2, 1, 100)\n; y = np.random.normal(1, 1, 100)\n; H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges))\n; H = H.T  # Let each row list bins with common y range.\n", "; fig = plt.figure(figsize=(7, 3))\n; ax = fig.add_subplot(131, title='imshow: square bins')\n; plt.imshow(H, interpolation='nearest', origin='low',\n...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n\n", "; fig = plt.figure(figsize=(7, 3))\n; ax = fig.add_subplot(131, title='imshow: square bins')\n; plt.imshow(H, interpolation='nearest', origin='low',\n...         extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]])\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n", "; ax = fig.add_subplot(132, title='pcolormesh: actual edges',\n...         aspect='equal')\n; X, Y = np.meshgrid(xedges, yedges)\n; ax.pcolormesh(X, Y, H)\n&lt;matplotlib.collections.QuadMesh object at 0x...&gt;\n\n", "; ax = fig.add_subplot(132, title='pcolormesh: actual edges',\n...         aspect='equal')\n; X, Y = np.meshgrid(xedges, yedges)\n; ax.pcolormesh(X, Y, H)\n&lt;matplotlib.collections.QuadMesh object at 0x...&gt;\n", "; ax = fig.add_subplot(133, title='NonUniformImage: interpolated',\n...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])\n; im = NonUniformImage(ax, interpolation='bilinear')\n; xcenters = (xedges[:-1] + xedges[1:]) / 2\n; ycenters = (yedges[:-1] + yedges[1:]) / 2\n; im.set_data(xcenters, ycenters, H)\n; ax.images.append(im)\n; plt.show()\n\n", "; ax = fig.add_subplot(133, title='NonUniformImage: interpolated',\n...         aspect='equal', xlim=xedges[[0, -1]], ylim=yedges[[0, -1]])\n; im = NonUniformImage(ax, interpolation='bilinear')\n; xcenters = (xedges[:-1] + xedges[1:]) / 2\n; ycenters = (yedges[:-1] + yedges[1:]) / 2\n; im.set_data(xcenters, ycenters, H)\n; ax.images.append(im)\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.fft.hfft", "code": "\nnumpy.fft.hfft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.\n\nParameters\n\naarray_likeThe input array.\n\nnint, optionalLength of the transformed axis of the output. For n output\npoints, n//2 + 1 input points are necessary.  If the input is\nlonger than this, it is cropped.  If it is shorter than this, it is\npadded with zeros.  If n is not given, it is taken to be 2*(m-1)\nwhere m is the length of the input along the axis specified by\naxis.\n\naxisint, optionalAxis over which to compute the FFT. If not given, the last\naxis is used.\n\nnorm{None, \u201cortho\u201d}, optionalNormalization mode (see numpy.fft). Default is None.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\noutndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\nThe length of the transformed axis is n, or, if n is not given,\n2*m - 2 where m is the length of the transformed axis of\nthe input. To get an odd number of output points, n must be\nspecified, for instance as 2*m - 1 in the typical case,\n\n\n\nRaises\n\nIndexErrorIf axis is larger than the last axis of a.\n\n\n\n\n\nSee also\n\nrfftCompute the one-dimensional FFT for real input.\n\nihfftThe inverse of hfft.\n\n\n\nNotes\nhfft/ihfft are a pair analogous to rfft/irfft, but for the\nopposite case: here the signal has Hermitian symmetry in the time\ndomain and is real in the frequency domain. So here it\u2019s hfft for\nwhich you must supply the length of the result if it is to be odd.\n\neven: ihfft(hfft(a, 2*len(a) - 2) == a, within roundoff error,\nodd: ihfft(hfft(a, 2*len(a) - 1) == a, within roundoff error.\n\nThe correct interpretation of the hermitian input depends on the length of\nthe original data, as given by n. This is because each input shape could\ncorrespond to either an odd or even length signal. By default, hfft\nassumes an even output length which puts the last entry at the Nyquist\nfrequency; aliasing with its symmetric counterpart. By Hermitian symmetry,\nthe value is thus treated as purely real. To avoid losing information, the\nshape of the full signal must be given.\nExamples\n&gt;&gt;&gt; signal = np.array([1, 2, 3, 4, 3, 2])\n&gt;&gt;&gt; np.fft.fft(signal)\narray([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary\n&gt;&gt;&gt; np.fft.hfft(signal[:4]) # Input first half of signal\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n&gt;&gt;&gt; np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n\n\n&gt;&gt;&gt; signal = np.array([[1, 1.j], [-1.j, 2]])\n&gt;&gt;&gt; np.conj(signal.T) - signal   # check Hermitian symmetry\narray([[ 0.-0.j,  -0.+0.j], # may vary\n       [ 0.+0.j,  0.-0.j]])\n&gt;&gt;&gt; freq_spectrum = np.fft.hfft(signal)\n&gt;&gt;&gt; freq_spectrum\narray([[ 1.,  1.],\n       [ 2., -2.]])\n\n\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outndarray", "Raises", "IndexError"], "returns": "outndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.The length of the transformed axis is n, or, if n is not given,2*m - 2 where m is the length of the transformed axis ofthe input. To get an odd number of output points, n must bespecified, for instance as 2*m - 1 in the typical case,", "examples": ["; signal = np.array([1, 2, 3, 4, 3, 2])\n; np.fft.fft(signal)\narray([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary\n; np.fft.hfft(signal[:4]) # Input first half of signal\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n; np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n\n", "; signal = np.array([1, 2, 3, 4, 3, 2])\n; np.fft.fft(signal)\narray([15.+0.j,  -4.+0.j,   0.+0.j,  -1.-0.j,   0.+0.j,  -4.+0.j]) # may vary\n; np.fft.hfft(signal[:4]) # Input first half of signal\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n; np.fft.hfft(signal, 6)  # Input entire signal and truncate\narray([15.,  -4.,   0.,  -1.,   0.,  -4.])\n", "; signal = np.array([[1, 1.j], [-1.j, 2]])\n; np.conj(signal.T) - signal   # check Hermitian symmetry\narray([[ 0.-0.j,  -0.+0.j], # may vary\n       [ 0.+0.j,  0.-0.j]])\n; freq_spectrum = np.fft.hfft(signal)\n; freq_spectrum\narray([[ 1.,  1.],\n       [ 2., -2.]])\n\n", "; signal = np.array([[1, 1.j], [-1.j, 2]])\n; np.conj(signal.T) - signal   # check Hermitian symmetry\narray([[ 0.-0.j,  -0.+0.j], # may vary\n       [ 0.+0.j,  0.-0.j]])\n; freq_spectrum = np.fft.hfft(signal)\n; freq_spectrum\narray([[ 1.,  1.],\n       [ 2., -2.]])\n"]},
{"library": "numpy", "item_id": "numpy.histogram", "code": "\nnumpy.histogram(a, bins=10, range=None, normed=None, weights=None, density=None)[source]\u00b6", "description": "Compute the histogram of a set of data.\n\nParameters\n\naarray_likeInput data. The histogram is computed over the flattened array.\n\nbinsint or sequence of scalars or str, optionalIf bins is an int, it defines the number of equal-width\nbins in the given range (10, by default). If bins is a\nsequence, it defines a monotonically increasing array of bin edges,\nincluding the rightmost edge, allowing for non-uniform bin widths.\n\nNew in version 1.11.0.\n\nIf bins is a string, it defines the method used to calculate the\noptimal bin width, as defined by histogram_bin_edges.\n\nrange(float, float), optionalThe lower and upper range of the bins.  If not provided, range\nis simply (a.min(), a.max()).  Values outside the range are\nignored. The first element of the range must be less than or\nequal to the second. range affects the automatic bin\ncomputation as well. While bin width is computed to be optimal\nbased on the actual data within range, the bin count will fill\nthe entire range including portions containing no data.\n\nnormedbool, optional\nDeprecated since version 1.6.0.\n\nThis is equivalent to the density argument, but produces incorrect\nresults for unequal bin widths. It should not be used.\n\nChanged in version 1.15.0: DeprecationWarnings are actually emitted.\n\n\nweightsarray_like, optionalAn array of weights, of the same shape as a.  Each value in\na only contributes its associated weight towards the bin count\n(instead of 1). If density is True, the weights are\nnormalized, so that the integral of the density over the range\nremains 1.\n\ndensitybool, optionalIf False, the result will contain the number of samples in\neach bin. If True, the result is the value of the\nprobability density function at the bin, normalized such that\nthe integral over the range is 1. Note that the sum of the\nhistogram values will not be equal to 1 unless bins of unity\nwidth are chosen; it is not a probability mass function.\nOverrides the normed keyword if given.\n\n\n\nReturns\n\nhistarrayThe values of the histogram. See density and weights for a\ndescription of the possible semantics.\n\nbin_edgesarray of dtype floatReturn the bin edges (length(hist)+1).\n\n\n\n\n\nSee also\nhistogramdd, bincount, searchsorted, digitize, histogram_bin_edges\n\nNotes\nAll but the last (righthand-most) bin is half-open.  In other words,\nif bins is:\n[1, 2, 3, 4]\n\n\nthen the first bin is [1, 2) (including 1, but excluding 2) and\nthe second [2, 3).  The last bin, however, is [3, 4], which\nincludes 4.\nExamples\n&gt;&gt;&gt; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n(array([0, 2, 1]), array([0, 1, 2, 3]))\n&gt;&gt;&gt; np.histogram(np.arange(4), bins=np.arange(5), density=True)\n(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))\n&gt;&gt;&gt; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n(array([1, 4, 1]), array([0, 1, 2, 3]))\n\n\n&gt;&gt;&gt; a = np.arange(5)\n&gt;&gt;&gt; hist, bin_edges = np.histogram(a, density=True)\n&gt;&gt;&gt; hist\narray([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])\n&gt;&gt;&gt; hist.sum()\n2.4999999999999996\n&gt;&gt;&gt; np.sum(hist * np.diff(bin_edges))\n1.0\n\n\n\nNew in version 1.11.0.\n\nAutomated Bin Selection Methods example, using 2 peak random data\nwith 2000 points:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; rng = np.random.RandomState(10)  # deterministic random data\n&gt;&gt;&gt; a = np.hstack((rng.normal(size=1000),\n...                rng.normal(loc=5, scale=2, size=1000)))\n&gt;&gt;&gt; _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram\n&gt;&gt;&gt; plt.title(\"Histogram with 'auto' bins\")\nText(0.5, 1.0, \"Histogram with 'auto' bins\")\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "binsint or sequence of scalars or str, optional", "range(float, float), optional", "normedbool, optional", "weightsarray_like, optional", "densitybool, optional", "Returns", "histarray", "bin_edgesarray of dtype float"], "returns": "histarrayThe values of the histogram. See density and weights for adescription of the possible semantics.bin_edgesarray of dtype floatReturn the bin edges (length(hist)+1).", "examples": ["; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n(array([0, 2, 1]), array([0, 1, 2, 3]))\n; np.histogram(np.arange(4), bins=np.arange(5), density=True)\n(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))\n; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n(array([1, 4, 1]), array([0, 1, 2, 3]))\n\n", "; np.histogram([1, 2, 1], bins=[0, 1, 2, 3])\n(array([0, 2, 1]), array([0, 1, 2, 3]))\n; np.histogram(np.arange(4), bins=np.arange(5), density=True)\n(array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4]))\n; np.histogram([[1, 2, 1], [1, 0, 1]], bins=[0,1,2,3])\n(array([1, 4, 1]), array([0, 1, 2, 3]))\n", "; a = np.arange(5)\n; hist, bin_edges = np.histogram(a, density=True)\n; hist\narray([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])\n; hist.sum()\n2.4999999999999996\n; np.sum(hist * np.diff(bin_edges))\n1.0\n\n", "; a = np.arange(5)\n; hist, bin_edges = np.histogram(a, density=True)\n; hist\narray([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5])\n; hist.sum()\n2.4999999999999996\n; np.sum(hist * np.diff(bin_edges))\n1.0\n", "; import matplotlib.pyplot as plt\n; rng = np.random.RandomState(10)  # deterministic random data\n; a = np.hstack((rng.normal(size=1000),\n...                rng.normal(loc=5, scale=2, size=1000)))\n; _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram\n; plt.title(\"Histogram with 'auto' bins\")\nText(0.5, 1.0, \"Histogram with 'auto' bins\")\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; rng = np.random.RandomState(10)  # deterministic random data\n; a = np.hstack((rng.normal(size=1000),\n...                rng.normal(loc=5, scale=2, size=1000)))\n; _ = plt.hist(a, bins='auto')  # arguments are passed to np.histogram\n; plt.title(\"Histogram with 'auto' bins\")\nText(0.5, 1.0, \"Histogram with 'auto' bins\")\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermzero", "code": "\nnumpy.polynomial.hermite.hermzero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermweight", "code": "\nnumpy.polynomial.hermite.hermweight(x)[source]\u00b6", "description": "Weight function of the Hermite polynomials.\nThe weight function is  and the interval of\nintegration is . the Hermite polynomials are\northogonal, but not normalized, with respect to this weight function.\n\nParameters\n\nxarray_likeValues at which the weight function will be computed.\n\n\n\nReturns\n\nwndarrayThe weight function at x.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "wndarray"], "returns": "wndarrayThe weight function at x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermvander3d", "code": "\nnumpy.polynomial.hermite.hermvander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe degrees of the Hermite polynomials.\nIf V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand  np.dot(V, c.flat) and hermval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D Hermite\nseries of the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\nhermvander, hermvander3d, hermval2d, hermval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermvander2d", "code": "\nnumpy.polynomial.hermite.hermvander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the degrees of\nthe Hermite polynomials.\nIf V = hermvander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and hermval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D Hermite\nseries of the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\nhermvander, hermvander3d, hermval2d, hermval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermvander", "code": "\nnumpy.polynomial.hermite.hermvander(x, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degree.\nReturns the pseudo-Vandermonde matrix of degree deg and sample points\nx. The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the degree of the Hermite polynomial.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\narray V = hermvander(x, n), then np.dot(V, c) and\nhermval(x, c) are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of Hermite series of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where The last index is the degree of the\ncorresponding Hermite polynomial.  The dtype will be the same as\nthe converted x.\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermvander\n&gt;&gt;&gt; x = np.array([-1, 0, 1])\n&gt;&gt;&gt; hermvander(x, 3)\narray([[ 1., -2.,  2.,  4.],\n       [ 1.,  0., -2., -0.],\n       [ 1.,  2.,  2., -4.]])\n\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray"], "returns": "vanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where The last index is the degree of thecorresponding Hermite polynomial.  The dtype will be the same asthe converted x.", "examples": ["; from numpy.polynomial.hermite import hermvander\n; x = np.array([-1, 0, 1])\n; hermvander(x, 3)\narray([[ 1., -2.,  2.,  4.],\n       [ 1.,  0., -2., -0.],\n       [ 1.,  2.,  2., -4.]])\n\n", "; from numpy.polynomial.hermite import hermvander\n; x = np.array([-1, 0, 1])\n; hermvander(x, 3)\narray([[ 1., -2.,  2.,  4.],\n       [ 1.,  0., -2., -0.],\n       [ 1.,  2.,  2., -4.]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermval3d", "code": "\nnumpy.polynomial.hermite.hermval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Hermite series at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimensional polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\nhermval, hermval2d, hermgrid2d, hermgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimensional polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermval2d", "code": "\nnumpy.polynomial.hermite.hermval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Hermite series at points (x, y).\nThis function returns the values:\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and if it isn\u2019t an ndarray it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than two the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points formed with\npairs of corresponding values from x and y.\n\n\n\n\n\nSee also\nhermval, hermgrid2d, hermval3d, hermgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points formed withpairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermval", "code": "\nnumpy.polynomial.hermite.hermval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate an Hermite series at points x.\nIf c is of length n + 1, this function returns the value:\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, algebra_likeThe shape of the return value is described above.\n\n\n\n\n\nSee also\nhermval2d, hermgrid2d, hermval3d, hermgrid3d\n\nNotes\nThe evaluation uses Clenshaw recursion, aka synthetic division.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermval\n&gt;&gt;&gt; coef = [1,2,3]\n&gt;&gt;&gt; hermval(1, coef)\n11.0\n&gt;&gt;&gt; hermval([[1,2],[3,4]], coef)\narray([[ 11.,   51.],\n       [115.,  203.]])\n\n\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, algebra_like"], "returns": "valuesndarray, algebra_likeThe shape of the return value is described above.", "examples": ["; from numpy.polynomial.hermite import hermval\n; coef = [1,2,3]\n; hermval(1, coef)\n11.0\n; hermval([[1,2],[3,4]], coef)\narray([[ 11.,   51.],\n       [115.,  203.]])\n\n", "; from numpy.polynomial.hermite import hermval\n; coef = [1,2,3]\n; hermval(1, coef)\n11.0\n; hermval([[1,2],[3,4]], coef)\narray([[ 11.,   51.],\n       [115.,  203.]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermtrim", "code": "\nnumpy.polynomial.hermite.hermtrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermsub", "code": "\nnumpy.polynomial.hermite.hermsub(c1, c2)[source]\u00b6", "description": "Subtract one Hermite series from another.\nReturns the difference of two Hermite series c1 - c2.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Hermite series coefficients representing their difference.\n\n\n\n\n\nSee also\nhermadd, hermmulx, hermmul, hermdiv, hermpow\n\nNotes\nUnlike multiplication, division, etc., the difference of two Hermite\nseries is a Hermite series (without having to \u201creproject\u201d the result\nonto the basis set) so subtraction, just like that of \u201cstandard\u201d\npolynomials, is simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermsub\n&gt;&gt;&gt; hermsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Hermite series coefficients representing their difference.", "examples": ["; from numpy.polynomial.hermite import hermsub\n; hermsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n\n", "; from numpy.polynomial.hermite import hermsub\n; hermsub([1, 2, 3, 4], [1, 2, 3])\narray([0.,  0.,  0.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermroots", "code": "\nnumpy.polynomial.hermite.hermroots(c)[source]\u00b6", "description": "Compute the roots of a Hermite series.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the series. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\npolyroots, legroots, lagroots, chebroots, hermeroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton\u2019s method.\nThe Hermite series basis polynomials aren\u2019t powers of x so the\nresults of this function may seem unintuitive.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermroots, hermfromroots\n&gt;&gt;&gt; coef = hermfromroots([-1, 0, 1])\n&gt;&gt;&gt; coef\narray([0.   ,  0.25 ,  0.   ,  0.125])\n&gt;&gt;&gt; hermroots(coef)\narray([-1.00000000e+00, -1.38777878e-17,  1.00000000e+00])\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the series. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; from numpy.polynomial.hermite import hermroots, hermfromroots\n; coef = hermfromroots([-1, 0, 1])\n; coef\narray([0.   ,  0.25 ,  0.   ,  0.125])\n; hermroots(coef)\narray([-1.00000000e+00, -1.38777878e-17,  1.00000000e+00])\n\n", "; from numpy.polynomial.hermite import hermroots, hermfromroots\n; coef = hermfromroots([-1, 0, 1])\n; coef\narray([0.   ,  0.25 ,  0.   ,  0.125])\n; hermroots(coef)\narray([-1.00000000e+00, -1.38777878e-17,  1.00000000e+00])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermone", "code": "\nnumpy.polynomial.hermite.hermone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermmulx", "code": "\nnumpy.polynomial.hermite.hermmulx(c)[source]\u00b6", "description": "Multiply a Hermite series by x.\nMultiply the Hermite series c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\n\nSee also\nhermadd, hermsub, hermmul, hermdiv, hermpow\n\nNotes\nThe multiplication uses the recursion relationship for Hermite\npolynomials in the form\n\n\nxP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermmulx\n&gt;&gt;&gt; hermmulx([1, 2, 3])\narray([2. , 6.5, 1. , 1.5])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": ["; from numpy.polynomial.hermite import hermmulx\n; hermmulx([1, 2, 3])\narray([2. , 6.5, 1. , 1.5])\n\n", "; from numpy.polynomial.hermite import hermmulx\n; hermmulx([1, 2, 3])\narray([2. , 6.5, 1. , 1.5])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermpow", "code": "\nnumpy.polynomial.hermite.hermpow(c, pow, maxpower=16)[source]\u00b6", "description": "Raise a Hermite series to a power.\nReturns the Hermite series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\ncarray_like1-D array of Hermite series coefficients ordered from low to\nhigh.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayHermite series of power.\n\n\n\n\n\nSee also\nhermadd, hermsub, hermmulx, hermmul, hermdiv\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermpow\n&gt;&gt;&gt; hermpow([1, 2, 3], 2)\narray([81.,  52.,  82.,  12.,   9.])\n\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayHermite series of power.", "examples": ["; from numpy.polynomial.hermite import hermpow\n; hermpow([1, 2, 3], 2)\narray([81.,  52.,  82.,  12.,   9.])\n\n", "; from numpy.polynomial.hermite import hermpow\n; hermpow([1, 2, 3], 2)\narray([81.,  52.,  82.,  12.,   9.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermmul", "code": "\nnumpy.polynomial.hermite.hermmul(c1, c2)[source]\u00b6", "description": "Multiply one Hermite series by another.\nReturns the product of two Hermite series c1 * c2.  The arguments\nare sequences of coefficients, from lowest order \u201cterm\u201d to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Hermite series coefficients representing their product.\n\n\n\n\n\nSee also\nhermadd, hermsub, hermmulx, hermdiv, hermpow\n\nNotes\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Hermite polynomial basis set.  Thus, to express\nthe product as a Hermite series, it is necessary to \u201creproject\u201d the\nproduct onto said basis set, which may produce \u201cunintuitive\u201d (but\ncorrect) results; see Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermmul\n&gt;&gt;&gt; hermmul([1, 2, 3], [0, 1, 2])\narray([52.,  29.,  52.,   7.,   6.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Hermite series coefficients representing their product.", "examples": ["; from numpy.polynomial.hermite import hermmul\n; hermmul([1, 2, 3], [0, 1, 2])\narray([52.,  29.,  52.,   7.,   6.])\n\n", "; from numpy.polynomial.hermite import hermmul\n; hermmul([1, 2, 3], [0, 1, 2])\narray([52.,  29.,  52.,   7.,   6.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE", "code": "\nclass numpy.polynomial.hermite_e.HermiteE(coef, domain=None, window=None)[source]\u00b6", "description": "An HermiteE series class.\nThe HermiteE class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nattributes and methods listed in the ABCPolyBase documentation.\n\nParameters\n\ncoefarray_likeHermiteE coefficients in order of increasing degree, i.e,\n(1, 2, 3) gives 1*He_0(x) + 2*He_1(X) + 3*He_2(x).\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [-1, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [-1, 1].\n\nNew in version 1.6.0.\n\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite", "code": "\nclass numpy.polynomial.hermite.Hermite(coef, domain=None, window=None)[source]\u00b6", "description": "An Hermite series class.\nThe Hermite class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nattributes and methods listed in the ABCPolyBase documentation.\n\nParameters\n\ncoefarray_likeHermite coefficients in order of increasing degree, i.e,\n(1, 2, 3) gives 1*H_0(x) + 2*H_1(X) + 3*H_2(x).\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [-1, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [-1, 1].\n\nNew in version 1.6.0.\n\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermint", "code": "\nnumpy.polynomial.hermite.hermint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a Hermite series.\nReturns the Hermite series coefficients c integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument c is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series H_0 + 2*H_1 + 3*H_2 while [[1,2],[1,2]]\nrepresents 1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +\n2*H_1(x)*H_1(y) if axis=0 is x and axis=1 is y.\n\nParameters\n\ncarray_likeArray of Hermite series coefficients. If c is multidimensional the\ndifferent axis correspond to different variables with the degree in\neach axis given by the corresponding index.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at\nlbnd is the first value in the list, the value of the second\nintegral at lbnd is the second value, etc.  If k == [] (the\ndefault), all constants are set to zero.  If m == 1, a single\nscalar can be given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayHermite series coefficients of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 0, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\nhermder\n\nNotes\nNote that the result of each integration is multiplied by scl.\nWhy is this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x.  Then\n, so one will need to set scl equal to\n - perhaps not what one would have first thought.\nAlso note that, in general, the result of integrating a C-series needs\nto be \u201creprojected\u201d onto the C-series basis set.  Thus, typically,\nthe result of this function is \u201cunintuitive,\u201d albeit correct; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermint\n&gt;&gt;&gt; hermint([1,2,3]) # integrate once, value 0 at 0.\narray([1. , 0.5, 0.5, 0.5])\n&gt;&gt;&gt; hermint([1,2,3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n&gt;&gt;&gt; hermint([1,2,3], k=1) # integrate once, value 1 at 0.\narray([2. , 0.5, 0.5, 0.5])\n&gt;&gt;&gt; hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\narray([-2. ,  0.5,  0.5,  0.5])\n&gt;&gt;&gt; hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\narray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayHermite series coefficients of the integral.", "examples": ["; from numpy.polynomial.hermite import hermint\n; hermint([1,2,3]) # integrate once, value 0 at 0.\narray([1. , 0.5, 0.5, 0.5])\n; hermint([1,2,3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n; hermint([1,2,3], k=1) # integrate once, value 1 at 0.\narray([2. , 0.5, 0.5, 0.5])\n; hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\narray([-2. ,  0.5,  0.5,  0.5])\n; hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\narray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n\n", "; from numpy.polynomial.hermite import hermint\n; hermint([1,2,3]) # integrate once, value 0 at 0.\narray([1. , 0.5, 0.5, 0.5])\n; hermint([1,2,3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.5       ,  0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n; hermint([1,2,3], k=1) # integrate once, value 1 at 0.\narray([2. , 0.5, 0.5, 0.5])\n; hermint([1,2,3], lbnd=-1) # integrate once, value 0 at -1\narray([-2. ,  0.5,  0.5,  0.5])\n; hermint([1,2,3], m=2, k=[1,2], lbnd=-1)\narray([ 1.66666667, -0.5       ,  0.125     ,  0.08333333,  0.0625    ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermgrid3d", "code": "\nnumpy.polynomial.hermite.hermgrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nhermval, hermval2d, hermgrid2d, hermval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermgrid2d", "code": "\nnumpy.polynomial.hermite.hermgrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Hermite series on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nhermval, hermval2d, hermval3d, hermgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermgauss", "code": "\nnumpy.polynomial.hermite.hermgauss(deg)[source]\u00b6", "description": "Gauss-Hermite quadrature.\nComputes the sample points and weights for Gauss-Hermite quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree  or less over the interval \nwith the weight function .\n\nParameters\n\ndegintNumber of sample points and weights. It must be &gt;= 1.\n\n\n\nReturns\n\nxndarray1-D ndarray containing the sample points.\n\nyndarray1-D ndarray containing the weights.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nThe results have only been tested up to degree 100, higher degrees may\nbe problematic. The weights are determined by using the fact that\n\n\nwhere  is a constant independent of  and \nis the k\u2019th root of , and then scaling the results to get\nthe right value when integrating 1.\n", "parameters": ["Parameters", "degint", "Returns", "xndarray", "yndarray"], "returns": "xndarray1-D ndarray containing the sample points.yndarray1-D ndarray containing the weights.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermfromroots", "code": "\nnumpy.polynomial.hermite.hermfromroots(roots)[source]\u00b6", "description": "Generate a Hermite series with given roots.\nThe function returns the coefficients of the polynomial\n\n\nin Hermite form, where the r_n are the roots specified in roots.\nIf a zero has multiplicity n, then it must appear in roots n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then roots looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in Hermite form.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of coefficients.  If all roots are real then out is a\nreal array, if some of the roots are complex, then out is complex\neven if all the coefficients in the result are real (see Examples\nbelow).\n\n\n\n\n\nSee also\npolyfromroots, legfromroots, lagfromroots, chebfromroots, hermefromroots\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermfromroots, hermval\n&gt;&gt;&gt; coef = hermfromroots((-1, 0, 1))\n&gt;&gt;&gt; hermval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n&gt;&gt;&gt; coef = hermfromroots((-1j, 1j))\n&gt;&gt;&gt; hermval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of coefficients.  If all roots are real then out is areal array, if some of the roots are complex, then out is complexeven if all the coefficients in the result are real (see Examplesbelow).", "examples": ["; from numpy.polynomial.hermite import hermfromroots, hermval\n; coef = hermfromroots((-1, 0, 1))\n; hermval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n; coef = hermfromroots((-1j, 1j))\n; hermval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n", "; from numpy.polynomial.hermite import hermfromroots, hermval\n; coef = hermfromroots((-1, 0, 1))\n; hermval((-1, 0, 1), coef)\narray([0.,  0.,  0.])\n; coef = hermfromroots((-1j, 1j))\n; hermval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermfit", "code": "\nnumpy.polynomial.hermite.hermfit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least squares fit of Hermite series to data.\nReturn the coefficients of a Hermite series of degree deg that is the\nleast squares fit to the data values y given at points x. If y is\n1-D the returned coefficients will also be 1-D. If y is 2-D multiple\nfits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\n\n\nReturns\n\ncoefndarray, shape (M,) or (M, K)Hermite coefficients ordered from low to high. If y was 2-D,\nthe coefficients for the data in column k  of y are in column\nk.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.  The\nwarnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\nchebfit, legfit, lagfit, polyfit, hermefit\n\nhermvalEvaluates a Hermite series.\n\nhermvanderVandermonde matrix of Hermite series.\n\nhermweightHermite weight function\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the Hermite series p that\nminimizes the sum of the weighted squared errors\n\n\nwhere the  are the weights. This problem is solved by\nsetting up the (typically) overdetermined matrix equation\n\n\nwhere V is the weighted pseudo Vandermonde matrix of x, c are the\ncoefficients to be solved for, w are the weights, y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected, then a RankWarning will be issued. This means that the\ncoefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The rcond parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\nFits using Hermite series are probably most useful when the data can be\napproximated by sqrt(w(x)) * p(x), where w(x) is the Hermite\nweight. In that case the weight sqrt(w(x[i]) should be used\ntogether with data values y[i]/sqrt(w(x[i]). The weight function is\navailable as hermweight.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermfit, hermval\n&gt;&gt;&gt; x = np.linspace(-10, 10)\n&gt;&gt;&gt; err = np.random.randn(len(x))/10\n&gt;&gt;&gt; y = hermval(x, [1, 2, 3]) + err\n&gt;&gt;&gt; hermfit(x, y, 2)\narray([1.0218, 1.9986, 2.9999]) # may vary\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (M,) or (M, K)", "[residuals, rank, singular_values, rcond]list", "Warns", "RankWarning"], "returns": "coefndarray, shape (M,) or (M, K)Hermite coefficients ordered from low to high. If y was 2-D,the coefficients for the data in column k  of y are in columnk.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": ["; from numpy.polynomial.hermite import hermfit, hermval\n; x = np.linspace(-10, 10)\n; err = np.random.randn(len(x))/10\n; y = hermval(x, [1, 2, 3]) + err\n; hermfit(x, y, 2)\narray([1.0218, 1.9986, 2.9999]) # may vary\n\n", "; from numpy.polynomial.hermite import hermfit, hermval\n; x = np.linspace(-10, 10)\n; err = np.random.randn(len(x))/10\n; y = hermval(x, [1, 2, 3]) + err\n; hermfit(x, y, 2)\narray([1.0218, 1.9986, 2.9999]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermezero", "code": "\nnumpy.polynomial.hermite_e.hermezero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermex", "code": "\nnumpy.polynomial.hermite_e.hermex = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeweight", "code": "\nnumpy.polynomial.hermite_e.hermeweight(x)[source]\u00b6", "description": "Weight function of the Hermite_e polynomials.\nThe weight function is  and the interval of\nintegration is . the HermiteE polynomials are\northogonal, but not normalized, with respect to this weight function.\n\nParameters\n\nxarray_likeValues at which the weight function will be computed.\n\n\n\nReturns\n\nwndarrayThe weight function at x.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "wndarray"], "returns": "wndarrayThe weight function at x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermevander3d", "code": "\nnumpy.polynomial.hermite_e.hermevander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen Hehe pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe degrees of the HermiteE polynomials.\nIf V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand  np.dot(V, c.flat) and hermeval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D HermiteE\nseries of the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\nhermevander, hermevander3d, hermeval2d, hermeval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermevander2d", "code": "\nnumpy.polynomial.hermite_e.hermevander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the degrees of\nthe HermiteE polynomials.\nIf V = hermevander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and hermeval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D HermiteE\nseries of the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to\n1-D arrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\nhermevander, hermevander3d, hermeval2d, hermeval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermevander", "code": "\nnumpy.polynomial.hermite_e.hermevander(x, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degree.\nReturns the pseudo-Vandermonde matrix of degree deg and sample points\nx. The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the degree of the HermiteE polynomial.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\narray V = hermevander(x, n), then np.dot(V, c) and\nhermeval(x, c) are the same up to roundoff. This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of HermiteE series of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where The last index is the degree of the\ncorresponding HermiteE polynomial.  The dtype will be the same as\nthe converted x.\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermevander\n&gt;&gt;&gt; x = np.array([-1, 0, 1])\n&gt;&gt;&gt; hermevander(x, 3)\narray([[ 1., -1.,  0.,  2.],\n       [ 1.,  0., -1., -0.],\n       [ 1.,  1.,  0., -2.]])\n\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray"], "returns": "vanderndarrayThe pseudo-Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where The last index is the degree of thecorresponding HermiteE polynomial.  The dtype will be the same asthe converted x.", "examples": ["; from numpy.polynomial.hermite_e import hermevander\n; x = np.array([-1, 0, 1])\n; hermevander(x, 3)\narray([[ 1., -1.,  0.,  2.],\n       [ 1.,  0., -1., -0.],\n       [ 1.,  1.,  0., -2.]])\n\n", "; from numpy.polynomial.hermite_e import hermevander\n; x = np.array([-1, 0, 1])\n; hermevander(x, 3)\narray([[ 1., -1.,  0.,  2.],\n       [ 1.,  0., -1., -0.],\n       [ 1.,  1.,  0., -2.]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeval3d", "code": "\nnumpy.polynomial.hermite_e.hermeval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Hermite_e series at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimensional polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\nhermeval, hermeval2d, hermegrid2d, hermegrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimensional polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermesub", "code": "\nnumpy.polynomial.hermite_e.hermesub(c1, c2)[source]\u00b6", "description": "Subtract one Hermite series from another.\nReturns the difference of two Hermite series c1 - c2.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Hermite series coefficients representing their difference.\n\n\n\n\n\nSee also\nhermeadd, hermemulx, hermemul, hermediv, hermepow\n\nNotes\nUnlike multiplication, division, etc., the difference of two Hermite\nseries is a Hermite series (without having to \u201creproject\u201d the result\nonto the basis set) so subtraction, just like that of \u201cstandard\u201d\npolynomials, is simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermesub\n&gt;&gt;&gt; hermesub([1, 2, 3, 4], [1, 2, 3])\narray([0., 0., 0., 4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Hermite series coefficients representing their difference.", "examples": ["; from numpy.polynomial.hermite_e import hermesub\n; hermesub([1, 2, 3, 4], [1, 2, 3])\narray([0., 0., 0., 4.])\n\n", "; from numpy.polynomial.hermite_e import hermesub\n; hermesub([1, 2, 3, 4], [1, 2, 3])\narray([0., 0., 0., 4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeroots", "code": "\nnumpy.polynomial.hermite_e.hermeroots(c)[source]\u00b6", "description": "Compute the roots of a HermiteE series.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the series. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\npolyroots, legroots, lagroots, hermroots, chebroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton\u2019s method.\nThe HermiteE series basis polynomials aren\u2019t powers of x so the\nresults of this function may seem unintuitive.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeroots, hermefromroots\n&gt;&gt;&gt; coef = hermefromroots([-1, 0, 1])\n&gt;&gt;&gt; coef\narray([0., 2., 0., 1.])\n&gt;&gt;&gt; hermeroots(coef)\narray([-1.,  0.,  1.]) # may vary\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the series. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; from numpy.polynomial.hermite_e import hermeroots, hermefromroots\n; coef = hermefromroots([-1, 0, 1])\n; coef\narray([0., 2., 0., 1.])\n; hermeroots(coef)\narray([-1.,  0.,  1.]) # may vary\n\n", "; from numpy.polynomial.hermite_e import hermeroots, hermefromroots\n; coef = hermefromroots([-1, 0, 1])\n; coef\narray([0., 2., 0., 1.])\n; hermeroots(coef)\narray([-1.,  0.,  1.]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeval2d", "code": "\nnumpy.polynomial.hermite_e.hermeval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D HermiteE series at points (x, y).\nThis function returns the values:\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and if it isn\u2019t an ndarray it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than two the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points formed with\npairs of corresponding values from x and y.\n\n\n\n\n\nSee also\nhermeval, hermegrid2d, hermeval3d, hermegrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points formed withpairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeval", "code": "\nnumpy.polynomial.hermite_e.hermeval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate an HermiteE series at points x.\nIf c is of length n + 1, this function returns the value:\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, algebra_likeThe shape of the return value is described above.\n\n\n\n\n\nSee also\nhermeval2d, hermegrid2d, hermeval3d, hermegrid3d\n\nNotes\nThe evaluation uses Clenshaw recursion, aka synthetic division.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeval\n&gt;&gt;&gt; coef = [1,2,3]\n&gt;&gt;&gt; hermeval(1, coef)\n3.0\n&gt;&gt;&gt; hermeval([[1,2],[3,4]], coef)\narray([[ 3., 14.],\n       [31., 54.]])\n\n\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, algebra_like"], "returns": "valuesndarray, algebra_likeThe shape of the return value is described above.", "examples": ["; from numpy.polynomial.hermite_e import hermeval\n; coef = [1,2,3]\n; hermeval(1, coef)\n3.0\n; hermeval([[1,2],[3,4]], coef)\narray([[ 3., 14.],\n       [31., 54.]])\n\n", "; from numpy.polynomial.hermite_e import hermeval\n; coef = [1,2,3]\n; hermeval(1, coef)\n3.0\n; hermeval([[1,2],[3,4]], coef)\narray([[ 3., 14.],\n       [31., 54.]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermetrim", "code": "\nnumpy.polynomial.hermite_e.hermetrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermepow", "code": "\nnumpy.polynomial.hermite_e.hermepow(c, pow, maxpower=16)[source]\u00b6", "description": "Raise a Hermite series to a power.\nReturns the Hermite series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\ncarray_like1-D array of Hermite series coefficients ordered from low to\nhigh.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayHermite series of power.\n\n\n\n\n\nSee also\nhermeadd, hermesub, hermemulx, hermemul, hermediv\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermepow\n&gt;&gt;&gt; hermepow([1, 2, 3], 2)\narray([23.,  28.,  46.,  12.,   9.])\n\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayHermite series of power.", "examples": ["; from numpy.polynomial.hermite_e import hermepow\n; hermepow([1, 2, 3], 2)\narray([23.,  28.,  46.,  12.,   9.])\n\n", "; from numpy.polynomial.hermite_e import hermepow\n; hermepow([1, 2, 3], 2)\narray([23.,  28.,  46.,  12.,   9.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeone", "code": "\nnumpy.polynomial.hermite_e.hermeone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermemul", "code": "\nnumpy.polynomial.hermite_e.hermemul(c1, c2)[source]\u00b6", "description": "Multiply one Hermite series by another.\nReturns the product of two Hermite series c1 * c2.  The arguments\nare sequences of coefficients, from lowest order \u201cterm\u201d to highest,\ne.g., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Hermite series coefficients representing their product.\n\n\n\n\n\nSee also\nhermeadd, hermesub, hermemulx, hermediv, hermepow\n\nNotes\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Hermite polynomial basis set.  Thus, to express\nthe product as a Hermite series, it is necessary to \u201creproject\u201d the\nproduct onto said basis set, which may produce \u201cunintuitive\u201d (but\ncorrect) results; see Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemul\n&gt;&gt;&gt; hermemul([1, 2, 3], [0, 1, 2])\narray([14.,  15.,  28.,   7.,   6.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Hermite series coefficients representing their product.", "examples": ["; from numpy.polynomial.hermite_e import hermemul\n; hermemul([1, 2, 3], [0, 1, 2])\narray([14.,  15.,  28.,   7.,   6.])\n\n", "; from numpy.polynomial.hermite_e import hermemul\n; hermemul([1, 2, 3], [0, 1, 2])\narray([14.,  15.,  28.,   7.,   6.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeline", "code": "\nnumpy.polynomial.hermite_e.hermeline(off, scl)[source]\u00b6", "description": "Hermite series whose graph is a straight line.\n\nParameters\n\noff, sclscalarsThe specified line is given by off + scl*x.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the Hermite series for\noff + scl*x.\n\n\n\n\n\nSee also\npolyline, chebline\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeline, hermeval\n&gt;&gt;&gt; hermeval(0,hermeline(3, 2))\n3.0\n&gt;&gt;&gt; hermeval(1,hermeline(3, 2))\n5.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the Hermite series foroff + scl*x.", "examples": ["; from numpy.polynomial.hermite_e import hermeline\n; from numpy.polynomial.hermite_e import hermeline, hermeval\n; hermeval(0,hermeline(3, 2))\n3.0\n; hermeval(1,hermeline(3, 2))\n5.0\n\n", "; from numpy.polynomial.hermite_e import hermeline\n; from numpy.polynomial.hermite_e import hermeline, hermeval\n; hermeval(0,hermeline(3, 2))\n3.0\n; hermeval(1,hermeline(3, 2))\n5.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeint", "code": "\nnumpy.polynomial.hermite_e.hermeint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a Hermite_e series.\nReturns the Hermite_e series coefficients c integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument c is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series H_0 + 2*H_1 + 3*H_2 while [[1,2],[1,2]]\nrepresents 1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) + 2*H_0(x)*H_1(y) +\n2*H_1(x)*H_1(y) if axis=0 is x and axis=1 is y.\n\nParameters\n\ncarray_likeArray of Hermite_e series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at\nlbnd is the first value in the list, the value of the second\nintegral at lbnd is the second value, etc.  If k == [] (the\ndefault), all constants are set to zero.  If m == 1, a single\nscalar can be given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayHermite_e series coefficients of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 0, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\nhermeder\n\nNotes\nNote that the result of each integration is multiplied by scl.\nWhy is this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x.  Then\n, so one will need to set scl equal to\n - perhaps not what one would have first thought.\nAlso note that, in general, the result of integrating a C-series needs\nto be \u201creprojected\u201d onto the C-series basis set.  Thus, typically,\nthe result of this function is \u201cunintuitive,\u201d albeit correct; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeint\n&gt;&gt;&gt; hermeint([1, 2, 3]) # integrate once, value 0 at 0.\narray([1., 1., 1., 1.])\n&gt;&gt;&gt; hermeint([1, 2, 3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n&gt;&gt;&gt; hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\narray([2., 1., 1., 1.])\n&gt;&gt;&gt; hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\narray([-1.,  1.,  1.,  1.])\n&gt;&gt;&gt; hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\narray([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayHermite_e series coefficients of the integral.", "examples": ["; from numpy.polynomial.hermite_e import hermeint\n; hermeint([1, 2, 3]) # integrate once, value 0 at 0.\narray([1., 1., 1., 1.])\n; hermeint([1, 2, 3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n; hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\narray([2., 1., 1., 1.])\n; hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\narray([-1.,  1.,  1.,  1.])\n; hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\narray([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n\n", "; from numpy.polynomial.hermite_e import hermeint\n; hermeint([1, 2, 3]) # integrate once, value 0 at 0.\narray([1., 1., 1., 1.])\n; hermeint([1, 2, 3], m=2) # integrate twice, value &amp; deriv 0 at 0\narray([-0.25      ,  1.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n; hermeint([1, 2, 3], k=1) # integrate once, value 1 at 0.\narray([2., 1., 1., 1.])\n; hermeint([1, 2, 3], lbnd=-1) # integrate once, value 0 at -1\narray([-1.,  1.,  1.,  1.])\n; hermeint([1, 2, 3], m=2, k=[1, 2], lbnd=-1)\narray([ 1.83333333,  0.        ,  0.5       ,  0.33333333,  0.25      ]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermegrid3d", "code": "\nnumpy.polynomial.hermite_e.hermegrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nhermeval, hermeval2d, hermegrid2d, hermeval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermegrid2d", "code": "\nnumpy.polynomial.hermite_e.hermegrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D HermiteE series on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nhermeval, hermeval2d, hermeval3d, hermegrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermemulx", "code": "\nnumpy.polynomial.hermite_e.hermemulx(c)[source]\u00b6", "description": "Multiply a Hermite series by x.\nMultiply the Hermite series c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\nNotes\nThe multiplication uses the recursion relationship for Hermite\npolynomials in the form\n\n\nxP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermemulx\n&gt;&gt;&gt; hermemulx([1, 2, 3])\narray([2.,  7.,  2.,  3.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": ["; from numpy.polynomial.hermite_e import hermemulx\n; hermemulx([1, 2, 3])\narray([2.,  7.,  2.,  3.])\n\n", "; from numpy.polynomial.hermite_e import hermemulx\n; hermemulx([1, 2, 3])\narray([2.,  7.,  2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermegauss", "code": "\nnumpy.polynomial.hermite_e.hermegauss(deg)[source]\u00b6", "description": "Gauss-HermiteE quadrature.\nComputes the sample points and weights for Gauss-HermiteE quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree  or less over the interval \nwith the weight function .\n\nParameters\n\ndegintNumber of sample points and weights. It must be &gt;= 1.\n\n\n\nReturns\n\nxndarray1-D ndarray containing the sample points.\n\nyndarray1-D ndarray containing the weights.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nThe results have only been tested up to degree 100, higher degrees may\nbe problematic. The weights are determined by using the fact that\n\n\nwhere  is a constant independent of  and \nis the k\u2019th root of , and then scaling the results to get\nthe right value when integrating 1.\n", "parameters": ["Parameters", "degint", "Returns", "xndarray", "yndarray"], "returns": "xndarray1-D ndarray containing the sample points.yndarray1-D ndarray containing the weights.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermefit", "code": "\nnumpy.polynomial.hermite_e.hermefit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least squares fit of Hermite series to data.\nReturn the coefficients of a HermiteE series of degree deg that is\nthe least squares fit to the data values y given at points x. If\ny is 1-D the returned coefficients will also be 1-D. If y is 2-D\nmultiple fits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\n\n\nReturns\n\ncoefndarray, shape (M,) or (M, K)Hermite coefficients ordered from low to high. If y was 2-D,\nthe coefficients for the data in column k  of y are in column\nk.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.  The\nwarnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\nchebfit, legfit, polyfit, hermfit, polyfit\n\nhermevalEvaluates a Hermite series.\n\nhermevanderpseudo Vandermonde matrix of Hermite series.\n\nhermeweightHermiteE weight function.\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the HermiteE series p that\nminimizes the sum of the weighted squared errors\n\n\nwhere the  are the weights. This problem is solved by\nsetting up the (typically) overdetermined matrix equation\n\n\nwhere V is the pseudo Vandermonde matrix of x, the elements of c\nare the coefficients to be solved for, and the elements of y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected, then a RankWarning will be issued. This means that the\ncoefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The rcond parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\nFits using HermiteE series are probably most useful when the data can\nbe approximated by sqrt(w(x)) * p(x), where w(x) is the HermiteE\nweight. In that case the weight sqrt(w(x[i]) should be used\ntogether with data values y[i]/sqrt(w(x[i]). The weight function is\navailable as hermeweight.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefit, hermeval\n&gt;&gt;&gt; x = np.linspace(-10, 10)\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; err = np.random.randn(len(x))/10\n&gt;&gt;&gt; y = hermeval(x, [1, 2, 3]) + err\n&gt;&gt;&gt; hermefit(x, y, 2)\narray([ 1.01690445,  1.99951418,  2.99948696]) # may vary\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (M,) or (M, K)", "[residuals, rank, singular_values, rcond]list", "Warns", "RankWarning"], "returns": "coefndarray, shape (M,) or (M, K)Hermite coefficients ordered from low to high. If y was 2-D,the coefficients for the data in column k  of y are in columnk.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": ["; from numpy.polynomial.hermite_e import hermefit, hermeval\n; x = np.linspace(-10, 10)\n; np.random.seed(123)\n; err = np.random.randn(len(x))/10\n; y = hermeval(x, [1, 2, 3]) + err\n; hermefit(x, y, 2)\narray([ 1.01690445,  1.99951418,  2.99948696]) # may vary\n\n", "; from numpy.polynomial.hermite_e import hermefit, hermeval\n; x = np.linspace(-10, 10)\n; np.random.seed(123)\n; err = np.random.randn(len(x))/10\n; y = hermeval(x, [1, 2, 3]) + err\n; hermefit(x, y, 2)\narray([ 1.01690445,  1.99951418,  2.99948696]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermedomain", "code": "\nnumpy.polynomial.hermite_e.hermedomain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermefromroots", "code": "\nnumpy.polynomial.hermite_e.hermefromroots(roots)[source]\u00b6", "description": "Generate a HermiteE series with given roots.\nThe function returns the coefficients of the polynomial\n\n\nin HermiteE form, where the r_n are the roots specified in roots.\nIf a zero has multiplicity n, then it must appear in roots n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then roots looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in HermiteE form.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of coefficients.  If all roots are real then out is a\nreal array, if some of the roots are complex, then out is complex\neven if all the coefficients in the result are real (see Examples\nbelow).\n\n\n\n\n\nSee also\npolyfromroots, legfromroots, lagfromroots, hermfromroots, chebfromroots\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermefromroots, hermeval\n&gt;&gt;&gt; coef = hermefromroots((-1, 0, 1))\n&gt;&gt;&gt; hermeval((-1, 0, 1), coef)\narray([0., 0., 0.])\n&gt;&gt;&gt; coef = hermefromroots((-1j, 1j))\n&gt;&gt;&gt; hermeval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of coefficients.  If all roots are real then out is areal array, if some of the roots are complex, then out is complexeven if all the coefficients in the result are real (see Examplesbelow).", "examples": ["; from numpy.polynomial.hermite_e import hermefromroots, hermeval\n; coef = hermefromroots((-1, 0, 1))\n; hermeval((-1, 0, 1), coef)\narray([0., 0., 0.])\n; coef = hermefromroots((-1j, 1j))\n; hermeval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n\n", "; from numpy.polynomial.hermite_e import hermefromroots, hermeval\n; coef = hermefromroots((-1, 0, 1))\n; hermeval((-1, 0, 1), coef)\narray([0., 0., 0.])\n; coef = hermefromroots((-1j, 1j))\n; hermeval((-1j, 1j), coef)\narray([0.+0.j, 0.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermediv", "code": "\nnumpy.polynomial.hermite_e.hermediv(c1, c2)[source]\u00b6", "description": "Divide one Hermite series by another.\nReturns the quotient-with-remainder of two Hermite series\nc1 / c2.  The arguments are sequences of coefficients from lowest\norder \u201cterm\u201d to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\n[quo, rem]ndarraysOf Hermite series coefficients representing the quotient and\nremainder.\n\n\n\n\n\nSee also\nhermeadd, hermesub, hermemulx, hermemul, hermepow\n\nNotes\nIn general, the (polynomial) division of one Hermite series by another\nresults in quotient and remainder terms that are not in the Hermite\npolynomial basis set.  Thus, to express these results as a Hermite\nseries, it is necessary to \u201creproject\u201d the results onto the Hermite\nbasis set, which may produce \u201cunintuitive\u201d (but correct) results; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermediv\n&gt;&gt;&gt; hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n&gt;&gt;&gt; hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 2.]))\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "[quo, rem]ndarrays"], "returns": "[quo, rem]ndarraysOf Hermite series coefficients representing the quotient andremainder.", "examples": ["; from numpy.polynomial.hermite_e import hermediv\n; hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 2.]))\n\n", "; from numpy.polynomial.hermite_e import hermediv\n; hermediv([ 14.,  15.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; hermediv([ 15.,  17.,  28.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 2.]))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeder", "code": "\nnumpy.polynomial.hermite_e.hermeder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a Hermite_e series.\nReturns the series coefficients c differentiated m times along\naxis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable). The argument\nc is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series 1*He_0 + 2*He_1 + 3*He_2\nwhile [[1,2],[1,2]] represents 1*He_0(x)*He_0(y) + 1*He_1(x)*He_0(y)\n+ 2*He_0(x)*He_1(y) + 2*He_1(x)*He_1(y) if axis=0 is x and axis=1\nis y.\n\nParameters\n\ncarray_likeArray of Hermite_e series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change of\nvariable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayHermite series of the derivative.\n\n\n\n\n\nSee also\nhermeint\n\nNotes\nIn general, the result of differentiating a Hermite series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \u201cunintuitive,\u201d albeit correct; see Examples section\nbelow.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeder\n&gt;&gt;&gt; hermeder([ 1.,  1.,  1.,  1.])\narray([1.,  2.,  3.])\n&gt;&gt;&gt; hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\narray([1.,  2.,  3.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayHermite series of the derivative.", "examples": ["; from numpy.polynomial.hermite_e import hermeder\n; hermeder([ 1.,  1.,  1.,  1.])\narray([1.,  2.,  3.])\n; hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\narray([1.,  2.,  3.])\n\n", "; from numpy.polynomial.hermite_e import hermeder\n; hermeder([ 1.,  1.,  1.,  1.])\narray([1.,  2.,  3.])\n; hermeder([-0.25,  1.,  1./2.,  1./3.,  1./4 ], m=2)\narray([1.,  2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermeadd", "code": "\nnumpy.polynomial.hermite_e.hermeadd(c1, c2)[source]\u00b6", "description": "Add one Hermite series to another.\nReturns the sum of two Hermite series c1 + c2.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the Hermite series of their sum.\n\n\n\n\n\nSee also\nhermesub, hermemulx, hermemul, hermediv, hermepow\n\nNotes\nUnlike multiplication, division, etc., the sum of two Hermite series\nis a Hermite series (without having to \u201creproject\u201d the result onto\nthe basis set) so addition, just like that of \u201cstandard\u201d polynomials,\nis simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import hermeadd\n&gt;&gt;&gt; hermeadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the Hermite series of their sum.", "examples": ["; from numpy.polynomial.hermite_e import hermeadd\n; hermeadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n\n", "; from numpy.polynomial.hermite_e import hermeadd\n; hermeadd([1, 2, 3], [1, 2, 3, 4])\narray([2.,  4.,  6.,  4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.hermecompanion", "code": "\nnumpy.polynomial.hermite_e.hermecompanion(c)[source]\u00b6", "description": "Return the scaled companion matrix of c.\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is an HermiteE basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters\n\ncarray_like1-D array of HermiteE series coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayScaled companion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayScaled companion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.herme2poly", "code": "\nnumpy.polynomial.hermite_e.herme2poly(c)[source]\u00b6", "description": "Convert a Hermite series to a polynomial.\nConvert an array representing the coefficients of a Hermite series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \u201cstandard\u201d basis) ordered\nfrom lowest to highest degree.\n\nParameters\n\ncarray_like1-D array containing the Hermite series coefficients, ordered\nfrom lowest order term to highest.\n\n\n\nReturns\n\npolndarray1-D array containing the coefficients of the equivalent polynomial\n(relative to the \u201cstandard\u201d basis) ordered from lowest order term\nto highest.\n\n\n\n\n\nSee also\npoly2herme\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite_e import herme2poly\n&gt;&gt;&gt; herme2poly([  2.,  10.,   2.,   3.])\narray([0.,  1.,  2.,  3.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "polndarray"], "returns": "polndarray1-D array containing the coefficients of the equivalent polynomial(relative to the \u201cstandard\u201d basis) ordered from lowest order termto highest.", "examples": ["; from numpy.polynomial.hermite_e import herme2poly\n; herme2poly([  2.,  10.,   2.,   3.])\narray([0.,  1.,  2.,  3.])\n\n", "; from numpy.polynomial.hermite_e import herme2poly\n; herme2poly([  2.,  10.,   2.,   3.])\narray([0.,  1.,  2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermdomain", "code": "\nnumpy.polynomial.hermite.hermdomain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermdiv", "code": "\nnumpy.polynomial.hermite.hermdiv(c1, c2)[source]\u00b6", "description": "Divide one Hermite series by another.\nReturns the quotient-with-remainder of two Hermite series\nc1 / c2.  The arguments are sequences of coefficients from lowest\norder \u201cterm\u201d to highest, e.g., [1,2,3] represents the series\nP_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\n[quo, rem]ndarraysOf Hermite series coefficients representing the quotient and\nremainder.\n\n\n\n\n\nSee also\nhermadd, hermsub, hermmulx, hermmul, hermpow\n\nNotes\nIn general, the (polynomial) division of one Hermite series by another\nresults in quotient and remainder terms that are not in the Hermite\npolynomial basis set.  Thus, to express these results as a Hermite\nseries, it is necessary to \u201creproject\u201d the results onto the Hermite\nbasis set, which may produce \u201cunintuitive\u201d (but correct) results; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermdiv\n&gt;&gt;&gt; hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n&gt;&gt;&gt; hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([2., 2.]))\n&gt;&gt;&gt; hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "[quo, rem]ndarrays"], "returns": "[quo, rem]ndarraysOf Hermite series coefficients representing the quotient andremainder.", "examples": ["; from numpy.polynomial.hermite import hermdiv\n; hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([2., 2.]))\n; hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n\n", "; from numpy.polynomial.hermite import hermdiv\n; hermdiv([ 52.,  29.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([0.]))\n; hermdiv([ 54.,  31.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([2., 2.]))\n; hermdiv([ 53.,  30.,  52.,   7.,   6.], [0, 1, 2])\n(array([1., 2., 3.]), array([1., 1.]))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermcompanion", "code": "\nnumpy.polynomial.hermite.hermcompanion(c)[source]\u00b6", "description": "Return the scaled companion matrix of c.\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is an Hermite basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters\n\ncarray_like1-D array of Hermite series coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayScaled companion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayScaled companion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermadd", "code": "\nnumpy.polynomial.hermite.hermadd(c1, c2)[source]\u00b6", "description": "Add one Hermite series to another.\nReturns the sum of two Hermite series c1 + c2.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series P_0 + 2*P_1 + 3*P_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Hermite series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the Hermite series of their sum.\n\n\n\n\n\nSee also\nhermsub, hermmulx, hermmul, hermdiv, hermpow\n\nNotes\nUnlike multiplication, division, etc., the sum of two Hermite series\nis a Hermite series (without having to \u201creproject\u201d the result onto\nthe basis set) so addition, just like that of \u201cstandard\u201d polynomials,\nis simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermadd\n&gt;&gt;&gt; hermadd([1, 2, 3], [1, 2, 3, 4])\narray([2., 4., 6., 4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the Hermite series of their sum.", "examples": ["; from numpy.polynomial.hermite import hermadd\n; hermadd([1, 2, 3], [1, 2, 3, 4])\narray([2., 4., 6., 4.])\n\n", "; from numpy.polynomial.hermite import hermadd\n; hermadd([1, 2, 3], [1, 2, 3, 4])\narray([2., 4., 6., 4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.herm2poly", "code": "\nnumpy.polynomial.hermite.herm2poly(c)[source]\u00b6", "description": "Convert a Hermite series to a polynomial.\nConvert an array representing the coefficients of a Hermite series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \u201cstandard\u201d basis) ordered\nfrom lowest to highest degree.\n\nParameters\n\ncarray_like1-D array containing the Hermite series coefficients, ordered\nfrom lowest order term to highest.\n\n\n\nReturns\n\npolndarray1-D array containing the coefficients of the equivalent polynomial\n(relative to the \u201cstandard\u201d basis) ordered from lowest order term\nto highest.\n\n\n\n\n\nSee also\npoly2herm\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import herm2poly\n&gt;&gt;&gt; herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\narray([0., 1., 2., 3.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "polndarray"], "returns": "polndarray1-D array containing the coefficients of the equivalent polynomial(relative to the \u201cstandard\u201d basis) ordered from lowest order termto highest.", "examples": ["; from numpy.polynomial.hermite import herm2poly\n; herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\narray([0., 1., 2., 3.])\n\n", "; from numpy.polynomial.hermite import herm2poly\n; herm2poly([ 1.   ,  2.75 ,  0.5  ,  0.375])\narray([0., 1., 2., 3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.hermder", "code": "\nnumpy.polynomial.hermite.hermder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a Hermite series.\nReturns the Hermite series coefficients c differentiated m times\nalong axis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable). The argument\nc is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series 1*H_0 + 2*H_1 + 3*H_2\nwhile [[1,2],[1,2]] represents 1*H_0(x)*H_0(y) + 1*H_1(x)*H_0(y) +\n2*H_0(x)*H_1(y) + 2*H_1(x)*H_1(y) if axis=0 is x and axis=1 is\ny.\n\nParameters\n\ncarray_likeArray of Hermite series coefficients. If c is multidimensional the\ndifferent axis correspond to different variables with the degree in\neach axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change of\nvariable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayHermite series of the derivative.\n\n\n\n\n\nSee also\nhermint\n\nNotes\nIn general, the result of differentiating a Hermite series does not\nresemble the same operation on a power series. Thus the result of this\nfunction may be \u201cunintuitive,\u201d albeit correct; see Examples section\nbelow.\nExamples\n&gt;&gt;&gt; from numpy.polynomial.hermite import hermder\n&gt;&gt;&gt; hermder([ 1. ,  0.5,  0.5,  0.5])\narray([1., 2., 3.])\n&gt;&gt;&gt; hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([1., 2., 3.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayHermite series of the derivative.", "examples": ["; from numpy.polynomial.hermite import hermder\n; hermder([ 1. ,  0.5,  0.5,  0.5])\narray([1., 2., 3.])\n; hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([1., 2., 3.])\n\n", "; from numpy.polynomial.hermite import hermder\n; hermder([ 1. ,  0.5,  0.5,  0.5])\narray([1., 2., 3.])\n; hermder([-0.5,  1./2.,  1./8.,  1./12.,  1./16.], m=2)\narray([1., 2., 3.])\n"]},
{"library": "numpy", "item_id": "numpy.heaviside", "code": "\nnumpy.heaviside(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'heaviside'&gt;\u00b6", "description": "Compute the Heaviside step function.\nThe Heaviside step function is defined as:\n                      0   if x1 &lt; 0\nheaviside(x1, x2) =  x2   if x1 == 0\n                      1   if x1 &gt; 0\n\n\nwhere x2 is often taken to be 0.5, but 0 and 1 are also sometimes used.\n\nParameters\n\nx1array_likeInput values.\n\nx2array_likeThe value of the function when x1 is 0. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThe output array, element-wise Heaviside step function of x1.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\n\nNew in version 1.13.0.\n\nReferences\nExamples\n&gt;&gt;&gt; np.heaviside([-1.5, 0, 2.0], 0.5)\narray([ 0. ,  0.5,  1. ])\n&gt;&gt;&gt; np.heaviside([-1.5, 0, 2.0], 1)\narray([ 0.,  1.,  1.])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe output array, element-wise Heaviside step function of x1.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.heaviside([-1.5, 0, 2.0], 0.5)\narray([ 0. ,  0.5,  1. ])\n; np.heaviside([-1.5, 0, 2.0], 1)\narray([ 0.,  1.,  1.])\n\n", "; np.heaviside([-1.5, 0, 2.0], 0.5)\narray([ 0. ,  0.5,  1. ])\n; np.heaviside([-1.5, 0, 2.0], 1)\narray([ 0.,  1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.dtype.hasobject", "code": "\ndtype.hasobject\u00b6", "description": "Boolean indicating whether this dtype contains any reference-counted\nobjects in any fields or sub-dtypes.\nRecall that what is actually in the ndarray memory representing\nthe Python object is the memory address of that object (a pointer).\nSpecial handling may be required, and this attribute is useful for\ndistinguishing data types that may contain arbitrary Python objects\nand data-types that won\u2019t.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.has_samewindow", "code": "\nLegendre.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.has_samewindow", "code": "\nLaguerre.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.has_samewindow", "code": "\nChebyshev.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.has_sametype", "code": "\nPolynomial.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.has_samewindow", "code": "\nPolynomial.has_samewindow(self, other)[source]\u00b6", "description": "Check if windows match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the window attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the windows are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the windows are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.has_sametype", "code": "\nLegendre.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.has_sametype", "code": "\nLaguerre.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.has_sametype", "code": "\nHermiteE.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.has_sametype", "code": "\nHermite.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.has_samedomain", "code": "\nPolynomial.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.has_samedomain", "code": "\nLegendre.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.has_samedomain", "code": "\nLaguerre.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.has_samedomain", "code": "\nHermiteE.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.has_sametype", "code": "\nChebyshev.has_sametype(self, other)[source]\u00b6", "description": "Check if types match.\n\nNew in version 1.7.0.\n\n\nParameters\n\notherobjectClass instance.\n\n\n\nReturns\n\nboolbooleanTrue if other is same class as self\n\n\n\n\n", "parameters": ["Parameters", "otherobject", "Returns", "boolboolean"], "returns": "boolbooleanTrue if other is same class as self", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.has_samedomain", "code": "\nHermite.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.has_samedomain", "code": "\nChebyshev.has_samedomain(self, other)[source]\u00b6", "description": "Check if domains match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the domain attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the domains are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the domains are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.has_samecoef", "code": "\nPolynomial.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.has_samecoef", "code": "\nLaguerre.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.has_samecoef", "code": "\nHermiteE.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.has_samecoef", "code": "\nChebyshev.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.has_samecoef", "code": "\nLegendre.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.has_index", "code": "\nnditer.has_index\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.has_samecoef", "code": "\nHermite.has_samecoef(self, other)[source]\u00b6", "description": "Check if coefficients match.\n\nNew in version 1.6.0.\n\n\nParameters\n\notherclass instanceThe other class must have the coef attribute.\n\n\n\nReturns\n\nboolbooleanTrue if the coefficients are the same, False otherwise.\n\n\n\n\n", "parameters": ["Parameters", "otherclass instance", "Returns", "boolboolean"], "returns": "boolbooleanTrue if the coefficients are the same, False otherwise.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.has_multi_index", "code": "\nnditer.has_multi_index\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.distutils.core.Extension.has_f2py_sources", "code": "\nExtension.has_f2py_sources(self)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.has_delayed_bufalloc", "code": "\nnditer.has_delayed_bufalloc\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.distutils.core.Extension.has_cxx_sources", "code": "\nExtension.has_cxx_sources(self)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.hardmask", "code": "\nproperty masked_array.hardmask\u00b6", "description": "Hardness of the mask\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.harden_mask", "code": "\nMaskedArray.harden_mask(self)[source]\u00b6", "description": "Force the mask to hard.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. harden_mask sets hardmask to True.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.harden_mask", "code": "\nmasked_array.harden_mask(self)[source]\u00b6", "description": "Force the mask to hard.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. harden_mask sets hardmask to True.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.harden_mask", "code": "\nnumpy.ma.harden_mask(self) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Force the mask to hard.\nWhether the mask of a masked array is hard or soft is determined by\nits hardmask property. harden_mask sets hardmask to True.\n\nSee also\nhardmask\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.hamming", "code": "\nnumpy.hamming(M)[source]\u00b6", "description": "Return the Hamming window.\nThe Hamming window is a taper formed by using a weighted cosine.\n\nParameters\n\nMintNumber of points in the output window. If zero or less, an\nempty array is returned.\n\n\n\nReturns\n\noutndarrayThe window, with the maximum value normalized to one (the value\none appears only if the number of samples is odd).\n\n\n\n\n\nSee also\nbartlett, blackman, hanning, kaiser\n\nNotes\nThe Hamming window is defined as\n\n\nThe Hamming was named for R. W. Hamming, an associate of J. W. Tukey\nand is described in Blackman and Tukey. It was recommended for\nsmoothing the truncated autocovariance function in the time domain.\nMost references to the Hamming window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\u201cremoving the foot\u201d, i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\nReferences\n\n1\nBlackman, R.B. and Tukey, J.W., (1958) The measurement of power\nspectra, Dover Publications, New York.\n\n2\nE.R. Kanasewich, \u201cTime Sequence Analysis in Geophysics\u201d, The\nUniversity of Alberta Press, 1975, pp. 109-110.\n\n3\nWikipedia, \u201cWindow function\u201d,\nhttps://en.wikipedia.org/wiki/Window_function\n\n4\nW.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n\u201cNumerical Recipes\u201d, Cambridge University Press, 1986, page 425.\n\n\nExamples\n&gt;&gt;&gt; np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n\n\nPlot the window and the frequency response:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from numpy.fft import fft, fftshift\n&gt;&gt;&gt; window = np.hamming(51)\n&gt;&gt;&gt; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Hamming window\")\nText(0.5, 1.0, 'Hamming window')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n&gt;&gt;&gt; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n&gt;&gt;&gt; A = fft(window, 2048) / 25.5\n&gt;&gt;&gt; mag = np.abs(fftshift(A))\n&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))\n&gt;&gt;&gt; response = 20 * np.log10(mag)\n&gt;&gt;&gt; response = np.clip(response, -100, 100)\n&gt;&gt;&gt; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Frequency response of Hamming window\")\nText(0.5, 1.0, 'Frequency response of Hamming window')\n&gt;&gt;&gt; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n&gt;&gt;&gt; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n&gt;&gt;&gt; plt.axis('tight')\n...\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "Mint", "Returns", "outndarray"], "returns": "outndarrayThe window, with the maximum value normalized to one (the valueone appears only if the number of samples is odd).", "examples": ["; np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n\n", "; np.hamming(12)\narray([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary\n        0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,\n        0.15302337,  0.08      ])\n", "; import matplotlib.pyplot as plt\n; from numpy.fft import fft, fftshift\n; window = np.hamming(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Hamming window\")\nText(0.5, 1.0, 'Hamming window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; from numpy.fft import fft, fftshift\n; window = np.hamming(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Hamming window\")\nText(0.5, 1.0, 'Hamming window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; response = 20 * np.log10(mag)\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Hamming window\")\nText(0.5, 1.0, 'Frequency response of Hamming window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n...\n; plt.show()\n\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; response = 20 * np.log10(mag)\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Hamming window\")\nText(0.5, 1.0, 'Frequency response of Hamming window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n...\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.hanning", "code": "\nnumpy.hanning(M)[source]\u00b6", "description": "Return the Hanning window.\nThe Hanning window is a taper formed by using a weighted cosine.\n\nParameters\n\nMintNumber of points in the output window. If zero or less, an\nempty array is returned.\n\n\n\nReturns\n\noutndarray, shape(M,)The window, with the maximum value normalized to one (the value\none appears only if M is odd).\n\n\n\n\n\nSee also\nbartlett, blackman, hamming, kaiser\n\nNotes\nThe Hanning window is defined as\n\n\nThe Hanning was named for Julius von Hann, an Austrian meteorologist.\nIt is also known as the Cosine Bell. Some authors prefer that it be\ncalled a Hann window, to help avoid confusion with the very similar\nHamming window.\nMost references to the Hanning window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\u201cremoving the foot\u201d, i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function.\nReferences\n\n1\nBlackman, R.B. and Tukey, J.W., (1958) The measurement of power\nspectra, Dover Publications, New York.\n\n2\nE.R. Kanasewich, \u201cTime Sequence Analysis in Geophysics\u201d,\nThe University of Alberta Press, 1975, pp. 106-108.\n\n3\nWikipedia, \u201cWindow function\u201d,\nhttps://en.wikipedia.org/wiki/Window_function\n\n4\nW.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n\u201cNumerical Recipes\u201d, Cambridge University Press, 1986, page 425.\n\n\nExamples\n&gt;&gt;&gt; np.hanning(12)\narray([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n       0.07937323, 0.        ])\n\n\nPlot the window and its frequency response:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; from numpy.fft import fft, fftshift\n&gt;&gt;&gt; window = np.hanning(51)\n&gt;&gt;&gt; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Hann window\")\nText(0.5, 1.0, 'Hann window')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n&gt;&gt;&gt; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n&gt;&gt;&gt; A = fft(window, 2048) / 25.5\n&gt;&gt;&gt; mag = np.abs(fftshift(A))\n&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))\n&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n&gt;&gt;&gt; response = np.clip(response, -100, 100)\n&gt;&gt;&gt; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Frequency response of the Hann window\")\nText(0.5, 1.0, 'Frequency response of the Hann window')\n&gt;&gt;&gt; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n&gt;&gt;&gt; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n&gt;&gt;&gt; plt.axis('tight')\n...\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "Mint", "Returns", "outndarray, shape(M,)"], "returns": "outndarray, shape(M,)The window, with the maximum value normalized to one (the valueone appears only if M is odd).", "examples": ["; np.hanning(12)\narray([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n       0.07937323, 0.        ])\n\n", "; np.hanning(12)\narray([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,\n       0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,\n       0.07937323, 0.        ])\n", "; import matplotlib.pyplot as plt\n; from numpy.fft import fft, fftshift\n; window = np.hanning(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Hann window\")\nText(0.5, 1.0, 'Hann window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; from numpy.fft import fft, fftshift\n; window = np.hanning(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Hann window\")\nText(0.5, 1.0, 'Hann window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of the Hann window\")\nText(0.5, 1.0, 'Frequency response of the Hann window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n...\n; plt.show()\n\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of the Hann window\")\nText(0.5, 1.0, 'Frequency response of the Hann window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; plt.axis('tight')\n...\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.matrix.H", "code": "\nproperty matrix.H\u00b6", "description": "Returns the (complex) conjugate transpose of self.\nEquivalent to np.transpose(self) if self is real-valued.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectcomplex conjugate transpose of self\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4)))\n&gt;&gt;&gt; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n&gt;&gt;&gt; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object"], "returns": "retmatrix objectcomplex conjugate transpose of self", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4)))\n; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4)))\n; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.gumbel", "code": "\nRandomState.gumbel(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gumbel distribution.\nDraw samples from a Gumbel distribution with specified location and\nscale.  For more information on the Gumbel distribution, see\nNotes and References below.\n\nNote\nNew code should use the gumbel method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalThe location of the mode of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalThe scale parameter of the distribution. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Gumbel distribution.\n\n\n\n\n\nSee also\nscipy.stats.gumbel_l, scipy.stats.gumbel_r, scipy.stats.genextreme, weibull\n\nGenerator.gumbelwhich should be used for new code.\n\n\n\nNotes\nThe Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme\nValue Type I) distribution is one of a class of Generalized Extreme\nValue (GEV) distributions used in modeling extreme value problems.\nThe Gumbel is a special case of the Extreme Value Type I distribution\nfor maximums from distributions with \u201cexponential-like\u201d tails.\nThe probability density for the Gumbel distribution is\n\n\nwhere  is the mode, a location parameter, and\n is the scale parameter.\nThe Gumbel (named for German mathematician Emil Julius Gumbel) was used\nvery early in the hydrology literature, for modeling the occurrence of\nflood events. It is also used for modeling maximum wind speed and\nrainfall rates.  It is a \u201cfat-tailed\u201d distribution - the probability of\nan event in the tail of the distribution is larger than if one used a\nGaussian, hence the surprisingly frequent occurrence of 100-year\nfloods. Floods were initially modeled as a Gaussian process, which\nunderestimated the frequency of extreme events.\nIt is one of a class of extreme value distributions, the Generalized\nExtreme Value (GEV) distributions, which also includes the Weibull and\nFrechet.\nThe function has a mean of  and a variance\nof .\nReferences\n\n1\nGumbel, E. J., \u201cStatistics of Extremes,\u201d\nNew York: Columbia University Press, 1958.\n\n2\nReiss, R.-D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues from Insurance, Finance, Hydrology and Other Fields,\u201d\nBasel: Birkhauser Verlag, 2001.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, beta = 0, 0.1 # location and scale\n&gt;&gt;&gt; s = np.random.gumbel(mu, beta, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nShow how an extreme value distribution can arise from a Gaussian process\nand compare to a Gaussian:\n&gt;&gt;&gt; means = []\n&gt;&gt;&gt; maxima = []\n&gt;&gt;&gt; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n&gt;&gt;&gt; count, bins, ignored = plt.hist(maxima, 30, density=True)\n&gt;&gt;&gt; beta = np.std(maxima) * np.sqrt(6) / np.pi\n&gt;&gt;&gt; mu = np.mean(maxima) - 0.57721*beta\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Gumbel distribution.", "examples": ["; mu, beta = 0, 0.1 # location and scale\n; s = np.random.gumbel(mu, beta, 1000)\n\n", "; mu, beta = 0, 0.1 # location and scale\n; s = np.random.gumbel(mu, beta, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.gumbel", "code": "\nnumpy.random.gumbel(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gumbel distribution.\nDraw samples from a Gumbel distribution with specified location and\nscale.  For more information on the Gumbel distribution, see\nNotes and References below.\n\nNote\nNew code should use the gumbel method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlocfloat or array_like of floats, optionalThe location of the mode of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalThe scale parameter of the distribution. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Gumbel distribution.\n\n\n\n\n\nSee also\nscipy.stats.gumbel_l, scipy.stats.gumbel_r, scipy.stats.genextreme, weibull\n\nGenerator.gumbelwhich should be used for new code.\n\n\n\nNotes\nThe Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme\nValue Type I) distribution is one of a class of Generalized Extreme\nValue (GEV) distributions used in modeling extreme value problems.\nThe Gumbel is a special case of the Extreme Value Type I distribution\nfor maximums from distributions with \u201cexponential-like\u201d tails.\nThe probability density for the Gumbel distribution is\n\n\nwhere  is the mode, a location parameter, and\n is the scale parameter.\nThe Gumbel (named for German mathematician Emil Julius Gumbel) was used\nvery early in the hydrology literature, for modeling the occurrence of\nflood events. It is also used for modeling maximum wind speed and\nrainfall rates.  It is a \u201cfat-tailed\u201d distribution - the probability of\nan event in the tail of the distribution is larger than if one used a\nGaussian, hence the surprisingly frequent occurrence of 100-year\nfloods. Floods were initially modeled as a Gaussian process, which\nunderestimated the frequency of extreme events.\nIt is one of a class of extreme value distributions, the Generalized\nExtreme Value (GEV) distributions, which also includes the Weibull and\nFrechet.\nThe function has a mean of  and a variance\nof .\nReferences\n\n1\nGumbel, E. J., \u201cStatistics of Extremes,\u201d\nNew York: Columbia University Press, 1958.\n\n2\nReiss, R.-D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues from Insurance, Finance, Hydrology and Other Fields,\u201d\nBasel: Birkhauser Verlag, 2001.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; mu, beta = 0, 0.1 # location and scale\n&gt;&gt;&gt; s = np.random.gumbel(mu, beta, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nShow how an extreme value distribution can arise from a Gaussian process\nand compare to a Gaussian:\n&gt;&gt;&gt; means = []\n&gt;&gt;&gt; maxima = []\n&gt;&gt;&gt; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n&gt;&gt;&gt; count, bins, ignored = plt.hist(maxima, 30, density=True)\n&gt;&gt;&gt; beta = np.std(maxima) * np.sqrt(6) / np.pi\n&gt;&gt;&gt; mu = np.mean(maxima) - 0.57721*beta\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Gumbel distribution.", "examples": ["; mu, beta = 0, 0.1 # location and scale\n; s = np.random.gumbel(mu, beta, 1000)\n\n", "; mu, beta = 0, 0.1 # location and scale\n; s = np.random.gumbel(mu, beta, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = np.random.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.gumbel", "code": "\nGenerator.gumbel(loc=0.0, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gumbel distribution.\nDraw samples from a Gumbel distribution with specified location and\nscale.  For more information on the Gumbel distribution, see\nNotes and References below.\n\nParameters\n\nlocfloat or array_like of floats, optionalThe location of the mode of the distribution. Default is 0.\n\nscalefloat or array_like of floats, optionalThe scale parameter of the distribution. Default is 1. Must be non-\nnegative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if loc and scale are both scalars.\nOtherwise, np.broadcast(loc, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Gumbel distribution.\n\n\n\n\n\nSee also\nscipy.stats.gumbel_l, scipy.stats.gumbel_r, scipy.stats.genextreme, weibull\n\nNotes\nThe Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme\nValue Type I) distribution is one of a class of Generalized Extreme\nValue (GEV) distributions used in modeling extreme value problems.\nThe Gumbel is a special case of the Extreme Value Type I distribution\nfor maximums from distributions with \u201cexponential-like\u201d tails.\nThe probability density for the Gumbel distribution is\n\n\nwhere  is the mode, a location parameter, and\n is the scale parameter.\nThe Gumbel (named for German mathematician Emil Julius Gumbel) was used\nvery early in the hydrology literature, for modeling the occurrence of\nflood events. It is also used for modeling maximum wind speed and\nrainfall rates.  It is a \u201cfat-tailed\u201d distribution - the probability of\nan event in the tail of the distribution is larger than if one used a\nGaussian, hence the surprisingly frequent occurrence of 100-year\nfloods. Floods were initially modeled as a Gaussian process, which\nunderestimated the frequency of extreme events.\nIt is one of a class of extreme value distributions, the Generalized\nExtreme Value (GEV) distributions, which also includes the Weibull and\nFrechet.\nThe function has a mean of  and a variance\nof .\nReferences\n\n1\nGumbel, E. J., \u201cStatistics of Extremes,\u201d\nNew York: Columbia University Press, 1958.\n\n2\nReiss, R.-D. and Thomas, M., \u201cStatistical Analysis of Extreme\nValues from Insurance, Finance, Hydrology and Other Fields,\u201d\nBasel: Birkhauser Verlag, 2001.\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; mu, beta = 0, 0.1 # location and scale\n&gt;&gt;&gt; s = rng.gumbel(mu, beta, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 30, density=True)\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nShow how an extreme value distribution can arise from a Gaussian process\nand compare to a Gaussian:\n&gt;&gt;&gt; means = []\n&gt;&gt;&gt; maxima = []\n&gt;&gt;&gt; for i in range(0,1000) :\n...    a = rng.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n&gt;&gt;&gt; count, bins, ignored = plt.hist(maxima, 30, density=True)\n&gt;&gt;&gt; beta = np.std(maxima) * np.sqrt(6) / np.pi\n&gt;&gt;&gt; mu = np.mean(maxima) - 0.57721*beta\n&gt;&gt;&gt; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n&gt;&gt;&gt; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "locfloat or array_like of floats, optional", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Gumbel distribution.", "examples": ["; rng = np.random.default_rng()\n; mu, beta = 0, 0.1 # location and scale\n; s = rng.gumbel(mu, beta, 1000)\n\n", "; rng = np.random.default_rng()\n; mu, beta = 0, 0.1 # location and scale\n; s = rng.gumbel(mu, beta, 1000)\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; count, bins, ignored = plt.hist(s, 30, density=True)\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp( -np.exp( -(bins - mu) /beta) ),\n...          linewidth=2, color='r')\n; plt.show()\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = rng.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n\n", "; means = []\n; maxima = []\n; for i in range(0,1000) :\n...    a = rng.normal(mu, beta, 1000)\n...    means.append(a.mean())\n...    maxima.append(a.max())\n; count, bins, ignored = plt.hist(maxima, 30, density=True)\n; beta = np.std(maxima) * np.sqrt(6) / np.pi\n; mu = np.mean(maxima) - 0.57721*beta\n; plt.plot(bins, (1/beta)*np.exp(-(bins - mu)/beta)\n...          * np.exp(-np.exp(-(bins - mu)/beta)),\n...          linewidth=2, color='r')\n; plt.plot(bins, 1/(beta * np.sqrt(2 * np.pi))\n...          * np.exp(-(bins - mu)**2 / (2 * beta**2)),\n...          linewidth=2, color='g')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.char.greater_equal", "code": "\nnumpy.char.greater_equal(x1, x2)\u00b6", "description": "Return (x1 &gt;= x2) element-wise.\nUnlike numpy.greater_equal, this comparison is performed by\nfirst stripping whitespace characters from the end of the string.\nThis behavior is provided for backward-compatibility with\nnumarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, not_equal, less_equal, greater, less\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.greater_equal", "code": "\nnumpy.greater_equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'greater_equal'&gt;\u00b6", "description": "Return the truth value of (x1 &gt;= x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutbool or ndarray of boolOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\ngreater, less, less_equal, equal, not_equal\n\nExamples\n&gt;&gt;&gt; np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outbool or ndarray of bool"], "returns": "outbool or ndarray of boolOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])\n\n", "; np.greater_equal([4, 2, 1], [2, 2, 2])\narray([ True, True, False])\n"]},
{"library": "numpy", "item_id": "numpy.char.greater", "code": "\nnumpy.char.greater(x1, x2)\u00b6", "description": "Return (x1 &gt; x2) element-wise.\nUnlike numpy.greater, this comparison is performed by first\nstripping whitespace characters from the end of the string.  This\nbehavior is provided for backward-compatibility with numarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nequal, not_equal, greater_equal, less_equal, less\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.greater", "code": "\nnumpy.greater(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'greater'&gt;\u00b6", "description": "Return the truth value of (x1 &gt; x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\ngreater_equal, less, less_equal, equal, not_equal\n\nExamples\n&gt;&gt;&gt; np.greater([4,2],[2,2])\narray([ True, False])\n\n\nIf the inputs are ndarrays, then np.greater is equivalent to \u2018&gt;\u2019.\n&gt;&gt;&gt; a = np.array([4,2])\n&gt;&gt;&gt; b = np.array([2,2])\n&gt;&gt;&gt; a &gt; b\narray([ True, False])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.greater([4,2],[2,2])\narray([ True, False])\n\n", "; np.greater([4,2],[2,2])\narray([ True, False])\n", "; a = np.array([4,2])\n; b = np.array([2,2])\n; a &gt; b\narray([ True, False])\n\n", "; a = np.array([4,2])\n; b = np.array([2,2])\n; a &gt; b\narray([ True, False])\n"]},
{"library": "numpy", "item_id": "numpy.gradient", "code": "\nnumpy.gradient(f, *varargs, **kwargs)[source]\u00b6", "description": "Return the gradient of an N-dimensional array.\nThe gradient is computed using second order accurate central differences\nin the interior points and either first or second order accurate one-sides\n(forward or backwards) differences at the boundaries.\nThe returned gradient hence has the same shape as the input array.\n\nParameters\n\nfarray_likeAn N-dimensional array containing samples of a scalar function.\n\nvarargslist of scalar or array, optionalSpacing between f values. Default unitary spacing for all dimensions.\nSpacing can be specified using:\n\nsingle scalar to specify a sample distance for all dimensions.\nN scalars to specify a constant sample distance for each dimension.\ni.e. dx, dy, dz, \u2026\nN arrays to specify the coordinates of the values along each\ndimension of F. The length of the array must match the size of\nthe corresponding dimension\nAny combination of N scalars/arrays with the meaning of 2. and 3.\n\nIf axis is given, the number of varargs must equal the number of axes.\nDefault: 1.\n\nedge_order{1, 2}, optionalGradient is calculated using N-th order accurate differences\nat the boundaries. Default: 1.\n\nNew in version 1.9.1.\n\n\naxisNone or int or tuple of ints, optionalGradient is calculated only along the given axis or axes\nThe default (axis = None) is to calculate the gradient for all the axes\nof the input array. axis may be negative, in which case it counts from\nthe last to the first axis.\n\nNew in version 1.11.0.\n\n\n\n\nReturns\n\ngradientndarray or list of ndarrayA set of ndarrays (or a single ndarray if there is only one dimension)\ncorresponding to the derivatives of f with respect to each dimension.\nEach derivative has the same shape as f.\n\n\n\n\nNotes\nAssuming that  (i.e.,  has at least 3 continuous\nderivatives) and let  be a non-homogeneous stepsize, we\nminimize the \u201cconsistency error\u201d  between the true gradient\nand its estimate from a linear combination of the neighboring grid-points:\n\n\nBy substituting  and \nwith their Taylor series expansion, this translates into solving\nthe following the linear system:\n\n\nThe resulting approximation of  is the following:\n\n\nIt is worth noting that if \n(i.e., data are evenly spaced)\nwe find the standard second order approximation:\n\n\nWith a similar procedure the forward/backward approximations used for\nboundaries can be derived.\nReferences\n\n1\nQuarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics\n(Texts in Applied Mathematics). New York: Springer.\n\n2\nDurran D. R. (1999) Numerical Methods for Wave Equations\nin Geophysical Fluid Dynamics. New York: Springer.\n\n3\nFornberg B. (1988) Generation of Finite Difference Formulas on\nArbitrarily Spaced Grids,\nMathematics of Computation 51, no. 184 : 699-706.\nPDF.\n\n\nExamples\n&gt;&gt;&gt; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)\n&gt;&gt;&gt; np.gradient(f)\narray([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n&gt;&gt;&gt; np.gradient(f, 2)\narray([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n\nSpacing can be also specified with an array that represents the coordinates\nof the values F along the dimensions.\nFor instance a uniform spacing:\n&gt;&gt;&gt; x = np.arange(f.size)\n&gt;&gt;&gt; np.gradient(f, x)\narray([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n\n\nOr a non uniform one:\n&gt;&gt;&gt; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)\n&gt;&gt;&gt; np.gradient(f, x)\narray([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n\n\nFor two dimensional arrays, the return will be two arrays ordered by\naxis. In this example the first array stands for the gradient in\nrows and the second one in columns direction:\n&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))\n[array([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],\n       [1. , 1. , 1. ]])]\n\n\nIn this example the spacing is also specified:\nuniform for axis=0 and non uniform for axis=1\n&gt;&gt;&gt; dx = 2.\n&gt;&gt;&gt; y = [1., 1.5, 3.5]\n&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)\n[array([[ 1. ,  1. , -0.5],\n       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],\n       [2. , 1.7, 0.5]])]\n\n\nIt is possible to specify how boundaries are treated using edge_order\n&gt;&gt;&gt; x = np.array([0, 1, 2, 3, 4])\n&gt;&gt;&gt; f = x**2\n&gt;&gt;&gt; np.gradient(f, edge_order=1)\narray([1.,  2.,  4.,  6.,  7.])\n&gt;&gt;&gt; np.gradient(f, edge_order=2)\narray([0., 2., 4., 6., 8.])\n\n\nThe axis keyword can be used to specify a subset of axes of which the\ngradient is calculated\n&gt;&gt;&gt; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)\narray([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]])\n\n\n", "parameters": ["Parameters", "farray_like", "varargslist of scalar or array, optional", "edge_order{1, 2}, optional", "axisNone or int or tuple of ints, optional", "Returns", "gradientndarray or list of ndarray"], "returns": "gradientndarray or list of ndarrayA set of ndarrays (or a single ndarray if there is only one dimension)corresponding to the derivatives of f with respect to each dimension.Each derivative has the same shape as f.", "examples": ["; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)\n; np.gradient(f)\narray([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n; np.gradient(f, 2)\narray([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n\n", "; f = np.array([1, 2, 4, 7, 11, 16], dtype=float)\n; np.gradient(f)\narray([1. , 1.5, 2.5, 3.5, 4.5, 5. ])\n; np.gradient(f, 2)\narray([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])\n", "; x = np.arange(f.size)\n; np.gradient(f, x)\narray([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n\n", "; x = np.arange(f.size)\n; np.gradient(f, x)\narray([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])\n", "; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)\n; np.gradient(f, x)\narray([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n\n", "; x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)\n; np.gradient(f, x)\narray([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])\n", "; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))\n[array([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],\n       [1. , 1. , 1. ]])]\n\n", "; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))\n[array([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],\n       [1. , 1. , 1. ]])]\n", "; dx = 2.\n; y = [1., 1.5, 3.5]\n; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)\n[array([[ 1. ,  1. , -0.5],\n       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],\n       [2. , 1.7, 0.5]])]\n\n", "; dx = 2.\n; y = [1., 1.5, 3.5]\n; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)\n[array([[ 1. ,  1. , -0.5],\n       [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],\n       [2. , 1.7, 0.5]])]\n", "; x = np.array([0, 1, 2, 3, 4])\n; f = x**2\n; np.gradient(f, edge_order=1)\narray([1.,  2.,  4.,  6.,  7.])\n; np.gradient(f, edge_order=2)\narray([0., 2., 4., 6., 8.])\n\n", "; x = np.array([0, 1, 2, 3, 4])\n; f = x**2\n; np.gradient(f, edge_order=1)\narray([1.,  2.,  4.,  6.,  7.])\n; np.gradient(f, edge_order=2)\narray([0., 2., 4., 6., 8.])\n", "; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)\narray([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]])\n\n", "; np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)\narray([[ 2.,  2., -1.],\n       [ 2.,  2., -1.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.getT", "code": "\nmatrix.getT(self)[source]\u00b6", "description": "Returns the transpose of the matrix.\nDoes not conjugate!  For the complex conjugate transpose, use .H.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectThe (non-conjugated) transpose of the matrix.\n\n\n\n\n\nSee also\ntranspose, getH\n\nExamples\n&gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]')\n&gt;&gt;&gt; m\nmatrix([[1, 2],\n        [3, 4]])\n&gt;&gt;&gt; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object"], "returns": "retmatrix objectThe (non-conjugated) transpose of the matrix.", "examples": ["; m = np.matrix('[1, 2; 3, 4]')\n; m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n\n", "; m = np.matrix('[1, 2; 3, 4]')\n; m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getT()\nmatrix([[1, 3],\n        [2, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.getmaskarray", "code": "\nnumpy.ma.getmaskarray(arr)[source]\u00b6", "description": "Return the mask of a masked array, or full boolean array of False.\nReturn the mask of arr as an ndarray if arr is a MaskedArray and\nthe mask is not nomask, else return a full boolean array of False of\nthe same shape as arr.\n\nParameters\n\narrarray_likeInput MaskedArray for which the mask is required.\n\n\n\n\n\nSee also\n\ngetmaskReturn the mask of a masked array, or nomask.\n\ngetdataReturn the data of a masked array as an ndarray.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n&gt;&gt;&gt; ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]])\n\n\nResult when mask == nomask\n&gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])\n&gt;&gt;&gt; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n&gt;&gt;&gt; ma.getmaskarray(b)\narray([[False, False],\n       [False, False]])\n\n\n", "parameters": ["Parameters", "arrarray_like"], "returns": [], "examples": ["; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]])\n\n", "; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getmaskarray(a)\narray([[False,  True],\n       [False, False]])\n", "; b = ma.masked_array([[1,2],[3,4]])\n; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; ma.getmaskarray(b)\narray([[False, False],\n       [False, False]])\n\n", "; b = ma.masked_array([[1,2],[3,4]])\n; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; ma.getmaskarray(b)\narray([[False, False],\n       [False, False]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.getI", "code": "\nmatrix.getI(self)[source]\u00b6", "description": "Returns the (multiplicative) inverse of invertible self.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectIf self is non-singular, ret is such that ret * self ==\nself * ret == np.matrix(np.eye(self[0,:].size) all return\nTrue.\n\n\n\nRaises\n\nnumpy.linalg.LinAlgError: Singular matrixIf self is singular.\n\n\n\n\n\nSee also\nlinalg.inv\n\nExamples\n&gt;&gt;&gt; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n&gt;&gt;&gt; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n&gt;&gt;&gt; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object", "Raises", "numpy.linalg.LinAlgError: Singular matrix"], "returns": "retmatrix objectIf self is non-singular, ret is such that ret * self ==self * ret == np.matrix(np.eye(self[0,:].size) all returnTrue.", "examples": ["; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n\n", "; m = np.matrix('[1, 2; 3, 4]'); m\nmatrix([[1, 2],\n        [3, 4]])\n; m.getI()\nmatrix([[-2. ,  1. ],\n        [ 1.5, -0.5]])\n; m.getI() * m\nmatrix([[ 1.,  0.], # may vary\n        [ 0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.getH", "code": "\nmatrix.getH(self)[source]\u00b6", "description": "Returns the (complex) conjugate transpose of self.\nEquivalent to np.transpose(self) if self is real-valued.\n\nParameters\n\nNone\n\n\nReturns\n\nretmatrix objectcomplex conjugate transpose of self\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4)))\n&gt;&gt;&gt; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n&gt;&gt;&gt; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retmatrix object"], "returns": "retmatrix objectcomplex conjugate transpose of self", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4)))\n; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4)))\n; z = x - 1j*x; z\nmatrix([[  0. +0.j,   1. -1.j,   2. -2.j,   3. -3.j],\n        [  4. -4.j,   5. -5.j,   6. -6.j,   7. -7.j],\n        [  8. -8.j,   9. -9.j,  10.-10.j,  11.-11.j]])\n; z.getH()\nmatrix([[ 0. -0.j,  4. +4.j,  8. +8.j],\n        [ 1. +1.j,  5. +5.j,  9. +9.j],\n        [ 2. +2.j,  6. +6.j, 10.+10.j],\n        [ 3. +3.j,  7. +7.j, 11.+11.j]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.getmask", "code": "\nnumpy.ma.getmask(a)[source]\u00b6", "description": "Return the mask of a masked array, or nomask.\nReturn the mask of a as an ndarray if a is a MaskedArray and the\nmask is not nomask, else return nomask. To guarantee a full array\nof booleans of the same shape as a, use getmaskarray.\n\nParameters\n\naarray_likeInput MaskedArray for which the mask is required.\n\n\n\n\n\nSee also\n\ngetdataReturn the data of a masked array as an ndarray.\n\ngetmaskarrayReturn the mask of a masked array, or full array of False.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n&gt;&gt;&gt; ma.getmask(a)\narray([[False,  True],\n       [False, False]])\n\n\nEquivalently use the MaskedArray mask attribute.\n&gt;&gt;&gt; a.mask\narray([[False,  True],\n       [False, False]])\n\n\nResult when mask == nomask\n&gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])\n&gt;&gt;&gt; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n&gt;&gt;&gt; ma.nomask\nFalse\n&gt;&gt;&gt; ma.getmask(b) == ma.nomask\nTrue\n&gt;&gt;&gt; b.mask == ma.nomask\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like"], "returns": [], "examples": ["; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getmask(a)\narray([[False,  True],\n       [False, False]])\n\n", "; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getmask(a)\narray([[False,  True],\n       [False, False]])\n", "; a.mask\narray([[False,  True],\n       [False, False]])\n\n", "; a.mask\narray([[False,  True],\n       [False, False]])\n", "; b = ma.masked_array([[1,2],[3,4]])\n; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; ma.nomask\nFalse\n; ma.getmask(b) == ma.nomask\nTrue\n; b.mask == ma.nomask\nTrue\n\n", "; b = ma.masked_array([[1,2],[3,4]])\n; b\nmasked_array(\n  data=[[1, 2],\n        [3, 4]],\n  mask=False,\n  fill_value=999999)\n; ma.nomask\nFalse\n; ma.getmask(b) == ma.nomask\nTrue\n; b.mask == ma.nomask\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.getfield", "code": "\nndarray.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.getfield", "code": "\nrecarray.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.record.getfield", "code": "\nrecord.getfield()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.getfield", "code": "\nmemmap.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.geterrcall", "code": "\nnumpy.geterrcall()[source]\u00b6", "description": "Return the current callback function used on floating-point errors.\nWhen the error handling for a floating-point error (one of \u201cdivide\u201d,\n\u201cover\u201d, \u201cunder\u201d, or \u201cinvalid\u201d) is set to \u2018call\u2019 or \u2018log\u2019, the function\nthat is called or the log instance that is written to is returned by\ngeterrcall. This function or log instance has been set with\nseterrcall.\n\nReturns\n\nerrobjcallable, log instance or NoneThe current error handler. If no handler was set through seterrcall,\nNone is returned.\n\n\n\n\n\nSee also\nseterrcall, seterr, geterr\n\nNotes\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see seterr.\nExamples\n&gt;&gt;&gt; np.geterrcall()  # we did not yet set a handler, returns None\n\n\n&gt;&gt;&gt; oldsettings = np.seterr(all='call')\n&gt;&gt;&gt; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n&gt;&gt;&gt; oldhandler = np.seterrcall(err_handler)\n&gt;&gt;&gt; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n\n&gt;&gt;&gt; cur_handler = np.geterrcall()\n&gt;&gt;&gt; cur_handler is err_handler\nTrue\n\n\n", "parameters": [], "returns": "errobjcallable, log instance or NoneThe current error handler. If no handler was set through seterrcall,None is returned.", "examples": ["; np.geterrcall()  # we did not yet set a handler, returns None\n\n", "; np.geterrcall()  # we did not yet set a handler, returns None\n", "; oldsettings = np.seterr(all='call')\n; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n; oldhandler = np.seterrcall(err_handler)\n; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n\n", "; oldsettings = np.seterr(all='call')\n; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n; oldhandler = np.seterrcall(err_handler)\n; np.array([1, 2, 3]) / 0.0\nFloating point error (divide by zero), with flag 1\narray([inf, inf, inf])\n", "; cur_handler = np.geterrcall()\n; cur_handler is err_handler\nTrue\n\n", "; cur_handler = np.geterrcall()\n; cur_handler is err_handler\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.geterr", "code": "\nnumpy.geterr()[source]\u00b6", "description": "Get the current way of handling floating-point errors.\n\nReturns\n\nresdictA dictionary with keys \u201cdivide\u201d, \u201cover\u201d, \u201cunder\u201d, and \u201cinvalid\u201d,\nwhose values are from the strings \u201cignore\u201d, \u201cprint\u201d, \u201clog\u201d, \u201cwarn\u201d,\n\u201craise\u201d, and \u201ccall\u201d. The keys represent possible floating-point\nexceptions, and the values define how these exceptions are handled.\n\n\n\n\n\nSee also\ngeterrcall, seterr, seterrcall\n\nNotes\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see seterr.\nExamples\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; sorted(np.geterr().items())\n[('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]\n&gt;&gt;&gt; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n\n\n&gt;&gt;&gt; oldsettings = np.seterr(all='warn', over='raise')\n&gt;&gt;&gt; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])\n&gt;&gt;&gt; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n\n\n", "parameters": [], "returns": "resdictA dictionary with keys \u201cdivide\u201d, \u201cover\u201d, \u201cunder\u201d, and \u201cinvalid\u201d,whose values are from the strings \u201cignore\u201d, \u201cprint\u201d, \u201clog\u201d, \u201cwarn\u201d,\u201craise\u201d, and \u201ccall\u201d. The keys represent possible floating-pointexceptions, and the values define how these exceptions are handled.", "examples": ["; from collections import OrderedDict\n; sorted(np.geterr().items())\n[('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]\n; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n\n", "; from collections import OrderedDict\n; sorted(np.geterr().items())\n[('divide', 'warn'), ('invalid', 'warn'), ('over', 'warn'), ('under', 'ignore')]\n; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n", "; oldsettings = np.seterr(all='warn', over='raise')\n; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])\n; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n\n", "; oldsettings = np.seterr(all='warn', over='raise')\n; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'warn'), ('invalid', 'warn'), ('over', 'raise'), ('under', 'warn')])\n; np.arange(3.) / np.arange(3.)\narray([nan,  1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.getfield", "code": "\nchararray.getfield(dtype, offset=0)\u00b6", "description": "Returns a field of the given array as a certain type.\nA field is a view of the array data with a given data-type. The values in\nthe view are determined by the given type and the offset into the current\narray in bytes. The offset needs to be such that the view dtype fits in the\narray dtype; for example an array of dtype complex128 has 16-byte elements.\nIf taking a view with a 32-bit integer (4 bytes), the offset needs to be\nbetween 0 and 12 bytes.\n\nParameters\n\ndtypestr or dtypeThe data type of the view. The dtype size of the view can not be larger\nthan that of the array itself.\n\noffsetintNumber of bytes to skip before beginning the element view.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.diag([1.+1.j]*2)\n&gt;&gt;&gt; x[1, 1] = 2 + 4.j\n&gt;&gt;&gt; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n&gt;&gt;&gt; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n\nBy choosing an offset of 8 bytes we can select the complex part of the\narray for our view:\n&gt;&gt;&gt; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "offsetint"], "returns": [], "examples": ["; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n\n", "; x = np.diag([1.+1.j]*2)\n; x[1, 1] = 2 + 4.j\n; x\narray([[1.+1.j,  0.+0.j],\n       [0.+0.j,  2.+4.j]])\n; x.getfield(np.float64)\narray([[1.,  0.],\n       [0.,  2.]])\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n\n", "; x.getfield(np.float64, offset=8)\narray([[1.,  0.],\n       [0.,  4.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.getdata", "code": "\nnumpy.ma.getdata(a, subok=True)[source]\u00b6", "description": "Return the data of a masked array as an ndarray.\nReturn the data of a (if any) as an ndarray if a is a MaskedArray,\nelse return a as a ndarray or subclass (depending on subok) if not.\n\nParameters\n\naarray_likeInput MaskedArray, alternatively a ndarray or a subclass thereof.\n\nsubokboolWhether to force the output to be a pure ndarray (False) or to\nreturn a subclass of ndarray if appropriate (True, default).\n\n\n\n\n\nSee also\n\ngetmaskReturn the mask of a masked array, or nomask.\n\ngetmaskarrayReturn the mask of a masked array, or full array of False.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n&gt;&gt;&gt; ma.getdata(a)\narray([[1, 2],\n       [3, 4]])\n\n\nEquivalently use the MaskedArray data attribute.\n&gt;&gt;&gt; a.data\narray([[1, 2],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "aarray_like", "subokbool"], "returns": [], "examples": ["; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getdata(a)\narray([[1, 2],\n       [3, 4]])\n\n", "; import numpy.ma as ma\n; a = ma.masked_equal([[1,2],[3,4]], 2)\n; a\nmasked_array(\n  data=[[1, --],\n        [3, 4]],\n  mask=[[False,  True],\n        [False, False]],\n  fill_value=2)\n; ma.getdata(a)\narray([[1, 2],\n       [3, 4]])\n", "; a.data\narray([[1, 2],\n       [3, 4]])\n\n", "; a.data\narray([[1, 2],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.getdomain", "code": "\nnumpy.polynomial.polyutils.getdomain(x)[source]\u00b6", "description": "Return a domain suitable for given abscissae.\nFind a domain suitable for a polynomial or Chebyshev series\ndefined at the values supplied.\n\nParameters\n\nxarray_like1-d array of abscissae whose domain will be determined.\n\n\n\nReturns\n\ndomainndarray1-d array containing two values.  If the inputs are complex, then\nthe two returned points are the lower left and upper right corners\nof the smallest rectangle (aligned with the axes) in the complex\nplane containing the points x. If the inputs are real, then the\ntwo points are the ends of the smallest interval containing the\npoints x.\n\n\n\n\n\nSee also\nmapparms, mapdomain\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; points = np.arange(4)**2 - 5; points\narray([-5, -4, -1,  4])\n&gt;&gt;&gt; pu.getdomain(points)\narray([-5.,  4.])\n&gt;&gt;&gt; c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle\n&gt;&gt;&gt; pu.getdomain(c)\narray([-1.-1.j,  1.+1.j])\n\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "domainndarray"], "returns": "domainndarray1-d array containing two values.  If the inputs are complex, thenthe two returned points are the lower left and upper right cornersof the smallest rectangle (aligned with the axes) in the complexplane containing the points x. If the inputs are real, then thetwo points are the ends of the smallest interval containing thepoints x.", "examples": ["; from numpy.polynomial import polyutils as pu\n; points = np.arange(4)**2 - 5; points\narray([-5, -4, -1,  4])\n; pu.getdomain(points)\narray([-5.,  4.])\n; c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle\n; pu.getdomain(c)\narray([-1.-1.j,  1.+1.j])\n\n", "; from numpy.polynomial import polyutils as pu\n; points = np.arange(4)**2 - 5; points\narray([-5, -4, -1,  4])\n; pu.getdomain(points)\narray([-5.,  4.])\n; c = np.exp(complex(0,1)*np.pi*np.arange(12)/6) # unit circle\n; pu.getdomain(c)\narray([-1.-1.j,  1.+1.j])\n"]},
{"library": "numpy", "item_id": "numpy.geterrobj", "code": "\nnumpy.geterrobj()\u00b6", "description": "Return the current object that defines floating-point error handling.\nThe error object contains all information that defines the error handling\nbehavior in NumPy. geterrobj is used internally by the other\nfunctions that get and set error handling behavior (geterr, seterr,\ngeterrcall, seterrcall).\n\nReturns\n\nerrobjlistThe error object, a list containing three elements:\n[internal numpy buffer size, error mask, error callback function].\nThe error mask is a single integer that holds the treatment information\non all four floating point errors. The information for each error type\nis contained in three bits of the integer. If we print it in base 8, we\ncan see what treatment is set for \u201cinvalid\u201d, \u201cunder\u201d, \u201cover\u201d, and\n\u201cdivide\u201d (in that order). The printed string can be interpreted with\n\n0 : \u2018ignore\u2019\n1 : \u2018warn\u2019\n2 : \u2018raise\u2019\n3 : \u2018call\u2019\n4 : \u2018print\u2019\n5 : \u2018log\u2019\n\n\n\n\n\n\nSee also\nseterrobj, seterr, geterr, seterrcall, geterrcall, getbufsize, setbufsize\n\nNotes\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see seterr.\nExamples\n&gt;&gt;&gt; np.geterrobj()  # first get the defaults\n[8192, 521, None]\n\n\n&gt;&gt;&gt; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n&gt;&gt;&gt; old_bufsize = np.setbufsize(20000)\n&gt;&gt;&gt; old_err = np.seterr(divide='raise')\n&gt;&gt;&gt; old_handler = np.seterrcall(err_handler)\n&gt;&gt;&gt; np.geterrobj()\n[8192, 521, &lt;function err_handler at 0x91dcaac&gt;]\n\n\n&gt;&gt;&gt; old_err = np.seterr(all='ignore')\n&gt;&gt;&gt; np.base_repr(np.geterrobj()[1], 8)\n'0'\n&gt;&gt;&gt; old_err = np.seterr(divide='warn', over='log', under='call',\n...                     invalid='print')\n&gt;&gt;&gt; np.base_repr(np.geterrobj()[1], 8)\n'4351'\n\n\n", "parameters": [], "returns": "errobjlistThe error object, a list containing three elements:[internal numpy buffer size, error mask, error callback function].The error mask is a single integer that holds the treatment informationon all four floating point errors. The information for each error typeis contained in three bits of the integer. If we print it in base 8, wecan see what treatment is set for \u201cinvalid\u201d, \u201cunder\u201d, \u201cover\u201d, and\u201cdivide\u201d (in that order). The printed string can be interpreted with0 : \u2018ignore\u20191 : \u2018warn\u20192 : \u2018raise\u20193 : \u2018call\u20194 : \u2018print\u20195 : \u2018log\u2019", "examples": ["; np.geterrobj()  # first get the defaults\n[8192, 521, None]\n\n", "; np.geterrobj()  # first get the defaults\n[8192, 521, None]\n", "; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n; old_bufsize = np.setbufsize(20000)\n; old_err = np.seterr(divide='raise')\n; old_handler = np.seterrcall(err_handler)\n; np.geterrobj()\n[8192, 521, &lt;function err_handler at 0x91dcaac&gt;]\n\n", "; def err_handler(type, flag):\n...     print(\"Floating point error (%s), with flag %s\" % (type, flag))\n...\n; old_bufsize = np.setbufsize(20000)\n; old_err = np.seterr(divide='raise')\n; old_handler = np.seterrcall(err_handler)\n; np.geterrobj()\n[8192, 521, &lt;function err_handler at 0x91dcaac&gt;]\n", "; old_err = np.seterr(all='ignore')\n; np.base_repr(np.geterrobj()[1], 8)\n'0'\n; old_err = np.seterr(divide='warn', over='log', under='call',\n...                     invalid='print')\n; np.base_repr(np.geterrobj()[1], 8)\n'4351'\n\n", "; old_err = np.seterr(all='ignore')\n; np.base_repr(np.geterrobj()[1], 8)\n'0'\n; old_err = np.seterr(divide='warn', over='log', under='call',\n...                     invalid='print')\n; np.base_repr(np.geterrobj()[1], 8)\n'4351'\n"]},
{"library": "numpy", "item_id": "numpy.getbufsize", "code": "\nnumpy.getbufsize()[source]\u00b6", "description": "Return the size of the buffer used in ufuncs.\n\nReturns\n\ngetbufsizeintSize of ufunc buffer in bytes.\n\n\n\n\n", "parameters": [], "returns": "getbufsizeintSize of ufunc buffer in bytes.", "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.getA1", "code": "\nmatrix.getA1(self)[source]\u00b6", "description": "Return self as a flattened ndarray.\nEquivalent to np.asarray(x).ravel()\n\nParameters\n\nNone\n\n\nReturns\n\nretndarrayself, 1-D, as an ndarray\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retndarray"], "returns": "retndarrayself, 1-D, as an ndarray", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.getA", "code": "\nmatrix.getA(self)[source]\u00b6", "description": "Return self as an ndarray object.\nEquivalent to np.asarray(self).\n\nParameters\n\nNone\n\n\nReturns\n\nretndarrayself as an ndarray\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retndarray"], "returns": "retndarrayself as an ndarray", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.get_state", "code": "\nRandomState.get_state()\u00b6", "description": "Return a tuple representing the internal state of the generator.\nFor more details, see set_state.\n\nReturns\n\nout{tuple(str, ndarray of 624 uints, int, int, float), dict}The returned tuple has the following items:\n\nthe string \u2018MT19937\u2019.\na 1-D array of 624 unsigned integer keys.\nan integer pos.\nan integer has_gauss.\na float cached_gaussian.\n\nIf legacy is False, or the BitGenerator is not NT19937, then\nstate is returned as a dictionary.\n\nlegacyboolFlag indicating the return a legacy tuple state when the BitGenerator\nis MT19937.\n\n\n\n\n\nSee also\nset_state\n\nNotes\nset_state and get_state are not needed to work with any of the\nrandom distributions in NumPy. If the internal state is manually altered,\nthe user should know exactly what he/she is doing.\n", "parameters": [], "returns": "out{tuple(str, ndarray of 624 uints, int, int, float), dict}The returned tuple has the following items:the string \u2018MT19937\u2019.a 1-D array of 624 unsigned integer keys.an integer pos.an integer has_gauss.a float cached_gaussian.If legacy is False, or the BitGenerator is not NT19937, thenstate is returned as a dictionary.legacyboolFlag indicating the return a legacy tuple state when the BitGeneratoris MT19937.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.get_state", "code": "\nnumpy.random.get_state()\u00b6", "description": "Return a tuple representing the internal state of the generator.\nFor more details, see set_state.\n\nReturns\n\nout{tuple(str, ndarray of 624 uints, int, int, float), dict}The returned tuple has the following items:\n\nthe string \u2018MT19937\u2019.\na 1-D array of 624 unsigned integer keys.\nan integer pos.\nan integer has_gauss.\na float cached_gaussian.\n\nIf legacy is False, or the BitGenerator is not NT19937, then\nstate is returned as a dictionary.\n\nlegacyboolFlag indicating the return a legacy tuple state when the BitGenerator\nis MT19937.\n\n\n\n\n\nSee also\nset_state\n\nNotes\nset_state and get_state are not needed to work with any of the\nrandom distributions in NumPy. If the internal state is manually altered,\nthe user should know exactly what he/she is doing.\n", "parameters": [], "returns": "out{tuple(str, ndarray of 624 uints, int, int, float), dict}The returned tuple has the following items:the string \u2018MT19937\u2019.a 1-D array of 624 unsigned integer keys.an integer pos.an integer has_gauss.a float cached_gaussian.If legacy is False, or the BitGenerator is not NT19937, thenstate is returned as a dictionary.legacyboolFlag indicating the return a legacy tuple state when the BitGeneratoris MT19937.", "examples": []},
{"library": "numpy", "item_id": "numpy.distutils.system_info.get_standard_file", "code": "\nnumpy.distutils.system_info.get_standard_file(fname)[source]\u00b6", "description": "Returns a list of files named \u2018fname\u2019 from\n1) System-wide directory (directory-location of this module)\n2) Users HOME directory (os.environ[\u2018HOME\u2019])\n3) Local directory\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.get_printoptions", "code": "\nnumpy.get_printoptions()[source]\u00b6", "description": "Return the current print options.\n\nReturns\n\nprint_optsdictDictionary of current print options with keys\n\n\nprecision : int\nthreshold : int\nedgeitems : int\nlinewidth : int\nsuppress : bool\nnanstr : str\ninfstr : str\nformatter : dict of callables\nsign : str\n\n\nFor a full description of these options, see set_printoptions.\n\n\n\n\n\nSee also\nset_printoptions, printoptions, set_string_function\n\n", "parameters": [], "returns": "print_optsdictDictionary of current print options with keysprecision : intthreshold : intedgeitems : intlinewidth : intsuppress : boolnanstr : strinfstr : strformatter : dict of callablessign : strFor a full description of these options, see set_printoptions.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.get_real", "code": "\nmasked_array.get_real(self)[source]\u00b6", "description": "The real part of the masked array.\nThis property is a view on the real part of this MaskedArray.\n\nSee also\nimag\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.real\nmasked_array(data=[1.0, --, 3.45],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.distutils.system_info.get_info", "code": "\nnumpy.distutils.system_info.get_info(name, notfound_action=0)[source]\u00b6", "description": "\nnotfound_action:0 - do nothing\n1 - display warning message\n2 - raise error\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.get_imag", "code": "\nmasked_array.get_imag(self)[source]\u00b6", "description": "The imaginary part of the masked array.\nThis property is a view on the imaginary part of this MaskedArray.\n\nSee also\nreal\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n&gt;&gt;&gt; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])\n; x.imag\nmasked_array(data=[1.0, --, 1.6],\n             mask=[False,  True, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.get_fill_value", "code": "\nMaskedArray.get_fill_value(self)[source]\u00b6", "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.\nExamples\n&gt;&gt;&gt; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n\n&gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)\n&gt;&gt;&gt; x.fill_value\n-inf\n&gt;&gt;&gt; x.fill_value = np.pi\n&gt;&gt;&gt; x.fill_value\n3.1415926535897931 # may vary\n\n\nReset to default:\n&gt;&gt;&gt; x.fill_value = None\n&gt;&gt;&gt; x.fill_value\n1e+20\n\n\n", "parameters": [], "returns": [], "examples": ["; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n", "; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n"]},
{"library": "numpy", "item_id": "numpy.get_include", "code": "\nnumpy.get_include()[source]\u00b6", "description": "Return the directory that contains the NumPy *.h header files.\nExtension modules that need to compile against NumPy should use this\nfunction to locate the appropriate include directory.\nNotes\nWhen using distutils, for example in setup.py.\nimport numpy as np\n...\nExtension('extension_name', ...\n        include_dirs=[np.get_include()])\n...\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.geometric", "code": "\nRandomState.geometric(p, size=None)\u00b6", "description": "Draw samples from the geometric distribution.\nBernoulli trials are experiments with one of two outcomes:\nsuccess or failure (an example of such an experiment is flipping\na coin).  The geometric distribution models the number of trials\nthat must be run in order to achieve success.  It is therefore\nsupported on the positive integers, k = 1, 2, ....\nThe probability mass function of the geometric distribution is\n\n\nwhere p is the probability of success of an individual trial.\n\nNote\nNew code should use the geometric method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\npfloat or array_like of floatsThe probability of success of an individual trial.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized geometric distribution.\n\n\n\n\n\nSee also\n\nGenerator.geometricwhich should be used for new code.\n\n\n\nExamples\nDraw ten thousand values from the geometric distribution,\nwith the probability of an individual success equal to 0.35:\n&gt;&gt;&gt; z = np.random.geometric(p=0.35, size=10000)\n\n\nHow many trials succeeded after a single run?\n&gt;&gt;&gt; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized geometric distribution.", "examples": ["; z = np.random.geometric(p=0.35, size=10000)\n\n", "; z = np.random.geometric(p=0.35, size=10000)\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n"]},
{"library": "numpy", "item_id": "numpy.geomspace", "code": "\nnumpy.geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0)[source]\u00b6", "description": "Return numbers spaced evenly on a log scale (a geometric progression).\nThis is similar to logspace, but with endpoints specified directly.\nEach output sample is a constant multiple of the previous.\n\nChanged in version 1.16.0: Non-scalar start and stop are now supported.\n\n\nParameters\n\nstartarray_likeThe starting value of the sequence.\n\nstoparray_likeThe final value of the sequence, unless endpoint is False.\nIn that case, num + 1 values are spaced over the\ninterval in log-space, of which all but the last (a sequence of\nlength num) are returned.\n\nnuminteger, optionalNumber of samples to generate.  Default is 50.\n\nendpointboolean, optionalIf true, stop is the last sample. Otherwise, it is not included.\nDefault is True.\n\ndtypedtypeThe type of the output array.  If dtype is not given, infer the data\ntype from the other input arguments.\n\naxisint, optionalThe axis in the result to store the samples.  Relevant only if start\nor stop are array-like.  By default (0), the samples will be along a\nnew axis inserted at the beginning. Use -1 to get an axis at the end.\n\nNew in version 1.16.0.\n\n\n\n\nReturns\n\nsamplesndarraynum samples, equally spaced on a log scale.\n\n\n\n\n\nSee also\n\nlogspaceSimilar to geomspace, but with endpoints specified using log and base.\n\nlinspaceSimilar to geomspace, but with arithmetic instead of geometric progression.\n\narangeSimilar to linspace, with the step size specified instead of the number of samples.\n\n\n\nNotes\nIf the inputs or dtype are complex, the output will follow a logarithmic\nspiral in the complex plane.  (There are an infinite number of spirals\npassing through two points; the output will follow the shortest such path.)\nExamples\n&gt;&gt;&gt; np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n&gt;&gt;&gt; np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n&gt;&gt;&gt; np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n&gt;&gt;&gt; np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n\n\nNote that the above may not produce exact integers:\n&gt;&gt;&gt; np.geomspace(1, 256, num=9, dtype=int)\narray([  1,   2,   4,   7,  16,  32,  63, 127, 256])\n&gt;&gt;&gt; np.around(np.geomspace(1, 256, num=9)).astype(int)\narray([  1,   2,   4,   8,  16,  32,  64, 128, 256])\n\n\nNegative, decreasing, and complex inputs are allowed:\n&gt;&gt;&gt; np.geomspace(1000, 1, num=4)\narray([1000.,  100.,   10.,    1.])\n&gt;&gt;&gt; np.geomspace(-1000, -1, num=4)\narray([-1000.,  -100.,   -10.,    -1.])\n&gt;&gt;&gt; np.geomspace(1j, 1000j, num=4)  # Straight line\narray([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])\n&gt;&gt;&gt; np.geomspace(-1+0j, 1+0j, num=5)  # Circle\narray([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,\n        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,\n        1.00000000e+00+0.00000000e+00j])\n\n\nGraphical illustration of endpoint parameter:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; N = 10\n&gt;&gt;&gt; y = np.zeros(N)\n&gt;&gt;&gt; plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.axis([0.5, 2000, 0, 3])\n[0.5, 2000, 0, 3]\n&gt;&gt;&gt; plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "startarray_like", "stoparray_like", "numinteger, optional", "endpointboolean, optional", "dtypedtype", "axisint, optional", "Returns", "samplesndarray"], "returns": "samplesndarraynum samples, equally spaced on a log scale.", "examples": ["; np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n; np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n; np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n; np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n\n", "; np.geomspace(1, 1000, num=4)\narray([    1.,    10.,   100.,  1000.])\n; np.geomspace(1, 1000, num=3, endpoint=False)\narray([   1.,   10.,  100.])\n; np.geomspace(1, 1000, num=4, endpoint=False)\narray([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])\n; np.geomspace(1, 256, num=9)\narray([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])\n", "; np.geomspace(1, 256, num=9, dtype=int)\narray([  1,   2,   4,   7,  16,  32,  63, 127, 256])\n; np.around(np.geomspace(1, 256, num=9)).astype(int)\narray([  1,   2,   4,   8,  16,  32,  64, 128, 256])\n\n", "; np.geomspace(1, 256, num=9, dtype=int)\narray([  1,   2,   4,   7,  16,  32,  63, 127, 256])\n; np.around(np.geomspace(1, 256, num=9)).astype(int)\narray([  1,   2,   4,   8,  16,  32,  64, 128, 256])\n", "; np.geomspace(1000, 1, num=4)\narray([1000.,  100.,   10.,    1.])\n; np.geomspace(-1000, -1, num=4)\narray([-1000.,  -100.,   -10.,    -1.])\n; np.geomspace(1j, 1000j, num=4)  # Straight line\narray([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])\n; np.geomspace(-1+0j, 1+0j, num=5)  # Circle\narray([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,\n        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,\n        1.00000000e+00+0.00000000e+00j])\n\n", "; np.geomspace(1000, 1, num=4)\narray([1000.,  100.,   10.,    1.])\n; np.geomspace(-1000, -1, num=4)\narray([-1000.,  -100.,   -10.,    -1.])\n; np.geomspace(1j, 1000j, num=4)  # Straight line\narray([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])\n; np.geomspace(-1+0j, 1+0j, num=5)  # Circle\narray([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,\n        6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,\n        1.00000000e+00+0.00000000e+00j])\n", "; import matplotlib.pyplot as plt\n; N = 10\n; y = np.zeros(N)\n; plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.axis([0.5, 2000, 0, 3])\n[0.5, 2000, 0, 3]\n; plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; N = 10\n; y = np.zeros(N)\n; plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.axis([0.5, 2000, 0, 3])\n[0.5, 2000, 0, 3]\n; plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.geometric", "code": "\nGenerator.geometric(p, size=None)\u00b6", "description": "Draw samples from the geometric distribution.\nBernoulli trials are experiments with one of two outcomes:\nsuccess or failure (an example of such an experiment is flipping\na coin).  The geometric distribution models the number of trials\nthat must be run in order to achieve success.  It is therefore\nsupported on the positive integers, k = 1, 2, ....\nThe probability mass function of the geometric distribution is\n\n\nwhere p is the probability of success of an individual trial.\n\nParameters\n\npfloat or array_like of floatsThe probability of success of an individual trial.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized geometric distribution.\n\n\n\n\nExamples\nDraw ten thousand values from the geometric distribution,\nwith the probability of an individual success equal to 0.35:\n&gt;&gt;&gt; z = np.random.default_rng().geometric(p=0.35, size=10000)\n\n\nHow many trials succeeded after a single run?\n&gt;&gt;&gt; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized geometric distribution.", "examples": ["; z = np.random.default_rng().geometric(p=0.35, size=10000)\n\n", "; z = np.random.default_rng().geometric(p=0.35, size=10000)\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.get_fill_value", "code": "\nmasked_array.get_fill_value(self)[source]\u00b6", "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.\nExamples\n&gt;&gt;&gt; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n\n&gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)\n&gt;&gt;&gt; x.fill_value\n-inf\n&gt;&gt;&gt; x.fill_value = np.pi\n&gt;&gt;&gt; x.fill_value\n3.1415926535897931 # may vary\n\n\nReset to default:\n&gt;&gt;&gt; x.fill_value = None\n&gt;&gt;&gt; x.fill_value\n1e+20\n\n\n", "parameters": [], "returns": [], "examples": ["; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n", "; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n"]},
{"library": "numpy", "item_id": "numpy.random.geometric", "code": "\nnumpy.random.geometric(p, size=None)\u00b6", "description": "Draw samples from the geometric distribution.\nBernoulli trials are experiments with one of two outcomes:\nsuccess or failure (an example of such an experiment is flipping\na coin).  The geometric distribution models the number of trials\nthat must be run in order to achieve success.  It is therefore\nsupported on the positive integers, k = 1, 2, ....\nThe probability mass function of the geometric distribution is\n\n\nwhere p is the probability of success of an individual trial.\n\nNote\nNew code should use the geometric method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\npfloat or array_like of floatsThe probability of success of an individual trial.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if p is a scalar.  Otherwise,\nnp.array(p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized geometric distribution.\n\n\n\n\n\nSee also\n\nGenerator.geometricwhich should be used for new code.\n\n\n\nExamples\nDraw ten thousand values from the geometric distribution,\nwith the probability of an individual success equal to 0.35:\n&gt;&gt;&gt; z = np.random.geometric(p=0.35, size=10000)\n\n\nHow many trials succeeded after a single run?\n&gt;&gt;&gt; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n\n", "parameters": ["Parameters", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized geometric distribution.", "examples": ["; z = np.random.geometric(p=0.35, size=10000)\n\n", "; z = np.random.geometric(p=0.35, size=10000)\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n\n", "; (z == 1).sum() / 10000.\n0.34889999999999999 #random\n"]},
{"library": "numpy", "item_id": "numpy.genfromtxt", "code": "\nnumpy.genfromtxt(fname, dtype=&lt;class 'float'&gt;, comments='#', delimiter=None, skip_header=0, skip_footer=0, converters=None, missing_values=None, filling_values=None, usecols=None, names=None, excludelist=None, deletechars=\" !#$%&amp;'()*+, -./:;&lt;=&gt;?@[\\]^{|}~\", replace_space='_', autostrip=False, case_sensitive=True, defaultfmt='f%i', unpack=None, usemask=False, loose=True, invalid_raise=True, max_rows=None, encoding='bytes')[source]\u00b6", "description": "Load data from a text file, with missing values handled as specified.\nEach line past the first skip_header lines is split at the delimiter\ncharacter, and characters following the comments character are discarded.\n\nParameters\n\nfnamefile, str, pathlib.Path, list of str, generatorFile, filename, list, or generator to read.  If the filename\nextension is gz or bz2, the file is first decompressed. Note\nthat generators must return byte strings. The strings\nin a list or produced by a generator are treated as lines.\n\ndtypedtype, optionalData type of the resulting array.\nIf None, the dtypes will be determined by the contents of each\ncolumn, individually.\n\ncommentsstr, optionalThe character used to indicate the start of a comment.\nAll the characters occurring on a line after a comment are discarded\n\ndelimiterstr, int, or sequence, optionalThe string used to separate values.  By default, any consecutive\nwhitespaces act as delimiter.  An integer or sequence of integers\ncan also be provided as width(s) of each field.\n\nskiprowsint, optionalskiprows was removed in numpy 1.10. Please use skip_header instead.\n\nskip_headerint, optionalThe number of lines to skip at the beginning of the file.\n\nskip_footerint, optionalThe number of lines to skip at the end of the file.\n\nconvertersvariable, optionalThe set of functions that convert the data of a column to a value.\nThe converters can also be used to provide a default value\nfor missing data: converters = {3: lambda s: float(s or 0)}.\n\nmissingvariable, optionalmissing was removed in numpy 1.10. Please use missing_values\ninstead.\n\nmissing_valuesvariable, optionalThe set of strings corresponding to missing data.\n\nfilling_valuesvariable, optionalThe set of values to be used as default when the data are missing.\n\nusecolssequence, optionalWhich columns to read, with 0 being the first.  For example,\nusecols = (1, 4, 5) will extract the 2nd, 5th and 6th columns.\n\nnames{None, True, str, sequence}, optionalIf names is True, the field names are read from the first line after\nthe first skip_header lines.  This line can optionally be proceeded\nby a comment delimiter. If names is a sequence or a single-string of\ncomma-separated names, the names will be used to define the field names\nin a structured dtype. If names is None, the names of the dtype\nfields will be used, if any.\n\nexcludelistsequence, optionalA list of names to exclude. This list is appended to the default list\n[\u2018return\u2019,\u2019file\u2019,\u2019print\u2019]. Excluded names are appended an underscore:\nfor example, file would become file_.\n\ndeletecharsstr, optionalA string combining invalid characters that must be deleted from the\nnames.\n\ndefaultfmtstr, optionalA format used to define default field names, such as \u201cf%i\u201d or \u201cf_%02i\u201d.\n\nautostripbool, optionalWhether to automatically strip white spaces from the variables.\n\nreplace_spacechar, optionalCharacter(s) used in replacement of white spaces in the variables\nnames. By default, use a \u2018_\u2019.\n\ncase_sensitive{True, False, \u2018upper\u2019, \u2018lower\u2019}, optionalIf True, field names are case sensitive.\nIf False or \u2018upper\u2019, field names are converted to upper case.\nIf \u2018lower\u2019, field names are converted to lower case.\n\nunpackbool, optionalIf True, the returned array is transposed, so that arguments may be\nunpacked using x, y, z = loadtxt(...)\n\nusemaskbool, optionalIf True, return a masked array.\nIf False, return a regular array.\n\nloosebool, optionalIf True, do not raise errors for invalid values.\n\ninvalid_raisebool, optionalIf True, an exception is raised if an inconsistency is detected in the\nnumber of columns.\nIf False, a warning is emitted and the offending lines are skipped.\n\nmax_rowsint,  optionalThe maximum number of rows to read. Must not be used with skip_footer\nat the same time.  If given, the value must be at least 1. Default is\nto read the entire file.\n\nNew in version 1.10.0.\n\n\nencodingstr, optionalEncoding used to decode the inputfile. Does not apply when fname is\na file object.  The special value \u2018bytes\u2019 enables backward compatibility\nworkarounds that ensure that you receive byte arrays when possible\nand passes latin1 encoded strings to converters. Override this value to\nreceive unicode arrays and pass strings as input to converters.  If set\nto None the system default is used. The default value is \u2018bytes\u2019.\n\nNew in version 1.14.0.\n\n\n\n\nReturns\n\noutndarrayData read from the text file. If usemask is True, this is a\nmasked array.\n\n\n\n\n\nSee also\n\nnumpy.loadtxtequivalent function when no data is missing.\n\n\n\nNotes\n\nWhen spaces are used as delimiters, or when no delimiter has been given\nas input, there should not be any missing data between two fields.\nWhen the variables are named (either by a flexible dtype or with names,\nthere must not be any header in the file (else a ValueError\nexception is raised).\nIndividual values are not stripped of spaces by default.\nWhen using a custom converter, make sure the function does remove spaces.\n\nReferences\n\n1\nNumPy User Guide, section I/O with NumPy.\n\n\nExamples\n&gt;&gt;&gt; from io import StringIO\n&gt;&gt;&gt; import numpy as np\n\n\nComma delimited file with mixed dtype\n&gt;&gt;&gt; s = StringIO(u\"1,1.3,abcde\")\n&gt;&gt;&gt; data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n... ('mystring','S5')], delimiter=\",\")\n&gt;&gt;&gt; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n\nUsing dtype = None\n&gt;&gt;&gt; _ = s.seek(0) # needed for StringIO example only\n&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None,\n... names = ['myint','myfloat','mystring'], delimiter=\",\")\n&gt;&gt;&gt; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n\nSpecifying dtype and names\n&gt;&gt;&gt; _ = s.seek(0)\n&gt;&gt;&gt; data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n... names=['myint','myfloat','mystring'], delimiter=\",\")\n&gt;&gt;&gt; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n\nAn example with fixed-width columns\n&gt;&gt;&gt; s = StringIO(u\"11.3abcde\")\n&gt;&gt;&gt; data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n...     delimiter=[1,3,5])\n&gt;&gt;&gt; data\narray((1, 1.3, b'abcde'),\n      dtype=[('intvar', '&lt;i8'), ('fltvar', '&lt;f8'), ('strvar', 'S5')])\n\n\nAn example to show comments\n&gt;&gt;&gt; f = StringIO('''\n... text,# of chars\n... hello world,11\n... numpy,5''')\n&gt;&gt;&gt; np.genfromtxt(f, dtype='S12,S12', delimiter=',')\narray([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n  dtype=[('f0', 'S12'), ('f1', 'S12')])\n\n\n", "parameters": ["Parameters", "fnamefile, str, pathlib.Path, list of str, generator", "dtypedtype, optional", "commentsstr, optional", "delimiterstr, int, or sequence, optional", "skiprowsint, optional", "skip_headerint, optional", "skip_footerint, optional", "convertersvariable, optional", "missingvariable, optional", "missing_valuesvariable, optional", "filling_valuesvariable, optional", "usecolssequence, optional", "names{None, True, str, sequence}, optional", "excludelistsequence, optional", "deletecharsstr, optional", "defaultfmtstr, optional", "autostripbool, optional", "replace_spacechar, optional", "case_sensitive{True, False, \u2018upper\u2019, \u2018lower\u2019}, optional", "unpackbool, optional", "usemaskbool, optional", "loosebool, optional", "invalid_raisebool, optional", "max_rowsint,  optional", "encodingstr, optional", "Returns", "outndarray"], "returns": "outndarrayData read from the text file. If usemask is True, this is amasked array.", "examples": ["; from io import StringIO\n; import numpy as np\n\n", "; from io import StringIO\n; import numpy as np\n", "; s = StringIO(u\"1,1.3,abcde\")\n; data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n... ('mystring','S5')], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n", "; s = StringIO(u\"1,1.3,abcde\")\n; data = np.genfromtxt(s, dtype=[('myint','i8'),('myfloat','f8'),\n... ('mystring','S5')], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n", "; _ = s.seek(0) # needed for StringIO example only\n; data = np.genfromtxt(s, dtype=None,\n... names = ['myint','myfloat','mystring'], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n", "; _ = s.seek(0) # needed for StringIO example only\n; data = np.genfromtxt(s, dtype=None,\n... names = ['myint','myfloat','mystring'], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n", "; _ = s.seek(0)\n; data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n... names=['myint','myfloat','mystring'], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n\n", "; _ = s.seek(0)\n; data = np.genfromtxt(s, dtype=\"i8,f8,S5\",\n... names=['myint','myfloat','mystring'], delimiter=\",\")\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('myint', '&lt;i8'), ('myfloat', '&lt;f8'), ('mystring', 'S5')])\n", "; s = StringIO(u\"11.3abcde\")\n; data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n...     delimiter=[1,3,5])\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('intvar', '&lt;i8'), ('fltvar', '&lt;f8'), ('strvar', 'S5')])\n\n", "; s = StringIO(u\"11.3abcde\")\n; data = np.genfromtxt(s, dtype=None, names=['intvar','fltvar','strvar'],\n...     delimiter=[1,3,5])\n; data\narray((1, 1.3, b'abcde'),\n      dtype=[('intvar', '&lt;i8'), ('fltvar', '&lt;f8'), ('strvar', 'S5')])\n", "; f = StringIO('''\n... text,# of chars\n... hello world,11\n... numpy,5''')\n; np.genfromtxt(f, dtype='S12,S12', delimiter=',')\narray([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n  dtype=[('f0', 'S12'), ('f1', 'S12')])\n\n", "; f = StringIO('''\n... text,# of chars\n... hello world,11\n... numpy,5''')\n; np.genfromtxt(f, dtype='S12,S12', delimiter=',')\narray([(b'text', b''), (b'hello world', b'11'), (b'numpy', b'5')],\n  dtype=[('f0', 'S12'), ('f1', 'S12')])\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.generate_state", "code": "\nSeedSequence.generate_state(n_words, dtype=np.uint32)\u00b6", "description": "Return the requested number of words for PRNG seeding.\nA BitGenerator should call this method in its constructor with\nan appropriate n_words parameter to properly seed itself.\n\nParameters\n\nn_wordsint\ndtypenp.uint32 or np.uint64, optionalThe size of each word. This should only be either uint32 or\nuint64. Strings (\u2018uint32\u2019, \u2018uint64\u2019) are fine. Note that\nrequesting uint64 will draw twice as many bits as uint32 for\nthe same n_words. This is a convenience for BitGenerator`s that\nexpress their states as `uint64 arrays.\n\n\n\nReturns\n\nstateuint32 or uint64 array, shape=(n_words,)\n\n\n\n", "parameters": ["Parameters", "n_wordsint", "dtypenp.uint32 or np.uint64, optional", "Returns", "stateuint32 or uint64 array, shape=(n_words,)"], "returns": "stateuint32 or uint64 array, shape=(n_words,)", "examples": []},
{"library": "numpy", "item_id": "numpy.generic", "code": "\nclass numpy.generic[source]\u00b6", "description": "Base class for numpy scalar types.\nClass from which most (all?) numpy scalar types are derived.  For\nconsistency, exposes the same API as ndarray, despite many\nconsequent attributes being either \u201cget-only,\u201d or completely irrelevant.\nThis is the class from which it is strongly suggested users should derive\ncustom scalar types.\n\nAttributes\n\nTtranspose\n\nbasebase object\n\ndatapointer to start of data\n\ndtypeget array data-descriptor\n\nflagsinteger value of flags\n\nflata 1-d view of scalar\n\nimagimaginary part of scalar\n\nitemsizelength of one element in bytes\n\nnbyteslength of item in bytes\n\nndimnumber of array dimensions\n\nrealreal part of scalar\n\nshapetuple of array dimensions\n\nsizenumber of elements in the gentype\n\nstridestuple of bytes steps in each dimension\n\n\n\n\nMethods\n\n\n\n\n\n\nall()\nNot implemented (virtual attribute)\n\nany()\nNot implemented (virtual attribute)\n\nargmax()\nNot implemented (virtual attribute)\n\nargmin()\nNot implemented (virtual attribute)\n\nargsort()\nNot implemented (virtual attribute)\n\nastype()\nNot implemented (virtual attribute)\n\nbyteswap()\nNot implemented (virtual attribute)\n\nchoose()\nNot implemented (virtual attribute)\n\nclip()\nNot implemented (virtual attribute)\n\ncompress()\nNot implemented (virtual attribute)\n\nconjugate()\nNot implemented (virtual attribute)\n\ncopy()\nNot implemented (virtual attribute)\n\ncumprod()\nNot implemented (virtual attribute)\n\ncumsum()\nNot implemented (virtual attribute)\n\ndiagonal()\nNot implemented (virtual attribute)\n\ndump()\nNot implemented (virtual attribute)\n\ndumps()\nNot implemented (virtual attribute)\n\nfill()\nNot implemented (virtual attribute)\n\nflatten()\nNot implemented (virtual attribute)\n\ngetfield()\nNot implemented (virtual attribute)\n\nitem()\nNot implemented (virtual attribute)\n\nitemset()\nNot implemented (virtual attribute)\n\nmax()\nNot implemented (virtual attribute)\n\nmean()\nNot implemented (virtual attribute)\n\nmin()\nNot implemented (virtual attribute)\n\nnewbyteorder([new_order])\nReturn a new dtype with a different byte order.\n\nnonzero()\nNot implemented (virtual attribute)\n\nprod()\nNot implemented (virtual attribute)\n\nptp()\nNot implemented (virtual attribute)\n\nput()\nNot implemented (virtual attribute)\n\nravel()\nNot implemented (virtual attribute)\n\nrepeat()\nNot implemented (virtual attribute)\n\nreshape()\nNot implemented (virtual attribute)\n\nresize()\nNot implemented (virtual attribute)\n\nround()\nNot implemented (virtual attribute)\n\nsearchsorted()\nNot implemented (virtual attribute)\n\nsetfield()\nNot implemented (virtual attribute)\n\nsetflags()\nNot implemented (virtual attribute)\n\nsort()\nNot implemented (virtual attribute)\n\nsqueeze()\nNot implemented (virtual attribute)\n\nstd()\nNot implemented (virtual attribute)\n\nsum()\nNot implemented (virtual attribute)\n\nswapaxes()\nNot implemented (virtual attribute)\n\ntake()\nNot implemented (virtual attribute)\n\ntofile()\nNot implemented (virtual attribute)\n\ntolist()\nNot implemented (virtual attribute)\n\ntostring()\nNot implemented (virtual attribute)\n\ntrace()\nNot implemented (virtual attribute)\n\ntranspose()\nNot implemented (virtual attribute)\n\nvar()\nNot implemented (virtual attribute)\n\nview()\nNot implemented (virtual attribute)\n\n\n\n\n\n\n\n\n\nconj\n\n\ntobytes\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.gamma", "code": "\nRandomState.gamma(shape, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale (sometimes designated\n\u201ctheta\u201d), where both parameters are &gt; 0.\n\nNote\nNew code should use the gamma method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nshapefloat or array_like of floatsThe shape of the gamma distribution. Must be non-negative.\n\nscalefloat or array_like of floats, optionalThe scale of the gamma distribution. Must be non-negative.\nDefault is equal to 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape and scale are both scalars.\nOtherwise, np.broadcast(shape, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\nGenerator.gammawhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n&gt;&gt;&gt; s = np.random.gamma(shape, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized gamma distribution.", "examples": ["; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.gamma(shape, scale, 1000)\n\n", "; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.gamma(shape, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.gcd", "code": "\nnumpy.gcd(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'gcd'&gt;\u00b6", "description": "Returns the greatest common divisor of |x1| and |x2|\n\nParameters\n\nx1, x2array_like, intArrays of values. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\n\n\nReturns\n\nyndarray or scalarThe greatest common divisor of the absolute value of the inputs\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nlcmThe lowest common multiple\n\n\n\nExamples\n&gt;&gt;&gt; np.gcd(12, 20)\n4\n&gt;&gt;&gt; np.gcd.reduce([15, 25, 35])\n5\n&gt;&gt;&gt; np.gcd(np.arange(6), 20)\narray([20,  1,  2,  1,  4,  5])\n\n\n", "parameters": ["Parameters", "x1, x2array_like, int", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe greatest common divisor of the absolute value of the inputsThis is a scalar if both x1 and x2 are scalars.", "examples": ["; np.gcd(12, 20)\n4\n; np.gcd.reduce([15, 25, 35])\n5\n; np.gcd(np.arange(6), 20)\narray([20,  1,  2,  1,  4,  5])\n\n", "; np.gcd(12, 20)\n4\n; np.gcd.reduce([15, 25, 35])\n5\n; np.gcd(np.arange(6), 20)\narray([20,  1,  2,  1,  4,  5])\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.gamma", "code": "\nGenerator.gamma(shape, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale (sometimes designated\n\u201ctheta\u201d), where both parameters are &gt; 0.\n\nParameters\n\nshapefloat or array_like of floatsThe shape of the gamma distribution. Must be non-negative.\n\nscalefloat or array_like of floats, optionalThe scale of the gamma distribution. Must be non-negative.\nDefault is equal to 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape and scale are both scalars.\nOtherwise, np.broadcast(shape, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n&gt;&gt;&gt; s = np.random.default_rng().gamma(shape, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized gamma distribution.", "examples": ["; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.default_rng().gamma(shape, scale, 1000)\n\n", "; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.default_rng().gamma(shape, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.gamma", "code": "\nnumpy.random.gamma(shape, scale=1.0, size=None)\u00b6", "description": "Draw samples from a Gamma distribution.\nSamples are drawn from a Gamma distribution with specified parameters,\nshape (sometimes designated \u201ck\u201d) and scale (sometimes designated\n\u201ctheta\u201d), where both parameters are &gt; 0.\n\nNote\nNew code should use the gamma method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nshapefloat or array_like of floatsThe shape of the gamma distribution. Must be non-negative.\n\nscalefloat or array_like of floats, optionalThe scale of the gamma distribution. Must be non-negative.\nDefault is equal to 1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if shape and scale are both scalars.\nOtherwise, np.broadcast(shape, scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized gamma distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.gammaprobability density function, distribution or cumulative density function, etc.\n\nGenerator.gammawhich should be used for new code.\n\n\n\nNotes\nThe probability density for the Gamma distribution is\n\n\nwhere  is the shape and  the scale,\nand  is the Gamma function.\nThe Gamma distribution is often used to model the times to failure of\nelectronic components, and arises naturally in processes for which the\nwaiting times between Poisson distributed events are relevant.\nReferences\n\n1\nWeisstein, Eric W. \u201cGamma Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/GammaDistribution.html\n\n2\nWikipedia, \u201cGamma distribution\u201d,\nhttps://en.wikipedia.org/wiki/Gamma_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n&gt;&gt;&gt; s = np.random.gamma(shape, scale, 1000)\n\n\nDisplay the histogram of the samples, along with\nthe probability density function:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; import scipy.special as sps  \n&gt;&gt;&gt; count, bins, ignored = plt.hist(s, 50, density=True)\n&gt;&gt;&gt; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n&gt;&gt;&gt; plt.plot(bins, y, linewidth=2, color='r')  \n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "shapefloat or array_like of floats", "scalefloat or array_like of floats, optional", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized gamma distribution.", "examples": ["; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.gamma(shape, scale, 1000)\n\n", "; shape, scale = 2., 2.  # mean=4, std=2*sqrt(2)\n; s = np.random.gamma(shape, scale, 1000)\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; import scipy.special as sps  \n; count, bins, ignored = plt.hist(s, 50, density=True)\n; y = bins**(shape-1)*(np.exp(-bins/scale) /  \n...                      (sps.gamma(shape)*scale**shape))\n; plt.plot(bins, y, linewidth=2, color='r')  \n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.fv", "code": "\nnumpy.fv(rate, nper, pmt, pv, when='end')[source]\u00b6", "description": "Compute the future value.\n\nDeprecated since version 1.18: fv is deprecated; for details, see NEP 32 [1].\nUse the corresponding function in the numpy-financial library,\nhttps://pypi.org/project/numpy-financial.\n\n\nGiven:\na present value, pv\nan interest rate compounded once per period, of which\nthere are\nnper total\na (fixed) payment, pmt, paid either\nat the beginning (when = {\u2018begin\u2019, 1}) or the end\n(when = {\u2018end\u2019, 0}) of each period\n\n\nReturn:the value at the end of the nper periods\n\n\n\nParameters\n\nratescalar or array_like of shape(M, )Rate of interest as decimal (not per cent) per period\n\nnperscalar or array_like of shape(M, )Number of compounding periods\n\npmtscalar or array_like of shape(M, )Payment\n\npvscalar or array_like of shape(M, )Present value\n\nwhen{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optionalWhen payments are due (\u2018begin\u2019 (1) or \u2018end\u2019 (0)).\nDefaults to {\u2018end\u2019, 0}.\n\n\n\nReturns\n\noutndarrayFuture values.  If all input is scalar, returns a scalar float.  If\nany input is array_like, returns future values for each input element.\nIf multiple inputs are array_like, they all must have the same shape.\n\n\n\n\nNotes\nThe future value is computed by solving the equation:\nfv +\npv*(1+rate)**nper +\npmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0\n\n\nor, when rate == 0:\nfv + pv + pmt * nper == 0\n\n\nReferences\n\n1\nNumPy Enhancement Proposal (NEP) 32,\nhttps://numpy.org/neps/nep-0032-remove-financial-functions.html\n\n2\nWheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).\nOpen Document Format for Office Applications (OpenDocument)v1.2,\nPart 2: Recalculated Formula (OpenFormula) Format - Annotated Version,\nPre-Draft 12. Organization for the Advancement of Structured Information\nStandards (OASIS). Billerica, MA, USA. [ODT Document].\nAvailable:\nhttp://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula\nOpenDocument-formula-20090508.odt\n\n\nExamples\nWhat is the future value after 10 years of saving $100 now, with\nan additional monthly savings of $100.  Assume the interest rate is\n5% (annually) compounded monthly?\n&gt;&gt;&gt; np.fv(0.05/12, 10*12, -100, -100)\n15692.928894335748\n\n\nBy convention, the negative sign represents cash flow out (i.e. money not\navailable today).  Thus, saving $100 a month at 5% annual interest leads\nto $15,692.93 available to spend in 10 years.\nIf any input is array_like, returns an array of equal shape.  Let\u2019s\ncompare different interest rates from the example above.\n&gt;&gt;&gt; a = np.array((0.05, 0.06, 0.07))/12\n&gt;&gt;&gt; np.fv(a, 10*12, -100, -100)\narray([ 15692.92889434,  16569.87435405,  17509.44688102]) # may vary\n\n\n", "parameters": ["Parameters", "ratescalar or array_like of shape(M, )", "nperscalar or array_like of shape(M, )", "pmtscalar or array_like of shape(M, )", "pvscalar or array_like of shape(M, )", "when{{\u2018begin\u2019, 1}, {\u2018end\u2019, 0}}, {string, int}, optional", "Returns", "outndarray"], "returns": "outndarrayFuture values.  If all input is scalar, returns a scalar float.  Ifany input is array_like, returns future values for each input element.If multiple inputs are array_like, they all must have the same shape.", "examples": ["; np.fv(0.05/12, 10*12, -100, -100)\n15692.928894335748\n\n", "; np.fv(0.05/12, 10*12, -100, -100)\n15692.928894335748\n", "; a = np.array((0.05, 0.06, 0.07))/12\n; np.fv(a, 10*12, -100, -100)\narray([ 15692.92889434,  16569.87435405,  17509.44688102]) # may vary\n\n", "; a = np.array((0.05, 0.06, 0.07))/12\n; np.fv(a, 10*12, -100, -100)\narray([ 15692.92889434,  16569.87435405,  17509.44688102]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.full_like", "code": "\nnumpy.full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None)[source]\u00b6", "description": "Return a full array with the same shape and type as a given array.\n\nParameters\n\naarray_likeThe shape and data-type of a define these same attributes of\nthe returned array.\n\nfill_valuescalarFill value.\n\ndtypedata-type, optionalOverrides the data type of the result.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optionalOverrides the memory layout of the result. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible.\n\nsubokbool, optional.If True, then the newly created array will use the sub-class\ntype of \u2018a\u2019, otherwise it will be a base-class array. Defaults\nto True.\n\nshapeint or sequence of ints, optional.Overrides the shape of the result. If order=\u2019K\u2019 and the number of\ndimensions is unchanged, will try to keep order, otherwise,\norder=\u2019C\u2019 is implied.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\noutndarrayArray of fill_value with the same shape and type as a.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nones_likeReturn an array of ones with shape and type of input.\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(6, dtype=int)\n&gt;&gt;&gt; np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n&gt;&gt;&gt; np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n&gt;&gt;&gt; np.full_like(x, 0.1, dtype=np.double)\narray([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n&gt;&gt;&gt; np.full_like(x, np.nan, dtype=np.double)\narray([nan, nan, nan, nan, nan, nan])\n\n\n&gt;&gt;&gt; y = np.arange(6, dtype=np.double)\n&gt;&gt;&gt; np.full_like(y, 0.1)\narray([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n\n\n", "parameters": ["Parameters", "aarray_like", "fill_valuescalar", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optional", "subokbool, optional.", "shapeint or sequence of ints, optional.", "Returns", "outndarray"], "returns": "outndarrayArray of fill_value with the same shape and type as a.", "examples": ["; x = np.arange(6, dtype=int)\n; np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n; np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n; np.full_like(x, 0.1, dtype=np.double)\narray([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n; np.full_like(x, np.nan, dtype=np.double)\narray([nan, nan, nan, nan, nan, nan])\n\n", "; x = np.arange(6, dtype=int)\n; np.full_like(x, 1)\narray([1, 1, 1, 1, 1, 1])\n; np.full_like(x, 0.1)\narray([0, 0, 0, 0, 0, 0])\n; np.full_like(x, 0.1, dtype=np.double)\narray([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])\n; np.full_like(x, np.nan, dtype=np.double)\narray([nan, nan, nan, nan, nan, nan])\n", "; y = np.arange(6, dtype=np.double)\n; np.full_like(y, 0.1)\narray([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n\n", "; y = np.arange(6, dtype=np.double)\n; np.full_like(y, 0.1)\narray([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])\n"]},
{"library": "numpy", "item_id": "numpy.full", "code": "\nnumpy.full(shape, fill_value, dtype=None, order='C')[source]\u00b6", "description": "Return a new array of given shape and type, filled with fill_value.\n\nParameters\n\nshapeint or sequence of intsShape of the new array, e.g., (2, 3) or 2.\n\nfill_valuescalarFill value.\n\ndtypedata-type, optional\nThe desired data-type for the array  The default, None, meansnp.array(fill_value).dtype.\n\n\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to store multidimensional data in C- or Fortran-contiguous\n(row- or column-wise) order in memory.\n\n\n\nReturns\n\noutndarrayArray of fill_value with the given shape, dtype, and order.\n\n\n\n\n\nSee also\n\nfull_likeReturn a new array with shape of input filled with value.\n\nemptyReturn a new uninitialized array.\n\nonesReturn a new array setting values to one.\n\nzerosReturn a new array setting values to zero.\n\n\n\nExamples\n&gt;&gt;&gt; np.full((2, 2), np.inf)\narray([[inf, inf],\n       [inf, inf]])\n&gt;&gt;&gt; np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n\n\n", "parameters": ["Parameters", "shapeint or sequence of ints", "fill_valuescalar", "dtypedata-type, optional", "The desired data-type for the array  The default, None, means", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outndarray"], "returns": "outndarrayArray of fill_value with the given shape, dtype, and order.", "examples": ["; np.full((2, 2), np.inf)\narray([[inf, inf],\n       [inf, inf]])\n; np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n\n", "; np.full((2, 2), np.inf)\narray([[inf, inf],\n       [inf, inf]])\n; np.full((2, 2), 10)\narray([[10, 10],\n       [10, 10]])\n"]},
{"library": "numpy", "item_id": "numpy.core.records.fromstring", "code": "\nnumpy.core.records.fromstring(datastring, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)[source]\u00b6", "description": "create a (read-only) record array from binary data contained in\na string\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.fromroots", "code": "\nclassmethod Polynomial.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.fromstring", "code": "\nnumpy.fromstring(string, dtype=float, count=-1, sep='')\u00b6", "description": "A new 1-D array initialized from text data in a string.\n\nParameters\n\nstringstrA string containing the data.\n\ndtypedata-type, optionalThe data type of the array; default: float.  For binary input data,\nthe data must be in exactly this format. Most builtin numeric types are \nsupported and extension types may be supported.\n\nNew in version 1.18.0: Complex dtypes.\n\n\ncountint, optionalRead this number of dtype elements from the data.  If this is\nnegative (the default), the count will be determined from the\nlength of the data.\n\nsepstr, optionalThe string separating numbers in the data; extra whitespace between\nelements is also ignored.\n\nDeprecated since version 1.14: Passing sep='', the default, is deprecated since it will\ntrigger the deprecated binary mode of this function. This mode\ninterprets string as binary bytes, rather than ASCII text with\ndecimal numbers, an operation which is better spelt\nfrombuffer(string, dtype, count). If string contains unicode\ntext, the binary mode of fromstring will first encode it into\nbytes using either utf-8 (python 3) or the default encoding\n(python 2), neither of which produce sane results.\n\n\n\n\nReturns\n\narrndarrayThe constructed array.\n\n\n\nRaises\n\nValueErrorIf the string is not the correct size to satisfy the requested\ndtype and count.\n\n\n\n\n\nSee also\nfrombuffer, fromfile, fromiter\n\nExamples\n&gt;&gt;&gt; np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n&gt;&gt;&gt; np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n\n\n", "parameters": ["Parameters", "stringstr", "dtypedata-type, optional", "countint, optional", "sepstr, optional", "Returns", "arrndarray", "Raises", "ValueError"], "returns": "arrndarrayThe constructed array.", "examples": ["; np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n; np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n\n", "; np.fromstring('1 2', dtype=int, sep=' ')\narray([1, 2])\n; np.fromstring('1, 2', dtype=int, sep=',')\narray([1, 2])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.fromroots", "code": "\nclassmethod Laguerre.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.fromroots", "code": "\nclassmethod Chebyshev.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.core.records.fromrecords", "code": "\nnumpy.core.records.fromrecords(recList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)[source]\u00b6", "description": "create a recarray from a list of records in text form\n\nThe data in the same field can be heterogeneous, they will be promoted\nto the highest data type.  This method is intended for creating\nsmaller record arrays.  If used to create large array without formats\ndefined\nr=fromrecords([(2,3.,\u2019abc\u2019)]*100000)\nit can be slow.\nIf formats is None, then this will auto-detect formats. Use list of\ntuples rather than list of lists for faster processing.\n\n&gt;&gt;&gt; r=np.core.records.fromrecords([(456,'dbe',1.2),(2,'de',1.3)],\n... names='col1,col2,col3')\n&gt;&gt;&gt; print(r[0])\n(456, 'dbe', 1.2)\n&gt;&gt;&gt; r.col1\narray([456,   2])\n&gt;&gt;&gt; r.col2\narray(['dbe', 'de'], dtype='&lt;U3')\n&gt;&gt;&gt; import pickle\n&gt;&gt;&gt; pickle.loads(pickle.dumps(r))\nrec.array([(456, 'dbe', 1.2), (  2, 'de', 1.3)],\n          dtype=[('col1', '&lt;i8'), ('col2', '&lt;U3'), ('col3', '&lt;f8')])\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.fromroots", "code": "\nclassmethod HermiteE.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.fromiter", "code": "\nnumpy.fromiter(iterable, dtype, count=-1)\u00b6", "description": "Create a new 1-dimensional array from an iterable object.\n\nParameters\n\niterableiterable objectAn iterable object providing data for the array.\n\ndtypedata-typeThe data-type of the returned array.\n\ncountint, optionalThe number of items to read from iterable.  The default is -1,\nwhich means all data is read.\n\n\n\nReturns\n\noutndarrayThe output array.\n\n\n\n\nNotes\nSpecify count to improve performance.  It allows fromiter to\npre-allocate the output array, instead of resizing it on demand.\nExamples\n&gt;&gt;&gt; iterable = (x*x for x in range(5))\n&gt;&gt;&gt; np.fromiter(iterable, float)\narray([  0.,   1.,   4.,   9.,  16.])\n\n\n", "parameters": ["Parameters", "iterableiterable object", "dtypedata-type", "countint, optional", "Returns", "outndarray"], "returns": "outndarrayThe output array.", "examples": ["; iterable = (x*x for x in range(5))\n; np.fromiter(iterable, float)\narray([  0.,   1.,   4.,   9.,  16.])\n\n", "; iterable = (x*x for x in range(5))\n; np.fromiter(iterable, float)\narray([  0.,   1.,   4.,   9.,  16.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.fromroots", "code": "\nclassmethod Hermite.fromroots(roots, domain=[], window=None)[source]\u00b6", "description": "Return series instance that has the specified roots.\nReturns a series representing the product\n(x - r[0])*(x - r[1])*...*(x - r[n-1]), where r is a\nlist of roots.\n\nParameters\n\nrootsarray_likeList of roots.\n\ndomain{[], None, array_like}, optionalDomain for the resulting series. If None the domain is the\ninterval from the smallest root to the largest. If [] the\ndomain is the class domain. The default is [].\n\nwindow{None, array_like}, optionalWindow for the returned series. If None the class window is\nused. The default is None.\n\n\n\nReturns\n\nnew_seriesseriesSeries with the specified roots.\n\n\n\n\n", "parameters": ["Parameters", "rootsarray_like", "domain{[], None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesSeries with the specified roots.", "examples": []},
{"library": "numpy", "item_id": "numpy.fromregex", "code": "\nnumpy.fromregex(file, regexp, dtype, encoding=None)[source]\u00b6", "description": "Construct an array from a text file, using regular expression parsing.\nThe returned array is always a structured array, and is constructed from\nall matches of the regular expression in the file. Groups in the regular\nexpression are converted to fields of the structured array.\n\nParameters\n\nfilestr or fileFilename or file object to read.\n\nregexpstr or regexpRegular expression used to parse the file.\nGroups in the regular expression correspond to fields in the dtype.\n\ndtypedtype or list of dtypesDtype for the structured array.\n\nencodingstr, optionalEncoding used to decode the inputfile. Does not apply to input streams.\n\nNew in version 1.14.0.\n\n\n\n\nReturns\n\noutputndarrayThe output array, containing the part of the content of file that\nwas matched by regexp. output is always a structured array.\n\n\n\nRaises\n\nTypeErrorWhen dtype is not a valid dtype for a structured array.\n\n\n\n\n\nSee also\nfromstring, loadtxt\n\nNotes\nDtypes for structured arrays can be specified in several forms, but all\nforms specify at least the data type and field name. For details see\ndoc.structured_arrays.\nExamples\n&gt;&gt;&gt; f = open('test.dat', 'w')\n&gt;&gt;&gt; _ = f.write(\"1312 foo\\n1534  bar\\n444   qux\")\n&gt;&gt;&gt; f.close()\n\n\n&gt;&gt;&gt; regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n&gt;&gt;&gt; output = np.fromregex('test.dat', regexp,\n...                       [('num', np.int64), ('key', 'S3')])\n&gt;&gt;&gt; output\narray([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n      dtype=[('num', '&lt;i8'), ('key', 'S3')])\n&gt;&gt;&gt; output['num']\narray([1312, 1534,  444])\n\n\n", "parameters": ["Parameters", "filestr or file", "regexpstr or regexp", "dtypedtype or list of dtypes", "encodingstr, optional", "Returns", "outputndarray", "Raises", "TypeError"], "returns": "outputndarrayThe output array, containing the part of the content of file thatwas matched by regexp. output is always a structured array.", "examples": ["; f = open('test.dat', 'w')\n; _ = f.write(\"1312 foo\\n1534  bar\\n444   qux\")\n; f.close()\n\n", "; f = open('test.dat', 'w')\n; _ = f.write(\"1312 foo\\n1534  bar\\n444   qux\")\n; f.close()\n", "; regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n; output = np.fromregex('test.dat', regexp,\n...                       [('num', np.int64), ('key', 'S3')])\n; output\narray([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n      dtype=[('num', '&lt;i8'), ('key', 'S3')])\n; output['num']\narray([1312, 1534,  444])\n\n", "; regexp = r\"(\\d+)\\s+(...)\"  # match [digits, whitespace, anything]\n; output = np.fromregex('test.dat', regexp,\n...                       [('num', np.int64), ('key', 'S3')])\n; output\narray([(1312, b'foo'), (1534, b'bar'), ( 444, b'qux')],\n      dtype=[('num', '&lt;i8'), ('key', 'S3')])\n; output['num']\narray([1312, 1534,  444])\n"]},
{"library": "numpy", "item_id": "numpy.frompyfunc", "code": "\nnumpy.frompyfunc(func, nin, nout)\u00b6", "description": "Takes an arbitrary Python function and returns a NumPy ufunc.\nCan be used, for example, to add broadcasting to a built-in Python\nfunction (see Examples section).\n\nParameters\n\nfuncPython function objectAn arbitrary Python function.\n\nninintThe number of input arguments.\n\nnoutintThe number of objects returned by func.\n\n\n\nReturns\n\noutufuncReturns a NumPy universal function (ufunc) object.\n\n\n\n\n\nSee also\n\nvectorizeEvaluates pyfunc over input arrays using broadcasting rules of numpy.\n\n\n\nNotes\nThe returned ufunc always returns PyObject arrays.\nExamples\nUse frompyfunc to add broadcasting to the Python function oct:\n&gt;&gt;&gt; oct_array = np.frompyfunc(oct, 1, 1)\n&gt;&gt;&gt; oct_array(np.array((10, 30, 100)))\narray(['0o12', '0o36', '0o144'], dtype=object)\n&gt;&gt;&gt; np.array((oct(10), oct(30), oct(100))) # for comparison\narray(['0o12', '0o36', '0o144'], dtype='&lt;U5')\n\n\n", "parameters": ["Parameters", "funcPython function object", "ninint", "noutint", "Returns", "outufunc"], "returns": "outufuncReturns a NumPy universal function (ufunc) object.", "examples": ["; oct_array = np.frompyfunc(oct, 1, 1)\n; oct_array(np.array((10, 30, 100)))\narray(['0o12', '0o36', '0o144'], dtype=object)\n; np.array((oct(10), oct(30), oct(100))) # for comparison\narray(['0o12', '0o36', '0o144'], dtype='&lt;U5')\n\n", "; oct_array = np.frompyfunc(oct, 1, 1)\n; oct_array(np.array((10, 30, 100)))\narray(['0o12', '0o36', '0o144'], dtype=object)\n; np.array((oct(10), oct(30), oct(100))) # for comparison\narray(['0o12', '0o36', '0o144'], dtype='&lt;U5')\n"]},
{"library": "numpy", "item_id": "numpy.fromfunction", "code": "\nnumpy.fromfunction(function, shape, **kwargs)[source]\u00b6", "description": "Construct an array by executing a function over each coordinate.\nThe resulting array therefore has a value fn(x, y, z) at\ncoordinate (x, y, z).\n\nParameters\n\nfunctioncallableThe function is called with N parameters, where N is the rank of\nshape.  Each parameter represents the coordinates of the array\nvarying along a specific axis.  For example, if shape\nwere (2, 2), then the parameters would be\narray([[0, 0], [1, 1]]) and array([[0, 1], [0, 1]])\n\nshape(N,) tuple of intsShape of the output array, which also determines the shape of\nthe coordinate arrays passed to function.\n\ndtypedata-type, optionalData-type of the coordinate arrays passed to function.\nBy default, dtype is float.\n\n\n\nReturns\n\nfromfunctionanyThe result of the call to function is passed back directly.\nTherefore the shape of fromfunction is completely determined by\nfunction.  If function returns a scalar value, the shape of\nfromfunction would not match the shape parameter.\n\n\n\n\n\nSee also\nindices, meshgrid\n\nNotes\nKeywords other than dtype are passed to function.\nExamples\n&gt;&gt;&gt; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n\n&gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n", "parameters": ["Parameters", "functioncallable", "shape(N,) tuple of ints", "dtypedata-type, optional", "Returns", "fromfunctionany"], "returns": "fromfunctionanyThe result of the call to function is passed back directly.Therefore the shape of fromfunction is completely determined byfunction.  If function returns a scalar value, the shape offromfunction would not match the shape parameter.", "examples": ["; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n", "; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n", "; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n", "; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.fromfunction", "code": "\nnumpy.ma.fromfunction(function, shape, **kwargs) = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Construct an array by executing a function over each coordinate.\nThe resulting array therefore has a value fn(x, y, z) at\ncoordinate (x, y, z).\n\nParameters\n\nfunctioncallableThe function is called with N parameters, where N is the rank of\nshape.  Each parameter represents the coordinates of the array\nvarying along a specific axis.  For example, if shape\nwere (2, 2), then the parameters would be\narray([[0, 0], [1, 1]]) and array([[0, 1], [0, 1]])\n\nshape(N,) tuple of intsShape of the output array, which also determines the shape of\nthe coordinate arrays passed to function.\n\ndtypedata-type, optionalData-type of the coordinate arrays passed to function.\nBy default, dtype is float.\n\n\n\nReturns\n\nfromfunctionanyThe result of the call to function is passed back directly.\nTherefore the shape of fromfunction is completely determined by\nfunction.  If function returns a scalar value, the shape of\nfromfunction would not match the shape parameter.\n\n\n\n\n\nSee also\nindices, meshgrid\n\nNotes\nKeywords other than dtype are passed to function.\nExamples\n&gt;&gt;&gt; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n\n&gt;&gt;&gt; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n\n", "parameters": ["Parameters", "functioncallable", "shape(N,) tuple of ints", "dtypedata-type, optional", "Returns", "fromfunctionany"], "returns": "fromfunctionanyThe result of the call to function is passed back directly.Therefore the shape of fromfunction is completely determined byfunction.  If function returns a scalar value, the shape offromfunction would not match the shape parameter.", "examples": ["; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n\n", "; np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)\narray([[ True, False, False],\n       [False,  True, False],\n       [False, False,  True]])\n", "; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n\n", "; np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)\narray([[0, 1, 2],\n       [1, 2, 3],\n       [2, 3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.core.records.fromfile", "code": "\nnumpy.core.records.fromfile(fd, dtype=None, shape=None, offset=0, formats=None, names=None, titles=None, aligned=False, byteorder=None)[source]\u00b6", "description": "Create an array from binary file data\nIf file is a string or a path-like object then that file is opened,\nelse it is assumed to be a file object. The file object must\nsupport random access (i.e. it must have tell and seek methods).\n&gt;&gt;&gt; from tempfile import TemporaryFile\n&gt;&gt;&gt; a = np.empty(10,dtype='f8,i4,a5')\n&gt;&gt;&gt; a[5] = (0.5,10,'abcde')\n&gt;&gt;&gt;\n&gt;&gt;&gt; fd=TemporaryFile()\n&gt;&gt;&gt; a = a.newbyteorder('&lt;')\n&gt;&gt;&gt; a.tofile(fd)\n&gt;&gt;&gt;\n&gt;&gt;&gt; _ = fd.seek(0)\n&gt;&gt;&gt; r=np.core.records.fromfile(fd, formats='f8,i4,a5', shape=10,\n... byteorder='&lt;')\n&gt;&gt;&gt; print(r[5])\n(0.5, 10, 'abcde')\n&gt;&gt;&gt; r.shape\n(10,)\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fromfile", "code": "\nnumpy.fromfile(file, dtype=float, count=-1, sep='', offset=0)\u00b6", "description": "Construct an array from data in a text or binary file.\nA highly efficient way of reading binary data with a known data-type,\nas well as parsing simply formatted text files.  Data written using the\ntofile method can be read using this function.\n\nParameters\n\nfilefile or str or PathOpen file object or filename.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\ndtypedata-typeData type of the returned array.\nFor binary files, it is used to determine the size and byte-order\nof the items in the file.\nMost builtin numeric types are supported and extension types may be supported.\n\nNew in version 1.18.0: Complex dtypes.\n\n\ncountintNumber of items to read. -1 means all items (i.e., the complete\nfile).\n\nsepstrSeparator between items if file is a text file.\nEmpty (\u201c\u201d) separator means the file should be treated as binary.\nSpaces (\u201d \u201c) in the separator match zero or more whitespace characters.\nA separator consisting only of spaces must match at least one\nwhitespace.\n\noffsetintThe offset (in bytes) from the file\u2019s current position. Defaults to 0.\nOnly permitted for binary files.\n\nNew in version 1.17.0.\n\n\n\n\n\n\nSee also\nload, save, ndarray.tofile\n\nloadtxtMore flexible way of loading data from a text file.\n\n\n\nNotes\nDo not rely on the combination of tofile and fromfile for\ndata storage, as the binary files generated are not platform\nindependent.  In particular, no byte-order or data-type information is\nsaved.  Data can be stored in the platform independent .npy format\nusing save and load instead.\nExamples\nConstruct an ndarray:\n&gt;&gt;&gt; dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),\n...                ('temp', float)])\n&gt;&gt;&gt; x = np.zeros((1,), dtype=dt)\n&gt;&gt;&gt; x['time']['min'] = 10; x['temp'] = 98.25\n&gt;&gt;&gt; x\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n\nSave the raw data to disk:\n&gt;&gt;&gt; import tempfile\n&gt;&gt;&gt; fname = tempfile.mkstemp()[1]\n&gt;&gt;&gt; x.tofile(fname)\n\n\nRead the raw data from disk:\n&gt;&gt;&gt; np.fromfile(fname, dtype=dt)\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n\nThe recommended way to store and load data:\n&gt;&gt;&gt; np.save(fname, x)\n&gt;&gt;&gt; np.load(fname + '.npy')\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n\n", "parameters": ["Parameters", "filefile or str or Path", "dtypedata-type", "countint", "sepstr", "offsetint"], "returns": [], "examples": ["; dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),\n...                ('temp', float)])\n; x = np.zeros((1,), dtype=dt)\n; x['time']['min'] = 10; x['temp'] = 98.25\n; x\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n", "; dt = np.dtype([('time', [('min', np.int64), ('sec', np.int64)]),\n...                ('temp', float)])\n; x = np.zeros((1,), dtype=dt)\n; x['time']['min'] = 10; x['temp'] = 98.25\n; x\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n", "; import tempfile\n; fname = tempfile.mkstemp()[1]\n; x.tofile(fname)\n\n", "; import tempfile\n; fname = tempfile.mkstemp()[1]\n; x.tofile(fname)\n", "; np.fromfile(fname, dtype=dt)\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n", "; np.fromfile(fname, dtype=dt)\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n", "; np.save(fname, x)\n; np.load(fname + '.npy')\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n\n", "; np.save(fname, x)\n; np.load(fname + '.npy')\narray([((10, 0), 98.25)],\n      dtype=[('time', [('min', '&lt;i8'), ('sec', '&lt;i8')]), ('temp', '&lt;f8')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.frombuffer", "code": "\nnumpy.ma.frombuffer(buffer, dtype=float, count=-1, offset=0) = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Interpret a buffer as a 1-dimensional array.\n\nParameters\n\nbufferbuffer_likeAn object that exposes the buffer interface.\n\ndtypedata-type, optionalData-type of the returned array; default: float.\n\ncountint, optionalNumber of items to read. -1 means all data in the buffer.\n\noffsetint, optionalStart reading the buffer from this offset (in bytes); default: 0.\n\n\n\n\nNotes\nIf the buffer has data that is not in machine byte-order, this should\nbe specified as part of the data-type, e.g.:\n&gt;&gt;&gt; dt = np.dtype(int)\n&gt;&gt;&gt; dt = dt.newbyteorder('&gt;')\n&gt;&gt;&gt; np.frombuffer(buf, dtype=dt) \n\n\nThe data of the resulting array will not be byteswapped, but will be\ninterpreted correctly.\nExamples\n&gt;&gt;&gt; s = b'hello world'\n&gt;&gt;&gt; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n\n&gt;&gt;&gt; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n&gt;&gt;&gt; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "bufferbuffer_like", "dtypedata-type, optional", "countint, optional", "offsetint, optional"], "returns": [], "examples": ["; s = b'hello world'\n; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n", "; s = b'hello world'\n; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n", "; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\n", "; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.frombuffer", "code": "\nnumpy.frombuffer(buffer, dtype=float, count=-1, offset=0)\u00b6", "description": "Interpret a buffer as a 1-dimensional array.\n\nParameters\n\nbufferbuffer_likeAn object that exposes the buffer interface.\n\ndtypedata-type, optionalData-type of the returned array; default: float.\n\ncountint, optionalNumber of items to read. -1 means all data in the buffer.\n\noffsetint, optionalStart reading the buffer from this offset (in bytes); default: 0.\n\n\n\n\nNotes\nIf the buffer has data that is not in machine byte-order, this should\nbe specified as part of the data-type, e.g.:\n&gt;&gt;&gt; dt = np.dtype(int)\n&gt;&gt;&gt; dt = dt.newbyteorder('&gt;')\n&gt;&gt;&gt; np.frombuffer(buf, dtype=dt) \n\n\nThe data of the resulting array will not be byteswapped, but will be\ninterpreted correctly.\nExamples\n&gt;&gt;&gt; s = b'hello world'\n&gt;&gt;&gt; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n\n&gt;&gt;&gt; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n&gt;&gt;&gt; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "bufferbuffer_like", "dtypedata-type, optional", "countint, optional", "offsetint, optional"], "returns": [], "examples": ["; s = b'hello world'\n; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n\n", "; s = b'hello world'\n; np.frombuffer(s, dtype='S1', count=5, offset=6)\narray([b'w', b'o', b'r', b'l', b'd'], dtype='|S1')\n", "; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n\n", "; np.frombuffer(b'\\x01\\x02', dtype=np.uint8)\narray([1, 2], dtype=uint8)\n; np.frombuffer(b'\\x01\\x02\\x03\\x04\\x05', dtype=np.uint8, count=3)\narray([1, 2, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.core.records.fromarrays", "code": "\nnumpy.core.records.fromarrays(arrayList, dtype=None, shape=None, formats=None, names=None, titles=None, aligned=False, byteorder=None)[source]\u00b6", "description": "create a record array from a (flat) list of arrays\n&gt;&gt;&gt; x1=np.array([1,2,3,4])\n&gt;&gt;&gt; x2=np.array(['a','dd','xyz','12'])\n&gt;&gt;&gt; x3=np.array([1.1,2,3,4])\n&gt;&gt;&gt; r = np.core.records.fromarrays([x1,x2,x3],names='a,b,c')\n&gt;&gt;&gt; print(r[1])\n(2, 'dd', 2.0) # may vary\n&gt;&gt;&gt; x1[1]=34\n&gt;&gt;&gt; r.a\narray([1, 2, 3, 4])\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.frexp", "code": "\nnumpy.frexp(x, [out1, out2, ]/, [out=(None, None), ]*, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'frexp'&gt;\u00b6", "description": "Decompose the elements of x into mantissa and twos exponent.\nReturns (mantissa, exponent), where x = mantissa * 2**exponent`.\nThe mantissa is lies in the open interval(-1, 1), while the twos\nexponent is a signed integer.\n\nParameters\n\nxarray_likeArray of numbers to be decomposed.\n\nout1ndarray, optionalOutput array for the mantissa. Must have the same shape as x.\n\nout2ndarray, optionalOutput array for the exponent. Must have the same shape as x.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nmantissandarrayFloating values between -1 and 1.\nThis is a scalar if x is a scalar.\n\nexponentndarrayInteger exponents of 2.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nldexpCompute y = x1 * 2**x2, the inverse of frexp.\n\n\n\nNotes\nComplex dtypes are not supported, they will raise a TypeError.\nExamples\n&gt;&gt;&gt; x = np.arange(9)\n&gt;&gt;&gt; y1, y2 = np.frexp(x)\n&gt;&gt;&gt; y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n&gt;&gt;&gt; y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n&gt;&gt;&gt; y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n\n\n", "parameters": ["Parameters", "xarray_like", "out1ndarray, optional", "out2ndarray, optional", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "mantissandarray", "exponentndarray"], "returns": "mantissandarrayFloating values between -1 and 1.This is a scalar if x is a scalar.exponentndarrayInteger exponents of 2.This is a scalar if x is a scalar.", "examples": ["; x = np.arange(9)\n; y1, y2 = np.frexp(x)\n; y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n; y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n; y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n\n", "; x = np.arange(9)\n; y1, y2 = np.frexp(x)\n; y1\narray([ 0.   ,  0.5  ,  0.5  ,  0.75 ,  0.5  ,  0.625,  0.75 ,  0.875,\n        0.5  ])\n; y2\narray([0, 1, 2, 2, 3, 3, 3, 3, 4])\n; y1 * 2**y2\narray([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.])\n"]},
{"library": "numpy", "item_id": "numpy.format_parser", "code": "\nclass numpy.format_parser(formats, names, titles, aligned=False, byteorder=None)[source]\u00b6", "description": "Class to convert formats, names, titles description to a dtype.\nAfter constructing the format_parser object, the dtype attribute is\nthe converted data-type:\ndtype = format_parser(formats, names, titles).dtype\n\nParameters\n\nformatsstr or list of strThe format description, either specified as a string with\ncomma-separated format descriptions in the form 'f8, i4, a5', or\na list of format description strings  in the form\n['f8', 'i4', 'a5'].\n\nnamesstr or list/tuple of strThe field names, either specified as a comma-separated string in the\nform 'col1, col2, col3', or as a list or tuple of strings in the\nform ['col1', 'col2', 'col3'].\nAn empty list can be used, in that case default field names\n(\u2018f0\u2019, \u2018f1\u2019, \u2026) are used.\n\ntitlessequenceSequence of title strings. An empty list can be used to leave titles\nout.\n\nalignedbool, optionalIf True, align the fields by padding as the C-compiler would.\nDefault is False.\n\nbyteorderstr, optionalIf specified, all the fields will be changed to the\nprovided byte-order.  Otherwise, the default byte-order is\nused. For all available string specifiers, see dtype.newbyteorder.\n\n\n\n\n\nSee also\ndtype, typename, sctype2char\n\nExamples\n&gt;&gt;&gt; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], ['col1', 'col2', 'col3'],\n...                  ['T1', 'T2', 'T3']).dtype\ndtype([(('T1', 'col1'), '&lt;f8'), (('T2', 'col2'), '&lt;i4'), (('T3', 'col3'), 'S5')])\n\n\nnames and/or titles can be empty lists. If titles is an empty list,\ntitles will simply not appear. If names is empty, default field names\nwill be used.\n&gt;&gt;&gt; np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n...                  []).dtype\ndtype([('col1', '&lt;f8'), ('col2', '&lt;i4'), ('col3', '&lt;S5')])\n&gt;&gt;&gt; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], [], []).dtype\ndtype([('f0', '&lt;f8'), ('f1', '&lt;i4'), ('f2', 'S5')])\n\n\n\nAttributes\n\ndtypedtypeThe converted data-type.\n\n\n\n\n", "parameters": ["Parameters", "formatsstr or list of str", "namesstr or list/tuple of str", "titlessequence", "alignedbool, optional", "byteorderstr, optional", "Attributes", "dtypedtype"], "returns": [], "examples": ["; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], ['col1', 'col2', 'col3'],\n...                  ['T1', 'T2', 'T3']).dtype\ndtype([(('T1', 'col1'), '&lt;f8'), (('T2', 'col2'), '&lt;i4'), (('T3', 'col3'), 'S5')])\n\n", "; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], ['col1', 'col2', 'col3'],\n...                  ['T1', 'T2', 'T3']).dtype\ndtype([(('T1', 'col1'), '&lt;f8'), (('T2', 'col2'), '&lt;i4'), (('T3', 'col3'), 'S5')])\n", "; np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n...                  []).dtype\ndtype([('col1', '&lt;f8'), ('col2', '&lt;i4'), ('col3', '&lt;S5')])\n; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], [], []).dtype\ndtype([('f0', '&lt;f8'), ('f1', '&lt;i4'), ('f2', 'S5')])\n\n", "; np.format_parser(['f8', 'i4', 'a5'], ['col1', 'col2', 'col3'],\n...                  []).dtype\ndtype([('col1', '&lt;f8'), ('col2', '&lt;i4'), ('col3', '&lt;S5')])\n; np.format_parser(['&lt;f8', '&lt;i4', '&lt;a5'], [], []).dtype\ndtype([('f0', '&lt;f8'), ('f1', '&lt;i4'), ('f2', 'S5')])\n"]},
{"library": "numpy", "item_id": "numpy.format_float_scientific", "code": "\nnumpy.format_float_scientific(x, precision=None, unique=True, trim='k', sign=False, pad_left=None, exp_digits=None)[source]\u00b6", "description": "Format a floating-point scalar as a decimal string in scientific notation.\nProvides control over rounding, trimming and padding. Uses and assumes\nIEEE unbiased rounding. Uses the \u201cDragon4\u201d algorithm.\n\nParameters\n\nxpython float or numpy floating scalarValue to format.\n\nprecisionnon-negative integer or None, optionalMaximum number of digits to print. May be None if unique is\nTrue, but must be an integer if unique is False.\n\nuniqueboolean, optionalIf True, use a digit-generation strategy which gives the shortest\nrepresentation which uniquely identifies the floating-point number from\nother values of the same type, by judicious rounding. If precision\nwas omitted, print all necessary digits, otherwise digit generation is\ncut off after precision digits and the remaining value is rounded.\nIf False, digits are generated as if printing an infinite-precision\nvalue and stopping after precision digits, rounding the remaining\nvalue.\n\ntrimone of \u2018k\u2019, \u2018.\u2019, \u20180\u2019, \u2018-\u2018, optionalControls post-processing trimming of trailing digits, as follows:\n\n\u2018k\u2019 : keep trailing zeros, keep decimal point (no trimming)\n\u2018.\u2019 : trim all trailing zeros, leave decimal point\n\u20180\u2019 : trim all but the zero before the decimal point. Insert the\nzero if it is missing.\n\u2018-\u2018 : trim trailing zeros and any trailing decimal point\n\n\nsignboolean, optionalWhether to show the sign for positive values.\n\npad_leftnon-negative integer, optionalPad the left side of the string with whitespace until at least that\nmany characters are to the left of the decimal point.\n\nexp_digitsnon-negative integer, optionalPad the exponent with zeros until it contains at least this many digits.\nIf omitted, the exponent will be at least 2 digits.\n\n\n\nReturns\n\nrepstringThe string representation of the floating point value\n\n\n\n\n\nSee also\nformat_float_positional\n\nExamples\n&gt;&gt;&gt; np.format_float_scientific(np.float32(np.pi))\n'3.1415927e+00'\n&gt;&gt;&gt; s = np.float32(1.23e24)\n&gt;&gt;&gt; np.format_float_scientific(s, unique=False, precision=15)\n'1.230000071797338e+24'\n&gt;&gt;&gt; np.format_float_scientific(s, exp_digits=4)\n'1.23e+0024'\n\n\n", "parameters": ["Parameters", "xpython float or numpy floating scalar", "precisionnon-negative integer or None, optional", "uniqueboolean, optional", "trimone of \u2018k\u2019, \u2018.\u2019, \u20180\u2019, \u2018-\u2018, optional", "signboolean, optional", "pad_leftnon-negative integer, optional", "exp_digitsnon-negative integer, optional", "Returns", "repstring"], "returns": "repstringThe string representation of the floating point value", "examples": ["; np.format_float_scientific(np.float32(np.pi))\n'3.1415927e+00'\n; s = np.float32(1.23e24)\n; np.format_float_scientific(s, unique=False, precision=15)\n'1.230000071797338e+24'\n; np.format_float_scientific(s, exp_digits=4)\n'1.23e+0024'\n\n", "; np.format_float_scientific(np.float32(np.pi))\n'3.1415927e+00'\n; s = np.float32(1.23e24)\n; np.format_float_scientific(s, unique=False, precision=15)\n'1.230000071797338e+24'\n; np.format_float_scientific(s, exp_digits=4)\n'1.23e+0024'\n"]},
{"library": "numpy", "item_id": "numpy.fmin", "code": "\nnumpy.fmin(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'fmin'&gt;\u00b6", "description": "Element-wise minimum of array elements.\nCompare two arrays and returns a new array containing the element-wise\nminima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n\nx1, x2array_likeThe arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe minimum of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfmaxElement-wise maximum of two arrays, ignores NaNs.\n\nminimumElement-wise minimum of two arrays, propagates NaNs.\n\naminThe minimum value of an array along a given axis, propagates NaNs.\n\nnanminThe minimum value of an array along a given axis, ignores NaNs.\n\n\nmaximum, amax, nanmax\n\nNotes\n\nNew in version 1.3.0.\n\nThe fmin is equivalent to np.where(x1 &lt;= x2, x1, x2) when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\nExamples\n&gt;&gt;&gt; np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n\n&gt;&gt;&gt; np.fmin(np.eye(2), [0.5, 2])\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n\n&gt;&gt;&gt; np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe minimum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n\n", "; np.fmin([2, 3, 4], [1, 5, 2])\narray([1, 3, 2])\n", "; np.fmin(np.eye(2), [0.5, 2])\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n\n", "; np.fmin(np.eye(2), [0.5, 2])\narray([[ 0.5,  0. ],\n       [ 0. ,  1. ]])\n", "; np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n\n", "; np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n"]},
{"library": "numpy", "item_id": "numpy.format_float_positional", "code": "\nnumpy.format_float_positional(x, precision=None, unique=True, fractional=True, trim='k', sign=False, pad_left=None, pad_right=None)[source]\u00b6", "description": "Format a floating-point scalar as a decimal string in positional notation.\nProvides control over rounding, trimming and padding. Uses and assumes\nIEEE unbiased rounding. Uses the \u201cDragon4\u201d algorithm.\n\nParameters\n\nxpython float or numpy floating scalarValue to format.\n\nprecisionnon-negative integer or None, optionalMaximum number of digits to print. May be None if unique is\nTrue, but must be an integer if unique is False.\n\nuniqueboolean, optionalIf True, use a digit-generation strategy which gives the shortest\nrepresentation which uniquely identifies the floating-point number from\nother values of the same type, by judicious rounding. If precision\nwas omitted, print out all necessary digits, otherwise digit generation\nis cut off after precision digits and the remaining value is rounded.\nIf False, digits are generated as if printing an infinite-precision\nvalue and stopping after precision digits, rounding the remaining\nvalue.\n\nfractionalboolean, optionalIf True, the cutoff of precision digits refers to the total number\nof digits after the decimal point, including leading zeros.\nIf False, precision refers to the total number of significant\ndigits, before or after the decimal point, ignoring leading zeros.\n\ntrimone of \u2018k\u2019, \u2018.\u2019, \u20180\u2019, \u2018-\u2018, optionalControls post-processing trimming of trailing digits, as follows:\n\n\u2018k\u2019 : keep trailing zeros, keep decimal point (no trimming)\n\u2018.\u2019 : trim all trailing zeros, leave decimal point\n\u20180\u2019 : trim all but the zero before the decimal point. Insert the\nzero if it is missing.\n\u2018-\u2018 : trim trailing zeros and any trailing decimal point\n\n\nsignboolean, optionalWhether to show the sign for positive values.\n\npad_leftnon-negative integer, optionalPad the left side of the string with whitespace until at least that\nmany characters are to the left of the decimal point.\n\npad_rightnon-negative integer, optionalPad the right side of the string with whitespace until at least that\nmany characters are to the right of the decimal point.\n\n\n\nReturns\n\nrepstringThe string representation of the floating point value\n\n\n\n\n\nSee also\nformat_float_scientific\n\nExamples\n&gt;&gt;&gt; np.format_float_positional(np.float32(np.pi))\n'3.1415927'\n&gt;&gt;&gt; np.format_float_positional(np.float16(np.pi))\n'3.14'\n&gt;&gt;&gt; np.format_float_positional(np.float16(0.3))\n'0.3'\n&gt;&gt;&gt; np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n'0.3000488281'\n\n\n", "parameters": ["Parameters", "xpython float or numpy floating scalar", "precisionnon-negative integer or None, optional", "uniqueboolean, optional", "fractionalboolean, optional", "trimone of \u2018k\u2019, \u2018.\u2019, \u20180\u2019, \u2018-\u2018, optional", "signboolean, optional", "pad_leftnon-negative integer, optional", "pad_rightnon-negative integer, optional", "Returns", "repstring"], "returns": "repstringThe string representation of the floating point value", "examples": ["; np.format_float_positional(np.float32(np.pi))\n'3.1415927'\n; np.format_float_positional(np.float16(np.pi))\n'3.14'\n; np.format_float_positional(np.float16(0.3))\n'0.3'\n; np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n'0.3000488281'\n\n", "; np.format_float_positional(np.float32(np.pi))\n'3.1415927'\n; np.format_float_positional(np.float16(np.pi))\n'3.14'\n; np.format_float_positional(np.float16(0.3))\n'0.3'\n; np.format_float_positional(np.float16(0.3), unique=False, precision=10)\n'0.3000488281'\n"]},
{"library": "numpy", "item_id": "numpy.fmod", "code": "\nnumpy.fmod(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'fmod'&gt;\u00b6", "description": "Return the element-wise remainder of division.\nThis is the NumPy implementation of the C library function fmod, the\nremainder has the same sign as the dividend x1. It is equivalent to\nthe Matlab(TM) rem function and should not be confused with the\nPython modulus operator x1 % x2.\n\nParameters\n\nx1array_likeDividend.\n\nx2array_likeDivisor. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyarray_likeThe remainder of the division of x1 by x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nremainderEquivalent to the Python % operator.\n\n\ndivide\n\nNotes\nThe result of the modulo operation for negative dividend and divisors\nis bound by conventions. For fmod, the sign of result is the sign of\nthe dividend, while for remainder the sign of the result is the sign\nof the divisor. The fmod function is equivalent to the Matlab(TM)\nrem function.\nExamples\n&gt;&gt;&gt; np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n&gt;&gt;&gt; np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n\n&gt;&gt;&gt; np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n&gt;&gt;&gt; a = np.arange(-3, 3).reshape(3, 2)\n&gt;&gt;&gt; a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n&gt;&gt;&gt; np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yarray_like"], "returns": "yarray_likeThe remainder of the division of x1 by x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n; np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n\n", "; np.fmod([-3, -2, -1, 1, 2, 3], 2)\narray([-1,  0, -1,  1,  0,  1])\n; np.remainder([-3, -2, -1, 1, 2, 3], 2)\narray([1, 0, 1, 1, 0, 1])\n", "; np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n; a = np.arange(-3, 3).reshape(3, 2)\n; a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n; np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])\n\n", "; np.fmod([5, 3], [2, 2.])\narray([ 1.,  1.])\n; a = np.arange(-3, 3).reshape(3, 2)\n; a\narray([[-3, -2],\n       [-1,  0],\n       [ 1,  2]])\n; np.fmod(a, [2,2])\narray([[-1,  0],\n       [-1,  0],\n       [ 1,  0]])\n"]},
{"library": "numpy", "item_id": "numpy.floor", "code": "\nnumpy.floor(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'floor'&gt;\u00b6", "description": "Return the floor of the input, element-wise.\nThe floor of the scalar x is the largest integer i, such that\ni &lt;= x.  It is often denoted as .\n\nParameters\n\nxarray_likeInput data.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe floor of each element in x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nceil, trunc, rint\n\nNotes\nSome spreadsheet programs calculate the \u201cfloor-towards-zero\u201d, in other\nwords floor(-2.5) == -2.  NumPy instead uses the definition of\nfloor where floor(-2.5) == -3.\nExamples\n&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n&gt;&gt;&gt; np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe floor of each element in x.This is a scalar if x is a scalar.", "examples": ["; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])\n\n", "; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.floor(a)\narray([-2., -2., -1.,  0.,  1.,  1.,  2.])\n"]},
{"library": "numpy", "item_id": "numpy.fmax", "code": "\nnumpy.fmax(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'fmax'&gt;\u00b6", "description": "Element-wise maximum of array elements.\nCompare two arrays and returns a new array containing the element-wise\nmaxima. If one of the elements being compared is a NaN, then the\nnon-nan element is returned. If both elements are NaNs then the first\nis returned.  The latter distinction is important for complex NaNs,\nwhich are defined as at least one of the real or imaginary parts being\na NaN. The net effect is that NaNs are ignored when possible.\n\nParameters\n\nx1, x2array_likeThe arrays holding the elements to be compared. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe maximum of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfminElement-wise minimum of two arrays, ignores NaNs.\n\nmaximumElement-wise maximum of two arrays, propagates NaNs.\n\namaxThe maximum value of an array along a given axis, propagates NaNs.\n\nnanmaxThe maximum value of an array along a given axis, ignores NaNs.\n\n\nminimum, amin, nanmin\n\nNotes\n\nNew in version 1.3.0.\n\nThe fmax is equivalent to np.where(x1 &gt;= x2, x1, x2) when neither\nx1 nor x2 are NaNs, but it is faster and does proper broadcasting.\nExamples\n&gt;&gt;&gt; np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n\n\n&gt;&gt;&gt; np.fmax(np.eye(2), [0.5, 2])\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n\n&gt;&gt;&gt; np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe maximum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n\n", "; np.fmax([2, 3, 4], [1, 5, 2])\narray([ 2.,  5.,  4.])\n", "; np.fmax(np.eye(2), [0.5, 2])\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n\n", "; np.fmax(np.eye(2), [0.5, 2])\narray([[ 1. ,  2. ],\n       [ 0.5,  2. ]])\n", "; np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n\n", "; np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan])\narray([ 0.,  0., nan])\n"]},
{"library": "numpy", "item_id": "numpy.float_power", "code": "\nnumpy.float_power(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'float_power'&gt;\u00b6", "description": "First array elements raised to powers from second array, element-wise.\nRaise each base in x1 to the positionally-corresponding power in x2.\nx1 and x2 must be broadcastable to the same shape. This differs from\nthe power function in that integers, float16, and float32  are promoted to\nfloats with a minimum precision of float64 so that the result is always\ninexact.  The intent is that the function will return a usable result for\nnegative powers and seldom overflow for positive powers.\n\nNew in version 1.12.0.\n\n\nParameters\n\nx1array_likeThe bases.\n\nx2array_likeThe exponents. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe bases in x1 raised to the exponents in x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\npowerpower function that preserves type\n\n\n\nExamples\nCube each element in a list.\n&gt;&gt;&gt; x1 = range(6)\n&gt;&gt;&gt; x1\n[0, 1, 2, 3, 4, 5]\n&gt;&gt;&gt; np.float_power(x1, 3)\narray([   0.,    1.,    8.,   27.,   64.,  125.])\n\n\nRaise the bases to different exponents.\n&gt;&gt;&gt; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n&gt;&gt;&gt; np.float_power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\n\nThe effect of broadcasting.\n&gt;&gt;&gt; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n&gt;&gt;&gt; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n&gt;&gt;&gt; np.float_power(x1, x2)\narray([[  0.,   1.,   8.,  27.,  16.,   5.],\n       [  0.,   1.,   8.,  27.,  16.,   5.]])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe bases in x1 raised to the exponents in x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; x1 = range(6)\n; x1\n[0, 1, 2, 3, 4, 5]\n; np.float_power(x1, 3)\narray([   0.,    1.,    8.,   27.,   64.,  125.])\n\n", "; x1 = range(6)\n; x1\n[0, 1, 2, 3, 4, 5]\n; np.float_power(x1, 3)\narray([   0.,    1.,    8.,   27.,   64.,  125.])\n", "; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n; np.float_power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n\n", "; x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0]\n; np.float_power(x1, x2)\narray([  0.,   1.,   8.,  27.,  16.,   5.])\n", "; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n; np.float_power(x1, x2)\narray([[  0.,   1.,   8.,  27.,  16.,   5.],\n       [  0.,   1.,   8.,  27.,  16.,   5.]])\n\n", "; x2 = np.array([[1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1]])\n; x2\narray([[1, 2, 3, 3, 2, 1],\n       [1, 2, 3, 3, 2, 1]])\n; np.float_power(x1, x2)\narray([[  0.,   1.,   8.,  27.,  16.,   5.],\n       [  0.,   1.,   8.,  27.,  16.,   5.]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.flush", "code": "\nmemmap.flush(self)[source]\u00b6", "description": "Write any changes in the array to the file on disk.\nFor further information, see memmap.\n\nParameters\n\nNone\n\n\n\n\nSee also\nmemmap\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.floor_divide", "code": "\nnumpy.floor_divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'floor_divide'&gt;\u00b6", "description": "Return the largest integer smaller or equal to the division of the inputs.\nIt is equivalent to the Python // operator and pairs with the\nPython % (remainder), function so that a = a % b + b * (a // b)\nup to roundoff.\n\nParameters\n\nx1array_likeNumerator.\n\nx2array_likeDenominator. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayy = floor(x1/x2)\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nremainderRemainder complementary to floor_divide.\n\ndivmodSimultaneous floor division and remainder.\n\ndivideStandard division.\n\nfloorRound a number to the nearest integer toward minus infinity.\n\nceilRound a number to the nearest integer toward infinity.\n\n\n\nExamples\n&gt;&gt;&gt; np.floor_divide(7,3)\n2\n&gt;&gt;&gt; np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayy = floor(x1/x2)This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.floor_divide(7,3)\n2\n; np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\n\n", "; np.floor_divide(7,3)\n2\n; np.floor_divide([1., 2., 3., 4.], 2.5)\narray([ 0.,  0.,  1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.flipud", "code": "\nnumpy.flipud(m)[source]\u00b6", "description": "Flip array in the up/down direction.\nFlip the entries in each column in the up/down direction.\nRows are preserved, but appear in a different order than before.\n\nParameters\n\nmarray_likeInput array.\n\n\n\nReturns\n\noutarray_likeA view of m with the rows reversed.  Since a view is\nreturned, this operation is .\n\n\n\n\n\nSee also\n\nfliplrFlip array in the left/right direction.\n\nrot90Rotate array counterclockwise.\n\n\n\nNotes\nEquivalent to m[::-1,...].\nDoes not require the array to be two-dimensional.\nExamples\n&gt;&gt;&gt; A = np.diag([1.0, 2, 3])\n&gt;&gt;&gt; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n&gt;&gt;&gt; np.flipud(A)\narray([[0.,  0.,  3.],\n       [0.,  2.,  0.],\n       [1.,  0.,  0.]])\n\n\n&gt;&gt;&gt; A = np.random.randn(2,3,5)\n&gt;&gt;&gt; np.all(np.flipud(A) == A[::-1,...])\nTrue\n\n\n&gt;&gt;&gt; np.flipud([1,2])\narray([2, 1])\n\n\n", "parameters": ["Parameters", "marray_like", "Returns", "outarray_like"], "returns": "outarray_likeA view of m with the rows reversed.  Since a view isreturned, this operation is .", "examples": ["; A = np.diag([1.0, 2, 3])\n; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n; np.flipud(A)\narray([[0.,  0.,  3.],\n       [0.,  2.,  0.],\n       [1.,  0.,  0.]])\n\n", "; A = np.diag([1.0, 2, 3])\n; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n; np.flipud(A)\narray([[0.,  0.,  3.],\n       [0.,  2.,  0.],\n       [1.,  0.,  0.]])\n", "; A = np.random.randn(2,3,5)\n; np.all(np.flipud(A) == A[::-1,...])\nTrue\n\n", "; A = np.random.randn(2,3,5)\n; np.all(np.flipud(A) == A[::-1,...])\nTrue\n", "; np.flipud([1,2])\narray([2, 1])\n\n", "; np.flipud([1,2])\narray([2, 1])\n"]},
{"library": "numpy", "item_id": "numpy.record.flatten", "code": "\nrecord.flatten()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fliplr", "code": "\nnumpy.fliplr(m)[source]\u00b6", "description": "Flip array in the left/right direction.\nFlip the entries in each row in the left/right direction.\nColumns are preserved, but appear in a different order than before.\n\nParameters\n\nmarray_likeInput array, must be at least 2-D.\n\n\n\nReturns\n\nfndarrayA view of m with the columns reversed.  Since a view\nis returned, this operation is .\n\n\n\n\n\nSee also\n\nflipudFlip array in the up/down direction.\n\nrot90Rotate array counterclockwise.\n\n\n\nNotes\nEquivalent to m[:,::-1]. Requires the array to be at least 2-D.\nExamples\n&gt;&gt;&gt; A = np.diag([1.,2.,3.])\n&gt;&gt;&gt; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n&gt;&gt;&gt; np.fliplr(A)\narray([[0.,  0.,  1.],\n       [0.,  2.,  0.],\n       [3.,  0.,  0.]])\n\n\n&gt;&gt;&gt; A = np.random.randn(2,3,5)\n&gt;&gt;&gt; np.all(np.fliplr(A) == A[:,::-1,...])\nTrue\n\n\n", "parameters": ["Parameters", "marray_like", "Returns", "fndarray"], "returns": "fndarrayA view of m with the columns reversed.  Since a viewis returned, this operation is .", "examples": ["; A = np.diag([1.,2.,3.])\n; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n; np.fliplr(A)\narray([[0.,  0.,  1.],\n       [0.,  2.,  0.],\n       [3.,  0.,  0.]])\n\n", "; A = np.diag([1.,2.,3.])\n; A\narray([[1.,  0.,  0.],\n       [0.,  2.,  0.],\n       [0.,  0.,  3.]])\n; np.fliplr(A)\narray([[0.,  0.,  1.],\n       [0.,  2.,  0.],\n       [3.,  0.,  0.]])\n", "; A = np.random.randn(2,3,5)\n; np.all(np.fliplr(A) == A[:,::-1,...])\nTrue\n\n", "; A = np.random.randn(2,3,5)\n; np.all(np.fliplr(A) == A[:,::-1,...])\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.flip", "code": "\nnumpy.flip(m, axis=None)[source]\u00b6", "description": "Reverse the order of elements in an array along the given axis.\nThe shape of the array is preserved, but the elements are reordered.\n\nNew in version 1.12.0.\n\n\nParameters\n\nmarray_likeInput array.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which to flip over. The default,\naxis=None, will flip over all of the axes of the input array.\nIf axis is negative it counts from the last to the first axis.\nIf axis is a tuple of ints, flipping is performed on all of the axes\nspecified in the tuple.\n\nChanged in version 1.15.0: None and tuples of axes are supported\n\n\n\n\nReturns\n\noutarray_likeA view of m with the entries of axis reversed.  Since a view is\nreturned, this operation is done in constant time.\n\n\n\n\n\nSee also\n\nflipudFlip an array vertically (axis=0).\n\nfliplrFlip an array horizontally (axis=1).\n\n\n\nNotes\nflip(m, 0) is equivalent to flipud(m).\nflip(m, 1) is equivalent to fliplr(m).\nflip(m, n) corresponds to m[...,::-1,...] with ::-1 at position n.\nflip(m) corresponds to m[::-1,::-1,...,::-1] with ::-1 at all\npositions.\nflip(m, (0, 1)) corresponds to m[::-1,::-1,...] with ::-1 at\nposition 0 and position 1.\nExamples\n&gt;&gt;&gt; A = np.arange(8).reshape((2,2,2))\n&gt;&gt;&gt; A\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n&gt;&gt;&gt; np.flip(A, 0)\narray([[[4, 5],\n        [6, 7]],\n       [[0, 1],\n        [2, 3]]])\n&gt;&gt;&gt; np.flip(A, 1)\narray([[[2, 3],\n        [0, 1]],\n       [[6, 7],\n        [4, 5]]])\n&gt;&gt;&gt; np.flip(A)\narray([[[7, 6],\n        [5, 4]],\n       [[3, 2],\n        [1, 0]]])\n&gt;&gt;&gt; np.flip(A, (0, 2))\narray([[[5, 4],\n        [7, 6]],\n       [[1, 0],\n        [3, 2]]])\n&gt;&gt;&gt; A = np.random.randn(3,4,5)\n&gt;&gt;&gt; np.all(np.flip(A,2) == A[:,:,::-1,...])\nTrue\n\n\n", "parameters": ["Parameters", "marray_like", "axisNone or int or tuple of ints, optional", "Returns", "outarray_like"], "returns": "outarray_likeA view of m with the entries of axis reversed.  Since a view isreturned, this operation is done in constant time.", "examples": ["; A = np.arange(8).reshape((2,2,2))\n; A\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; np.flip(A, 0)\narray([[[4, 5],\n        [6, 7]],\n       [[0, 1],\n        [2, 3]]])\n; np.flip(A, 1)\narray([[[2, 3],\n        [0, 1]],\n       [[6, 7],\n        [4, 5]]])\n; np.flip(A)\narray([[[7, 6],\n        [5, 4]],\n       [[3, 2],\n        [1, 0]]])\n; np.flip(A, (0, 2))\narray([[[5, 4],\n        [7, 6]],\n       [[1, 0],\n        [3, 2]]])\n; A = np.random.randn(3,4,5)\n; np.all(np.flip(A,2) == A[:,:,::-1,...])\nTrue\n\n", "; A = np.arange(8).reshape((2,2,2))\n; A\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; np.flip(A, 0)\narray([[[4, 5],\n        [6, 7]],\n       [[0, 1],\n        [2, 3]]])\n; np.flip(A, 1)\narray([[[2, 3],\n        [0, 1]],\n       [[6, 7],\n        [4, 5]]])\n; np.flip(A)\narray([[[7, 6],\n        [5, 4]],\n       [[3, 2],\n        [1, 0]]])\n; np.flip(A, (0, 2))\narray([[[5, 4],\n        [7, 6]],\n       [[1, 0],\n        [3, 2]]])\n; A = np.random.randn(3,4,5)\n; np.all(np.flip(A,2) == A[:,:,::-1,...])\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.recarray.flatten", "code": "\nrecarray.flatten(order='C')\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.flatten", "code": "\nndarray.flatten(order='C')\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.flatten", "code": "\nmemmap.flatten(order='C')\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.flatten", "code": "\nmatrix.flatten(self, order='C')[source]\u00b6", "description": "Return a flattened copy of the matrix.\nAll N elements of the matrix are placed into a single row.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order. \u2018F\u2019 means to\nflatten in column-major (Fortran-style) order. \u2018A\u2019 means to\nflatten in column-major order if m is Fortran contiguous in\nmemory, row-major order otherwise. \u2018K\u2019 means to flatten m in\nthe order the elements occur in memory. The default is \u2018C\u2019.\n\n\n\nReturns\n\nymatrixA copy of the matrix, flattened to a (1, N) matrix where N\nis the number of elements in the original matrix.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the matrix.\n\n\n\nExamples\n&gt;&gt;&gt; m = np.matrix([[1,2], [3,4]])\n&gt;&gt;&gt; m.flatten()\nmatrix([[1, 2, 3, 4]])\n&gt;&gt;&gt; m.flatten('F')\nmatrix([[1, 3, 2, 4]])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "ymatrix"], "returns": "ymatrixA copy of the matrix, flattened to a (1, N) matrix where Nis the number of elements in the original matrix.", "examples": ["; m = np.matrix([[1,2], [3,4]])\n; m.flatten()\nmatrix([[1, 2, 3, 4]])\n; m.flatten('F')\nmatrix([[1, 3, 2, 4]])\n\n", "; m = np.matrix([[1,2], [3,4]])\n; m.flatten()\nmatrix([[1, 2, 3, 4]])\n; m.flatten('F')\nmatrix([[1, 3, 2, 4]])\n"]},
{"library": "numpy", "item_id": "id2", "code": "1", "description": "However, array scalars are immutable, so none of the array\nscalar attributes are settable.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.flatten", "code": "\nMaskType.flatten()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.flatten", "code": "\nMaskedArray.flatten(order='C')[source]\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.flatten", "code": "\nmasked_array.flatten(order='C')[source]\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.generic.flatten", "code": "\ngeneric.flatten()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.flatten", "code": "\nchararray.flatten(order='C')\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.flatten", "code": "\nchararray.flatten(order='C')\u00b6", "description": "Return a copy of the array collapsed into one dimension.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional\u2018C\u2019 means to flatten in row-major (C-style) order.\n\u2018F\u2019 means to flatten in column-major (Fortran-\nstyle) order. \u2018A\u2019 means to flatten in column-major\norder if a is Fortran contiguous in memory,\nrow-major order otherwise. \u2018K\u2019 means to flatten\na in the order the elements occur in memory.\nThe default is \u2018C\u2019.\n\n\n\nReturns\n\nyndarrayA copy of the input array, flattened to one dimension.\n\n\n\n\n\nSee also\n\nravelReturn a flattened array.\n\nflatA 1-D flat iterator over the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([[1,2], [3,4]])\n&gt;&gt;&gt; a.flatten()\narray([1, 2, 3, 4])\n&gt;&gt;&gt; a.flatten('F')\narray([1, 3, 2, 4])\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "yndarray"], "returns": "yndarrayA copy of the input array, flattened to one dimension.", "examples": ["; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n\n", "; a = np.array([[1,2], [3,4]])\n; a.flatten()\narray([1, 2, 3, 4])\n; a.flatten('F')\narray([1, 3, 2, 4])\n"]},
{"library": "numpy", "item_id": "numpy.ma.flatnotmasked_edges", "code": "\nnumpy.ma.flatnotmasked_edges(a)[source]\u00b6", "description": "Find the indices of the first and last unmasked values.\nExpects a 1-D MaskedArray, returns None if all values are masked.\n\nParameters\n\naarray_likeInput 1-D MaskedArray\n\n\n\nReturns\n\nedgesndarray or NoneThe indices of first and last non-masked value in the array.\nReturns None if all values are masked.\n\n\n\n\n\nSee also\nflatnotmasked_contiguous, notmasked_contiguous, notmasked_edges, clump_masked, clump_unmasked\n\nNotes\nOnly accepts 1-D arrays.\nExamples\n&gt;&gt;&gt; a = np.ma.arange(10)\n&gt;&gt;&gt; np.ma.flatnotmasked_edges(a)\narray([0, 9])\n\n\n&gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n&gt;&gt;&gt; a[mask] = np.ma.masked\n&gt;&gt;&gt; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n\n&gt;&gt;&gt; np.ma.flatnotmasked_edges(a)\narray([3, 8])\n\n\n&gt;&gt;&gt; a[:] = np.ma.masked\n&gt;&gt;&gt; print(np.ma.flatnotmasked_edges(a))\nNone\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "edgesndarray or None"], "returns": "edgesndarray or NoneThe indices of first and last non-masked value in the array.Returns None if all values are masked.", "examples": ["; a = np.ma.arange(10)\n; np.ma.flatnotmasked_edges(a)\narray([0, 9])\n\n", "; a = np.ma.arange(10)\n; np.ma.flatnotmasked_edges(a)\narray([0, 9])\n", "; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n; a[mask] = np.ma.masked\n; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n", "; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n; a[mask] = np.ma.masked\n; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n", "; np.ma.flatnotmasked_edges(a)\narray([3, 8])\n\n", "; np.ma.flatnotmasked_edges(a)\narray([3, 8])\n", "; a[:] = np.ma.masked\n; print(np.ma.flatnotmasked_edges(a))\nNone\n\n", "; a[:] = np.ma.masked\n; print(np.ma.flatnotmasked_edges(a))\nNone\n"]},
{"library": "numpy", "item_id": "numpy.ma.flatnotmasked_contiguous", "code": "\nnumpy.ma.flatnotmasked_contiguous(a)[source]\u00b6", "description": "Find contiguous unmasked data in a masked array along the given axis.\n\nParameters\n\nanarrayThe input array.\n\n\n\nReturns\n\nslice_listlistA sorted sequence of slice objects (start index, end index).\n\n..versionchanged:: 1.15.0Now returns an empty list instead of None for a fully masked array\n\n\n\n\n\n\n\nSee also\nflatnotmasked_edges, notmasked_contiguous, notmasked_edges, clump_masked, clump_unmasked\n\nNotes\nOnly accepts 2-D arrays at most.\nExamples\n&gt;&gt;&gt; a = np.ma.arange(10)\n&gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n\n\n&gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n&gt;&gt;&gt; a[mask] = np.ma.masked\n&gt;&gt;&gt; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n\n&gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n&gt;&gt;&gt; a[:] = np.ma.masked\n&gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)\n[]\n\n\n", "parameters": ["Parameters", "anarray", "Returns", "slice_listlist", "..versionchanged:: 1.15.0"], "returns": "slice_listlistA sorted sequence of slice objects (start index, end index)...versionchanged:: 1.15.0Now returns an empty list instead of None for a fully masked array", "examples": ["; a = np.ma.arange(10)\n; np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n\n", "; a = np.ma.arange(10)\n; np.ma.flatnotmasked_contiguous(a)\n[slice(0, 10, None)]\n", "; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n; a[mask] = np.ma.masked\n; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n\n", "; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)\n; a[mask] = np.ma.masked\n; np.array(a[~a.mask])\narray([3, 4, 6, 7, 8])\n", "; np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n; a[:] = np.ma.masked\n; np.ma.flatnotmasked_contiguous(a)\n[]\n\n", "; np.ma.flatnotmasked_contiguous(a)\n[slice(3, 5, None), slice(6, 9, None)]\n; a[:] = np.ma.masked\n; np.ma.flatnotmasked_contiguous(a)\n[]\n"]},
{"library": "numpy", "item_id": "numpy.flatnonzero", "code": "\nnumpy.flatnonzero(a)[source]\u00b6", "description": "Return indices that are non-zero in the flattened version of a.\nThis is equivalent to np.nonzero(np.ravel(a))[0].\n\nParameters\n\naarray_likeInput data.\n\n\n\nReturns\n\nresndarrayOutput array, containing the indices of the elements of a.ravel()\nthat are non-zero.\n\n\n\n\n\nSee also\n\nnonzeroReturn the indices of the non-zero elements of the input array.\n\nravelReturn a 1-D array containing the elements of the input array.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(-2, 3)\n&gt;&gt;&gt; x\narray([-2, -1,  0,  1,  2])\n&gt;&gt;&gt; np.flatnonzero(x)\narray([0, 1, 3, 4])\n\n\nUse the indices of the non-zero elements as an index array to extract\nthese elements:\n&gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]\narray([-2, -1,  1,  2])\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "resndarray"], "returns": "resndarrayOutput array, containing the indices of the elements of a.ravel()that are non-zero.", "examples": ["; x = np.arange(-2, 3)\n; x\narray([-2, -1,  0,  1,  2])\n; np.flatnonzero(x)\narray([0, 1, 3, 4])\n\n", "; x = np.arange(-2, 3)\n; x\narray([-2, -1,  0,  1,  2])\n; np.flatnonzero(x)\narray([0, 1, 3, 4])\n", "; x.ravel()[np.flatnonzero(x)]\narray([-2, -1,  1,  2])\n\n", "; x.ravel()[np.flatnonzero(x)]\narray([-2, -1,  1,  2])\n"]},
{"library": "numpy", "item_id": "numpy.flatiter", "code": "\nclass numpy.flatiter[source]\u00b6", "description": "Flat iterator object to iterate over arrays.\nA flatiter iterator is returned by x.flat for any array x.\nIt allows iterating over the array as if it were a 1-D array,\neither in a for-loop or by calling its next method.\nIteration is done in row-major, C-style order (the last\nindex varying the fastest). The iterator can also be indexed using\nbasic slicing or advanced indexing.\n\nSee also\n\nndarray.flatReturn a flat iterator over an array.\n\nndarray.flattenReturns a flattened copy of an array.\n\n\n\nNotes\nA flatiter iterator can not be constructed directly from Python code\nby calling the flatiter constructor.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; fl = x.flat\n&gt;&gt;&gt; type(fl)\n&lt;class 'numpy.flatiter'&gt;\n&gt;&gt;&gt; for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5\n\n\n&gt;&gt;&gt; fl[2:4]\narray([2, 3])\n\n\n\nAttributes\n\nbaseA reference to the array that is iterated over.\n\ncoordsAn N-dimensional tuple of current coordinates.\n\nindexCurrent flat index into the array.\n\n\n\n\nMethods\n\n\n\n\n\n\ncopy()\nGet a copy of the iterator as a 1-D array.\n\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; type(fl)\n&lt;class 'numpy.flatiter'&gt;\n; for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5\n\n", "; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; type(fl)\n&lt;class 'numpy.flatiter'&gt;\n; for item in fl:\n...     print(item)\n...\n0\n1\n2\n3\n4\n5\n", "; fl[2:4]\narray([2, 3])\n\n", "; fl[2:4]\narray([2, 3])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.flat", "code": "\nproperty MaskedArray.flat\u00b6", "description": "Return a flat iterator, or set a flattened version of self to value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.flat", "code": "\nrecarray.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.lib.Arrayterator.flat", "code": "\nproperty Arrayterator.flat\u00b6", "description": "A 1-D flat iterator for Arrayterator objects.\nThis iterator returns elements of the array to be iterated over in\nArrayterator one by one. It is similar to flatiter.\n\nSee also\nArrayterator, flatiter\n\nExamples\n&gt;&gt;&gt; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n&gt;&gt;&gt; a_itor = np.lib.Arrayterator(a, 2)\n\n\n&gt;&gt;&gt; for subarr in a_itor.flat:\n...     if not subarr:\n...         print(subarr, type(subarr))\n...\n0 &lt;class 'numpy.int64'&gt;\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n; a_itor = np.lib.Arrayterator(a, 2)\n\n", "; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n; a_itor = np.lib.Arrayterator(a, 2)\n", "; for subarr in a_itor.flat:\n...     if not subarr:\n...         print(subarr, type(subarr))\n...\n0 &lt;class 'numpy.int64'&gt;\n\n", "; for subarr in a_itor.flat:\n...     if not subarr:\n...         print(subarr, type(subarr))\n...\n0 &lt;class 'numpy.int64'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.flat", "code": "\nproperty masked_array.flat\u00b6", "description": "Return a flat iterator, or set a flattened version of self to value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.flat", "code": "\nrecord.flat\u00b6", "description": "a 1-d view of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.flat", "code": "\nndarray.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.flat", "code": "\nmemmap.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.flat", "code": "\nmatrix.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.flat", "code": "\nchararray.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.flat", "code": "\nMaskType.flat\u00b6", "description": "a 1-d view of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.flat", "code": "\ngeneric.flat\u00b6", "description": "a 1-d view of scalar\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.flat", "code": "\nchararray.flat\u00b6", "description": "A 1-D iterator over the array.\nThis is a numpy.flatiter instance, which acts similarly to, but is not\na subclass of, Python\u2019s built-in iterator object.\n\nSee also\n\nflattenReturn a copy of the array collapsed into one dimension.\n\n\nflatiter\n\nExamples\n&gt;&gt;&gt; x = np.arange(1, 7).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; x.flat[3]\n4\n&gt;&gt;&gt; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; x.T.flat[3]\n5\n&gt;&gt;&gt; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n\nAn assignment example:\n&gt;&gt;&gt; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n&gt;&gt;&gt; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n\n", "; x = np.arange(1, 7).reshape(2, 3)\n; x\narray([[1, 2, 3],\n       [4, 5, 6]])\n; x.flat[3]\n4\n; x.T\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; x.T.flat[3]\n5\n; type(x.flat)\n&lt;class 'numpy.flatiter'&gt;\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n\n", "; x.flat = 3; x\narray([[3, 3, 3],\n       [3, 3, 3]])\n; x.flat[[1,4]] = 1; x\narray([[3, 1, 3],\n       [3, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.record.flags", "code": "\nrecord.flags\u00b6", "description": "integer value of flags\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.flags", "code": "\nrecarray.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.flags", "code": "\nndarray.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.flags", "code": "\nmemmap.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.flags", "code": "\nmatrix.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.flags", "code": "\nMaskType.flags\u00b6", "description": "integer value of flags\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.flags", "code": "\nMaskedArray.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.flags", "code": "\ngeneric.flags\u00b6", "description": "integer value of flags\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.flags", "code": "\nmasked_array.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.flags", "code": "\ndtype.flags\u00b6", "description": "Bit-flags describing how this data type is to be interpreted.\nBit-masks are in numpy.core.multiarray as the constants\nITEM_HASOBJECT, LIST_PICKLE, ITEM_IS_POINTER, NEEDS_INIT,\nNEEDS_PYAPI, USE_GETITEM, USE_SETITEM. A full explanation\nof these flags is in C-API documentation; they are largely useful\nfor user-defined data-types.\nThe following example demonstrates that operations on this particular\ndtype requires Python C-API.\nExamples\n&gt;&gt;&gt; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n&gt;&gt;&gt; x.flags\n16\n&gt;&gt;&gt; np.core.multiarray.NEEDS_PYAPI\n16\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n; x.flags\n16\n; np.core.multiarray.NEEDS_PYAPI\n16\n\n", "; x = np.dtype([('a', np.int32, 8), ('b', np.float64, 6)])\n; x.flags\n16\n; np.core.multiarray.NEEDS_PYAPI\n16\n"]},
{"library": "numpy", "item_id": "numpy.chararray.flags", "code": "\nchararray.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.flags", "code": "\nchararray.flags\u00b6", "description": "Information about the memory layout of the array.\nNotes\nThe flags object can be accessed dictionary-like (as in a.flags['WRITEABLE']),\nor by using lowercased attribute names (as in a.flags.writeable). Short flag\nnames are only supported in dictionary access.\nOnly the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be\nchanged by the user, via direct assignment to the attribute or dictionary\nentry, or by calling ndarray.setflags.\nThe array flags cannot be set arbitrarily:\n\nUPDATEIFCOPY can only be set False.\nWRITEBACKIFCOPY can only be set False.\nALIGNED can only be set True if the data is truly aligned.\nWRITEABLE can only be set True if the array owns its own memory\nor the ultimate owner of the memory exposes a writeable buffer\ninterface or is a string.\n\nArrays can be both C-style and Fortran-style contiguous simultaneously.\nThis is clear for 1-dimensional arrays, but can also be true for higher\ndimensional arrays.\nEven for contiguous arrays a stride for a given dimension\narr.strides[dim] may be arbitrary if arr.shape[dim] == 1\nor the array has no elements.\nIt does not generally hold that self.strides[-1] == self.itemsize\nfor C-style contiguous arrays or self.strides[0] == self.itemsize for\nFortran-style contiguous arrays is true.\n\nAttributes\n\nC_CONTIGUOUS (C)The data is in a single, C-style contiguous segment.\n\nF_CONTIGUOUS (F)The data is in a single, Fortran-style contiguous segment.\n\nOWNDATA (O)The array owns the memory it uses or borrows it from another object.\n\nWRITEABLE (W)The data area can be written to.  Setting this to False locks\nthe data, making it read-only.  A view (slice, etc.) inherits WRITEABLE\nfrom its base array at creation time, but a view of a writeable\narray may be subsequently locked while the base array remains writeable.\n(The opposite is not true, in that a view of a locked array may not\nbe made writeable.  However, currently, locking a base object does not\nlock any views that already reference it, so under that circumstance it\nis possible to alter the contents of a locked array via a previously\ncreated writeable view onto it.)  Attempting to change a non-writeable\narray raises a RuntimeError exception.\n\nALIGNED (A)The data and all elements are aligned appropriately for the hardware.\n\nWRITEBACKIFCOPY (X)This array is a copy of some other array. The C-API function\nPyArray_ResolveWritebackIfCopy must be called before deallocating\nto the base array will be updated with the contents of this array.\n\nUPDATEIFCOPY (U)(Deprecated, use WRITEBACKIFCOPY) This array is a copy of some other array.\nWhen this array is\ndeallocated, the base array will be updated with the contents of\nthis array.\n\nFNCF_CONTIGUOUS and not C_CONTIGUOUS.\n\nFORCF_CONTIGUOUS or C_CONTIGUOUS (one-segment test).\n\nBEHAVED (B)ALIGNED and WRITEABLE.\n\nCARRAY (CA)BEHAVED and C_CONTIGUOUS.\n\nFARRAY (FA)BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fix", "code": "\nnumpy.fix(x, out=None)[source]\u00b6", "description": "Round to nearest integer towards zero.\nRound an array of floats element-wise to nearest integer towards zero.\nThe rounded values are returned as floats.\n\nParameters\n\nxarray_likeAn array of floats to be rounded\n\nyndarray, optionalOutput array\n\n\n\nReturns\n\noutndarray of floatsThe array of rounded numbers\n\n\n\n\n\nSee also\ntrunc, floor, ceil\n\naroundRound to given number of decimals\n\n\n\nExamples\n&gt;&gt;&gt; np.fix(3.14)\n3.0\n&gt;&gt;&gt; np.fix(3)\n3.0\n&gt;&gt;&gt; np.fix([2.1, 2.9, -2.1, -2.9])\narray([ 2.,  2., -2., -2.])\n\n\n", "parameters": ["Parameters", "xarray_like", "yndarray, optional", "Returns", "outndarray of floats"], "returns": "outndarray of floatsThe array of rounded numbers", "examples": ["; np.fix(3.14)\n3.0\n; np.fix(3)\n3.0\n; np.fix([2.1, 2.9, -2.1, -2.9])\narray([ 2.,  2., -2., -2.])\n\n", "; np.fix(3.14)\n3.0\n; np.fix(3)\n3.0\n; np.fix([2.1, 2.9, -2.1, -2.9])\narray([ 2.,  2., -2., -2.])\n"]},
{"library": "numpy", "item_id": "numpy.ma.fix_invalid", "code": "\nnumpy.ma.fix_invalid(a, mask=False, copy=True, fill_value=None)[source]\u00b6", "description": "Return input with invalid data masked and replaced by a fill value.\nInvalid data means values of nan, inf, etc.\n\nParameters\n\naarray_likeInput array, a (subclass of) ndarray.\n\nmasksequence, optionalMask. Must be convertible to an array of booleans with the same\nshape as data. True indicates a masked (i.e. invalid) data.\n\ncopybool, optionalWhether to use a copy of a (True) or to fix a in place (False).\nDefault is True.\n\nfill_valuescalar, optionalValue used for fixing invalid data. Default is None, in which case\nthe a.fill_value is used.\n\n\n\nReturns\n\nbMaskedArrayThe input array with invalid entries fixed.\n\n\n\n\nNotes\nA copy is performed by default.\nExamples\n&gt;&gt;&gt; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n&gt;&gt;&gt; x\nmasked_array(data=[--, -1.0, nan, inf],\n             mask=[ True, False, False, False],\n       fill_value=1e+20)\n&gt;&gt;&gt; np.ma.fix_invalid(x)\nmasked_array(data=[--, -1.0, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=1e+20)\n\n\n&gt;&gt;&gt; fixed = np.ma.fix_invalid(x)\n&gt;&gt;&gt; fixed.data\narray([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])\n&gt;&gt;&gt; x.data\narray([ 1., -1., nan, inf])\n\n\n", "parameters": ["Parameters", "aarray_like", "masksequence, optional", "copybool, optional", "fill_valuescalar, optional", "Returns", "bMaskedArray"], "returns": "bMaskedArrayThe input array with invalid entries fixed.", "examples": ["; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n; x\nmasked_array(data=[--, -1.0, nan, inf],\n             mask=[ True, False, False, False],\n       fill_value=1e+20)\n; np.ma.fix_invalid(x)\nmasked_array(data=[--, -1.0, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=1e+20)\n\n", "; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)\n; x\nmasked_array(data=[--, -1.0, nan, inf],\n             mask=[ True, False, False, False],\n       fill_value=1e+20)\n; np.ma.fix_invalid(x)\nmasked_array(data=[--, -1.0, --, --],\n             mask=[ True, False,  True,  True],\n       fill_value=1e+20)\n", "; fixed = np.ma.fix_invalid(x)\n; fixed.data\narray([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])\n; x.data\narray([ 1., -1., nan, inf])\n\n", "; fixed = np.ma.fix_invalid(x)\n; fixed.data\narray([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])\n; x.data\narray([ 1., -1., nan, inf])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.fit", "code": "\nclassmethod Polynomial.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.fit", "code": "\nclassmethod Legendre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.fit", "code": "\nclassmethod Laguerre.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.fit", "code": "\nclassmethod HermiteE.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.fit", "code": "\nclassmethod Hermite.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.fit", "code": "\nclassmethod Chebyshev.fit(x, y, deg, domain=None, rcond=None, full=False, w=None, window=None)[source]\u00b6", "description": "Least squares fit to data.\nReturn a series instance that is the least squares fit to the data\ny sampled at x. The domain of the returned instance can be\nspecified and this will often result in a superior fit with less\nchance of ill conditioning.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\ndomain{None, [beg, end], []}, optionalDomain to use for the returned series. If None,\nthen a minimal domain that covers the points x is chosen.  If\n[] the class domain is used. The default value was the\nclass domain in NumPy 1.4 and None in later versions.\nThe [] option was added in numpy 1.5.0.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller\nthan this relative to the largest singular value will be\nignored. The default value is len(x)*eps, where eps is the\nrelative precision of the float type, about 2e-16 in most\ncases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False\n(the default) just the coefficients are returned, when True\ndiagnostic information from the singular value decomposition is\nalso returned.\n\nwarray_like, shape (M,), optionalWeights. If not None the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products\nw[i]*y[i] all have the same variance.  The default value is\nNone.\n\nNew in version 1.5.0.\n\n\nwindow{[beg, end]}, optionalWindow to use for the returned series. The default\nvalue is the default class domain\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\nnew_seriesseriesA series that represents the least squares fit to the data and\nhas the domain and window specified in the call. If the\ncoefficients for the unscaled and unshifted basis polynomials are\nof interest, do new_series.convert().coef.\n\n[resid, rank, sv, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "domain{None, [beg, end], []}, optional", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "window{[beg, end]}, optional", "Returns", "new_seriesseries", "[resid, rank, sv, rcond]list"], "returns": "new_seriesseriesA series that represents the least squares fit to the data andhas the domain and window specified in the call. If thecoefficients for the unscaled and unshifted basis polynomials areof interest, do new_series.convert().coef.[resid, rank, sv, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.finished", "code": "\nnditer.finished\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.finfo", "code": "\nclass numpy.finfo(dtype)[source]\u00b6", "description": "Machine limits for floating point types.\n\nParameters\n\ndtypefloat, dtype, or instanceKind of floating point data-type about which to get information.\n\n\n\n\n\nSee also\n\nMachArThe implementation of the tests that produce this information.\n\niinfoThe equivalent for integer data types.\n\n\n\nNotes\nFor developers of NumPy: do not instantiate this at the module level.\nThe initial calculation of these parameters is expensive and negatively\nimpacts import times.  These objects are cached, so calling finfo()\nrepeatedly inside your functions is not a problem.\n\nAttributes\n\nbitsintThe number of bits occupied by the type.\n\nepsfloatThe smallest representable positive number such that\n1.0 + eps != 1.0.  Type of eps is an appropriate floating\npoint type.\n\nepsnegfloating point number of the appropriate typeThe smallest representable positive number such that\n1.0 - epsneg != 1.0.\n\niexpintThe number of bits in the exponent portion of the floating point\nrepresentation.\n\nmacharMachArThe object which calculated these parameters and holds more\ndetailed information.\n\nmachepintThe exponent that yields eps.\n\nmaxfloating point number of the appropriate typeThe largest representable number.\n\nmaxexpintThe smallest positive power of the base (2) that causes overflow.\n\nminfloating point number of the appropriate typeThe smallest representable number, typically -max.\n\nminexpintThe most negative power of the base (2) consistent with there\nbeing no leading 0\u2019s in the mantissa.\n\nnegepintThe exponent that yields epsneg.\n\nnexpintThe number of bits in the exponent including its sign and bias.\n\nnmantintThe number of bits in the mantissa.\n\nprecisionintThe approximate number of decimal digits to which this kind of\nfloat is precise.\n\nresolutionfloating point number of the appropriate typeThe approximate decimal resolution of this type, i.e.,\n10**-precision.\n\ntinyfloatThe smallest positive usable number.  Type of tiny is an\nappropriate floating point type.\n\n\n\n\n", "parameters": ["Parameters", "dtypefloat, dtype, or instance", "Attributes", "bitsint", "epsfloat", "epsnegfloating point number of the appropriate type", "iexpint", "macharMachAr", "machepint", "maxfloating point number of the appropriate type", "maxexpint", "minfloating point number of the appropriate type", "minexpint", "negepint", "nexpint", "nmantint", "precisionint", "resolutionfloating point number of the appropriate type", "tinyfloat"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.find", "code": "\nchararray.find(self, sub, start=0, end=None)[source]\u00b6", "description": "For each element, return the lowest index in the string where\nsubstring sub is found.\n\nSee also\nchar.find\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.find_common_type", "code": "\nnumpy.find_common_type(array_types, scalar_types)[source]\u00b6", "description": "Determine common type following standard coercion rules.\n\nParameters\n\narray_typessequenceA list of dtypes or dtype convertible objects representing arrays.\n\nscalar_typessequenceA list of dtypes or dtype convertible objects representing scalars.\n\n\n\nReturns\n\ndatatypedtypeThe common data type, which is the maximum of array_types ignoring\nscalar_types, unless the maximum of scalar_types is of a\ndifferent kind (dtype.kind). If the kind is not understood, then\nNone is returned.\n\n\n\n\n\nSee also\ndtype, common_type, can_cast, mintypecode\n\nExamples\n&gt;&gt;&gt; np.find_common_type([], [np.int64, np.float32, complex])\ndtype('complex128')\n&gt;&gt;&gt; np.find_common_type([np.int64, np.float32], [])\ndtype('float64')\n\n\nThe standard casting rules ensure that a scalar cannot up-cast an\narray unless the scalar is of a fundamentally different kind of data\n(i.e. under a different hierarchy in the data type hierarchy) then\nthe array:\n&gt;&gt;&gt; np.find_common_type([np.float32], [np.int64, np.float64])\ndtype('float32')\n\n\nComplex is of a different type, so it up-casts the float in the\narray_types argument:\n&gt;&gt;&gt; np.find_common_type([np.float32], [complex])\ndtype('complex128')\n\n\nType specifier strings are convertible to dtypes and can therefore\nbe used instead of dtypes:\n&gt;&gt;&gt; np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\ndtype('complex128')\n\n\n", "parameters": ["Parameters", "array_typessequence", "scalar_typessequence", "Returns", "datatypedtype"], "returns": "datatypedtypeThe common data type, which is the maximum of array_types ignoringscalar_types, unless the maximum of scalar_types is of adifferent kind (dtype.kind). If the kind is not understood, thenNone is returned.", "examples": ["; np.find_common_type([], [np.int64, np.float32, complex])\ndtype('complex128')\n; np.find_common_type([np.int64, np.float32], [])\ndtype('float64')\n\n", "; np.find_common_type([], [np.int64, np.float32, complex])\ndtype('complex128')\n; np.find_common_type([np.int64, np.float32], [])\ndtype('float64')\n", "; np.find_common_type([np.float32], [np.int64, np.float64])\ndtype('float32')\n\n", "; np.find_common_type([np.float32], [np.int64, np.float64])\ndtype('float32')\n", "; np.find_common_type([np.float32], [complex])\ndtype('complex128')\n\n", "; np.find_common_type([np.float32], [complex])\ndtype('complex128')\n", "; np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\ndtype('complex128')\n\n", "; np.find_common_type(['f4', 'f4', 'i4'], ['c8'])\ndtype('complex128')\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.find", "code": "\nchararray.find(self, sub, start=0, end=None)\u00b6", "description": "For each element, return the lowest index in the string where\nsubstring sub is found.\n\nSee also\nchar.find\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.find", "code": "\nnumpy.char.find(a, sub, start=0, end=None)\u00b6", "description": "For each element, return the lowest index in the string where\nsubstring sub is found.\nCalls str.find element-wise.\nFor each element, return the lowest index in the string where\nsubstring sub is found, such that sub is contained in the\nrange [start, end].\n\nParameters\n\naarray_like of str or unicode\nsubstr or unicode\nstart, endint, optionalOptional arguments start and end are interpreted as in\nslice notation.\n\n\n\nReturns\n\noutndarray or intOutput array of ints.  Returns -1 if sub is not found.\n\n\n\n\n\nSee also\nstr.find\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "substr or unicode", "start, endint, optional", "Returns", "outndarray or int"], "returns": "outndarray or intOutput array of ints.  Returns -1 if sub is not found.", "examples": []},
{"library": "numpy", "item_id": "numpy.testing.suppress_warnings.filter", "code": "\nsuppress_warnings.filter(self, category=&lt;class 'Warning'&gt;, message='', module=None)[source]\u00b6", "description": "Add a new suppressing filter or apply it if the state is entered.\n\nParameters\n\ncategoryclass, optionalWarning class to filter\n\nmessagestring, optionalRegular expression matching the warning message.\n\nmodulemodule, optionalModule to filter for. Note that the module (and its file)\nmust match exactly and cannot be a submodule. This may make\nit unreliable for external modules.\n\n\n\n\nNotes\nWhen added within a context, filters are only added inside\nthe context and will be forgotten when the context is exited.\n", "parameters": ["Parameters", "categoryclass, optional", "messagestring, optional", "modulemodule, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.filled", "code": "\nMaskedArray.filled(self, fill_value=None)[source]\u00b6", "description": "Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.\n\nParameters\n\nfill_valuearray_like, optionalThe value to use for invalid entries. Can be scalar or non-scalar.\nIf non-scalar, the resulting ndarray must be broadcastable over\ninput array. Default is None, in which case, the fill_value\nattribute of the array is used instead.\n\n\n\nReturns\n\nfilled_arrayndarrayA copy of self with invalid entries replaced by fill_value\n(be it the function argument or the attribute of self), or\nself itself as an ndarray if there are no invalid entries to\nbe replaced.\n\n\n\n\nNotes\nThe result is not a MaskedArray!\nExamples\n&gt;&gt;&gt; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n&gt;&gt;&gt; x.filled()\narray([   1,    2, -999,    4, -999])\n&gt;&gt;&gt; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n&gt;&gt;&gt; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n\n\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, filled returns a recarray:\n&gt;&gt;&gt; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n&gt;&gt;&gt; m = np.ma.array(x, mask=[(True, False), (False, True)])\n&gt;&gt;&gt; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "fill_valuearray_like, optional", "Returns", "filled_arrayndarray"], "returns": "filled_arrayndarrayA copy of self with invalid entries replaced by fill_value(be it the function argument or the attribute of self), orself itself as an ndarray if there are no invalid entries tobe replaced.", "examples": ["; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n; x.filled()\narray([   1,    2, -999,    4, -999])\n; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n\n", "; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n; x.filled()\narray([   1,    2, -999,    4, -999])\n; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n", "; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n; m = np.ma.array(x, mask=[(True, False), (False, True)])\n; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n\n", "; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n; m = np.ma.array(x, mask=[(True, False), (False, True)])\n; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.filled", "code": "\nmasked_array.filled(self, fill_value=None)[source]\u00b6", "description": "Return a copy of self, with masked values filled with a given value.\nHowever, if there are no masked values to fill, self will be\nreturned instead as an ndarray.\n\nParameters\n\nfill_valuearray_like, optionalThe value to use for invalid entries. Can be scalar or non-scalar.\nIf non-scalar, the resulting ndarray must be broadcastable over\ninput array. Default is None, in which case, the fill_value\nattribute of the array is used instead.\n\n\n\nReturns\n\nfilled_arrayndarrayA copy of self with invalid entries replaced by fill_value\n(be it the function argument or the attribute of self), or\nself itself as an ndarray if there are no invalid entries to\nbe replaced.\n\n\n\n\nNotes\nThe result is not a MaskedArray!\nExamples\n&gt;&gt;&gt; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n&gt;&gt;&gt; x.filled()\narray([   1,    2, -999,    4, -999])\n&gt;&gt;&gt; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n&gt;&gt;&gt; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n\n\nSubclassing is preserved. This means that if, e.g., the data part of\nthe masked array is a recarray, filled returns a recarray:\n&gt;&gt;&gt; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n&gt;&gt;&gt; m = np.ma.array(x, mask=[(True, False), (False, True)])\n&gt;&gt;&gt; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n\n\n", "parameters": ["Parameters", "fill_valuearray_like, optional", "Returns", "filled_arrayndarray"], "returns": "filled_arrayndarrayA copy of self with invalid entries replaced by fill_value(be it the function argument or the attribute of self), orself itself as an ndarray if there are no invalid entries tobe replaced.", "examples": ["; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n; x.filled()\narray([   1,    2, -999,    4, -999])\n; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n\n", "; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)\n; x.filled()\narray([   1,    2, -999,    4, -999])\n; x.filled(fill_value=1000)\narray([   1,    2, 1000,    4, 1000])\n; type(x.filled())\n&lt;class 'numpy.ndarray'&gt;\n", "; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n; m = np.ma.array(x, mask=[(True, False), (False, True)])\n; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n\n", "; x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)\n; m = np.ma.array(x, mask=[(True, False), (False, True)])\n; m.filled()\nrec.array([(999999,      2), (    -3, 999999)],\n          dtype=[('f0', '&lt;i8'), ('f1', '&lt;i8')])\n"]},
{"library": "numpy", "item_id": "numpy.record.fill", "code": "\nrecord.fill()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.filled", "code": "\nnumpy.ma.filled(a, fill_value=None)[source]\u00b6", "description": "Return input as an array with masked data replaced by a fill value.\nIf a is not a MaskedArray, a itself is returned.\nIf a is a MaskedArray and fill_value is None, fill_value is set to\na.fill_value.\n\nParameters\n\naMaskedArray or array_likeAn input object.\n\nfill_valuearray_like, optional.Can be scalar or non-scalar. If non-scalar, the\nresulting filled array should be broadcastable\nover input array. Default is None.\n\n\n\nReturns\n\nandarrayThe filled array.\n\n\n\n\n\nSee also\ncompressed\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n&gt;&gt;&gt; x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])\n&gt;&gt;&gt; x.filled(fill_value=333)\narray([[333,   1,   2],\n       [333,   4,   5],\n       [  6,   7,   8]])\n&gt;&gt;&gt; x.filled(fill_value=np.arange(3))\narray([[0, 1, 2],\n       [0, 4, 5],\n       [6, 7, 8]])\n\n\n", "parameters": ["Parameters", "aMaskedArray or array_like", "fill_valuearray_like, optional.", "Returns", "andarray"], "returns": "andarrayThe filled array.", "examples": ["; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n; x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])\n; x.filled(fill_value=333)\narray([[333,   1,   2],\n       [333,   4,   5],\n       [  6,   7,   8]])\n; x.filled(fill_value=np.arange(3))\narray([[0, 1, 2],\n       [0, 4, 5],\n       [6, 7, 8]])\n\n", "; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n; x.filled()\narray([[999999,      1,      2],\n       [999999,      4,      5],\n       [     6,      7,      8]])\n; x.filled(fill_value=333)\narray([[333,   1,   2],\n       [333,   4,   5],\n       [  6,   7,   8]])\n; x.filled(fill_value=np.arange(3))\narray([[0, 1, 2],\n       [0, 4, 5],\n       [6, 7, 8]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.fill_value", "code": "\nproperty masked_array.fill_value\u00b6", "description": "The filling value of the masked array is a scalar. When setting, None\nwill set to a default based on the data type.\nExamples\n&gt;&gt;&gt; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n\n&gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)\n&gt;&gt;&gt; x.fill_value\n-inf\n&gt;&gt;&gt; x.fill_value = np.pi\n&gt;&gt;&gt; x.fill_value\n3.1415926535897931 # may vary\n\n\nReset to default:\n&gt;&gt;&gt; x.fill_value = None\n&gt;&gt;&gt; x.fill_value\n1e+20\n\n\n", "parameters": [], "returns": [], "examples": ["; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n", "; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n"]},
{"library": "numpy", "item_id": "numpy.fill_diagonal", "code": "\nnumpy.fill_diagonal(a, val, wrap=False)[source]\u00b6", "description": "Fill the main diagonal of the given array of any dimensionality.\nFor an array a with a.ndim &gt;= 2, the diagonal is the list of\nlocations with indices a[i, ..., i] all identical. This function\nmodifies the input array in-place, it does not return a value.\n\nParameters\n\naarray, at least 2-D.Array whose diagonal is to be filled, it gets modified in-place.\n\nvalscalarValue to be written on the diagonal, its type must be compatible with\nthat of the array a.\n\nwrapboolFor tall matrices in NumPy version up to 1.6.2, the\ndiagonal \u201cwrapped\u201d after N columns. You can have this behavior\nwith this option. This affects only tall matrices.\n\n\n\n\n\nSee also\ndiag_indices, diag_indices_from\n\nNotes\n\nNew in version 1.4.0.\n\nThis functionality can be obtained via diag_indices, but internally\nthis version uses a much faster implementation that never constructs the\nindices and uses simple slicing.\nExamples\n&gt;&gt;&gt; a = np.zeros((3, 3), int)\n&gt;&gt;&gt; np.fill_diagonal(a, 5)\n&gt;&gt;&gt; a\narray([[5, 0, 0],\n       [0, 5, 0],\n       [0, 0, 5]])\n\n\nThe same function can operate on a 4-D array:\n&gt;&gt;&gt; a = np.zeros((3, 3, 3, 3), int)\n&gt;&gt;&gt; np.fill_diagonal(a, 4)\n\n\nWe only show a few blocks for clarity:\n&gt;&gt;&gt; a[0, 0]\narray([[4, 0, 0],\n       [0, 0, 0],\n       [0, 0, 0]])\n&gt;&gt;&gt; a[1, 1]\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 0]])\n&gt;&gt;&gt; a[2, 2]\narray([[0, 0, 0],\n       [0, 0, 0],\n       [0, 0, 4]])\n\n\nThe wrap option affects only tall matrices:\n&gt;&gt;&gt; # tall matrices no wrap\n&gt;&gt;&gt; a = np.zeros((5, 3), int)\n&gt;&gt;&gt; np.fill_diagonal(a, 4)\n&gt;&gt;&gt; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; # tall matrices wrap\n&gt;&gt;&gt; a = np.zeros((5, 3), int)\n&gt;&gt;&gt; np.fill_diagonal(a, 4, wrap=True)\n&gt;&gt;&gt; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [4, 0, 0]])\n\n\n&gt;&gt;&gt; # wide matrices\n&gt;&gt;&gt; a = np.zeros((3, 5), int)\n&gt;&gt;&gt; np.fill_diagonal(a, 4, wrap=True)\n&gt;&gt;&gt; a\narray([[4, 0, 0, 0, 0],\n       [0, 4, 0, 0, 0],\n       [0, 0, 4, 0, 0]])\n\n\nThe anti-diagonal can be filled by reversing the order of elements\nusing either numpy.flipud or numpy.fliplr.\n&gt;&gt;&gt; a = np.zeros((3, 3), int);\n&gt;&gt;&gt; np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip\n&gt;&gt;&gt; a\narray([[0, 0, 1],\n       [0, 2, 0],\n       [3, 0, 0]])\n&gt;&gt;&gt; np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip\n&gt;&gt;&gt; a\narray([[0, 0, 3],\n       [0, 2, 0],\n       [1, 0, 0]])\n\n\nNote that the order in which the diagonal is filled varies depending\non the flip function.\n", "parameters": ["Parameters", "aarray, at least 2-D.", "valscalar", "wrapbool"], "returns": [], "examples": ["; a = np.zeros((3, 3), int)\n; np.fill_diagonal(a, 5)\n; a\narray([[5, 0, 0],\n       [0, 5, 0],\n       [0, 0, 5]])\n\n", "; a = np.zeros((3, 3), int)\n; np.fill_diagonal(a, 5)\n; a\narray([[5, 0, 0],\n       [0, 5, 0],\n       [0, 0, 5]])\n", "; a = np.zeros((3, 3, 3, 3), int)\n; np.fill_diagonal(a, 4)\n\n", "; a = np.zeros((3, 3, 3, 3), int)\n; np.fill_diagonal(a, 4)\n", "; a[0, 0]\narray([[4, 0, 0],\n       [0, 0, 0],\n       [0, 0, 0]])\n; a[1, 1]\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 0]])\n; a[2, 2]\narray([[0, 0, 0],\n       [0, 0, 0],\n       [0, 0, 4]])\n\n", "; a[0, 0]\narray([[4, 0, 0],\n       [0, 0, 0],\n       [0, 0, 0]])\n; a[1, 1]\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 0]])\n; a[2, 2]\narray([[0, 0, 0],\n       [0, 0, 0],\n       [0, 0, 4]])\n", "; # tall matrices no wrap\n; a = np.zeros((5, 3), int)\n; np.fill_diagonal(a, 4)\n; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [0, 0, 0]])\n\n", "; # tall matrices no wrap\n; a = np.zeros((5, 3), int)\n; np.fill_diagonal(a, 4)\n; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [0, 0, 0]])\n", "; # tall matrices wrap\n; a = np.zeros((5, 3), int)\n; np.fill_diagonal(a, 4, wrap=True)\n; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [4, 0, 0]])\n\n", "; # tall matrices wrap\n; a = np.zeros((5, 3), int)\n; np.fill_diagonal(a, 4, wrap=True)\n; a\narray([[4, 0, 0],\n       [0, 4, 0],\n       [0, 0, 4],\n       [0, 0, 0],\n       [4, 0, 0]])\n", "; # wide matrices\n; a = np.zeros((3, 5), int)\n; np.fill_diagonal(a, 4, wrap=True)\n; a\narray([[4, 0, 0, 0, 0],\n       [0, 4, 0, 0, 0],\n       [0, 0, 4, 0, 0]])\n\n", "; # wide matrices\n; a = np.zeros((3, 5), int)\n; np.fill_diagonal(a, 4, wrap=True)\n; a\narray([[4, 0, 0, 0, 0],\n       [0, 4, 0, 0, 0],\n       [0, 0, 4, 0, 0]])\n", "; a = np.zeros((3, 3), int);\n; np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip\n; a\narray([[0, 0, 1],\n       [0, 2, 0],\n       [3, 0, 0]])\n; np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip\n; a\narray([[0, 0, 3],\n       [0, 2, 0],\n       [1, 0, 0]])\n\n", "; a = np.zeros((3, 3), int);\n; np.fill_diagonal(np.fliplr(a), [1,2,3])  # Horizontal flip\n; a\narray([[0, 0, 1],\n       [0, 2, 0],\n       [3, 0, 0]])\n; np.fill_diagonal(np.flipud(a), [1,2,3])  # Vertical flip\n; a\narray([[0, 0, 3],\n       [0, 2, 0],\n       [1, 0, 0]])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.fill", "code": "\nrecarray.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.fill", "code": "\nndarray.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.fill", "code": "\nMaskedArray.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.fill", "code": "\nmemmap.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.fill", "code": "\nmatrix.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.fill", "code": "\nMaskType.fill()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.fill", "code": "\nmasked_array.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.generic.fill", "code": "\ngeneric.fill()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.fields", "code": "\ndtype.fields\u00b6", "description": "Dictionary of named fields defined for this data type, or None.\nThe dictionary is indexed by keys that are the names of the fields.\nEach entry in the dictionary is a tuple fully describing the field:\n(dtype, offset[, title])\n\n\nOffset is limited to C int, which is signed and usually 32 bits.\nIf present, the optional title can be any object (if it is a string\nor unicode then it will also be a key in the fields dictionary,\notherwise it\u2019s meta-data). Notice also that the first two elements\nof the tuple can be passed directly as arguments to the ndarray.getfield\nand ndarray.setfield methods.\n\nSee also\nndarray.getfield, ndarray.setfield\n\nExamples\n&gt;&gt;&gt; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n&gt;&gt;&gt; print(dt.fields)\n{'grades': (dtype(('float64',(2,))), 16), 'name': (dtype('|S16'), 0)}\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; print(dt.fields)\n{'grades': (dtype(('float64',(2,))), 16), 'name': (dtype('|S16'), 0)}\n\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; print(dt.fields)\n{'grades': (dtype(('float64',(2,))), 16), 'name': (dtype('|S16'), 0)}\n"]},
{"library": "numpy", "item_id": "numpy.recarray.field", "code": "\nrecarray.field(self, attr, val=None)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.fft.fftshift", "code": "\nnumpy.fft.fftshift(x, axes=None)[source]\u00b6", "description": "Shift the zero-frequency component to the center of the spectrum.\nThis function swaps half-spaces for all axes listed (defaults to all).\nNote that y[0] is the Nyquist component only if len(x) is even.\n\nParameters\n\nxarray_likeInput array.\n\naxesint or shape tuple, optionalAxes over which to shift.  Default is None, which shifts all axes.\n\n\n\nReturns\n\nyndarrayThe shifted array.\n\n\n\n\n\nSee also\n\nifftshiftThe inverse of fftshift.\n\n\n\nExamples\n&gt;&gt;&gt; freqs = np.fft.fftfreq(10, 0.1)\n&gt;&gt;&gt; freqs\narray([ 0.,  1.,  2., ..., -3., -2., -1.])\n&gt;&gt;&gt; np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n\n\nShift the zero-frequency component only along the second axis:\n&gt;&gt;&gt; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n&gt;&gt;&gt; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n&gt;&gt;&gt; np.fft.fftshift(freqs, axes=(1,))\narray([[ 2.,  0.,  1.],\n       [-4.,  3.,  4.],\n       [-1., -3., -2.]])\n\n\n", "parameters": ["Parameters", "xarray_like", "axesint or shape tuple, optional", "Returns", "yndarray"], "returns": "yndarrayThe shifted array.", "examples": ["; freqs = np.fft.fftfreq(10, 0.1)\n; freqs\narray([ 0.,  1.,  2., ..., -3., -2., -1.])\n; np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n\n", "; freqs = np.fft.fftfreq(10, 0.1)\n; freqs\narray([ 0.,  1.,  2., ..., -3., -2., -1.])\n; np.fft.fftshift(freqs)\narray([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.])\n", "; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n; np.fft.fftshift(freqs, axes=(1,))\narray([[ 2.,  0.,  1.],\n       [-4.,  3.,  4.],\n       [-1., -3., -2.]])\n\n", "; freqs = np.fft.fftfreq(9, d=1./9).reshape(3, 3)\n; freqs\narray([[ 0.,  1.,  2.],\n       [ 3.,  4., -4.],\n       [-3., -2., -1.]])\n; np.fft.fftshift(freqs, axes=(1,))\narray([[ 2.,  0.,  1.],\n       [-4.,  3.,  4.],\n       [-1., -3., -2.]])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.fill", "code": "\nchararray.fill(value)\u00b6", "description": "Fill the array with a scalar value.\n\nParameters\n\nvaluescalarAll elements of a will be assigned this value.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; a.fill(0)\n&gt;&gt;&gt; a\narray([0, 0])\n&gt;&gt;&gt; a = np.empty(2)\n&gt;&gt;&gt; a.fill(1)\n&gt;&gt;&gt; a\narray([1.,  1.])\n\n\n", "parameters": ["Parameters", "valuescalar"], "returns": [], "examples": ["; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n\n", "; a = np.array([1, 2])\n; a.fill(0)\n; a\narray([0, 0])\n; a = np.empty(2)\n; a.fill(1)\n; a\narray([1.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.fft.fftfreq", "code": "\nnumpy.fft.fftfreq(n, d=1.0)[source]\u00b6", "description": "Return the Discrete Fourier Transform sample frequencies.\nThe returned float array f contains the frequency bin centers in cycles\nper unit of the sample spacing (with zero at the start).  For instance, if\nthe sample spacing is in seconds, then the frequency unit is cycles/second.\nGiven a window length n and a sample spacing d:\nf = [0, 1, ...,   n/2-1,     -n/2, ..., -1] / (d*n)   if n is even\nf = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] / (d*n)   if n is odd\n\n\n\nParameters\n\nnintWindow length.\n\ndscalar, optionalSample spacing (inverse of the sampling rate). Defaults to 1.\n\n\n\nReturns\n\nfndarrayArray of length n containing the sample frequencies.\n\n\n\n\nExamples\n&gt;&gt;&gt; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)\n&gt;&gt;&gt; fourier = np.fft.fft(signal)\n&gt;&gt;&gt; n = signal.size\n&gt;&gt;&gt; timestep = 0.1\n&gt;&gt;&gt; freq = np.fft.fftfreq(n, d=timestep)\n&gt;&gt;&gt; freq\narray([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])\n\n\n", "parameters": ["Parameters", "nint", "dscalar, optional", "Returns", "fndarray"], "returns": "fndarrayArray of length n containing the sample frequencies.", "examples": ["; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)\n; fourier = np.fft.fft(signal)\n; n = signal.size\n; timestep = 0.1\n; freq = np.fft.fftfreq(n, d=timestep)\n; freq\narray([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])\n\n", "; signal = np.array([-2, 8, 6, 4, 1, 0, 3, 5], dtype=float)\n; fourier = np.fft.fft(signal)\n; n = signal.size\n; timestep = 0.1\n; freq = np.fft.fftfreq(n, d=timestep)\n; freq\narray([ 0.  ,  1.25,  2.5 , ..., -3.75, -2.5 , -1.25])\n"]},
{"library": "numpy", "item_id": "numpy.fft.fftn", "code": "\nnumpy.fft.fftn(a, s=None, axes=None, norm=None)[source]\u00b6", "description": "Compute the N-dimensional discrete Fourier Transform.\nThis function computes the N-dimensional discrete Fourier Transform over\nany number of axes in an M-dimensional array by means of the Fast Fourier\nTransform (FFT).\n\nParameters\n\naarray_likeInput array, can be complex.\n\nssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0] refers to axis 0, s[1] to axis 1, etc.).\nThis corresponds to n for fft(x, n).\nAlong any axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nif s is not given, the shape of the input along the axes specified\nby axes is used.\n\naxessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last len(s)\naxes are used, or all axes if s is also not specified.\nRepeated indices in axes means that the transform over that axis is\nperformed multiple times.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or by a combination of s and a,\nas explained in the parameters section above.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nnumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.\n\nifftnThe inverse of fftn, the inverse n-dimensional FFT.\n\nfftThe one-dimensional FFT, with definitions and conventions used.\n\nrfftnThe n-dimensional FFT of real input.\n\nfft2The two-dimensional FFT.\n\nfftshiftShifts zero-frequency terms to centre of array\n\n\n\nNotes\nThe output, analogously to fft, contains the term for zero frequency in\nthe low-order corner of all axes, the positive frequency terms in the\nfirst half of all axes, the term for the Nyquist frequency in the middle\nof all axes and the negative frequency terms in the second half of all\naxes, in order of decreasingly negative frequency.\nSee numpy.fft for details, definitions and conventions used.\nExamples\n&gt;&gt;&gt; a = np.mgrid[:3, :3, :3][0]\n&gt;&gt;&gt; np.fft.fftn(a, axes=(1, 2))\narray([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 9.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[18.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]]])\n&gt;&gt;&gt; np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,\n...                      2 * np.pi * np.arange(200) / 34)\n&gt;&gt;&gt; S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)\n&gt;&gt;&gt; FS = np.fft.fftn(S)\n&gt;&gt;&gt; plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "ValueError", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or by a combination of s and a,as explained in the parameters section above.", "examples": ["; a = np.mgrid[:3, :3, :3][0]\n; np.fft.fftn(a, axes=(1, 2))\narray([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 9.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[18.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]]])\n; np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n\n", "; a = np.mgrid[:3, :3, :3][0]\n; np.fft.fftn(a, axes=(1, 2))\narray([[[ 0.+0.j,   0.+0.j,   0.+0.j], # may vary\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[ 9.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]],\n       [[18.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j],\n        [ 0.+0.j,   0.+0.j,   0.+0.j]]])\n; np.fft.fftn(a, (2, 2), axes=(0, 1))\narray([[[ 2.+0.j,  2.+0.j,  2.+0.j], # may vary\n        [ 0.+0.j,  0.+0.j,  0.+0.j]],\n       [[-2.+0.j, -2.+0.j, -2.+0.j],\n        [ 0.+0.j,  0.+0.j,  0.+0.j]]])\n", "; import matplotlib.pyplot as plt\n; [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,\n...                      2 * np.pi * np.arange(200) / 34)\n; S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)\n; FS = np.fft.fftn(S)\n; plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; [X, Y] = np.meshgrid(2 * np.pi * np.arange(200) / 12,\n...                      2 * np.pi * np.arange(200) / 34)\n; S = np.sin(X) + np.cos(Y) + np.random.uniform(0, 1, X.shape)\n; FS = np.fft.fftn(S)\n; plt.imshow(np.log(np.abs(np.fft.fftshift(FS))**2))\n&lt;matplotlib.image.AxesImage object at 0x...&gt;\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.fft.fft2", "code": "\nnumpy.fft.fft2(a, s=None, axes=(-2, -1), norm=None)[source]\u00b6", "description": "Compute the 2-dimensional discrete Fourier Transform\nThis function computes the n-dimensional discrete Fourier Transform\nover any axes in an M-dimensional array by means of the\nFast Fourier Transform (FFT).  By default, the transform is computed over\nthe last two axes of the input array, i.e., a 2-dimensional FFT.\n\nParameters\n\naarray_likeInput array, can be complex\n\nssequence of ints, optionalShape (length of each transformed axis) of the output\n(s[0] refers to axis 0, s[1] to axis 1, etc.).\nThis corresponds to n for fft(x, n).\nAlong each axis, if the given shape is smaller than that of the input,\nthe input is cropped.  If it is larger, the input is padded with zeros.\nif s is not given, the shape of the input along the axes specified\nby axes is used.\n\naxessequence of ints, optionalAxes over which to compute the FFT.  If not given, the last two\naxes are used.  A repeated index in axes means the transform over\nthat axis is performed multiple times.  A one-element sequence means\nthat a one-dimensional FFT is performed.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axes\nindicated by axes, or the last two axes if axes is not given.\n\n\n\nRaises\n\nValueErrorIf s and axes have different length, or axes not given and\nlen(s) != 2.\n\nIndexErrorIf an element of axes is larger than than the number of axes of a.\n\n\n\n\n\nSee also\n\nnumpy.fftOverall view of discrete Fourier transforms, with definitions and conventions used.\n\nifft2The inverse two-dimensional FFT.\n\nfftThe one-dimensional FFT.\n\nfftnThe n-dimensional FFT.\n\nfftshiftShifts zero-frequency terms to the center of the array. For two-dimensional input, swaps first and third quadrants, and second and fourth quadrants.\n\n\n\nNotes\nfft2 is just fftn with a different default for axes.\nThe output, analogously to fft, contains the term for zero frequency in\nthe low-order corner of the transformed axes, the positive frequency terms\nin the first half of these axes, the term for the Nyquist frequency in the\nmiddle of the axes and the negative frequency terms in the second half of\nthe axes, in order of decreasingly negative frequency.\nSee fftn for details and a plotting example, and numpy.fft for\ndefinitions and conventions used.\nExamples\n&gt;&gt;&gt; a = np.mgrid[:5, :5][0]\n&gt;&gt;&gt; np.fft.fft2(a)\narray([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ]])\n\n\n", "parameters": ["Parameters", "aarray_like", "ssequence of ints, optional", "axessequence of ints, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "ValueError", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axesindicated by axes, or the last two axes if axes is not given.", "examples": ["; a = np.mgrid[:5, :5][0]\n; np.fft.fft2(a)\narray([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ]])\n\n", "; a = np.mgrid[:5, :5][0]\n; np.fft.fft2(a)\narray([[ 50.  +0.j        ,   0.  +0.j        ,   0.  +0.j        , # may vary\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5+17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 +4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5 -4.0614962j ,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ],\n       [-12.5-17.20477401j,   0.  +0.j        ,   0.  +0.j        ,\n          0.  +0.j        ,   0.  +0.j        ]])\n"]},
{"library": "numpy", "item_id": "numpy.fft.fft", "code": "\nnumpy.fft.fft(a, n=None, axis=-1, norm=None)[source]\u00b6", "description": "Compute the one-dimensional discrete Fourier Transform.\nThis function computes the one-dimensional n-point discrete Fourier\nTransform (DFT) with the efficient Fast Fourier Transform (FFT)\nalgorithm [CT].\n\nParameters\n\naarray_likeInput array, can be complex.\n\nnint, optionalLength of the transformed axis of the output.\nIf n is smaller than the length of the input, the input is cropped.\nIf it is larger, the input is padded with zeros.  If n is not given,\nthe length of the input along the axis specified by axis is used.\n\naxisint, optionalAxis over which to compute the FFT.  If not given, the last axis is\nused.\n\nnorm{None, \u201cortho\u201d}, optional\nNew in version 1.10.0.\n\nNormalization mode (see numpy.fft). Default is None.\n\n\n\nReturns\n\noutcomplex ndarrayThe truncated or zero-padded input, transformed along the axis\nindicated by axis, or the last one if axis is not specified.\n\n\n\nRaises\n\nIndexErrorif axes is larger than the last axis of a.\n\n\n\n\n\nSee also\n\nnumpy.fftfor definition of the DFT and conventions used.\n\nifftThe inverse of fft.\n\nfft2The two-dimensional FFT.\n\nfftnThe n-dimensional FFT.\n\nrfftnThe n-dimensional FFT of real input.\n\nfftfreqFrequency bins for given FFT parameters.\n\n\n\nNotes\nFFT (Fast Fourier Transform) refers to a way the discrete Fourier\nTransform (DFT) can be calculated efficiently, by using symmetries in the\ncalculated terms.  The symmetry is highest when n is a power of 2, and\nthe transform is therefore most efficient for these sizes.\nThe DFT is defined, with the conventions used in this implementation, in\nthe documentation for the numpy.fft module.\nReferences\n\nCT\nCooley, James W., and John W. Tukey, 1965, \u201cAn algorithm for the\nmachine calculation of complex Fourier series,\u201d Math. Comput.\n19: 297-301.\n\n\nExamples\n&gt;&gt;&gt; np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,\n        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,\n       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,\n        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])\n\n\nIn this example, real input has an FFT which is Hermitian, i.e., symmetric\nin the real part and anti-symmetric in the imaginary part, as described in\nthe numpy.fft documentation:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; t = np.arange(256)\n&gt;&gt;&gt; sp = np.fft.fft(np.sin(t))\n&gt;&gt;&gt; freq = np.fft.fftfreq(t.shape[-1])\n&gt;&gt;&gt; plt.plot(freq, sp.real, freq, sp.imag)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "norm{None, \u201cortho\u201d}, optional", "Returns", "outcomplex ndarray", "Raises", "IndexError"], "returns": "outcomplex ndarrayThe truncated or zero-padded input, transformed along the axisindicated by axis, or the last one if axis is not specified.", "examples": ["; np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,\n        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,\n       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,\n        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])\n\n", "; np.fft.fft(np.exp(2j * np.pi * np.arange(8) / 8))\narray([-2.33486982e-16+1.14423775e-17j,  8.00000000e+00-1.25557246e-15j,\n        2.33486982e-16+2.33486982e-16j,  0.00000000e+00+1.22464680e-16j,\n       -1.14423775e-17+2.33486982e-16j,  0.00000000e+00+5.20784380e-16j,\n        1.14423775e-17+1.14423775e-17j,  0.00000000e+00+1.22464680e-16j])\n", "; import matplotlib.pyplot as plt\n; t = np.arange(256)\n; sp = np.fft.fft(np.sin(t))\n; freq = np.fft.fftfreq(t.shape[-1])\n; plt.plot(freq, sp.real, freq, sp.imag)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; t = np.arange(256)\n; sp = np.fft.fft(np.sin(t))\n; freq = np.fft.fftfreq(t.shape[-1])\n; plt.plot(freq, sp.real, freq, sp.imag)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;, &lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.f", "code": "\nGenerator.f(dfnum, dfden, size=None)\u00b6", "description": "Draw samples from an F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters must be greater than\nzero.\nThe random variate of the F distribution (also known as the\nFisher distribution) is a continuous probability distribution\nthat arises in ANOVA tests, and is the ratio of two chi-square\nvariates.\n\nParameters\n\ndfnumfloat or array_like of floatsDegrees of freedom in numerator, must be &gt; 0.\n\ndfdenfloat or array_like of floatDegrees of freedom in denominator, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum and dfden are both scalars.\nOtherwise, np.broadcast(dfnum, dfden).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Fisher distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.fprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe F statistic is used to compare in-group variances to between-group\nvariances. Calculating the distribution depends on the sampling, and\nso it is a function of the respective degrees of freedom in the\nproblem.  The variable dfnum is the number of samples minus one, the\nbetween-groups degrees of freedom, while dfden is the within-groups\ndegrees of freedom, the sum of the number of samples in each group\nminus the number of groups.\nReferences\n\n1\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n2\nWikipedia, \u201cF-distribution\u201d,\nhttps://en.wikipedia.org/wiki/F-distribution\n\n\nExamples\nAn example from Glantz[1], pp 47-40:\nTwo groups, children of diabetics (25 people) and children from people\nwithout diabetes (25 controls). Fasting blood glucose was measured,\ncase group had a mean value of 86.1, controls had a mean value of\n82.2. Standard deviations were 2.09 and 2.49 respectively. Are these\ndata consistent with the null hypothesis that the parents diabetic\nstatus does not affect their children\u2019s blood glucose levels?\nCalculating the F statistic from the data gives a value of 36.01.\nDraw samples from the distribution:\n&gt;&gt;&gt; dfnum = 1. # between group degrees of freedom\n&gt;&gt;&gt; dfden = 48. # within groups degrees of freedom\n&gt;&gt;&gt; s = np.random.default_rng().f(dfnum, dfden, 1000)\n\n\nThe lower bound for the top 1% of the samples is :\n&gt;&gt;&gt; np.sort(s)[-10]\n7.61988120985 # random\n\n\nSo there is about a 1% chance that the F statistic will exceed 7.62,\nthe measured value is 36, so the null hypothesis is rejected at the 1%\nlevel.\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of float", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Fisher distribution.", "examples": ["; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.default_rng().f(dfnum, dfden, 1000)\n\n", "; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.default_rng().f(dfnum, dfden, 1000)\n", "; np.sort(s)[-10]\n7.61988120985 # random\n\n", "; np.sort(s)[-10]\n7.61988120985 # random\n"]},
{"library": "numpy", "item_id": "numpy.random.f", "code": "\nnumpy.random.f(dfnum, dfden, size=None)\u00b6", "description": "Draw samples from an F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters must be greater than\nzero.\nThe random variate of the F distribution (also known as the\nFisher distribution) is a continuous probability distribution\nthat arises in ANOVA tests, and is the ratio of two chi-square\nvariates.\n\nNote\nNew code should use the f method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndfnumfloat or array_like of floatsDegrees of freedom in numerator, must be &gt; 0.\n\ndfdenfloat or array_like of floatDegrees of freedom in denominator, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum and dfden are both scalars.\nOtherwise, np.broadcast(dfnum, dfden).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Fisher distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.fprobability density function, distribution or cumulative density function, etc.\n\nGenerator.fwhich should be used for new code.\n\n\n\nNotes\nThe F statistic is used to compare in-group variances to between-group\nvariances. Calculating the distribution depends on the sampling, and\nso it is a function of the respective degrees of freedom in the\nproblem.  The variable dfnum is the number of samples minus one, the\nbetween-groups degrees of freedom, while dfden is the within-groups\ndegrees of freedom, the sum of the number of samples in each group\nminus the number of groups.\nReferences\n\n1\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n2\nWikipedia, \u201cF-distribution\u201d,\nhttps://en.wikipedia.org/wiki/F-distribution\n\n\nExamples\nAn example from Glantz[1], pp 47-40:\nTwo groups, children of diabetics (25 people) and children from people\nwithout diabetes (25 controls). Fasting blood glucose was measured,\ncase group had a mean value of 86.1, controls had a mean value of\n82.2. Standard deviations were 2.09 and 2.49 respectively. Are these\ndata consistent with the null hypothesis that the parents diabetic\nstatus does not affect their children\u2019s blood glucose levels?\nCalculating the F statistic from the data gives a value of 36.01.\nDraw samples from the distribution:\n&gt;&gt;&gt; dfnum = 1. # between group degrees of freedom\n&gt;&gt;&gt; dfden = 48. # within groups degrees of freedom\n&gt;&gt;&gt; s = np.random.f(dfnum, dfden, 1000)\n\n\nThe lower bound for the top 1% of the samples is :\n&gt;&gt;&gt; np.sort(s)[-10]\n7.61988120985 # random\n\n\nSo there is about a 1% chance that the F statistic will exceed 7.62,\nthe measured value is 36, so the null hypothesis is rejected at the 1%\nlevel.\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of float", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Fisher distribution.", "examples": ["; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.f(dfnum, dfden, 1000)\n\n", "; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.f(dfnum, dfden, 1000)\n", "; np.sort(s)[-10]\n7.61988120985 # random\n\n", "; np.sort(s)[-10]\n7.61988120985 # random\n"]},
{"library": "numpy", "item_id": "numpy.fabs", "code": "\nnumpy.fabs(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'fabs'&gt;\u00b6", "description": "Compute the absolute values element-wise.\nThis function returns the absolute values (positive magnitude) of the\ndata in x. Complex values are not handled, use absolute to find the\nabsolute values of complex data.\n\nParameters\n\nxarray_likeThe array of numbers for which the absolute values are required. If\nx is a scalar, the result y will also be a scalar.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe absolute values of x, the returned values are always floats.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nabsoluteAbsolute values including complex types.\n\n\n\nExamples\n&gt;&gt;&gt; np.fabs(-1)\n1.0\n&gt;&gt;&gt; np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe absolute values of x, the returned values are always floats.This is a scalar if x is a scalar.", "examples": ["; np.fabs(-1)\n1.0\n; np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])\n\n", "; np.fabs(-1)\n1.0\n; np.fabs([-1.2, 1.2])\narray([ 1.2,  1.2])\n"]},
{"library": "numpy", "item_id": "numpy.matlib.eye", "code": "\nnumpy.matlib.eye(n, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')[source]\u00b6", "description": "Return a matrix with ones on the diagonal and zeros elsewhere.\n\nParameters\n\nnintNumber of rows in the output.\n\nMint, optionalNumber of columns in the output, defaults to n.\n\nkint, optionalIndex of the diagonal: 0 refers to the main diagonal,\na positive value refers to an upper diagonal,\nand a negative value to a lower diagonal.\n\ndtypedtype, optionalData-type of the returned matrix.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether the output should be stored in row-major (C-style) or\ncolumn-major (Fortran-style) order in memory.\n\nNew in version 1.14.0.\n\n\n\n\nReturns\n\nImatrixA n x M matrix where all elements are equal to zero,\nexcept for the k-th diagonal, whose values are equal to one.\n\n\n\n\n\nSee also\n\nnumpy.eyeEquivalent array function.\n\nidentitySquare identity matrix.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.eye(3, k=1, dtype=float)\nmatrix([[0.,  1.,  0.],\n        [0.,  0.,  1.],\n        [0.,  0.,  0.]])\n\n\n", "parameters": ["Parameters", "nint", "Mint, optional", "kint, optional", "dtypedtype, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "Imatrix"], "returns": "ImatrixA n x M matrix where all elements are equal to zero,except for the k-th diagonal, whose values are equal to one.", "examples": ["; import numpy.matlib\n; np.matlib.eye(3, k=1, dtype=float)\nmatrix([[0.,  1.,  0.],\n        [0.,  0.,  1.],\n        [0.,  0.,  0.]])\n\n", "; import numpy.matlib\n; np.matlib.eye(3, k=1, dtype=float)\nmatrix([[0.,  1.,  0.],\n        [0.,  0.,  1.],\n        [0.,  0.,  0.]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.f", "code": "\nRandomState.f(dfnum, dfden, size=None)\u00b6", "description": "Draw samples from an F distribution.\nSamples are drawn from an F distribution with specified parameters,\ndfnum (degrees of freedom in numerator) and dfden (degrees of\nfreedom in denominator), where both parameters must be greater than\nzero.\nThe random variate of the F distribution (also known as the\nFisher distribution) is a continuous probability distribution\nthat arises in ANOVA tests, and is the ratio of two chi-square\nvariates.\n\nNote\nNew code should use the f method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndfnumfloat or array_like of floatsDegrees of freedom in numerator, must be &gt; 0.\n\ndfdenfloat or array_like of floatDegrees of freedom in denominator, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if dfnum and dfden are both scalars.\nOtherwise, np.broadcast(dfnum, dfden).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized Fisher distribution.\n\n\n\n\n\nSee also\n\nscipy.stats.fprobability density function, distribution or cumulative density function, etc.\n\nGenerator.fwhich should be used for new code.\n\n\n\nNotes\nThe F statistic is used to compare in-group variances to between-group\nvariances. Calculating the distribution depends on the sampling, and\nso it is a function of the respective degrees of freedom in the\nproblem.  The variable dfnum is the number of samples minus one, the\nbetween-groups degrees of freedom, while dfden is the within-groups\ndegrees of freedom, the sum of the number of samples in each group\nminus the number of groups.\nReferences\n\n1\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n2\nWikipedia, \u201cF-distribution\u201d,\nhttps://en.wikipedia.org/wiki/F-distribution\n\n\nExamples\nAn example from Glantz[1], pp 47-40:\nTwo groups, children of diabetics (25 people) and children from people\nwithout diabetes (25 controls). Fasting blood glucose was measured,\ncase group had a mean value of 86.1, controls had a mean value of\n82.2. Standard deviations were 2.09 and 2.49 respectively. Are these\ndata consistent with the null hypothesis that the parents diabetic\nstatus does not affect their children\u2019s blood glucose levels?\nCalculating the F statistic from the data gives a value of 36.01.\nDraw samples from the distribution:\n&gt;&gt;&gt; dfnum = 1. # between group degrees of freedom\n&gt;&gt;&gt; dfden = 48. # within groups degrees of freedom\n&gt;&gt;&gt; s = np.random.f(dfnum, dfden, 1000)\n\n\nThe lower bound for the top 1% of the samples is :\n&gt;&gt;&gt; np.sort(s)[-10]\n7.61988120985 # random\n\n\nSo there is about a 1% chance that the F statistic will exceed 7.62,\nthe measured value is 36, so the null hypothesis is rejected at the 1%\nlevel.\n", "parameters": ["Parameters", "dfnumfloat or array_like of floats", "dfdenfloat or array_like of float", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized Fisher distribution.", "examples": ["; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.f(dfnum, dfden, 1000)\n\n", "; dfnum = 1. # between group degrees of freedom\n; dfden = 48. # within groups degrees of freedom\n; s = np.random.f(dfnum, dfden, 1000)\n", "; np.sort(s)[-10]\n7.61988120985 # random\n\n", "; np.sort(s)[-10]\n7.61988120985 # random\n"]},
{"library": "numpy", "item_id": "numpy.eye", "code": "\nnumpy.eye(N, M=None, k=0, dtype=&lt;class 'float'&gt;, order='C')[source]\u00b6", "description": "Return a 2-D array with ones on the diagonal and zeros elsewhere.\n\nParameters\n\nNintNumber of rows in the output.\n\nMint, optionalNumber of columns in the output. If None, defaults to N.\n\nkint, optionalIndex of the diagonal: 0 (the default) refers to the main diagonal,\na positive value refers to an upper diagonal, and a negative value\nto a lower diagonal.\n\ndtypedata-type, optionalData-type of the returned array.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether the output should be stored in row-major (C-style) or\ncolumn-major (Fortran-style) order in memory.\n\nNew in version 1.14.0.\n\n\n\n\nReturns\n\nIndarray of shape (N,M)An array where all elements are equal to zero, except for the k-th\ndiagonal, whose values are equal to one.\n\n\n\n\n\nSee also\n\nidentity(almost) equivalent function\n\ndiagdiagonal 2-D array from a 1-D array specified by the user.\n\n\n\nExamples\n&gt;&gt;&gt; np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n&gt;&gt;&gt; np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])\n\n\n", "parameters": ["Parameters", "Nint", "Mint, optional", "kint, optional", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "Indarray of shape (N,M)"], "returns": "Indarray of shape (N,M)An array where all elements are equal to zero, except for the k-thdiagonal, whose values are equal to one.", "examples": ["; np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n; np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])\n\n", "; np.eye(2, dtype=int)\narray([[1, 0],\n       [0, 1]])\n; np.eye(3, k=1)\narray([[0.,  1.,  0.],\n       [0.,  0.,  1.],\n       [0.,  0.,  0.]])\n"]},
{"library": "numpy", "item_id": "numpy.extract", "code": "\nnumpy.extract(condition, arr)[source]\u00b6", "description": "Return the elements of an array that satisfy some condition.\nThis is equivalent to np.compress(ravel(condition), ravel(arr)).  If\ncondition is boolean np.extract is equivalent to arr[condition].\nNote that place does the exact opposite of extract.\n\nParameters\n\nconditionarray_likeAn array whose nonzero or True entries indicate the elements of arr\nto extract.\n\narrarray_likeInput array of the same size as condition.\n\n\n\nReturns\n\nextractndarrayRank 1 array of values from arr where condition is True.\n\n\n\n\n\nSee also\ntake, put, copyto, compress, place\n\nExamples\n&gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))\n&gt;&gt;&gt; arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n&gt;&gt;&gt; condition = np.mod(arr, 3)==0\n&gt;&gt;&gt; condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]])\n&gt;&gt;&gt; np.extract(condition, arr)\narray([0, 3, 6, 9])\n\n\nIf condition is boolean:\n&gt;&gt;&gt; arr[condition]\narray([0, 3, 6, 9])\n\n\n", "parameters": ["Parameters", "conditionarray_like", "arrarray_like", "Returns", "extractndarray"], "returns": "extractndarrayRank 1 array of values from arr where condition is True.", "examples": ["; arr = np.arange(12).reshape((3, 4))\n; arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n; condition = np.mod(arr, 3)==0\n; condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]])\n; np.extract(condition, arr)\narray([0, 3, 6, 9])\n\n", "; arr = np.arange(12).reshape((3, 4))\n; arr\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n; condition = np.mod(arr, 3)==0\n; condition\narray([[ True, False, False,  True],\n       [False, False,  True, False],\n       [False,  True, False, False]])\n; np.extract(condition, arr)\narray([0, 3, 6, 9])\n", "; arr[condition]\narray([0, 3, 6, 9])\n\n", "; arr[condition]\narray([0, 3, 6, 9])\n"]},
{"library": "numpy", "item_id": "c.PyModule_AddObject", "code": "\nint PyModule_AddObject(PyObject*\u00a0module, char*\u00a0name, PyObject*\u00a0value)\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.distutils.core.Extension", "code": "\nclass numpy.distutils.core.Extension(name, sources, include_dirs=None, define_macros=None, undef_macros=None, library_dirs=None, libraries=None, runtime_library_dirs=None, extra_objects=None, extra_compile_args=None, extra_link_args=None, export_symbols=None, swig_opts=None, depends=None, language=None, f2py_options=None, module_dirs=None, extra_f77_compile_args=None, extra_f90_compile_args=None)[source]\u00b6", "description": "\nParameters\n\nnamestrExtension name.\n\nsourceslist of strList of source file locations relative to the top directory of\nthe package.\n\nextra_compile_argslist of strExtra command line arguments to pass to the compiler.\n\nextra_f77_compile_argslist of strExtra command line arguments to pass to the fortran77 compiler.\n\nextra_f90_compile_argslist of strExtra command line arguments to pass to the fortran90 compiler.\n\n\n\n\nMethods\n\n\n\n\n\n\nhas_cxx_sources\n\n\nhas_f2py_sources\n\n\n\n\n", "parameters": ["Parameters", "namestr", "sourceslist of str", "extra_compile_argslist of str", "extra_f77_compile_argslist of str", "extra_f90_compile_argslist of str"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.exponential", "code": "\nRandomState.exponential(scale=1.0, size=None)\u00b6", "description": "Draw samples from an exponential distribution.\nIts probability density function is\n\n\nfor x &gt; 0 and 0 elsewhere.  is the scale parameter,\nwhich is the inverse of the rate parameter .\nThe rate parameter is an alternative, widely used parameterization\nof the exponential distribution [3].\nThe exponential distribution is a continuous analogue of the\ngeometric distribution.  It describes many common situations, such as\nthe size of raindrops measured over many rainstorms [1], or the time\nbetween page requests to Wikipedia [2].\n\nNote\nNew code should use the exponential method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nscalefloat or array_like of floatsThe scale parameter, . Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized exponential distribution.\n\n\n\n\n\nSee also\n\nGenerator.exponentialwhich should be used for new code.\n\n\n\nReferences\n\n1\nPeyton Z. Peebles Jr., \u201cProbability, Random Variables and\nRandom Signal Principles\u201d, 4th ed, 2001, p. 57.\n\n2\nWikipedia, \u201cPoisson process\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_process\n\n3\nWikipedia, \u201cExponential distribution\u201d,\nhttps://en.wikipedia.org/wiki/Exponential_distribution\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized exponential distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.exponential", "code": "\nGenerator.exponential(scale=1.0, size=None)\u00b6", "description": "Draw samples from an exponential distribution.\nIts probability density function is\n\n\nfor x &gt; 0 and 0 elsewhere.  is the scale parameter,\nwhich is the inverse of the rate parameter .\nThe rate parameter is an alternative, widely used parameterization\nof the exponential distribution [3].\nThe exponential distribution is a continuous analogue of the\ngeometric distribution.  It describes many common situations, such as\nthe size of raindrops measured over many rainstorms [1], or the time\nbetween page requests to Wikipedia [2].\n\nParameters\n\nscalefloat or array_like of floatsThe scale parameter, . Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized exponential distribution.\n\n\n\n\nReferences\n\n1\nPeyton Z. Peebles Jr., \u201cProbability, Random Variables and\nRandom Signal Principles\u201d, 4th ed, 2001, p. 57.\n\n2\nWikipedia, \u201cPoisson process\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_process\n\n3\nWikipedia, \u201cExponential distribution\u201d,\nhttps://en.wikipedia.org/wiki/Exponential_distribution\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized exponential distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.exponential", "code": "\nnumpy.random.exponential(scale=1.0, size=None)\u00b6", "description": "Draw samples from an exponential distribution.\nIts probability density function is\n\n\nfor x &gt; 0 and 0 elsewhere.  is the scale parameter,\nwhich is the inverse of the rate parameter .\nThe rate parameter is an alternative, widely used parameterization\nof the exponential distribution [3].\nThe exponential distribution is a continuous analogue of the\ngeometric distribution.  It describes many common situations, such as\nthe size of raindrops measured over many rainstorms [1], or the time\nbetween page requests to Wikipedia [2].\n\nNote\nNew code should use the exponential method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nscalefloat or array_like of floatsThe scale parameter, . Must be\nnon-negative.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if scale is a scalar.  Otherwise,\nnp.array(scale).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized exponential distribution.\n\n\n\n\n\nSee also\n\nGenerator.exponentialwhich should be used for new code.\n\n\n\nReferences\n\n1\nPeyton Z. Peebles Jr., \u201cProbability, Random Variables and\nRandom Signal Principles\u201d, 4th ed, 2001, p. 57.\n\n2\nWikipedia, \u201cPoisson process\u201d,\nhttps://en.wikipedia.org/wiki/Poisson_process\n\n3\nWikipedia, \u201cExponential distribution\u201d,\nhttps://en.wikipedia.org/wiki/Exponential_distribution\n\n\n", "parameters": ["Parameters", "scalefloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized exponential distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.expm1", "code": "\nnumpy.expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'expm1'&gt;\u00b6", "description": "Calculate exp(x) - 1 for all elements in the array.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarElement-wise exponential minus one: out = exp(x) - 1.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nlog1plog(1 + x), the inverse of expm1.\n\n\n\nNotes\nThis function provides greater precision than exp(x) - 1\nfor small values of x.\nExamples\nThe true value of exp(1e-10) - 1 is 1.00000000005e-10 to\nabout 32 significant digits. This example shows the superiority of\nexpm1 in this case.\n&gt;&gt;&gt; np.expm1(1e-10)\n1.00000000005e-10\n&gt;&gt;&gt; np.exp(1e-10) - 1\n1.000000082740371e-10\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarElement-wise exponential minus one: out = exp(x) - 1.This is a scalar if x is a scalar.", "examples": ["; np.expm1(1e-10)\n1.00000000005e-10\n; np.exp(1e-10) - 1\n1.000000082740371e-10\n\n", "; np.expm1(1e-10)\n1.00000000005e-10\n; np.exp(1e-10) - 1\n1.000000082740371e-10\n"]},
{"library": "numpy", "item_id": "numpy.chararray.expandtabs", "code": "\nchararray.expandtabs(self, tabsize=8)[source]\u00b6", "description": "Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.\n\nSee also\nchar.expandtabs\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.expandtabs", "code": "\nchararray.expandtabs(self, tabsize=8)\u00b6", "description": "Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.\n\nSee also\nchar.expandtabs\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.expandtabs", "code": "\nnumpy.char.expandtabs(a, tabsize=8)\u00b6", "description": "Return a copy of each string element where all tab characters are\nreplaced by one or more spaces.\nCalls str.expandtabs element-wise.\nReturn a copy of each string element where all tab characters are\nreplaced by one or more spaces, depending on the current column\nand the given tabsize. The column number is reset to zero after\neach newline occurring in the string. This doesn\u2019t understand other\nnon-printing characters or escape sequences.\n\nParameters\n\naarray_like of str or unicodeInput array\n\ntabsizeint, optionalReplace tabs with tabsize number of spaces.  If not given defaults\nto 8 spaces.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input type\n\n\n\n\n\nSee also\nstr.expandtabs\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "tabsizeint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on input type", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.expand_dims", "code": "\nnumpy.ma.expand_dims(a, axis)[source]\u00b6", "description": "Expand the shape of an array.\nInsert a new axis that will appear at the axis position in the expanded\narray shape.\n\nParameters\n\naarray_likeInput array.\n\naxisint or tuple of intsPosition in the expanded axes where the new axis (or axes) is placed.\n\nDeprecated since version 1.13.0: Passing an axis where axis &gt; a.ndim will be treated as\naxis == a.ndim, and passing axis &lt; -a.ndim - 1 will\nbe treated as axis == 0. This behavior is deprecated.\n\n\nChanged in version 1.18.0: A tuple of axes is now supported.  Out of range axes as\ndescribed above are now forbidden and raise an AxisError.\n\n\n\n\nReturns\n\nresultndarrayView of a with the number of dimensions increased.\n\n\n\n\n\nSee also\n\nsqueezeThe inverse operation, removing singleton dimensions\n\nreshapeInsert, remove, and combine dimensions, and resize existing ones\n\n\ndoc.indexing, atleast_1d, atleast_2d, atleast_3d\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2])\n&gt;&gt;&gt; x.shape\n(2,)\n\n\nThe following is equivalent to x[np.newaxis, :] or x[np.newaxis]:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=0)\n&gt;&gt;&gt; y\narray([[1, 2]])\n&gt;&gt;&gt; y.shape\n(1, 2)\n\n\nThe following is equivalent to x[:, np.newaxis]:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=1)\n&gt;&gt;&gt; y\narray([[1],\n       [2]])\n&gt;&gt;&gt; y.shape\n(2, 1)\n\n\naxis may also be a tuple:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=(0, 1))\n&gt;&gt;&gt; y\narray([[[1, 2]]])\n\n\n&gt;&gt;&gt; y = np.expand_dims(x, axis=(2, 0))\n&gt;&gt;&gt; y\narray([[[1],\n        [2]]])\n\n\nNote that some examples may use None instead of np.newaxis.  These\nare the same objects:\n&gt;&gt;&gt; np.newaxis is None\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint or tuple of ints", "Returns", "resultndarray"], "returns": "resultndarrayView of a with the number of dimensions increased.", "examples": ["; x = np.array([1, 2])\n; x.shape\n(2,)\n\n", "; x = np.array([1, 2])\n; x.shape\n(2,)\n", "; y = np.expand_dims(x, axis=0)\n; y\narray([[1, 2]])\n; y.shape\n(1, 2)\n\n", "; y = np.expand_dims(x, axis=0)\n; y\narray([[1, 2]])\n; y.shape\n(1, 2)\n", "; y = np.expand_dims(x, axis=1)\n; y\narray([[1],\n       [2]])\n; y.shape\n(2, 1)\n\n", "; y = np.expand_dims(x, axis=1)\n; y\narray([[1],\n       [2]])\n; y.shape\n(2, 1)\n", "; y = np.expand_dims(x, axis=(0, 1))\n; y\narray([[[1, 2]]])\n\n", "; y = np.expand_dims(x, axis=(0, 1))\n; y\narray([[[1, 2]]])\n", "; y = np.expand_dims(x, axis=(2, 0))\n; y\narray([[[1],\n        [2]]])\n\n", "; y = np.expand_dims(x, axis=(2, 0))\n; y\narray([[[1],\n        [2]]])\n", "; np.newaxis is None\nTrue\n\n", "; np.newaxis is None\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.expand_dims", "code": "\nnumpy.expand_dims(a, axis)[source]\u00b6", "description": "Expand the shape of an array.\nInsert a new axis that will appear at the axis position in the expanded\narray shape.\n\nParameters\n\naarray_likeInput array.\n\naxisint or tuple of intsPosition in the expanded axes where the new axis (or axes) is placed.\n\nDeprecated since version 1.13.0: Passing an axis where axis &gt; a.ndim will be treated as\naxis == a.ndim, and passing axis &lt; -a.ndim - 1 will\nbe treated as axis == 0. This behavior is deprecated.\n\n\nChanged in version 1.18.0: A tuple of axes is now supported.  Out of range axes as\ndescribed above are now forbidden and raise an AxisError.\n\n\n\n\nReturns\n\nresultndarrayView of a with the number of dimensions increased.\n\n\n\n\n\nSee also\n\nsqueezeThe inverse operation, removing singleton dimensions\n\nreshapeInsert, remove, and combine dimensions, and resize existing ones\n\n\ndoc.indexing, atleast_1d, atleast_2d, atleast_3d\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2])\n&gt;&gt;&gt; x.shape\n(2,)\n\n\nThe following is equivalent to x[np.newaxis, :] or x[np.newaxis]:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=0)\n&gt;&gt;&gt; y\narray([[1, 2]])\n&gt;&gt;&gt; y.shape\n(1, 2)\n\n\nThe following is equivalent to x[:, np.newaxis]:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=1)\n&gt;&gt;&gt; y\narray([[1],\n       [2]])\n&gt;&gt;&gt; y.shape\n(2, 1)\n\n\naxis may also be a tuple:\n&gt;&gt;&gt; y = np.expand_dims(x, axis=(0, 1))\n&gt;&gt;&gt; y\narray([[[1, 2]]])\n\n\n&gt;&gt;&gt; y = np.expand_dims(x, axis=(2, 0))\n&gt;&gt;&gt; y\narray([[[1],\n        [2]]])\n\n\nNote that some examples may use None instead of np.newaxis.  These\nare the same objects:\n&gt;&gt;&gt; np.newaxis is None\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint or tuple of ints", "Returns", "resultndarray"], "returns": "resultndarrayView of a with the number of dimensions increased.", "examples": ["; x = np.array([1, 2])\n; x.shape\n(2,)\n\n", "; x = np.array([1, 2])\n; x.shape\n(2,)\n", "; y = np.expand_dims(x, axis=0)\n; y\narray([[1, 2]])\n; y.shape\n(1, 2)\n\n", "; y = np.expand_dims(x, axis=0)\n; y\narray([[1, 2]])\n; y.shape\n(1, 2)\n", "; y = np.expand_dims(x, axis=1)\n; y\narray([[1],\n       [2]])\n; y.shape\n(2, 1)\n\n", "; y = np.expand_dims(x, axis=1)\n; y\narray([[1],\n       [2]])\n; y.shape\n(2, 1)\n", "; y = np.expand_dims(x, axis=(0, 1))\n; y\narray([[[1, 2]]])\n\n", "; y = np.expand_dims(x, axis=(0, 1))\n; y\narray([[[1, 2]]])\n", "; y = np.expand_dims(x, axis=(2, 0))\n; y\narray([[[1],\n        [2]]])\n\n", "; y = np.expand_dims(x, axis=(2, 0))\n; y\narray([[[1],\n        [2]]])\n", "; np.newaxis is None\nTrue\n\n", "; np.newaxis is None\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.exp2", "code": "\nnumpy.exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'exp2'&gt;\u00b6", "description": "Calculate 2**p for all p in the input array.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarElement-wise 2 to the power x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\npower\n\nNotes\n\nNew in version 1.3.0.\n\nExamples\n&gt;&gt;&gt; np.exp2([2, 3])\narray([ 4.,  8.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarElement-wise 2 to the power x.This is a scalar if x is a scalar.", "examples": ["; np.exp2([2, 3])\narray([ 4.,  8.])\n\n", "; np.exp2([2, 3])\narray([ 4.,  8.])\n"]},
{"library": "numpy", "item_id": "numpy.exp", "code": "\nnumpy.exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'exp'&gt;\u00b6", "description": "Calculate the exponential of all elements in the input array.\n\nParameters\n\nxarray_likeInput values.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise exponential of x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nexpm1Calculate exp(x) - 1 for all elements in the array.\n\nexp2Calculate 2**x for all elements in the array.\n\n\n\nNotes\nThe irrational number e is also known as Euler\u2019s number.  It is\napproximately 2.718281, and is the base of the natural logarithm,\nln (this means that, if ,\nthen . For real input, exp(x) is always positive.\nFor complex arguments, x = a + ib, we can write\n.  The first term, , is already\nknown (it is the real argument, described above).  The second term,\n, is , a function with\nmagnitude 1 and a periodic phase.\nReferences\n\n1\nWikipedia, \u201cExponential function\u201d,\nhttps://en.wikipedia.org/wiki/Exponential_function\n\n2\nM. Abramovitz and I. A. Stegun, \u201cHandbook of Mathematical Functions\nwith Formulas, Graphs, and Mathematical Tables,\u201d Dover, 1964, p. 69,\nhttp://www.math.sfu.ca/~cbm/aands/page_69.htm\n\n\nExamples\nPlot the magnitude and phase of exp(x) in the complex plane:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n\n\n&gt;&gt;&gt; x = np.linspace(-2*np.pi, 2*np.pi, 100)\n&gt;&gt;&gt; xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n&gt;&gt;&gt; out = np.exp(xx)\n\n\n&gt;&gt;&gt; plt.subplot(121)\n&gt;&gt;&gt; plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n&gt;&gt;&gt; plt.title('Magnitude of exp(x)')\n\n\n&gt;&gt;&gt; plt.subplot(122)\n&gt;&gt;&gt; plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n&gt;&gt;&gt; plt.title('Phase (angle) of exp(x)')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise exponential of x.This is a scalar if x is a scalar.", "examples": ["; import matplotlib.pyplot as plt\n\n", "; import matplotlib.pyplot as plt\n", "; x = np.linspace(-2*np.pi, 2*np.pi, 100)\n; xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n; out = np.exp(xx)\n\n", "; x = np.linspace(-2*np.pi, 2*np.pi, 100)\n; xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane\n; out = np.exp(xx)\n", "; plt.subplot(121)\n; plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n; plt.title('Magnitude of exp(x)')\n\n", "; plt.subplot(121)\n; plt.imshow(np.abs(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='gray')\n; plt.title('Magnitude of exp(x)')\n", "; plt.subplot(122)\n; plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n; plt.title('Phase (angle) of exp(x)')\n; plt.show()\n\n", "; plt.subplot(122)\n; plt.imshow(np.angle(out),\n...            extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap='hsv')\n; plt.title('Phase (angle) of exp(x)')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.DataSource.exists", "code": "\nDataSource.exists(self, path)[source]\u00b6", "description": "Test if path exists.\nTest if path exists as (and in this order):\n\na local file.\na remote URL that has been downloaded and stored locally in the\nDataSource directory.\na remote URL that has not been downloaded, but is valid and\naccessible.\n\n\nParameters\n\npathstrCan be a local file or a remote URL.\n\n\n\nReturns\n\noutboolTrue if path exists.\n\n\n\n\nNotes\nWhen path is an URL, exists will return True if it\u2019s either\nstored locally in the DataSource directory, or is a valid remote\nURL.  DataSource does not discriminate between the two, the file\nis accessible if it exists in either location.\n", "parameters": ["Parameters", "pathstr", "Returns", "outbool"], "returns": "outboolTrue if path exists.", "examples": []},
{"library": "numpy", "item_id": "numpy.errstate", "code": "\nclass numpy.errstate(**kwargs)[source]\u00b6", "description": "Context manager for floating-point error handling.\nUsing an instance of errstate as a context manager allows statements in\nthat context to execute with a known error handling behavior. Upon entering\nthe context the error handling is set with seterr and seterrcall, and\nupon exiting it is reset to what it was before.\n\nChanged in version 1.17.0: errstate is also usable as a function decorator, saving\na level of indentation if an entire function is wrapped.\nSee contextlib.ContextDecorator for more information.\n\n\nParameters\n\nkwargs{divide, over, under, invalid}Keyword arguments. The valid keywords are the possible floating-point\nexceptions. Each keyword should have a string value that defines the\ntreatment for the particular error. Possible values are\n{\u2018ignore\u2019, \u2018warn\u2019, \u2018raise\u2019, \u2018call\u2019, \u2018print\u2019, \u2018log\u2019}.\n\n\n\n\n\nSee also\nseterr, geterr, seterrcall, geterrcall\n\nNotes\nFor complete documentation of the types of floating-point exceptions and\ntreatment options, see seterr.\nExamples\n&gt;&gt;&gt; from collections import OrderedDict\n&gt;&gt;&gt; olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n\n&gt;&gt;&gt; np.arange(3) / 0.\narray([nan, inf, inf])\n&gt;&gt;&gt; with np.errstate(divide='warn'):\n...     np.arange(3) / 0.\narray([nan, inf, inf])\n\n\n&gt;&gt;&gt; np.sqrt(-1)\nnan\n&gt;&gt;&gt; with np.errstate(invalid='raise'):\n...     np.sqrt(-1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nFloatingPointError: invalid value encountered in sqrt\n\n\nOutside the context the error handling behavior has not changed:\n&gt;&gt;&gt; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0func)\nCall self as a function.\n\n\n\n", "parameters": ["Parameters", "kwargs{divide, over, under, invalid}"], "returns": [], "examples": ["; from collections import OrderedDict\n; olderr = np.seterr(all='ignore')  # Set error handling to known state.\n\n", "; from collections import OrderedDict\n; olderr = np.seterr(all='ignore')  # Set error handling to known state.\n", "; np.arange(3) / 0.\narray([nan, inf, inf])\n; with np.errstate(divide='warn'):\n...     np.arange(3) / 0.\narray([nan, inf, inf])\n\n", "; np.arange(3) / 0.\narray([nan, inf, inf])\n; with np.errstate(divide='warn'):\n...     np.arange(3) / 0.\narray([nan, inf, inf])\n", "; np.sqrt(-1)\nnan\n; with np.errstate(invalid='raise'):\n...     np.sqrt(-1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nFloatingPointError: invalid value encountered in sqrt\n\n", "; np.sqrt(-1)\nnan\n; with np.errstate(invalid='raise'):\n...     np.sqrt(-1)\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 2, in &lt;module&gt;\nFloatingPointError: invalid value encountered in sqrt\n", "; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])\n\n", "; OrderedDict(sorted(np.geterr().items()))\nOrderedDict([('divide', 'ignore'), ('invalid', 'ignore'), ('over', 'ignore'), ('under', 'ignore')])\n"]},
{"library": "numpy", "item_id": "numpy.char.equal", "code": "\nnumpy.char.equal(x1, x2)\u00b6", "description": "Return (x1 == x2) element-wise.\nUnlike numpy.equal, this comparison is performed by first\nstripping whitespace characters from the end of the string.  This\nbehavior is provided for backward-compatibility with numarray.\n\nParameters\n\nx1, x2array_like of str or unicodeInput arrays of the same shape.\n\n\n\nReturns\n\noutndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.\n\n\n\n\n\nSee also\nnot_equal, greater_equal, less_equal, greater, less\n\n", "parameters": ["Parameters", "x1, x2array_like of str or unicode", "Returns", "outndarray or bool"], "returns": "outndarray or boolOutput array of bools, or a single bool if x1 and x2 are scalars.", "examples": []},
{"library": "numpy", "item_id": "numpy.equal", "code": "\nnumpy.equal(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'equal'&gt;\u00b6", "description": "Return (x1 == x2) element-wise.\n\nParameters\n\nx1, x2array_likeInput arrays. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array, element-wise comparison of x1 and x2.\nTypically of type bool, unless dtype=object is passed.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nnot_equal, greater_equal, less_equal, greater, less\n\nExamples\n&gt;&gt;&gt; np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\n\nWhat is compared are values, not types. So an int (1) and an array of\nlength one can evaluate as True:\n&gt;&gt;&gt; np.equal(1, np.ones(1))\narray([ True])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array, element-wise comparison of x1 and x2.Typically of type bool, unless dtype=object is passed.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n\n", "; np.equal([0, 1, 3], np.arange(3))\narray([ True,  True, False])\n", "; np.equal(1, np.ones(1))\narray([ True])\n\n", "; np.equal(1, np.ones(1))\narray([ True])\n"]},
{"library": "numpy", "item_id": "numpy.random.SeedSequence.entropy", "code": "\nSeedSequence.entropy\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.endswith", "code": "\nchararray.endswith(self, suffix, start=0, end=None)\u00b6", "description": "Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.\n\nSee also\nchar.endswith\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.encode", "code": "\nchararray.encode(self, encoding=None, errors=None)[source]\u00b6", "description": "Calls str.encode element-wise.\n\nSee also\nchar.encode\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.encode", "code": "\nchararray.encode(self, encoding=None, errors=None)\u00b6", "description": "Calls str.encode element-wise.\n\nSee also\nchar.encode\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.endswith", "code": "\nchararray.endswith(self, suffix, start=0, end=None)[source]\u00b6", "description": "Returns a boolean array which is True where the string element\nin self ends with suffix, otherwise False.\n\nSee also\nchar.endswith\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.endswith", "code": "\nnumpy.char.endswith(a, suffix, start=0, end=None)\u00b6", "description": "Returns a boolean array which is True where the string element\nin a ends with suffix, otherwise False.\nCalls str.endswith element-wise.\n\nParameters\n\naarray_like of str or unicode\nsuffixstr\nstart, endint, optionalWith optional start, test beginning at that position. With\noptional end, stop comparing at that position.\n\n\n\nReturns\n\noutndarrayOutputs an array of bools.\n\n\n\n\n\nSee also\nstr.endswith\n\nExamples\n&gt;&gt;&gt; s = np.array(['foo', 'bar'])\n&gt;&gt;&gt; s[0] = 'foo'\n&gt;&gt;&gt; s[1] = 'bar'\n&gt;&gt;&gt; s\narray(['foo', 'bar'], dtype='&lt;U3')\n&gt;&gt;&gt; np.char.endswith(s, 'ar')\narray([False,  True])\n&gt;&gt;&gt; np.char.endswith(s, 'a', start=1, end=2)\narray([False,  True])\n\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "suffixstr", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayOutputs an array of bools.", "examples": ["; s = np.array(['foo', 'bar'])\n; s[0] = 'foo'\n; s[1] = 'bar'\n; s\narray(['foo', 'bar'], dtype='&lt;U3')\n; np.char.endswith(s, 'ar')\narray([False,  True])\n; np.char.endswith(s, 'a', start=1, end=2)\narray([False,  True])\n\n", "; s = np.array(['foo', 'bar'])\n; s[0] = 'foo'\n; s[1] = 'bar'\n; s\narray(['foo', 'bar'], dtype='&lt;U3')\n; np.char.endswith(s, 'ar')\narray([False,  True])\n; np.char.endswith(s, 'a', start=1, end=2)\narray([False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.char.encode", "code": "\nnumpy.char.encode(a, encoding=None, errors=None)\u00b6", "description": "Calls str.encode element-wise.\nThe set of available codecs comes from the Python standard library,\nand may be extended at runtime. For more information, see the codecs\nmodule.\n\nParameters\n\naarray_like of str or unicode\nencodingstr, optionalThe name of an encoding\n\nerrorsstr, optionalSpecifies how to handle encoding errors\n\n\n\nReturns\n\noutndarray\n\n\n\n\nSee also\nstr.encode\n\nNotes\nThe type of the result will depend on the encoding specified.\n", "parameters": ["Parameters", "aarray_like of str or unicode", "encodingstr, optional", "errorsstr, optional", "Returns", "outndarray"], "returns": "outndarray", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.enable_external_loop", "code": "\nnditer.enable_external_loop()\u00b6", "description": "When the \u201cexternal_loop\u201d was not used during construction, but\nis desired, this modifies the iterator to behave as if the flag\nwas specified.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.empty_like", "code": "\nnumpy.empty_like(prototype, dtype=None, order='K', subok=True, shape=None)\u00b6", "description": "Return a new array with the same shape and type as a given array.\n\nParameters\n\nprototypearray_likeThe shape and data-type of prototype define these same attributes\nof the returned array.\n\ndtypedata-type, optionalOverrides the data type of the result.\n\nNew in version 1.6.0.\n\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optionalOverrides the memory layout of the result. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if prototype is Fortran\ncontiguous, \u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of prototype\nas closely as possible.\n\nNew in version 1.6.0.\n\n\nsubokbool, optional.If True, then the newly created array will use the sub-class\ntype of \u2018a\u2019, otherwise it will be a base-class array. Defaults\nto True.\n\nshapeint or sequence of ints, optional.Overrides the shape of the result. If order=\u2019K\u2019 and the number of\ndimensions is unchanged, will try to keep order, otherwise,\norder=\u2019C\u2019 is implied.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\noutndarrayArray of uninitialized (arbitrary) data with the same\nshape and type as prototype.\n\n\n\n\n\nSee also\n\nones_likeReturn an array of ones with shape and type of input.\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nfull_likeReturn a new array with shape of input filled with value.\n\nemptyReturn a new uninitialized array.\n\n\n\nNotes\nThis function does not initialize the returned array; to do that use\nzeros_like or ones_like instead.  It may be marginally faster than\nthe functions that do set the array values.\nExamples\n&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like\n&gt;&gt;&gt; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n&gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n&gt;&gt;&gt; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n\n", "parameters": ["Parameters", "prototypearray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optional", "subokbool, optional.", "shapeint or sequence of ints, optional.", "Returns", "outndarray"], "returns": "outndarrayArray of uninitialized (arbitrary) data with the sameshape and type as prototype.", "examples": ["; a = ([1,2,3], [4,5,6])                         # a is array-like\n; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n", "; a = ([1,2,3], [4,5,6])                         # a is array-like\n; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.empty_like", "code": "\nnumpy.ma.empty_like(prototype, dtype=None, order='K', subok=True, shape=None) = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return a new array with the same shape and type as a given array.\n\nParameters\n\nprototypearray_likeThe shape and data-type of prototype define these same attributes\nof the returned array.\n\ndtypedata-type, optionalOverrides the data type of the result.\n\nNew in version 1.6.0.\n\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optionalOverrides the memory layout of the result. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if prototype is Fortran\ncontiguous, \u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of prototype\nas closely as possible.\n\nNew in version 1.6.0.\n\n\nsubokbool, optional.If True, then the newly created array will use the sub-class\ntype of \u2018a\u2019, otherwise it will be a base-class array. Defaults\nto True.\n\nshapeint or sequence of ints, optional.Overrides the shape of the result. If order=\u2019K\u2019 and the number of\ndimensions is unchanged, will try to keep order, otherwise,\norder=\u2019C\u2019 is implied.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\noutndarrayArray of uninitialized (arbitrary) data with the same\nshape and type as prototype.\n\n\n\n\n\nSee also\n\nones_likeReturn an array of ones with shape and type of input.\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nfull_likeReturn a new array with shape of input filled with value.\n\nemptyReturn a new uninitialized array.\n\n\n\nNotes\nThis function does not initialize the returned array; to do that use\nzeros_like or ones_like instead.  It may be marginally faster than\nthe functions that do set the array values.\nExamples\n&gt;&gt;&gt; a = ([1,2,3], [4,5,6])                         # a is array-like\n&gt;&gt;&gt; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n&gt;&gt;&gt; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n&gt;&gt;&gt; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n\n", "parameters": ["Parameters", "prototypearray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, or \u2018K\u2019}, optional", "subokbool, optional.", "shapeint or sequence of ints, optional.", "Returns", "outndarray"], "returns": "outndarrayArray of uninitialized (arbitrary) data with the sameshape and type as prototype.", "examples": ["; a = ([1,2,3], [4,5,6])                         # a is array-like\n; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n\n", "; a = ([1,2,3], [4,5,6])                         # a is array-like\n; np.empty_like(a)\narray([[-1073741821, -1073741821,           3],    # uninitialized\n       [          0,           0, -1073741821]])\n; a = np.array([[1., 2., 3.],[4.,5.,6.]])\n; np.empty_like(a)\narray([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized\n       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])\n"]},
{"library": "numpy", "item_id": "numpy.matlib.empty", "code": "\nnumpy.matlib.empty(shape, dtype=None, order='C')[source]\u00b6", "description": "Return a new matrix of given shape and type, without initializing entries.\n\nParameters\n\nshapeint or tuple of intShape of the empty matrix.\n\ndtypedata-type, optionalDesired output data-type.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\n\n\nSee also\nempty_like, zeros\n\nNotes\nempty, unlike zeros, does not set the matrix values to zero,\nand may therefore be marginally faster.  On the other hand, it requires\nthe user to manually set all the values in the array, and should be\nused with caution.\nExamples\n&gt;&gt;&gt; import numpy.matlib\n&gt;&gt;&gt; np.matlib.empty((2, 2))    # filled with random data\nmatrix([[  6.76425276e-320,   9.79033856e-307], # random\n        [  7.39337286e-309,   3.22135945e-309]])\n&gt;&gt;&gt; np.matlib.empty((2, 2), dtype=int)\nmatrix([[ 6600475,        0], # random\n        [ 6586976, 22740995]])\n\n\n", "parameters": ["Parameters", "shapeint or tuple of int", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional"], "returns": [], "examples": ["; import numpy.matlib\n; np.matlib.empty((2, 2))    # filled with random data\nmatrix([[  6.76425276e-320,   9.79033856e-307], # random\n        [  7.39337286e-309,   3.22135945e-309]])\n; np.matlib.empty((2, 2), dtype=int)\nmatrix([[ 6600475,        0], # random\n        [ 6586976, 22740995]])\n\n", "; import numpy.matlib\n; np.matlib.empty((2, 2))    # filled with random data\nmatrix([[  6.76425276e-320,   9.79033856e-307], # random\n        [  7.39337286e-309,   3.22135945e-309]])\n; np.matlib.empty((2, 2), dtype=int)\nmatrix([[ 6600475,        0], # random\n        [ 6586976, 22740995]])\n"]},
{"library": "numpy", "item_id": "numpy.empty", "code": "\nnumpy.empty(shape, dtype=float, order='C')\u00b6", "description": "Return a new array of given shape and type, without initializing entries.\n\nParameters\n\nshapeint or tuple of intShape of the empty array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalDesired output data-type for the array, e.g, numpy.int8. Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019Whether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of uninitialized (arbitrary) data of the given shape, dtype, and\norder.  Object arrays will be initialized to None.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nonesReturn a new array setting values to one.\n\nzerosReturn a new array setting values to zero.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nNotes\nempty, unlike zeros, does not set the array values to zero,\nand may therefore be marginally faster.  On the other hand, it requires\nthe user to manually set all the values in the array, and should be\nused with caution.\nExamples\n&gt;&gt;&gt; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n\n&gt;&gt;&gt; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n\n\n", "parameters": ["Parameters", "shapeint or tuple of int", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019", "Returns", "outndarray"], "returns": "outndarrayArray of uninitialized (arbitrary) data of the given shape, dtype, andorder.  Object arrays will be initialized to None.", "examples": ["; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n", "; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n", "; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n\n", "; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n"]},
{"library": "numpy", "item_id": "numpy.ma.empty", "code": "\nnumpy.ma.empty(shape, dtype=float, order='C') = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return a new array of given shape and type, without initializing entries.\n\nParameters\n\nshapeint or tuple of intShape of the empty array, e.g., (2, 3) or 2.\n\ndtypedata-type, optionalDesired output data-type for the array, e.g, numpy.int8. Default is\nnumpy.float64.\n\norder{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019Whether to store multi-dimensional data in row-major\n(C-style) or column-major (Fortran-style) order in\nmemory.\n\n\n\nReturns\n\noutndarrayArray of uninitialized (arbitrary) data of the given shape, dtype, and\norder.  Object arrays will be initialized to None.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nonesReturn a new array setting values to one.\n\nzerosReturn a new array setting values to zero.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nNotes\nempty, unlike zeros, does not set the array values to zero,\nand may therefore be marginally faster.  On the other hand, it requires\nthe user to manually set all the values in the array, and should be\nused with caution.\nExamples\n&gt;&gt;&gt; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n\n&gt;&gt;&gt; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n\n\n", "parameters": ["Parameters", "shapeint or tuple of int", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional, default: \u2018C\u2019", "Returns", "outndarray"], "returns": "outndarrayArray of uninitialized (arbitrary) data of the given shape, dtype, andorder.  Object arrays will be initialized to None.", "examples": ["; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n\n", "; np.empty([2, 2])\narray([[ -9.74499359e+001,   6.69583040e-309],\n       [  2.13182611e-314,   3.06959433e-309]])         #uninitialized\n", "; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n\n", "; np.empty([2, 2], dtype=int)\narray([[-1073741821, -1067949133],\n       [  496041986,    19249760]])                     #uninitialized\n"]},
{"library": "numpy", "item_id": "numpy.einsum_path", "code": "\nnumpy.einsum_path(subscripts, *operands, optimize='greedy')[source]\u00b6", "description": "Evaluates the lowest cost contraction order for an einsum expression by\nconsidering the creation of intermediate arrays.\n\nParameters\n\nsubscriptsstrSpecifies the subscripts for summation.\n\n*operandslist of array_likeThese are the arrays for the operation.\n\noptimize{bool, list, tuple, \u2018greedy\u2019, \u2018optimal\u2019}Choose the type of path. If a tuple is provided, the second argument is\nassumed to be the maximum intermediate size created. If only a single\nargument is provided the largest input or output array size is used\nas a maximum intermediate size.\n\nif a list is given that starts with einsum_path, uses this as the\ncontraction path\nif False no optimization is taken\nif True defaults to the \u2018greedy\u2019 algorithm\n\u2018optimal\u2019 An algorithm that combinatorially explores all possible\nways of contracting the listed tensors and choosest the least costly\npath. Scales exponentially with the number of terms in the\ncontraction.\n\u2018greedy\u2019 An algorithm that chooses the best pair contraction\nat each step. Effectively, this algorithm searches the largest inner,\nHadamard, and then outer products at each step. Scales cubically with\nthe number of terms in the contraction. Equivalent to the \u2018optimal\u2019\npath for most contractions.\n\nDefault is \u2018greedy\u2019.\n\n\n\nReturns\n\npathlist of tuplesA list representation of the einsum path.\n\nstring_reprstrA printable representation of the einsum path.\n\n\n\n\n\nSee also\neinsum, linalg.multi_dot\n\nNotes\nThe resulting path indicates which terms of the input contraction should be\ncontracted first, the result of this contraction is then appended to the\nend of the contraction list. This list can then be iterated over until all\nintermediate contractions are complete.\nExamples\nWe can begin with a chain dot example. In this case, it is optimal to\ncontract the b and c tensors first as represented by the first\nelement of the path (1, 2). The resulting tensor is added to the end\nof the contraction and the remaining contraction (0, 1) is then\ncompleted.\n&gt;&gt;&gt; np.random.seed(123)\n&gt;&gt;&gt; a = np.random.rand(2, 2)\n&gt;&gt;&gt; b = np.random.rand(2, 5)\n&gt;&gt;&gt; c = np.random.rand(5, 2)\n&gt;&gt;&gt; path_info = np.einsum_path('ij,jk,kl-&gt;il', a, b, c, optimize='greedy')\n&gt;&gt;&gt; print(path_info[0])\n['einsum_path', (1, 2), (0, 1)]\n&gt;&gt;&gt; print(path_info[1])\n  Complete contraction:  ij,jk,kl-&gt;il # may vary\n         Naive scaling:  4\n     Optimized scaling:  3\n      Naive FLOP count:  1.600e+02\n  Optimized FLOP count:  5.600e+01\n   Theoretical speedup:  2.857\n  Largest intermediate:  4.000e+00 elements\n-------------------------------------------------------------------------\nscaling                  current                                remaining\n-------------------------------------------------------------------------\n   3                   kl,jk-&gt;jl                                ij,jl-&gt;il\n   3                   jl,ij-&gt;il                                   il-&gt;il\n\n\nA more complex index transformation example.\n&gt;&gt;&gt; I = np.random.rand(10, 10, 10, 10)\n&gt;&gt;&gt; C = np.random.rand(10, 10)\n&gt;&gt;&gt; path_info = np.einsum_path('ea,fb,abcd,gc,hd-&gt;efgh', C, C, I, C, C,\n...                            optimize='greedy')\n\n\n&gt;&gt;&gt; print(path_info[0])\n['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]\n&gt;&gt;&gt; print(path_info[1]) \n  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary\n         Naive scaling:  8\n     Optimized scaling:  5\n      Naive FLOP count:  8.000e+08\n  Optimized FLOP count:  8.000e+05\n   Theoretical speedup:  1000.000\n  Largest intermediate:  1.000e+04 elements\n--------------------------------------------------------------------------\nscaling                  current                                remaining\n--------------------------------------------------------------------------\n   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh\n   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh\n   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh\n   5               defg,hd-&gt;efgh                               efgh-&gt;efgh\n\n\n", "parameters": ["Parameters", "subscriptsstr", "*operandslist of array_like", "optimize{bool, list, tuple, \u2018greedy\u2019, \u2018optimal\u2019}", "Returns", "pathlist of tuples", "string_reprstr"], "returns": "pathlist of tuplesA list representation of the einsum path.string_reprstrA printable representation of the einsum path.", "examples": ["; np.random.seed(123)\n; a = np.random.rand(2, 2)\n; b = np.random.rand(2, 5)\n; c = np.random.rand(5, 2)\n; path_info = np.einsum_path('ij,jk,kl-&gt;il', a, b, c, optimize='greedy')\n; print(path_info[0])\n['einsum_path', (1, 2), (0, 1)]\n; print(path_info[1])\n  Complete contraction:  ij,jk,kl-&gt;il # may vary\n         Naive scaling:  4\n     Optimized scaling:  3\n      Naive FLOP count:  1.600e+02\n  Optimized FLOP count:  5.600e+01\n   Theoretical speedup:  2.857\n  Largest intermediate:  4.000e+00 elements\n-------------------------------------------------------------------------\nscaling                  current                                remaining\n-------------------------------------------------------------------------\n   3                   kl,jk-&gt;jl                                ij,jl-&gt;il\n   3                   jl,ij-&gt;il                                   il-&gt;il\n\n", "; np.random.seed(123)\n; a = np.random.rand(2, 2)\n; b = np.random.rand(2, 5)\n; c = np.random.rand(5, 2)\n; path_info = np.einsum_path('ij,jk,kl-&gt;il', a, b, c, optimize='greedy')\n; print(path_info[0])\n['einsum_path', (1, 2), (0, 1)]\n; print(path_info[1])\n  Complete contraction:  ij,jk,kl-&gt;il # may vary\n         Naive scaling:  4\n     Optimized scaling:  3\n      Naive FLOP count:  1.600e+02\n  Optimized FLOP count:  5.600e+01\n   Theoretical speedup:  2.857\n  Largest intermediate:  4.000e+00 elements\n-------------------------------------------------------------------------\nscaling                  current                                remaining\n-------------------------------------------------------------------------\n   3                   kl,jk-&gt;jl                                ij,jl-&gt;il\n   3                   jl,ij-&gt;il                                   il-&gt;il\n", "; I = np.random.rand(10, 10, 10, 10)\n; C = np.random.rand(10, 10)\n; path_info = np.einsum_path('ea,fb,abcd,gc,hd-&gt;efgh', C, C, I, C, C,\n...                            optimize='greedy')\n\n", "; I = np.random.rand(10, 10, 10, 10)\n; C = np.random.rand(10, 10)\n; path_info = np.einsum_path('ea,fb,abcd,gc,hd-&gt;efgh', C, C, I, C, C,\n...                            optimize='greedy')\n", "; print(path_info[0])\n['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]\n; print(path_info[1]) \n  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary\n         Naive scaling:  8\n     Optimized scaling:  5\n      Naive FLOP count:  8.000e+08\n  Optimized FLOP count:  8.000e+05\n   Theoretical speedup:  1000.000\n  Largest intermediate:  1.000e+04 elements\n--------------------------------------------------------------------------\nscaling                  current                                remaining\n--------------------------------------------------------------------------\n   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh\n   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh\n   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh\n   5               defg,hd-&gt;efgh                               efgh-&gt;efgh\n\n", "; print(path_info[0])\n['einsum_path', (0, 2), (0, 3), (0, 2), (0, 1)]\n; print(path_info[1]) \n  Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh # may vary\n         Naive scaling:  8\n     Optimized scaling:  5\n      Naive FLOP count:  8.000e+08\n  Optimized FLOP count:  8.000e+05\n   Theoretical speedup:  1000.000\n  Largest intermediate:  1.000e+04 elements\n--------------------------------------------------------------------------\nscaling                  current                                remaining\n--------------------------------------------------------------------------\n   5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh\n   5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh\n   5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh\n   5               defg,hd-&gt;efgh                               efgh-&gt;efgh\n"]},
{"library": "numpy", "item_id": "numpy.einsum", "code": "\nnumpy.einsum(subscripts, *operands, out=None, dtype=None, order='K', casting='safe', optimize=False)[source]\u00b6", "description": "Evaluates the Einstein summation convention on the operands.\nUsing the Einstein summation convention, many common multi-dimensional,\nlinear algebraic array operations can be represented in a simple fashion.\nIn implicit mode einsum computes these values.\nIn explicit mode, einsum provides further flexibility to compute\nother array operations that might not be considered classical Einstein\nsummation operations, by disabling, or forcing summation over specified\nsubscript labels.\nSee the notes and examples for clarification.\n\nParameters\n\nsubscriptsstrSpecifies the subscripts for summation as comma separated list of\nsubscript labels. An implicit (classical Einstein summation)\ncalculation is performed unless the explicit indicator \u2018-&gt;\u2019 is\nincluded as well as subscript labels of the precise output form.\n\noperandslist of array_likeThese are the arrays for the operation.\n\noutndarray, optionalIf provided, the calculation is done into this array.\n\ndtype{data-type, None}, optionalIf provided, forces the calculation to use the data type specified.\nNote that you may have to also give a more liberal casting\nparameter to allow the conversions. Default is None.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the output. \u2018C\u2019 means it should\nbe C contiguous. \u2018F\u2019 means it should be Fortran contiguous,\n\u2018A\u2019 means it should be \u2018F\u2019 if the inputs are all \u2018F\u2019, \u2018C\u2019 otherwise.\n\u2018K\u2019 means it should be as close to the layout as the inputs as\nis possible, including arbitrarily permuted axes.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur.  Setting this to\n\u2018unsafe\u2019 is not recommended, as it can adversely affect accumulations.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\nDefault is \u2018safe\u2019.\n\noptimize{False, True, \u2018greedy\u2019, \u2018optimal\u2019}, optionalControls if intermediate optimization should occur. No optimization\nwill occur if False and True will default to the \u2018greedy\u2019 algorithm.\nAlso accepts an explicit contraction list from the np.einsum_path\nfunction. See np.einsum_path for more details. Defaults to False.\n\n\n\nReturns\n\noutputndarrayThe calculation based on the Einstein summation convention.\n\n\n\n\n\nSee also\neinsum_path, dot, inner, outer, tensordot, linalg.multi_dot\n\nNotes\n\nNew in version 1.6.0.\n\nThe Einstein summation convention can be used to compute\nmany multi-dimensional, linear algebraic array operations. einsum\nprovides a succinct way of representing these.\nA non-exhaustive list of these operations,\nwhich can be computed by einsum, is shown below along with examples:\n\nTrace of an array, numpy.trace.\nReturn a diagonal, numpy.diag.\nArray axis summations, numpy.sum.\nTranspositions and permutations, numpy.transpose.\nMatrix multiplication and dot product, numpy.matmul numpy.dot.\nVector inner and outer products, numpy.inner numpy.outer.\nBroadcasting, element-wise and scalar multiplication, numpy.multiply.\nTensor contractions, numpy.tensordot.\nChained array operations, in efficient calculation order, numpy.einsum_path.\n\nThe subscripts string is a comma-separated list of subscript labels,\nwhere each label refers to a dimension of the corresponding operand.\nWhenever a label is repeated it is summed, so np.einsum('i,i', a, b)\nis equivalent to np.inner(a,b). If a label\nappears only once, it is not summed, so np.einsum('i', a) produces a\nview of a with no changes. A further example np.einsum('ij,jk', a, b)\ndescribes traditional matrix multiplication and is equivalent to\nnp.matmul(a,b). Repeated subscript labels in one\noperand take the diagonal. For example, np.einsum('ii', a) is equivalent\nto np.trace(a).\nIn implicit mode, the chosen subscripts are important\nsince the axes of the output are reordered alphabetically.  This\nmeans that np.einsum('ij', a) doesn\u2019t affect a 2D array, while\nnp.einsum('ji', a) takes its transpose. Additionally,\nnp.einsum('ij,jk', a, b) returns a matrix multiplication, while,\nnp.einsum('ij,jh', a, b) returns the transpose of the\nmultiplication since subscript \u2018h\u2019 precedes subscript \u2018i\u2019.\nIn explicit mode the output can be directly controlled by\nspecifying output subscript labels.  This requires the\nidentifier \u2018-&gt;\u2019 as well as the list of output subscript labels.\nThis feature increases the flexibility of the function since\nsumming can be disabled or forced when required. The call\nnp.einsum('i-&gt;', a) is like np.sum(a, axis=-1),\nand np.einsum('ii-&gt;i', a) is like np.diag(a).\nThe difference is that einsum does not allow broadcasting by default.\nAdditionally np.einsum('ij,jh-&gt;ih', a, b) directly specifies the\norder of the output subscript labels and therefore returns matrix\nmultiplication, unlike the example above in implicit mode.\nTo enable and control broadcasting, use an ellipsis.  Default\nNumPy-style broadcasting is done by adding an ellipsis\nto the left of each term, like np.einsum('...ii-&gt;...i', a).\nTo take the trace along the first and last axes,\nyou can do np.einsum('i...i', a), or to do a matrix-matrix\nproduct with the left-most indices instead of rightmost, one can do\nnp.einsum('ij...,jk...-&gt;ik...', a, b).\nWhen there is only one operand, no axes are summed, and no output\nparameter is provided, a view into the operand is returned instead\nof a new array.  Thus, taking the diagonal as np.einsum('ii-&gt;i', a)\nproduces a view (changed in version 1.10.0).\neinsum also provides an alternative way to provide the subscripts\nand operands as einsum(op0, sublist0, op1, sublist1, ..., [sublistout]).\nIf the output shape is not provided in this format einsum will be\ncalculated in implicit mode, otherwise it will be performed explicitly.\nThe examples below have corresponding einsum calls with the two\nparameter methods.\n\nNew in version 1.10.0.\n\nViews returned from einsum are now writeable whenever the input array\nis writeable. For example, np.einsum('ijk...-&gt;kji...', a) will now\nhave the same effect as np.swapaxes(a, 0, 2)\nand np.einsum('ii-&gt;i', a) will return a writeable view of the diagonal\nof a 2D array.\n\nNew in version 1.12.0.\n\nAdded the optimize argument which will optimize the contraction order\nof an einsum expression. For a contraction with three or more operands this\ncan greatly increase the computational efficiency at the cost of a larger\nmemory footprint during computation.\nTypically a \u2018greedy\u2019 algorithm is applied which empirical tests have shown\nreturns the optimal path in the majority of cases. In some cases \u2018optimal\u2019\nwill return the superlative path through a more expensive, exhaustive search.\nFor iterative calculations it may be advisable to calculate the optimal path\nonce and reuse that path by supplying it as an argument. An example is given\nbelow.\nSee numpy.einsum_path for more details.\nExamples\n&gt;&gt;&gt; a = np.arange(25).reshape(5,5)\n&gt;&gt;&gt; b = np.arange(5)\n&gt;&gt;&gt; c = np.arange(6).reshape(2,3)\n\n\nTrace of a matrix:\n&gt;&gt;&gt; np.einsum('ii', a)\n60\n&gt;&gt;&gt; np.einsum(a, [0,0])\n60\n&gt;&gt;&gt; np.trace(a)\n60\n\n\nExtract the diagonal (requires explicit form):\n&gt;&gt;&gt; np.einsum('ii-&gt;i', a)\narray([ 0,  6, 12, 18, 24])\n&gt;&gt;&gt; np.einsum(a, [0,0], [0])\narray([ 0,  6, 12, 18, 24])\n&gt;&gt;&gt; np.diag(a)\narray([ 0,  6, 12, 18, 24])\n\n\nSum over an axis (requires explicit form):\n&gt;&gt;&gt; np.einsum('ij-&gt;i', a)\narray([ 10,  35,  60,  85, 110])\n&gt;&gt;&gt; np.einsum(a, [0,1], [0])\narray([ 10,  35,  60,  85, 110])\n&gt;&gt;&gt; np.sum(a, axis=1)\narray([ 10,  35,  60,  85, 110])\n\n\nFor higher dimensional arrays summing a single axis can be done with ellipsis:\n&gt;&gt;&gt; np.einsum('...j-&gt;...', a)\narray([ 10,  35,  60,  85, 110])\n&gt;&gt;&gt; np.einsum(a, [Ellipsis,1], [Ellipsis])\narray([ 10,  35,  60,  85, 110])\n\n\nCompute a matrix transpose, or reorder any number of axes:\n&gt;&gt;&gt; np.einsum('ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n&gt;&gt;&gt; np.einsum('ij-&gt;ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n&gt;&gt;&gt; np.einsum(c, [1,0])\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n&gt;&gt;&gt; np.transpose(c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n\n\nVector inner products:\n&gt;&gt;&gt; np.einsum('i,i', b, b)\n30\n&gt;&gt;&gt; np.einsum(b, [0], b, [0])\n30\n&gt;&gt;&gt; np.inner(b,b)\n30\n\n\nMatrix vector multiplication:\n&gt;&gt;&gt; np.einsum('ij,j', a, b)\narray([ 30,  80, 130, 180, 230])\n&gt;&gt;&gt; np.einsum(a, [0,1], b, [1])\narray([ 30,  80, 130, 180, 230])\n&gt;&gt;&gt; np.dot(a, b)\narray([ 30,  80, 130, 180, 230])\n&gt;&gt;&gt; np.einsum('...j,j', a, b)\narray([ 30,  80, 130, 180, 230])\n\n\nBroadcasting and scalar multiplication:\n&gt;&gt;&gt; np.einsum('..., ...', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n&gt;&gt;&gt; np.einsum(',ij', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n&gt;&gt;&gt; np.einsum(3, [Ellipsis], c, [Ellipsis])\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n&gt;&gt;&gt; np.multiply(3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n\n\nVector outer product:\n&gt;&gt;&gt; np.einsum('i,j', np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n&gt;&gt;&gt; np.einsum(np.arange(2)+1, [0], b, [1])\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n&gt;&gt;&gt; np.outer(np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n\n\nTensor contraction:\n&gt;&gt;&gt; a = np.arange(60.).reshape(3,4,5)\n&gt;&gt;&gt; b = np.arange(24.).reshape(4,3,2)\n&gt;&gt;&gt; np.einsum('ijk,jil-&gt;kl', a, b)\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n&gt;&gt;&gt; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n&gt;&gt;&gt; np.tensordot(a,b, axes=([1,0],[0,1]))\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n\n\nWriteable returned arrays (since version 1.10.0):\n&gt;&gt;&gt; a = np.zeros((3, 3))\n&gt;&gt;&gt; np.einsum('ii-&gt;i', a)[:] = 1\n&gt;&gt;&gt; a\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nExample of ellipsis use:\n&gt;&gt;&gt; a = np.arange(6).reshape((3,2))\n&gt;&gt;&gt; b = np.arange(12).reshape((4,3))\n&gt;&gt;&gt; np.einsum('ki,jk-&gt;ij', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n&gt;&gt;&gt; np.einsum('ki,...k-&gt;i...', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n&gt;&gt;&gt; np.einsum('k...,jk', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n\n\nChained array operations. For more complicated contractions, speed ups\nmight be achieved by repeatedly computing a \u2018greedy\u2019 path or pre-computing the\n\u2018optimal\u2019 path and repeatedly applying it, using an\neinsum_path insertion (since version 1.12.0). Performance improvements can be\nparticularly significant with larger arrays:\n&gt;&gt;&gt; a = np.ones(64).reshape(2,4,8)\n\n\nBasic einsum: ~1520ms  (benchmarked on 3.1GHz Intel i5.)\n&gt;&gt;&gt; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a)\n\n\nSub-optimal einsum (due to repeated path calculation time): ~330ms\n&gt;&gt;&gt; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')\n\n\nGreedy einsum (faster optimal path approximation): ~160ms\n&gt;&gt;&gt; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy')\n\n\nOptimal einsum (best usage pattern in some use cases): ~110ms\n&gt;&gt;&gt; path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0]\n&gt;&gt;&gt; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path)\n\n\n", "parameters": ["Parameters", "subscriptsstr", "operandslist of array_like", "outndarray, optional", "dtype{data-type, None}, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "optimize{False, True, \u2018greedy\u2019, \u2018optimal\u2019}, optional", "Returns", "outputndarray"], "returns": "outputndarrayThe calculation based on the Einstein summation convention.", "examples": ["; a = np.arange(25).reshape(5,5)\n; b = np.arange(5)\n; c = np.arange(6).reshape(2,3)\n\n", "; a = np.arange(25).reshape(5,5)\n; b = np.arange(5)\n; c = np.arange(6).reshape(2,3)\n", "; np.einsum('ii', a)\n60\n; np.einsum(a, [0,0])\n60\n; np.trace(a)\n60\n\n", "; np.einsum('ii', a)\n60\n; np.einsum(a, [0,0])\n60\n; np.trace(a)\n60\n", "; np.einsum('ii-&gt;i', a)\narray([ 0,  6, 12, 18, 24])\n; np.einsum(a, [0,0], [0])\narray([ 0,  6, 12, 18, 24])\n; np.diag(a)\narray([ 0,  6, 12, 18, 24])\n\n", "; np.einsum('ii-&gt;i', a)\narray([ 0,  6, 12, 18, 24])\n; np.einsum(a, [0,0], [0])\narray([ 0,  6, 12, 18, 24])\n; np.diag(a)\narray([ 0,  6, 12, 18, 24])\n", "; np.einsum('ij-&gt;i', a)\narray([ 10,  35,  60,  85, 110])\n; np.einsum(a, [0,1], [0])\narray([ 10,  35,  60,  85, 110])\n; np.sum(a, axis=1)\narray([ 10,  35,  60,  85, 110])\n\n", "; np.einsum('ij-&gt;i', a)\narray([ 10,  35,  60,  85, 110])\n; np.einsum(a, [0,1], [0])\narray([ 10,  35,  60,  85, 110])\n; np.sum(a, axis=1)\narray([ 10,  35,  60,  85, 110])\n", "; np.einsum('...j-&gt;...', a)\narray([ 10,  35,  60,  85, 110])\n; np.einsum(a, [Ellipsis,1], [Ellipsis])\narray([ 10,  35,  60,  85, 110])\n\n", "; np.einsum('...j-&gt;...', a)\narray([ 10,  35,  60,  85, 110])\n; np.einsum(a, [Ellipsis,1], [Ellipsis])\narray([ 10,  35,  60,  85, 110])\n", "; np.einsum('ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.einsum('ij-&gt;ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.einsum(c, [1,0])\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.transpose(c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n\n", "; np.einsum('ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.einsum('ij-&gt;ji', c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.einsum(c, [1,0])\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n; np.transpose(c)\narray([[0, 3],\n       [1, 4],\n       [2, 5]])\n", "; np.einsum('i,i', b, b)\n30\n; np.einsum(b, [0], b, [0])\n30\n; np.inner(b,b)\n30\n\n", "; np.einsum('i,i', b, b)\n30\n; np.einsum(b, [0], b, [0])\n30\n; np.inner(b,b)\n30\n", "; np.einsum('ij,j', a, b)\narray([ 30,  80, 130, 180, 230])\n; np.einsum(a, [0,1], b, [1])\narray([ 30,  80, 130, 180, 230])\n; np.dot(a, b)\narray([ 30,  80, 130, 180, 230])\n; np.einsum('...j,j', a, b)\narray([ 30,  80, 130, 180, 230])\n\n", "; np.einsum('ij,j', a, b)\narray([ 30,  80, 130, 180, 230])\n; np.einsum(a, [0,1], b, [1])\narray([ 30,  80, 130, 180, 230])\n; np.dot(a, b)\narray([ 30,  80, 130, 180, 230])\n; np.einsum('...j,j', a, b)\narray([ 30,  80, 130, 180, 230])\n", "; np.einsum('..., ...', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.einsum(',ij', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.einsum(3, [Ellipsis], c, [Ellipsis])\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.multiply(3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n\n", "; np.einsum('..., ...', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.einsum(',ij', 3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.einsum(3, [Ellipsis], c, [Ellipsis])\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n; np.multiply(3, c)\narray([[ 0,  3,  6],\n       [ 9, 12, 15]])\n", "; np.einsum('i,j', np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n; np.einsum(np.arange(2)+1, [0], b, [1])\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n; np.outer(np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n\n", "; np.einsum('i,j', np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n; np.einsum(np.arange(2)+1, [0], b, [1])\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n; np.outer(np.arange(2)+1, b)\narray([[0, 1, 2, 3, 4],\n       [0, 2, 4, 6, 8]])\n", "; a = np.arange(60.).reshape(3,4,5)\n; b = np.arange(24.).reshape(4,3,2)\n; np.einsum('ijk,jil-&gt;kl', a, b)\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; np.tensordot(a,b, axes=([1,0],[0,1]))\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n\n", "; a = np.arange(60.).reshape(3,4,5)\n; b = np.arange(24.).reshape(4,3,2)\n; np.einsum('ijk,jil-&gt;kl', a, b)\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; np.einsum(a, [0,1,2], b, [1,0,3], [2,3])\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n; np.tensordot(a,b, axes=([1,0],[0,1]))\narray([[4400., 4730.],\n       [4532., 4874.],\n       [4664., 5018.],\n       [4796., 5162.],\n       [4928., 5306.]])\n", "; a = np.zeros((3, 3))\n; np.einsum('ii-&gt;i', a)[:] = 1\n; a\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n", "; a = np.zeros((3, 3))\n; np.einsum('ii-&gt;i', a)[:] = 1\n; a\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n", "; a = np.arange(6).reshape((3,2))\n; b = np.arange(12).reshape((4,3))\n; np.einsum('ki,jk-&gt;ij', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n; np.einsum('ki,...k-&gt;i...', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n; np.einsum('k...,jk', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n\n", "; a = np.arange(6).reshape((3,2))\n; b = np.arange(12).reshape((4,3))\n; np.einsum('ki,jk-&gt;ij', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n; np.einsum('ki,...k-&gt;i...', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n; np.einsum('k...,jk', a, b)\narray([[10, 28, 46, 64],\n       [13, 40, 67, 94]])\n", "; a = np.ones(64).reshape(2,4,8)\n\n", "; a = np.ones(64).reshape(2,4,8)\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a)\n\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a)\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')\n\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy')\n\n", "; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='greedy')\n", "; path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0]\n; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path)\n\n", "; path = np.einsum_path('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize='optimal')[0]\n; for iteration in range(500):\n...     _ = np.einsum('ijk,ilm,njm,nlk,abc-&gt;',a,a,a,a,a, optimize=path)\n"]},
{"library": "numpy", "item_id": "numpy.linalg.eigvalsh", "code": "\nnumpy.linalg.eigvalsh(a, UPLO='L')[source]\u00b6", "description": "Compute the eigenvalues of a complex Hermitian or real symmetric matrix.\nMain difference from eigh: the eigenvectors are not computed.\n\nParameters\n\na(\u2026, M, M) array_likeA complex- or real-valued matrix whose eigenvalues are to be\ncomputed.\n\nUPLO{\u2018L\u2019, \u2018U\u2019}, optionalSpecifies whether the calculation is done with the lower triangular\npart of a (\u2018L\u2019, default) or the upper triangular part (\u2018U\u2019).\nIrrespective of this value only the real parts of the diagonal will\nbe considered in the computation to preserve the notion of a Hermitian\nmatrix. It therefore follows that the imaginary part of the diagonal\nwill always be treated as zero.\n\n\n\nReturns\n\nw(\u2026, M,) ndarrayThe eigenvalues in ascending order, each repeated according to\nits multiplicity.\n\n\n\nRaises\n\nLinAlgErrorIf the eigenvalue computation does not converge.\n\n\n\n\n\nSee also\n\neigheigenvalues and eigenvectors of real symmetric or complex Hermitian (conjugate symmetric) arrays.\n\neigvalseigenvalues of general real or complex arrays.\n\neigeigenvalues and right eigenvectors of general real or complex arrays.\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThe eigenvalues are computed using LAPACK routines _syevd, _heevd.\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])\n&gt;&gt;&gt; LA.eigvalsh(a)\narray([ 0.17157288,  5.82842712]) # may vary\n\n\n&gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal\n&gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n&gt;&gt;&gt; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n&gt;&gt;&gt; # with UPLO='L' this is numerically equivalent to using LA.eigvals()\n&gt;&gt;&gt; # with:\n&gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n&gt;&gt;&gt; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n&gt;&gt;&gt; wa = LA.eigvalsh(a)\n&gt;&gt;&gt; wb = LA.eigvals(b)\n&gt;&gt;&gt; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "UPLO{\u2018L\u2019, \u2018U\u2019}, optional", "Returns", "w(\u2026, M,) ndarray", "Raises", "LinAlgError"], "returns": "w(\u2026, M,) ndarrayThe eigenvalues in ascending order, each repeated according toits multiplicity.", "examples": ["; from numpy import linalg as LA\n; a = np.array([[1, -2j], [2j, 5]])\n; LA.eigvalsh(a)\narray([ 0.17157288,  5.82842712]) # may vary\n\n", "; from numpy import linalg as LA\n; a = np.array([[1, -2j], [2j, 5]])\n; LA.eigvalsh(a)\narray([ 0.17157288,  5.82842712]) # may vary\n", "; # demonstrate the treatment of the imaginary part of the diagonal\n; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n; # with UPLO='L' this is numerically equivalent to using LA.eigvals()\n; # with:\n; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n; wa = LA.eigvalsh(a)\n; wb = LA.eigvals(b)\n; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n\n", "; # demonstrate the treatment of the imaginary part of the diagonal\n; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n; # with UPLO='L' this is numerically equivalent to using LA.eigvals()\n; # with:\n; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n; wa = LA.eigvalsh(a)\n; wb = LA.eigvals(b)\n; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.eigvals", "code": "\nnumpy.linalg.eigvals(a)[source]\u00b6", "description": "Compute the eigenvalues of a general matrix.\nMain difference between eigvals and eig: the eigenvectors aren\u2019t\nreturned.\n\nParameters\n\na(\u2026, M, M) array_likeA complex- or real-valued matrix whose eigenvalues will be computed.\n\n\n\nReturns\n\nw(\u2026, M,) ndarrayThe eigenvalues, each repeated according to its multiplicity.\nThey are not necessarily ordered, nor are they necessarily\nreal for real matrices.\n\n\n\nRaises\n\nLinAlgErrorIf the eigenvalue computation does not converge.\n\n\n\n\n\nSee also\n\neigeigenvalues and right eigenvectors of general arrays\n\neigvalsheigenvalues of real symmetric or complex Hermitian (conjugate symmetric) arrays.\n\neigheigenvalues and eigenvectors of real symmetric or complex Hermitian (conjugate symmetric) arrays.\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThis is implemented using the _geev LAPACK routines which compute\nthe eigenvalues and eigenvectors of general square arrays.\nExamples\nIllustration, using the fact that the eigenvalues of a diagonal matrix\nare its diagonal elements, that multiplying a matrix on the left\nby an orthogonal matrix, Q, and on the right by Q.T (the transpose\nof Q), preserves the eigenvalues of the \u201cmiddle\u201d matrix.  In other words,\nif Q is orthogonal, then Q * A * Q.T has the same eigenvalues as\nA:\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; x = np.random.random()\n&gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])\n&gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])\n(1.0, 1.0, 0.0)\n\n\nNow multiply a diagonal matrix by Q on one side and by Q.T on the other:\n&gt;&gt;&gt; D = np.diag((-1,1))\n&gt;&gt;&gt; LA.eigvals(D)\narray([-1.,  1.])\n&gt;&gt;&gt; A = np.dot(Q, D)\n&gt;&gt;&gt; A = np.dot(A, Q.T)\n&gt;&gt;&gt; LA.eigvals(A)\narray([ 1., -1.]) # random\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "Returns", "w(\u2026, M,) ndarray", "Raises", "LinAlgError"], "returns": "w(\u2026, M,) ndarrayThe eigenvalues, each repeated according to its multiplicity.They are not necessarily ordered, nor are they necessarilyreal for real matrices.", "examples": ["; from numpy import linalg as LA\n; x = np.random.random()\n; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])\n; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])\n(1.0, 1.0, 0.0)\n\n", "; from numpy import linalg as LA\n; x = np.random.random()\n; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])\n; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])\n(1.0, 1.0, 0.0)\n", "; D = np.diag((-1,1))\n; LA.eigvals(D)\narray([-1.,  1.])\n; A = np.dot(Q, D)\n; A = np.dot(A, Q.T)\n; LA.eigvals(A)\narray([ 1., -1.]) # random\n\n", "; D = np.diag((-1,1))\n; LA.eigvals(D)\narray([-1.,  1.])\n; A = np.dot(Q, D)\n; A = np.dot(A, Q.T)\n; LA.eigvals(A)\narray([ 1., -1.]) # random\n"]},
{"library": "numpy", "item_id": "numpy.linalg.eigh", "code": "\nnumpy.linalg.eigh(a, UPLO='L')[source]\u00b6", "description": "Return the eigenvalues and eigenvectors of a complex Hermitian\n(conjugate symmetric) or a real symmetric matrix.\nReturns two objects, a 1-D array containing the eigenvalues of a, and\na 2-D square array or matrix (depending on the input type) of the\ncorresponding eigenvectors (in columns).\n\nParameters\n\na(\u2026, M, M) arrayHermitian or real symmetric matrices whose eigenvalues and\neigenvectors are to be computed.\n\nUPLO{\u2018L\u2019, \u2018U\u2019}, optionalSpecifies whether the calculation is done with the lower triangular\npart of a (\u2018L\u2019, default) or the upper triangular part (\u2018U\u2019).\nIrrespective of this value only the real parts of the diagonal will\nbe considered in the computation to preserve the notion of a Hermitian\nmatrix. It therefore follows that the imaginary part of the diagonal\nwill always be treated as zero.\n\n\n\nReturns\n\nw(\u2026, M) ndarrayThe eigenvalues in ascending order, each repeated according to\nits multiplicity.\n\nv{(\u2026, M, M) ndarray, (\u2026, M, M) matrix}The column v[:, i] is the normalized eigenvector corresponding\nto the eigenvalue w[i].  Will return a matrix object if a is\na matrix object.\n\n\n\nRaises\n\nLinAlgErrorIf the eigenvalue computation does not converge.\n\n\n\n\n\nSee also\n\neigvalsheigenvalues of real symmetric or complex Hermitian (conjugate symmetric) arrays.\n\neigeigenvalues and right eigenvectors for non-symmetric arrays.\n\neigvalseigenvalues of non-symmetric arrays.\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThe eigenvalues/eigenvectors are computed using LAPACK routines _syevd,\n_heevd.\nThe eigenvalues of real symmetric or complex Hermitian matrices are\nalways real. [1] The array v of (column) eigenvectors is unitary\nand a, w, and v satisfy the equations\ndot(a, v[:, i]) = w[i] * v[:, i].\nReferences\n\n1\nG. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando,\nFL, Academic Press, Inc., 1980, pg. 222.\n\n\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])\n&gt;&gt;&gt; a\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n&gt;&gt;&gt; w, v = LA.eigh(a)\n&gt;&gt;&gt; w; v\narray([0.17157288, 5.82842712])\narray([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n       [ 0.        +0.38268343j,  0.        -0.92387953j]])\n\n\n&gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair\narray([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])\n&gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair\narray([0.+0.j, 0.+0.j])\n\n\n&gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object\n&gt;&gt;&gt; A\nmatrix([[ 1.+0.j, -0.-2.j],\n        [ 0.+2.j,  5.+0.j]])\n&gt;&gt;&gt; w, v = LA.eigh(A)\n&gt;&gt;&gt; w; v\narray([0.17157288, 5.82842712])\nmatrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n        [ 0.        +0.38268343j,  0.        -0.92387953j]])\n\n\n&gt;&gt;&gt; # demonstrate the treatment of the imaginary part of the diagonal\n&gt;&gt;&gt; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n&gt;&gt;&gt; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n&gt;&gt;&gt; # with UPLO='L' this is numerically equivalent to using LA.eig() with:\n&gt;&gt;&gt; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n&gt;&gt;&gt; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n&gt;&gt;&gt; wa, va = LA.eigh(a)\n&gt;&gt;&gt; wb, vb = LA.eig(b)\n&gt;&gt;&gt; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n&gt;&gt;&gt; va; vb\narray([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary\n       [ 0.        +0.89442719j,  0.        -0.4472136j ]])\narray([[ 0.89442719+0.j       , -0.        +0.4472136j],\n       [-0.        +0.4472136j,  0.89442719+0.j       ]])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array", "UPLO{\u2018L\u2019, \u2018U\u2019}, optional", "Returns", "w(\u2026, M) ndarray", "v{(\u2026, M, M) ndarray, (\u2026, M, M) matrix}", "Raises", "LinAlgError"], "returns": "w(\u2026, M) ndarrayThe eigenvalues in ascending order, each repeated according toits multiplicity.v{(\u2026, M, M) ndarray, (\u2026, M, M) matrix}The column v[:, i] is the normalized eigenvector correspondingto the eigenvalue w[i].  Will return a matrix object if a isa matrix object.", "examples": ["; from numpy import linalg as LA\n; a = np.array([[1, -2j], [2j, 5]])\n; a\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n; w, v = LA.eigh(a)\n; w; v\narray([0.17157288, 5.82842712])\narray([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n       [ 0.        +0.38268343j,  0.        -0.92387953j]])\n\n", "; from numpy import linalg as LA\n; a = np.array([[1, -2j], [2j, 5]])\n; a\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n; w, v = LA.eigh(a)\n; w; v\narray([0.17157288, 5.82842712])\narray([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n       [ 0.        +0.38268343j,  0.        -0.92387953j]])\n", "; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair\narray([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])\n; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair\narray([0.+0.j, 0.+0.j])\n\n", "; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair\narray([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])\n; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair\narray([0.+0.j, 0.+0.j])\n", "; A = np.matrix(a) # what happens if input is a matrix object\n; A\nmatrix([[ 1.+0.j, -0.-2.j],\n        [ 0.+2.j,  5.+0.j]])\n; w, v = LA.eigh(A)\n; w; v\narray([0.17157288, 5.82842712])\nmatrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n        [ 0.        +0.38268343j,  0.        -0.92387953j]])\n\n", "; A = np.matrix(a) # what happens if input is a matrix object\n; A\nmatrix([[ 1.+0.j, -0.-2.j],\n        [ 0.+2.j,  5.+0.j]])\n; w, v = LA.eigh(A)\n; w; v\narray([0.17157288, 5.82842712])\nmatrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary\n        [ 0.        +0.38268343j,  0.        -0.92387953j]])\n", "; # demonstrate the treatment of the imaginary part of the diagonal\n; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n; # with UPLO='L' this is numerically equivalent to using LA.eig() with:\n; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n; wa, va = LA.eigh(a)\n; wb, vb = LA.eig(b)\n; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n; va; vb\narray([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary\n       [ 0.        +0.89442719j,  0.        -0.4472136j ]])\narray([[ 0.89442719+0.j       , -0.        +0.4472136j],\n       [-0.        +0.4472136j,  0.89442719+0.j       ]])\n\n", "; # demonstrate the treatment of the imaginary part of the diagonal\n; a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])\n; a\narray([[5.+2.j, 9.-2.j],\n       [0.+2.j, 2.-1.j]])\n; # with UPLO='L' this is numerically equivalent to using LA.eig() with:\n; b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])\n; b\narray([[5.+0.j, 0.-2.j],\n       [0.+2.j, 2.+0.j]])\n; wa, va = LA.eigh(a)\n; wb, vb = LA.eig(b)\n; wa; wb\narray([1., 6.])\narray([6.+0.j, 1.+0.j])\n; va; vb\narray([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary\n       [ 0.        +0.89442719j,  0.        -0.4472136j ]])\narray([[ 0.89442719+0.j       , -0.        +0.4472136j],\n       [-0.        +0.4472136j,  0.89442719+0.j       ]])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.eig", "code": "\nnumpy.linalg.eig(a)[source]\u00b6", "description": "Compute the eigenvalues and right eigenvectors of a square array.\n\nParameters\n\na(\u2026, M, M) arrayMatrices for which the eigenvalues and right eigenvectors will\nbe computed\n\n\n\nReturns\n\nw(\u2026, M) arrayThe eigenvalues, each repeated according to its multiplicity.\nThe eigenvalues are not necessarily ordered. The resulting\narray will be of complex type, unless the imaginary part is\nzero in which case it will be cast to a real type. When a\nis real the resulting eigenvalues will be real (0 imaginary\npart) or occur in conjugate pairs\n\nv(\u2026, M, M) arrayThe normalized (unit \u201clength\u201d) eigenvectors, such that the\ncolumn v[:,i] is the eigenvector corresponding to the\neigenvalue w[i].\n\n\n\nRaises\n\nLinAlgErrorIf the eigenvalue computation does not converge.\n\n\n\n\n\nSee also\n\neigvalseigenvalues of a non-symmetric array.\n\neigheigenvalues and eigenvectors of a real symmetric or complex Hermitian (conjugate symmetric) array.\n\neigvalsheigenvalues of a real symmetric or complex Hermitian (conjugate symmetric) array.\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThis is implemented using the _geev LAPACK routines which compute\nthe eigenvalues and eigenvectors of general square arrays.\nThe number w is an eigenvalue of a if there exists a vector\nv such that dot(a,v) = w * v. Thus, the arrays a, w, and\nv satisfy the equations dot(a[:,:], v[:,i]) = w[i] * v[:,i]\nfor .\nThe array v of eigenvectors may not be of maximum rank, that is, some\nof the columns may be linearly dependent, although round-off error may\nobscure that fact. If the eigenvalues are all different, then theoretically\nthe eigenvectors are linearly independent. Likewise, the (complex-valued)\nmatrix of eigenvectors v is unitary if the matrix a is normal, i.e.,\nif dot(a, a.H) = dot(a.H, a), where a.H denotes the conjugate\ntranspose of a.\nFinally, it is emphasized that v consists of the right (as in\nright-hand side) eigenvectors of a.  A vector y satisfying\ndot(y.T, a) = z * y.T for some number z is called a left\neigenvector of a, and, in general, the left and right eigenvectors\nof a matrix are not necessarily the (perhaps conjugate) transposes\nof each other.\nReferences\nG. Strang, Linear Algebra and Its Applications, 2nd Ed., Orlando, FL,\nAcademic Press, Inc., 1980, Various pp.\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n\n\n(Almost) trivial example with real e-values and e-vectors.\n&gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))\n&gt;&gt;&gt; w; v\narray([1., 2., 3.])\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n\nReal matrix possessing complex e-values and e-vectors; note that the\ne-values are complex conjugates of each other.\n&gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))\n&gt;&gt;&gt; w; v\narray([1.+1.j, 1.-1.j])\narray([[0.70710678+0.j        , 0.70710678-0.j        ],\n       [0.        -0.70710678j, 0.        +0.70710678j]])\n\n\nComplex-valued matrix with real e-values (but complex-valued e-vectors);\nnote that a.conj().T == a, i.e., a is Hermitian.\n&gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])\n&gt;&gt;&gt; w, v = LA.eig(a)\n&gt;&gt;&gt; w; v\narray([2.+0.j, 0.+0.j])\narray([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary\n       [ 0.70710678+0.j        , -0.        +0.70710678j]])\n\n\nBe careful about round-off error!\n&gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])\n&gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9\n&gt;&gt;&gt; w, v = LA.eig(a)\n&gt;&gt;&gt; w; v\narray([1., 1.])\narray([[1., 0.],\n       [0., 1.]])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array", "Returns", "w(\u2026, M) array", "v(\u2026, M, M) array", "Raises", "LinAlgError"], "returns": "w(\u2026, M) arrayThe eigenvalues, each repeated according to its multiplicity.The eigenvalues are not necessarily ordered. The resultingarray will be of complex type, unless the imaginary part iszero in which case it will be cast to a real type. When ais real the resulting eigenvalues will be real (0 imaginarypart) or occur in conjugate pairsv(\u2026, M, M) arrayThe normalized (unit \u201clength\u201d) eigenvectors, such that thecolumn v[:,i] is the eigenvector corresponding to theeigenvalue w[i].", "examples": ["; from numpy import linalg as LA\n\n", "; from numpy import linalg as LA\n", "; w, v = LA.eig(np.diag((1, 2, 3)))\n; w; v\narray([1., 2., 3.])\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\n", "; w, v = LA.eig(np.diag((1, 2, 3)))\n; w; v\narray([1., 2., 3.])\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n", "; w, v = LA.eig(np.array([[1, -1], [1, 1]]))\n; w; v\narray([1.+1.j, 1.-1.j])\narray([[0.70710678+0.j        , 0.70710678-0.j        ],\n       [0.        -0.70710678j, 0.        +0.70710678j]])\n\n", "; w, v = LA.eig(np.array([[1, -1], [1, 1]]))\n; w; v\narray([1.+1.j, 1.-1.j])\narray([[0.70710678+0.j        , 0.70710678-0.j        ],\n       [0.        -0.70710678j, 0.        +0.70710678j]])\n", "; a = np.array([[1, 1j], [-1j, 1]])\n; w, v = LA.eig(a)\n; w; v\narray([2.+0.j, 0.+0.j])\narray([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary\n       [ 0.70710678+0.j        , -0.        +0.70710678j]])\n\n", "; a = np.array([[1, 1j], [-1j, 1]])\n; w, v = LA.eig(a)\n; w; v\narray([2.+0.j, 0.+0.j])\narray([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary\n       [ 0.70710678+0.j        , -0.        +0.70710678j]])\n", "; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])\n; # Theor. e-values are 1 +/- 1e-9\n; w, v = LA.eig(a)\n; w; v\narray([1., 1.])\narray([[1., 0.],\n       [0., 1.]])\n\n", "; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])\n; # Theor. e-values are 1 +/- 1e-9\n; w, v = LA.eig(a)\n; w; v\narray([1., 1.])\narray([[1., 0.],\n       [0., 1.]])\n"]},
{"library": "numpy", "item_id": "numpy.Inf", "code": "\nnumpy.Inf\u00b6", "description": "IEEE 754 floating point representation of (positive) infinity.\nUse inf because Inf, Infinity, PINF and infty are aliases for\ninf. For more details, see inf.\nSee Also\ninf\n", "parameters": [], "returns": [], "examples": ["; np.NINF\n-inf\n; np.log(0)\n-inf\n\n", "; np.NINF\n-inf\n; np.log(0)\n-inf\n", "; np.NZERO\n-0.0\n; np.PZERO\n0.0\n\n", "; np.NZERO\n-0.0\n; np.PZERO\n0.0\n", "; np.isfinite([np.NZERO])\narray([ True])\n; np.isnan([np.NZERO])\narray([False])\n; np.isinf([np.NZERO])\narray([False])\n\n", "; np.isfinite([np.NZERO])\narray([ True])\n; np.isnan([np.NZERO])\narray([False])\n; np.isinf([np.NZERO])\narray([False])\n", "; np.PZERO\n0.0\n; np.NZERO\n-0.0\n\n", "; np.PZERO\n0.0\n; np.NZERO\n-0.0\n", "; np.isfinite([np.PZERO])\narray([ True])\n; np.isnan([np.PZERO])\narray([False])\n; np.isinf([np.PZERO])\narray([False])\n\n", "; np.isfinite([np.PZERO])\narray([ True])\n; np.isnan([np.PZERO])\narray([False])\n; np.isinf([np.PZERO])\narray([False])\n", "; np.inf\ninf\n; np.array([1]) / 0.\narray([ Inf])\n\n", "; np.inf\ninf\n; np.array([1]) / 0.\narray([ Inf])\n", "; np.nan\nnan\n; np.log(-1)\nnan\n; np.log([-1, 1, 2])\narray([        NaN,  0.        ,  0.69314718])\n\n", "; np.nan\nnan\n; np.log(-1)\nnan\n; np.log([-1, 1, 2])\narray([        NaN,  0.        ,  0.69314718])\n", "; newaxis is None\nTrue\n; x = np.arange(3)\n; x\narray([0, 1, 2])\n; x[:, newaxis]\narray([[0],\n[1],\n[2]])\n; x[:, newaxis, newaxis]\narray([[[0]],\n[[1]],\n[[2]]])\n; x[:, newaxis] * x\narray([[0, 0, 0],\n[0, 1, 2],\n[0, 2, 4]])\n\n", "; newaxis is None\nTrue\n; x = np.arange(3)\n; x\narray([0, 1, 2])\n; x[:, newaxis]\narray([[0],\n[1],\n[2]])\n; x[:, newaxis, newaxis]\narray([[[0]],\n[[1]],\n[[2]]])\n; x[:, newaxis] * x\narray([[0, 0, 0],\n[0, 1, 2],\n[0, 2, 4]])\n", "; y = np.arange(3, 6)\n; x[:, newaxis] * y\narray([[ 0,  0,  0],\n[ 3,  4,  5],\n[ 6,  8, 10]])\n\n", "; y = np.arange(3, 6)\n; x[:, newaxis] * y\narray([[ 0,  0,  0],\n[ 3,  4,  5],\n[ 6,  8, 10]])\n", "; x[newaxis, :].shape\n(1, 3)\n; x[newaxis].shape\n(1, 3)\n; x[None].shape\n(1, 3)\n; x[:, newaxis].shape\n(3, 1)\n\n", "; x[newaxis, :].shape\n(1, 3)\n; x[newaxis].shape\n(1, 3)\n; x[None].shape\n(1, 3)\n; x[:, newaxis].shape\n(3, 1)\n"]},
{"library": "numpy", "item_id": "numpy.record.dumps", "code": "\nrecord.dumps()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.ediff1d", "code": "\nnumpy.ma.ediff1d(arr, to_end=None, to_begin=None)[source]\u00b6", "description": "Compute the differences between consecutive elements of an array.\nThis function is the equivalent of numpy.ediff1d that takes masked\nvalues into account, see numpy.ediff1d for details.\n\nSee also\n\nnumpy.ediff1dEquivalent function for ndarrays.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ediff1d", "code": "\nnumpy.ediff1d(ary, to_end=None, to_begin=None)[source]\u00b6", "description": "The differences between consecutive elements of an array.\n\nParameters\n\naryarray_likeIf necessary, will be flattened before the differences are taken.\n\nto_endarray_like, optionalNumber(s) to append at the end of the returned differences.\n\nto_beginarray_like, optionalNumber(s) to prepend at the beginning of the returned differences.\n\n\n\nReturns\n\nediff1dndarrayThe differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].\n\n\n\n\n\nSee also\ndiff, gradient\n\nNotes\nWhen applied to masked arrays, this function drops the mask information\nif the to_begin and/or to_end parameters are used.\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])\n&gt;&gt;&gt; np.ediff1d(x)\narray([ 1,  2,  3, -7])\n\n\n&gt;&gt;&gt; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\narray([-99,   1,   2, ...,  -7,  88,  99])\n\n\nThe returned array is always 1D.\n&gt;&gt;&gt; y = [[1, 2, 4], [1, 6, 24]]\n&gt;&gt;&gt; np.ediff1d(y)\narray([ 1,  2, -3,  5, 18])\n\n\n", "parameters": ["Parameters", "aryarray_like", "to_endarray_like, optional", "to_beginarray_like, optional", "Returns", "ediff1dndarray"], "returns": "ediff1dndarrayThe differences. Loosely, this is ary.flat[1:] - ary.flat[:-1].", "examples": ["; x = np.array([1, 2, 4, 7, 0])\n; np.ediff1d(x)\narray([ 1,  2,  3, -7])\n\n", "; x = np.array([1, 2, 4, 7, 0])\n; np.ediff1d(x)\narray([ 1,  2,  3, -7])\n", "; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\narray([-99,   1,   2, ...,  -7,  88,  99])\n\n", "; np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99]))\narray([-99,   1,   2, ...,  -7,  88,  99])\n", "; y = [[1, 2, 4], [1, 6, 24]]\n; np.ediff1d(y)\narray([ 1,  2, -3,  5, 18])\n\n", "; y = [[1, 2, 4], [1, 6, 24]]\n; np.ediff1d(y)\narray([ 1,  2, -3,  5, 18])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.dumps", "code": "\nndarray.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.dumps", "code": "\nchararray.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.dumps", "code": "\nrecarray.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.dump", "code": "\nndarray.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.dump", "code": "\nmemmap.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.dump", "code": "\nmatrix.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.dump", "code": "\nMaskType.dump()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.dumps", "code": "\nchararray.dumps()\u00b6", "description": "Returns the pickle of the array as a string.\npickle.loads or numpy.loads will convert the string back to an array.\n\nParameters\n\nNone\n\n\n\n", "parameters": ["Parameters", "None"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.dump", "code": "\nrecord.dump()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.dump", "code": "\nMaskedArray.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.dump", "code": "\nrecarray.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.dump", "code": "\nmasked_array.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.dump", "code": "\ngeneric.dump()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.dump", "code": "\nchararray.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.dump", "code": "\nchararray.dump(file)\u00b6", "description": "Dump a pickle of the array to the specified file.\nThe array can be read back with pickle.load or numpy.load.\n\nParameters\n\nfilestr or PathA string naming the dump file.\n\nChanged in version 1.17.0: pathlib.Path objects are now accepted.\n\n\n\n\n\n", "parameters": ["Parameters", "filestr or Path"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.dtypes", "code": "\nnditer.dtypes\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.dtype", "code": "\nproperty MaskedArray.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.dtype", "code": "\nproperty masked_array.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.record.dtype", "code": "\nrecord.dtype\u00b6", "description": "dtype object\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.dtype", "code": "\nmatrix.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.recarray.dtype", "code": "\nrecarray.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.dtype", "code": "\nndarray.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.memmap.dtype", "code": "\nmemmap.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.dtype", "code": "\nMaskType.dtype\u00b6", "description": "get array data-descriptor\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.dtype", "code": "\ngeneric.dtype\u00b6", "description": "get array data-descriptor\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.dtype", "code": "\nchararray.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.dtype", "code": "\nchararray.dtype\u00b6", "description": "Data-type of the array\u2019s elements.\n\nParameters\n\nNone\n\n\nReturns\n\ndnumpy dtype object\n\n\n\n\nSee also\nnumpy.dtype\n\nExamples\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.dtype\ndtype('int32')\n&gt;&gt;&gt; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "dnumpy dtype object"], "returns": "dnumpy dtype object", "examples": ["; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n\n", "; x\narray([[0, 1],\n       [2, 3]])\n; x.dtype\ndtype('int32')\n; type(x.dtype)\n&lt;type 'numpy.dtype'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.dtype", "code": "\nclass numpy.dtype(obj, align=False, copy=False)[source]\u00b6", "description": "Create a data type object.\nA numpy array is homogeneous, and contains elements described by a\ndtype object. A dtype object can be constructed from different\ncombinations of fundamental numeric types.\n\nParameters\n\nobjObject to be converted to a data type object.\n\nalignbool, optionalAdd padding to the fields to match what a C compiler would output\nfor a similar C-struct. Can be True only if obj is a dictionary\nor a comma-separated string. If a struct dtype is being created,\nthis also sets a sticky alignment flag isalignedstruct.\n\ncopybool, optionalMake a new copy of the data-type object. If False, the result\nmay just be a reference to a built-in data-type object.\n\n\n\n\n\nSee also\nresult_type\n\nExamples\nUsing array-scalar type:\n&gt;&gt;&gt; np.dtype(np.int16)\ndtype('int16')\n\n\nStructured type, one field name \u2018f1\u2019, containing int16:\n&gt;&gt;&gt; np.dtype([('f1', np.int16)])\ndtype([('f1', '&lt;i2')])\n\n\nStructured type, one field named \u2018f1\u2019, in itself containing a structured\ntype with one field:\n&gt;&gt;&gt; np.dtype([('f1', [('f1', np.int16)])])\ndtype([('f1', [('f1', '&lt;i2')])])\n\n\nStructured type, two fields: the first field contains an unsigned int, the\nsecond an int32:\n&gt;&gt;&gt; np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '&lt;u8'), ('f2', '&lt;i4')])\n\n\nUsing array-protocol type strings:\n&gt;&gt;&gt; np.dtype([('a','f8'),('b','S10')])\ndtype([('a', '&lt;f8'), ('b', 'S10')])\n\n\nUsing comma-separated field formats.  The shape is (2,3):\n&gt;&gt;&gt; np.dtype(\"i4, (2,3)f8\")\ndtype([('f0', '&lt;i4'), ('f1', '&lt;f8', (2, 3))])\n\n\nUsing tuples.  int is a fixed type, 3 the field\u2019s shape.  void\nis a flexible type, here of size 10:\n&gt;&gt;&gt; np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\ndtype([('hello', '&lt;i8', (3,)), ('world', 'V10')])\n\n\nSubdivide int16 into 2 int8\u2019s, called x and y.  0 and 1 are\nthe offsets in bytes:\n&gt;&gt;&gt; np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\ndtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\n\n\nUsing dictionaries.  Two fields named \u2018gender\u2019 and \u2018age\u2019:\n&gt;&gt;&gt; np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\ndtype([('gender', 'S1'), ('age', 'u1')])\n\n\nOffsets in bytes, here 0 and 25:\n&gt;&gt;&gt; np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\ndtype([('surname', 'S25'), ('age', 'u1')])\n\n\n\nAttributes\n\nalignmentThe required alignment (bytes) of this data-type according to the compiler.\n\nbaseReturns dtype for the base element of the subarrays, regardless of their dimension or shape.\n\nbyteorderA character indicating the byte-order of this data-type object.\n\ncharA unique character code for each of the 21 different built-in types.\n\ndescr__array_interface__ description of the data-type.\n\nfieldsDictionary of named fields defined for this data type, or None.\n\nflagsBit-flags describing how this data type is to be interpreted.\n\nhasobjectBoolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.\n\nisalignedstructBoolean indicating whether the dtype is a struct which maintains field alignment.\n\nisbuiltinInteger indicating how this dtype relates to the built-in dtypes.\n\nisnativeBoolean indicating whether the byte order of this dtype is native to the platform.\n\nitemsizeThe element size of this data-type object.\n\nkindA character code (one of \u2018biufcmMOSUV\u2019) identifying the general kind of data.\n\nmetadata\nnameA bit-width name for this data-type.\n\nnamesOrdered list of field names, or None if there are no fields.\n\nndimNumber of dimensions of the sub-array if this data type describes a sub-array, and 0 otherwise.\n\nnumA unique number for each of the 21 different built-in types.\n\nshapeShape tuple of the sub-array if this data type describes a sub-array, and () otherwise.\n\nstrThe array-protocol typestring of this data-type object.\n\nsubdtypeTuple (item_dtype, shape) if this dtype describes a sub-array, and None otherwise.\n\ntypeThe type object used to instantiate a scalar of this data-type.\n\n\n\n\nMethods\n\n\n\n\n\n\nnewbyteorder([new_order])\nReturn a new dtype with a different byte order.\n\n\n\n", "parameters": ["Parameters", "obj", "alignbool, optional", "copybool, optional", "Attributes", "alignment", "base", "byteorder", "char", "descr", "fields", "flags", "hasobject", "isalignedstruct", "isbuiltin", "isnative", "itemsize", "kind", "metadata", "name", "names", "ndim", "num", "shape", "str", "subdtype", "type"], "returns": [], "examples": ["; np.dtype(np.int16)\ndtype('int16')\n\n", "; np.dtype(np.int16)\ndtype('int16')\n", "; np.dtype([('f1', np.int16)])\ndtype([('f1', '&lt;i2')])\n\n", "; np.dtype([('f1', np.int16)])\ndtype([('f1', '&lt;i2')])\n", "; np.dtype([('f1', [('f1', np.int16)])])\ndtype([('f1', [('f1', '&lt;i2')])])\n\n", "; np.dtype([('f1', [('f1', np.int16)])])\ndtype([('f1', [('f1', '&lt;i2')])])\n", "; np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '&lt;u8'), ('f2', '&lt;i4')])\n\n", "; np.dtype([('f1', np.uint64), ('f2', np.int32)])\ndtype([('f1', '&lt;u8'), ('f2', '&lt;i4')])\n", "; np.dtype([('a','f8'),('b','S10')])\ndtype([('a', '&lt;f8'), ('b', 'S10')])\n\n", "; np.dtype([('a','f8'),('b','S10')])\ndtype([('a', '&lt;f8'), ('b', 'S10')])\n", "; np.dtype(\"i4, (2,3)f8\")\ndtype([('f0', '&lt;i4'), ('f1', '&lt;f8', (2, 3))])\n\n", "; np.dtype(\"i4, (2,3)f8\")\ndtype([('f0', '&lt;i4'), ('f1', '&lt;f8', (2, 3))])\n", "; np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\ndtype([('hello', '&lt;i8', (3,)), ('world', 'V10')])\n\n", "; np.dtype([('hello',(np.int64,3)),('world',np.void,10)])\ndtype([('hello', '&lt;i8', (3,)), ('world', 'V10')])\n", "; np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\ndtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\n\n", "; np.dtype((np.int16, {'x':(np.int8,0), 'y':(np.int8,1)}))\ndtype((numpy.int16, [('x', 'i1'), ('y', 'i1')]))\n", "; np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\ndtype([('gender', 'S1'), ('age', 'u1')])\n\n", "; np.dtype({'names':['gender','age'], 'formats':['S1',np.uint8]})\ndtype([('gender', 'S1'), ('age', 'u1')])\n", "; np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\ndtype([('surname', 'S25'), ('age', 'u1')])\n\n", "; np.dtype({'surname':('S25',0),'age':(np.uint8,25)})\ndtype([('surname', 'S25'), ('age', 'u1')])\n"]},
{"library": "numpy", "item_id": "numpy.ma.dstack", "code": "\nnumpy.ma.dstack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nStack arrays in sequence depth wise (along third axis).\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape (M,N) have been reshaped to (M,N,1) and 1-D arrays of shape\n(N,) have been reshaped to (1,N,1). Rebuilds arrays divided by\ndsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\n\nParameters\n\ntupsequence of arraysThe arrays must have the same shape along all but the third axis.\n1-D or 2-D arrays must have the same shape.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays, will be at least 3-D.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nvstackStack along first axis.\n\nhstackStack along second axis.\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\ndsplitSplit array along third axis.\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n\n&gt;&gt;&gt; a = np.array([[1],[2],[3]])\n&gt;&gt;&gt; b = np.array([[2],[3],[4]])\n&gt;&gt;&gt; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n\n\n", "parameters": ["Parameters", "tupsequence of arrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays, will be at least 3-D.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n", "; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n\n", "; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n"]},
{"library": "numpy", "item_id": "numpy.dsplit", "code": "\nnumpy.dsplit(ary, indices_or_sections)[source]\u00b6", "description": "Split array into multiple sub-arrays along the 3rd axis (depth).\nPlease refer to the split documentation.  dsplit is equivalent\nto split with axis=2, the array is always split along the third\naxis provided the array dimension is greater than or equal to 3.\n\nSee also\n\nsplitSplit an array into multiple sub-arrays of equal size.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(16.0).reshape(2, 2, 4)\n&gt;&gt;&gt; x\narray([[[ 0.,   1.,   2.,   3.],\n        [ 4.,   5.,   6.,   7.]],\n       [[ 8.,   9.,  10.,  11.],\n        [12.,  13.,  14.,  15.]]])\n&gt;&gt;&gt; np.dsplit(x, 2)\n[array([[[ 0.,  1.],\n        [ 4.,  5.]],\n       [[ 8.,  9.],\n        [12., 13.]]]), array([[[ 2.,  3.],\n        [ 6.,  7.]],\n       [[10., 11.],\n        [14., 15.]]])]\n&gt;&gt;&gt; np.dsplit(x, np.array([3, 6]))\n[array([[[ 0.,   1.,   2.],\n        [ 4.,   5.,   6.]],\n       [[ 8.,   9.,  10.],\n        [12.,  13.,  14.]]]),\n array([[[ 3.],\n        [ 7.]],\n       [[11.],\n        [15.]]]),\narray([], shape=(2, 2, 0), dtype=float64)]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(16.0).reshape(2, 2, 4)\n; x\narray([[[ 0.,   1.,   2.,   3.],\n        [ 4.,   5.,   6.,   7.]],\n       [[ 8.,   9.,  10.,  11.],\n        [12.,  13.,  14.,  15.]]])\n; np.dsplit(x, 2)\n[array([[[ 0.,  1.],\n        [ 4.,  5.]],\n       [[ 8.,  9.],\n        [12., 13.]]]), array([[[ 2.,  3.],\n        [ 6.,  7.]],\n       [[10., 11.],\n        [14., 15.]]])]\n; np.dsplit(x, np.array([3, 6]))\n[array([[[ 0.,   1.,   2.],\n        [ 4.,   5.,   6.]],\n       [[ 8.,   9.,  10.],\n        [12.,  13.,  14.]]]),\n array([[[ 3.],\n        [ 7.]],\n       [[11.],\n        [15.]]]),\narray([], shape=(2, 2, 0), dtype=float64)]\n\n", "; x = np.arange(16.0).reshape(2, 2, 4)\n; x\narray([[[ 0.,   1.,   2.,   3.],\n        [ 4.,   5.,   6.,   7.]],\n       [[ 8.,   9.,  10.,  11.],\n        [12.,  13.,  14.,  15.]]])\n; np.dsplit(x, 2)\n[array([[[ 0.,  1.],\n        [ 4.,  5.]],\n       [[ 8.,  9.],\n        [12., 13.]]]), array([[[ 2.,  3.],\n        [ 6.,  7.]],\n       [[10., 11.],\n        [14., 15.]]])]\n; np.dsplit(x, np.array([3, 6]))\n[array([[[ 0.,   1.,   2.],\n        [ 4.,   5.,   6.]],\n       [[ 8.,   9.,  10.],\n        [12.,  13.,  14.]]]),\n array([[[ 3.],\n        [ 7.]],\n       [[11.],\n        [15.]]]),\narray([], shape=(2, 2, 0), dtype=float64)]\n"]},
{"library": "numpy", "item_id": "numpy.recarray.dot", "code": "\nrecarray.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.dot", "code": "\nmatrix.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.dstack", "code": "\nnumpy.dstack(tup)[source]\u00b6", "description": "Stack arrays in sequence depth wise (along third axis).\nThis is equivalent to concatenation along the third axis after 2-D arrays\nof shape (M,N) have been reshaped to (M,N,1) and 1-D arrays of shape\n(N,) have been reshaped to (1,N,1). Rebuilds arrays divided by\ndsplit.\nThis function makes most sense for arrays with up to 3 dimensions. For\ninstance, for pixel-data with a height (first axis), width (second axis),\nand r/g/b channels (third axis). The functions concatenate, stack and\nblock provide more general stacking and concatenation operations.\n\nParameters\n\ntupsequence of arraysThe arrays must have the same shape along all but the third axis.\n1-D or 2-D arrays must have the same shape.\n\n\n\nReturns\n\nstackedndarrayThe array formed by stacking the given arrays, will be at least 3-D.\n\n\n\n\n\nSee also\n\nstackJoin a sequence of arrays along a new axis.\n\nvstackStack along first axis.\n\nhstackStack along second axis.\n\nconcatenateJoin a sequence of arrays along an existing axis.\n\ndsplitSplit array along third axis.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n\n&gt;&gt;&gt; a = np.array([[1],[2],[3]])\n&gt;&gt;&gt; b = np.array([[2],[3],[4]])\n&gt;&gt;&gt; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n\n\n", "parameters": ["Parameters", "tupsequence of arrays", "Returns", "stackedndarray"], "returns": "stackedndarrayThe array formed by stacking the given arrays, will be at least 3-D.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.dstack((a,b))\narray([[[1, 2],\n        [2, 3],\n        [3, 4]]])\n", "; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n\n", "; a = np.array([[1],[2],[3]])\n; b = np.array([[2],[3],[4]])\n; np.dstack((a,b))\narray([[[1, 2]],\n       [[2, 3]],\n       [[3, 4]]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.dot", "code": "\nndarray.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.dot", "code": "\nmemmap.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.dot", "code": "\nmasked_array.dot(b, out=None)[source]\u00b6", "description": "Masked dot product of two arrays. Note that out and strict are\nlocated in different positions than in ma.dot. In order to\nmaintain compatibility with the functional version, it is\nrecommended that the optional arguments be treated as keyword only.\nAt some point that may be mandatory.\n\nNew in version 1.10.0.\n\n\nParameters\n\nbmasked_array_likeInputs array.\n\noutmasked_array, optionalOutput argument. This must have the exact kind that would be\nreturned if it was not used. In particular, it must have the\nright type, must be C-contiguous, and its dtype must be the\ndtype that would be returned for ma.dot(a,b). This is a\nperformance feature. Therefore, if these conditions are not\nmet, an exception is raised, instead of attempting to be\nflexible.\n\nstrictbool, optionalWhether masked data are propagated (True) or set to 0 (False)\nfor the computation. Default is False.  Propagating the mask\nmeans that if a masked value appears in a row or column, the\nwhole row or column is considered masked.\n\nNew in version 1.10.2.\n\n\n\n\n\n\nSee also\n\nnumpy.ma.dotequivalent function\n\n\n\n", "parameters": ["Parameters", "bmasked_array_like", "outmasked_array, optional", "strictbool, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.dot", "code": "\nchararray.dot(b, out=None)\u00b6", "description": "Dot product of two arrays.\nRefer to numpy.dot for full documentation.\n\nSee also\n\nnumpy.dotequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; a = np.eye(2)\n&gt;&gt;&gt; b = np.ones((2, 2)) * 2\n&gt;&gt;&gt; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n\nThis array method can be conveniently chained:\n&gt;&gt;&gt; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n\n", "parameters": [], "returns": [], "examples": ["; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n\n", "; a = np.eye(2)\n; b = np.ones((2, 2)) * 2\n; a.dot(b)\narray([[2.,  2.],\n       [2.,  2.]])\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n\n", "; a.dot(b).dot(b)\narray([[8.,  8.],\n       [8.,  8.]])\n"]},
{"library": "numpy", "item_id": "numpy.dot", "code": "\nnumpy.dot(a, b, out=None)\u00b6", "description": "Dot product of two arrays. Specifically,\n\nIf both a and b are 1-D arrays, it is inner product of vectors\n(without complex conjugation).\nIf both a and b are 2-D arrays, it is matrix multiplication,\nbut using matmul or a @ b is preferred.\nIf either a or b is 0-D (scalar), it is equivalent to multiply\nand using numpy.multiply(a, b) or a * b is preferred.\nIf a is an N-D array and b is a 1-D array, it is a sum product over\nthe last axis of a and b.\nIf a is an N-D array and b is an M-D array (where M&gt;=2), it is a\nsum product over the last axis of a and the second-to-last axis of b:\ndot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])\n\n\n\n\n\nParameters\n\naarray_likeFirst argument.\n\nbarray_likeSecond argument.\n\noutndarray, optionalOutput argument. This must have the exact kind that would be returned\nif it was not used. In particular, it must have the right type, must be\nC-contiguous, and its dtype must be the dtype that would be returned\nfor dot(a,b). This is a performance feature. Therefore, if these\nconditions are not met, an exception is raised, instead of attempting\nto be flexible.\n\n\n\nReturns\n\noutputndarrayReturns the dot product of a and b.  If a and b are both\nscalars or both 1-D arrays then a scalar is returned; otherwise\nan array is returned.\nIf out is given, then it is returned.\n\n\n\nRaises\n\nValueErrorIf the last dimension of a is not the same size as\nthe second-to-last dimension of b.\n\n\n\n\n\nSee also\n\nvdotComplex-conjugating dot product.\n\ntensordotSum products over arbitrary axes.\n\neinsumEinstein summation convention.\n\nmatmul\u2018@\u2019 operator as method with out parameter.\n\n\n\nExamples\n&gt;&gt;&gt; np.dot(3, 4)\n12\n\n\nNeither argument is complex-conjugated:\n&gt;&gt;&gt; np.dot([2j, 3j], [2j, 3j])\n(-13+0j)\n\n\nFor 2-D arrays it is the matrix product:\n&gt;&gt;&gt; a = [[1, 0], [0, 1]]\n&gt;&gt;&gt; b = [[4, 1], [2, 2]]\n&gt;&gt;&gt; np.dot(a, b)\narray([[4, 1],\n       [2, 2]])\n\n\n&gt;&gt;&gt; a = np.arange(3*4*5*6).reshape((3,4,5,6))\n&gt;&gt;&gt; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n&gt;&gt;&gt; np.dot(a, b)[2,3,2,1,2,2]\n499128\n&gt;&gt;&gt; sum(a[2,3,2,:] * b[1,2,:,2])\n499128\n\n\n", "parameters": ["Parameters", "aarray_like", "barray_like", "outndarray, optional", "Returns", "outputndarray", "Raises", "ValueError"], "returns": "outputndarrayReturns the dot product of a and b.  If a and b are bothscalars or both 1-D arrays then a scalar is returned; otherwisean array is returned.If out is given, then it is returned.", "examples": ["; np.dot(3, 4)\n12\n\n", "; np.dot(3, 4)\n12\n", "; np.dot([2j, 3j], [2j, 3j])\n(-13+0j)\n\n", "; np.dot([2j, 3j], [2j, 3j])\n(-13+0j)\n", "; a = [[1, 0], [0, 1]]\n; b = [[4, 1], [2, 2]]\n; np.dot(a, b)\narray([[4, 1],\n       [2, 2]])\n\n", "; a = [[1, 0], [0, 1]]\n; b = [[4, 1], [2, 2]]\n; np.dot(a, b)\narray([[4, 1],\n       [2, 2]])\n", "; a = np.arange(3*4*5*6).reshape((3,4,5,6))\n; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n; np.dot(a, b)[2,3,2,1,2,2]\n499128\n; sum(a[2,3,2,:] * b[1,2,:,2])\n499128\n\n", "; a = np.arange(3*4*5*6).reshape((3,4,5,6))\n; b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))\n; np.dot(a, b)[2,3,2,1,2,2]\n499128\n; sum(a[2,3,2,:] * b[1,2,:,2])\n499128\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.domain", "code": "\nPolynomial.domain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.domain", "code": "\nLegendre.domain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.dot", "code": "\nnumpy.ma.dot(a, b, strict=False, out=None)[source]\u00b6", "description": "Return the dot product of two arrays.\nThis function is the equivalent of numpy.dot that takes masked values\ninto account. Note that strict and out are in different position\nthan in the method version. In order to maintain compatibility with the\ncorresponding method, it is recommended that the optional arguments be\ntreated as keyword only.  At some point that may be mandatory.\n\nNote\nWorks only with 2-D arrays at the moment.\n\n\nParameters\n\na, bmasked_array_likeInputs arrays.\n\nstrictbool, optionalWhether masked data are propagated (True) or set to 0 (False) for\nthe computation. Default is False.  Propagating the mask means that\nif a masked value appears in a row or column, the whole row or\ncolumn is considered masked.\n\noutmasked_array, optionalOutput argument. This must have the exact kind that would be returned\nif it was not used. In particular, it must have the right type, must be\nC-contiguous, and its dtype must be the dtype that would be returned\nfor dot(a,b). This is a performance feature. Therefore, if these\nconditions are not met, an exception is raised, instead of attempting\nto be flexible.\n\nNew in version 1.10.2.\n\n\n\n\n\n\nSee also\n\nnumpy.dotEquivalent function for ndarrays.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n&gt;&gt;&gt; b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n&gt;&gt;&gt; np.ma.dot(a, b)\nmasked_array(\n  data=[[21, 26],\n        [45, 64]],\n  mask=[[False, False],\n        [False, False]],\n  fill_value=999999)\n&gt;&gt;&gt; np.ma.dot(a, b, strict=True)\nmasked_array(\n  data=[[--, --],\n        [--, 64]],\n  mask=[[ True,  True],\n        [ True, False]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "a, bmasked_array_like", "strictbool, optional", "outmasked_array, optional"], "returns": [], "examples": ["; a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n; b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n; np.ma.dot(a, b)\nmasked_array(\n  data=[[21, 26],\n        [45, 64]],\n  mask=[[False, False],\n        [False, False]],\n  fill_value=999999)\n; np.ma.dot(a, b, strict=True)\nmasked_array(\n  data=[[--, --],\n        [--, 64]],\n  mask=[[ True,  True],\n        [ True, False]],\n  fill_value=999999)\n\n", "; a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])\n; b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])\n; np.ma.dot(a, b)\nmasked_array(\n  data=[[21, 26],\n        [45, 64]],\n  mask=[[False, False],\n        [False, False]],\n  fill_value=999999)\n; np.ma.dot(a, b, strict=True)\nmasked_array(\n  data=[[--, --],\n        [--, 64]],\n  mask=[[ True,  True],\n        [ True, False]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.domain", "code": "\nLaguerre.domain = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.domain", "code": "\nHermiteE.domain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.domain", "code": "\nHermite.domain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.domain", "code": "\nChebyshev.domain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.divmod", "code": "\nnumpy.divmod(x1, x2, [out1, out2, ]/, [out=(None, None), ]*, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'divmod'&gt;\u00b6", "description": "Return element-wise quotient and remainder simultaneously.\n\nNew in version 1.13.0.\n\nnp.divmod(x, y) is equivalent to (x // y, x % y), but faster\nbecause it avoids redundant work. It is used to implement the Python\nbuilt-in function divmod on NumPy arrays.\n\nParameters\n\nx1array_likeDividend array.\n\nx2array_likeDivisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nout1ndarrayElement-wise quotient resulting from floor division.\nThis is a scalar if both x1 and x2 are scalars.\n\nout2ndarrayElement-wise remainder from floor division.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\n\nfloor_divideEquivalent to Python\u2019s // operator.\n\nremainderEquivalent to Python\u2019s % operator.\n\nmodfEquivalent to divmod(x, 1) for positive x with the return values switched.\n\n\n\nExamples\n&gt;&gt;&gt; np.divmod(np.arange(5), 3)\n(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "out1ndarray", "out2ndarray"], "returns": "out1ndarrayElement-wise quotient resulting from floor division.This is a scalar if both x1 and x2 are scalars.out2ndarrayElement-wise remainder from floor division.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.divmod(np.arange(5), 3)\n(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))\n\n", "; np.divmod(np.arange(5), 3)\n(array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))\n"]},
{"library": "numpy", "item_id": "numpy.divide", "code": "\nnumpy.divide(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'true_divide'&gt;\u00b6", "description": "Returns a true division of the inputs, element-wise.\nInstead of the Python traditional \u2018floor division\u2019, this returns a true\ndivision.  True division adjusts the output type to present the best\nanswer, regardless of input types.\n\nParameters\n\nx1array_likeDividend array.\n\nx2array_likeDivisor array. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\nThe floor division operator // was added in Python 2.2 making\n// and / equivalent operators.  The default floor division\noperation of / can be replaced by true division with from\n__future__ import division.\nIn Python 3.0, // is the floor division operator and / the\ntrue division operator.  The true_divide(x1, x2) function is\nequivalent to true division in Python.\nExamples\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n\n&gt;&gt;&gt; x//4\narray([0, 0, 0, 0, 1])\n\n\n&gt;&gt;&gt; from __future__ import division\n&gt;&gt;&gt; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n&gt;&gt;&gt; x//4\narray([0, 0, 0, 0, 1])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThis is a scalar if both x1 and x2 are scalars.", "examples": ["; x = np.arange(5)\n; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n\n", "; x = np.arange(5)\n; np.true_divide(x, 4)\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n", "; x//4\narray([0, 0, 0, 0, 1])\n\n", "; x//4\narray([0, 0, 0, 0, 1])\n", "; from __future__ import division\n; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n; x//4\narray([0, 0, 0, 0, 1])\n\n", "; from __future__ import division\n; x/4\narray([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ])\n; x//4\narray([0, 0, 0, 0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.disp", "code": "\nnumpy.disp(mesg, device=None, linefeed=True)[source]\u00b6", "description": "Display a message on a device.\n\nParameters\n\nmesgstrMessage to display.\n\ndeviceobjectDevice to write message. If None, defaults to sys.stdout which is\nvery similar to print. device needs to have write() and\nflush() methods.\n\nlinefeedbool, optionalOption whether to print a line feed or not. Defaults to True.\n\n\n\nRaises\n\nAttributeErrorIf device does not have a write() or flush() method.\n\n\n\n\nExamples\nBesides sys.stdout, a file-like object can also be used as it has\nboth required methods:\n&gt;&gt;&gt; from io import StringIO\n&gt;&gt;&gt; buf = StringIO()\n&gt;&gt;&gt; np.disp(u'\"Display\" in a file', device=buf)\n&gt;&gt;&gt; buf.getvalue()\n'\"Display\" in a file\\n'\n\n\n", "parameters": ["Parameters", "mesgstr", "deviceobject", "linefeedbool, optional", "Raises", "AttributeError"], "returns": [], "examples": ["; from io import StringIO\n; buf = StringIO()\n; np.disp(u'\"Display\" in a file', device=buf)\n; buf.getvalue()\n'\"Display\" in a file\\n'\n\n", "; from io import StringIO\n; buf = StringIO()\n; np.disp(u'\"Display\" in a file', device=buf)\n; buf.getvalue()\n'\"Display\" in a file\\n'\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.dirichlet", "code": "\nRandomState.dirichlet(alpha, size=None)\u00b6", "description": "Draw samples from the Dirichlet distribution.\nDraw size samples of dimension k from a Dirichlet distribution. A\nDirichlet-distributed random variable can be seen as a multivariate\ngeneralization of a Beta distribution. The Dirichlet distribution\nis a conjugate prior of a multinomial distribution in Bayesian\ninference.\n\nNote\nNew code should use the dirichlet method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nalphasequence of floats, length kParameter of the distribution (length k for sample of\nlength k).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n), then\nm * n * k samples are drawn.  Default is None, in which case a\nvector of length k is returned.\n\n\n\nReturns\n\nsamplesndarray,The drawn samples, of shape (size, k).\n\n\n\nRaises\n\nValueErrorIf any value in alpha is less than or equal to zero\n\n\n\n\n\nSee also\n\nGenerator.dirichletwhich should be used for new code.\n\n\n\nNotes\nThe Dirichlet distribution is a distribution over vectors\n that fulfil the conditions  and\n.\nThe probability density function  of a\nDirichlet-distributed random vector  is\nproportional to\n\n\nwhere  is a vector containing the positive\nconcentration parameters.\nThe method uses the following property for computation: let \nbe a random vector which has components that follow a standard gamma\ndistribution, then \nis Dirichlet-distributed\nReferences\n\n1\nDavid McKay, \u201cInformation Theory, Inference and Learning\nAlgorithms,\u201d chapter 23,\nhttp://www.inference.org.uk/mackay/itila/\n\n2\nWikipedia, \u201cDirichlet distribution\u201d,\nhttps://en.wikipedia.org/wiki/Dirichlet_distribution\n\n\nExamples\nTaking an example cited in Wikipedia, this distribution can be used if\none wanted to cut strings (each of initial length 1.0) into K pieces\nwith different lengths, where each piece had, on average, a designated\naverage length, but allowing some variation in the relative sizes of\nthe pieces.\n&gt;&gt;&gt; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.barh(range(20), s[0])\n&gt;&gt;&gt; plt.barh(range(20), s[1], left=s[0], color='g')\n&gt;&gt;&gt; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n&gt;&gt;&gt; plt.title(\"Lengths of Strings\")\n\n\n\n\n\n", "parameters": ["Parameters", "alphasequence of floats, length k", "sizeint or tuple of ints, optional", "Returns", "samplesndarray,", "Raises", "ValueError"], "returns": "samplesndarray,The drawn samples, of shape (size, k).", "examples": ["; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n", "; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.dirichlet", "code": "\nGenerator.dirichlet(alpha, size=None)\u00b6", "description": "Draw samples from the Dirichlet distribution.\nDraw size samples of dimension k from a Dirichlet distribution. A\nDirichlet-distributed random variable can be seen as a multivariate\ngeneralization of a Beta distribution. The Dirichlet distribution\nis a conjugate prior of a multinomial distribution in Bayesian\ninference.\n\nParameters\n\nalphasequence of floats, length kParameter of the distribution (length k for sample of\nlength k).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n), then\nm * n * k samples are drawn.  Default is None, in which case a\nvector of length k is returned.\n\n\n\nReturns\n\nsamplesndarray,The drawn samples, of shape (size, k).\n\n\n\nRaises\n\nValueErrorIf any value in alpha is less than or equal to zero\n\n\n\n\nNotes\nThe Dirichlet distribution is a distribution over vectors\n that fulfil the conditions  and\n.\nThe probability density function  of a\nDirichlet-distributed random vector  is\nproportional to\n\n\nwhere  is a vector containing the positive\nconcentration parameters.\nThe method uses the following property for computation: let \nbe a random vector which has components that follow a standard gamma\ndistribution, then \nis Dirichlet-distributed\nReferences\n\n1\nDavid McKay, \u201cInformation Theory, Inference and Learning\nAlgorithms,\u201d chapter 23,\nhttp://www.inference.org.uk/mackay/itila/\n\n2\nWikipedia, \u201cDirichlet distribution\u201d,\nhttps://en.wikipedia.org/wiki/Dirichlet_distribution\n\n\nExamples\nTaking an example cited in Wikipedia, this distribution can be used if\none wanted to cut strings (each of initial length 1.0) into K pieces\nwith different lengths, where each piece had, on average, a designated\naverage length, but allowing some variation in the relative sizes of\nthe pieces.\n&gt;&gt;&gt; s = np.random.default_rng().dirichlet((10, 5, 3), 20).transpose()\n\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.barh(range(20), s[0])\n&gt;&gt;&gt; plt.barh(range(20), s[1], left=s[0], color='g')\n&gt;&gt;&gt; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n&gt;&gt;&gt; plt.title(\"Lengths of Strings\")\n\n\n\n\n\n", "parameters": ["Parameters", "alphasequence of floats, length k", "sizeint or tuple of ints, optional", "Returns", "samplesndarray,", "Raises", "ValueError"], "returns": "samplesndarray,The drawn samples, of shape (size, k).", "examples": ["; s = np.random.default_rng().dirichlet((10, 5, 3), 20).transpose()\n\n", "; s = np.random.default_rng().dirichlet((10, 5, 3), 20).transpose()\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n"]},
{"library": "numpy", "item_id": "numpy.random.dirichlet", "code": "\nnumpy.random.dirichlet(alpha, size=None)\u00b6", "description": "Draw samples from the Dirichlet distribution.\nDraw size samples of dimension k from a Dirichlet distribution. A\nDirichlet-distributed random variable can be seen as a multivariate\ngeneralization of a Beta distribution. The Dirichlet distribution\nis a conjugate prior of a multinomial distribution in Bayesian\ninference.\n\nNote\nNew code should use the dirichlet method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nalphasequence of floats, length kParameter of the distribution (length k for sample of\nlength k).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n), then\nm * n * k samples are drawn.  Default is None, in which case a\nvector of length k is returned.\n\n\n\nReturns\n\nsamplesndarray,The drawn samples, of shape (size, k).\n\n\n\nRaises\n\nValueErrorIf any value in alpha is less than or equal to zero\n\n\n\n\n\nSee also\n\nGenerator.dirichletwhich should be used for new code.\n\n\n\nNotes\nThe Dirichlet distribution is a distribution over vectors\n that fulfil the conditions  and\n.\nThe probability density function  of a\nDirichlet-distributed random vector  is\nproportional to\n\n\nwhere  is a vector containing the positive\nconcentration parameters.\nThe method uses the following property for computation: let \nbe a random vector which has components that follow a standard gamma\ndistribution, then \nis Dirichlet-distributed\nReferences\n\n1\nDavid McKay, \u201cInformation Theory, Inference and Learning\nAlgorithms,\u201d chapter 23,\nhttp://www.inference.org.uk/mackay/itila/\n\n2\nWikipedia, \u201cDirichlet distribution\u201d,\nhttps://en.wikipedia.org/wiki/Dirichlet_distribution\n\n\nExamples\nTaking an example cited in Wikipedia, this distribution can be used if\none wanted to cut strings (each of initial length 1.0) into K pieces\nwith different lengths, where each piece had, on average, a designated\naverage length, but allowing some variation in the relative sizes of\nthe pieces.\n&gt;&gt;&gt; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; plt.barh(range(20), s[0])\n&gt;&gt;&gt; plt.barh(range(20), s[1], left=s[0], color='g')\n&gt;&gt;&gt; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n&gt;&gt;&gt; plt.title(\"Lengths of Strings\")\n\n\n\n\n\n", "parameters": ["Parameters", "alphasequence of floats, length k", "sizeint or tuple of ints, optional", "Returns", "samplesndarray,", "Raises", "ValueError"], "returns": "samplesndarray,The drawn samples, of shape (size, k).", "examples": ["; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n\n", "; s = np.random.dirichlet((10, 5, 3), 20).transpose()\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n\n", "; import matplotlib.pyplot as plt\n; plt.barh(range(20), s[0])\n; plt.barh(range(20), s[1], left=s[0], color='g')\n; plt.barh(range(20), s[2], left=s[0]+s[1], color='r')\n; plt.title(\"Lengths of Strings\")\n"]},
{"library": "numpy", "item_id": "numpy.diff", "code": "\nnumpy.diff(a, n=1, axis=-1, prepend=&lt;no value&gt;, append=&lt;no value&gt;)[source]\u00b6", "description": "Calculate the n-th discrete difference along the given axis.\nThe first difference is given by out[i] = a[i+1] - a[i] along\nthe given axis, higher differences are calculated by using diff\nrecursively.\n\nParameters\n\naarray_likeInput array\n\nnint, optionalThe number of times values are differenced. If zero, the input\nis returned as-is.\n\naxisint, optionalThe axis along which the difference is taken, default is the\nlast axis.\n\nprepend, appendarray_like, optionalValues to prepend or append to a along axis prior to\nperforming the difference.  Scalar values are expanded to\narrays with length 1 in the direction of axis and the shape\nof the input array in along all other axes.  Otherwise the\ndimension and shape must match a except along axis.\n\nNew in version 1.16.0.\n\n\n\n\nReturns\n\ndiffndarrayThe n-th differences. The shape of the output is the same as a\nexcept along axis where the dimension is smaller by n. The\ntype of the output is the same as the type of the difference\nbetween any two elements of a. This is the same as the type of\na in most cases. A notable exception is datetime64, which\nresults in a timedelta64 output array.\n\n\n\n\n\nSee also\ngradient, ediff1d, cumsum\n\nNotes\nType is preserved for boolean arrays, so the result will contain\nFalse when consecutive elements are the same and True when they\ndiffer.\nFor unsigned integer arrays, the results will also be unsigned. This\nshould not be surprising, as the result is consistent with\ncalculating the difference directly:\n&gt;&gt;&gt; u8_arr = np.array([1, 0], dtype=np.uint8)\n&gt;&gt;&gt; np.diff(u8_arr)\narray([255], dtype=uint8)\n&gt;&gt;&gt; u8_arr[1,...] - u8_arr[0,...]\n255\n\n\nIf this is not desirable, then the array should be cast to a larger\ninteger type first:\n&gt;&gt;&gt; i16_arr = u8_arr.astype(np.int16)\n&gt;&gt;&gt; np.diff(i16_arr)\narray([-1], dtype=int16)\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 4, 7, 0])\n&gt;&gt;&gt; np.diff(x)\narray([ 1,  2,  3, -7])\n&gt;&gt;&gt; np.diff(x, n=2)\narray([  1,   1, -10])\n\n\n&gt;&gt;&gt; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n&gt;&gt;&gt; np.diff(x)\narray([[2, 3, 4],\n       [5, 1, 2]])\n&gt;&gt;&gt; np.diff(x, axis=0)\narray([[-1,  2,  0, -2]])\n\n\n&gt;&gt;&gt; x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n&gt;&gt;&gt; np.diff(x)\narray([1, 1], dtype='timedelta64[D]')\n\n\n", "parameters": ["Parameters", "aarray_like", "nint, optional", "axisint, optional", "prepend, appendarray_like, optional", "Returns", "diffndarray"], "returns": "diffndarrayThe n-th differences. The shape of the output is the same as aexcept along axis where the dimension is smaller by n. Thetype of the output is the same as the type of the differencebetween any two elements of a. This is the same as the type ofa in most cases. A notable exception is datetime64, whichresults in a timedelta64 output array.", "examples": ["; x = np.array([1, 2, 4, 7, 0])\n; np.diff(x)\narray([ 1,  2,  3, -7])\n; np.diff(x, n=2)\narray([  1,   1, -10])\n\n", "; x = np.array([1, 2, 4, 7, 0])\n; np.diff(x)\narray([ 1,  2,  3, -7])\n; np.diff(x, n=2)\narray([  1,   1, -10])\n", "; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n; np.diff(x)\narray([[2, 3, 4],\n       [5, 1, 2]])\n; np.diff(x, axis=0)\narray([[-1,  2,  0, -2]])\n\n", "; x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])\n; np.diff(x)\narray([[2, 3, 4],\n       [5, 1, 2]])\n; np.diff(x, axis=0)\narray([[-1,  2,  0, -2]])\n", "; x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n; np.diff(x)\narray([1, 1], dtype='timedelta64[D]')\n\n", "; x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)\n; np.diff(x)\narray([1, 1], dtype='timedelta64[D]')\n"]},
{"library": "numpy", "item_id": "numpy.digitize", "code": "\nnumpy.digitize(x, bins, right=False)[source]\u00b6", "description": "Return the indices of the bins to which each value in input array belongs.\n\n\n\n\n\n\n\nright\norder of bins\nreturned index i satisfies\n\n\n\nFalse\nincreasing\nbins[i-1] &lt;= x &lt; bins[i]\n\nTrue\nincreasing\nbins[i-1] &lt; x &lt;= bins[i]\n\nFalse\ndecreasing\nbins[i-1] &gt; x &gt;= bins[i]\n\nTrue\ndecreasing\nbins[i-1] &gt;= x &gt; bins[i]\n\n\n\nIf values in x are beyond the bounds of bins, 0 or len(bins) is\nreturned as appropriate.\n\nParameters\n\nxarray_likeInput array to be binned. Prior to NumPy 1.10.0, this array had to\nbe 1-dimensional, but can now have any shape.\n\nbinsarray_likeArray of bins. It has to be 1-dimensional and monotonic.\n\nrightbool, optionalIndicating whether the intervals include the right or the left bin\nedge. Default behavior is (right==False) indicating that the interval\ndoes not include the right edge. The left bin end is open in this\ncase, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for\nmonotonically increasing bins.\n\n\n\nReturns\n\nindicesndarray of intsOutput array of indices, of same shape as x.\n\n\n\nRaises\n\nValueErrorIf bins is not monotonic.\n\nTypeErrorIf the type of the input is complex.\n\n\n\n\n\nSee also\nbincount, histogram, unique, searchsorted\n\nNotes\nIf values in x are such that they fall outside the bin range,\nattempting to index bins with the indices that digitize returns\nwill result in an IndexError.\n\nNew in version 1.10.0.\n\nnp.digitize is  implemented in terms of np.searchsorted. This means\nthat a binary search is used to bin the values, which scales much better\nfor larger number of bins than the previous linear search. It also removes\nthe requirement for the input array to be 1-dimensional.\nFor monotonically _increasing_ bins, the following are equivalent:\nnp.digitize(x, bins, right=True)\nnp.searchsorted(bins, x, side='left')\n\n\nNote that as the order of the arguments are reversed, the side must be too.\nThe searchsorted call is marginally faster, as it does not do any\nmonotonicity checks. Perhaps more importantly, it supports all dtypes.\nExamples\n&gt;&gt;&gt; x = np.array([0.2, 6.4, 3.0, 1.6])\n&gt;&gt;&gt; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n&gt;&gt;&gt; inds = np.digitize(x, bins)\n&gt;&gt;&gt; inds\narray([1, 4, 3, 2])\n&gt;&gt;&gt; for n in range(x.size):\n...   print(bins[inds[n]-1], \"&lt;=\", x[n], \"&lt;\", bins[inds[n]])\n...\n0.0 &lt;= 0.2 &lt; 1.0\n4.0 &lt;= 6.4 &lt; 10.0\n2.5 &lt;= 3.0 &lt; 4.0\n1.0 &lt;= 1.6 &lt; 2.5\n\n\n&gt;&gt;&gt; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n&gt;&gt;&gt; bins = np.array([0, 5, 10, 15, 20])\n&gt;&gt;&gt; np.digitize(x,bins,right=True)\narray([1, 2, 3, 4, 4])\n&gt;&gt;&gt; np.digitize(x,bins,right=False)\narray([1, 3, 3, 4, 5])\n\n\n", "parameters": ["Parameters", "xarray_like", "binsarray_like", "rightbool, optional", "Returns", "indicesndarray of ints", "Raises", "ValueError", "TypeError"], "returns": "indicesndarray of intsOutput array of indices, of same shape as x.", "examples": ["; x = np.array([0.2, 6.4, 3.0, 1.6])\n; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n; inds = np.digitize(x, bins)\n; inds\narray([1, 4, 3, 2])\n; for n in range(x.size):\n...   print(bins[inds[n]-1], \"&lt;=\", x[n], \"&lt;\", bins[inds[n]])\n...\n0.0 &lt;= 0.2 &lt; 1.0\n4.0 &lt;= 6.4 &lt; 10.0\n2.5 &lt;= 3.0 &lt; 4.0\n1.0 &lt;= 1.6 &lt; 2.5\n\n", "; x = np.array([0.2, 6.4, 3.0, 1.6])\n; bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])\n; inds = np.digitize(x, bins)\n; inds\narray([1, 4, 3, 2])\n; for n in range(x.size):\n...   print(bins[inds[n]-1], \"&lt;=\", x[n], \"&lt;\", bins[inds[n]])\n...\n0.0 &lt;= 0.2 &lt; 1.0\n4.0 &lt;= 6.4 &lt; 10.0\n2.5 &lt;= 3.0 &lt; 4.0\n1.0 &lt;= 1.6 &lt; 2.5\n", "; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n; bins = np.array([0, 5, 10, 15, 20])\n; np.digitize(x,bins,right=True)\narray([1, 2, 3, 4, 4])\n; np.digitize(x,bins,right=False)\narray([1, 3, 3, 4, 5])\n\n", "; x = np.array([1.2, 10.0, 12.4, 15.5, 20.])\n; bins = np.array([0, 5, 10, 15, 20])\n; np.digitize(x,bins,right=True)\narray([1, 2, 3, 4, 4])\n; np.digitize(x,bins,right=False)\narray([1, 3, 3, 4, 5])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.diagonal", "code": "\nrecarray.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.diagonal", "code": "\nndarray.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.diagonal", "code": "\nmemmap.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.diagonal", "code": "\nmatrix.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.diagonal", "code": "\nrecord.diagonal()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.diagonal", "code": "\nMaskedArray.diagonal(offset=0, axis1=0, axis2=1)[source]\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.diagonal", "code": "\nMaskType.diagonal()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.diagonal", "code": "\nmasked_array.diagonal(offset=0, axis1=0, axis2=1)[source]\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.diagonal", "code": "\ngeneric.diagonal()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.diagonal", "code": "\nchararray.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.diagonal", "code": "\nchararray.diagonal(offset=0, axis1=0, axis2=1)\u00b6", "description": "Return specified diagonals. In NumPy 1.9 the returned array is a\nread-only view instead of a copy as in previous NumPy versions.  In\na future version the read-only restriction will be removed.\nRefer to numpy.diagonal for full documentation.\n\nSee also\n\nnumpy.diagonalequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.diagonal", "code": "\nnumpy.diagonal(a, offset=0, axis1=0, axis2=1)[source]\u00b6", "description": "Return specified diagonals.\nIf a is 2-D, returns the diagonal of a with the given offset,\ni.e., the collection of elements of the form a[i, i+offset].  If\na has more than two dimensions, then the axes specified by axis1\nand axis2 are used to determine the 2-D sub-array whose diagonal is\nreturned.  The shape of the resulting array can be determined by\nremoving axis1 and axis2 and appending an index to the right equal\nto the size of the resulting diagonals.\nIn versions of NumPy prior to 1.7, this function always returned a new,\nindependent array containing a copy of the values in the diagonal.\nIn NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,\nbut depending on this fact is deprecated. Writing to the resulting\narray continues to work as it used to, but a FutureWarning is issued.\nStarting in NumPy 1.9 it returns a read-only view on the original array.\nAttempting to write to the resulting array will produce an error.\nIn some future release, it will return a read/write view and writing to\nthe returned array will alter your original array.  The returned array\nwill have the same type as the input array.\nIf you don\u2019t write to the array returned by this function, then you can\njust ignore all of the above.\nIf you depend on the current behavior, then we suggest copying the\nreturned array explicitly, i.e., use np.diagonal(a).copy() instead\nof just np.diagonal(a). This will work with both past and future\nversions of NumPy.\n\nParameters\n\naarray_likeArray from which the diagonals are taken.\n\noffsetint, optionalOffset of the diagonal from the main diagonal.  Can be positive or\nnegative.  Defaults to main diagonal (0).\n\naxis1int, optionalAxis to be used as the first axis of the 2-D sub-arrays from which\nthe diagonals should be taken.  Defaults to first axis (0).\n\naxis2int, optionalAxis to be used as the second axis of the 2-D sub-arrays from\nwhich the diagonals should be taken. Defaults to second axis (1).\n\n\n\nReturns\n\narray_of_diagonalsndarrayIf a is 2-D, then a 1-D array containing the diagonal and of the\nsame type as a is returned unless a is a matrix, in which case\na 1-D array rather than a (2-D) matrix is returned in order to\nmaintain backward compatibility.\nIf a.ndim &gt; 2, then the dimensions specified by axis1 and axis2\nare removed, and a new axis inserted at the end corresponding to the\ndiagonal.\n\n\n\nRaises\n\nValueErrorIf the dimension of a is less than 2.\n\n\n\n\n\nSee also\n\ndiagMATLAB work-a-like for 1-D and 2-D arrays.\n\ndiagflatCreate diagonal arrays.\n\ntraceSum along diagonals.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(4).reshape(2,2)\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; a.diagonal()\narray([0, 3])\n&gt;&gt;&gt; a.diagonal(1)\narray([1])\n\n\nA 3-D example:\n&gt;&gt;&gt; a = np.arange(8).reshape(2,2,2); a\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n&gt;&gt;&gt; a.diagonal(0,  # Main diagonals of two arrays created by skipping\n...            0,  # across the outer(left)-most axis last and\n...            1)  # the \"middle\" (row) axis first.\narray([[0, 6],\n       [1, 7]])\n\n\nThe sub-arrays whose main diagonals we just obtained; note that each\ncorresponds to fixing the right-most (column) axis, and that the\ndiagonals are \u201cpacked\u201d in rows.\n&gt;&gt;&gt; a[:,:,0]  # main diagonal is [0 6]\narray([[0, 2],\n       [4, 6]])\n&gt;&gt;&gt; a[:,:,1]  # main diagonal is [1 7]\narray([[1, 3],\n       [5, 7]])\n\n\nThe anti-diagonal can be obtained by reversing the order of elements\nusing either numpy.flipud or numpy.fliplr.\n&gt;&gt;&gt; a = np.arange(9).reshape(3, 3)\n&gt;&gt;&gt; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n&gt;&gt;&gt; np.fliplr(a).diagonal()  # Horizontal flip\narray([2, 4, 6])\n&gt;&gt;&gt; np.flipud(a).diagonal()  # Vertical flip\narray([6, 4, 2])\n\n\nNote that the order in which the diagonal is retrieved varies depending\non the flip function.\n", "parameters": ["Parameters", "aarray_like", "offsetint, optional", "axis1int, optional", "axis2int, optional", "Returns", "array_of_diagonalsndarray", "Raises", "ValueError"], "returns": "array_of_diagonalsndarrayIf a is 2-D, then a 1-D array containing the diagonal and of thesame type as a is returned unless a is a matrix, in which casea 1-D array rather than a (2-D) matrix is returned in order tomaintain backward compatibility.If a.ndim &gt; 2, then the dimensions specified by axis1 and axis2are removed, and a new axis inserted at the end corresponding to thediagonal.", "examples": ["; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; a.diagonal()\narray([0, 3])\n; a.diagonal(1)\narray([1])\n\n", "; a = np.arange(4).reshape(2,2)\n; a\narray([[0, 1],\n       [2, 3]])\n; a.diagonal()\narray([0, 3])\n; a.diagonal(1)\narray([1])\n", "; a = np.arange(8).reshape(2,2,2); a\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; a.diagonal(0,  # Main diagonals of two arrays created by skipping\n...            0,  # across the outer(left)-most axis last and\n...            1)  # the \"middle\" (row) axis first.\narray([[0, 6],\n       [1, 7]])\n\n", "; a = np.arange(8).reshape(2,2,2); a\narray([[[0, 1],\n        [2, 3]],\n       [[4, 5],\n        [6, 7]]])\n; a.diagonal(0,  # Main diagonals of two arrays created by skipping\n...            0,  # across the outer(left)-most axis last and\n...            1)  # the \"middle\" (row) axis first.\narray([[0, 6],\n       [1, 7]])\n", "; a[:,:,0]  # main diagonal is [0 6]\narray([[0, 2],\n       [4, 6]])\n; a[:,:,1]  # main diagonal is [1 7]\narray([[1, 3],\n       [5, 7]])\n\n", "; a[:,:,0]  # main diagonal is [0 6]\narray([[0, 2],\n       [4, 6]])\n; a[:,:,1]  # main diagonal is [1 7]\narray([[1, 3],\n       [5, 7]])\n", "; a = np.arange(9).reshape(3, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n; np.fliplr(a).diagonal()  # Horizontal flip\narray([2, 4, 6])\n; np.flipud(a).diagonal()  # Vertical flip\narray([6, 4, 2])\n\n", "; a = np.arange(9).reshape(3, 3)\n; a\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n; np.fliplr(a).diagonal()  # Horizontal flip\narray([2, 4, 6])\n; np.flipud(a).diagonal()  # Vertical flip\narray([6, 4, 2])\n"]},
{"library": "numpy", "item_id": "numpy.diagflat", "code": "\nnumpy.diagflat(v, k=0)[source]\u00b6", "description": "Create a two-dimensional array with the flattened input as a diagonal.\n\nParameters\n\nvarray_likeInput data, which is flattened and set as the k-th\ndiagonal of the output.\n\nkint, optionalDiagonal to set; 0, the default, corresponds to the \u201cmain\u201d diagonal,\na positive (negative) k giving the number of the diagonal above\n(below) the main.\n\n\n\nReturns\n\noutndarrayThe 2-D output array.\n\n\n\n\n\nSee also\n\ndiagMATLAB work-alike for 1-D and 2-D arrays.\n\ndiagonalReturn specified diagonals.\n\ntraceSum along diagonals.\n\n\n\nExamples\n&gt;&gt;&gt; np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n\n&gt;&gt;&gt; np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])\n\n\n", "parameters": ["Parameters", "varray_like", "kint, optional", "Returns", "outndarray"], "returns": "outndarrayThe 2-D output array.", "examples": ["; np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n\n", "; np.diagflat([[1,2], [3,4]])\narray([[1, 0, 0, 0],\n       [0, 2, 0, 0],\n       [0, 0, 3, 0],\n       [0, 0, 0, 4]])\n", "; np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])\n\n", "; np.diagflat([1,2], 1)\narray([[0, 1, 0],\n       [0, 0, 2],\n       [0, 0, 0]])\n"]},
{"library": "numpy", "item_id": "numpy.diag_indices_from", "code": "\nnumpy.diag_indices_from(arr)[source]\u00b6", "description": "Return the indices to access the main diagonal of an n-dimensional array.\nSee diag_indices for full details.\n\nParameters\n\narrarray, at least 2-D\n\n\n\n\nSee also\ndiag_indices\n\nNotes\n\nNew in version 1.4.0.\n\n", "parameters": ["Parameters", "arrarray, at least 2-D"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.diag_indices", "code": "\nnumpy.diag_indices(n, ndim=2)[source]\u00b6", "description": "Return the indices to access the main diagonal of an array.\nThis returns a tuple of indices that can be used to access the main\ndiagonal of an array a with a.ndim &gt;= 2 dimensions and shape\n(n, n, \u2026, n). For a.ndim = 2 this is the usual diagonal, for\na.ndim &gt; 2 this is the set of indices to access a[i, i, ..., i]\nfor i = [0..n-1].\n\nParameters\n\nnintThe size, along each dimension, of the arrays for which the returned\nindices can be used.\n\nndimint, optionalThe number of dimensions.\n\n\n\n\n\nSee also\ndiag_indices_from\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\nCreate a set of indices to access the diagonal of a (4, 4) array:\n&gt;&gt;&gt; di = np.diag_indices(4)\n&gt;&gt;&gt; di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n&gt;&gt;&gt; a = np.arange(16).reshape(4, 4)\n&gt;&gt;&gt; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n&gt;&gt;&gt; a[di] = 100\n&gt;&gt;&gt; a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])\n\n\nNow, we create indices to manipulate a 3-D array:\n&gt;&gt;&gt; d3 = np.diag_indices(2, 3)\n&gt;&gt;&gt; d3\n(array([0, 1]), array([0, 1]), array([0, 1]))\n\n\nAnd use it to set the diagonal of an array of zeros to 1:\n&gt;&gt;&gt; a = np.zeros((2, 2, 2), dtype=int)\n&gt;&gt;&gt; a[d3] = 1\n&gt;&gt;&gt; a\narray([[[1, 0],\n        [0, 0]],\n       [[0, 0],\n        [0, 1]]])\n\n\n", "parameters": ["Parameters", "nint", "ndimint, optional"], "returns": [], "examples": ["; di = np.diag_indices(4)\n; di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n; a[di] = 100\n; a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])\n\n", "; di = np.diag_indices(4)\n; di\n(array([0, 1, 2, 3]), array([0, 1, 2, 3]))\n; a = np.arange(16).reshape(4, 4)\n; a\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11],\n       [12, 13, 14, 15]])\n; a[di] = 100\n; a\narray([[100,   1,   2,   3],\n       [  4, 100,   6,   7],\n       [  8,   9, 100,  11],\n       [ 12,  13,  14, 100]])\n", "; d3 = np.diag_indices(2, 3)\n; d3\n(array([0, 1]), array([0, 1]), array([0, 1]))\n\n", "; d3 = np.diag_indices(2, 3)\n; d3\n(array([0, 1]), array([0, 1]), array([0, 1]))\n", "; a = np.zeros((2, 2, 2), dtype=int)\n; a[d3] = 1\n; a\narray([[[1, 0],\n        [0, 0]],\n       [[0, 0],\n        [0, 1]]])\n\n", "; a = np.zeros((2, 2, 2), dtype=int)\n; a[d3] = 1\n; a\narray([[[1, 0],\n        [0, 0]],\n       [[0, 0],\n        [0, 1]]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.diag", "code": "\nnumpy.ma.diag(v, k=0)[source]\u00b6", "description": "Extract a diagonal or construct a diagonal array.\nThis function is the equivalent of numpy.diag that takes masked\nvalues into account, see numpy.diag for details.\n\nSee also\n\nnumpy.diagEquivalent function for ndarrays.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.descr", "code": "\ndtype.descr\u00b6", "description": "__array_interface__ description of the data-type.\nThe format is that required by the \u2018descr\u2019 key in the\n__array_interface__ attribute.\nWarning: This attribute exists specifically for __array_interface__,\nand passing it directly to np.dtype will not accurately reconstruct\nsome dtypes (e.g., scalar and subarray dtypes).\nExamples\n&gt;&gt;&gt; x = np.dtype(float)\n&gt;&gt;&gt; x.descr\n[('', '&lt;f8')]\n\n\n&gt;&gt;&gt; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n&gt;&gt;&gt; dt.descr\n[('name', '&lt;U16'), ('grades', '&lt;f8', (2,))]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype(float)\n; x.descr\n[('', '&lt;f8')]\n\n", "; x = np.dtype(float)\n; x.descr\n[('', '&lt;f8')]\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.descr\n[('name', '&lt;U16'), ('grades', '&lt;f8', (2,))]\n\n", "; dt = np.dtype([('name', np.str_, 16), ('grades', np.float64, (2,))])\n; dt.descr\n[('name', '&lt;U16'), ('grades', '&lt;f8', (2,))]\n"]},
{"library": "numpy", "item_id": "numpy.diag", "code": "\nnumpy.diag(v, k=0)[source]\u00b6", "description": "Extract a diagonal or construct a diagonal array.\nSee the more detailed documentation for numpy.diagonal if you use this\nfunction to extract a diagonal and wish to write to the resulting array;\nwhether it returns a copy or a view depends on what version of numpy you\nare using.\n\nParameters\n\nvarray_likeIf v is a 2-D array, return a copy of its k-th diagonal.\nIf v is a 1-D array, return a 2-D array with v on the k-th\ndiagonal.\n\nkint, optionalDiagonal in question. The default is 0. Use k&gt;0 for diagonals\nabove the main diagonal, and k&lt;0 for diagonals below the main\ndiagonal.\n\n\n\nReturns\n\noutndarrayThe extracted diagonal or constructed diagonal array.\n\n\n\n\n\nSee also\n\ndiagonalReturn specified diagonals.\n\ndiagflatCreate a 2-D array with the flattened input as a diagonal.\n\ntraceSum along diagonals.\n\ntriuUpper triangle of an array.\n\ntrilLower triangle of an array.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(9).reshape((3,3))\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n\n&gt;&gt;&gt; np.diag(x)\narray([0, 4, 8])\n&gt;&gt;&gt; np.diag(x, k=1)\narray([1, 5])\n&gt;&gt;&gt; np.diag(x, k=-1)\narray([3, 7])\n\n\n&gt;&gt;&gt; np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])\n\n\n", "parameters": ["Parameters", "varray_like", "kint, optional", "Returns", "outndarray"], "returns": "outndarrayThe extracted diagonal or constructed diagonal array.", "examples": ["; x = np.arange(9).reshape((3,3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n\n", "; x = np.arange(9).reshape((3,3))\n; x\narray([[0, 1, 2],\n       [3, 4, 5],\n       [6, 7, 8]])\n", "; np.diag(x)\narray([0, 4, 8])\n; np.diag(x, k=1)\narray([1, 5])\n; np.diag(x, k=-1)\narray([3, 7])\n\n", "; np.diag(x)\narray([0, 4, 8])\n; np.diag(x, k=1)\narray([1, 5])\n; np.diag(x, k=-1)\narray([3, 7])\n", "; np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])\n\n", "; np.diag(np.diag(x))\narray([[0, 0, 0],\n       [0, 4, 0],\n       [0, 0, 8]])\n"]},
{"library": "numpy", "item_id": "numpy.linalg.det", "code": "\nnumpy.linalg.det(a)[source]\u00b6", "description": "Compute the determinant of an array.\n\nParameters\n\na(\u2026, M, M) array_likeInput array to compute determinants for.\n\n\n\nReturns\n\ndet(\u2026) array_likeDeterminant of a.\n\n\n\n\n\nSee also\n\nslogdetAnother way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThe determinant is computed via LU factorization using the LAPACK\nroutine z/dgetrf.\nExamples\nThe determinant of a 2-D array [[a, b], [c, d]] is ad - bc:\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; np.linalg.det(a)\n-2.0 # may vary\n\n\nComputing determinants for a stack of matrices:\n&gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n&gt;&gt;&gt; a.shape\n(3, 2, 2)\n&gt;&gt;&gt; np.linalg.det(a)\narray([-2., -3., -8.])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "Returns", "det(\u2026) array_like"], "returns": "det(\u2026) array_likeDeterminant of a.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; np.linalg.det(a)\n-2.0 # may vary\n\n", "; a = np.array([[1, 2], [3, 4]])\n; np.linalg.det(a)\n-2.0 # may vary\n", "; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n; a.shape\n(3, 2, 2)\n; np.linalg.det(a)\narray([-2., -3., -8.])\n\n", "; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])\n; a.shape\n(3, 2, 2)\n; np.linalg.det(a)\narray([-2., -3., -8.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.deriv", "code": "\nLegendre.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.deriv", "code": "\nLaguerre.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.deriv", "code": "\nHermiteE.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.deriv", "code": "\nPolynomial.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.deriv", "code": "\nHermite.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.deriv", "code": "\nChebyshev.deriv(self, m=1)[source]\u00b6", "description": "Differentiate.\nReturn a series instance of that is the derivative of the current\nseries.\n\nParameters\n\nmnon-negative intFind the derivative of order m.\n\n\n\nReturns\n\nnew_seriesseriesA new series representing the derivative. The domain is the same\nas the domain of the differentiated series.\n\n\n\n\n", "parameters": ["Parameters", "mnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA new series representing the derivative. The domain is the sameas the domain of the differentiated series.", "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.deriv", "code": "\npoly1d.deriv(self, m=1)[source]\u00b6", "description": "Return a derivative of this polynomial.\nRefer to polyder for full documentation.\n\nSee also\n\npolyderequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.dec.deprecated", "code": "\nnumpy.testing.dec.deprecated(conditional=True)\u00b6", "description": "Filter deprecation warnings while running the test suite.\nThis decorator can be used to filter DeprecationWarning\u2019s, to avoid\nprinting them during the test suite run, while checking that the test\nactually raises a DeprecationWarning.\n\nParameters\n\nconditionalbool or callable, optionalFlag to determine whether to mark test as deprecated or not. If the\ncondition is a callable, it is used at runtime to dynamically make the\ndecision. Default is True.\n\n\n\nReturns\n\ndecoratorfunctionThe deprecated decorator itself.\n\n\n\n\nNotes\n\nNew in version 1.4.0.\n\n", "parameters": ["Parameters", "conditionalbool or callable, optional", "Returns", "decoratorfunction"], "returns": "decoratorfunctionThe deprecated decorator itself.", "examples": []},
{"library": "numpy", "item_id": "numpy.deprecate", "code": "\nnumpy.deprecate(*args, **kwargs)[source]\u00b6", "description": "Issues a DeprecationWarning, adds warning to old_name\u2019s\ndocstring, rebinds old_name.__name__ and returns the new\nfunction object.\nThis function may also be used as a decorator.\n\nParameters\n\nfuncfunctionThe function to be deprecated.\n\nold_namestr, optionalThe name of the function to be deprecated. Default is None, in\nwhich case the name of func is used.\n\nnew_namestr, optionalThe new name for the function. Default is None, in which case the\ndeprecation message is that old_name is deprecated. If given, the\ndeprecation message is that old_name is deprecated and new_name\nshould be used instead.\n\nmessagestr, optionalAdditional explanation of the deprecation.  Displayed in the\ndocstring after the warning.\n\n\n\nReturns\n\nold_funcfunctionThe deprecated function.\n\n\n\n\nExamples\nNote that olduint returns a value after printing Deprecation\nWarning:\n&gt;&gt;&gt; olduint = np.deprecate(np.uint)\nDeprecationWarning: `uint64` is deprecated! # may vary\n&gt;&gt;&gt; olduint(6)\n6\n\n\n", "parameters": ["Parameters", "funcfunction", "old_namestr, optional", "new_namestr, optional", "messagestr, optional", "Returns", "old_funcfunction"], "returns": "old_funcfunctionThe deprecated function.", "examples": ["; olduint = np.deprecate(np.uint)\nDeprecationWarning: `uint64` is deprecated! # may vary\n; olduint(6)\n6\n\n", "; olduint = np.deprecate(np.uint)\nDeprecationWarning: `uint64` is deprecated! # may vary\n; olduint(6)\n6\n"]},
{"library": "numpy", "item_id": "numpy.delete", "code": "\nnumpy.delete(arr, obj, axis=None)[source]\u00b6", "description": "Return a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by\narr[obj].\n\nParameters\n\narrarray_likeInput array.\n\nobjslice, int or array of intsIndicate indices of sub-arrays to remove along the specified axis.\n\naxisint, optionalThe axis along which to delete the subarray defined by obj.\nIf axis is None, obj is applied to the flattened array.\n\n\n\nReturns\n\noutndarrayA copy of arr with the elements specified by obj removed. Note\nthat delete does not occur in-place. If axis is None, out is\na flattened array.\n\n\n\n\n\nSee also\n\ninsertInsert elements into an array.\n\nappendAppend elements at the end of an array.\n\n\n\nNotes\nOften it is preferable to use a boolean mask. For example:\n&gt;&gt;&gt; arr = np.arange(12) + 1\n&gt;&gt;&gt; mask = np.ones(len(arr), dtype=bool)\n&gt;&gt;&gt; mask[[0,2,4]] = False\n&gt;&gt;&gt; result = arr[mask,...]\n\n\nIs equivalent to np.delete(arr, [0,2,4], axis=0), but allows further\nuse of mask.\nExamples\n&gt;&gt;&gt; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n&gt;&gt;&gt; arr\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n&gt;&gt;&gt; np.delete(arr, 1, 0)\narray([[ 1,  2,  3,  4],\n       [ 9, 10, 11, 12]])\n\n\n&gt;&gt;&gt; np.delete(arr, np.s_[::2], 1)\narray([[ 2,  4],\n       [ 6,  8],\n       [10, 12]])\n&gt;&gt;&gt; np.delete(arr, [1,3,5], None)\narray([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n\n\n", "parameters": ["Parameters", "arrarray_like", "objslice, int or array of ints", "axisint, optional", "Returns", "outndarray"], "returns": "outndarrayA copy of arr with the elements specified by obj removed. Notethat delete does not occur in-place. If axis is None, out isa flattened array.", "examples": ["; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n; arr\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n; np.delete(arr, 1, 0)\narray([[ 1,  2,  3,  4],\n       [ 9, 10, 11, 12]])\n\n", "; arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])\n; arr\narray([[ 1,  2,  3,  4],\n       [ 5,  6,  7,  8],\n       [ 9, 10, 11, 12]])\n; np.delete(arr, 1, 0)\narray([[ 1,  2,  3,  4],\n       [ 9, 10, 11, 12]])\n", "; np.delete(arr, np.s_[::2], 1)\narray([[ 2,  4],\n       [ 6,  8],\n       [10, 12]])\n; np.delete(arr, [1,3,5], None)\narray([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n\n", "; np.delete(arr, np.s_[::2], 1)\narray([[ 2,  4],\n       [ 6,  8],\n       [10, 12]])\n; np.delete(arr, [1,3,5], None)\narray([ 1,  3,  5,  7,  8,  9, 10, 11, 12])\n"]},
{"library": "numpy", "item_id": "numpy.degrees", "code": "\nnumpy.degrees(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'degrees'&gt;\u00b6", "description": "Convert angles from radians to degrees.\n\nParameters\n\nxarray_likeInput array in radians.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray of floatsThe corresponding degree values; if out was supplied this is a\nreference to it.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nrad2degequivalent function\n\n\n\nExamples\nConvert a radian array to degrees\n&gt;&gt;&gt; rad = np.arange(12.)*np.pi/6\n&gt;&gt;&gt; np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n\n\n&gt;&gt;&gt; out = np.zeros((rad.shape))\n&gt;&gt;&gt; r = np.degrees(rad, out)\n&gt;&gt;&gt; np.all(r == out)\nTrue\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray of floats"], "returns": "yndarray of floatsThe corresponding degree values; if out was supplied this is areference to it.This is a scalar if x is a scalar.", "examples": ["; rad = np.arange(12.)*np.pi/6\n; np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n\n", "; rad = np.arange(12.)*np.pi/6\n; np.degrees(rad)\narray([   0.,   30.,   60.,   90.,  120.,  150.,  180.,  210.,  240.,\n        270.,  300.,  330.])\n", "; out = np.zeros((rad.shape))\n; r = np.degrees(rad, out)\n; np.all(r == out)\nTrue\n\n", "; out = np.zeros((rad.shape))\n; r = np.degrees(rad, out)\n; np.all(r == out)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.deprecate_with_doc", "code": "\nnumpy.deprecate_with_doc(msg)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.degree", "code": "\nLegendre.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.degree", "code": "\nPolynomial.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.degree", "code": "\nLaguerre.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.degree", "code": "\nHermiteE.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.degree", "code": "\nHermite.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.deg2rad", "code": "\nnumpy.deg2rad(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'deg2rad'&gt;\u00b6", "description": "Convert angles from degrees to radians.\n\nParameters\n\nxarray_likeAngles in degrees.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding angle in radians.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\nrad2degConvert angles from radians to degrees.\n\nunwrapRemove large jumps in angle by wrapping.\n\n\n\nNotes\n\nNew in version 1.3.0.\n\ndeg2rad(x) is x * pi / 180.\nExamples\n&gt;&gt;&gt; np.deg2rad(180)\n3.1415926535897931\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding angle in radians.This is a scalar if x is a scalar.", "examples": ["; np.deg2rad(180)\n3.1415926535897931\n\n", "; np.deg2rad(180)\n3.1415926535897931\n"]},
{"library": "numpy", "item_id": "numpy.random.default_rng", "code": "\nnumpy.random.default_rng()\u00b6", "description": "Construct a new Generator with the default BitGenerator (PCG64).\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence, BitGenerator, Generator}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\nSeedSequence to derive the initial BitGenerator state. One may also\npass in a`SeedSequence` instance\nAdditionally, when passed a BitGenerator, it will be wrapped by\nGenerator. If passed a Generator, it will be returned unaltered.\n\n\n\nReturns\n\nGeneratorThe initialized generator object.\n\n\n\n\nNotes\nIf seed is not a BitGenerator or a Generator, a new BitGenerator\nis instantiated. This function does not manage a default global instance.\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence, BitGenerator, Generator}, optional", "Returns", "Generator", "Parameters", "bit_generatorBitGenerator"], "returns": "GeneratorThe initialized generator object.", "examples": ["; from numpy.random import Generator, PCG64\n; rg = Generator(PCG64())\n; rg.standard_normal()\n-0.203  # random\n\n", "; from numpy.random import Generator, PCG64\n; rg = Generator(PCG64())\n; rg.standard_normal()\n-0.203  # random\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.degree", "code": "\nChebyshev.degree(self)[source]\u00b6", "description": "The degree of the series.\n\nNew in version 1.5.0.\n\n\nReturns\n\ndegreeintDegree of the series, one less than the number of coefficients.\n\n\n\n\n", "parameters": [], "returns": "degreeintDegree of the series, one less than the number of coefficients.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.default_fill_value", "code": "\nnumpy.ma.default_fill_value(obj)[source]\u00b6", "description": "Return the default fill value for the argument object.\nThe default filling value depends on the datatype of the input\narray or the type of the input scalar:\n\n\n\n\n\n\n\ndatatype\ndefault\n\n\n\nbool\nTrue\n\nint\n999999\n\nfloat\n1.e20\n\ncomplex\n1.e20+0j\n\nobject\n\u2018?\u2019\n\nstring\n\u2018N/A\u2019\n\n\n\n\nFor structured types, a structured scalar is returned, with each field the\ndefault fill value for its type.\nFor subarray types, the fill value is an array of the same size containing\nthe default scalar fill value.\n\nParameters\n\nobjndarray, dtype or scalarThe array data-type or scalar for which the default fill value\nis returned.\n\n\n\nReturns\n\nfill_valuescalarThe default fill value.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.ma.default_fill_value(1)\n999999\n&gt;&gt;&gt; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n&gt;&gt;&gt; np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)\n\n\n", "parameters": ["Parameters", "objndarray, dtype or scalar", "Returns", "fill_valuescalar"], "returns": "fill_valuescalarThe default fill value.", "examples": ["; np.ma.default_fill_value(1)\n999999\n; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n; np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)\n\n", "; np.ma.default_fill_value(1)\n999999\n; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))\n1e+20\n; np.ma.default_fill_value(np.dtype(complex))\n(1e+20+0j)\n"]},
{"library": "numpy", "item_id": "numpy.testing.decorate_methods", "code": "\nnumpy.testing.decorate_methods(cls, decorator, testmatch=None)[source]\u00b6", "description": "Apply a decorator to all methods in a class matching a regular expression.\nThe given decorator is applied to all public methods of cls that are\nmatched by the regular expression testmatch\n(testmatch.search(methodname)). Methods that are private, i.e. start\nwith an underscore, are ignored.\n\nParameters\n\nclsclassClass whose methods to decorate.\n\ndecoratorfunctionDecorator to apply to methods\n\ntestmatchcompiled regexp or str, optionalThe regular expression. Default value is None, in which case the\nnose default (re.compile(r'(?:^|[\\b_\\.%s-])[Tt]est' % os.sep))\nis used.\nIf testmatch is a string, it is compiled to a regular expression\nfirst.\n\n\n\n\n", "parameters": ["Parameters", "clsclass", "decoratorfunction", "testmatchcompiled regexp or str, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.decode", "code": "\nchararray.decode(self, encoding=None, errors=None)[source]\u00b6", "description": "Calls str.decode element-wise.\n\nSee also\nchar.decode\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.decode", "code": "\nchararray.decode(self, encoding=None, errors=None)\u00b6", "description": "Calls str.decode element-wise.\n\nSee also\nchar.decode\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.decode", "code": "\nnumpy.char.decode(a, encoding=None, errors=None)\u00b6", "description": "Calls str.decode element-wise.\nThe set of available codecs comes from the Python standard library,\nand may be extended at runtime.  For more information, see the\ncodecs module.\n\nParameters\n\naarray_like of str or unicode\nencodingstr, optionalThe name of an encoding\n\nerrorsstr, optionalSpecifies how to handle encoding errors\n\n\n\nReturns\n\noutndarray\n\n\n\n\nSee also\nstr.decode\n\nNotes\nThe type of the result will depend on the encoding specified.\nExamples\n&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n&gt;&gt;&gt; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n&gt;&gt;&gt; np.char.encode(c, encoding='cp037')\narray(['\\x81\\xc1\\x81\\xc1\\x81\\xc1', '@@\\x81\\[email\u00a0protected]@',\n    '\\x81\\x82\\xc2\\xc1\\xc2\\x82\\x81'],\n    dtype='|S7')\n\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "encodingstr, optional", "errorsstr, optional", "Returns", "outndarray"], "returns": "outndarray", "examples": ["; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.encode(c, encoding='cp037')\narray(['\\x81\\xc1\\x81\\xc1\\x81\\xc1', '@@\\x81\\[email\u00a0protected]@',\n    '\\x81\\x82\\xc2\\xc1\\xc2\\x82\\x81'],\n    dtype='|S7')\n\n", "; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.encode(c, encoding='cp037')\narray(['\\x81\\xc1\\x81\\xc1\\x81\\xc1', '@@\\x81\\[email\u00a0protected]@',\n    '\\x81\\x82\\xc2\\xc1\\xc2\\x82\\x81'],\n    dtype='|S7')\n"]},
{"library": "numpy", "item_id": "numpy.nditer.debug_print", "code": "\nnditer.debug_print()\u00b6", "description": "Print the current state of the nditer instance and debug info to stdout.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.datetime_data", "code": "\nnumpy.datetime_data(dtype, /)\u00b6", "description": "Get information about the step size of a date or time type.\nThe returned tuple can be passed as the second argument of numpy.datetime64 and\nnumpy.timedelta64.\n\nParameters\n\ndtypedtypeThe dtype object, which must be a datetime64 or timedelta64 type.\n\n\n\nReturns\n\nunitstrThe datetime unit on which this dtype\nis based.\n\ncountintThe number of base units in a step.\n\n\n\n\nExamples\n&gt;&gt;&gt; dt_25s = np.dtype('timedelta64[25s]')\n&gt;&gt;&gt; np.datetime_data(dt_25s)\n('s', 25)\n&gt;&gt;&gt; np.array(10, dt_25s).astype('timedelta64[s]')\narray(250, dtype='timedelta64[s]')\n\n\nThe result can be used to construct a datetime that uses the same units\nas a timedelta\n&gt;&gt;&gt; np.datetime64('2010', np.datetime_data(dt_25s))\nnumpy.datetime64('2010-01-01T00:00:00','25s')\n\n\n", "parameters": ["Parameters", "dtypedtype", "Returns", "unitstr", "countint"], "returns": "unitstrThe datetime unit on which this dtypeis based.countintThe number of base units in a step.", "examples": ["; dt_25s = np.dtype('timedelta64[25s]')\n; np.datetime_data(dt_25s)\n('s', 25)\n; np.array(10, dt_25s).astype('timedelta64[s]')\narray(250, dtype='timedelta64[s]')\n\n", "; dt_25s = np.dtype('timedelta64[25s]')\n; np.datetime_data(dt_25s)\n('s', 25)\n; np.array(10, dt_25s).astype('timedelta64[s]')\narray(250, dtype='timedelta64[s]')\n", "; np.datetime64('2010', np.datetime_data(dt_25s))\nnumpy.datetime64('2010-01-01T00:00:00','25s')\n\n", "; np.datetime64('2010', np.datetime_data(dt_25s))\nnumpy.datetime64('2010-01-01T00:00:00','25s')\n"]},
{"library": "numpy", "item_id": "numpy.datetime_as_string", "code": "\nnumpy.datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')\u00b6", "description": "Convert an array of datetimes into an array of strings.\n\nParameters\n\narrarray_like of datetime64The array of UTC timestamps to format.\n\nunitstrOne of None, \u2018auto\u2019, or a datetime unit.\n\ntimezone{\u2018naive\u2019, \u2018UTC\u2019, \u2018local\u2019} or tzinfoTimezone information to use when displaying the datetime. If \u2018UTC\u2019, end\nwith a Z to indicate UTC time. If \u2018local\u2019, convert to the local timezone\nfirst, and suffix with a +-#### timezone offset. If a tzinfo object,\nthen do as with \u2018local\u2019, but use the specified timezone.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}Casting to allow when changing between datetime units.\n\n\n\nReturns\n\nstr_arrndarrayAn array of strings the same shape as arr.\n\n\n\n\nExamples\n&gt;&gt;&gt; import pytz\n&gt;&gt;&gt; d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n&gt;&gt;&gt; d\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n       '2002-10-27T07:30'], dtype='datetime64[m]')\n\n\nSetting the timezone to UTC shows the same information, but with a Z suffix\n&gt;&gt;&gt; np.datetime_as_string(d, timezone='UTC')\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n       '2002-10-27T07:30Z'], dtype='&lt;U35')\n\n\nNote that we picked datetimes that cross a DST boundary. Passing in a\npytz timezone object will print the appropriate offset\n&gt;&gt;&gt; np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))\narray(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='&lt;U39')\n\n\nPassing in a unit will change the precision\n&gt;&gt;&gt; np.datetime_as_string(d, unit='h')\narray(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n      dtype='&lt;U32')\n&gt;&gt;&gt; np.datetime_as_string(d, unit='s')\narray(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n       '2002-10-27T07:30:00'], dtype='&lt;U38')\n\n\n\u2018casting\u2019 can be used to specify whether precision can be changed\n&gt;&gt;&gt; np.datetime_as_string(d, unit='h', casting='safe')\nTraceback (most recent call last):\n    ...\nTypeError: Cannot create a datetime string as units 'h' from a NumPy\ndatetime with units 'm' according to the rule 'safe'\n\n\n", "parameters": ["Parameters", "arrarray_like of datetime64", "unitstr", "timezone{\u2018naive\u2019, \u2018UTC\u2019, \u2018local\u2019} or tzinfo", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}", "Returns", "str_arrndarray"], "returns": "str_arrndarrayAn array of strings the same shape as arr.", "examples": ["; import pytz\n; d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n; d\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n       '2002-10-27T07:30'], dtype='datetime64[m]')\n\n", "; import pytz\n; d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')\n; d\narray(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',\n       '2002-10-27T07:30'], dtype='datetime64[m]')\n", "; np.datetime_as_string(d, timezone='UTC')\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n       '2002-10-27T07:30Z'], dtype='&lt;U35')\n\n", "; np.datetime_as_string(d, timezone='UTC')\narray(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',\n       '2002-10-27T07:30Z'], dtype='&lt;U35')\n", "; np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))\narray(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='&lt;U39')\n\n", "; np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))\narray(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',\n       '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='&lt;U39')\n", "; np.datetime_as_string(d, unit='h')\narray(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n      dtype='&lt;U32')\n; np.datetime_as_string(d, unit='s')\narray(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n       '2002-10-27T07:30:00'], dtype='&lt;U38')\n\n", "; np.datetime_as_string(d, unit='h')\narray(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],\n      dtype='&lt;U32')\n; np.datetime_as_string(d, unit='s')\narray(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',\n       '2002-10-27T07:30:00'], dtype='&lt;U38')\n", "; np.datetime_as_string(d, unit='h', casting='safe')\nTraceback (most recent call last):\n    ...\nTypeError: Cannot create a datetime string as units 'h' from a NumPy\ndatetime with units 'm' according to the rule 'safe'\n\n", "; np.datetime_as_string(d, unit='h', casting='safe')\nTraceback (most recent call last):\n    ...\nTypeError: Cannot create a datetime string as units 'h' from a NumPy\ndatetime with units 'm' according to the rule 'safe'\n"]},
{"library": "numpy", "item_id": "numpy.DataSource", "code": "\nclass numpy.DataSource(destpath='.')[source]\u00b6", "description": "A generic data source file (file, http, ftp, \u2026).\nDataSources can be local files or remote files/URLs.  The files may\nalso be compressed or uncompressed. DataSource hides some of the\nlow-level details of downloading the file, allowing you to simply pass\nin a valid file path (or URL) and obtain a file object.\n\nParameters\n\ndestpathstr or None, optionalPath to the directory where the source file gets downloaded to for\nuse.  If destpath is None, a temporary directory will be created.\nThe default path is the current directory.\n\n\n\n\nNotes\nURLs require a scheme string (http://) to be used, without it they\nwill fail:\n&gt;&gt;&gt; repos = np.DataSource()\n&gt;&gt;&gt; repos.exists('www.google.com/index.html')\nFalse\n&gt;&gt;&gt; repos.exists('http://www.google.com/index.html')\nTrue\n\n\nTemporary directories are deleted when the DataSource is deleted.\nExamples\n&gt;&gt;&gt; ds = np.DataSource('/home/guido')\n&gt;&gt;&gt; urlname = 'http://www.google.com/'\n&gt;&gt;&gt; gfile = ds.open('http://www.google.com/')\n&gt;&gt;&gt; ds.abspath(urlname)\n'/home/guido/www.google.com/index.html'\n\n&gt;&gt;&gt; ds = np.DataSource(None)  # use with temporary file\n&gt;&gt;&gt; ds.open('/home/guido/foobar.txt')\n&lt;open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430&gt;\n&gt;&gt;&gt; ds.abspath('/home/guido/foobar.txt')\n'/tmp/.../home/guido/foobar.txt'\n\n\nMethods\n\n\n\n\n\n\nabspath(self,\u00a0path)\nReturn absolute path of file in the DataSource directory.\n\nexists(self,\u00a0path)\nTest if path exists.\n\nopen(self,\u00a0path[,\u00a0mode,\u00a0encoding,\u00a0newline])\nOpen and return file-like object.\n\n\n\n", "parameters": ["Parameters", "destpathstr or None, optional"], "returns": [], "examples": ["; ds = np.DataSource('/home/guido')\n; urlname = 'http://www.google.com/'\n; gfile = ds.open('http://www.google.com/')\n; ds.abspath(urlname)\n'/home/guido/www.google.com/index.html'\n\n; ds = np.DataSource(None)  # use with temporary file\n; ds.open('/home/guido/foobar.txt')\n&lt;open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430&gt;\n; ds.abspath('/home/guido/foobar.txt')\n'/tmp/.../home/guido/foobar.txt'\n\n", "; ds = np.DataSource('/home/guido')\n; urlname = 'http://www.google.com/'\n; gfile = ds.open('http://www.google.com/')\n; ds.abspath(urlname)\n'/home/guido/www.google.com/index.html'\n\n; ds = np.DataSource(None)  # use with temporary file\n; ds.open('/home/guido/foobar.txt')\n&lt;open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430&gt;\n; ds.abspath('/home/guido/foobar.txt')\n'/tmp/.../home/guido/foobar.txt'\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.data", "code": "\nproperty masked_array.data\u00b6", "description": "Returns the underlying data, as a view of the masked array.\nIf the underlying data is a subclass of numpy.ndarray, it is\nreturned as such.\n&gt;&gt;&gt; x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])\n&gt;&gt;&gt; x.data\nmatrix([[1, 2],\n        [3, 4]])\n\n\nThe type of the data can be accessed through the baseclass\nattribute.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.data", "code": "\nrecord.data\u00b6", "description": "pointer to start of data\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.data", "code": "\nrecarray.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.data", "code": "\nndarray.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.data", "code": "\nmemmap.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.data", "code": "\nMaskType.data\u00b6", "description": "pointer to start of data\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.data", "code": "\ngeneric.data\u00b6", "description": "pointer to start of data\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.data", "code": "\nchararray.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.data", "code": "\nmatrix.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.data", "code": "\nchararray.data\u00b6", "description": "Python buffer object pointing to the start of the array\u2019s data.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.cutdeg", "code": "\nPolynomial.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.cutdeg", "code": "\nLegendre.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.cutdeg", "code": "\nLaguerre.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.cutdeg", "code": "\nHermiteE.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.cumsum", "code": "\nndarray.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.cutdeg", "code": "\nChebyshev.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.cutdeg", "code": "\nHermite.cutdeg(self, deg)[source]\u00b6", "description": "Truncate series to the given degree.\nReduce the degree of the series to deg by discarding the\nhigh order terms. If deg is greater than the current degree a\ncopy of the current series is returned. This can be useful in least\nsquares where the coefficients of the high degree terms may be very\nsmall.\n\nNew in version 1.5.0.\n\n\nParameters\n\ndegnon-negative intThe series is reduced to degree deg by discarding the high\norder terms. The value of deg must be a non-negative integer.\n\n\n\nReturns\n\nnew_seriesseriesNew instance of series with reduced degree.\n\n\n\n\n", "parameters": ["Parameters", "degnon-negative int", "Returns", "new_seriesseries"], "returns": "new_seriesseriesNew instance of series with reduced degree.", "examples": []},
{"library": "numpy", "item_id": "numpy.record.cumsum", "code": "\nrecord.cumsum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.cumsum", "code": "\nrecarray.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.cumsum", "code": "\nmatrix.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.cumsum", "code": "\nmemmap.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.cumsum", "code": "\ngeneric.cumsum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.cumsum", "code": "\nMaskType.cumsum()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.cumsum", "code": "\nMaskedArray.cumsum(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.ndarray.cumsumcorresponding function for ndarrays\n\nnumpy.cumsumequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nExamples\n&gt;&gt;&gt; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n&gt;&gt;&gt; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n", "; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.chararray.cumsum", "code": "\nchararray.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.cumsum", "code": "\nchararray.cumsum(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative sum of the elements along the given axis.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.cumsumequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.cumsum", "code": "\nnumpy.cumsum(a, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative sum of the elements along a given axis.\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalAxis along which the cumulative sum is computed. The default\n(None) is to compute the cumsum over the flattened array.\n\ndtypedtype, optionalType of the returned array and of the accumulator in which the\nelements are summed.  If dtype is not specified, it defaults\nto the dtype of a, unless a has an integer dtype with a\nprecision less than that of the default platform integer.  In\nthat case, the default platform integer is used.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type will be cast if necessary. See ufuncs-output-type for\nmore details.\n\n\n\nReturns\n\ncumsum_along_axisndarray.A new array holding the result is returned unless out is\nspecified, in which case a reference to out is returned. The\nresult has the same size as a, and the same shape as a if\naxis is not None or a is a 1-d array.\n\n\n\n\n\nSee also\n\nsumSum array elements.\n\ntrapzIntegration of array values using the composite trapezoidal rule.\n\ndiffCalculate the n-th discrete difference along given axis.\n\n\n\nNotes\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nExamples\n&gt;&gt;&gt; a = np.array([[1,2,3], [4,5,6]])\n&gt;&gt;&gt; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n&gt;&gt;&gt; np.cumsum(a)\narray([ 1,  3,  6, 10, 15, 21])\n&gt;&gt;&gt; np.cumsum(a, dtype=float)     # specifies type of output value(s)\narray([  1.,   3.,   6.,  10.,  15.,  21.])\n\n\n&gt;&gt;&gt; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\narray([[1, 2, 3],\n       [5, 7, 9]])\n&gt;&gt;&gt; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\narray([[ 1,  3,  6],\n       [ 4,  9, 15]])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "cumsum_along_axisndarray."], "returns": "cumsum_along_axisndarray.A new array holding the result is returned unless out isspecified, in which case a reference to out is returned. Theresult has the same size as a, and the same shape as a ifaxis is not None or a is a 1-d array.", "examples": ["; a = np.array([[1,2,3], [4,5,6]])\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.cumsum(a)\narray([ 1,  3,  6, 10, 15, 21])\n; np.cumsum(a, dtype=float)     # specifies type of output value(s)\narray([  1.,   3.,   6.,  10.,  15.,  21.])\n\n", "; a = np.array([[1,2,3], [4,5,6]])\n; a\narray([[1, 2, 3],\n       [4, 5, 6]])\n; np.cumsum(a)\narray([ 1,  3,  6, 10, 15, 21])\n; np.cumsum(a, dtype=float)     # specifies type of output value(s)\narray([  1.,   3.,   6.,  10.,  15.,  21.])\n", "; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\narray([[1, 2, 3],\n       [5, 7, 9]])\n; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\narray([[ 1,  3,  6],\n       [ 4,  9, 15]])\n\n", "; np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns\narray([[1, 2, 3],\n       [5, 7, 9]])\n; np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows\narray([[ 1,  3,  6],\n       [ 4,  9, 15]])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.cumprod", "code": "\nrecarray.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.cumprod", "code": "\nndarray.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.cumsum", "code": "\nnumpy.ma.cumsum(self, axis=None, dtype=None, out=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.ndarray.cumsumcorresponding function for ndarrays\n\nnumpy.cumsumequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nExamples\n&gt;&gt;&gt; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n&gt;&gt;&gt; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n", "; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.record.cumprod", "code": "\nrecord.cumprod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.cumsum", "code": "\nmasked_array.cumsum(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative sum of the array elements over the given axis.\nMasked values are set to 0 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumsum for full documentation.\n\nSee also\n\nnumpy.ndarray.cumsumcorresponding function for ndarrays\n\nnumpy.cumsumequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nExamples\n&gt;&gt;&gt; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n&gt;&gt;&gt; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n\n", "; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])\n; marr.cumsum()\nmasked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],\n             mask=[False, False, False,  True,  True,  True, False, False,\n                   False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.memmap.cumprod", "code": "\nmemmap.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.cumprod", "code": "\nMaskType.cumprod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.cumprod", "code": "\nMaskedArray.cumprod(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.ndarray.cumprodcorresponding function for ndarrays\n\nnumpy.cumprodequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.cumprod", "code": "\nmasked_array.cumprod(self, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.ndarray.cumprodcorresponding function for ndarrays\n\nnumpy.cumprodequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.cumprod", "code": "\nmatrix.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.cumprod", "code": "\nchararray.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.cumprod", "code": "\ngeneric.cumprod()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.cumprod", "code": "\nchararray.cumprod(axis=None, dtype=None, out=None)\u00b6", "description": "Return the cumulative product of the elements along the given axis.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.cumprodequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.cumprod", "code": "\nnumpy.cumprod(a, axis=None, dtype=None, out=None)[source]\u00b6", "description": "Return the cumulative product of elements along a given axis.\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalAxis along which the cumulative product is computed.  By default\nthe input is flattened.\n\ndtypedtype, optionalType of the returned array, as well as of the accumulator in which\nthe elements are multiplied.  If dtype is not specified, it\ndefaults to the dtype of a, unless a has an integer dtype with\na precision less than that of the default platform integer.  In\nthat case, the default platform integer is used instead.\n\noutndarray, optionalAlternative output array in which to place the result. It must\nhave the same shape and buffer length as the expected output\nbut the type of the resulting values will be cast if necessary.\n\n\n\nReturns\n\ncumprodndarrayA new array holding the result is returned unless out is\nspecified, in which case a reference to out is returned.\n\n\n\n\n\nSee also\nufuncs-output-type\n\nNotes\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\nExamples\n&gt;&gt;&gt; a = np.array([1,2,3])\n&gt;&gt;&gt; np.cumprod(a) # intermediate results 1, 1*2\n...               # total product 1*2*3 = 6\narray([1, 2, 6])\n&gt;&gt;&gt; a = np.array([[1, 2, 3], [4, 5, 6]])\n&gt;&gt;&gt; np.cumprod(a, dtype=float) # specify type of output\narray([   1.,    2.,    6.,   24.,  120.,  720.])\n\n\nThe cumulative product for each column (i.e., over the rows) of a:\n&gt;&gt;&gt; np.cumprod(a, axis=0)\narray([[ 1,  2,  3],\n       [ 4, 10, 18]])\n\n\nThe cumulative product for each row (i.e. over the columns) of a:\n&gt;&gt;&gt; np.cumprod(a,axis=1)\narray([[  1,   2,   6],\n       [  4,  20, 120]])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "dtypedtype, optional", "outndarray, optional", "Returns", "cumprodndarray"], "returns": "cumprodndarrayA new array holding the result is returned unless out isspecified, in which case a reference to out is returned.", "examples": ["; a = np.array([1,2,3])\n; np.cumprod(a) # intermediate results 1, 1*2\n...               # total product 1*2*3 = 6\narray([1, 2, 6])\n; a = np.array([[1, 2, 3], [4, 5, 6]])\n; np.cumprod(a, dtype=float) # specify type of output\narray([   1.,    2.,    6.,   24.,  120.,  720.])\n\n", "; a = np.array([1,2,3])\n; np.cumprod(a) # intermediate results 1, 1*2\n...               # total product 1*2*3 = 6\narray([1, 2, 6])\n; a = np.array([[1, 2, 3], [4, 5, 6]])\n; np.cumprod(a, dtype=float) # specify type of output\narray([   1.,    2.,    6.,   24.,  120.,  720.])\n", "; np.cumprod(a, axis=0)\narray([[ 1,  2,  3],\n       [ 4, 10, 18]])\n\n", "; np.cumprod(a, axis=0)\narray([[ 1,  2,  3],\n       [ 4, 10, 18]])\n", "; np.cumprod(a,axis=1)\narray([[  1,   2,   6],\n       [  4,  20, 120]])\n\n", "; np.cumprod(a,axis=1)\narray([[  1,   2,   6],\n       [  4,  20, 120]])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.ctypes", "code": "\nrecarray.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.random.SFC64.ctypes", "code": "\nSFC64.ctypes\u00b6", "description": "ctypes interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing ctypes wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.PCG64.ctypes", "code": "\nPCG64.ctypes\u00b6", "description": "ctypes interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing ctypes wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.cumprod", "code": "\nnumpy.ma.cumprod(self, axis=None, dtype=None, out=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return the cumulative product of the array elements over the given axis.\nMasked values are set to 1 internally during the computation.\nHowever, their position is saved, and the result will be masked at\nthe same locations.\nRefer to numpy.cumprod for full documentation.\n\nSee also\n\nnumpy.ndarray.cumprodcorresponding function for ndarrays\n\nnumpy.cumprodequivalent function\n\n\n\nNotes\nThe mask is lost if out is not a valid MaskedArray !\nArithmetic is modular when using integer types, and no error is\nraised on overflow.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Philox.ctypes", "code": "\nPhilox.ctypes\u00b6", "description": "ctypes interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing ctypes wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.MT19937.ctypes", "code": "\nMT19937.ctypes\u00b6", "description": "ctypes interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing ctypes wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.ctypes", "code": "\nBitGenerator.ctypes\u00b6", "description": "ctypes interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing ctypes wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing ctypes wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.ctypes", "code": "\nndarray.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.matrix.ctypes", "code": "\nmatrix.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.memmap.ctypes", "code": "\nmemmap.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.ctypes", "code": "\nmasked_array.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.chararray.ctypes", "code": "\nchararray.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.ctypes", "code": "\nMaskedArray.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.ctypes", "code": "\nchararray.ctypes\u00b6", "description": "An object to simplify the interaction of the array with the ctypes\nmodule.\nThis attribute creates an object that makes it easier to use arrays\nwhen calling shared libraries with the ctypes module. The returned\nobject has, among others, data, shape, and strides attributes (see\nNotes below) which themselves return ctypes objects that can be used\nas arguments to a shared library.\n\nParameters\n\nNone\n\n\nReturns\n\ncPython objectPossessing attributes data, shape, strides, etc.\n\n\n\n\n\nSee also\nnumpy.ctypeslib\n\nNotes\nBelow are the public attributes of this object which were documented\nin \u201cGuide to NumPy\u201d (we have omitted undocumented public attributes,\nas well as documented private attributes):\n\n\n_ctypes.data\nA pointer to the memory area of the array as a Python integer.\nThis memory area may contain data that is not aligned, or not in correct\nbyte-order. The memory area may not even be writeable. The array\nflags and data-type of this array should be respected when passing this\nattribute to arbitrary C-code to avoid trouble that can include Python\ncrashing. User Beware! The value of this attribute is exactly the same\nas self._array_interface_['data'][0].\nNote that unlike data_as, a reference will not be kept to the array:\ncode like ctypes.c_void_p((a + b).ctypes.data) will result in a\npointer to a deallocated array, and should be spelt\n(a + b).ctypes.data_as(ctypes.c_void_p)\n\n\n\n\n_ctypes.shape\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the C-integer corresponding to dtype('p') on this\nplatform. This base-type could be ctypes.c_int, ctypes.c_long, or\nctypes.c_longlong depending on the platform.\nThe c_intp type is defined accordingly in numpy.ctypeslib.\nThe ctypes array contains the shape of the underlying array.\n\n\n\n\n_ctypes.strides\n(c_intp*self.ndim): A ctypes array of length self.ndim where\nthe basetype is the same as for the shape attribute. This ctypes array\ncontains the strides information from the underlying array. This strides\ninformation is important for showing how many bytes must be jumped to\nget to the next element in the array.\n\n\n\n\n_ctypes.data_as(self, obj)[source]\nReturn the data pointer cast to a particular c-types object.\nFor example, calling self._as_parameter_ is equivalent to\nself.data_as(ctypes.c_void_p). Perhaps you want to use the data as a\npointer to a ctypes array of floating-point data:\nself.data_as(ctypes.POINTER(ctypes.c_double)).\nThe returned pointer will keep a reference to the array.\n\n\n\n\n_ctypes.shape_as(self, obj)[source]\nReturn the shape tuple as an array of some other c-types\ntype. For example: self.shape_as(ctypes.c_short).\n\n\n\n\n_ctypes.strides_as(self, obj)[source]\nReturn the strides tuple as an array of some other\nc-types type. For example: self.strides_as(ctypes.c_longlong).\n\n\nIf the ctypes module is not available, then the ctypes attribute\nof array objects still returns something useful, but ctypes objects\nare not returned and errors may be raised instead. In particular,\nthe object will still have the as_parameter attribute which will\nreturn an integer equal to the data attribute.\nExamples\n&gt;&gt;&gt; import ctypes\n&gt;&gt;&gt; x\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; x.ctypes.data\n30439712\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n&gt;&gt;&gt; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n&gt;&gt;&gt; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n&gt;&gt;&gt; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n&gt;&gt;&gt; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n\n", "parameters": ["Parameters", "None", "Returns", "cPython object"], "returns": "cPython objectPossessing attributes data, shape, strides, etc.", "examples": ["; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n\n", "; import ctypes\n; x\narray([[0, 1],\n       [2, 3]])\n; x.ctypes.data\n30439712\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long))\n&lt;ctypes.LP_c_long object at 0x01F01300&gt;\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_long)).contents\nc_long(0)\n; x.ctypes.data_as(ctypes.POINTER(ctypes.c_longlong)).contents\nc_longlong(4294967296L)\n; x.ctypes.shape\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FFD580&gt;\n; x.ctypes.shape_as(ctypes.c_long)\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides\n&lt;numpy.core._internal.c_long_Array_2 object at 0x01FCE620&gt;\n; x.ctypes.strides_as(ctypes.c_longlong)\n&lt;numpy.core._internal.c_longlong_Array_2 object at 0x01F01300&gt;\n"]},
{"library": "numpy", "item_id": "numpy.cross", "code": "\nnumpy.cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None)[source]\u00b6", "description": "Return the cross product of two (arrays of) vectors.\nThe cross product of a and b in  is a vector perpendicular\nto both a and b.  If a and b are arrays of vectors, the vectors\nare defined by the last axis of a and b by default, and these axes\ncan have dimensions 2 or 3.  Where the dimension of either a or b is\n2, the third component of the input vector is assumed to be zero and the\ncross product calculated accordingly.  In cases where both input vectors\nhave dimension 2, the z-component of the cross product is returned.\n\nParameters\n\naarray_likeComponents of the first vector(s).\n\nbarray_likeComponents of the second vector(s).\n\naxisaint, optionalAxis of a that defines the vector(s).  By default, the last axis.\n\naxisbint, optionalAxis of b that defines the vector(s).  By default, the last axis.\n\naxiscint, optionalAxis of c containing the cross product vector(s).  Ignored if\nboth input vectors have dimension 2, as the return is scalar.\nBy default, the last axis.\n\naxisint, optionalIf defined, the axis of a, b and c that defines the vector(s)\nand cross product(s).  Overrides axisa, axisb and axisc.\n\n\n\nReturns\n\ncndarrayVector cross product(s).\n\n\n\nRaises\n\nValueErrorWhen the dimension of the vector(s) in a and/or b does not\nequal 2 or 3.\n\n\n\n\n\nSee also\n\ninnerInner product\n\nouterOuter product.\n\nix_Construct index arrays.\n\n\n\nNotes\n\nNew in version 1.9.0.\n\nSupports full broadcasting of the inputs.\nExamples\nVector cross-product.\n&gt;&gt;&gt; x = [1, 2, 3]\n&gt;&gt;&gt; y = [4, 5, 6]\n&gt;&gt;&gt; np.cross(x, y)\narray([-3,  6, -3])\n\n\nOne vector with dimension 2.\n&gt;&gt;&gt; x = [1, 2]\n&gt;&gt;&gt; y = [4, 5, 6]\n&gt;&gt;&gt; np.cross(x, y)\narray([12, -6, -3])\n\n\nEquivalently:\n&gt;&gt;&gt; x = [1, 2, 0]\n&gt;&gt;&gt; y = [4, 5, 6]\n&gt;&gt;&gt; np.cross(x, y)\narray([12, -6, -3])\n\n\nBoth vectors with dimension 2.\n&gt;&gt;&gt; x = [1,2]\n&gt;&gt;&gt; y = [4,5]\n&gt;&gt;&gt; np.cross(x, y)\narray(-3)\n\n\nMultiple vector cross-products. Note that the direction of the cross\nproduct vector is defined by the right-hand rule.\n&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6]])\n&gt;&gt;&gt; y = np.array([[4,5,6], [1,2,3]])\n&gt;&gt;&gt; np.cross(x, y)\narray([[-3,  6, -3],\n       [ 3, -6,  3]])\n\n\nThe orientation of c can be changed using the axisc keyword.\n&gt;&gt;&gt; np.cross(x, y, axisc=0)\narray([[-3,  3],\n       [ 6, -6],\n       [-3,  3]])\n\n\nChange the vector definition of x and y using axisa and axisb.\n&gt;&gt;&gt; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n&gt;&gt;&gt; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n&gt;&gt;&gt; np.cross(x, y)\narray([[ -6,  12,  -6],\n       [  0,   0,   0],\n       [  6, -12,   6]])\n&gt;&gt;&gt; np.cross(x, y, axisa=0, axisb=0)\narray([[-24,  48, -24],\n       [-30,  60, -30],\n       [-36,  72, -36]])\n\n\n", "parameters": ["Parameters", "aarray_like", "barray_like", "axisaint, optional", "axisbint, optional", "axiscint, optional", "axisint, optional", "Returns", "cndarray", "Raises", "ValueError"], "returns": "cndarrayVector cross product(s).", "examples": ["; x = [1, 2, 3]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([-3,  6, -3])\n\n", "; x = [1, 2, 3]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([-3,  6, -3])\n", "; x = [1, 2]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([12, -6, -3])\n\n", "; x = [1, 2]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([12, -6, -3])\n", "; x = [1, 2, 0]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([12, -6, -3])\n\n", "; x = [1, 2, 0]\n; y = [4, 5, 6]\n; np.cross(x, y)\narray([12, -6, -3])\n", "; x = [1,2]\n; y = [4,5]\n; np.cross(x, y)\narray(-3)\n\n", "; x = [1,2]\n; y = [4,5]\n; np.cross(x, y)\narray(-3)\n", "; x = np.array([[1,2,3], [4,5,6]])\n; y = np.array([[4,5,6], [1,2,3]])\n; np.cross(x, y)\narray([[-3,  6, -3],\n       [ 3, -6,  3]])\n\n", "; x = np.array([[1,2,3], [4,5,6]])\n; y = np.array([[4,5,6], [1,2,3]])\n; np.cross(x, y)\narray([[-3,  6, -3],\n       [ 3, -6,  3]])\n", "; np.cross(x, y, axisc=0)\narray([[-3,  3],\n       [ 6, -6],\n       [-3,  3]])\n\n", "; np.cross(x, y, axisc=0)\narray([[-3,  3],\n       [ 6, -6],\n       [-3,  3]])\n", "; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n; np.cross(x, y)\narray([[ -6,  12,  -6],\n       [  0,   0,   0],\n       [  6, -12,   6]])\n; np.cross(x, y, axisa=0, axisb=0)\narray([[-24,  48, -24],\n       [-30,  60, -30],\n       [-36,  72, -36]])\n\n", "; x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])\n; y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])\n; np.cross(x, y)\narray([[ -6,  12,  -6],\n       [  0,   0,   0],\n       [  6, -12,   6]])\n; np.cross(x, y, axisa=0, axisb=0)\narray([[-24,  48, -24],\n       [-30,  60, -30],\n       [-36,  72, -36]])\n"]},
{"library": "numpy", "item_id": "numpy.distutils.cpuinfo.cpu", "code": "\nnumpy.distutils.cpuinfo.cpu = &lt;numpy.distutils.cpuinfo.LinuxCPUInfo object&gt;\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.cov", "code": "\nnumpy.ma.cov(x, y=None, rowvar=True, bias=False, allow_masked=True, ddof=None)[source]\u00b6", "description": "Estimate the covariance matrix.\nExcept for the handling of missing data this function does the same as\nnumpy.cov. For more details and examples, see numpy.cov.\nBy default, masked values are recognized as such. If x and y have the\nsame shape, a common mask is allocated: if x[i,j] is masked, then\ny[i,j] will also be masked.\nSetting allow_masked to False will raise an exception if values are\nmissing in either of the input arrays.\n\nParameters\n\nxarray_likeA 1-D or 2-D array containing multiple variables and observations.\nEach row of x represents a variable, and each column a single\nobservation of all those variables. Also see rowvar below.\n\nyarray_like, optionalAn additional set of variables and observations. y has the same\nform as x.\n\nrowvarbool, optionalIf rowvar is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations.\n\nbiasbool, optionalDefault normalization (False) is by (N-1), where N is the\nnumber of observations given (unbiased estimate). If bias is True,\nthen normalization is by N. This keyword can be overridden by\nthe keyword ddof in numpy versions &gt;= 1.5.\n\nallow_maskedbool, optionalIf True, masked values are propagated pair-wise: if a value is masked\nin x, the corresponding value is masked in y.\nIf False, raises a ValueError exception when some values are missing.\n\nddof{None, int}, optionalIf not None normalization is by (N - ddof), where N is\nthe number of observations; this overrides the value implied by\nbias. The default value is None.\n\nNew in version 1.5.\n\n\n\n\nRaises\n\nValueErrorRaised if some values are missing and allow_masked is False.\n\n\n\n\n\nSee also\nnumpy.cov\n\n", "parameters": ["Parameters", "xarray_like", "yarray_like, optional", "rowvarbool, optional", "biasbool, optional", "allow_maskedbool, optional", "ddof{None, int}, optional", "Raises", "ValueError"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.cov", "code": "\nnumpy.cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None, aweights=None)[source]\u00b6", "description": "Estimate a covariance matrix, given data and weights.\nCovariance indicates the level to which two variables vary together.\nIf we examine N-dimensional samples, ,\nthen the covariance matrix element  is the covariance of\n and . The element  is the variance\nof .\nSee the notes for an outline of the algorithm.\n\nParameters\n\nmarray_likeA 1-D or 2-D array containing multiple variables and observations.\nEach row of m represents a variable, and each column a single\nobservation of all those variables. Also see rowvar below.\n\nyarray_like, optionalAn additional set of variables and observations. y has the same form\nas that of m.\n\nrowvarbool, optionalIf rowvar is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations.\n\nbiasbool, optionalDefault normalization (False) is by (N - 1), where N is the\nnumber of observations given (unbiased estimate). If bias is True,\nthen normalization is by N. These values can be overridden by using\nthe keyword ddof in numpy versions &gt;= 1.5.\n\nddofint, optionalIf not None the default value implied by bias is overridden.\nNote that ddof=1 will return the unbiased estimate, even if both\nfweights and aweights are specified, and ddof=0 will return\nthe simple average. See the notes for the details. The default value\nis None.\n\nNew in version 1.5.\n\n\nfweightsarray_like, int, optional1-D array of integer frequency weights; the number of times each\nobservation vector should be repeated.\n\nNew in version 1.10.\n\n\naweightsarray_like, optional1-D array of observation vector weights. These relative weights are\ntypically large for observations considered \u201cimportant\u201d and smaller for\nobservations considered less \u201cimportant\u201d. If ddof=0 the array of\nweights can be used to assign probabilities to observation vectors.\n\nNew in version 1.10.\n\n\n\n\nReturns\n\noutndarrayThe covariance matrix of the variables.\n\n\n\n\n\nSee also\n\ncorrcoefNormalized covariance matrix\n\n\n\nNotes\nAssume that the observations are in the columns of the observation\narray m and let f = fweights and a = aweights for brevity. The\nsteps to compute the weighted covariance are as follows:\n&gt;&gt;&gt; m = np.arange(10, dtype=np.float64)\n&gt;&gt;&gt; f = np.arange(10) * 2\n&gt;&gt;&gt; a = np.arange(10) ** 2.\n&gt;&gt;&gt; ddof = 1\n&gt;&gt;&gt; w = f * a\n&gt;&gt;&gt; v1 = np.sum(w)\n&gt;&gt;&gt; v2 = np.sum(w * a)\n&gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1\n&gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)\n\n\nNote that when a == 1, the normalization factor\nv1 / (v1**2 - ddof * v2) goes over to 1 / (np.sum(f) - ddof)\nas it should.\nExamples\nConsider two variables,  and , which\ncorrelate perfectly, but in opposite directions:\n&gt;&gt;&gt; x = np.array([[0, 2], [1, 1], [2, 0]]).T\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [2, 1, 0]])\n\n\nNote how  increases while  decreases. The covariance\nmatrix shows this clearly:\n&gt;&gt;&gt; np.cov(x)\narray([[ 1., -1.],\n       [-1.,  1.]])\n\n\nNote that element , which shows the correlation between\n and , is negative.\nFurther, note how x and y are combined:\n&gt;&gt;&gt; x = [-2.1, -1,  4.3]\n&gt;&gt;&gt; y = [3,  1.1,  0.12]\n&gt;&gt;&gt; X = np.stack((x, y), axis=0)\n&gt;&gt;&gt; np.cov(X)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n&gt;&gt;&gt; np.cov(x, y)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n&gt;&gt;&gt; np.cov(x)\narray(11.71)\n\n\n", "parameters": ["Parameters", "marray_like", "yarray_like, optional", "rowvarbool, optional", "biasbool, optional", "ddofint, optional", "fweightsarray_like, int, optional", "aweightsarray_like, optional", "Returns", "outndarray"], "returns": "outndarrayThe covariance matrix of the variables.", "examples": ["; x = np.array([[0, 2], [1, 1], [2, 0]]).T\n; x\narray([[0, 1, 2],\n       [2, 1, 0]])\n\n", "; x = np.array([[0, 2], [1, 1], [2, 0]]).T\n; x\narray([[0, 1, 2],\n       [2, 1, 0]])\n", "; np.cov(x)\narray([[ 1., -1.],\n       [-1.,  1.]])\n\n", "; np.cov(x)\narray([[ 1., -1.],\n       [-1.,  1.]])\n", "; x = [-2.1, -1,  4.3]\n; y = [3,  1.1,  0.12]\n; X = np.stack((x, y), axis=0)\n; np.cov(X)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n; np.cov(x, y)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n; np.cov(x)\narray(11.71)\n\n", "; x = [-2.1, -1,  4.3]\n; y = [3,  1.1,  0.12]\n; X = np.stack((x, y), axis=0)\n; np.cov(X)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n; np.cov(x, y)\narray([[11.71      , -4.286     ], # may vary\n       [-4.286     ,  2.144133]])\n; np.cov(x)\narray(11.71)\n"]},
{"library": "numpy", "item_id": "numpy.count_nonzero", "code": "\nnumpy.count_nonzero(a, axis=None)[source]\u00b6", "description": "Counts the number of non-zero values in the array a.\nThe word \u201cnon-zero\u201d is in reference to the Python 2.x\nbuilt-in method __nonzero__() (renamed __bool__()\nin Python 3.x) of Python objects that tests an object\u2019s\n\u201ctruthfulness\u201d. For example, any number is considered\ntruthful if it is nonzero, whereas any string is considered\ntruthful if it is not the empty string. Thus, this function\n(recursively) counts how many elements in a (and in\nsub-arrays thereof) have their __nonzero__() or __bool__()\nmethod evaluated to True.\n\nParameters\n\naarray_likeThe array for which to count non-zeros.\n\naxisint or tuple, optionalAxis or tuple of axes along which to count non-zeros.\nDefault is None, meaning that non-zeros will be counted\nalong a flattened version of a.\n\nNew in version 1.12.0.\n\n\n\n\nReturns\n\ncountint or array of intNumber of non-zero values in the array along a given axis.\nOtherwise, the total number of non-zero values in the array\nis returned.\n\n\n\n\n\nSee also\n\nnonzeroReturn the coordinates of all the non-zero values.\n\n\n\nExamples\n&gt;&gt;&gt; np.count_nonzero(np.eye(4))\n4\n&gt;&gt;&gt; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n5\n&gt;&gt;&gt; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\narray([2, 3])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint or tuple, optional", "Returns", "countint or array of int"], "returns": "countint or array of intNumber of non-zero values in the array along a given axis.Otherwise, the total number of non-zero values in the arrayis returned.", "examples": ["; np.count_nonzero(np.eye(4))\n4\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n5\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\narray([1, 1, 1, 1, 1])\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\narray([2, 3])\n\n", "; np.count_nonzero(np.eye(4))\n4\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])\n5\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)\narray([1, 1, 1, 1, 1])\n; np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)\narray([2, 3])\n"]},
{"library": "numpy", "item_id": "numpy.ma.count_masked", "code": "\nnumpy.ma.count_masked(arr, axis=None)[source]\u00b6", "description": "Count the number of masked elements along the given axis.\n\nParameters\n\narrarray_likeAn array with (possibly) masked elements.\n\naxisint, optionalAxis along which to count. If None (default), a flattened\nversion of the array is used.\n\n\n\nReturns\n\ncountint, ndarrayThe total number of masked elements (axis=None) or the number\nof masked elements along each slice of the given axis.\n\n\n\n\n\nSee also\n\nMaskedArray.countCount non-masked elements.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = np.arange(9).reshape((3,3))\n&gt;&gt;&gt; a = ma.array(a)\n&gt;&gt;&gt; a[1, 0] = ma.masked\n&gt;&gt;&gt; a[1, 2] = ma.masked\n&gt;&gt;&gt; a[2, 1] = ma.masked\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; ma.count_masked(a)\n3\n\n\nWhen the axis keyword is used an array is returned.\n&gt;&gt;&gt; ma.count_masked(a, axis=0)\narray([1, 1, 1])\n&gt;&gt;&gt; ma.count_masked(a, axis=1)\narray([0, 2, 1])\n\n\n", "parameters": ["Parameters", "arrarray_like", "axisint, optional", "Returns", "countint, ndarray"], "returns": "countint, ndarrayThe total number of masked elements (axis=None) or the numberof masked elements along each slice of the given axis.", "examples": ["; import numpy.ma as ma\n; a = np.arange(9).reshape((3,3))\n; a = ma.array(a)\n; a[1, 0] = ma.masked\n; a[1, 2] = ma.masked\n; a[2, 1] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; ma.count_masked(a)\n3\n\n", "; import numpy.ma as ma\n; a = np.arange(9).reshape((3,3))\n; a = ma.array(a)\n; a[1, 0] = ma.masked\n; a[1, 2] = ma.masked\n; a[2, 1] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, 4, --],\n        [6, --, 8]],\n  mask=[[False, False, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; ma.count_masked(a)\n3\n", "; ma.count_masked(a, axis=0)\narray([1, 1, 1])\n; ma.count_masked(a, axis=1)\narray([0, 2, 1])\n\n", "; ma.count_masked(a, axis=0)\narray([1, 1, 1])\n; ma.count_masked(a, axis=1)\narray([0, 2, 1])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.count", "code": "\nMaskedArray.count(self, axis=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Count the non-masked elements of the array along the given axis.\n\nParameters\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.10.0.\n\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nresultndarray or scalarAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if axis is None, a\nscalar is returned.\n\n\n\n\n\nSee also\n\ncount_maskedCount masked elements in array or along a given axis.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))\n&gt;&gt;&gt; a[1, :] = ma.masked\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; a.count()\n3\n\n\nWhen the axis keyword is specified an array of appropriate size is\nreturned.\n&gt;&gt;&gt; a.count(axis=0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.count(axis=1)\narray([3, 0])\n\n\n", "parameters": ["Parameters", "axisNone or int or tuple of ints, optional", "keepdimsbool, optional", "Returns", "resultndarray or scalar"], "returns": "resultndarray or scalarAn array with the same shape as the input array, with the specifiedaxis removed. If the array is a 0-d array, or if axis is None, ascalar is returned.", "examples": ["; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n\n", "; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.count", "code": "\nmasked_array.count(self, axis=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Count the non-masked elements of the array along the given axis.\n\nParameters\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.10.0.\n\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nresultndarray or scalarAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if axis is None, a\nscalar is returned.\n\n\n\n\n\nSee also\n\ncount_maskedCount masked elements in array or along a given axis.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))\n&gt;&gt;&gt; a[1, :] = ma.masked\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; a.count()\n3\n\n\nWhen the axis keyword is specified an array of appropriate size is\nreturned.\n&gt;&gt;&gt; a.count(axis=0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.count(axis=1)\narray([3, 0])\n\n\n", "parameters": ["Parameters", "axisNone or int or tuple of ints, optional", "keepdimsbool, optional", "Returns", "resultndarray or scalar"], "returns": "resultndarray or scalarAn array with the same shape as the input array, with the specifiedaxis removed. If the array is a 0-d array, or if axis is None, ascalar is returned.", "examples": ["; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n\n", "; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.count", "code": "\nchararray.count(self, sub, start=0, end=None)[source]\u00b6", "description": "Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].\n\nSee also\nchar.count\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.count", "code": "\nchararray.count(self, sub, start=0, end=None)\u00b6", "description": "Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].\n\nSee also\nchar.count\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.count", "code": "\nnumpy.char.count(a, sub, start=0, end=None)\u00b6", "description": "Returns an array with the number of non-overlapping occurrences of\nsubstring sub in the range [start, end].\nCalls str.count element-wise.\n\nParameters\n\naarray_like of str or unicode\nsubstr or unicodeThe substring to search for.\n\nstart, endint, optionalOptional arguments start and end are interpreted as slice\nnotation to specify the range in which to count.\n\n\n\nReturns\n\noutndarrayOutput array of ints.\n\n\n\n\n\nSee also\nstr.count\n\nExamples\n&gt;&gt;&gt; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n&gt;&gt;&gt; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n&gt;&gt;&gt; np.char.count(c, 'A')\narray([3, 1, 1])\n&gt;&gt;&gt; np.char.count(c, 'aA')\narray([3, 1, 0])\n&gt;&gt;&gt; np.char.count(c, 'A', start=1, end=4)\narray([2, 1, 1])\n&gt;&gt;&gt; np.char.count(c, 'A', start=1, end=3)\narray([1, 0, 0])\n\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "substr or unicode", "start, endint, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of ints.", "examples": ["; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.count(c, 'A')\narray([3, 1, 1])\n; np.char.count(c, 'aA')\narray([3, 1, 0])\n; np.char.count(c, 'A', start=1, end=4)\narray([2, 1, 1])\n; np.char.count(c, 'A', start=1, end=3)\narray([1, 0, 0])\n\n", "; c = np.array(['aAaAaA', '  aA  ', 'abBABba'])\n; c\narray(['aAaAaA', '  aA  ', 'abBABba'], dtype='&lt;U7')\n; np.char.count(c, 'A')\narray([3, 1, 1])\n; np.char.count(c, 'aA')\narray([3, 1, 0])\n; np.char.count(c, 'A', start=1, end=4)\narray([2, 1, 1])\n; np.char.count(c, 'A', start=1, end=3)\narray([1, 0, 0])\n"]},
{"library": "numpy", "item_id": "numpy.cosh", "code": "\nnumpy.cosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'cosh'&gt;\u00b6", "description": "Hyperbolic cosine, element-wise.\nEquivalent to 1/2 * (np.exp(x) + np.exp(-x)) and np.cos(1j*x).\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOutput array of same shape as x.\nThis is a scalar if x is a scalar.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.cosh(0)\n1.0\n\n\nThe hyperbolic cosine describes the shape of a hanging cable:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.linspace(-4, 4, 1000)\n&gt;&gt;&gt; plt.plot(x, np.cosh(x))\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOutput array of same shape as x.This is a scalar if x is a scalar.", "examples": ["; np.cosh(0)\n1.0\n\n", "; np.cosh(0)\n1.0\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-4, 4, 1000)\n; plt.plot(x, np.cosh(x))\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-4, 4, 1000)\n; plt.plot(x, np.cosh(x))\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.ma.count", "code": "\nnumpy.ma.count(self, axis=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Count the non-masked elements of the array along the given axis.\n\nParameters\n\naxisNone or int or tuple of ints, optionalAxis or axes along which the count is performed.\nThe default, None, performs the count over all\nthe dimensions of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.10.0.\n\nIf this is a tuple of ints, the count is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the array.\n\n\n\nReturns\n\nresultndarray or scalarAn array with the same shape as the input array, with the specified\naxis removed. If the array is a 0-d array, or if axis is None, a\nscalar is returned.\n\n\n\n\n\nSee also\n\ncount_maskedCount masked elements in array or along a given axis.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))\n&gt;&gt;&gt; a[1, :] = ma.masked\n&gt;&gt;&gt; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n&gt;&gt;&gt; a.count()\n3\n\n\nWhen the axis keyword is specified an array of appropriate size is\nreturned.\n&gt;&gt;&gt; a.count(axis=0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.count(axis=1)\narray([3, 0])\n\n\n", "parameters": ["Parameters", "axisNone or int or tuple of ints, optional", "keepdimsbool, optional", "Returns", "resultndarray or scalar"], "returns": "resultndarray or scalarAn array with the same shape as the input array, with the specifiedaxis removed. If the array is a 0-d array, or if axis is None, ascalar is returned.", "examples": ["; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n\n", "; import numpy.ma as ma\n; a = ma.arange(6).reshape((2, 3))\n; a[1, :] = ma.masked\n; a\nmasked_array(\n  data=[[0, 1, 2],\n        [--, --, --]],\n  mask=[[False, False, False],\n        [ True,  True,  True]],\n  fill_value=999999)\n; a.count()\n3\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n\n", "; a.count(axis=0)\narray([1, 1, 1])\n; a.count(axis=1)\narray([3, 0])\n"]},
{"library": "numpy", "item_id": "numpy.correlate", "code": "\nnumpy.correlate(a, v, mode='valid')[source]\u00b6", "description": "Cross-correlation of two 1-dimensional sequences.\nThis function computes the correlation as generally defined in signal\nprocessing texts:\nc_{av}[k] = sum_n a[n+k] * conj(v[n])\n\n\nwith a and v sequences being zero-padded where necessary and conj being\nthe conjugate.\n\nParameters\n\na, varray_likeInput sequences.\n\nmode{\u2018valid\u2019, \u2018same\u2019, \u2018full\u2019}, optionalRefer to the convolve docstring.  Note that the default\nis \u2018valid\u2019, unlike convolve, which uses \u2018full\u2019.\n\nold_behaviorboolold_behavior was removed in NumPy 1.10. If you need the old\nbehavior, use multiarray.correlate.\n\n\n\nReturns\n\noutndarrayDiscrete cross-correlation of a and v.\n\n\n\n\n\nSee also\n\nconvolveDiscrete, linear convolution of two one-dimensional sequences.\n\nmultiarray.correlateOld, no conjugate, version of correlate.\n\n\n\nNotes\nThe definition of correlation above is not unique and sometimes correlation\nmay be defined differently. Another common definition is:\nc'_{av}[k] = sum_n a[n] conj(v[n+k])\n\n\nwhich is related to c_{av}[k] by c'_{av}[k] = c_{av}[-k].\nExamples\n&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5])\narray([3.5])\n&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\narray([2. ,  3.5,  3. ])\n&gt;&gt;&gt; np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\narray([0.5,  2. ,  3.5,  3. ,  0. ])\n\n\nUsing complex sequences:\n&gt;&gt;&gt; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\narray([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n\n\nNote that you get the time reversed, complex conjugated result\nwhen the two input sequences change places, i.e.,\nc_{va}[k] = c^{*}_{av}[-k]:\n&gt;&gt;&gt; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\narray([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n\n\n", "parameters": ["Parameters", "a, varray_like", "mode{\u2018valid\u2019, \u2018same\u2019, \u2018full\u2019}, optional", "old_behaviorbool", "Returns", "outndarray"], "returns": "outndarrayDiscrete cross-correlation of a and v.", "examples": ["; np.correlate([1, 2, 3], [0, 1, 0.5])\narray([3.5])\n; np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\narray([2. ,  3.5,  3. ])\n; np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\narray([0.5,  2. ,  3.5,  3. ,  0. ])\n\n", "; np.correlate([1, 2, 3], [0, 1, 0.5])\narray([3.5])\n; np.correlate([1, 2, 3], [0, 1, 0.5], \"same\")\narray([2. ,  3.5,  3. ])\n; np.correlate([1, 2, 3], [0, 1, 0.5], \"full\")\narray([0.5,  2. ,  3.5,  3. ,  0. ])\n", "; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\narray([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n\n", "; np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')\narray([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])\n", "; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\narray([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n\n", "; np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')\narray([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])\n"]},
{"library": "numpy", "item_id": "numpy.corrcoef", "code": "\nnumpy.corrcoef(x, y=None, rowvar=True, bias=&lt;no value&gt;, ddof=&lt;no value&gt;)[source]\u00b6", "description": "Return Pearson product-moment correlation coefficients.\nPlease refer to the documentation for cov for more detail.  The\nrelationship between the correlation coefficient matrix, R, and the\ncovariance matrix, C, is\n\n\nThe values of R are between -1 and 1, inclusive.\n\nParameters\n\nxarray_likeA 1-D or 2-D array containing multiple variables and observations.\nEach row of x represents a variable, and each column a single\nobservation of all those variables. Also see rowvar below.\n\nyarray_like, optionalAn additional set of variables and observations. y has the same\nshape as x.\n\nrowvarbool, optionalIf rowvar is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations.\n\nbias_NoValue, optionalHas no effect, do not use.\n\nDeprecated since version 1.10.0.\n\n\nddof_NoValue, optionalHas no effect, do not use.\n\nDeprecated since version 1.10.0.\n\n\n\n\nReturns\n\nRndarrayThe correlation coefficient matrix of the variables.\n\n\n\n\n\nSee also\n\ncovCovariance matrix\n\n\n\nNotes\nDue to floating point rounding the resulting array may not be Hermitian,\nthe diagonal elements may not be 1, and the elements may not satisfy the\ninequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the\ninterval [-1,  1] in an attempt to improve on that situation but is not\nmuch help in the complex case.\nThis function accepts but discards arguments bias and ddof.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.\n", "parameters": ["Parameters", "xarray_like", "yarray_like, optional", "rowvarbool, optional", "bias_NoValue, optional", "ddof_NoValue, optional", "Returns", "Rndarray"], "returns": "RndarrayThe correlation coefficient matrix of the variables.", "examples": []},
{"library": "numpy", "item_id": "numpy.copyto", "code": "\nnumpy.copyto(dst, src, casting='same_kind', where=True)\u00b6", "description": "Copies values from one array to another, broadcasting as necessary.\nRaises a TypeError if the casting rule is violated, and if\nwhere is provided, it selects which elements to copy.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndstndarrayThe array into which values are copied.\n\nsrcarray_likeThe array from which values are copied.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur when copying.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nwherearray_like of bool, optionalA boolean array which is broadcasted to match the dimensions\nof dst, and selects elements to copy from src to dst\nwherever it contains the value True.\n\n\n\n\n", "parameters": ["Parameters", "dstndarray", "srcarray_like", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "wherearray_like of bool, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.cos", "code": "\nnumpy.cos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'cos'&gt;\u00b6", "description": "Cosine element-wise.\n\nParameters\n\nxarray_likeInput array in radians.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe corresponding cosine values.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nIf out is provided, the function writes the result into it,\nand returns a reference to out.  (See Examples)\nReferences\nM. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.\nNew York, NY: Dover, 1972.\nExamples\n&gt;&gt;&gt; np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example of providing the optional output parameter\n&gt;&gt;&gt; out1 = np.array([0], dtype='d')\n&gt;&gt;&gt; out2 = np.cos([0.1], out1)\n&gt;&gt;&gt; out2 is out1\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Example of ValueError due to provision of shape mis-matched `out`\n&gt;&gt;&gt; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe corresponding cosine values.This is a scalar if x is a scalar.", "examples": ["; np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n;\n; # Example of providing the optional output parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.cos([0.1], out1)\n; out2 is out1\nTrue\n;\n; # Example of ValueError due to provision of shape mis-matched `out`\n; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n\n", "; np.cos(np.array([0, np.pi/2, np.pi]))\narray([  1.00000000e+00,   6.12303177e-17,  -1.00000000e+00])\n;\n; # Example of providing the optional output parameter\n; out1 = np.array([0], dtype='d')\n; out2 = np.cos([0.1], out1)\n; out2 is out1\nTrue\n;\n; # Example of ValueError due to provision of shape mis-matched `out`\n; np.cos(np.zeros((3,3)),np.zeros((2,2)))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nValueError: operands could not be broadcast together with shapes (3,3) (2,2)\n"]},
{"library": "numpy", "item_id": "numpy.ma.corrcoef", "code": "\nnumpy.ma.corrcoef(x, y=None, rowvar=True, bias=&lt;no value&gt;, allow_masked=True, ddof=&lt;no value&gt;)[source]\u00b6", "description": "Return Pearson product-moment correlation coefficients.\nExcept for the handling of missing data this function does the same as\nnumpy.corrcoef. For more details and examples, see numpy.corrcoef.\n\nParameters\n\nxarray_likeA 1-D or 2-D array containing multiple variables and observations.\nEach row of x represents a variable, and each column a single\nobservation of all those variables. Also see rowvar below.\n\nyarray_like, optionalAn additional set of variables and observations. y has the same\nshape as x.\n\nrowvarbool, optionalIf rowvar is True (default), then each row represents a\nvariable, with observations in the columns. Otherwise, the relationship\nis transposed: each column represents a variable, while the rows\ncontain observations.\n\nbias_NoValue, optionalHas no effect, do not use.\n\nDeprecated since version 1.10.0.\n\n\nallow_maskedbool, optionalIf True, masked values are propagated pair-wise: if a value is masked\nin x, the corresponding value is masked in y.\nIf False, raises an exception.  Because bias is deprecated, this\nargument needs to be treated as keyword only to avoid a warning.\n\nddof_NoValue, optionalHas no effect, do not use.\n\nDeprecated since version 1.10.0.\n\n\n\n\n\n\nSee also\n\nnumpy.corrcoefEquivalent function in top-level NumPy module.\n\ncovEstimate the covariance matrix.\n\n\n\nNotes\nThis function accepts but discards arguments bias and ddof.  This is\nfor backwards compatibility with previous versions of this function.  These\narguments had no effect on the return values of the function and can be\nsafely ignored in this and previous versions of numpy.\n", "parameters": ["Parameters", "xarray_like", "yarray_like, optional", "rowvarbool, optional", "bias_NoValue, optional", "allow_maskedbool, optional", "ddof_NoValue, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.copy", "code": "\nrecord.copy()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.copysign", "code": "\nnumpy.copysign(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'copysign'&gt;\u00b6", "description": "Change the sign of x1 to that of x2, element-wise.\nIf x2 is a scalar, its sign will be copied to all elements of x1.\n\nParameters\n\nx1array_likeValues to change the sign of.\n\nx2array_likeThe sign of x2 is copied to x1. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarThe values of x1 with the sign of x2.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.copysign(1.3, -1)\n-1.3\n&gt;&gt;&gt; 1/np.copysign(0, 1)\ninf\n&gt;&gt;&gt; 1/np.copysign(0, -1)\n-inf\n\n\n&gt;&gt;&gt; np.copysign([-1, 0, 1], -1.1)\narray([-1., -0., -1.])\n&gt;&gt;&gt; np.copysign([-1, 0, 1], np.arange(3)-1)\narray([-1.,  0.,  1.])\n\n\n", "parameters": ["Parameters", "x1array_like", "x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarThe values of x1 with the sign of x2.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.copysign(1.3, -1)\n-1.3\n; 1/np.copysign(0, 1)\ninf\n; 1/np.copysign(0, -1)\n-inf\n\n", "; np.copysign(1.3, -1)\n-1.3\n; 1/np.copysign(0, 1)\ninf\n; 1/np.copysign(0, -1)\n-inf\n", "; np.copysign([-1, 0, 1], -1.1)\narray([-1., -0., -1.])\n; np.copysign([-1, 0, 1], np.arange(3)-1)\narray([-1.,  0.,  1.])\n\n", "; np.copysign([-1, 0, 1], -1.1)\narray([-1., -0., -1.])\n; np.copysign([-1, 0, 1], np.arange(3)-1)\narray([-1.,  0.,  1.])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.copy", "code": "\nrecarray.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.copy", "code": "\nPolynomial.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.copy", "code": "\nLegendre.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.copy", "code": "\nLaguerre.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.copy", "code": "\nHermiteE.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.copy", "code": "\nChebyshev.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.copy", "code": "\nnditer.copy()\u00b6", "description": "Get a copy of the iterator in its current state.\nExamples\n&gt;&gt;&gt; x = np.arange(10)\n&gt;&gt;&gt; y = x + 1\n&gt;&gt;&gt; it = np.nditer([x, y])\n&gt;&gt;&gt; next(it)\n(array(0), array(1))\n&gt;&gt;&gt; it2 = it.copy()\n&gt;&gt;&gt; next(it2)\n(array(1), array(2))\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(10)\n; y = x + 1\n; it = np.nditer([x, y])\n; next(it)\n(array(0), array(1))\n; it2 = it.copy()\n; next(it2)\n(array(1), array(2))\n\n", "; x = np.arange(10)\n; y = x + 1\n; it = np.nditer([x, y])\n; next(it)\n(array(0), array(1))\n; it2 = it.copy()\n; next(it2)\n(array(1), array(2))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.copy", "code": "\nHermite.copy(self)[source]\u00b6", "description": "Return a copy.\n\nReturns\n\nnew_seriesseriesCopy of self.\n\n\n\n\n", "parameters": [], "returns": "new_seriesseriesCopy of self.", "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.copy", "code": "\nndarray.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.memmap.copy", "code": "\nmemmap.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.matrix.copy", "code": "\nmatrix.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.copy", "code": "\nMaskType.copy()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.copy", "code": "\nMaskedArray.copy(order='C')[source]\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.lib.user_array.container.copy", "code": "\ncontainer.copy(self)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.copy", "code": "\nmasked_array.copy(order='C')[source]\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.generic.copy", "code": "\ngeneric.copy()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.flatiter.copy", "code": "\nflatiter.copy()\u00b6", "description": "Get a copy of the iterator as a 1-D array.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; fl = x.flat\n&gt;&gt;&gt; fl.copy()\narray([0, 1, 2, 3, 4, 5])\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(6).reshape(2, 3)\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; fl = x.flat\n; fl.copy()\narray([0, 1, 2, 3, 4, 5])\n\n", "; x = np.arange(6).reshape(2, 3)\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; fl = x.flat\n; fl.copy()\narray([0, 1, 2, 3, 4, 5])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.copy", "code": "\nchararray.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.copy", "code": "\nchararray.copy(order='C')\u00b6", "description": "Return a copy of the array.\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\n\nSee also\nnumpy.copy, numpy.copyto\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.copy", "code": "\nnumpy.copy(a, order='K')[source]\u00b6", "description": "Return an array copy of the given object.\n\nParameters\n\naarray_likeInput data.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and ndarray.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\nReturns\n\narrndarrayArray interpretation of a.\n\n\n\n\nNotes\nThis is equivalent to:\n&gt;&gt;&gt; np.array(a, copy=True)  \n\n\nExamples\nCreate an array x, with a reference y and a copy z:\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; y = x\n&gt;&gt;&gt; z = np.copy(x)\n\n\nNote that, when we modify x, y changes, but not z:\n&gt;&gt;&gt; x[0] = 10\n&gt;&gt;&gt; x[0] == y[0]\nTrue\n&gt;&gt;&gt; x[0] == z[0]\nFalse\n\n\n", "parameters": ["Parameters", "aarray_like", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "Returns", "arrndarray"], "returns": "arrndarrayArray interpretation of a.", "examples": ["; x = np.array([1, 2, 3])\n; y = x\n; z = np.copy(x)\n\n", "; x = np.array([1, 2, 3])\n; y = x\n; z = np.copy(x)\n", "; x[0] = 10\n; x[0] == y[0]\nTrue\n; x[0] == z[0]\nFalse\n\n", "; x[0] = 10\n; x[0] == y[0]\nTrue\n; x[0] == z[0]\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.convolve", "code": "\nnumpy.convolve(a, v, mode='full')[source]\u00b6", "description": "Returns the discrete, linear convolution of two one-dimensional sequences.\nThe convolution operator is often seen in signal processing, where it\nmodels the effect of a linear time-invariant system on a signal [1].  In\nprobability theory, the sum of two independent random variables is\ndistributed according to the convolution of their individual\ndistributions.\nIf v is longer than a, the arrays are swapped before computation.\n\nParameters\n\na(N,) array_likeFirst one-dimensional input array.\n\nv(M,) array_likeSecond one-dimensional input array.\n\nmode{\u2018full\u2019, \u2018valid\u2019, \u2018same\u2019}, optional\n\u2018full\u2019:By default, mode is \u2018full\u2019.  This returns the convolution\nat each point of overlap, with an output shape of (N+M-1,). At\nthe end-points of the convolution, the signals do not overlap\ncompletely, and boundary effects may be seen.\n\n\u2018same\u2019:Mode \u2018same\u2019 returns output of length max(M, N).  Boundary\neffects are still visible.\n\n\u2018valid\u2019:Mode \u2018valid\u2019 returns output of length\nmax(M, N) - min(M, N) + 1.  The convolution product is only given\nfor points where the signals overlap completely.  Values outside\nthe signal boundary have no effect.\n\n\n\n\n\nReturns\n\noutndarrayDiscrete, linear convolution of a and v.\n\n\n\n\n\nSee also\n\nscipy.signal.fftconvolveConvolve two arrays using the Fast Fourier Transform.\n\nscipy.linalg.toeplitzUsed to construct the convolution operator.\n\npolymulPolynomial multiplication. Same output as convolve, but also accepts poly1d objects as input.\n\n\n\nNotes\nThe discrete convolution operation is defined as\n\n\nIt can be shown that a convolution  in time/space\nis equivalent to the multiplication  in the Fourier\ndomain, after appropriate padding (padding is necessary to prevent\ncircular convolution).  Since multiplication is more efficient (faster)\nthan convolution, the function scipy.signal.fftconvolve exploits the\nFFT to calculate the convolution of large data-sets.\nReferences\n\n1\nWikipedia, \u201cConvolution\u201d,\nhttps://en.wikipedia.org/wiki/Convolution\n\n\nExamples\nNote how the convolution operator flips the second array\nbefore \u201csliding\u201d the two across one another:\n&gt;&gt;&gt; np.convolve([1, 2, 3], [0, 1, 0.5])\narray([0. , 1. , 2.5, 4. , 1.5])\n\n\nOnly return the middle values of the convolution.\nContains boundary effects, where zeros are taken\ninto account:\n&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'same')\narray([1. ,  2.5,  4. ])\n\n\nThe two arrays are of the same length, so there\nis only one position where they completely overlap:\n&gt;&gt;&gt; np.convolve([1,2,3],[0,1,0.5], 'valid')\narray([2.5])\n\n\n", "parameters": ["Parameters", "a(N,) array_like", "v(M,) array_like", "mode{\u2018full\u2019, \u2018valid\u2019, \u2018same\u2019}, optional", "\u2018full\u2019:", "\u2018same\u2019:", "\u2018valid\u2019:", "Returns", "outndarray"], "returns": "outndarrayDiscrete, linear convolution of a and v.", "examples": ["; np.convolve([1, 2, 3], [0, 1, 0.5])\narray([0. , 1. , 2.5, 4. , 1.5])\n\n", "; np.convolve([1, 2, 3], [0, 1, 0.5])\narray([0. , 1. , 2.5, 4. , 1.5])\n", "; np.convolve([1,2,3],[0,1,0.5], 'same')\narray([1. ,  2.5,  4. ])\n\n", "; np.convolve([1,2,3],[0,1,0.5], 'same')\narray([1. ,  2.5,  4. ])\n", "; np.convolve([1,2,3],[0,1,0.5], 'valid')\narray([2.5])\n\n", "; np.convolve([1,2,3],[0,1,0.5], 'valid')\narray([2.5])\n"]},
{"library": "numpy", "item_id": "numpy.ma.copy", "code": "\nnumpy.ma.copy(self, *args, **params) a.copy(order='C') = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "\nReturn a copy of the array.\n\n\nParameters\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout of the copy. \u2018C\u2019 means C-order,\n\u2018F\u2019 means F-order, \u2018A\u2019 means \u2018F\u2019 if a is Fortran contiguous,\n\u2018C\u2019 otherwise. \u2018K\u2019 means match the layout of a as closely\nas possible. (Note that this function and numpy.copy are very\nsimilar, but have different default values for their order=\narguments.)\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n\n&gt;&gt;&gt; y = x.copy()\n\n\n&gt;&gt;&gt; x.fill(0)\n\n\n&gt;&gt;&gt; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n\n&gt;&gt;&gt; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n&gt;&gt;&gt; y.flags['C_CONTIGUOUS']\nTrue\n\n\n", "parameters": ["Parameters", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional"], "returns": [], "examples": ["; x = np.array([[1,2,3],[4,5,6]], order='F')\n\n", "; x = np.array([[1,2,3],[4,5,6]], order='F')\n", "; y = x.copy()\n\n", "; y = x.copy()\n", "; x.fill(0)\n\n", "; x.fill(0)\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n\n", "; x\narray([[0, 0, 0],\n       [0, 0, 0]])\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n", "; y\narray([[1, 2, 3],\n       [4, 5, 6]])\n", "; y.flags['C_CONTIGUOUS']\nTrue\n\n", "; y.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.flatiter.coords", "code": "\nflatiter.coords\u00b6", "description": "An N-dimensional tuple of current coordinates.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2, 3)\n&gt;&gt;&gt; fl = x.flat\n&gt;&gt;&gt; fl.coords\n(0, 0)\n&gt;&gt;&gt; next(fl)\n0\n&gt;&gt;&gt; fl.coords\n(0, 1)\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; fl.coords\n(0, 0)\n; next(fl)\n0\n; fl.coords\n(0, 1)\n\n", "; x = np.arange(6).reshape(2, 3)\n; fl = x.flat\n; fl.coords\n(0, 0)\n; next(fl)\n0\n; fl.coords\n(0, 1)\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.convert", "code": "\nPolynomial.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.convert", "code": "\nLegendre.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.convert", "code": "\nHermiteE.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.convert", "code": "\nHermite.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.convert", "code": "\nLaguerre.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.convert", "code": "\nChebyshev.convert(self, domain=None, kind=None, window=None)[source]\u00b6", "description": "Convert series to a different kind and/or domain and/or window.\n\nParameters\n\ndomainarray_like, optionalThe domain of the converted series. If the value is None,\nthe default domain of kind is used.\n\nkindclass, optionalThe polynomial series type class to which the current instance\nshould be converted. If kind is None, then the class of the\ncurrent instance is used.\n\nwindowarray_like, optionalThe window of the converted series. If the value is None,\nthe default window of kind is used.\n\n\n\nReturns\n\nnew_seriesseriesThe returned class can be of different type than the current\ninstance and/or have a different domain and/or different\nwindow.\n\n\n\n\nNotes\nConversion between domains and class types can result in\nnumerically ill defined series.\n", "parameters": ["Parameters", "domainarray_like, optional", "kindclass, optional", "windowarray_like, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesThe returned class can be of different type than the currentinstance and/or have a different domain and/or differentwindow.", "examples": []},
{"library": "numpy", "item_id": "numpy.lib.user_array.container", "code": "\nclass numpy.lib.user_array.container(data, dtype=None, copy=True)[source]\u00b6", "description": "Standard container-class for easy multiple-inheritance.\nMethods\n\n\n\n\n\n\ncopy\n\n\ntostring\n\n\nbyteswap\n\n\nastype\n\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.conjugate", "code": "\nrecord.conjugate()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.conjugate", "code": "\nrecarray.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.conjugate", "code": "\nndarray.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.conjugate", "code": "\nmemmap.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.conjugate", "code": "\nmatrix.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.conjugate", "code": "\nMaskType.conjugate()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.conjugate", "code": "\nMaskedArray.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.conjugate", "code": "\nmasked_array.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.conjugate", "code": "\ngeneric.conjugate()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.conjugate", "code": "\nchararray.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.conjugate", "code": "\nchararray.conjugate()\u00b6", "description": "Return the complex conjugate, element-wise.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.conjugate", "code": "\nnumpy.ma.conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;numpy.ma.core._MaskedUnaryOperation object&gt;\u00b6", "description": "Return the complex conjugate, element-wise.\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n\nxarray_likeInput value.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe complex conjugate of x, with same dtype as y.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nconj is an alias for conjugate:\n&gt;&gt;&gt; np.conj is np.conjugate\nTrue\n\n\nExamples\n&gt;&gt;&gt; np.conjugate(1+2j)\n(1-2j)\n\n\n&gt;&gt;&gt; x = np.eye(2) + 1j * np.eye(2)\n&gt;&gt;&gt; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.", "examples": ["; np.conjugate(1+2j)\n(1-2j)\n\n", "; np.conjugate(1+2j)\n(1-2j)\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n"]},
{"library": "numpy", "item_id": "numpy.conjugate", "code": "\nnumpy.conjugate(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'conjugate'&gt;\u00b6", "description": "Return the complex conjugate, element-wise.\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n\nxarray_likeInput value.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe complex conjugate of x, with same dtype as y.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nconj is an alias for conjugate:\n&gt;&gt;&gt; np.conj is np.conjugate\nTrue\n\n\nExamples\n&gt;&gt;&gt; np.conjugate(1+2j)\n(1-2j)\n\n\n&gt;&gt;&gt; x = np.eye(2) + 1j * np.eye(2)\n&gt;&gt;&gt; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.", "examples": ["; np.conjugate(1+2j)\n(1-2j)\n\n", "; np.conjugate(1+2j)\n(1-2j)\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n"]},
{"library": "numpy", "item_id": "numpy.record.conj", "code": "\nrecord.conj()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.conj", "code": "\nrecarray.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.conj", "code": "\nndarray.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.conj", "code": "\nmemmap.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.conj", "code": "\nmatrix.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.conj", "code": "\nMaskType.conj()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.conj", "code": "\nMaskedArray.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.conj", "code": "\nmasked_array.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.conj", "code": "\ngeneric.conj()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.conj", "code": "\nchararray.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.conj", "code": "\nchararray.conj()\u00b6", "description": "Complex-conjugate all elements.\nRefer to numpy.conjugate for full documentation.\n\nSee also\n\nnumpy.conjugateequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.cond", "code": "\nnumpy.linalg.cond(x, p=None)[source]\u00b6", "description": "Compute the condition number of a matrix.\nThis function is capable of returning the condition number using\none of seven different norms, depending on the value of p (see\nParameters below).\n\nParameters\n\nx(\u2026, M, N) array_likeThe matrix whose condition number is sought.\n\np{None, 1, -1, 2, -2, inf, -inf, \u2018fro\u2019}, optionalOrder of the norm:\n\n\n\n\n\n\np\nnorm for matrices\n\n\n\nNone\n2-norm, computed directly using the SVD\n\n\u2018fro\u2019\nFrobenius norm\n\ninf\nmax(sum(abs(x), axis=1))\n\n-inf\nmin(sum(abs(x), axis=1))\n\n1\nmax(sum(abs(x), axis=0))\n\n-1\nmin(sum(abs(x), axis=0))\n\n2\n2-norm (largest sing. value)\n\n-2\nsmallest singular value\n\n\n\ninf means the numpy.inf object, and the Frobenius norm is\nthe root-of-sum-of-squares norm.\n\n\n\nReturns\n\nc{float, inf}The condition number of the matrix. May be infinite.\n\n\n\n\n\nSee also\nnumpy.linalg.norm\n\nNotes\nThe condition number of x is defined as the norm of x times the\nnorm of the inverse of x [1]; the norm can be the usual L2-norm\n(root-of-sum-of-squares) or one of a number of other matrix norms.\nReferences\n\n1\nG. Strang, Linear Algebra and Its Applications, Orlando, FL,\nAcademic Press, Inc., 1980, pg. 285.\n\n\nExamples\n&gt;&gt;&gt; from numpy import linalg as LA\n&gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n&gt;&gt;&gt; a\narray([[ 1,  0, -1],\n       [ 0,  1,  0],\n       [ 1,  0,  1]])\n&gt;&gt;&gt; LA.cond(a)\n1.4142135623730951\n&gt;&gt;&gt; LA.cond(a, 'fro')\n3.1622776601683795\n&gt;&gt;&gt; LA.cond(a, np.inf)\n2.0\n&gt;&gt;&gt; LA.cond(a, -np.inf)\n1.0\n&gt;&gt;&gt; LA.cond(a, 1)\n2.0\n&gt;&gt;&gt; LA.cond(a, -1)\n1.0\n&gt;&gt;&gt; LA.cond(a, 2)\n1.4142135623730951\n&gt;&gt;&gt; LA.cond(a, -2)\n0.70710678118654746 # may vary\n&gt;&gt;&gt; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))\n0.70710678118654746 # may vary\n\n\n", "parameters": ["Parameters", "x(\u2026, M, N) array_like", "p{None, 1, -1, 2, -2, inf, -inf, \u2018fro\u2019}, optional", "Returns", "c{float, inf}"], "returns": "c{float, inf}The condition number of the matrix. May be infinite.", "examples": ["; from numpy import linalg as LA\n; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n; a\narray([[ 1,  0, -1],\n       [ 0,  1,  0],\n       [ 1,  0,  1]])\n; LA.cond(a)\n1.4142135623730951\n; LA.cond(a, 'fro')\n3.1622776601683795\n; LA.cond(a, np.inf)\n2.0\n; LA.cond(a, -np.inf)\n1.0\n; LA.cond(a, 1)\n2.0\n; LA.cond(a, -1)\n1.0\n; LA.cond(a, 2)\n1.4142135623730951\n; LA.cond(a, -2)\n0.70710678118654746 # may vary\n; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))\n0.70710678118654746 # may vary\n\n", "; from numpy import linalg as LA\n; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])\n; a\narray([[ 1,  0, -1],\n       [ 0,  1,  0],\n       [ 1,  0,  1]])\n; LA.cond(a)\n1.4142135623730951\n; LA.cond(a, 'fro')\n3.1622776601683795\n; LA.cond(a, np.inf)\n2.0\n; LA.cond(a, -np.inf)\n1.0\n; LA.cond(a, 1)\n2.0\n; LA.cond(a, -1)\n1.0\n; LA.cond(a, 2)\n1.4142135623730951\n; LA.cond(a, -2)\n0.70710678118654746 # may vary\n; min(LA.svd(a, compute_uv=False))*min(LA.svd(LA.inv(a), compute_uv=False))\n0.70710678118654746 # may vary\n"]},
{"library": "numpy", "item_id": "numpy.conj", "code": "\nnumpy.conj(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'conjugate'&gt;\u00b6", "description": "Return the complex conjugate, element-wise.\nThe complex conjugate of a complex number is obtained by changing the\nsign of its imaginary part.\n\nParameters\n\nxarray_likeInput value.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayThe complex conjugate of x, with same dtype as y.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\nconj is an alias for conjugate:\n&gt;&gt;&gt; np.conj is np.conjugate\nTrue\n\n\nExamples\n&gt;&gt;&gt; np.conjugate(1+2j)\n(1-2j)\n\n\n&gt;&gt;&gt; x = np.eye(2) + 1j * np.eye(2)\n&gt;&gt;&gt; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayThe complex conjugate of x, with same dtype as y.This is a scalar if x is a scalar.", "examples": ["; np.conjugate(1+2j)\n(1-2j)\n\n", "; np.conjugate(1+2j)\n(1-2j)\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n\n", "; x = np.eye(2) + 1j * np.eye(2)\n; np.conjugate(x)\narray([[ 1.-1.j,  0.-0.j],\n       [ 0.-0.j,  1.-1.j]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.concatenate", "code": "\nnumpy.ma.concatenate(arrays, axis=0)[source]\u00b6", "description": "Concatenate a sequence of arrays along the given axis.\n\nParameters\n\narrayssequence of array_likeThe arrays must have the same shape, except in the dimension\ncorresponding to axis (the first, by default).\n\naxisint, optionalThe axis along which the arrays will be joined. Default is 0.\n\n\n\nReturns\n\nresultMaskedArrayThe concatenated array with any masked entries preserved.\n\n\n\n\n\nSee also\n\nnumpy.concatenateEquivalent function in the top-level NumPy module.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.arange(3)\n&gt;&gt;&gt; a[1] = ma.masked\n&gt;&gt;&gt; b = ma.arange(2, 5)\n&gt;&gt;&gt; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; b\nmasked_array(data=[2, 3, 4],\n             mask=False,\n       fill_value=999999)\n&gt;&gt;&gt; ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "arrayssequence of array_like", "axisint, optional", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayThe concatenated array with any masked entries preserved.", "examples": ["; import numpy.ma as ma\n; a = ma.arange(3)\n; a[1] = ma.masked\n; b = ma.arange(2, 5)\n; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n; b\nmasked_array(data=[2, 3, 4],\n             mask=False,\n       fill_value=999999)\n; ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = ma.arange(3)\n; a[1] = ma.masked\n; b = ma.arange(2, 5)\n; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n; b\nmasked_array(data=[2, 3, 4],\n             mask=False,\n       fill_value=999999)\n; ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.concatenate", "code": "\nnumpy.concatenate((a1, a2, ...), axis=0, out=None)\u00b6", "description": "Join a sequence of arrays along an existing axis.\n\nParameters\n\na1, a2, \u2026sequence of array_likeThe arrays must have the same shape, except in the dimension\ncorresponding to axis (the first, by default).\n\naxisint, optionalThe axis along which the arrays will be joined.  If axis is None,\narrays are flattened before use.  Default is 0.\n\noutndarray, optionalIf provided, the destination to place the result. The shape must be\ncorrect, matching that of what concatenate would have returned if no\nout argument were specified.\n\n\n\nReturns\n\nresndarrayThe concatenated array.\n\n\n\n\n\nSee also\n\nma.concatenateConcatenate function that preserves input masks.\n\narray_splitSplit an array into multiple sub-arrays of equal or near-equal size.\n\nsplitSplit array into a list of multiple sub-arrays of equal size.\n\nhsplitSplit array into multiple sub-arrays horizontally (column wise)\n\nvsplitSplit array into multiple sub-arrays vertically (row wise)\n\ndsplitSplit array into multiple sub-arrays along the 3rd axis (depth).\n\nstackStack a sequence of arrays along a new axis.\n\nhstackStack arrays in sequence horizontally (column wise)\n\nvstackStack arrays in sequence vertically (row wise)\n\ndstackStack arrays in sequence depth wise (along third dimension)\n\nblockAssemble arrays from blocks.\n\n\n\nNotes\nWhen one or more of the arrays to be concatenated is a MaskedArray,\nthis function will return a MaskedArray object instead of an ndarray,\nbut the input masks are not preserved. In cases where a MaskedArray\nis expected as input, use the ma.concatenate function from the masked\narray module instead.\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])\n&gt;&gt;&gt; b = np.array([[5, 6]])\n&gt;&gt;&gt; np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])\n&gt;&gt;&gt; np.concatenate((a, b), axis=None)\narray([1, 2, 3, 4, 5, 6])\n\n\nThis function will not preserve masking of MaskedArray inputs.\n&gt;&gt;&gt; a = np.ma.arange(3)\n&gt;&gt;&gt; a[1] = np.ma.masked\n&gt;&gt;&gt; b = np.arange(2, 5)\n&gt;&gt;&gt; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n&gt;&gt;&gt; b\narray([2, 3, 4])\n&gt;&gt;&gt; np.concatenate([a, b])\nmasked_array(data=[0, 1, 2, 2, 3, 4],\n             mask=False,\n       fill_value=999999)\n&gt;&gt;&gt; np.ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "a1, a2, \u2026sequence of array_like", "axisint, optional", "outndarray, optional", "Returns", "resndarray"], "returns": "resndarrayThe concatenated array.", "examples": ["; a = np.array([[1, 2], [3, 4]])\n; b = np.array([[5, 6]])\n; np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n; np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])\n; np.concatenate((a, b), axis=None)\narray([1, 2, 3, 4, 5, 6])\n\n", "; a = np.array([[1, 2], [3, 4]])\n; b = np.array([[5, 6]])\n; np.concatenate((a, b), axis=0)\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n; np.concatenate((a, b.T), axis=1)\narray([[1, 2, 5],\n       [3, 4, 6]])\n; np.concatenate((a, b), axis=None)\narray([1, 2, 3, 4, 5, 6])\n", "; a = np.ma.arange(3)\n; a[1] = np.ma.masked\n; b = np.arange(2, 5)\n; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n; b\narray([2, 3, 4])\n; np.concatenate([a, b])\nmasked_array(data=[0, 1, 2, 2, 3, 4],\n             mask=False,\n       fill_value=999999)\n; np.ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n\n", "; a = np.ma.arange(3)\n; a[1] = np.ma.masked\n; b = np.arange(2, 5)\n; a\nmasked_array(data=[0, --, 2],\n             mask=[False,  True, False],\n       fill_value=999999)\n; b\narray([2, 3, 4])\n; np.concatenate([a, b])\nmasked_array(data=[0, 1, 2, 2, 3, 4],\n             mask=False,\n       fill_value=999999)\n; np.ma.concatenate([a, b])\nmasked_array(data=[0, --, 2, 2, 3, 4],\n             mask=[False,  True, False, False, False, False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.compressed", "code": "\nMaskedArray.compressed(self)[source]\u00b6", "description": "Return all the non-masked data as a 1-D array.\n\nReturns\n\ndatandarrayA new ndarray holding the non-masked data is returned.\n\n\n\n\nNotes\nThe result is not a MaskedArray!\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n&gt;&gt;&gt; x.compressed()\narray([0, 1])\n&gt;&gt;&gt; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n\n\n", "parameters": [], "returns": "datandarrayA new ndarray holding the non-masked data is returned.", "examples": ["; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n; x.compressed()\narray([0, 1])\n; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n\n", "; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n; x.compressed()\narray([0, 1])\n; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.compressed", "code": "\nmasked_array.compressed(self)[source]\u00b6", "description": "Return all the non-masked data as a 1-D array.\n\nReturns\n\ndatandarrayA new ndarray holding the non-masked data is returned.\n\n\n\n\nNotes\nThe result is not a MaskedArray!\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n&gt;&gt;&gt; x.compressed()\narray([0, 1])\n&gt;&gt;&gt; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n\n\n", "parameters": [], "returns": "datandarrayA new ndarray holding the non-masked data is returned.", "examples": ["; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n; x.compressed()\narray([0, 1])\n; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n\n", "; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)\n; x.compressed()\narray([0, 1])\n; type(x.compressed())\n&lt;class 'numpy.ndarray'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.ma.compress_rows", "code": "\nnumpy.ma.compress_rows(a)[source]\u00b6", "description": "Suppress whole rows of a 2-D array that contain masked values.\nThis is equivalent to np.ma.compress_rowcols(a, 0), see\nextras.compress_rowcols for details.\n\nSee also\nextras.compress_rowcols\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.compressed", "code": "\nnumpy.ma.compressed(x)[source]\u00b6", "description": "Return all the non-masked data as a 1-D array.\nThis function is equivalent to calling the \u201ccompressed\u201d method of a\nMaskedArray, see MaskedArray.compressed for details.\n\nSee also\n\nMaskedArray.compressedEquivalent method.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.compress", "code": "\nrecarray.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.compress_rowcols", "code": "\nnumpy.ma.compress_rowcols(x, axis=None)[source]\u00b6", "description": "Suppress the rows and/or columns of a 2-D array that contain\nmasked values.\nThe suppression behavior is selected with the axis parameter.\n\nIf axis is None, both rows and columns are suppressed.\nIf axis is 0, only rows are suppressed.\nIf axis is 1 or -1, only columns are suppressed.\n\n\nParameters\n\nxarray_like, MaskedArrayThe array to operate on.  If not a MaskedArray instance (or if no array\nelements are masked), x is interpreted as a MaskedArray with\nmask set to nomask. Must be a 2D array.\n\naxisint, optionalAxis along which to perform the operation. Default is None.\n\n\n\nReturns\n\ncompressed_arrayndarrayThe compressed array.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, 1, 2],\n        [--, 4, 5],\n        [6, 7, 8]],\n  mask=[[ True, False, False],\n        [ True, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n\n&gt;&gt;&gt; np.ma.compress_rowcols(x)\narray([[7, 8]])\n&gt;&gt;&gt; np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n&gt;&gt;&gt; np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])\n\n\n", "parameters": ["Parameters", "xarray_like, MaskedArray", "axisint, optional", "Returns", "compressed_arrayndarray"], "returns": "compressed_arrayndarrayThe compressed array.", "examples": ["; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n; x\nmasked_array(\n  data=[[--, 1, 2],\n        [--, 4, 5],\n        [6, 7, 8]],\n  mask=[[ True, False, False],\n        [ True, False, False],\n        [False, False, False]],\n  fill_value=999999)\n\n", "; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],\n...                                                   [1, 0, 0],\n...                                                   [0, 0, 0]])\n; x\nmasked_array(\n  data=[[--, 1, 2],\n        [--, 4, 5],\n        [6, 7, 8]],\n  mask=[[ True, False, False],\n        [ True, False, False],\n        [False, False, False]],\n  fill_value=999999)\n", "; np.ma.compress_rowcols(x)\narray([[7, 8]])\n; np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n; np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])\n\n", "; np.ma.compress_rowcols(x)\narray([[7, 8]])\n; np.ma.compress_rowcols(x, 0)\narray([[6, 7, 8]])\n; np.ma.compress_rowcols(x, 1)\narray([[1, 2],\n       [4, 5],\n       [7, 8]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.compress_cols", "code": "\nnumpy.ma.compress_cols(a)[source]\u00b6", "description": "Suppress whole columns of a 2-D array that contain masked values.\nThis is equivalent to np.ma.compress_rowcols(a, 1), see\nextras.compress_rowcols for details.\n\nSee also\nextras.compress_rowcols\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.compress", "code": "\nrecord.compress()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.compress", "code": "\nmemmap.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.compress", "code": "\nmatrix.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.compress", "code": "\nndarray.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.compress", "code": "\nMaskType.compress()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.compress", "code": "\nMaskedArray.compress(self, condition, axis=None, out=None)[source]\u00b6", "description": "Return a where condition is True.\nIf condition is a MaskedArray, missing values are considered\nas False.\n\nParameters\n\nconditionvarBoolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array.\n\naxis{None, int}, optionalAxis along which the operation must be performed.\n\nout{None, ndarray}, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary.\n\n\n\nReturns\n\nresultMaskedArrayA MaskedArray object.\n\n\n\n\nNotes\nPlease note the difference with compressed !\nThe output of compress has a mask, the output of\ncompressed does not.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "conditionvar", "axis{None, int}, optional", "out{None, ndarray}, optional", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayA MaskedArray object.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n", "; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n\n", "; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.compress", "code": "\nmasked_array.compress(self, condition, axis=None, out=None)[source]\u00b6", "description": "Return a where condition is True.\nIf condition is a MaskedArray, missing values are considered\nas False.\n\nParameters\n\nconditionvarBoolean 1-d array selecting which entries to return. If len(condition)\nis less than the size of a along the axis, then output is truncated\nto length of condition array.\n\naxis{None, int}, optionalAxis along which the operation must be performed.\n\nout{None, ndarray}, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output but the type will be cast if\nnecessary.\n\n\n\nReturns\n\nresultMaskedArrayA MaskedArray object.\n\n\n\n\nNotes\nPlease note the difference with compressed !\nThe output of compress has a mask, the output of\ncompressed does not.\nExamples\n&gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n\n&gt;&gt;&gt; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n\n\n", "parameters": ["Parameters", "conditionvar", "axis{None, int}, optional", "out{None, ndarray}, optional", "Returns", "resultMaskedArray"], "returns": "resultMaskedArrayA MaskedArray object.", "examples": ["; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n\n", "; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)\n; x\nmasked_array(\n  data=[[1, --, 3],\n        [--, 5, --],\n        [7, --, 9]],\n  mask=[[False,  True, False],\n        [ True, False,  True],\n        [False,  True, False]],\n  fill_value=999999)\n; x.compress([1, 0, 1])\nmasked_array(data=[1, 3],\n             mask=[False, False],\n       fill_value=999999)\n", "; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n\n", "; x.compress([1, 0, 1], axis=1)\nmasked_array(\n  data=[[1, 3],\n        [--, --],\n        [7, 9]],\n  mask=[[False, False],\n        [ True,  True],\n        [False, False]],\n  fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.chararray.compress", "code": "\nchararray.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.compress", "code": "\nchararray.compress(condition, axis=None, out=None)\u00b6", "description": "Return selected slices of this array along given axis.\nRefer to numpy.compress for full documentation.\n\nSee also\n\nnumpy.compressequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.compress", "code": "\ngeneric.compress()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.compress", "code": "\nnumpy.compress(condition, a, axis=None, out=None)[source]\u00b6", "description": "Return selected slices of an array along given axis.\nWhen working along a given axis, a slice along that axis is returned in\noutput for each index where condition evaluates to True. When\nworking on a 1-D array, compress is equivalent to extract.\n\nParameters\n\ncondition1-D array of boolsArray that selects which entries to return. If len(condition)\nis less than the size of a along the given axis, then output is\ntruncated to the length of the condition array.\n\naarray_likeArray from which to extract a part.\n\naxisint, optionalAxis along which to take slices. If None (default), work on the\nflattened array.\n\noutndarray, optionalOutput array.  Its type is preserved and it must be of the right\nshape to hold the output.\n\n\n\nReturns\n\ncompressed_arrayndarrayA copy of a without the slices along axis for which condition\nis false.\n\n\n\n\n\nSee also\ntake, choose, diag, diagonal, select\n\nndarray.compressEquivalent method in ndarray\n\nnp.extractEquivalent method when working on 1-D arrays\n\n\nufuncs-output-type\n\nExamples\n&gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])\n&gt;&gt;&gt; a\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n&gt;&gt;&gt; np.compress([0, 1], a, axis=0)\narray([[3, 4]])\n&gt;&gt;&gt; np.compress([False, True, True], a, axis=0)\narray([[3, 4],\n       [5, 6]])\n&gt;&gt;&gt; np.compress([False, True], a, axis=1)\narray([[2],\n       [4],\n       [6]])\n\n\nWorking on the flattened array does not return slices along an axis but\nselects elements.\n&gt;&gt;&gt; np.compress([False, True], a)\narray([2])\n\n\n", "parameters": ["Parameters", "condition1-D array of bools", "aarray_like", "axisint, optional", "outndarray, optional", "Returns", "compressed_arrayndarray"], "returns": "compressed_arrayndarrayA copy of a without the slices along axis for which conditionis false.", "examples": ["; a = np.array([[1, 2], [3, 4], [5, 6]])\n; a\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n; np.compress([0, 1], a, axis=0)\narray([[3, 4]])\n; np.compress([False, True, True], a, axis=0)\narray([[3, 4],\n       [5, 6]])\n; np.compress([False, True], a, axis=1)\narray([[2],\n       [4],\n       [6]])\n\n", "; a = np.array([[1, 2], [3, 4], [5, 6]])\n; a\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n; np.compress([0, 1], a, axis=0)\narray([[3, 4]])\n; np.compress([False, True, True], a, axis=0)\narray([[3, 4],\n       [5, 6]])\n; np.compress([False, True], a, axis=1)\narray([[2],\n       [4],\n       [6]])\n", "; np.compress([False, True], a)\narray([2])\n\n", "; np.compress([False, True], a)\narray([2])\n"]},
{"library": "numpy", "item_id": "numpy.char.compare_chararrays", "code": "\nnumpy.char.compare_chararrays(a, b, cmp_op, rstrip)\u00b6", "description": "Performs element-wise comparison of two string arrays using the\ncomparison operator specified by cmp_op.\n\nParameters\n\na, barray_likeArrays to be compared.\n\ncmp_op{\u201c&lt;\u201d, \u201c&lt;=\u201d, \u201c==\u201d, \u201c&gt;=\u201d, \u201c&gt;\u201d, \u201c!=\u201d}Type of comparison.\n\nrstripBooleanIf True, the spaces at the end of Strings are removed before the comparison.\n\n\n\nReturns\n\noutndarrayThe output array of type Boolean with the same shape as a and b.\n\n\n\nRaises\n\nValueErrorIf cmp_op is not valid.\n\nTypeErrorIf at least one of a or b is a non-string array\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.array([\"a\", \"b\", \"cde\"])\n&gt;&gt;&gt; b = np.array([\"a\", \"a\", \"dec\"])\n&gt;&gt;&gt; np.compare_chararrays(a, b, \"&gt;\", True)\narray([False,  True, False])\n\n\n", "parameters": ["Parameters", "a, barray_like", "cmp_op{\u201c&lt;\u201d, \u201c&lt;=\u201d, \u201c==\u201d, \u201c&gt;=\u201d, \u201c&gt;\u201d, \u201c!=\u201d}", "rstripBoolean", "Returns", "outndarray", "Raises", "ValueError", "TypeError"], "returns": "outndarrayThe output array of type Boolean with the same shape as a and b.", "examples": ["; a = np.array([\"a\", \"b\", \"cde\"])\n; b = np.array([\"a\", \"a\", \"dec\"])\n; np.compare_chararrays(a, b, \"&gt;\", True)\narray([False,  True, False])\n\n", "; a = np.array([\"a\", \"b\", \"cde\"])\n; b = np.array([\"a\", \"a\", \"dec\"])\n; np.compare_chararrays(a, b, \"&gt;\", True)\narray([False,  True, False])\n"]},
{"library": "numpy", "item_id": "numpy.common_type", "code": "\nnumpy.common_type(*arrays)[source]\u00b6", "description": "Return a scalar type which is common to the input arrays.\nThe return type will always be an inexact (i.e. floating point) scalar\ntype, even if all the arrays are integer arrays. If one of the inputs is\nan integer array, the minimum precision type that is returned is a\n64-bit floating point dtype.\nAll input arrays except int64 and uint64 can be safely cast to the\nreturned dtype without loss of information.\n\nParameters\n\narray1, array2, \u2026ndarraysInput arrays.\n\n\n\nReturns\n\noutdata type codeData type code.\n\n\n\n\n\nSee also\ndtype, mintypecode\n\nExamples\n&gt;&gt;&gt; np.common_type(np.arange(2, dtype=np.float32))\n&lt;class 'numpy.float32'&gt;\n&gt;&gt;&gt; np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n&lt;class 'numpy.float64'&gt;\n&gt;&gt;&gt; np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n&lt;class 'numpy.complex128'&gt;\n\n\n", "parameters": ["Parameters", "array1, array2, \u2026ndarrays", "Returns", "outdata type code"], "returns": "outdata type codeData type code.", "examples": ["; np.common_type(np.arange(2, dtype=np.float32))\n&lt;class 'numpy.float32'&gt;\n; np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n&lt;class 'numpy.float64'&gt;\n; np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n&lt;class 'numpy.complex128'&gt;\n\n", "; np.common_type(np.arange(2, dtype=np.float32))\n&lt;class 'numpy.float32'&gt;\n; np.common_type(np.arange(2, dtype=np.float32), np.arange(2))\n&lt;class 'numpy.float64'&gt;\n; np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0]))\n&lt;class 'numpy.complex128'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.column_stack", "code": "\nnumpy.column_stack(tup)[source]\u00b6", "description": "Stack 1-D arrays as columns into a 2-D array.\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with hstack.  1-D arrays are turned into 2-D columns\nfirst.\n\nParameters\n\ntupsequence of 1-D or 2-D arrays.Arrays to stack. All of them must have the same first dimension.\n\n\n\nReturns\n\nstacked2-D arrayThe array formed by stacking the given arrays.\n\n\n\n\n\nSee also\nstack, hstack, vstack, concatenate\n\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "tupsequence of 1-D or 2-D arrays.", "Returns", "stacked2-D array"], "returns": "stacked2-D arrayThe array formed by stacking the given arrays.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.column_stack", "code": "\nnumpy.ma.column_stack(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_seq object&gt;\u00b6", "description": "\nStack 1-D arrays as columns into a 2-D array.\nTake a sequence of 1-D arrays and stack them as columns\nto make a single 2-D array. 2-D arrays are stacked as-is,\njust like with hstack.  1-D arrays are turned into 2-D columns\nfirst.\n\n\nParameters\n\ntupsequence of 1-D or 2-D arrays.Arrays to stack. All of them must have the same first dimension.\n\n\n\nReturns\n\nstacked2-D arrayThe array formed by stacking the given arrays.\n\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; a = np.array((1,2,3))\n&gt;&gt;&gt; b = np.array((2,3,4))\n&gt;&gt;&gt; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n\n", "parameters": ["Parameters", "tupsequence of 1-D or 2-D arrays.", "Returns", "stacked2-D array"], "returns": "stacked2-D arrayThe array formed by stacking the given arrays.", "examples": ["; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n\n", "; a = np.array((1,2,3))\n; b = np.array((2,3,4))\n; np.column_stack((a,b))\narray([[1, 2],\n       [2, 3],\n       [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.coef", "code": "\nproperty poly1d.coef\u00b6", "description": "The polynomial coefficients\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.common_fill_value", "code": "\nnumpy.ma.common_fill_value(a, b)[source]\u00b6", "description": "Return the common filling value of two masked arrays, if any.\nIf a.fill_value == b.fill_value, return the fill value,\notherwise return None.\n\nParameters\n\na, bMaskedArrayThe masked arrays for which to compare fill values.\n\n\n\nReturns\n\nfill_valuescalar or NoneThe common fill value, or None.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=3)\n&gt;&gt;&gt; y = np.ma.array([0, 1.], fill_value=3)\n&gt;&gt;&gt; np.ma.common_fill_value(x, y)\n3.0\n\n\n", "parameters": ["Parameters", "a, bMaskedArray", "Returns", "fill_valuescalar or None"], "returns": "fill_valuescalar or NoneThe common fill value, or None.", "examples": ["; x = np.ma.array([0, 1.], fill_value=3)\n; y = np.ma.array([0, 1.], fill_value=3)\n; np.ma.common_fill_value(x, y)\n3.0\n\n", "; x = np.ma.array([0, 1.], fill_value=3)\n; y = np.ma.array([0, 1.], fill_value=3)\n; np.ma.common_fill_value(x, y)\n3.0\n"]},
{"library": "numpy", "item_id": "numpy.poly1d.coeffs", "code": "\nproperty poly1d.coeffs\u00b6", "description": "The polynomial coefficients\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.coefficients", "code": "\nproperty poly1d.coefficients\u00b6", "description": "The polynomial coefficients\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.clump_unmasked", "code": "\nnumpy.ma.clump_unmasked(a)[source]\u00b6", "description": "Return list of slices corresponding to the unmasked clumps of a 1-D array.\n(A \u201cclump\u201d is defined as a contiguous region of the array).\n\nParameters\n\nandarrayA one-dimensional masked array.\n\n\n\nReturns\n\nsliceslist of sliceThe list of slices, one for each continuous region of unmasked\nelements in a.\n\n\n\n\n\nSee also\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges, notmasked_contiguous, clump_masked\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\n&gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))\n&gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n&gt;&gt;&gt; np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]\n\n\n", "parameters": ["Parameters", "andarray", "Returns", "sliceslist of slice"], "returns": "sliceslist of sliceThe list of slices, one for each continuous region of unmaskedelements in a.", "examples": ["; a = np.ma.masked_array(np.arange(10))\n; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n; np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]\n\n", "; a = np.ma.masked_array(np.arange(10))\n; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n; np.ma.clump_unmasked(a)\n[slice(3, 6, None), slice(7, 8, None)]\n"]},
{"library": "numpy", "item_id": "numpy.record.clip", "code": "\nrecord.clip()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.clip", "code": "\nndarray.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.clump_masked", "code": "\nnumpy.ma.clump_masked(a)[source]\u00b6", "description": "Returns a list of slices corresponding to the masked clumps of a 1-D array.\n(A \u201cclump\u201d is defined as a contiguous region of the array).\n\nParameters\n\nandarrayA one-dimensional masked array.\n\n\n\nReturns\n\nsliceslist of sliceThe list of slices, one for each continuous region of masked elements\nin a.\n\n\n\n\n\nSee also\nflatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges, notmasked_contiguous, clump_unmasked\n\nNotes\n\nNew in version 1.4.0.\n\nExamples\n&gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))\n&gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n&gt;&gt;&gt; np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]\n\n\n", "parameters": ["Parameters", "andarray", "Returns", "sliceslist of slice"], "returns": "sliceslist of sliceThe list of slices, one for each continuous region of masked elementsin a.", "examples": ["; a = np.ma.masked_array(np.arange(10))\n; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n; np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]\n\n", "; a = np.ma.masked_array(np.arange(10))\n; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked\n; np.ma.clump_masked(a)\n[slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]\n"]},
{"library": "numpy", "item_id": "numpy.recarray.clip", "code": "\nrecarray.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.clip", "code": "\nmemmap.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.clip", "code": "\nmatrix.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.clip", "code": "\nMaskType.clip()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.clip", "code": "\nMaskedArray.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.clip", "code": "\nmasked_array.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.clip", "code": "\ngeneric.clip()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.nditer.close", "code": "\nnditer.close()\u00b6", "description": "Resolve all writeback semantics in writeable operands.\n\nNew in version 1.15.0.\n\n\nSee also\nModifying Array Values\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.clip", "code": "\nchararray.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.clip", "code": "\nchararray.clip(min=None, max=None, out=None, **kwargs)\u00b6", "description": "Return an array whose values are limited to [min, max].\nOne of max or min must be given.\nRefer to numpy.clip for full documentation.\n\nSee also\n\nnumpy.clipequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.clip", "code": "\nnumpy.ma.clip(a, a_min, a_max, out=None, **kwargs)[source]\u00b6", "description": "Clip (limit) the values in an array.\nGiven an interval, values outside the interval are clipped to\nthe interval edges.  For example, if an interval of [0, 1]\nis specified, values smaller than 0 become 0, and values larger\nthan 1 become 1.\nEquivalent to but faster than np.maximum(a_min, np.minimum(a, a_max)).\nNo check is performed to ensure a_min &lt; a_max.\n\nParameters\n\naarray_likeArray containing elements to clip.\n\na_minscalar or array_like or NoneMinimum value. If None, clipping is not performed on lower\ninterval edge. Not more than one of a_min and a_max may be\nNone.\n\na_maxscalar or array_like or NoneMaximum value. If None, clipping is not performed on upper\ninterval edge. Not more than one of a_min and a_max may be\nNone. If a_min or a_max are array_like, then the three\narrays will be broadcasted to match their shapes.\n\noutndarray, optionalThe results will be placed in this array. It may be the input\narray for in-place clipping.  out must be of the right shape\nto hold the output.  Its type is preserved.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nclipped_arrayndarrayAn array with the elements of a, but where values\n&lt; a_min are replaced with a_min, and those &gt; a_max\nwith a_max.\n\n\n\n\n\nSee also\nufuncs-output-type\n\nExamples\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n\n", "parameters": ["Parameters", "aarray_like", "a_minscalar or array_like or None", "a_maxscalar or array_like or None", "outndarray, optional", "**kwargs", "Returns", "clipped_arrayndarray"], "returns": "clipped_arrayndarrayAn array with the elements of a, but where values&lt; a_min are replaced with a_min, and those &gt; a_maxwith a_max.", "examples": ["; a = np.arange(10)\n; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n", "; a = np.arange(10)\n; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n"]},
{"library": "numpy", "item_id": "numpy.clip", "code": "\nnumpy.clip(a, a_min, a_max, out=None, **kwargs)[source]\u00b6", "description": "Clip (limit) the values in an array.\nGiven an interval, values outside the interval are clipped to\nthe interval edges.  For example, if an interval of [0, 1]\nis specified, values smaller than 0 become 0, and values larger\nthan 1 become 1.\nEquivalent to but faster than np.maximum(a_min, np.minimum(a, a_max)).\nNo check is performed to ensure a_min &lt; a_max.\n\nParameters\n\naarray_likeArray containing elements to clip.\n\na_minscalar or array_like or NoneMinimum value. If None, clipping is not performed on lower\ninterval edge. Not more than one of a_min and a_max may be\nNone.\n\na_maxscalar or array_like or NoneMaximum value. If None, clipping is not performed on upper\ninterval edge. Not more than one of a_min and a_max may be\nNone. If a_min or a_max are array_like, then the three\narrays will be broadcasted to match their shapes.\n\noutndarray, optionalThe results will be placed in this array. It may be the input\narray for in-place clipping.  out must be of the right shape\nto hold the output.  Its type is preserved.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\nclipped_arrayndarrayAn array with the elements of a, but where values\n&lt; a_min are replaced with a_min, and those &gt; a_max\nwith a_max.\n\n\n\n\n\nSee also\nufuncs-output-type\n\nExamples\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n&gt;&gt;&gt; a = np.arange(10)\n&gt;&gt;&gt; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n&gt;&gt;&gt; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n\n", "parameters": ["Parameters", "aarray_like", "a_minscalar or array_like or None", "a_maxscalar or array_like or None", "outndarray, optional", "**kwargs", "Returns", "clipped_arrayndarray"], "returns": "clipped_arrayndarrayAn array with the elements of a, but where values&lt; a_min are replaced with a_min, and those &gt; a_maxwith a_max.", "examples": ["; a = np.arange(10)\n; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n\n", "; a = np.arange(10)\n; np.clip(a, 1, 8)\narray([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, 3, 6, out=a)\narray([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])\n; a = np.arange(10)\n; a\narray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\n; np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)\narray([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.choose", "code": "\nmatrix.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.choose", "code": "\nrecord.choose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.choose", "code": "\nMaskType.choose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.choose", "code": "\nndarray.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.choose", "code": "\nMaskedArray.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.choose", "code": "\nmemmap.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.choose", "code": "\nrecarray.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.choose", "code": "\nchararray.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.linalg.cholesky", "code": "\nnumpy.linalg.cholesky(a)[source]\u00b6", "description": "Cholesky decomposition.\nReturn the Cholesky decomposition, L * L.H, of the square matrix a,\nwhere L is lower-triangular and .H is the conjugate transpose operator\n(which is the ordinary transpose if a is real-valued).  a must be\nHermitian (symmetric if real-valued) and positive-definite.  Only L is\nactually returned.\n\nParameters\n\na(\u2026, M, M) array_likeHermitian (symmetric if all elements are real), positive-definite\ninput matrix.\n\n\n\nReturns\n\nL(\u2026, M, M) array_likeUpper or lower-triangular Cholesky factor of a.  Returns a\nmatrix object if a is a matrix object.\n\n\n\nRaises\n\nLinAlgErrorIf the decomposition fails, for example, if a is not\npositive-definite.\n\n\n\n\nNotes\n\nNew in version 1.8.0.\n\nBroadcasting rules apply, see the numpy.linalg documentation for\ndetails.\nThe Cholesky decomposition is often used as a fast way of solving\n\n\n(when A is both Hermitian/symmetric and positive-definite).\nFirst, we solve for  in\n\n\nand then for  in\n\n\nExamples\n&gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])\n&gt;&gt;&gt; A\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n&gt;&gt;&gt; L = np.linalg.cholesky(A)\n&gt;&gt;&gt; L\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n&gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A\narray([[1.+0.j, 0.-2.j],\n       [0.+2.j, 5.+0.j]])\n&gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\n&gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n&gt;&gt;&gt; # But a matrix object is returned if A is a matrix object\n&gt;&gt;&gt; np.linalg.cholesky(np.matrix(A))\nmatrix([[ 1.+0.j,  0.+0.j],\n        [ 0.+2.j,  1.+0.j]])\n\n\n", "parameters": ["Parameters", "a(\u2026, M, M) array_like", "Returns", "L(\u2026, M, M) array_like", "Raises", "LinAlgError"], "returns": "L(\u2026, M, M) array_likeUpper or lower-triangular Cholesky factor of a.  Returns amatrix object if a is a matrix object.", "examples": ["; A = np.array([[1,-2j],[2j,5]])\n; A\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n; L = np.linalg.cholesky(A)\n; L\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n; np.dot(L, L.T.conj()) # verify that L * L.H = A\narray([[1.+0.j, 0.-2.j],\n       [0.+2.j, 5.+0.j]])\n; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\n; np.linalg.cholesky(A) # an ndarray object is returned\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n; # But a matrix object is returned if A is a matrix object\n; np.linalg.cholesky(np.matrix(A))\nmatrix([[ 1.+0.j,  0.+0.j],\n        [ 0.+2.j,  1.+0.j]])\n\n", "; A = np.array([[1,-2j],[2j,5]])\n; A\narray([[ 1.+0.j, -0.-2.j],\n       [ 0.+2.j,  5.+0.j]])\n; L = np.linalg.cholesky(A)\n; L\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n; np.dot(L, L.T.conj()) # verify that L * L.H = A\narray([[1.+0.j, 0.-2.j],\n       [0.+2.j, 5.+0.j]])\n; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?\n; np.linalg.cholesky(A) # an ndarray object is returned\narray([[1.+0.j, 0.+0.j],\n       [0.+2.j, 1.+0.j]])\n; # But a matrix object is returned if A is a matrix object\n; np.linalg.cholesky(np.matrix(A))\nmatrix([[ 1.+0.j,  0.+0.j],\n        [ 0.+2.j,  1.+0.j]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.choose", "code": "\nmasked_array.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.choose", "code": "\ngeneric.choose()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.choose", "code": "\nchararray.choose(choices, out=None, mode='raise')\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nRefer to numpy.choose for full documentation.\n\nSee also\n\nnumpy.chooseequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.choose", "code": "\nnumpy.ma.choose(indices, choices, out=None, mode='raise')[source]\u00b6", "description": "Use an index array to construct a new array from a set of choices.\nGiven an array of integers and a set of n choice arrays, this method\nwill create a new array that merges each of the choice arrays.  Where a\nvalue in a is i, the new array will have the value that choices[i]\ncontains in the same place.\n\nParameters\n\nandarray of intsThis array must contain integers in [0, n-1], where n is the\nnumber of choices.\n\nchoicessequence of arraysChoice arrays. The index array and all of the choices should be\nbroadcastable to the same shape.\n\noutarray, optionalIf provided, the result will be inserted into this array. It should\nbe of the appropriate shape and dtype.\n\nmode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how out-of-bounds indices will behave.\n\n\u2018raise\u2019 : raise an error\n\u2018wrap\u2019 : wrap around\n\u2018clip\u2019 : clip to the range\n\n\n\n\nReturns\n\nmerged_arrayarray\n\n\n\n\nSee also\n\nchooseequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n&gt;&gt;&gt; a = np.array([2, 1, 0])\n&gt;&gt;&gt; np.ma.choose(a, choice)\nmasked_array(data=[3, 2, 1],\n             mask=False,\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "andarray of ints", "choicessequence of arrays", "outarray, optional", "mode{\u2018raise\u2019, \u2018wrap\u2019, \u2018clip\u2019}, optional", "Returns", "merged_arrayarray"], "returns": "merged_arrayarray", "examples": ["; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n; a = np.array([2, 1, 0])\n; np.ma.choose(a, choice)\nmasked_array(data=[3, 2, 1],\n             mask=False,\n       fill_value=999999)\n\n", "; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])\n; a = np.array([2, 1, 0])\n; np.ma.choose(a, choice)\nmasked_array(data=[3, 2, 1],\n             mask=False,\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.choose", "code": "\nnumpy.choose(a, choices, out=None, mode='raise')[source]\u00b6", "description": "Construct an array from an index array and a set of arrays to choose from.\nFirst of all, if confused or uncertain, definitely look at the Examples -\nin its full generality, this function is less simple than it might\nseem from the following code description (below ndi =\nnumpy.lib.index_tricks):\nnp.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)]).\nBut this omits some subtleties.  Here is a fully general summary:\nGiven an \u201cindex\u201d array (a) of integers and a sequence of n arrays\n(choices), a and each choice array are first broadcast, as necessary,\nto arrays of a common shape; calling these Ba and Bchoices[i], i =\n0,\u2026,n-1 we have that, necessarily, Ba.shape == Bchoices[i].shape\nfor each i.  Then, a new array with shape Ba.shape is created as\nfollows:\n\nif mode=raise (the default), then, first of all, each element of\na (and thus Ba) must be in the range [0, n-1]; now, suppose that\ni (in that range) is the value at the (j0, j1, \u2026, jm) position\nin Ba - then the value at the same position in the new array is the\nvalue in Bchoices[i] at that same position;\nif mode=wrap, values in a (and thus Ba) may be any (signed)\ninteger; modular arithmetic is used to map integers outside the range\n[0, n-1] back into that range; and then the new array is constructed\nas above;\nif mode=clip, values in a (and thus Ba) may be any (signed)\ninteger; negative integers are mapped to 0; values greater than n-1\nare mapped to n-1; and then the new array is constructed as above.\n\n\nParameters\n\naint arrayThis array must contain integers in [0, n-1], where n is the number\nof choices, unless mode=wrap or mode=clip, in which cases any\nintegers are permissible.\n\nchoicessequence of arraysChoice arrays. a and all of the choices must be broadcastable to the\nsame shape.  If choices is itself an array (not recommended), then\nits outermost dimension (i.e., the one corresponding to\nchoices.shape[0]) is taken as defining the \u201csequence\u201d.\n\noutarray, optionalIf provided, the result will be inserted into this array. It should\nbe of the appropriate shape and dtype. Note that out is always\nbuffered if mode=\u2019raise\u2019; use other modes for better performance.\n\nmode{\u2018raise\u2019 (default), \u2018wrap\u2019, \u2018clip\u2019}, optionalSpecifies how indices outside [0, n-1] will be treated:\n\n\n\u2018raise\u2019 : an exception is raised\n\u2018wrap\u2019 : value becomes value mod n\n\u2018clip\u2019 : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1\n\n\n\n\n\nReturns\n\nmerged_arrayarrayThe merged result.\n\n\n\nRaises\n\nValueError: shape mismatchIf a and each choice array are not all broadcastable to the same\nshape.\n\n\n\n\n\nSee also\n\nndarray.chooseequivalent method\n\nnumpy.take_along_axisPreferable if choices is an array\n\n\n\nNotes\nTo reduce the chance of misinterpretation, even though the following\n\u201cabuse\u201d is nominally supported, choices should neither be, nor be\nthought of as, a single array, i.e., the outermost sequence-like container\nshould be either a list or a tuple.\nExamples\n&gt;&gt;&gt; choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n...   [20, 21, 22, 23], [30, 31, 32, 33]]\n&gt;&gt;&gt; np.choose([2, 3, 1, 0], choices\n... # the first element of the result will be the first element of the\n... # third (2+1) \"array\" in choices, namely, 20; the second element\n... # will be the second element of the fourth (3+1) choice array, i.e.,\n... # 31, etc.\n... )\narray([20, 31, 12,  3])\n&gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\narray([20, 31, 12,  3])\n&gt;&gt;&gt; # because there are 4 choice arrays\n&gt;&gt;&gt; np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\narray([20,  1, 12,  3])\n&gt;&gt;&gt; # i.e., 0\n\n\nA couple examples illustrating how choose broadcasts:\n&gt;&gt;&gt; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n&gt;&gt;&gt; choices = [-10, 10]\n&gt;&gt;&gt; np.choose(a, choices)\narray([[ 10, -10,  10],\n       [-10,  10, -10],\n       [ 10, -10,  10]])\n\n\n&gt;&gt;&gt; # With thanks to Anne Archibald\n&gt;&gt;&gt; a = np.array([0, 1]).reshape((2,1,1))\n&gt;&gt;&gt; c1 = np.array([1, 2, 3]).reshape((1,3,1))\n&gt;&gt;&gt; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n&gt;&gt;&gt; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\narray([[[ 1,  1,  1,  1,  1],\n        [ 2,  2,  2,  2,  2],\n        [ 3,  3,  3,  3,  3]],\n       [[-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5]]])\n\n\n", "parameters": ["Parameters", "aint array", "choicessequence of arrays", "outarray, optional", "mode{\u2018raise\u2019 (default), \u2018wrap\u2019, \u2018clip\u2019}, optional", "Returns", "merged_arrayarray", "Raises", "ValueError: shape mismatch"], "returns": "merged_arrayarrayThe merged result.", "examples": ["; choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n...   [20, 21, 22, 23], [30, 31, 32, 33]]\n; np.choose([2, 3, 1, 0], choices\n... # the first element of the result will be the first element of the\n... # third (2+1) \"array\" in choices, namely, 20; the second element\n... # will be the second element of the fourth (3+1) choice array, i.e.,\n... # 31, etc.\n... )\narray([20, 31, 12,  3])\n; np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\narray([20, 31, 12,  3])\n; # because there are 4 choice arrays\n; np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\narray([20,  1, 12,  3])\n; # i.e., 0\n\n", "; choices = [[0, 1, 2, 3], [10, 11, 12, 13],\n...   [20, 21, 22, 23], [30, 31, 32, 33]]\n; np.choose([2, 3, 1, 0], choices\n... # the first element of the result will be the first element of the\n... # third (2+1) \"array\" in choices, namely, 20; the second element\n... # will be the second element of the fourth (3+1) choice array, i.e.,\n... # 31, etc.\n... )\narray([20, 31, 12,  3])\n; np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)\narray([20, 31, 12,  3])\n; # because there are 4 choice arrays\n; np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)\narray([20,  1, 12,  3])\n; # i.e., 0\n", "; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n; choices = [-10, 10]\n; np.choose(a, choices)\narray([[ 10, -10,  10],\n       [-10,  10, -10],\n       [ 10, -10,  10]])\n\n", "; a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n; choices = [-10, 10]\n; np.choose(a, choices)\narray([[ 10, -10,  10],\n       [-10,  10, -10],\n       [ 10, -10,  10]])\n", "; # With thanks to Anne Archibald\n; a = np.array([0, 1]).reshape((2,1,1))\n; c1 = np.array([1, 2, 3]).reshape((1,3,1))\n; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\narray([[[ 1,  1,  1,  1,  1],\n        [ 2,  2,  2,  2,  2],\n        [ 3,  3,  3,  3,  3]],\n       [[-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5]]])\n\n", "; # With thanks to Anne Archibald\n; a = np.array([0, 1]).reshape((2,1,1))\n; c1 = np.array([1, 2, 3]).reshape((1,3,1))\n; c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))\n; np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2\narray([[[ 1,  1,  1,  1,  1],\n        [ 2,  2,  2,  2,  2],\n        [ 3,  3,  3,  3,  3]],\n       [[-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5],\n        [-1, -2, -3, -4, -5]]])\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.choice", "code": "\nRandomState.choice(a, size=None, replace=True, p=None)\u00b6", "description": "Generates a random sample from a given 1-D array\n\n\nNew in version 1.7.0.\n\n\n\nNote\nNew code should use the choice method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\na1-D array-like or intIf an ndarray, a random sample is generated from its elements.\nIf an int, the random sample is generated as if a were np.arange(a)\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\nreplaceboolean, optionalWhether the sample is with or without replacement\n\np1-D array-like, optionalThe probabilities associated with each entry in a.\nIf not given the sample assumes a uniform distribution over all\nentries in a.\n\n\n\nReturns\n\nsamplessingle item or ndarrayThe generated random samples\n\n\n\nRaises\n\nValueErrorIf a is an int and less than zero, if a or p are not 1-dimensional,\nif a is an array-like of size 0, if p is not a vector of\nprobabilities, if a and p have different lengths, or if\nreplace=False and the sample size is greater than the population\nsize\n\n\n\n\n\nSee also\nrandint, shuffle, permutation\n\nGenerator.choicewhich should be used in new code\n\n\n\nExamples\nGenerate a uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n&gt;&gt;&gt; #This is equivalent to np.random.randint(0,5,3)\n\n\nGenerate a non-uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n\nGenerate a uniform random sample from np.arange(5) of size 3 without\nreplacement:\n&gt;&gt;&gt; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n\nGenerate a non-uniform random sample from np.arange(5) of size\n3 without replacement:\n&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n\nAny of the above can be repeated with an arbitrary array-like\ninstead of just integers. For instance:\n&gt;&gt;&gt; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n&gt;&gt;&gt; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n\n", "parameters": ["Parameters", "a1-D array-like or int", "sizeint or tuple of ints, optional", "replaceboolean, optional", "p1-D array-like, optional", "Returns", "samplessingle item or ndarray", "Raises", "ValueError"], "returns": "samplessingle item or ndarrayThe generated random samples", "examples": ["; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to np.random.randint(0,5,3)\n\n", "; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to np.random.randint(0,5,3)\n", "; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n", "; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n", "; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n", "; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n", "; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n", "; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.choice", "code": "\nGenerator.choice()\u00b6", "description": "choice(a, size=None, replace=True, p=None, axis=0):\nGenerates a random sample from a given 1-D array\n\nParameters\n\na1-D array-like or intIf an ndarray, a random sample is generated from its elements.\nIf an int, the random sample is generated as if a were np.arange(a)\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn from the 1-d a. If a has more\nthan one dimension, the size shape will be inserted into the\naxis dimension, so the output ndim will be a.ndim - 1 +\nlen(size). Default is None, in which case a single value is\nreturned.\n\nreplaceboolean, optionalWhether the sample is with or without replacement\n\np1-D array-like, optionalThe probabilities associated with each entry in a.\nIf not given the sample assumes a uniform distribution over all\nentries in a.\n\naxisint, optionalThe axis along which the selection is performed. The default, 0,\nselects by row.\n\nshuffleboolean, optionalWhether the sample is shuffled when sampling without replacement.\nDefault is True, False provides a speedup.\n\n\n\nReturns\n\nsamplessingle item or ndarrayThe generated random samples\n\n\n\nRaises\n\nValueErrorIf a is an int and less than zero, if p is not 1-dimensional, if\na is array-like with a size 0, if p is not a vector of\nprobabilities, if a and p have different lengths, or if\nreplace=False and the sample size is greater than the population\nsize.\n\n\n\n\n\nSee also\nintegers, shuffle, permutation\n\nExamples\nGenerate a uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; rng.choice(5, 3)\narray([0, 3, 4]) # random\n&gt;&gt;&gt; #This is equivalent to rng.integers(0,5,3)\n\n\nGenerate a non-uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; rng.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n\nGenerate a uniform random sample from np.arange(5) of size 3 without\nreplacement:\n&gt;&gt;&gt; rng.choice(5, 3, replace=False)\narray([3,1,0]) # random\n&gt;&gt;&gt; #This is equivalent to rng.permutation(np.arange(5))[:3]\n\n\nGenerate a non-uniform random sample from np.arange(5) of size\n3 without replacement:\n&gt;&gt;&gt; rng.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n\nAny of the above can be repeated with an arbitrary array-like\ninstead of just integers. For instance:\n&gt;&gt;&gt; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n&gt;&gt;&gt; rng.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n\n", "parameters": ["Parameters", "a1-D array-like or int", "sizeint or tuple of ints, optional", "replaceboolean, optional", "p1-D array-like, optional", "axisint, optional", "shuffleboolean, optional", "Returns", "samplessingle item or ndarray", "Raises", "ValueError"], "returns": "samplessingle item or ndarrayThe generated random samples", "examples": ["; rng = np.random.default_rng()\n; rng.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to rng.integers(0,5,3)\n\n", "; rng = np.random.default_rng()\n; rng.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to rng.integers(0,5,3)\n", "; rng.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n", "; rng.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n", "; rng.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to rng.permutation(np.arange(5))[:3]\n\n", "; rng.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to rng.permutation(np.arange(5))[:3]\n", "; rng.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n", "; rng.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; rng.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; rng.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n"]},
{"library": "numpy", "item_id": "numpy.random.choice", "code": "\nnumpy.random.choice(a, size=None, replace=True, p=None)\u00b6", "description": "Generates a random sample from a given 1-D array\n\n\nNew in version 1.7.0.\n\n\n\nNote\nNew code should use the choice method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\na1-D array-like or intIf an ndarray, a random sample is generated from its elements.\nIf an int, the random sample is generated as if a were np.arange(a)\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  Default is None, in which case a\nsingle value is returned.\n\nreplaceboolean, optionalWhether the sample is with or without replacement\n\np1-D array-like, optionalThe probabilities associated with each entry in a.\nIf not given the sample assumes a uniform distribution over all\nentries in a.\n\n\n\nReturns\n\nsamplessingle item or ndarrayThe generated random samples\n\n\n\nRaises\n\nValueErrorIf a is an int and less than zero, if a or p are not 1-dimensional,\nif a is an array-like of size 0, if p is not a vector of\nprobabilities, if a and p have different lengths, or if\nreplace=False and the sample size is greater than the population\nsize\n\n\n\n\n\nSee also\nrandint, shuffle, permutation\n\nGenerator.choicewhich should be used in new code\n\n\n\nExamples\nGenerate a uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n&gt;&gt;&gt; #This is equivalent to np.random.randint(0,5,3)\n\n\nGenerate a non-uniform random sample from np.arange(5) of size 3:\n&gt;&gt;&gt; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n\nGenerate a uniform random sample from np.arange(5) of size 3 without\nreplacement:\n&gt;&gt;&gt; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n&gt;&gt;&gt; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n\nGenerate a non-uniform random sample from np.arange(5) of size\n3 without replacement:\n&gt;&gt;&gt; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n\nAny of the above can be repeated with an arbitrary array-like\ninstead of just integers. For instance:\n&gt;&gt;&gt; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n&gt;&gt;&gt; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n\n", "parameters": ["Parameters", "a1-D array-like or int", "sizeint or tuple of ints, optional", "replaceboolean, optional", "p1-D array-like, optional", "Returns", "samplessingle item or ndarray", "Raises", "ValueError"], "returns": "samplessingle item or ndarrayThe generated random samples", "examples": ["; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to np.random.randint(0,5,3)\n\n", "; np.random.choice(5, 3)\narray([0, 3, 4]) # random\n; #This is equivalent to np.random.randint(0,5,3)\n", "; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n\n", "; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])\narray([3, 3, 0]) # random\n", "; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n\n", "; np.random.choice(5, 3, replace=False)\narray([3,1,0]) # random\n; #This is equivalent to np.random.permutation(np.arange(5))[:3]\n", "; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n\n", "; np.random.choice(5, 3, replace=False, p=[0.1, 0, 0.3, 0.6, 0])\narray([2, 3, 0]) # random\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n\n", "; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']\n; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])\narray(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random\n      dtype='&lt;U11')\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.chisquare", "code": "\nRandomState.chisquare(df, size=None)\u00b6", "description": "Draw samples from a chi-square distribution.\nWhen df independent random variables, each with standard normal\ndistributions (mean 0, variance 1), are squared and summed, the\nresulting distribution is chi-square (see Notes).  This distribution\nis often used in hypothesis testing.\n\nNote\nNew code should use the chisquare method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsNumber of degrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized chi-square distribution.\n\n\n\nRaises\n\nValueErrorWhen df &lt;= 0 or when an inappropriate size (e.g. size=-1)\nis given.\n\n\n\n\n\nSee also\n\nGenerator.chisquarewhich should be used for new code.\n\n\n\nNotes\nThe variable obtained by summing the squares of df independent,\nstandard normally distributed random variables:\n\n\nis chi-square distributed, denoted\n\n\nThe probability density function of the chi-squared distribution is\n\n\nwhere  is the gamma function,\n\n\nReferences\n\n1\nNIST \u201cEngineering Statistics Handbook\u201d\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n\n\nExamples\n&gt;&gt;&gt; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized chi-square distribution.", "examples": ["; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n", "; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebzero", "code": "\nnumpy.polynomial.chebyshev.chebzero = array([0])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev", "code": "\nclass numpy.polynomial.chebyshev.Chebyshev(coef, domain=None, window=None)[source]\u00b6", "description": "A Chebyshev series class.\nThe Chebyshev class provides the standard Python numerical methods\n\u2018+\u2019, \u2018-\u2018, \u2018*\u2019, \u2018//\u2019, \u2018%\u2019, \u2018divmod\u2019, \u2018**\u2019, and \u2018()\u2019 as well as the\nmethods listed below.\n\nParameters\n\ncoefarray_likeChebyshev coefficients in order of increasing degree, i.e.,\n(1, 2, 3) gives 1*T_0(x) + 2*T_1(x) + 3*T_2(x).\n\ndomain(2,) array_like, optionalDomain to use. The interval [domain[0], domain[1]] is mapped\nto the interval [window[0], window[1]] by shifting and scaling.\nThe default value is [-1, 1].\n\nwindow(2,) array_like, optionalWindow, see domain for its use. The default value is [-1, 1].\n\nNew in version 1.6.0.\n\n\n\n\n\nMethods\n\n\n\n\n\n\n__call__(self,\u00a0arg)\nCall self as a function.\n\nbasis(deg[,\u00a0domain,\u00a0window])\nSeries basis polynomial of degree deg.\n\ncast(series[,\u00a0domain,\u00a0window])\nConvert series to series of this class.\n\nconvert(self[,\u00a0domain,\u00a0kind,\u00a0window])\nConvert series to a different kind and/or domain and/or window.\n\ncopy(self)\nReturn a copy.\n\ncutdeg(self,\u00a0deg)\nTruncate series to the given degree.\n\ndegree(self)\nThe degree of the series.\n\nderiv(self[,\u00a0m])\nDifferentiate.\n\nfit(x,\u00a0y,\u00a0deg[,\u00a0domain,\u00a0rcond,\u00a0full,\u00a0w,\u00a0window])\nLeast squares fit to data.\n\nfromroots(roots[,\u00a0domain,\u00a0window])\nReturn series instance that has the specified roots.\n\nhas_samecoef(self,\u00a0other)\nCheck if coefficients match.\n\nhas_samedomain(self,\u00a0other)\nCheck if domains match.\n\nhas_sametype(self,\u00a0other)\nCheck if types match.\n\nhas_samewindow(self,\u00a0other)\nCheck if windows match.\n\nidentity([domain,\u00a0window])\nIdentity function.\n\ninteg(self[,\u00a0m,\u00a0k,\u00a0lbnd])\nIntegrate.\n\ninterpolate(func,\u00a0deg[,\u00a0domain,\u00a0args])\nInterpolate a function at the Chebyshev points of the first kind.\n\nlinspace(self[,\u00a0n,\u00a0domain])\nReturn x, y values at equally spaced points in domain.\n\nmapparms(self)\nReturn the mapping parameters.\n\nroots(self)\nReturn the roots of the series polynomial.\n\ntrim(self[,\u00a0tol])\nRemove trailing coefficients\n\ntruncate(self,\u00a0size)\nTruncate series to length size.\n\n\n\n", "parameters": ["Parameters", "coefarray_like", "domain(2,) array_like, optional", "window(2,) array_like, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.chisquare", "code": "\nGenerator.chisquare(df, size=None)\u00b6", "description": "Draw samples from a chi-square distribution.\nWhen df independent random variables, each with standard normal\ndistributions (mean 0, variance 1), are squared and summed, the\nresulting distribution is chi-square (see Notes).  This distribution\nis often used in hypothesis testing.\n\nParameters\n\ndffloat or array_like of floatsNumber of degrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized chi-square distribution.\n\n\n\nRaises\n\nValueErrorWhen df &lt;= 0 or when an inappropriate size (e.g. size=-1)\nis given.\n\n\n\n\nNotes\nThe variable obtained by summing the squares of df independent,\nstandard normally distributed random variables:\n\n\nis chi-square distributed, denoted\n\n\nThe probability density function of the chi-squared distribution is\n\n\nwhere  is the gamma function,\n\n\nReferences\n\n1\nNIST \u201cEngineering Statistics Handbook\u201d\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n\n\nExamples\n&gt;&gt;&gt; np.random.default_rng().chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized chi-square distribution.", "examples": ["; np.random.default_rng().chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n", "; np.random.default_rng().chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebx", "code": "\nnumpy.polynomial.chebyshev.chebx = array([0, 1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.chisquare", "code": "\nnumpy.random.chisquare(df, size=None)\u00b6", "description": "Draw samples from a chi-square distribution.\nWhen df independent random variables, each with standard normal\ndistributions (mean 0, variance 1), are squared and summed, the\nresulting distribution is chi-square (see Notes).  This distribution\nis often used in hypothesis testing.\n\nNote\nNew code should use the chisquare method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\ndffloat or array_like of floatsNumber of degrees of freedom, must be &gt; 0.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if df is a scalar.  Otherwise,\nnp.array(df).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized chi-square distribution.\n\n\n\nRaises\n\nValueErrorWhen df &lt;= 0 or when an inappropriate size (e.g. size=-1)\nis given.\n\n\n\n\n\nSee also\n\nGenerator.chisquarewhich should be used for new code.\n\n\n\nNotes\nThe variable obtained by summing the squares of df independent,\nstandard normally distributed random variables:\n\n\nis chi-square distributed, denoted\n\n\nThe probability density function of the chi-squared distribution is\n\n\nwhere  is the gamma function,\n\n\nReferences\n\n1\nNIST \u201cEngineering Statistics Handbook\u201d\nhttps://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n\n\nExamples\n&gt;&gt;&gt; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n\n", "parameters": ["Parameters", "dffloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar", "Raises", "ValueError"], "returns": "outndarray or scalarDrawn samples from the parameterized chi-square distribution.", "examples": ["; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n\n", "; np.random.chisquare(2,4)\narray([ 1.89920014,  9.00867716,  3.13710533,  5.62318272]) # random\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebweight", "code": "\nnumpy.polynomial.chebyshev.chebweight(x)[source]\u00b6", "description": "The weight function of the Chebyshev polynomials.\nThe weight function is  and the interval of\nintegration is . The Chebyshev polynomials are\northogonal, but not normalized, with respect to this weight function.\n\nParameters\n\nxarray_likeValues at which the weight function will be computed.\n\n\n\nReturns\n\nwndarrayThe weight function at x.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "xarray_like", "Returns", "wndarray"], "returns": "wndarrayThe weight function at x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebvander3d", "code": "\nnumpy.polynomial.chebyshev.chebvander3d(x, y, z, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y, z). If l, m, n are the given degrees in x, y, z,\nthen The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= l, 0 &lt;= j &lt;= m, and 0 &lt;= j &lt;= n.  The leading\nindices of V index the points (x, y, z) and the last index encodes\nthe degrees of the Chebyshev polynomials.\nIf V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg]), then the columns\nof V correspond to the elements of a 3-D coefficient array c of\nshape (xdeg + 1, ydeg + 1, zdeg + 1) in the order\n\n\nand np.dot(V, c.flat) and chebval3d(x, y, z, c) will be the\nsame up to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 3-D Chebyshev\nseries of the same degrees and sample points.\n\nParameters\n\nx, y, zarray_likeArrays of point coordinates, all of the same shape. The dtypes will\nbe converted to either float64 or complex128 depending on whether\nany of the elements are complex. Scalars are converted to 1-D\narrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg, z_deg].\n\n\n\nReturns\n\nvander3dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will\nbe the same as the converted x, y, and z.\n\n\n\n\n\nSee also\nchebvander, chebvander3d, chebval2d, chebval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like", "deglist of ints", "Returns", "vander3dndarray"], "returns": "vander3dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype willbe the same as the converted x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebvander2d", "code": "\nnumpy.polynomial.chebyshev.chebvander2d(x, y, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degrees.\nReturns the pseudo-Vandermonde matrix of degrees deg and sample\npoints (x, y). The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg[0] and 0 &lt;= j &lt;= deg[1]. The leading indices of\nV index the points (x, y) and the last index encodes the degrees of\nthe Chebyshev polynomials.\nIf V = chebvander2d(x, y, [xdeg, ydeg]), then the columns of V\ncorrespond to the elements of a 2-D coefficient array c of shape\n(xdeg + 1, ydeg + 1) in the order\n\n\nand np.dot(V, c.flat) and chebval2d(x, y, c) will be the same\nup to roundoff. This equivalence is useful both for least squares\nfitting and for the evaluation of a large number of 2-D Chebyshev\nseries of the same degrees and sample points.\n\nParameters\n\nx, yarray_likeArrays of point coordinates, all of the same shape. The dtypes\nwill be converted to either float64 or complex128 depending on\nwhether any of the elements are complex. Scalars are converted to\n1-D arrays.\n\ndeglist of intsList of maximum degrees of the form [x_deg, y_deg].\n\n\n\nReturns\n\nvander2dndarrayThe shape of the returned matrix is x.shape + (order,), where\n.  The dtype will be the same\nas the converted x and y.\n\n\n\n\n\nSee also\nchebvander, chebvander3d, chebval2d, chebval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like", "deglist of ints", "Returns", "vander2dndarray"], "returns": "vander2dndarrayThe shape of the returned matrix is x.shape + (order,), where.  The dtype will be the sameas the converted x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebvander", "code": "\nnumpy.polynomial.chebyshev.chebvander(x, deg)[source]\u00b6", "description": "Pseudo-Vandermonde matrix of given degree.\nReturns the pseudo-Vandermonde matrix of degree deg and sample points\nx. The pseudo-Vandermonde matrix is defined by\n\n\nwhere 0 &lt;= i &lt;= deg. The leading indices of V index the elements of\nx and the last index is the degree of the Chebyshev polynomial.\nIf c is a 1-D array of coefficients of length n + 1 and V is the\nmatrix V = chebvander(x, n), then np.dot(V, c) and\nchebval(x, c) are the same up to roundoff.  This equivalence is\nuseful both for least squares fitting and for the evaluation of a large\nnumber of Chebyshev series of the same degree and sample points.\n\nParameters\n\nxarray_likeArray of points. The dtype is converted to float64 or complex128\ndepending on whether any of the elements are complex. If x is\nscalar it is converted to a 1-D array.\n\ndegintDegree of the resulting matrix.\n\n\n\nReturns\n\nvanderndarrayThe pseudo Vandermonde matrix. The shape of the returned matrix is\nx.shape + (deg + 1,), where The last index is the degree of the\ncorresponding Chebyshev polynomial.  The dtype will be the same as\nthe converted x.\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "degint", "Returns", "vanderndarray"], "returns": "vanderndarrayThe pseudo Vandermonde matrix. The shape of the returned matrix isx.shape + (deg + 1,), where The last index is the degree of thecorresponding Chebyshev polynomial.  The dtype will be the same asthe converted x.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebval3d", "code": "\nnumpy.polynomial.chebyshev.chebval3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Chebyshev series at points (x, y, z).\nThis function returns the values:\n\n\nThe parameters x, y, and z are converted to arrays only if\nthey are tuples or a lists, otherwise they are treated as a scalars and\nthey must have the same shape after conversion. In either case, either\nx, y, and z or their elements must support multiplication and\naddition both with themselves and with the elements of c.\nIf c has fewer than 3 dimensions, ones are implicitly appended to its\nshape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectThe three dimensional series is evaluated at the points\n(x, y, z), where x, y, and z must have the same shape.  If\nany of x, y, or z is a list or tuple, it is first converted\nto an ndarray, otherwise it is left unchanged and if it isn\u2019t an\nndarray it is  treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j,k is contained in c[i,j,k]. If c has dimension\ngreater than 3 the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the multidimensional polynomial on points formed with\ntriples of corresponding values from x, y, and z.\n\n\n\n\n\nSee also\nchebval, chebval2d, chebgrid2d, chebgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible object", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the multidimensional polynomial on points formed withtriples of corresponding values from x, y, and z.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebval2d", "code": "\nnumpy.polynomial.chebyshev.chebval2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Chebyshev series at points (x, y).\nThis function returns the values:\n\n\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars and they\nmust have the same shape after conversion. In either case, either x\nand y or their elements must support multiplication and addition both\nwith themselves and with the elements of c.\nIf c is a 1-D array a one is implicitly appended to its shape to make\nit 2-D. The shape of the result will be c.shape[2:] + x.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points (x, y),\nwhere x and y must have the same shape. If x or y is a list\nor tuple, it is first converted to an ndarray, otherwise it is left\nunchanged and if it isn\u2019t an ndarray it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term\nof multi-degree i,j is contained in c[i,j]. If c has\ndimension greater than 2 the remaining indices enumerate multiple\nsets of coefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional Chebyshev series at points formed\nfrom pairs of corresponding values from x and y.\n\n\n\n\n\nSee also\nchebval, chebgrid2d, chebval3d, chebgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional Chebyshev series at points formedfrom pairs of corresponding values from x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebval", "code": "\nnumpy.polynomial.chebyshev.chebval(x, c, tensor=True)[source]\u00b6", "description": "Evaluate a Chebyshev series at points x.\nIf c is of length n + 1, this function returns the value:\n\n\nThe parameter x is converted to an array only if it is a tuple or a\nlist, otherwise it is treated as a scalar. In either case, either x\nor its elements must support multiplication and addition both with\nthemselves and with the elements of c.\nIf c is a 1-D array, then p(x) will have the same shape as x.  If\nc is multidimensional, then the shape of the result depends on the\nvalue of tensor. If tensor is true the shape will be c.shape[1:] +\nx.shape. If tensor is false the shape will be c.shape[1:]. Note that\nscalars have shape (,).\nTrailing zeros in the coefficients will be used in the evaluation, so\nthey should be avoided if efficiency is a concern.\n\nParameters\n\nxarray_like, compatible objectIf x is a list or tuple, it is converted to an ndarray, otherwise\nit is left unchanged and treated as a scalar. In either case, x\nor its elements must support addition and multiplication with\nwith themselves and with the elements of c.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree n are contained in c[n]. If c is multidimensional the\nremaining indices enumerate multiple polynomials. In the two\ndimensional case the coefficients may be thought of as stored in\nthe columns of c.\n\ntensorboolean, optionalIf True, the shape of the coefficient array is extended with ones\non the right, one for each dimension of x. Scalars have dimension 0\nfor this action. The result is that every column of coefficients in\nc is evaluated for every element of x. If False, x is broadcast\nover the columns of c for the evaluation.  This keyword is useful\nwhen c is multidimensional. The default value is True.\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nvaluesndarray, algebra_likeThe shape of the return value is described above.\n\n\n\n\n\nSee also\nchebval2d, chebgrid2d, chebval3d, chebgrid3d\n\nNotes\nThe evaluation uses Clenshaw recursion, aka synthetic division.\n", "parameters": ["Parameters", "xarray_like, compatible object", "carray_like", "tensorboolean, optional", "Returns", "valuesndarray, algebra_like"], "returns": "valuesndarray, algebra_likeThe shape of the return value is described above.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebtrim", "code": "\nnumpy.polynomial.chebyshev.chebtrim(c, tol=0)[source]\u00b6", "description": "Remove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\u201cSmall\u201d means \u201csmall in absolute value\u201d and is controlled by the\nparameter tol; \u201ctrailing\u201d means highest order coefficient(s), e.g., in\n[0, 1, 1, 0, 0] (which represents 0 + x + x**2 + 0*x**3 + 0*x**4)\nboth the 3-rd and 4-th order coefficients would be \u201ctrimmed.\u201d\n\nParameters\n\ncarray_like1-d array of coefficients, ordered from lowest order to highest.\n\ntolnumber, optionalTrailing (i.e., highest order) elements with absolute value less\nthan or equal to tol (default value is zero) are removed.\n\n\n\nReturns\n\ntrimmedndarray1-d array with trailing zeros removed.  If the resulting series\nwould be empty, a series containing a single zero is returned.\n\n\n\nRaises\n\nValueErrorIf tol &lt; 0\n\n\n\n\n\nSee also\ntrimseq\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n&gt;&gt;&gt; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n&gt;&gt;&gt; i = complex(0,1) # works for complex\n&gt;&gt;&gt; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n\n", "parameters": ["Parameters", "carray_like", "tolnumber, optional", "Returns", "trimmedndarray", "Raises", "ValueError"], "returns": "trimmedndarray1-d array with trailing zeros removed.  If the resulting serieswould be empty, a series containing a single zero is returned.", "examples": ["; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n\n", "; from numpy.polynomial import polyutils as pu\n; pu.trimcoef((0,0,3,0,5,0,0))\narray([0.,  0.,  3.,  0.,  5.])\n; pu.trimcoef((0,0,1e-3,0,1e-5,0,0),1e-3) # item == tol is trimmed\narray([0.])\n; i = complex(0,1) # works for complex\n; pu.trimcoef((3e-4,1e-3*(1-i),5e-4,2e-5*(1+i)), 1e-3)\narray([0.0003+0.j   , 0.001 -0.001j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebsub", "code": "\nnumpy.polynomial.chebyshev.chebsub(c1, c2)[source]\u00b6", "description": "Subtract one Chebyshev series from another.\nReturns the difference of two Chebyshev series c1 - c2.  The\nsequences of coefficients are from lowest order term to highest, i.e.,\n[1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Chebyshev series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Chebyshev series coefficients representing their difference.\n\n\n\n\n\nSee also\nchebadd, chebmulx, chebmul, chebdiv, chebpow\n\nNotes\nUnlike multiplication, division, etc., the difference of two Chebyshev\nseries is a Chebyshev series (without having to \u201creproject\u201d the result\nonto the basis set) so subtraction, just like that of \u201cstandard\u201d\npolynomials, is simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; C.chebsub(c1,c2)\narray([-2.,  0.,  2.])\n&gt;&gt;&gt; C.chebsub(c2,c1) # -C.chebsub(c1,c2)\narray([ 2.,  0., -2.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Chebyshev series coefficients representing their difference.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebsub(c1,c2)\narray([-2.,  0.,  2.])\n; C.chebsub(c2,c1) # -C.chebsub(c1,c2)\narray([ 2.,  0., -2.])\n\n", "; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebsub(c1,c2)\narray([-2.,  0.,  2.])\n; C.chebsub(c2,c1) # -C.chebsub(c1,c2)\narray([ 2.,  0., -2.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebroots", "code": "\nnumpy.polynomial.chebyshev.chebroots(c)[source]\u00b6", "description": "Compute the roots of a Chebyshev series.\nReturn the roots (a.k.a. \u201czeros\u201d) of the polynomial\n\n\n\nParameters\n\nc1-D array_like1-D array of coefficients.\n\n\n\nReturns\n\noutndarrayArray of the roots of the series. If all the roots are real,\nthen out is also real, otherwise it is complex.\n\n\n\n\n\nSee also\npolyroots, legroots, lagroots, hermroots, hermeroots\n\nNotes\nThe root estimates are obtained as the eigenvalues of the companion\nmatrix, Roots far from the origin of the complex plane may have large\nerrors due to the numerical instability of the series for such\nvalues. Roots with multiplicity greater than 1 will also show larger\nerrors as the value of the series near such points is relatively\ninsensitive to errors in the roots. Isolated roots near the origin can\nbe improved by a few iterations of Newton\u2019s method.\nThe Chebyshev series basis polynomials aren\u2019t powers of x so the\nresults of this function may seem unintuitive.\nExamples\n&gt;&gt;&gt; import numpy.polynomial.chebyshev as cheb\n&gt;&gt;&gt; cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\narray([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary\n\n\n", "parameters": ["Parameters", "c1-D array_like", "Returns", "outndarray"], "returns": "outndarrayArray of the roots of the series. If all the roots are real,then out is also real, otherwise it is complex.", "examples": ["; import numpy.polynomial.chebyshev as cheb\n; cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\narray([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary\n\n", "; import numpy.polynomial.chebyshev as cheb\n; cheb.chebroots((-1, 1,-1, 1)) # T3 - T2 + T1 - T0 has real roots\narray([ -5.00000000e-01,   2.60860684e-17,   1.00000000e+00]) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebone", "code": "\nnumpy.polynomial.chebyshev.chebone = array([1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebmulx", "code": "\nnumpy.polynomial.chebyshev.chebmulx(c)[source]\u00b6", "description": "Multiply a Chebyshev series by x.\nMultiply the polynomial c by x, where x is the independent\nvariable.\n\nParameters\n\ncarray_like1-D array of Chebyshev series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the result of the multiplication.\n\n\n\n\nNotes\n\nNew in version 1.5.0.\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; C.chebmulx([1,2,3])\narray([1. , 2.5, 1. , 1.5])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the result of the multiplication.", "examples": ["; from numpy.polynomial import chebyshev as C\n; C.chebmulx([1,2,3])\narray([1. , 2.5, 1. , 1.5])\n\n", "; from numpy.polynomial import chebyshev as C\n; C.chebmulx([1,2,3])\narray([1. , 2.5, 1. , 1.5])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebpow", "code": "\nnumpy.polynomial.chebyshev.chebpow(c, pow, maxpower=16)[source]\u00b6", "description": "Raise a Chebyshev series to a power.\nReturns the Chebyshev series c raised to the power pow. The\nargument c is a sequence of coefficients ordered from low to high.\ni.e., [1,2,3] is the series  T_0 + 2*T_1 + 3*T_2.\n\nParameters\n\ncarray_like1-D array of Chebyshev series coefficients ordered from low to\nhigh.\n\npowintegerPower to which the series will be raised\n\nmaxpowerinteger, optionalMaximum power allowed. This is mainly to limit growth of the series\nto unmanageable size. Default is 16\n\n\n\nReturns\n\ncoefndarrayChebyshev series of power.\n\n\n\n\n\nSee also\nchebadd, chebsub, chebmulx, chebmul, chebdiv\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; C.chebpow([1, 2, 3, 4], 2)\narray([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])\n\n\n", "parameters": ["Parameters", "carray_like", "powinteger", "maxpowerinteger, optional", "Returns", "coefndarray"], "returns": "coefndarrayChebyshev series of power.", "examples": ["; from numpy.polynomial import chebyshev as C\n; C.chebpow([1, 2, 3, 4], 2)\narray([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])\n\n", "; from numpy.polynomial import chebyshev as C\n; C.chebpow([1, 2, 3, 4], 2)\narray([15.5, 22. , 16. , ..., 12.5, 12. ,  8. ])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebmul", "code": "\nnumpy.polynomial.chebyshev.chebmul(c1, c2)[source]\u00b6", "description": "Multiply one Chebyshev series by another.\nReturns the product of two Chebyshev series c1 * c2.  The arguments\nare sequences of coefficients, from lowest order \u201cterm\u201d to highest,\ne.g., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Chebyshev series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayOf Chebyshev series coefficients representing their product.\n\n\n\n\n\nSee also\nchebadd, chebsub, chebmulx, chebdiv, chebpow\n\nNotes\nIn general, the (polynomial) product of two C-series results in terms\nthat are not in the Chebyshev polynomial basis set.  Thus, to express\nthe product as a C-series, it is typically necessary to \u201creproject\u201d\nthe product onto said basis set, which typically produces\n\u201cunintuitive live\u201d (but correct) results; see Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; C.chebmul(c1,c2) # multiplication requires \"reprojection\"\narray([  6.5,  12. ,  12. ,   4. ,   1.5])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayOf Chebyshev series coefficients representing their product.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebmul(c1,c2) # multiplication requires \"reprojection\"\narray([  6.5,  12. ,  12. ,   4. ,   1.5])\n\n", "; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebmul(c1,c2) # multiplication requires \"reprojection\"\narray([  6.5,  12. ,  12. ,   4. ,   1.5])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebint", "code": "\nnumpy.polynomial.chebyshev.chebint(c, m=1, k=[], lbnd=0, scl=1, axis=0)[source]\u00b6", "description": "Integrate a Chebyshev series.\nReturns the Chebyshev series coefficients c integrated m times from\nlbnd along axis. At each iteration the resulting series is\nmultiplied by scl and an integration constant, k, is added.\nThe scaling factor is for use in a linear change of variable.  (\u201cBuyer\nbeware\u201d: note that, depending on what one is doing, one may want scl\nto be the reciprocal of what one might expect; for more information,\nsee the Notes section below.)  The argument c is an array of\ncoefficients from low to high degree along each axis, e.g., [1,2,3]\nrepresents the series T_0 + 2*T_1 + 3*T_2 while [[1,2],[1,2]]\nrepresents 1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) + 2*T_0(x)*T_1(y) +\n2*T_1(x)*T_1(y) if axis=0 is x and axis=1 is y.\n\nParameters\n\ncarray_likeArray of Chebyshev series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalOrder of integration, must be positive. (Default: 1)\n\nk{[], list, scalar}, optionalIntegration constant(s).  The value of the first integral at zero\nis the first value in the list, the value of the second integral\nat zero is the second value, etc.  If k == [] (the default),\nall constants are set to zero.  If m == 1, a single scalar can\nbe given instead of a list.\n\nlbndscalar, optionalThe lower bound of the integral. (Default: 0)\n\nsclscalar, optionalFollowing each integration the result is multiplied by scl\nbefore the integration constant is added. (Default: 1)\n\naxisint, optionalAxis over which the integral is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nSndarrayC-series coefficients of the integral.\n\n\n\nRaises\n\nValueErrorIf m &lt; 1, len(k) &gt; m, np.ndim(lbnd) != 0, or\nnp.ndim(scl) != 0.\n\n\n\n\n\nSee also\nchebder\n\nNotes\nNote that the result of each integration is multiplied by scl.\nWhy is this important to note?  Say one is making a linear change of\nvariable  in an integral relative to x.  Then\n, so one will need to set scl equal to\n- perhaps not what one would have first thought.\nAlso note that, in general, the result of integrating a C-series needs\nto be \u201creprojected\u201d onto the C-series basis set.  Thus, typically,\nthe result of this function is \u201cunintuitive,\u201d albeit correct; see\nExamples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c = (1,2,3)\n&gt;&gt;&gt; C.chebint(c)\narray([ 0.5, -0.5,  0.5,  0.5])\n&gt;&gt;&gt; C.chebint(c,3)\narray([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667, # may vary\n    0.00625   ])\n&gt;&gt;&gt; C.chebint(c, k=3)\narray([ 3.5, -0.5,  0.5,  0.5])\n&gt;&gt;&gt; C.chebint(c,lbnd=-2)\narray([ 8.5, -0.5,  0.5,  0.5])\n&gt;&gt;&gt; C.chebint(c,scl=-2)\narray([-1.,  1., -1., -1.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "k{[], list, scalar}, optional", "lbndscalar, optional", "sclscalar, optional", "axisint, optional", "Returns", "Sndarray", "Raises", "ValueError"], "returns": "SndarrayC-series coefficients of the integral.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c = (1,2,3)\n; C.chebint(c)\narray([ 0.5, -0.5,  0.5,  0.5])\n; C.chebint(c,3)\narray([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667, # may vary\n    0.00625   ])\n; C.chebint(c, k=3)\narray([ 3.5, -0.5,  0.5,  0.5])\n; C.chebint(c,lbnd=-2)\narray([ 8.5, -0.5,  0.5,  0.5])\n; C.chebint(c,scl=-2)\narray([-1.,  1., -1., -1.])\n\n", "; from numpy.polynomial import chebyshev as C\n; c = (1,2,3)\n; C.chebint(c)\narray([ 0.5, -0.5,  0.5,  0.5])\n; C.chebint(c,3)\narray([ 0.03125   , -0.1875    ,  0.04166667, -0.05208333,  0.01041667, # may vary\n    0.00625   ])\n; C.chebint(c, k=3)\narray([ 3.5, -0.5,  0.5,  0.5])\n; C.chebint(c,lbnd=-2)\narray([ 8.5, -0.5,  0.5,  0.5])\n; C.chebint(c,scl=-2)\narray([-1.,  1., -1., -1.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebline", "code": "\nnumpy.polynomial.chebyshev.chebline(off, scl)[source]\u00b6", "description": "Chebyshev series whose graph is a straight line.\n\nParameters\n\noff, sclscalarsThe specified line is given by off + scl*x.\n\n\n\nReturns\n\nyndarrayThis module\u2019s representation of the Chebyshev series for\noff + scl*x.\n\n\n\n\n\nSee also\npolyline\n\nExamples\n&gt;&gt;&gt; import numpy.polynomial.chebyshev as C\n&gt;&gt;&gt; C.chebline(3,2)\narray([3, 2])\n&gt;&gt;&gt; C.chebval(-3, C.chebline(3,2)) # should be -3\n-3.0\n\n\n", "parameters": ["Parameters", "off, sclscalars", "Returns", "yndarray"], "returns": "yndarrayThis module\u2019s representation of the Chebyshev series foroff + scl*x.", "examples": ["; import numpy.polynomial.chebyshev as C\n; C.chebline(3,2)\narray([3, 2])\n; C.chebval(-3, C.chebline(3,2)) # should be -3\n-3.0\n\n", "; import numpy.polynomial.chebyshev as C\n; C.chebline(3,2)\narray([3, 2])\n; C.chebval(-3, C.chebline(3,2)) # should be -3\n-3.0\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebgrid3d", "code": "\nnumpy.polynomial.chebyshev.chebgrid3d(x, y, z, c)[source]\u00b6", "description": "Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.\nThis function returns the values:\n\n\nwhere the points (a, b, c) consist of all triples formed by taking\na from x, b from y, and c from z. The resulting points form\na grid with x in the first dimension, y in the second, and z in\nthe third.\nThe parameters x, y, and z are converted to arrays only if they\nare tuples or a lists, otherwise they are treated as a scalars. In\neither case, either x, y, and z or their elements must support\nmultiplication and addition both with themselves and with the elements\nof c.\nIf c has fewer than three dimensions, ones are implicitly appended to\nits shape to make it 3-D. The shape of the result will be c.shape[3:] +\nx.shape + y.shape + z.shape.\n\nParameters\n\nx, y, zarray_like, compatible objectsThe three dimensional series is evaluated at the points in the\nCartesian product of x, y, and z.  If x,`y`, or z is a\nlist or tuple, it is first converted to an ndarray, otherwise it is\nleft unchanged and, if it isn\u2019t an ndarray, it is treated as a\nscalar.\n\ncarray_likeArray of coefficients ordered so that the coefficients for terms of\ndegree i,j are contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesian\nproduct of x and y.\n\n\n\n\n\nSee also\nchebval, chebval2d, chebgrid2d, chebval3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, y, zarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional polynomial at points in the Cartesianproduct of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebgrid2d", "code": "\nnumpy.polynomial.chebyshev.chebgrid2d(x, y, c)[source]\u00b6", "description": "Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.\nThis function returns the values:\n\n\nwhere the points (a, b) consist of all pairs formed by taking\na from x and b from y. The resulting points form a grid with\nx in the first dimension and y in the second.\nThe parameters x and y are converted to arrays only if they are\ntuples or a lists, otherwise they are treated as a scalars. In either\ncase, either x and y or their elements must support multiplication\nand addition both with themselves and with the elements of c.\nIf c has fewer than two dimensions, ones are implicitly appended to\nits shape to make it 2-D. The shape of the result will be c.shape[2:] +\nx.shape + y.shape.\n\nParameters\n\nx, yarray_like, compatible objectsThe two dimensional series is evaluated at the points in the\nCartesian product of x and y.  If x or y is a list or\ntuple, it is first converted to an ndarray, otherwise it is left\nunchanged and, if it isn\u2019t an ndarray, it is treated as a scalar.\n\ncarray_likeArray of coefficients ordered so that the coefficient of the term of\nmulti-degree i,j is contained in c[i,j]. If c has dimension\ngreater than two the remaining indices enumerate multiple sets of\ncoefficients.\n\n\n\nReturns\n\nvaluesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in the\nCartesian product of x and y.\n\n\n\n\n\nSee also\nchebval, chebval2d, chebval3d, chebgrid3d\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "x, yarray_like, compatible objects", "carray_like", "Returns", "valuesndarray, compatible object"], "returns": "valuesndarray, compatible objectThe values of the two dimensional Chebyshev series at points in theCartesian product of x and y.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebfromroots", "code": "\nnumpy.polynomial.chebyshev.chebfromroots(roots)[source]\u00b6", "description": "Generate a Chebyshev series with given roots.\nThe function returns the coefficients of the polynomial\n\n\nin Chebyshev form, where the r_n are the roots specified in roots.\nIf a zero has multiplicity n, then it must appear in roots n times.\nFor instance, if 2 is a root of multiplicity three and 3 is a root of\nmultiplicity 2, then roots looks something like [2, 2, 2, 3, 3]. The\nroots can appear in any order.\nIf the returned coefficients are c, then\n\n\nThe coefficient of the last term is not generally 1 for monic\npolynomials in Chebyshev form.\n\nParameters\n\nrootsarray_likeSequence containing the roots.\n\n\n\nReturns\n\noutndarray1-D array of coefficients.  If all roots are real then out is a\nreal array, if some of the roots are complex, then out is complex\neven if all the coefficients in the result are real (see Examples\nbelow).\n\n\n\n\n\nSee also\npolyfromroots, legfromroots, lagfromroots, hermfromroots, hermefromroots\n\nExamples\n&gt;&gt;&gt; import numpy.polynomial.chebyshev as C\n&gt;&gt;&gt; C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0.  , -0.25,  0.  ,  0.25])\n&gt;&gt;&gt; j = complex(0,1)\n&gt;&gt;&gt; C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([1.5+0.j, 0. +0.j, 0.5+0.j])\n\n\n", "parameters": ["Parameters", "rootsarray_like", "Returns", "outndarray"], "returns": "outndarray1-D array of coefficients.  If all roots are real then out is areal array, if some of the roots are complex, then out is complexeven if all the coefficients in the result are real (see Examplesbelow).", "examples": ["; import numpy.polynomial.chebyshev as C\n; C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0.  , -0.25,  0.  ,  0.25])\n; j = complex(0,1)\n; C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([1.5+0.j, 0. +0.j, 0.5+0.j])\n\n", "; import numpy.polynomial.chebyshev as C\n; C.chebfromroots((-1,0,1)) # x^3 - x relative to the standard basis\narray([ 0.  , -0.25,  0.  ,  0.25])\n; j = complex(0,1)\n; C.chebfromroots((-j,j)) # x^2 + 1 relative to the standard basis\narray([1.5+0.j, 0. +0.j, 0.5+0.j])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebfit", "code": "\nnumpy.polynomial.chebyshev.chebfit(x, y, deg, rcond=None, full=False, w=None)[source]\u00b6", "description": "Least squares fit of Chebyshev series to data.\nReturn the coefficients of a Chebyshev series of degree deg that is the\nleast squares fit to the data values y given at points x. If y is\n1-D the returned coefficients will also be 1-D. If y is 2-D multiple\nfits are done, one for each column of y, and the resulting\ncoefficients are stored in the corresponding columns of a 2-D return.\nThe fitted polynomial(s) are in the form\n\n\nwhere n is deg.\n\nParameters\n\nxarray_like, shape (M,)x-coordinates of the M sample points (x[i], y[i]).\n\nyarray_like, shape (M,) or (M, K)y-coordinates of the sample points. Several data sets of sample\npoints sharing the same x-coordinates can be fitted at once by\npassing in a 2D-array that contains one dataset per column.\n\ndegint or 1-D array_likeDegree(s) of the fitting polynomials. If deg is a single integer,\nall terms up to and including the deg\u2019th term are included in the\nfit. For NumPy versions &gt;= 1.11.0 a list of integers specifying the\ndegrees of the terms to include may be used instead.\n\nrcondfloat, optionalRelative condition number of the fit. Singular values smaller than\nthis relative to the largest singular value will be ignored. The\ndefault value is len(x)*eps, where eps is the relative precision of\nthe float type, about 2e-16 in most cases.\n\nfullbool, optionalSwitch determining nature of return value. When it is False (the\ndefault) just the coefficients are returned, when True diagnostic\ninformation from the singular value decomposition is also returned.\n\nwarray_like, shape (M,), optionalWeights. If not None, the contribution of each point\n(x[i],y[i]) to the fit is weighted by w[i]. Ideally the\nweights are chosen so that the errors of the products w[i]*y[i]\nall have the same variance.  The default value is None.\n\nNew in version 1.5.0.\n\n\n\n\nReturns\n\ncoefndarray, shape (M,) or (M, K)Chebyshev coefficients ordered from low to high. If y was 2-D,\nthe coefficients for the data in column k  of y are in column\nk.\n\n[residuals, rank, singular_values, rcond]listThese values are only returned if full = True\nresid \u2013 sum of squared residuals of the least squares fit\nrank \u2013 the numerical rank of the scaled Vandermonde matrix\nsv \u2013 singular values of the scaled Vandermonde matrix\nrcond \u2013 value of rcond.\nFor more details, see linalg.lstsq.\n\n\n\nWarns\n\nRankWarningThe rank of the coefficient matrix in the least-squares fit is\ndeficient. The warning is only raised if full = False.  The\nwarnings can be turned off by\n&gt;&gt;&gt; import warnings\n&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)\n\n\n\n\n\n\n\nSee also\npolyfit, legfit, lagfit, hermfit, hermefit\n\nchebvalEvaluates a Chebyshev series.\n\nchebvanderVandermonde matrix of Chebyshev series.\n\nchebweightChebyshev weight function.\n\nlinalg.lstsqComputes a least-squares fit from the matrix.\n\nscipy.interpolate.UnivariateSplineComputes spline fits.\n\n\n\nNotes\nThe solution is the coefficients of the Chebyshev series p that\nminimizes the sum of the weighted squared errors\n\n\nwhere  are the weights. This problem is solved by setting up\nas the (typically) overdetermined matrix equation\n\n\nwhere V is the weighted pseudo Vandermonde matrix of x, c are the\ncoefficients to be solved for, w are the weights, and y are the\nobserved values.  This equation is then solved using the singular value\ndecomposition of V.\nIf some of the singular values of V are so small that they are\nneglected, then a RankWarning will be issued. This means that the\ncoefficient values may be poorly determined. Using a lower order fit\nwill usually get rid of the warning.  The rcond parameter can also be\nset to a value smaller than its default, but the resulting fit may be\nspurious and have large contributions from roundoff error.\nFits using Chebyshev series are usually better conditioned than fits\nusing power series, but much can depend on the distribution of the\nsample points and the smoothness of the data. If the quality of the fit\nis inadequate splines may be a good alternative.\nReferences\n\n1\nWikipedia, \u201cCurve fitting\u201d,\nhttps://en.wikipedia.org/wiki/Curve_fitting\n\n\n", "parameters": ["Parameters", "xarray_like, shape (M,)", "yarray_like, shape (M,) or (M, K)", "degint or 1-D array_like", "rcondfloat, optional", "fullbool, optional", "warray_like, shape (M,), optional", "Returns", "coefndarray, shape (M,) or (M, K)", "[residuals, rank, singular_values, rcond]list", "Warns", "RankWarning"], "returns": "coefndarray, shape (M,) or (M, K)Chebyshev coefficients ordered from low to high. If y was 2-D,the coefficients for the data in column k  of y are in columnk.[residuals, rank, singular_values, rcond]listThese values are only returned if full = Trueresid \u2013 sum of squared residuals of the least squares fitrank \u2013 the numerical rank of the scaled Vandermonde matrixsv \u2013 singular values of the scaled Vandermonde matrixrcond \u2013 value of rcond.For more details, see linalg.lstsq.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebdomain", "code": "\nnumpy.polynomial.chebyshev.chebdomain = array([-1,  1])\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebcompanion", "code": "\nnumpy.polynomial.chebyshev.chebcompanion(c)[source]\u00b6", "description": "Return the scaled companion matrix of c.\nThe basis polynomials are scaled so that the companion matrix is\nsymmetric when c is a Chebyshev basis polynomial. This provides\nbetter eigenvalue estimates than the unscaled case and for basis\npolynomials the eigenvalues are guaranteed to be real if\nnumpy.linalg.eigvalsh is used to obtain them.\n\nParameters\n\ncarray_like1-D array of Chebyshev series coefficients ordered from low to high\ndegree.\n\n\n\nReturns\n\nmatndarrayScaled companion matrix of dimensions (deg, deg).\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\n", "parameters": ["Parameters", "carray_like", "Returns", "matndarray"], "returns": "matndarrayScaled companion matrix of dimensions (deg, deg).", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebdiv", "code": "\nnumpy.polynomial.chebyshev.chebdiv(c1, c2)[source]\u00b6", "description": "Divide one Chebyshev series by another.\nReturns the quotient-with-remainder of two Chebyshev series\nc1 / c2.  The arguments are sequences of coefficients from lowest\norder \u201cterm\u201d to highest, e.g., [1,2,3] represents the series\nT_0 + 2*T_1 + 3*T_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Chebyshev series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\n[quo, rem]ndarraysOf Chebyshev series coefficients representing the quotient and\nremainder.\n\n\n\n\n\nSee also\nchebadd, chebsub, chemulx, chebmul, chebpow\n\nNotes\nIn general, the (polynomial) division of one C-series by another\nresults in quotient and remainder terms that are not in the Chebyshev\npolynomial basis set.  Thus, to express these results as C-series, it\nis typically necessary to \u201creproject\u201d the results onto said basis\nset, which typically produces \u201cunintuitive\u201d (but correct) results;\nsee Examples section below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; C.chebdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n&gt;&gt;&gt; c2 = (0,1,2,3)\n&gt;&gt;&gt; C.chebdiv(c2,c1) # neither \"intuitive\"\n(array([0., 2.]), array([-2., -4.]))\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "[quo, rem]ndarrays"], "returns": "[quo, rem]ndarraysOf Chebyshev series coefficients representing the quotient andremainder.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n; c2 = (0,1,2,3)\n; C.chebdiv(c2,c1) # neither \"intuitive\"\n(array([0., 2.]), array([-2., -4.]))\n\n", "; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebdiv(c1,c2) # quotient \"intuitive,\" remainder not\n(array([3.]), array([-8., -4.]))\n; c2 = (0,1,2,3)\n; C.chebdiv(c2,c1) # neither \"intuitive\"\n(array([0., 2.]), array([-2., -4.]))\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebder", "code": "\nnumpy.polynomial.chebyshev.chebder(c, m=1, scl=1, axis=0)[source]\u00b6", "description": "Differentiate a Chebyshev series.\nReturns the Chebyshev series coefficients c differentiated m times\nalong axis.  At each iteration the result is multiplied by scl (the\nscaling factor is for use in a linear change of variable). The argument\nc is an array of coefficients from low to high degree along each\naxis, e.g., [1,2,3] represents the series 1*T_0 + 2*T_1 + 3*T_2\nwhile [[1,2],[1,2]] represents 1*T_0(x)*T_0(y) + 1*T_1(x)*T_0(y) +\n2*T_0(x)*T_1(y) + 2*T_1(x)*T_1(y) if axis=0 is x and axis=1 is\ny.\n\nParameters\n\ncarray_likeArray of Chebyshev series coefficients. If c is multidimensional\nthe different axis correspond to different variables with the\ndegree in each axis given by the corresponding index.\n\nmint, optionalNumber of derivatives taken, must be non-negative. (Default: 1)\n\nsclscalar, optionalEach differentiation is multiplied by scl.  The end result is\nmultiplication by scl**m.  This is for use in a linear change of\nvariable. (Default: 1)\n\naxisint, optionalAxis over which the derivative is taken. (Default: 0).\n\nNew in version 1.7.0.\n\n\n\n\nReturns\n\nderndarrayChebyshev series of the derivative.\n\n\n\n\n\nSee also\nchebint\n\nNotes\nIn general, the result of differentiating a C-series needs to be\n\u201creprojected\u201d onto the C-series basis set. Thus, typically, the\nresult of this function is \u201cunintuitive,\u201d albeit correct; see Examples\nsection below.\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c = (1,2,3,4)\n&gt;&gt;&gt; C.chebder(c)\narray([14., 12., 24.])\n&gt;&gt;&gt; C.chebder(c,3)\narray([96.])\n&gt;&gt;&gt; C.chebder(c,scl=-1)\narray([-14., -12., -24.])\n&gt;&gt;&gt; C.chebder(c,2,-1)\narray([12.,  96.])\n\n\n", "parameters": ["Parameters", "carray_like", "mint, optional", "sclscalar, optional", "axisint, optional", "Returns", "derndarray"], "returns": "derndarrayChebyshev series of the derivative.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c = (1,2,3,4)\n; C.chebder(c)\narray([14., 12., 24.])\n; C.chebder(c,3)\narray([96.])\n; C.chebder(c,scl=-1)\narray([-14., -12., -24.])\n; C.chebder(c,2,-1)\narray([12.,  96.])\n\n", "; from numpy.polynomial import chebyshev as C\n; c = (1,2,3,4)\n; C.chebder(c)\narray([14., 12., 24.])\n; C.chebder(c,3)\narray([96.])\n; C.chebder(c,scl=-1)\narray([-14., -12., -24.])\n; C.chebder(c,2,-1)\narray([12.,  96.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebgauss", "code": "\nnumpy.polynomial.chebyshev.chebgauss(deg)[source]\u00b6", "description": "Gauss-Chebyshev quadrature.\nComputes the sample points and weights for Gauss-Chebyshev quadrature.\nThese sample points and weights will correctly integrate polynomials of\ndegree  or less over the interval  with\nthe weight function .\n\nParameters\n\ndegintNumber of sample points and weights. It must be &gt;= 1.\n\n\n\nReturns\n\nxndarray1-D ndarray containing the sample points.\n\nyndarray1-D ndarray containing the weights.\n\n\n\n\nNotes\n\nNew in version 1.7.0.\n\nThe results have only been tested up to degree 100, higher degrees may\nbe problematic. For Gauss-Chebyshev there are closed form solutions for\nthe sample points and weights. If n = deg, then\n\n\n\n\n", "parameters": ["Parameters", "degint", "Returns", "xndarray", "yndarray"], "returns": "xndarray1-D ndarray containing the sample points.yndarray1-D ndarray containing the weights.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.chebadd", "code": "\nnumpy.polynomial.chebyshev.chebadd(c1, c2)[source]\u00b6", "description": "Add one Chebyshev series to another.\nReturns the sum of two Chebyshev series c1 + c2.  The arguments\nare sequences of coefficients ordered from lowest order term to\nhighest, i.e., [1,2,3] represents the series T_0 + 2*T_1 + 3*T_2.\n\nParameters\n\nc1, c2array_like1-D arrays of Chebyshev series coefficients ordered from low to\nhigh.\n\n\n\nReturns\n\noutndarrayArray representing the Chebyshev series of their sum.\n\n\n\n\n\nSee also\nchebsub, chebmulx, chebmul, chebdiv, chebpow\n\nNotes\nUnlike multiplication, division, etc., the sum of two Chebyshev series\nis a Chebyshev series (without having to \u201creproject\u201d the result onto\nthe basis set) so addition, just like that of \u201cstandard\u201d polynomials,\nis simply \u201ccomponent-wise.\u201d\nExamples\n&gt;&gt;&gt; from numpy.polynomial import chebyshev as C\n&gt;&gt;&gt; c1 = (1,2,3)\n&gt;&gt;&gt; c2 = (3,2,1)\n&gt;&gt;&gt; C.chebadd(c1,c2)\narray([4., 4., 4.])\n\n\n", "parameters": ["Parameters", "c1, c2array_like", "Returns", "outndarray"], "returns": "outndarrayArray representing the Chebyshev series of their sum.", "examples": ["; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebadd(c1,c2)\narray([4., 4., 4.])\n\n", "; from numpy.polynomial import chebyshev as C\n; c1 = (1,2,3)\n; c2 = (3,2,1)\n; C.chebadd(c1,c2)\narray([4., 4., 4.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.cheb2poly", "code": "\nnumpy.polynomial.chebyshev.cheb2poly(c)[source]\u00b6", "description": "Convert a Chebyshev series to a polynomial.\nConvert an array representing the coefficients of a Chebyshev series,\nordered from lowest degree to highest, to an array of the coefficients\nof the equivalent polynomial (relative to the \u201cstandard\u201d basis) ordered\nfrom lowest to highest degree.\n\nParameters\n\ncarray_like1-D array containing the Chebyshev series coefficients, ordered\nfrom lowest order term to highest.\n\n\n\nReturns\n\npolndarray1-D array containing the coefficients of the equivalent polynomial\n(relative to the \u201cstandard\u201d basis) ordered from lowest order term\nto highest.\n\n\n\n\n\nSee also\npoly2cheb\n\nNotes\nThe easy way to do conversions between polynomial basis sets\nis to use the convert method of a class instance.\nExamples\n&gt;&gt;&gt; from numpy import polynomial as P\n&gt;&gt;&gt; c = P.Chebyshev(range(4))\n&gt;&gt;&gt; c\nChebyshev([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n&gt;&gt;&gt; p = c.convert(kind=P.Polynomial)\n&gt;&gt;&gt; p\nPolynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.])\n&gt;&gt;&gt; P.chebyshev.cheb2poly(range(4))\narray([-2.,  -8.,   4.,  12.])\n\n\n", "parameters": ["Parameters", "carray_like", "Returns", "polndarray"], "returns": "polndarray1-D array containing the coefficients of the equivalent polynomial(relative to the \u201cstandard\u201d basis) ordered from lowest order termto highest.", "examples": ["; from numpy import polynomial as P\n; c = P.Chebyshev(range(4))\n; c\nChebyshev([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; p = c.convert(kind=P.Polynomial)\n; p\nPolynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.])\n; P.chebyshev.cheb2poly(range(4))\narray([-2.,  -8.,   4.,  12.])\n\n", "; from numpy import polynomial as P\n; c = P.Chebyshev(range(4))\n; c\nChebyshev([0., 1., 2., 3.], domain=[-1,  1], window=[-1,  1])\n; p = c.convert(kind=P.Polynomial)\n; p\nPolynomial([-2., -8.,  4., 12.], domain=[-1.,  1.], window=[-1.,  1.])\n; P.chebyshev.cheb2poly(range(4))\narray([-2.,  -8.,   4.,  12.])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray", "code": "\nclass numpy.char.chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0, strides=None, order=None)\u00b6", "description": "Provides a convenient view on arrays of string and unicode values.\n\nNote\nThe chararray class exists for backwards compatibility with\nNumarray, it is not recommended for new development. Starting from numpy\n1.4, if one needs arrays of strings, it is recommended to use arrays of\ndtype object_, string_ or unicode_, and use the free functions\nin the numpy.char module for fast vectorized string operations.\n\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. endswith) and infix operators (e.g. \"+\", \"*\", \"%\")\n\n\nchararrays should be created using numpy.char.array or\nnumpy.char.asarray, rather than this constructor directly.\nThis constructor creates the array, using buffer (with offset\nand strides) if it is not None. If buffer is None, then\nconstructs a new array with strides in \u201cC order\u201d, unless both\nlen(shape) &gt;= 2 and order='F', in which case strides\nis in \u201cFortran order\u201d.\n\nParameters\n\nshapetupleShape of the array.\n\nitemsizeint, optionalLength of each array element, in number of characters. Default is 1.\n\nunicodebool, optionalAre the array elements of type unicode (True) or string (False).\nDefault is False.\n\nbufferint, optionalMemory address of the start of the array data.  Default is None,\nin which case a new array is created.\n\noffsetint, optionalFixed stride displacement from the beginning of an axis?\nDefault is 0. Needs to be &gt;=0.\n\nstridesarray_like of ints, optionalStrides for the array (see ndarray.strides for full description).\nDefault is None.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalThe order in which the array data is stored in memory: \u2018C\u2019 -&gt;\n\u201crow major\u201d order (the default), \u2018F\u2019 -&gt; \u201ccolumn major\u201d\n(Fortran) order.\n\n\n\n\nExamples\n&gt;&gt;&gt; charar = np.chararray((3, 3))\n&gt;&gt;&gt; charar[:] = 'a'\n&gt;&gt;&gt; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n\n\n&gt;&gt;&gt; charar = np.chararray(charar.shape, itemsize=5)\n&gt;&gt;&gt; charar[:] = 'abc'\n&gt;&gt;&gt; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n\n\n\nAttributes\n\nTThe transposed array.\n\nbaseBase object if memory is from some other object.\n\nctypesAn object to simplify the interaction of the array with the ctypes module.\n\ndataPython buffer object pointing to the start of the array\u2019s data.\n\ndtypeData-type of the array\u2019s elements.\n\nflagsInformation about the memory layout of the array.\n\nflatA 1-D iterator over the array.\n\nimagThe imaginary part of the array.\n\nitemsizeLength of one array element in bytes.\n\nnbytesTotal bytes consumed by the elements of the array.\n\nndimNumber of array dimensions.\n\nrealThe real part of the array.\n\nshapeTuple of array dimensions.\n\nsizeNumber of elements in the array.\n\nstridesTuple of bytes to step in each dimension when traversing an array.\n\n\n\n\nMethods\n\n\n\n\n\n\nastype(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])\nCopy of the array, cast to a specified type.\n\nargsort([axis,\u00a0kind,\u00a0order])\nReturns the indices that would sort this array.\n\ncopy([order])\nReturn a copy of the array.\n\ncount(self,\u00a0sub[,\u00a0start,\u00a0end])\nReturns an array with the number of non-overlapping occurrences of substring sub in the range [start, end].\n\ndecode(self[,\u00a0encoding,\u00a0errors])\nCalls str.decode element-wise.\n\ndump(file)\nDump a pickle of the array to the specified file.\n\ndumps()\nReturns the pickle of the array as a string.\n\nencode(self[,\u00a0encoding,\u00a0errors])\nCalls str.encode element-wise.\n\nendswith(self,\u00a0suffix[,\u00a0start,\u00a0end])\nReturns a boolean array which is True where the string element in self ends with suffix, otherwise False.\n\nexpandtabs(self[,\u00a0tabsize])\nReturn a copy of each string element where all tab characters are replaced by one or more spaces.\n\nfill(value)\nFill the array with a scalar value.\n\nfind(self,\u00a0sub[,\u00a0start,\u00a0end])\nFor each element, return the lowest index in the string where substring sub is found.\n\nflatten([order])\nReturn a copy of the array collapsed into one dimension.\n\ngetfield(dtype[,\u00a0offset])\nReturns a field of the given array as a certain type.\n\nindex(self,\u00a0sub[,\u00a0start,\u00a0end])\nLike find, but raises ValueError when the substring is not found.\n\nisalnum(self)\nReturns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\n\nisalpha(self)\nReturns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\n\nisdecimal(self)\nFor each element in self, return True if there are only decimal characters in the element.\n\nisdigit(self)\nReturns true for each element if all characters in the string are digits and there is at least one character, false otherwise.\n\nislower(self)\nReturns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\n\nisnumeric(self)\nFor each element in self, return True if there are only numeric characters in the element.\n\nisspace(self)\nReturns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\n\nistitle(self)\nReturns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\n\nisupper(self)\nReturns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.\n\nitem(*args)\nCopy an element of an array to a standard Python scalar and return it.\n\njoin(self,\u00a0seq)\nReturn a string which is the concatenation of the strings in the sequence seq.\n\nljust(self,\u00a0width[,\u00a0fillchar])\nReturn an array with the elements of self left-justified in a string of length width.\n\nlower(self)\nReturn an array with the elements of self converted to lowercase.\n\nlstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the leading characters removed.\n\nnonzero()\nReturn the indices of the elements that are non-zero.\n\nput(indices,\u00a0values[,\u00a0mode])\nSet a.flat[n] = values[n] for all n in indices.\n\nravel([order])\nReturn a flattened array.\n\nrepeat(repeats[,\u00a0axis])\nRepeat elements of an array.\n\nreplace(self,\u00a0old,\u00a0new[,\u00a0count])\nFor each element in self, return a copy of the string with all occurrences of substring old replaced by new.\n\nreshape(shape[,\u00a0order])\nReturns an array containing the same data with a new shape.\n\nresize(new_shape[,\u00a0refcheck])\nChange shape and size of array in-place.\n\nrfind(self,\u00a0sub[,\u00a0start,\u00a0end])\nFor each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end].\n\nrindex(self,\u00a0sub[,\u00a0start,\u00a0end])\nLike rfind, but raises ValueError when the substring sub is not found.\n\nrjust(self,\u00a0width[,\u00a0fillchar])\nReturn an array with the elements of self right-justified in a string of length width.\n\nrsplit(self[,\u00a0sep,\u00a0maxsplit])\nFor each element in self, return a list of the words in the string, using sep as the delimiter string.\n\nrstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the trailing characters removed.\n\nsearchsorted(v[,\u00a0side,\u00a0sorter])\nFind indices where elements of v should be inserted in a to maintain order.\n\nsetfield(val,\u00a0dtype[,\u00a0offset])\nPut a value into a specified place in a field defined by a data-type.\n\nsetflags([write,\u00a0align,\u00a0uic])\nSet array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.\n\nsort([axis,\u00a0kind,\u00a0order])\nSort an array in-place.\n\nsplit(self[,\u00a0sep,\u00a0maxsplit])\nFor each element in self, return a list of the words in the string, using sep as the delimiter string.\n\nsplitlines(self[,\u00a0keepends])\nFor each element in self, return a list of the lines in the element, breaking at line boundaries.\n\nsqueeze([axis])\nRemove single-dimensional entries from the shape of a.\n\nstartswith(self,\u00a0prefix[,\u00a0start,\u00a0end])\nReturns a boolean array which is True where the string element in self starts with prefix, otherwise False.\n\nstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the leading and trailing characters removed.\n\nswapaxes(axis1,\u00a0axis2)\nReturn a view of the array with axis1 and axis2 interchanged.\n\nswapcase(self)\nFor each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa.\n\ntake(indices[,\u00a0axis,\u00a0out,\u00a0mode])\nReturn an array formed from the elements of a at the given indices.\n\ntitle(self)\nFor each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.\n\ntofile(fid[,\u00a0sep,\u00a0format])\nWrite array to a file as text or binary (default).\n\ntolist()\nReturn the array as an a.ndim-levels deep nested list of Python scalars.\n\ntostring([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntranslate(self,\u00a0table[,\u00a0deletechars])\nFor each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table.\n\ntranspose(*axes)\nReturns a view of the array with axes transposed.\n\nupper(self)\nReturn an array with the elements of self converted to uppercase.\n\nview([dtype,\u00a0type])\nNew view of array with the same data.\n\nzfill(self,\u00a0width)\nReturn the numeric string left-filled with zeros in a string of length width.\n\n\n\n", "parameters": ["Parameters", "shapetuple", "itemsizeint, optional", "unicodebool, optional", "bufferint, optional", "offsetint, optional", "stridesarray_like of ints, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Attributes", "T", "base", "ctypes", "data", "dtype", "flags", "flat", "imag", "itemsize", "nbytes", "ndim", "real", "shape", "size", "strides"], "returns": [], "examples": ["; charar = np.chararray((3, 3))\n; charar[:] = 'a'\n; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n\n", "; charar = np.chararray((3, 3))\n; charar[:] = 'a'\n; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n", "; charar = np.chararray(charar.shape, itemsize=5)\n; charar[:] = 'abc'\n; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n\n", "; charar = np.chararray(charar.shape, itemsize=5)\n; charar[:] = 'abc'\n; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n"]},
{"library": "numpy", "item_id": "numpy.chararray", "code": "\nclass numpy.chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0, strides=None, order=None)[source]\u00b6", "description": "Provides a convenient view on arrays of string and unicode values.\n\nNote\nThe chararray class exists for backwards compatibility with\nNumarray, it is not recommended for new development. Starting from numpy\n1.4, if one needs arrays of strings, it is recommended to use arrays of\ndtype object_, string_ or unicode_, and use the free functions\nin the numpy.char module for fast vectorized string operations.\n\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. endswith) and infix operators (e.g. \"+\", \"*\", \"%\")\n\n\nchararrays should be created using numpy.char.array or\nnumpy.char.asarray, rather than this constructor directly.\nThis constructor creates the array, using buffer (with offset\nand strides) if it is not None. If buffer is None, then\nconstructs a new array with strides in \u201cC order\u201d, unless both\nlen(shape) &gt;= 2 and order='F', in which case strides\nis in \u201cFortran order\u201d.\n\nParameters\n\nshapetupleShape of the array.\n\nitemsizeint, optionalLength of each array element, in number of characters. Default is 1.\n\nunicodebool, optionalAre the array elements of type unicode (True) or string (False).\nDefault is False.\n\nbufferint, optionalMemory address of the start of the array data.  Default is None,\nin which case a new array is created.\n\noffsetint, optionalFixed stride displacement from the beginning of an axis?\nDefault is 0. Needs to be &gt;=0.\n\nstridesarray_like of ints, optionalStrides for the array (see ndarray.strides for full description).\nDefault is None.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalThe order in which the array data is stored in memory: \u2018C\u2019 -&gt;\n\u201crow major\u201d order (the default), \u2018F\u2019 -&gt; \u201ccolumn major\u201d\n(Fortran) order.\n\n\n\n\nExamples\n&gt;&gt;&gt; charar = np.chararray((3, 3))\n&gt;&gt;&gt; charar[:] = 'a'\n&gt;&gt;&gt; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n\n\n&gt;&gt;&gt; charar = np.chararray(charar.shape, itemsize=5)\n&gt;&gt;&gt; charar[:] = 'abc'\n&gt;&gt;&gt; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n\n\n\nAttributes\n\nTThe transposed array.\n\nbaseBase object if memory is from some other object.\n\nctypesAn object to simplify the interaction of the array with the ctypes module.\n\ndataPython buffer object pointing to the start of the array\u2019s data.\n\ndtypeData-type of the array\u2019s elements.\n\nflagsInformation about the memory layout of the array.\n\nflatA 1-D iterator over the array.\n\nimagThe imaginary part of the array.\n\nitemsizeLength of one array element in bytes.\n\nnbytesTotal bytes consumed by the elements of the array.\n\nndimNumber of array dimensions.\n\nrealThe real part of the array.\n\nshapeTuple of array dimensions.\n\nsizeNumber of elements in the array.\n\nstridesTuple of bytes to step in each dimension when traversing an array.\n\n\n\n\nMethods\n\n\n\n\n\n\nastype(dtype[,\u00a0order,\u00a0casting,\u00a0subok,\u00a0copy])\nCopy of the array, cast to a specified type.\n\nargsort([axis,\u00a0kind,\u00a0order])\nReturns the indices that would sort this array.\n\ncopy([order])\nReturn a copy of the array.\n\ncount(self,\u00a0sub[,\u00a0start,\u00a0end])\nReturns an array with the number of non-overlapping occurrences of substring sub in the range [start, end].\n\ndecode(self[,\u00a0encoding,\u00a0errors])\nCalls str.decode element-wise.\n\ndump(file)\nDump a pickle of the array to the specified file.\n\ndumps()\nReturns the pickle of the array as a string.\n\nencode(self[,\u00a0encoding,\u00a0errors])\nCalls str.encode element-wise.\n\nendswith(self,\u00a0suffix[,\u00a0start,\u00a0end])\nReturns a boolean array which is True where the string element in self ends with suffix, otherwise False.\n\nexpandtabs(self[,\u00a0tabsize])\nReturn a copy of each string element where all tab characters are replaced by one or more spaces.\n\nfill(value)\nFill the array with a scalar value.\n\nfind(self,\u00a0sub[,\u00a0start,\u00a0end])\nFor each element, return the lowest index in the string where substring sub is found.\n\nflatten([order])\nReturn a copy of the array collapsed into one dimension.\n\ngetfield(dtype[,\u00a0offset])\nReturns a field of the given array as a certain type.\n\nindex(self,\u00a0sub[,\u00a0start,\u00a0end])\nLike find, but raises ValueError when the substring is not found.\n\nisalnum(self)\nReturns true for each element if all characters in the string are alphanumeric and there is at least one character, false otherwise.\n\nisalpha(self)\nReturns true for each element if all characters in the string are alphabetic and there is at least one character, false otherwise.\n\nisdecimal(self)\nFor each element in self, return True if there are only decimal characters in the element.\n\nisdigit(self)\nReturns true for each element if all characters in the string are digits and there is at least one character, false otherwise.\n\nislower(self)\nReturns true for each element if all cased characters in the string are lowercase and there is at least one cased character, false otherwise.\n\nisnumeric(self)\nFor each element in self, return True if there are only numeric characters in the element.\n\nisspace(self)\nReturns true for each element if there are only whitespace characters in the string and there is at least one character, false otherwise.\n\nistitle(self)\nReturns true for each element if the element is a titlecased string and there is at least one character, false otherwise.\n\nisupper(self)\nReturns true for each element if all cased characters in the string are uppercase and there is at least one character, false otherwise.\n\nitem(*args)\nCopy an element of an array to a standard Python scalar and return it.\n\njoin(self,\u00a0seq)\nReturn a string which is the concatenation of the strings in the sequence seq.\n\nljust(self,\u00a0width[,\u00a0fillchar])\nReturn an array with the elements of self left-justified in a string of length width.\n\nlower(self)\nReturn an array with the elements of self converted to lowercase.\n\nlstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the leading characters removed.\n\nnonzero()\nReturn the indices of the elements that are non-zero.\n\nput(indices,\u00a0values[,\u00a0mode])\nSet a.flat[n] = values[n] for all n in indices.\n\nravel([order])\nReturn a flattened array.\n\nrepeat(repeats[,\u00a0axis])\nRepeat elements of an array.\n\nreplace(self,\u00a0old,\u00a0new[,\u00a0count])\nFor each element in self, return a copy of the string with all occurrences of substring old replaced by new.\n\nreshape(shape[,\u00a0order])\nReturns an array containing the same data with a new shape.\n\nresize(new_shape[,\u00a0refcheck])\nChange shape and size of array in-place.\n\nrfind(self,\u00a0sub[,\u00a0start,\u00a0end])\nFor each element in self, return the highest index in the string where substring sub is found, such that sub is contained within [start, end].\n\nrindex(self,\u00a0sub[,\u00a0start,\u00a0end])\nLike rfind, but raises ValueError when the substring sub is not found.\n\nrjust(self,\u00a0width[,\u00a0fillchar])\nReturn an array with the elements of self right-justified in a string of length width.\n\nrsplit(self[,\u00a0sep,\u00a0maxsplit])\nFor each element in self, return a list of the words in the string, using sep as the delimiter string.\n\nrstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the trailing characters removed.\n\nsearchsorted(v[,\u00a0side,\u00a0sorter])\nFind indices where elements of v should be inserted in a to maintain order.\n\nsetfield(val,\u00a0dtype[,\u00a0offset])\nPut a value into a specified place in a field defined by a data-type.\n\nsetflags([write,\u00a0align,\u00a0uic])\nSet array flags WRITEABLE, ALIGNED, (WRITEBACKIFCOPY and UPDATEIFCOPY), respectively.\n\nsort([axis,\u00a0kind,\u00a0order])\nSort an array in-place.\n\nsplit(self[,\u00a0sep,\u00a0maxsplit])\nFor each element in self, return a list of the words in the string, using sep as the delimiter string.\n\nsplitlines(self[,\u00a0keepends])\nFor each element in self, return a list of the lines in the element, breaking at line boundaries.\n\nsqueeze([axis])\nRemove single-dimensional entries from the shape of a.\n\nstartswith(self,\u00a0prefix[,\u00a0start,\u00a0end])\nReturns a boolean array which is True where the string element in self starts with prefix, otherwise False.\n\nstrip(self[,\u00a0chars])\nFor each element in self, return a copy with the leading and trailing characters removed.\n\nswapaxes(axis1,\u00a0axis2)\nReturn a view of the array with axis1 and axis2 interchanged.\n\nswapcase(self)\nFor each element in self, return a copy of the string with uppercase characters converted to lowercase and vice versa.\n\ntake(indices[,\u00a0axis,\u00a0out,\u00a0mode])\nReturn an array formed from the elements of a at the given indices.\n\ntitle(self)\nFor each element in self, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.\n\ntofile(fid[,\u00a0sep,\u00a0format])\nWrite array to a file as text or binary (default).\n\ntolist()\nReturn the array as an a.ndim-levels deep nested list of Python scalars.\n\ntostring([order])\nConstruct Python bytes containing the raw data bytes in the array.\n\ntranslate(self,\u00a0table[,\u00a0deletechars])\nFor each element in self, return a copy of the string where all characters occurring in the optional argument deletechars are removed, and the remaining characters have been mapped through the given translation table.\n\ntranspose(*axes)\nReturns a view of the array with axes transposed.\n\nupper(self)\nReturn an array with the elements of self converted to uppercase.\n\nview([dtype,\u00a0type])\nNew view of array with the same data.\n\nzfill(self,\u00a0width)\nReturn the numeric string left-filled with zeros in a string of length width.\n\n\n\n", "parameters": ["Parameters", "shapetuple", "itemsizeint, optional", "unicodebool, optional", "bufferint, optional", "offsetint, optional", "stridesarray_like of ints, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Attributes", "T", "base", "ctypes", "data", "dtype", "flags", "flat", "imag", "itemsize", "nbytes", "ndim", "real", "shape", "size", "strides"], "returns": [], "examples": ["; charar = np.chararray((3, 3))\n; charar[:] = 'a'\n; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n\n", "; charar = np.chararray((3, 3))\n; charar[:] = 'a'\n; charar\nchararray([[b'a', b'a', b'a'],\n           [b'a', b'a', b'a'],\n           [b'a', b'a', b'a']], dtype='|S1')\n", "; charar = np.chararray(charar.shape, itemsize=5)\n; charar[:] = 'abc'\n; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n\n", "; charar = np.chararray(charar.shape, itemsize=5)\n; charar[:] = 'abc'\n; charar\nchararray([[b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc'],\n           [b'abc', b'abc', b'abc']], dtype='|S5')\n"]},
{"library": "numpy", "item_id": "numpy.dtype.char", "code": "\ndtype.char\u00b6", "description": "A unique character code for each of the 21 different built-in types.\nExamples\n&gt;&gt;&gt; x = np.dtype(float)\n&gt;&gt;&gt; x.char\n'd'\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype(float)\n; x.char\n'd'\n\n", "; x = np.dtype(float)\n; x.char\n'd'\n"]},
{"library": "numpy", "item_id": "numpy.random.Philox.cffi", "code": "\nPhilox.cffi\u00b6", "description": "CFFI interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing CFFI wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.PCG64.cffi", "code": "\nPCG64.cffi\u00b6", "description": "CFFI interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing CFFI wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.SFC64.cffi", "code": "\nSFC64.cffi\u00b6", "description": "CFFI interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing CFFI wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.cffi", "code": "\nBitGenerator.cffi\u00b6", "description": "CFFI interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing CFFI wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.center", "code": "\nchararray.center(self, width, fillchar=' ')\u00b6", "description": "Return a copy of self with its elements centered in a\nstring of length width.\n\nSee also\ncenter\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.center", "code": "\nnumpy.char.center(a, width, fillchar=' ')\u00b6", "description": "Return a copy of a with its elements centered in a string of\nlength width.\nCalls str.center element-wise.\n\nParameters\n\naarray_like of str or unicode\nwidthintThe length of the resulting strings\n\nfillcharstr or unicode, optionalThe padding character to use (default is space).\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input\ntypes\n\n\n\n\n\nSee also\nstr.center\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "widthint", "fillcharstr or unicode, optional", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on inputtypes", "examples": []},
{"library": "numpy", "item_id": "numpy.random.MT19937.cffi", "code": "\nMT19937.cffi\u00b6", "description": "CFFI interface\n\nReturns\n\ninterfacenamedtupleNamed tuple containing CFFI wrapper\n\nstate_address - Memory address of the state struct\nstate - pointer to the state struct\nnext_uint64 - function pointer to produce 64 bit integers\nnext_uint32 - function pointer to produce 32 bit integers\nnext_double - function pointer to produce doubles\nbitgen - pointer to the bit generator struct\n\n\n\n\n\n", "parameters": [], "returns": "interfacenamedtupleNamed tuple containing CFFI wrapperstate_address - Memory address of the state structstate - pointer to the state structnext_uint64 - function pointer to produce 64 bit integersnext_uint32 - function pointer to produce 32 bit integersnext_double - function pointer to produce doublesbitgen - pointer to the bit generator struct", "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.center", "code": "\nchararray.center(self, width, fillchar=' ')[source]\u00b6", "description": "Return a copy of self with its elements centered in a\nstring of length width.\n\nSee also\ncenter\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.cast", "code": "\nclassmethod Polynomial.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.ceil", "code": "\nnumpy.ceil(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'ceil'&gt;\u00b6", "description": "Return the ceiling of the input, element-wise.\nThe ceil of the scalar x is the smallest integer i, such that\ni &gt;= x.  It is often denoted as .\n\nParameters\n\nxarray_likeInput data.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarray or scalarThe ceiling of each element in x, with float dtype.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nfloor, trunc, rint\n\nExamples\n&gt;&gt;&gt; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n&gt;&gt;&gt; np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray or scalar"], "returns": "yndarray or scalarThe ceiling of each element in x, with float dtype.This is a scalar if x is a scalar.", "examples": ["; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])\n\n", "; a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0])\n; np.ceil(a)\narray([-1., -1., -0.,  1.,  2.,  2.,  2.])\n"]},
{"library": "numpy", "item_id": "numpy.cbrt", "code": "\nnumpy.cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'cbrt'&gt;\u00b6", "description": "Return the cube-root of an array, element-wise.\n\nNew in version 1.10.0.\n\n\nParameters\n\nxarray_likeThe values whose cube-roots are required.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nyndarrayAn array of the same shape as x, containing the cube\ncube-root of each element in x.\nIf out was provided, y is a reference to it.\nThis is a scalar if x is a scalar.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "yndarray"], "returns": "yndarrayAn array of the same shape as x, containing the cubecube-root of each element in x.If out was provided, y is a reference to it.This is a scalar if x is a scalar.", "examples": ["; np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])\n\n", "; np.cbrt([1,8,27])\narray([ 1.,  2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.cast", "code": "\nclassmethod Legendre.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.cast", "code": "\nclassmethod Laguerre.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.cast", "code": "\nclassmethod HermiteE.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.cast", "code": "\nclassmethod Hermite.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.cast", "code": "\nclassmethod Chebyshev.cast(series, domain=None, window=None)[source]\u00b6", "description": "Convert series to series of this class.\nThe series is expected to be an instance of some polynomial\nseries of one of the types supported by by the numpy.polynomial\nmodule, but could be some other class that supports the convert\nmethod.\n\nNew in version 1.7.0.\n\n\nParameters\n\nseriesseriesThe series instance to be converted.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series of the same kind as the calling class and equal to\nseries when evaluated.\n\n\n\n\n\nSee also\n\nconvertsimilar instance method\n\n\n\n", "parameters": ["Parameters", "seriesseries", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series of the same kind as the calling class and equal toseries when evaluated.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.BitGenerator.capsule", "code": "\nBitGenerator.capsule\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.capitalize", "code": "\nchararray.capitalize(self)[source]\u00b6", "description": "Return a copy of self with only the first character of each element\ncapitalized.\n\nSee also\nchar.capitalize\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.capitalize", "code": "\nnumpy.char.capitalize(a)\u00b6", "description": "Return a copy of a with only the first character of each element\ncapitalized.\nCalls str.capitalize element-wise.\nFor 8-bit strings, this method is locale-dependent.\n\nParameters\n\naarray_like of str or unicodeInput array of strings to capitalize.\n\n\n\nReturns\n\noutndarrayOutput array of str or unicode, depending on input\ntypes\n\n\n\n\n\nSee also\nstr.capitalize\n\nExamples\n&gt;&gt;&gt; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c\narray(['a1b2', '1b2a', 'b2a1', '2a1b'],\n    dtype='|S4')\n&gt;&gt;&gt; np.char.capitalize(c)\narray(['A1b2', '1b2a', 'B2a1', '2a1b'],\n    dtype='|S4')\n\n\n", "parameters": ["Parameters", "aarray_like of str or unicode", "Returns", "outndarray"], "returns": "outndarrayOutput array of str or unicode, depending on inputtypes", "examples": ["; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c\narray(['a1b2', '1b2a', 'b2a1', '2a1b'],\n    dtype='|S4')\n; np.char.capitalize(c)\narray(['A1b2', '1b2a', 'B2a1', '2a1b'],\n    dtype='|S4')\n\n", "; c = np.array(['a1b2','1b2a','b2a1','2a1b'],'S4'); c\narray(['a1b2', '1b2a', 'b2a1', '2a1b'],\n    dtype='|S4')\n; np.char.capitalize(c)\narray(['A1b2', '1b2a', 'B2a1', '2a1b'],\n    dtype='|S4')\n"]},
{"library": "numpy", "item_id": "numpy.can_cast", "code": "\nnumpy.can_cast(from_, to, casting='safe')\u00b6", "description": "Returns True if cast between data types can occur according to the\ncasting rule.  If from is a scalar or array scalar, also returns\nTrue if the scalar value can be cast without overflow or truncation\nto an integer.\n\nParameters\n\nfrom_dtype, dtype specifier, scalar, or arrayData type, scalar, or array to cast from.\n\ntodtype or dtype specifierData type to cast to.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\n\n\nReturns\n\noutboolTrue if cast can occur according to the casting rule.\n\n\n\n\n\nSee also\ndtype, result_type\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the maximum\ninteger/float value converted.\n\nExamples\nBasic examples\n&gt;&gt;&gt; np.can_cast(np.int32, np.int64)\nTrue\n&gt;&gt;&gt; np.can_cast(np.float64, complex)\nTrue\n&gt;&gt;&gt; np.can_cast(complex, float)\nFalse\n\n\n&gt;&gt;&gt; np.can_cast('i8', 'f8')\nTrue\n&gt;&gt;&gt; np.can_cast('i8', 'f4')\nFalse\n&gt;&gt;&gt; np.can_cast('i4', 'S4')\nFalse\n\n\nCasting scalars\n&gt;&gt;&gt; np.can_cast(100, 'i1')\nTrue\n&gt;&gt;&gt; np.can_cast(150, 'i1')\nFalse\n&gt;&gt;&gt; np.can_cast(150, 'u1')\nTrue\n\n\n&gt;&gt;&gt; np.can_cast(3.5e100, np.float32)\nFalse\n&gt;&gt;&gt; np.can_cast(1000.0, np.float32)\nTrue\n\n\nArray scalar checks the value, array does not\n&gt;&gt;&gt; np.can_cast(np.array(1000.0), np.float32)\nTrue\n&gt;&gt;&gt; np.can_cast(np.array([1000.0]), np.float32)\nFalse\n\n\nUsing the casting rules\n&gt;&gt;&gt; np.can_cast('i8', 'i8', 'no')\nTrue\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'no')\nFalse\n\n\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i8', 'equiv')\nTrue\n&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'equiv')\nFalse\n\n\n&gt;&gt;&gt; np.can_cast('&lt;i4', '&gt;i8', 'safe')\nTrue\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'safe')\nFalse\n\n\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;i4', 'same_kind')\nTrue\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'same_kind')\nFalse\n\n\n&gt;&gt;&gt; np.can_cast('&lt;i8', '&gt;u4', 'unsafe')\nTrue\n\n\n", "parameters": ["Parameters", "from_dtype, dtype specifier, scalar, or array", "todtype or dtype specifier", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "Returns", "outbool"], "returns": "outboolTrue if cast can occur according to the casting rule.", "examples": ["; np.can_cast(np.int32, np.int64)\nTrue\n; np.can_cast(np.float64, complex)\nTrue\n; np.can_cast(complex, float)\nFalse\n\n", "; np.can_cast(np.int32, np.int64)\nTrue\n; np.can_cast(np.float64, complex)\nTrue\n; np.can_cast(complex, float)\nFalse\n", "; np.can_cast('i8', 'f8')\nTrue\n; np.can_cast('i8', 'f4')\nFalse\n; np.can_cast('i4', 'S4')\nFalse\n\n", "; np.can_cast('i8', 'f8')\nTrue\n; np.can_cast('i8', 'f4')\nFalse\n; np.can_cast('i4', 'S4')\nFalse\n", "; np.can_cast(100, 'i1')\nTrue\n; np.can_cast(150, 'i1')\nFalse\n; np.can_cast(150, 'u1')\nTrue\n\n", "; np.can_cast(100, 'i1')\nTrue\n; np.can_cast(150, 'i1')\nFalse\n; np.can_cast(150, 'u1')\nTrue\n", "; np.can_cast(3.5e100, np.float32)\nFalse\n; np.can_cast(1000.0, np.float32)\nTrue\n\n", "; np.can_cast(3.5e100, np.float32)\nFalse\n; np.can_cast(1000.0, np.float32)\nTrue\n", "; np.can_cast(np.array(1000.0), np.float32)\nTrue\n; np.can_cast(np.array([1000.0]), np.float32)\nFalse\n\n", "; np.can_cast(np.array(1000.0), np.float32)\nTrue\n; np.can_cast(np.array([1000.0]), np.float32)\nFalse\n", "; np.can_cast('i8', 'i8', 'no')\nTrue\n; np.can_cast('&lt;i8', '&gt;i8', 'no')\nFalse\n\n", "; np.can_cast('i8', 'i8', 'no')\nTrue\n; np.can_cast('&lt;i8', '&gt;i8', 'no')\nFalse\n", "; np.can_cast('&lt;i8', '&gt;i8', 'equiv')\nTrue\n; np.can_cast('&lt;i4', '&gt;i8', 'equiv')\nFalse\n\n", "; np.can_cast('&lt;i8', '&gt;i8', 'equiv')\nTrue\n; np.can_cast('&lt;i4', '&gt;i8', 'equiv')\nFalse\n", "; np.can_cast('&lt;i4', '&gt;i8', 'safe')\nTrue\n; np.can_cast('&lt;i8', '&gt;i4', 'safe')\nFalse\n\n", "; np.can_cast('&lt;i4', '&gt;i8', 'safe')\nTrue\n; np.can_cast('&lt;i8', '&gt;i4', 'safe')\nFalse\n", "; np.can_cast('&lt;i8', '&gt;i4', 'same_kind')\nTrue\n; np.can_cast('&lt;i8', '&gt;u4', 'same_kind')\nFalse\n\n", "; np.can_cast('&lt;i8', '&gt;i4', 'same_kind')\nTrue\n; np.can_cast('&lt;i8', '&gt;u4', 'same_kind')\nFalse\n", "; np.can_cast('&lt;i8', '&gt;u4', 'unsafe')\nTrue\n\n", "; np.can_cast('&lt;i8', '&gt;u4', 'unsafe')\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.c_", "code": "\nnumpy.c_ = &lt;numpy.lib.index_tricks.CClass object&gt;\u00b6", "description": "Translates slice objects to concatenation along the second axis.\nThis is short-hand for np.r_['-1,2,0', index expression], which is\nuseful because of its common occurrence. In particular, arrays will be\nstacked along their last axis after being upgraded to at least 2-D with\n1\u2019s post-pended to the shape (column vectors made out of 1-D arrays).\n\nSee also\n\ncolumn_stackStack 1-D arrays as columns into a 2-D array.\n\nr_For more detailed documentation.\n\n\n\nExamples\n&gt;&gt;&gt; np.c_[np.array([1,2,3]), np.array([4,5,6])]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n&gt;&gt;&gt; np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\narray([[1, 2, 3, ..., 4, 5, 6]])\n\n\n", "parameters": [], "returns": [], "examples": ["; np.c_[np.array([1,2,3]), np.array([4,5,6])]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\narray([[1, 2, 3, ..., 4, 5, 6]])\n\n", "; np.c_[np.array([1,2,3]), np.array([4,5,6])]\narray([[1, 4],\n       [2, 5],\n       [3, 6]])\n; np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])]\narray([[1, 2, 3, ..., 4, 5, 6]])\n"]},
{"library": "numpy", "item_id": "numpy.record.byteswap", "code": "\nrecord.byteswap()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.byteswap", "code": "\nrecarray.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.byteswap", "code": "\nndarray.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "c.NpyIter", "code": "\nNpyIter\u00b6", "description": "This is an opaque pointer type for the iterator. Access to its contents\ncan only be done through the iterator API.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.c", "code": "\nproperty poly1d.c\u00b6", "description": "The polynomial coefficients\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.byteswap", "code": "\nmemmap.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.matrix.byteswap", "code": "\nmatrix.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.byteswap", "code": "\nMaskType.byteswap()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.byteswap", "code": "\nmasked_array.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.lib.user_array.container.byteswap", "code": "\ncontainer.byteswap(self)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.byteswap", "code": "\ngeneric.byteswap()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class so as to\nprovide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.byteswap", "code": "\nchararray.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.byteswap", "code": "\nMaskedArray.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.byteswap", "code": "\nchararray.byteswap(inplace=False)\u00b6", "description": "Swap the bytes of the array elements\nToggle between low-endian and big-endian data representation by\nreturning a byteswapped array, optionally swapped in-place.\nArrays of byte-strings are not swapped. The real and imaginary\nparts of a complex number are swapped individually.\n\nParameters\n\ninplacebool, optionalIf True, swap bytes in-place, default is False.\n\n\n\nReturns\n\noutndarrayThe byteswapped array. If inplace is True, this is\na view to self.\n\n\n\n\nExamples\n&gt;&gt;&gt; A = np.array([1, 256, 8755], dtype=np.int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n&gt;&gt;&gt; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n&gt;&gt;&gt; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n\nArrays of byte-strings are not swapped\n&gt;&gt;&gt; A = np.array([b'ceg', b'fac'])\n&gt;&gt;&gt; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n\n\nA.newbyteorder().byteswap() produces an array with the same valuesbut different representation in memory\n\n\n&gt;&gt;&gt; A = np.array([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n&gt;&gt;&gt; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n&gt;&gt;&gt; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n\n", "parameters": ["Parameters", "inplacebool, optional", "Returns", "outndarray"], "returns": "outndarrayThe byteswapped array. If inplace is True, this isa view to self.", "examples": ["; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n\n", "; A = np.array([1, 256, 8755], dtype=np.int16)\n; list(map(hex, A))\n['0x1', '0x100', '0x2233']\n; A.byteswap(inplace=True)\narray([  256,     1, 13090], dtype=int16)\n; list(map(hex, A))\n['0x100', '0x1', '0x3322']\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n\n", "; A = np.array([b'ceg', b'fac'])\n; A.byteswap()\narray([b'ceg', b'fac'], dtype='|S3')\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n\n", "; A = np.array([1, 2, 3])\n; A.view(np.uint8)\narray([1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0,\n       0, 0], dtype=uint8)\n; A.newbyteorder().byteswap(inplace=True)\narray([1, 2, 3])\n; A.view(np.uint8)\narray([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0,\n       0, 3], dtype=uint8)\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.bytes", "code": "\nRandomState.bytes(length)\u00b6", "description": "Return random bytes.\n\nNote\nNew code should use the bytes method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlengthintNumber of random bytes.\n\n\n\nReturns\n\noutstrString of length length.\n\n\n\n\n\nSee also\n\nGenerator.byteswhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n\n", "parameters": ["Parameters", "lengthint", "Returns", "outstr"], "returns": "outstrString of length length.", "examples": ["; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n", "; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.bytes", "code": "\nGenerator.bytes(length)\u00b6", "description": "Return random bytes.\n\nParameters\n\nlengthintNumber of random bytes.\n\n\n\nReturns\n\noutstrString of length length.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.random.default_rng().bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n\n", "parameters": ["Parameters", "lengthint", "Returns", "outstr"], "returns": "outstrString of length length.", "examples": ["; np.random.default_rng().bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n", "; np.random.default_rng().bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n"]},
{"library": "numpy", "item_id": "numpy.random.bytes", "code": "\nnumpy.random.bytes(length)\u00b6", "description": "Return random bytes.\n\nNote\nNew code should use the bytes method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nlengthintNumber of random bytes.\n\n\n\nReturns\n\noutstrString of length length.\n\n\n\n\n\nSee also\n\nGenerator.byteswhich should be used for new code.\n\n\n\nExamples\n&gt;&gt;&gt; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n\n", "parameters": ["Parameters", "lengthint", "Returns", "outstr"], "returns": "outstrString of length length.", "examples": ["; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n\n", "; np.random.bytes(10)\n' eh\\x85\\x022SZ\\xbf\\xa4' #random\n"]},
{"library": "numpy", "item_id": "numpy.dtype.byteorder", "code": "\ndtype.byteorder\u00b6", "description": "A character indicating the byte-order of this data-type object.\nOne of:\n\n\n\n\n\n\n\u2018=\u2019\nnative\n\n\u2018&lt;\u2019\nlittle-endian\n\n\u2018&gt;\u2019\nbig-endian\n\n\u2018|\u2019\nnot applicable\n\n\n\nAll built-in data-type objects have byteorder either \u2018=\u2019 or \u2018|\u2019.\nExamples\n&gt;&gt;&gt; dt = np.dtype('i2')\n&gt;&gt;&gt; dt.byteorder\n'='\n&gt;&gt;&gt; # endian is not relevant for 8 bit numbers\n&gt;&gt;&gt; np.dtype('i1').byteorder\n'|'\n&gt;&gt;&gt; # or ASCII strings\n&gt;&gt;&gt; np.dtype('S2').byteorder\n'|'\n&gt;&gt;&gt; # Even if specific code is given, and it is native\n&gt;&gt;&gt; # '=' is the byteorder\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys_is_le = sys.byteorder == 'little'\n&gt;&gt;&gt; native_code = sys_is_le and '&lt;' or '&gt;'\n&gt;&gt;&gt; swapped_code = sys_is_le and '&gt;' or '&lt;'\n&gt;&gt;&gt; dt = np.dtype(native_code + 'i2')\n&gt;&gt;&gt; dt.byteorder\n'='\n&gt;&gt;&gt; # Swapped code shows up as itself\n&gt;&gt;&gt; dt = np.dtype(swapped_code + 'i2')\n&gt;&gt;&gt; dt.byteorder == swapped_code\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; dt = np.dtype('i2')\n; dt.byteorder\n'='\n; # endian is not relevant for 8 bit numbers\n; np.dtype('i1').byteorder\n'|'\n; # or ASCII strings\n; np.dtype('S2').byteorder\n'|'\n; # Even if specific code is given, and it is native\n; # '=' is the byteorder\n; import sys\n; sys_is_le = sys.byteorder == 'little'\n; native_code = sys_is_le and '&lt;' or '&gt;'\n; swapped_code = sys_is_le and '&gt;' or '&lt;'\n; dt = np.dtype(native_code + 'i2')\n; dt.byteorder\n'='\n; # Swapped code shows up as itself\n; dt = np.dtype(swapped_code + 'i2')\n; dt.byteorder == swapped_code\nTrue\n\n", "; dt = np.dtype('i2')\n; dt.byteorder\n'='\n; # endian is not relevant for 8 bit numbers\n; np.dtype('i1').byteorder\n'|'\n; # or ASCII strings\n; np.dtype('S2').byteorder\n'|'\n; # Even if specific code is given, and it is native\n; # '=' is the byteorder\n; import sys\n; sys_is_le = sys.byteorder == 'little'\n; native_code = sys_is_le and '&lt;' or '&gt;'\n; swapped_code = sys_is_le and '&gt;' or '&lt;'\n; dt = np.dtype(native_code + 'i2')\n; dt.byteorder\n'='\n; # Swapped code shows up as itself\n; dt = np.dtype(swapped_code + 'i2')\n; dt.byteorder == swapped_code\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.byte_bounds", "code": "\nnumpy.byte_bounds(a)[source]\u00b6", "description": "Returns pointers to the end-points of an array.\n\nParameters\n\nandarrayInput array. It must conform to the Python-side of the array\ninterface.\n\n\n\nReturns\n\n(low, high)tuple of 2 integersThe first integer is the first byte of the array, the second\ninteger is just past the last byte of the array.  If a is not\ncontiguous it will not use every byte between the (low, high)\nvalues.\n\n\n\n\nExamples\n&gt;&gt;&gt; I = np.eye(2, dtype='f'); I.dtype\ndtype('float32')\n&gt;&gt;&gt; low, high = np.byte_bounds(I)\n&gt;&gt;&gt; high - low == I.size*I.itemsize\nTrue\n&gt;&gt;&gt; I = np.eye(2); I.dtype\ndtype('float64')\n&gt;&gt;&gt; low, high = np.byte_bounds(I)\n&gt;&gt;&gt; high - low == I.size*I.itemsize\nTrue\n\n\n", "parameters": ["Parameters", "andarray", "Returns", "(low, high)tuple of 2 integers"], "returns": "(low, high)tuple of 2 integersThe first integer is the first byte of the array, the secondinteger is just past the last byte of the array.  If a is notcontiguous it will not use every byte between the (low, high)values.", "examples": ["; I = np.eye(2, dtype='f'); I.dtype\ndtype('float32')\n; low, high = np.byte_bounds(I)\n; high - low == I.size*I.itemsize\nTrue\n; I = np.eye(2); I.dtype\ndtype('float64')\n; low, high = np.byte_bounds(I)\n; high - low == I.size*I.itemsize\nTrue\n\n", "; I = np.eye(2, dtype='f'); I.dtype\ndtype('float32')\n; low, high = np.byte_bounds(I)\n; high - low == I.size*I.itemsize\nTrue\n; I = np.eye(2); I.dtype\ndtype('float64')\n; low, high = np.byte_bounds(I)\n; high - low == I.size*I.itemsize\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.busdaycalendar", "code": "\nclass numpy.busdaycalendar(weekmask='1111100', holidays=None)[source]\u00b6", "description": "A business day calendar object that efficiently stores information\ndefining valid days for the busday family of functions.\nThe default valid days are Monday through Friday (\u201cbusiness days\u201d).\nA busdaycalendar object can be specified with any set of weekly\nvalid days, plus an optional \u201choliday\u201d dates that always will be invalid.\nOnce a busdaycalendar object is created, the weekmask and holidays\ncannot be modified.\n\nNew in version 1.7.0.\n\n\nParameters\n\nweekmaskstr or array_like of bool, optionalA seven-element array indicating which of Monday through Sunday are\nvalid days. May be specified as a length-seven list or array, like\n[1,1,1,1,1,0,0]; a length-seven string, like \u20181111100\u2019; or a string\nlike \u201cMon Tue Wed Thu Fri\u201d, made up of 3-character abbreviations for\nweekdays, optionally separated by white space. Valid abbreviations\nare: Mon Tue Wed Thu Fri Sat Sun\n\nholidaysarray_like of datetime64[D], optionalAn array of dates to consider as invalid dates, no matter which\nweekday they fall upon.  Holiday dates may be specified in any\norder, and NaT (not-a-time) dates are ignored.  This list is\nsaved in a normalized form that is suited for fast calculations\nof valid days.\n\n\n\nReturns\n\noutbusdaycalendarA business day calendar object containing the specified\nweekmask and holidays values.\n\n\n\n\n\nSee also\n\nis_busdayReturns a boolean array indicating valid days.\n\nbusday_offsetApplies an offset counted in valid days.\n\nbusday_countCounts how many valid days are in a half-open date range.\n\n\n\nExamples\n&gt;&gt;&gt; # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n&gt;&gt;&gt; # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False])\n&gt;&gt;&gt; # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')\n\n\n\nAttributes\n\nNote: once a busdaycalendar object is created, you cannot modify the\nweekmask or holidays.  The attributes return copies of internal data.\nweekmask(copy) seven-element array of boolA copy of the seven-element boolean mask indicating valid days.\n\nholidays(copy) sorted array of datetime64[D]A copy of the holiday array indicating additional invalid days.\n\n\n\n\n", "parameters": ["Parameters", "weekmaskstr or array_like of bool, optional", "holidaysarray_like of datetime64[D], optional", "Returns", "outbusdaycalendar", "Attributes", "Note: once a busdaycalendar object is created, you cannot modify the", "weekmask or holidays.  The attributes return copies of internal data.", "weekmask(copy) seven-element array of bool", "holidays(copy) sorted array of datetime64[D]"], "returns": "outbusdaycalendarA business day calendar object containing the specifiedweekmask and holidays values.", "examples": ["; # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n; # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False])\n; # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')\n\n", "; # Some important days in July\n... bdd = np.busdaycalendar(\n...             holidays=['2011-07-01', '2011-07-04', '2011-07-17'])\n; # Default is Monday to Friday weekdays\n... bdd.weekmask\narray([ True,  True,  True,  True,  True, False, False])\n; # Any holidays already on the weekend are removed\n... bdd.holidays\narray(['2011-07-01', '2011-07-04'], dtype='datetime64[D]')\n"]},
{"library": "numpy", "item_id": "numpy.busday_offset", "code": "\nnumpy.busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)\u00b6", "description": "First adjusts the date to fall on a valid day according to\nthe roll rule, then applies offsets to the given dates\ncounted in valid days.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndatesarray_like of datetime64[D]The array of dates to process.\n\noffsetsarray_like of intThe array of offsets, which is broadcast with dates.\n\nroll{\u2018raise\u2019, \u2018nat\u2019, \u2018forward\u2019, \u2018following\u2019, \u2018backward\u2019, \u2018preceding\u2019, \u2018modifiedfollowing\u2019, \u2018modifiedpreceding\u2019}, optionalHow to treat dates that do not fall on a valid day. The default\nis \u2018raise\u2019.\n\n\n\u2018raise\u2019 means to raise an exception for an invalid day.\n\u2018nat\u2019 means to return a NaT (not-a-time) for an invalid day.\n\u2018forward\u2019 and \u2018following\u2019 mean to take the first valid day\nlater in time.\n\u2018backward\u2019 and \u2018preceding\u2019 mean to take the first valid day\nearlier in time.\n\u2018modifiedfollowing\u2019 means to take the first valid day\nlater in time unless it is across a Month boundary, in which\ncase to take the first valid day earlier in time.\n\u2018modifiedpreceding\u2019 means to take the first valid day\nearlier in time unless it is across a Month boundary, in which\ncase to take the first valid day later in time.\n\n\n\nweekmaskstr or array_like of bool, optionalA seven-element array indicating which of Monday through Sunday are\nvalid days. May be specified as a length-seven list or array, like\n[1,1,1,1,1,0,0]; a length-seven string, like \u20181111100\u2019; or a string\nlike \u201cMon Tue Wed Thu Fri\u201d, made up of 3-character abbreviations for\nweekdays, optionally separated by white space. Valid abbreviations\nare: Mon Tue Wed Thu Fri Sat Sun\n\nholidaysarray_like of datetime64[D], optionalAn array of dates to consider as invalid dates.  They may be\nspecified in any order, and NaT (not-a-time) dates are ignored.\nThis list is saved in a normalized form that is suited for\nfast calculations of valid days.\n\nbusdaycalbusdaycalendar, optionalA busdaycalendar object which specifies the valid days. If this\nparameter is provided, neither weekmask nor holidays may be\nprovided.\n\noutarray of datetime64[D], optionalIf provided, this array is filled with the result.\n\n\n\nReturns\n\noutarray of datetime64[D]An array with a shape from broadcasting dates and offsets\ntogether, containing the dates with offsets applied.\n\n\n\n\n\nSee also\n\nbusdaycalendarAn object that specifies a custom set of valid days.\n\nis_busdayReturns a boolean array indicating valid days.\n\nbusday_countCounts how many valid days are in a half-open date range.\n\n\n\nExamples\n&gt;&gt;&gt; # First business day in October 2011 (not accounting for holidays)\n... np.busday_offset('2011-10', 0, roll='forward')\nnumpy.datetime64('2011-10-03')\n&gt;&gt;&gt; # Last business day in February 2012 (not accounting for holidays)\n... np.busday_offset('2012-03', -1, roll='forward')\nnumpy.datetime64('2012-02-29')\n&gt;&gt;&gt; # Third Wednesday in January 2011\n... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\nnumpy.datetime64('2011-01-19')\n&gt;&gt;&gt; # 2012 Mother's Day in Canada and the U.S.\n... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\nnumpy.datetime64('2012-05-13')\n\n\n&gt;&gt;&gt; # First business day on or after a date\n... np.busday_offset('2011-03-20', 0, roll='forward')\nnumpy.datetime64('2011-03-21')\n&gt;&gt;&gt; np.busday_offset('2011-03-22', 0, roll='forward')\nnumpy.datetime64('2011-03-22')\n&gt;&gt;&gt; # First business day after a date\n... np.busday_offset('2011-03-20', 1, roll='backward')\nnumpy.datetime64('2011-03-21')\n&gt;&gt;&gt; np.busday_offset('2011-03-22', 1, roll='backward')\nnumpy.datetime64('2011-03-23')\n\n\n", "parameters": ["Parameters", "datesarray_like of datetime64[D]", "offsetsarray_like of int", "roll{\u2018raise\u2019, \u2018nat\u2019, \u2018forward\u2019, \u2018following\u2019, \u2018backward\u2019, \u2018preceding\u2019, \u2018modifiedfollowing\u2019, \u2018modifiedpreceding\u2019}, optional", "weekmaskstr or array_like of bool, optional", "holidaysarray_like of datetime64[D], optional", "busdaycalbusdaycalendar, optional", "outarray of datetime64[D], optional", "Returns", "outarray of datetime64[D]"], "returns": "outarray of datetime64[D]An array with a shape from broadcasting dates and offsetstogether, containing the dates with offsets applied.", "examples": ["; # First business day in October 2011 (not accounting for holidays)\n... np.busday_offset('2011-10', 0, roll='forward')\nnumpy.datetime64('2011-10-03')\n; # Last business day in February 2012 (not accounting for holidays)\n... np.busday_offset('2012-03', -1, roll='forward')\nnumpy.datetime64('2012-02-29')\n; # Third Wednesday in January 2011\n... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\nnumpy.datetime64('2011-01-19')\n; # 2012 Mother's Day in Canada and the U.S.\n... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\nnumpy.datetime64('2012-05-13')\n\n", "; # First business day in October 2011 (not accounting for holidays)\n... np.busday_offset('2011-10', 0, roll='forward')\nnumpy.datetime64('2011-10-03')\n; # Last business day in February 2012 (not accounting for holidays)\n... np.busday_offset('2012-03', -1, roll='forward')\nnumpy.datetime64('2012-02-29')\n; # Third Wednesday in January 2011\n... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')\nnumpy.datetime64('2011-01-19')\n; # 2012 Mother's Day in Canada and the U.S.\n... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')\nnumpy.datetime64('2012-05-13')\n", "; # First business day on or after a date\n... np.busday_offset('2011-03-20', 0, roll='forward')\nnumpy.datetime64('2011-03-21')\n; np.busday_offset('2011-03-22', 0, roll='forward')\nnumpy.datetime64('2011-03-22')\n; # First business day after a date\n... np.busday_offset('2011-03-20', 1, roll='backward')\nnumpy.datetime64('2011-03-21')\n; np.busday_offset('2011-03-22', 1, roll='backward')\nnumpy.datetime64('2011-03-23')\n\n", "; # First business day on or after a date\n... np.busday_offset('2011-03-20', 0, roll='forward')\nnumpy.datetime64('2011-03-21')\n; np.busday_offset('2011-03-22', 0, roll='forward')\nnumpy.datetime64('2011-03-22')\n; # First business day after a date\n... np.busday_offset('2011-03-20', 1, roll='backward')\nnumpy.datetime64('2011-03-21')\n; np.busday_offset('2011-03-22', 1, roll='backward')\nnumpy.datetime64('2011-03-23')\n"]},
{"library": "numpy", "item_id": "numpy.busday_count", "code": "\nnumpy.busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)\u00b6", "description": "Counts the number of valid days between begindates and\nenddates, not including the day of enddates.\nIf enddates specifies a date value that is earlier than the\ncorresponding begindates date value, the count will be negative.\n\nNew in version 1.7.0.\n\n\nParameters\n\nbegindatesarray_like of datetime64[D]The array of the first dates for counting.\n\nenddatesarray_like of datetime64[D]The array of the end dates for counting, which are excluded\nfrom the count themselves.\n\nweekmaskstr or array_like of bool, optionalA seven-element array indicating which of Monday through Sunday are\nvalid days. May be specified as a length-seven list or array, like\n[1,1,1,1,1,0,0]; a length-seven string, like \u20181111100\u2019; or a string\nlike \u201cMon Tue Wed Thu Fri\u201d, made up of 3-character abbreviations for\nweekdays, optionally separated by white space. Valid abbreviations\nare: Mon Tue Wed Thu Fri Sat Sun\n\nholidaysarray_like of datetime64[D], optionalAn array of dates to consider as invalid dates.  They may be\nspecified in any order, and NaT (not-a-time) dates are ignored.\nThis list is saved in a normalized form that is suited for\nfast calculations of valid days.\n\nbusdaycalbusdaycalendar, optionalA busdaycalendar object which specifies the valid days. If this\nparameter is provided, neither weekmask nor holidays may be\nprovided.\n\noutarray of int, optionalIf provided, this array is filled with the result.\n\n\n\nReturns\n\noutarray of intAn array with a shape from broadcasting begindates and enddates\ntogether, containing the number of valid days between\nthe begin and end dates.\n\n\n\n\n\nSee also\n\nbusdaycalendarAn object that specifies a custom set of valid days.\n\nis_busdayReturns a boolean array indicating valid days.\n\nbusday_offsetApplies an offset counted in valid days.\n\n\n\nExamples\n&gt;&gt;&gt; # Number of weekdays in January 2011\n... np.busday_count('2011-01', '2011-02')\n21\n&gt;&gt;&gt; # Number of weekdays in 2011\n&gt;&gt;&gt; np.busday_count('2011', '2012')\n260\n&gt;&gt;&gt; # Number of Saturdays in 2011\n... np.busday_count('2011', '2012', weekmask='Sat')\n53\n\n\n", "parameters": ["Parameters", "begindatesarray_like of datetime64[D]", "enddatesarray_like of datetime64[D]", "weekmaskstr or array_like of bool, optional", "holidaysarray_like of datetime64[D], optional", "busdaycalbusdaycalendar, optional", "outarray of int, optional", "Returns", "outarray of int"], "returns": "outarray of intAn array with a shape from broadcasting begindates and enddatestogether, containing the number of valid days betweenthe begin and end dates.", "examples": ["; # Number of weekdays in January 2011\n... np.busday_count('2011-01', '2011-02')\n21\n; # Number of weekdays in 2011\n; np.busday_count('2011', '2012')\n260\n; # Number of Saturdays in 2011\n... np.busday_count('2011', '2012', weekmask='Sat')\n53\n\n", "; # Number of weekdays in January 2011\n... np.busday_count('2011-01', '2011-02')\n21\n; # Number of weekdays in 2011\n; np.busday_count('2011', '2012')\n260\n; # Number of Saturdays in 2011\n... np.busday_count('2011', '2012', weekmask='Sat')\n53\n"]},
{"library": "numpy", "item_id": "numpy.broadcast_to", "code": "\nnumpy.broadcast_to(array, shape, subok=False)[source]\u00b6", "description": "Broadcast an array to a new shape.\n\nParameters\n\narrayarray_likeThe array to broadcast.\n\nshapetupleThe shape of the desired array.\n\nsubokbool, optionalIf True, then sub-classes will be passed-through, otherwise\nthe returned array will be forced to be a base-class array (default).\n\n\n\nReturns\n\nbroadcastarrayA readonly view on the original array with the given shape. It is\ntypically not contiguous. Furthermore, more than one element of a\nbroadcasted array may refer to a single memory location.\n\n\n\nRaises\n\nValueErrorIf the array is not compatible with the new shape according to NumPy\u2019s\nbroadcasting rules.\n\n\n\n\nNotes\n\nNew in version 1.10.0.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 3])\n&gt;&gt;&gt; np.broadcast_to(x, (3, 3))\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])\n\n\n", "parameters": ["Parameters", "arrayarray_like", "shapetuple", "subokbool, optional", "Returns", "broadcastarray", "Raises", "ValueError"], "returns": "broadcastarrayA readonly view on the original array with the given shape. It istypically not contiguous. Furthermore, more than one element of abroadcasted array may refer to a single memory location.", "examples": ["; x = np.array([1, 2, 3])\n; np.broadcast_to(x, (3, 3))\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])\n\n", "; x = np.array([1, 2, 3])\n; np.broadcast_to(x, (3, 3))\narray([[1, 2, 3],\n       [1, 2, 3],\n       [1, 2, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.broadcast_arrays", "code": "\nnumpy.broadcast_arrays(*args, **kwargs)[source]\u00b6", "description": "Broadcast any number of arrays against each other.\n\nParameters\n\n`*args`array_likesThe arrays to broadcast.\n\nsubokbool, optionalIf True, then sub-classes will be passed-through, otherwise\nthe returned arrays will be forced to be a base-class array (default).\n\n\n\nReturns\n\nbroadcastedlist of arraysThese arrays are views on the original arrays.  They are typically\nnot contiguous.  Furthermore, more than one element of a\nbroadcasted array may refer to a single memory location. If you need\nto write to the arrays, make copies first. While you can set the\nwritable flag True, writing to a single output value may end up\nchanging more than one location in the output array.\n\nDeprecated since version 1.17: The output is currently marked so that if written to, a deprecation\nwarning will be emitted. A future version will set the\nwritable flag False so writing to it will raise an error.\n\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[1,2,3]])\n&gt;&gt;&gt; y = np.array([[4],[5]])\n&gt;&gt;&gt; np.broadcast_arrays(x, y)\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n\n\nHere is a useful idiom for getting contiguous copies instead of\nnon-contiguous views.\n&gt;&gt;&gt; [np.array(a) for a in np.broadcast_arrays(x, y)]\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n\n\n", "parameters": ["Parameters", "`*args`array_likes", "subokbool, optional", "Returns", "broadcastedlist of arrays"], "returns": "broadcastedlist of arraysThese arrays are views on the original arrays.  They are typicallynot contiguous.  Furthermore, more than one element of abroadcasted array may refer to a single memory location. If you needto write to the arrays, make copies first. While you can set thewritable flag True, writing to a single output value may end upchanging more than one location in the output array.Deprecated since version 1.17: The output is currently marked so that if written to, a deprecationwarning will be emitted. A future version will set thewritable flag False so writing to it will raise an error.", "examples": ["; x = np.array([[1,2,3]])\n; y = np.array([[4],[5]])\n; np.broadcast_arrays(x, y)\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n\n", "; x = np.array([[1,2,3]])\n; y = np.array([[4],[5]])\n; np.broadcast_arrays(x, y)\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n", "; [np.array(a) for a in np.broadcast_arrays(x, y)]\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n\n", "; [np.array(a) for a in np.broadcast_arrays(x, y)]\n[array([[1, 2, 3],\n       [1, 2, 3]]), array([[4, 4, 4],\n       [5, 5, 5]])]\n"]},
{"library": "numpy", "item_id": "ndpointer", "code": "\nndpointer(dtype=None, ndim=None, shape=None, flags=None)\u00b6", "description": "Keyword arguments with the value None are not checked.\nSpecifying a keyword enforces checking of that aspect of the\nndarray on conversion to a ctypes-compatible object. The dtype\nkeyword can be any object understood as a data-type object. The\nndim keyword should be an integer, and the shape keyword should be\nan integer or a sequence of integers. The flags keyword specifies\nthe minimal flags that are required on any array passed in. This\ncan be specified as a string of comma separated requirements, an\ninteger indicating the requirement bits OR\u2019d together, or a flags\nobject returned from the flags attribute of an array with the\nnecessary requirements.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.broadcast", "code": "\nclass numpy.broadcast[source]\u00b6", "description": "Produce an object that mimics broadcasting.\n\nParameters\n\nin1, in2, \u2026array_likeInput parameters.\n\n\n\nReturns\n\nbbroadcast objectBroadcast the input parameters against one another, and\nreturn an object that encapsulates the result.\nAmongst others, it has shape and nd properties, and\nmay be used as an iterator.\n\n\n\n\n\nSee also\nbroadcast_arrays, broadcast_to\n\nExamples\nManually adding two vectors, using broadcasting:\n&gt;&gt;&gt; x = np.array([[1], [2], [3]])\n&gt;&gt;&gt; y = np.array([4, 5, 6])\n&gt;&gt;&gt; b = np.broadcast(x, y)\n\n\n&gt;&gt;&gt; out = np.empty(b.shape)\n&gt;&gt;&gt; out.flat = [u+v for (u,v) in b]\n&gt;&gt;&gt; out\narray([[5.,  6.,  7.],\n       [6.,  7.,  8.],\n       [7.,  8.,  9.]])\n\n\nCompare against built-in broadcasting:\n&gt;&gt;&gt; x + y\narray([[5, 6, 7],\n       [6, 7, 8],\n       [7, 8, 9]])\n\n\n\nAttributes\n\nindexcurrent index in broadcasted result\n\niterstuple of iterators along self\u2019s \u201ccomponents.\u201d\n\nndNumber of dimensions of broadcasted result.\n\nndimNumber of dimensions of broadcasted result.\n\nnumiterNumber of iterators possessed by the broadcasted result.\n\nshapeShape of broadcasted result.\n\nsizeTotal size of broadcasted result.\n\n\n\n\nMethods\n\n\n\n\n\n\nreset()\nReset the broadcasted result\u2019s iterator(s).\n\n\n\n", "parameters": ["Parameters", "in1, in2, \u2026array_like", "Returns", "bbroadcast object", "Attributes", "index", "iters", "nd", "ndim", "numiter", "shape", "size"], "returns": "bbroadcast objectBroadcast the input parameters against one another, andreturn an object that encapsulates the result.Amongst others, it has shape and nd properties, andmay be used as an iterator.", "examples": ["; x = np.array([[1], [2], [3]])\n; y = np.array([4, 5, 6])\n; b = np.broadcast(x, y)\n\n", "; x = np.array([[1], [2], [3]])\n; y = np.array([4, 5, 6])\n; b = np.broadcast(x, y)\n", "; out = np.empty(b.shape)\n; out.flat = [u+v for (u,v) in b]\n; out\narray([[5.,  6.,  7.],\n       [6.,  7.,  8.],\n       [7.,  8.,  9.]])\n\n", "; out = np.empty(b.shape)\n; out.flat = [u+v for (u,v) in b]\n; out\narray([[5.,  6.,  7.],\n       [6.,  7.,  8.],\n       [7.,  8.,  9.]])\n", "; x + y\narray([[5, 6, 7],\n       [6, 7, 8],\n       [7, 8, 9]])\n\n", "; x + y\narray([[5, 6, 7],\n       [6, 7, 8],\n       [7, 8, 9]])\n"]},
{"library": "numpy", "item_id": "numpy.bmat", "code": "\nnumpy.bmat(obj, ldict=None, gdict=None)[source]\u00b6", "description": "Build a matrix object from a string, nested sequence, or array.\n\nParameters\n\nobjstr or array_likeInput data. If a string, variables in the current scope may be\nreferenced by name.\n\nldictdict, optionalA dictionary that replaces local operands in current frame.\nIgnored if obj is not a string or gdict is None.\n\ngdictdict, optionalA dictionary that replaces global operands in current frame.\nIgnored if obj is not a string.\n\n\n\nReturns\n\noutmatrixReturns a matrix object, which is a specialized 2-D array.\n\n\n\n\n\nSee also\n\nblockA generalization of this function for N-d arrays, that returns normal ndarrays.\n\n\n\nExamples\n&gt;&gt;&gt; A = np.mat('1 1; 1 1')\n&gt;&gt;&gt; B = np.mat('2 2; 2 2')\n&gt;&gt;&gt; C = np.mat('3 4; 5 6')\n&gt;&gt;&gt; D = np.mat('7 8; 9 0')\n\n\nAll the following expressions construct the same block matrix:\n&gt;&gt;&gt; np.bmat([[A, B], [C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n&gt;&gt;&gt; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n&gt;&gt;&gt; np.bmat('A,B; C,D')\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n\n\n", "parameters": ["Parameters", "objstr or array_like", "ldictdict, optional", "gdictdict, optional", "Returns", "outmatrix"], "returns": "outmatrixReturns a matrix object, which is a specialized 2-D array.", "examples": ["; A = np.mat('1 1; 1 1')\n; B = np.mat('2 2; 2 2')\n; C = np.mat('3 4; 5 6')\n; D = np.mat('7 8; 9 0')\n\n", "; A = np.mat('1 1; 1 1')\n; B = np.mat('2 2; 2 2')\n; C = np.mat('3 4; 5 6')\n; D = np.mat('7 8; 9 0')\n", "; np.bmat([[A, B], [C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n; np.bmat('A,B; C,D')\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n\n", "; np.bmat([[A, B], [C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n; np.bmat(np.r_[np.c_[A, B], np.c_[C, D]])\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n; np.bmat('A,B; C,D')\nmatrix([[1, 1, 2, 2],\n        [1, 1, 2, 2],\n        [3, 4, 7, 8],\n        [5, 6, 9, 0]])\n"]},
{"library": "numpy", "item_id": "numpy.block", "code": "\nnumpy.block(arrays)[source]\u00b6", "description": "Assemble an nd-array from nested lists of blocks.\nBlocks in the innermost lists are concatenated (see concatenate) along\nthe last dimension (-1), then these are concatenated along the\nsecond-last dimension (-2), and so on until the outermost list is reached.\nBlocks can be of any dimension, but will not be broadcasted using the normal\nrules. Instead, leading axes of size 1 are inserted, to make block.ndim\nthe same for all blocks. This is primarily useful for working with scalars,\nand means that code like np.block([v, 1]) is valid, where\nv.ndim == 1.\nWhen the nested list is two levels deep, this allows block matrices to be\nconstructed from their components.\n\nNew in version 1.13.0.\n\n\nParameters\n\narraysnested list of array_like or scalars (but not tuples)If passed a single ndarray or scalar (a nested list of depth 0), this\nis returned unmodified (and not copied).\nElements shapes must match along the appropriate axes (without\nbroadcasting), but leading 1s will be prepended to the shape as\nnecessary to make the dimensions match.\n\n\n\nReturns\n\nblock_arrayndarrayThe array assembled from the given blocks.\nThe dimensionality of the output is equal to the greatest of:\n* the dimensionality of all the inputs\n* the depth to which the input list is nested\n\n\n\nRaises\n\nValueError\nIf list depths are mismatched - for instance, [[a, b], c] is\nillegal, and should be spelt [[a, b], [c]]\nIf lists are empty - for instance, [[a, b], []]\n\n\n\n\n\n\nSee also\n\nconcatenateJoin a sequence of arrays together.\n\nstackStack arrays in sequence along a new dimension.\n\nhstackStack arrays in sequence horizontally (column wise).\n\nvstackStack arrays in sequence vertically (row wise).\n\ndstackStack arrays in sequence depth wise (along third dimension).\n\nvsplitSplit array into a list of multiple sub-arrays vertically.\n\n\n\nNotes\nWhen called with only scalars, np.block is equivalent to an ndarray\ncall. So np.block([[1, 2], [3, 4]]) is equivalent to\nnp.array([[1, 2], [3, 4]]).\nThis function does not enforce that the blocks lie on a fixed grid.\nnp.block([[a, b], [c, d]]) is not restricted to arrays of the form:\nAAAbb\nAAAbb\ncccDD\n\n\nBut is also allowed to produce, for some a, b, c, d:\nAAAbb\nAAAbb\ncDDDD\n\n\nSince concatenation happens along the last axis first, block is _not_\ncapable of producing the following directly:\nAAAbb\ncccbb\ncccDD\n\n\nMatlab\u2019s \u201csquare bracket stacking\u201d, [A, B, ...; p, q, ...], is\nequivalent to np.block([[A, B, ...], [p, q, ...]]).\nExamples\nThe most common use of this function is to build a block matrix\n&gt;&gt;&gt; A = np.eye(2) * 2\n&gt;&gt;&gt; B = np.eye(3) * 3\n&gt;&gt;&gt; np.block([\n...     [A,               np.zeros((2, 3))],\n...     [np.ones((3, 2)), B               ]\n... ])\narray([[2., 0., 0., 0., 0.],\n       [0., 2., 0., 0., 0.],\n       [1., 1., 3., 0., 0.],\n       [1., 1., 0., 3., 0.],\n       [1., 1., 0., 0., 3.]])\n\n\nWith a list of depth 1, block can be used as hstack\n&gt;&gt;&gt; np.block([1, 2, 3])              # hstack([1, 2, 3])\narray([1, 2, 3])\n\n\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.block([a, b, 10])             # hstack([a, b, 10])\narray([ 1,  2,  3,  2,  3,  4, 10])\n\n\n&gt;&gt;&gt; A = np.ones((2, 2), int)\n&gt;&gt;&gt; B = 2 * A\n&gt;&gt;&gt; np.block([A, B])                 # hstack([A, B])\narray([[1, 1, 2, 2],\n       [1, 1, 2, 2]])\n\n\nWith a list of depth 2, block can be used in place of vstack:\n&gt;&gt;&gt; a = np.array([1, 2, 3])\n&gt;&gt;&gt; b = np.array([2, 3, 4])\n&gt;&gt;&gt; np.block([[a], [b]])             # vstack([a, b])\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n\n&gt;&gt;&gt; A = np.ones((2, 2), int)\n&gt;&gt;&gt; B = 2 * A\n&gt;&gt;&gt; np.block([[A], [B]])             # vstack([A, B])\narray([[1, 1],\n       [1, 1],\n       [2, 2],\n       [2, 2]])\n\n\nIt can also be used in places of atleast_1d and atleast_2d\n&gt;&gt;&gt; a = np.array(0)\n&gt;&gt;&gt; b = np.array([1])\n&gt;&gt;&gt; np.block([a])                    # atleast_1d(a)\narray([0])\n&gt;&gt;&gt; np.block([b])                    # atleast_1d(b)\narray([1])\n\n\n&gt;&gt;&gt; np.block([[a]])                  # atleast_2d(a)\narray([[0]])\n&gt;&gt;&gt; np.block([[b]])                  # atleast_2d(b)\narray([[1]])\n\n\n", "parameters": ["Parameters", "arraysnested list of array_like or scalars (but not tuples)", "Returns", "block_arrayndarray", "Raises", "ValueError"], "returns": "block_arrayndarrayThe array assembled from the given blocks.The dimensionality of the output is equal to the greatest of:* the dimensionality of all the inputs* the depth to which the input list is nested", "examples": ["; A = np.eye(2) * 2\n; B = np.eye(3) * 3\n; np.block([\n...     [A,               np.zeros((2, 3))],\n...     [np.ones((3, 2)), B               ]\n... ])\narray([[2., 0., 0., 0., 0.],\n       [0., 2., 0., 0., 0.],\n       [1., 1., 3., 0., 0.],\n       [1., 1., 0., 3., 0.],\n       [1., 1., 0., 0., 3.]])\n\n", "; A = np.eye(2) * 2\n; B = np.eye(3) * 3\n; np.block([\n...     [A,               np.zeros((2, 3))],\n...     [np.ones((3, 2)), B               ]\n... ])\narray([[2., 0., 0., 0., 0.],\n       [0., 2., 0., 0., 0.],\n       [1., 1., 3., 0., 0.],\n       [1., 1., 0., 3., 0.],\n       [1., 1., 0., 0., 3.]])\n", "; np.block([1, 2, 3])              # hstack([1, 2, 3])\narray([1, 2, 3])\n\n", "; np.block([1, 2, 3])              # hstack([1, 2, 3])\narray([1, 2, 3])\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.block([a, b, 10])             # hstack([a, b, 10])\narray([ 1,  2,  3,  2,  3,  4, 10])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.block([a, b, 10])             # hstack([a, b, 10])\narray([ 1,  2,  3,  2,  3,  4, 10])\n", "; A = np.ones((2, 2), int)\n; B = 2 * A\n; np.block([A, B])                 # hstack([A, B])\narray([[1, 1, 2, 2],\n       [1, 1, 2, 2]])\n\n", "; A = np.ones((2, 2), int)\n; B = 2 * A\n; np.block([A, B])                 # hstack([A, B])\narray([[1, 1, 2, 2],\n       [1, 1, 2, 2]])\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.block([[a], [b]])             # vstack([a, b])\narray([[1, 2, 3],\n       [2, 3, 4]])\n\n", "; a = np.array([1, 2, 3])\n; b = np.array([2, 3, 4])\n; np.block([[a], [b]])             # vstack([a, b])\narray([[1, 2, 3],\n       [2, 3, 4]])\n", "; A = np.ones((2, 2), int)\n; B = 2 * A\n; np.block([[A], [B]])             # vstack([A, B])\narray([[1, 1],\n       [1, 1],\n       [2, 2],\n       [2, 2]])\n\n", "; A = np.ones((2, 2), int)\n; B = 2 * A\n; np.block([[A], [B]])             # vstack([A, B])\narray([[1, 1],\n       [1, 1],\n       [2, 2],\n       [2, 2]])\n", "; a = np.array(0)\n; b = np.array([1])\n; np.block([a])                    # atleast_1d(a)\narray([0])\n; np.block([b])                    # atleast_1d(b)\narray([1])\n\n", "; a = np.array(0)\n; b = np.array([1])\n; np.block([a])                    # atleast_1d(a)\narray([0])\n; np.block([b])                    # atleast_1d(b)\narray([1])\n", "; np.block([[a]])                  # atleast_2d(a)\narray([[0]])\n; np.block([[b]])                  # atleast_2d(b)\narray([[1]])\n\n", "; np.block([[a]])                  # atleast_2d(a)\narray([[0]])\n; np.block([[b]])                  # atleast_2d(b)\narray([[1]])\n"]},
{"library": "numpy", "item_id": "numpy.blackman", "code": "\nnumpy.blackman(M)[source]\u00b6", "description": "Return the Blackman window.\nThe Blackman window is a taper formed by using the first three\nterms of a summation of cosines. It was designed to have close to the\nminimal leakage possible.  It is close to optimal, only slightly worse\nthan a Kaiser window.\n\nParameters\n\nMintNumber of points in the output window. If zero or less, an empty\narray is returned.\n\n\n\nReturns\n\noutndarrayThe window, with the maximum value normalized to one (the value one\nappears only if the number of samples is odd).\n\n\n\n\n\nSee also\nbartlett, hamming, hanning, kaiser\n\nNotes\nThe Blackman window is defined as\n\n\nMost references to the Blackman window come from the signal processing\nliterature, where it is used as one of many windowing functions for\nsmoothing values.  It is also known as an apodization (which means\n\u201cremoving the foot\u201d, i.e. smoothing discontinuities at the beginning\nand end of the sampled signal) or tapering function. It is known as a\n\u201cnear optimal\u201d tapering function, almost as good (by some measures)\nas the kaiser window.\nReferences\nBlackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,\nDover Publications, New York.\nOppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.\nUpper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.\nExamples\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; np.blackman(12)\narray([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n\nPlot the window and the frequency response:\n&gt;&gt;&gt; from numpy.fft import fft, fftshift\n&gt;&gt;&gt; window = np.blackman(51)\n&gt;&gt;&gt; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Blackman window\")\nText(0.5, 1.0, 'Blackman window')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n&gt;&gt;&gt; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n&gt;&gt;&gt; A = fft(window, 2048) / 25.5\n&gt;&gt;&gt; mag = np.abs(fftshift(A))\n&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))\n&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n&gt;&gt;&gt; response = np.clip(response, -100, 100)\n&gt;&gt;&gt; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Frequency response of Blackman window\")\nText(0.5, 1.0, 'Frequency response of Blackman window')\n&gt;&gt;&gt; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n&gt;&gt;&gt; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n&gt;&gt;&gt; _ = plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "Mint", "Returns", "outndarray"], "returns": "outndarrayThe window, with the maximum value normalized to one (the value oneappears only if the number of samples is odd).", "examples": ["; import matplotlib.pyplot as plt\n; np.blackman(12)\narray([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n\n", "; import matplotlib.pyplot as plt\n; np.blackman(12)\narray([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary\n        4.14397981e-01,   7.36045180e-01,   9.67046769e-01,\n        9.67046769e-01,   7.36045180e-01,   4.14397981e-01,\n        1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])\n", "; from numpy.fft import fft, fftshift\n; window = np.blackman(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Blackman window\")\nText(0.5, 1.0, 'Blackman window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n\n", "; from numpy.fft import fft, fftshift\n; window = np.blackman(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Blackman window\")\nText(0.5, 1.0, 'Blackman window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Blackman window\")\nText(0.5, 1.0, 'Frequency response of Blackman window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; _ = plt.axis('tight')\n; plt.show()\n\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Blackman window\")\nText(0.5, 1.0, 'Frequency response of Blackman window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; _ = plt.axis('tight')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.bitwise_xor", "code": "\nnumpy.bitwise_xor(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'bitwise_xor'&gt;\u00b6", "description": "Compute the bit-wise XOR of two arrays element-wise.\nComputes the bit-wise XOR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator ^.\n\nParameters\n\nx1, x2array_likeOnly integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarResult.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_xor, bitwise_and, bitwise_or\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nExamples\nThe number 13 is represented by 00001101. Likewise, 17 is\nrepresented by 00010001.  The bit-wise XOR of 13 and 17 is\ntherefore 00011100, or 28:\n&gt;&gt;&gt; np.bitwise_xor(13, 17)\n28\n&gt;&gt;&gt; np.binary_repr(28)\n'11100'\n\n\n&gt;&gt;&gt; np.bitwise_xor(31, 5)\n26\n&gt;&gt;&gt; np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n\n&gt;&gt;&gt; np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n&gt;&gt;&gt; np.bitwise_xor([True, True], [False, True])\narray([ True, False])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarResult.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.bitwise_xor(13, 17)\n28\n; np.binary_repr(28)\n'11100'\n\n", "; np.bitwise_xor(13, 17)\n28\n; np.binary_repr(28)\n'11100'\n", "; np.bitwise_xor(31, 5)\n26\n; np.bitwise_xor([31,3], 5)\narray([26,  6])\n\n", "; np.bitwise_xor(31, 5)\n26\n; np.bitwise_xor([31,3], 5)\narray([26,  6])\n", "; np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n; np.bitwise_xor([True, True], [False, True])\narray([ True, False])\n\n", "; np.bitwise_xor([31,3], [5,6])\narray([26,  5])\n; np.bitwise_xor([True, True], [False, True])\narray([ True, False])\n"]},
{"library": "numpy", "item_id": "numpy.bitwise_or", "code": "\nnumpy.bitwise_or(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'bitwise_or'&gt;\u00b6", "description": "Compute the bit-wise OR of two arrays element-wise.\nComputes the bit-wise OR of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator |.\n\nParameters\n\nx1, x2array_likeOnly integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarResult.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_or, bitwise_and, bitwise_xor\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nExamples\nThe number 13 has the binaray representation 00001101. Likewise,\n16 is represented by 00010000.  The bit-wise OR of 13 and 16 is\nthen 000111011, or 29:\n&gt;&gt;&gt; np.bitwise_or(13, 16)\n29\n&gt;&gt;&gt; np.binary_repr(29)\n'11101'\n\n\n&gt;&gt;&gt; np.bitwise_or(32, 2)\n34\n&gt;&gt;&gt; np.bitwise_or([33, 4], 1)\narray([33,  5])\n&gt;&gt;&gt; np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n\n&gt;&gt;&gt; np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n&gt;&gt;&gt; np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n&gt;&gt;&gt; np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n&gt;&gt;&gt; np.bitwise_or([True, True], [False, True])\narray([ True,  True])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarResult.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.bitwise_or(13, 16)\n29\n; np.binary_repr(29)\n'11101'\n\n", "; np.bitwise_or(13, 16)\n29\n; np.binary_repr(29)\n'11101'\n", "; np.bitwise_or(32, 2)\n34\n; np.bitwise_or([33, 4], 1)\narray([33,  5])\n; np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n\n", "; np.bitwise_or(32, 2)\n34\n; np.bitwise_or([33, 4], 1)\narray([33,  5])\n; np.bitwise_or([33, 4], [1, 2])\narray([33,  6])\n", "; np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n; np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n; np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n; np.bitwise_or([True, True], [False, True])\narray([ True,  True])\n\n", "; np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4]))\narray([  6,   5, 255])\n; np.array([2, 5, 255]) | np.array([4, 4, 4])\narray([  6,   5, 255])\n; np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),\n...               np.array([4, 4, 4, 2147483647], dtype=np.int32))\narray([         6,          5,        255, 2147483647])\n; np.bitwise_or([True, True], [False, True])\narray([ True,  True])\n"]},
{"library": "numpy", "item_id": "numpy.bitwise_and", "code": "\nnumpy.bitwise_and(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'bitwise_and'&gt;\u00b6", "description": "Compute the bit-wise AND of two arrays element-wise.\nComputes the bit-wise AND of the underlying binary representation of\nthe integers in the input arrays. This ufunc implements the C/Python\noperator &amp;.\n\nParameters\n\nx1, x2array_likeOnly integer and boolean types are handled. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarResult.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\nlogical_and, bitwise_or, bitwise_xor\n\nbinary_reprReturn the binary representation of the input number as a string.\n\n\n\nExamples\nThe number 13 is represented by 00001101.  Likewise, 17 is\nrepresented by 00010001.  The bit-wise AND of 13 and 17 is\ntherefore 000000001, or 1:\n&gt;&gt;&gt; np.bitwise_and(13, 17)\n1\n\n\n&gt;&gt;&gt; np.bitwise_and(14, 13)\n12\n&gt;&gt;&gt; np.binary_repr(12)\n'1100'\n&gt;&gt;&gt; np.bitwise_and([14,3], 13)\narray([12,  1])\n\n\n&gt;&gt;&gt; np.bitwise_and([11,7], [4,25])\narray([0, 1])\n&gt;&gt;&gt; np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n&gt;&gt;&gt; np.bitwise_and([True, True], [False, True])\narray([False,  True])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarResult.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.bitwise_and(13, 17)\n1\n\n", "; np.bitwise_and(13, 17)\n1\n", "; np.bitwise_and(14, 13)\n12\n; np.binary_repr(12)\n'1100'\n; np.bitwise_and([14,3], 13)\narray([12,  1])\n\n", "; np.bitwise_and(14, 13)\n12\n; np.binary_repr(12)\n'1100'\n; np.bitwise_and([14,3], 13)\narray([12,  1])\n", "; np.bitwise_and([11,7], [4,25])\narray([0, 1])\n; np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n; np.bitwise_and([True, True], [False, True])\narray([False,  True])\n\n", "; np.bitwise_and([11,7], [4,25])\narray([0, 1])\n; np.bitwise_and(np.array([2,5,255]), np.array([3,14,16]))\narray([ 2,  4, 16])\n; np.bitwise_and([True, True], [False, True])\narray([False,  True])\n"]},
{"library": "numpy", "item_id": "numpy.random.BitGenerator", "code": "\nclass numpy.random.BitGenerator(seed=None)\u00b6", "description": "Base Class for generic BitGenerators, which provide a stream\nof random bits based on different algorithms. Must be overridden.\n\nParameters\n\nseed{None, int, array_like[ints], SeedSequence}, optionalA seed to initialize the BitGenerator. If None, then fresh,\nunpredictable entropy will be pulled from the OS. If an int or\narray_like[ints] is passed, then it will be passed to\n~`numpy.random.SeedSequence` to derive the initial BitGenerator state.\nOne may also pass in a SeedSequence instance.\n\n\n\nAttributes\n\nlockthreading.LockLock instance that is shared so that the same BitGenerator can\nbe used in multiple Generators without corrupting the state. Code that\ngenerates values from a bit generator should hold the bit generator\u2019s\nlock.\n\nSee Also\n\u2014\u2014-\nSeedSequence\n\n\n\nMethods\n\n\n\n\n\n\nrandom_raw(self[,\u00a0size])\nReturn randoms as generated by the underlying BitGenerator\n\n\n\n", "parameters": ["Parameters", "seed{None, int, array_like[ints], SeedSequence}, optional", "Attributes", "lockthreading.Lock", "See Also", "\u2014\u2014-", "SeedSequence"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.bit_generator", "code": "\nGenerator.bit_generator\u00b6", "description": "Gets the bit generator instance used by the generator\n\nReturns\n\nbit_generatorBitGeneratorThe bit generator instance used by the generator\n\n\n\n\n", "parameters": [], "returns": "bit_generatorBitGeneratorThe bit generator instance used by the generator", "examples": []},
{"library": "numpy", "item_id": "c.bitgen_t", "code": "\nbitgen_t\u00b6", "description": "The bitgen_t holds the current state of the BitGenerator and\npointers to functions that return standard C types while advancing the\nstate.\nstruct bitgen:\n    void *state\n    npy_uint64 (*next_uint64)(void *st) nogil\n    uint32_t (*next_uint32)(void *st) nogil\n    double (*next_double)(void *st) nogil\n    npy_uint64 (*next_raw)(void *st) nogil\n\nctypedef bitgen bitgen_t\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.RandomState.binomial", "code": "\nRandomState.binomial(n, p, size=None)\u00b6", "description": "Draw samples from a binomial distribution.\nSamples are drawn from a binomial distribution with specified\nparameters, n trials and p probability of success where\nn an integer &gt;= 0 and p is in the interval [0,1]. (n may be\ninput as a float, but it is truncated to an integer in use)\n\nNote\nNew code should use the binomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnint or array_like of intsParameter of the distribution, &gt;= 0. Floats are also accepted,\nbut they will be truncated to integers.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized binomial distribution, where\neach sample is equal to the number of successes over the n trials.\n\n\n\n\n\nSee also\n\nscipy.stats.binomprobability density function, distribution or cumulative density function, etc.\n\nGenerator.binomialwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the binomial distribution is\n\n\nwhere  is the number of trials,  is the probability\nof success, and  is the number of successes.\nWhen estimating the standard error of a proportion in a population by\nusing a random sample, the normal distribution works well unless the\nproduct p*n &lt;=5, where p = population proportion estimate, and n =\nnumber of samples, in which case the binomial distribution is used\ninstead. For example, a sample of 15 people shows 4 who are left\nhanded, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\nso the binomial distribution should be used in this case.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics with R\u201d,\nSpringer-Verlag, 2002.\n\n2\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n3\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n4\nWeisstein, Eric W. \u201cBinomial Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/BinomialDistribution.html\n\n5\nWikipedia, \u201cBinomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; n, p = 10, .5  # number of trials, probability of each trial\n&gt;&gt;&gt; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n\nA real world example. A company drills 9 wild-cat oil exploration\nwells, each with an estimated probability of success of 0.1. All nine\nwells fail. What is the probability of that happening?\nLet\u2019s do 20,000 trials of the model, and count the number that\ngenerate zero positive results.\n&gt;&gt;&gt; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n\n", "parameters": ["Parameters", "nint or array_like of ints", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.", "examples": ["; n, p = 10, .5  # number of trials, probability of each trial\n; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n", "; n, p = 10, .5  # number of trials, probability of each trial\n; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n", "; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n", "; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n"]},
{"library": "numpy", "item_id": "numpy.random.Generator.binomial", "code": "\nGenerator.binomial(n, p, size=None)\u00b6", "description": "Draw samples from a binomial distribution.\nSamples are drawn from a binomial distribution with specified\nparameters, n trials and p probability of success where\nn an integer &gt;= 0 and p is in the interval [0,1]. (n may be\ninput as a float, but it is truncated to an integer in use)\n\nParameters\n\nnint or array_like of intsParameter of the distribution, &gt;= 0. Floats are also accepted,\nbut they will be truncated to integers.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized binomial distribution, where\neach sample is equal to the number of successes over the n trials.\n\n\n\n\n\nSee also\n\nscipy.stats.binomprobability density function, distribution or cumulative density function, etc.\n\n\n\nNotes\nThe probability density for the binomial distribution is\n\n\nwhere  is the number of trials,  is the probability\nof success, and  is the number of successes.\nWhen estimating the standard error of a proportion in a population by\nusing a random sample, the normal distribution works well unless the\nproduct p*n &lt;=5, where p = population proportion estimate, and n =\nnumber of samples, in which case the binomial distribution is used\ninstead. For example, a sample of 15 people shows 4 who are left\nhanded, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\nso the binomial distribution should be used in this case.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics with R\u201d,\nSpringer-Verlag, 2002.\n\n2\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n3\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n4\nWeisstein, Eric W. \u201cBinomial Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/BinomialDistribution.html\n\n5\nWikipedia, \u201cBinomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; rng = np.random.default_rng()\n&gt;&gt;&gt; n, p = 10, .5  # number of trials, probability of each trial\n&gt;&gt;&gt; s = rng.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n\nA real world example. A company drills 9 wild-cat oil exploration\nwells, each with an estimated probability of success of 0.1. All nine\nwells fail. What is the probability of that happening?\nLet\u2019s do 20,000 trials of the model, and count the number that\ngenerate zero positive results.\n&gt;&gt;&gt; sum(rng.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n\n", "parameters": ["Parameters", "nint or array_like of ints", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.", "examples": ["; rng = np.random.default_rng()\n; n, p = 10, .5  # number of trials, probability of each trial\n; s = rng.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n", "; rng = np.random.default_rng()\n; n, p = 10, .5  # number of trials, probability of each trial\n; s = rng.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n", "; sum(rng.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n", "; sum(rng.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n"]},
{"library": "numpy", "item_id": "numpy.bincount", "code": "\nnumpy.bincount(x, weights=None, minlength=0)\u00b6", "description": "Count number of occurrences of each value in array of non-negative ints.\nThe number of bins (of size 1) is one larger than the largest value in\nx. If minlength is specified, there will be at least this number\nof bins in the output array (though it will be longer if necessary,\ndepending on the contents of x).\nEach bin gives the number of occurrences of its index value in x.\nIf weights is specified the input array is weighted by it, i.e. if a\nvalue n is found at position i, out[n] += weight[i] instead\nof out[n] += 1.\n\nParameters\n\nxarray_like, 1 dimension, nonnegative intsInput array.\n\nweightsarray_like, optionalWeights, array of the same shape as x.\n\nminlengthint, optionalA minimum number of bins for the output array.\n\nNew in version 1.6.0.\n\n\n\n\nReturns\n\noutndarray of intsThe result of binning the input array.\nThe length of out is equal to np.amax(x)+1.\n\n\n\nRaises\n\nValueErrorIf the input is not 1-dimensional, or contains elements with negative\nvalues, or if minlength is negative.\n\nTypeErrorIf the type of the input is float or complex.\n\n\n\n\n\nSee also\nhistogram, digitize, unique\n\nExamples\n&gt;&gt;&gt; np.bincount(np.arange(5))\narray([1, 1, 1, 1, 1])\n&gt;&gt;&gt; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\narray([1, 3, 1, 1, 0, 0, 0, 1])\n\n\n&gt;&gt;&gt; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n&gt;&gt;&gt; np.bincount(x).size == np.amax(x)+1\nTrue\n\n\nThe input array needs to be of integer dtype, otherwise a\nTypeError is raised:\n&gt;&gt;&gt; np.bincount(np.arange(5, dtype=float))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: array cannot be safely cast to required type\n\n\nA possible use of bincount is to perform sums over\nvariable-size chunks of an array, using the weights keyword.\n&gt;&gt;&gt; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n&gt;&gt;&gt; x = np.array([0, 1, 1, 2, 2, 2])\n&gt;&gt;&gt; np.bincount(x,  weights=w)\narray([ 0.3,  0.7,  1.1])\n\n\n", "parameters": ["Parameters", "xarray_like, 1 dimension, nonnegative ints", "weightsarray_like, optional", "minlengthint, optional", "Returns", "outndarray of ints", "Raises", "ValueError", "TypeError"], "returns": "outndarray of intsThe result of binning the input array.The length of out is equal to np.amax(x)+1.", "examples": ["; np.bincount(np.arange(5))\narray([1, 1, 1, 1, 1])\n; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\narray([1, 3, 1, 1, 0, 0, 0, 1])\n\n", "; np.bincount(np.arange(5))\narray([1, 1, 1, 1, 1])\n; np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))\narray([1, 3, 1, 1, 0, 0, 0, 1])\n", "; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n; np.bincount(x).size == np.amax(x)+1\nTrue\n\n", "; x = np.array([0, 1, 1, 3, 2, 1, 7, 23])\n; np.bincount(x).size == np.amax(x)+1\nTrue\n", "; np.bincount(np.arange(5, dtype=float))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: array cannot be safely cast to required type\n\n", "; np.bincount(np.arange(5, dtype=float))\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\nTypeError: array cannot be safely cast to required type\n", "; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n; x = np.array([0, 1, 1, 2, 2, 2])\n; np.bincount(x,  weights=w)\narray([ 0.3,  0.7,  1.1])\n\n", "; w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights\n; x = np.array([0, 1, 1, 2, 2, 2])\n; np.bincount(x,  weights=w)\narray([ 0.3,  0.7,  1.1])\n"]},
{"library": "numpy", "item_id": "numpy.random.binomial", "code": "\nnumpy.random.binomial(n, p, size=None)\u00b6", "description": "Draw samples from a binomial distribution.\nSamples are drawn from a binomial distribution with specified\nparameters, n trials and p probability of success where\nn an integer &gt;= 0 and p is in the interval [0,1]. (n may be\ninput as a float, but it is truncated to an integer in use)\n\nNote\nNew code should use the binomial method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nnint or array_like of intsParameter of the distribution, &gt;= 0. Floats are also accepted,\nbut they will be truncated to integers.\n\npfloat or array_like of floatsParameter of the distribution, &gt;= 0 and &lt;=1.\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if n and p are both scalars.\nOtherwise, np.broadcast(n, p).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized binomial distribution, where\neach sample is equal to the number of successes over the n trials.\n\n\n\n\n\nSee also\n\nscipy.stats.binomprobability density function, distribution or cumulative density function, etc.\n\nGenerator.binomialwhich should be used for new code.\n\n\n\nNotes\nThe probability density for the binomial distribution is\n\n\nwhere  is the number of trials,  is the probability\nof success, and  is the number of successes.\nWhen estimating the standard error of a proportion in a population by\nusing a random sample, the normal distribution works well unless the\nproduct p*n &lt;=5, where p = population proportion estimate, and n =\nnumber of samples, in which case the binomial distribution is used\ninstead. For example, a sample of 15 people shows 4 who are left\nhanded, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4,\nso the binomial distribution should be used in this case.\nReferences\n\n1\nDalgaard, Peter, \u201cIntroductory Statistics with R\u201d,\nSpringer-Verlag, 2002.\n\n2\nGlantz, Stanton A. \u201cPrimer of Biostatistics.\u201d, McGraw-Hill,\nFifth Edition, 2002.\n\n3\nLentner, Marvin, \u201cElementary Applied Statistics\u201d, Bogden\nand Quigley, 1972.\n\n4\nWeisstein, Eric W. \u201cBinomial Distribution.\u201d From MathWorld\u2013A\nWolfram Web Resource.\nhttp://mathworld.wolfram.com/BinomialDistribution.html\n\n5\nWikipedia, \u201cBinomial distribution\u201d,\nhttps://en.wikipedia.org/wiki/Binomial_distribution\n\n\nExamples\nDraw samples from the distribution:\n&gt;&gt;&gt; n, p = 10, .5  # number of trials, probability of each trial\n&gt;&gt;&gt; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n\nA real world example. A company drills 9 wild-cat oil exploration\nwells, each with an estimated probability of success of 0.1. All nine\nwells fail. What is the probability of that happening?\nLet\u2019s do 20,000 trials of the model, and count the number that\ngenerate zero positive results.\n&gt;&gt;&gt; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n\n", "parameters": ["Parameters", "nint or array_like of ints", "pfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized binomial distribution, whereeach sample is equal to the number of successes over the n trials.", "examples": ["; n, p = 10, .5  # number of trials, probability of each trial\n; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n\n", "; n, p = 10, .5  # number of trials, probability of each trial\n; s = np.random.binomial(n, p, 1000)\n# result of flipping a coin 10 times, tested 1000 times.\n", "; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n\n", "; sum(np.random.binomial(9, 0.1, 20000) == 0)/20000.\n# answer = 0.38885, or 38%.\n"]},
{"library": "numpy", "item_id": "numpy.binary_repr", "code": "\nnumpy.binary_repr(num, width=None)[source]\u00b6", "description": "Return the binary representation of the input number as a string.\nFor negative numbers, if width is not given, a minus sign is added to the\nfront. If width is given, the two\u2019s complement of the number is\nreturned, with respect to that width.\nIn a two\u2019s-complement system negative numbers are represented by the two\u2019s\ncomplement of the absolute value. This is the most common method of\nrepresenting signed integers on computers [1]. A N-bit two\u2019s-complement\nsystem can represent every integer in the range\n to .\n\nParameters\n\nnumintOnly an integer decimal number can be used.\n\nwidthint, optionalThe length of the returned string if num is positive, or the length\nof the two\u2019s complement if num is negative, provided that width is\nat least a sufficient number of bits for num to be represented in the\ndesignated form.\nIf the width value is insufficient, it will be ignored, and num will\nbe returned in binary (num &gt; 0) or two\u2019s complement (num &lt; 0) form\nwith its width equal to the minimum number of bits needed to represent\nthe number in the designated form. This behavior is deprecated and will\nlater raise an error.\n\nDeprecated since version 1.12.0.\n\n\n\n\nReturns\n\nbinstrBinary representation of num or two\u2019s complement of num.\n\n\n\n\n\nSee also\n\nbase_reprReturn a string representation of a number in the given base system.\n\nbinPython\u2019s built-in binary representation generator of an integer.\n\n\n\nNotes\nbinary_repr is equivalent to using base_repr with base 2, but about 25x\nfaster.\nReferences\n\n1\nWikipedia, \u201cTwo\u2019s complement\u201d,\nhttps://en.wikipedia.org/wiki/Two\u2019s_complement\n\n\nExamples\n&gt;&gt;&gt; np.binary_repr(3)\n'11'\n&gt;&gt;&gt; np.binary_repr(-3)\n'-11'\n&gt;&gt;&gt; np.binary_repr(3, width=4)\n'0011'\n\n\nThe two\u2019s complement is returned when the input number is negative and\nwidth is specified:\n&gt;&gt;&gt; np.binary_repr(-3, width=3)\n'101'\n&gt;&gt;&gt; np.binary_repr(-3, width=5)\n'11101'\n\n\n", "parameters": ["Parameters", "numint", "widthint, optional", "Returns", "binstr"], "returns": "binstrBinary representation of num or two\u2019s complement of num.", "examples": ["; np.binary_repr(3)\n'11'\n; np.binary_repr(-3)\n'-11'\n; np.binary_repr(3, width=4)\n'0011'\n\n", "; np.binary_repr(3)\n'11'\n; np.binary_repr(-3)\n'-11'\n; np.binary_repr(3, width=4)\n'0011'\n", "; np.binary_repr(-3, width=3)\n'101'\n; np.binary_repr(-3, width=5)\n'11101'\n\n", "; np.binary_repr(-3, width=3)\n'101'\n; np.binary_repr(-3, width=5)\n'11101'\n"]},
{"library": "numpy", "item_id": "numpy.random.RandomState.beta", "code": "\nRandomState.beta(a, b, size=None)\u00b6", "description": "Draw samples from a Beta distribution.\nThe Beta distribution is a special case of the Dirichlet distribution,\nand is related to the Gamma distribution.  It has the probability\ndistribution function\n\n\nwhere the normalization, B, is the beta function,\n\n\nIt is often seen in Bayesian inference and order statistics.\n\nNote\nNew code should use the beta method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsAlpha, positive (&gt;0).\n\nbfloat or array_like of floatsBeta, positive (&gt;0).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a and b are both scalars.\nOtherwise, np.broadcast(a, b).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized beta distribution.\n\n\n\n\n\nSee also\n\nGenerator.betawhich should be used for new code.\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "bfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized beta distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.Generator.beta", "code": "\nGenerator.beta(a, b, size=None)\u00b6", "description": "Draw samples from a Beta distribution.\nThe Beta distribution is a special case of the Dirichlet distribution,\nand is related to the Gamma distribution.  It has the probability\ndistribution function\n\n\nwhere the normalization, B, is the beta function,\n\n\nIt is often seen in Bayesian inference and order statistics.\n\nParameters\n\nafloat or array_like of floatsAlpha, positive (&gt;0).\n\nbfloat or array_like of floatsBeta, positive (&gt;0).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a and b are both scalars.\nOtherwise, np.broadcast(a, b).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized beta distribution.\n\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "bfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized beta distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.random.beta", "code": "\nnumpy.random.beta(a, b, size=None)\u00b6", "description": "Draw samples from a Beta distribution.\nThe Beta distribution is a special case of the Dirichlet distribution,\nand is related to the Gamma distribution.  It has the probability\ndistribution function\n\n\nwhere the normalization, B, is the beta function,\n\n\nIt is often seen in Bayesian inference and order statistics.\n\nNote\nNew code should use the beta method of a default_rng()\ninstance instead; see random-quick-start.\n\n\nParameters\n\nafloat or array_like of floatsAlpha, positive (&gt;0).\n\nbfloat or array_like of floatsBeta, positive (&gt;0).\n\nsizeint or tuple of ints, optionalOutput shape.  If the given shape is, e.g., (m, n, k), then\nm * n * k samples are drawn.  If size is None (default),\na single value is returned if a and b are both scalars.\nOtherwise, np.broadcast(a, b).size samples are drawn.\n\n\n\nReturns\n\noutndarray or scalarDrawn samples from the parameterized beta distribution.\n\n\n\n\n\nSee also\n\nGenerator.betawhich should be used for new code.\n\n\n\n", "parameters": ["Parameters", "afloat or array_like of floats", "bfloat or array_like of floats", "sizeint or tuple of ints, optional", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarDrawn samples from the parameterized beta distribution.", "examples": []},
{"library": "numpy", "item_id": "numpy.testing.Tester.bench", "code": "\nTester.bench(self, label='fast', verbose=1, extra_argv=None)[source]\u00b6", "description": "Run benchmarks for module using nose.\n\nParameters\n\nlabel{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optionalIdentifies the benchmarks to run. This can be a string to pass to\nthe nosetests executable with the \u2018-A\u2019 option, or one of several\nspecial values.  Special values are:\n\n\u2018fast\u2019 - the default - which corresponds to the nosetests -A\noption of \u2018not slow\u2019.\n\u2018full\u2019 - fast (as above) and slow benchmarks as in the\n\u2018no -A\u2019 option to nosetests - this is the same as \u2018\u2019.\nNone or \u2018\u2019 - run all tests.\nattribute_identifier - string passed directly to nosetests as \u2018-A\u2019.\n\n\nverboseint, optionalVerbosity value for benchmark outputs, in the range 1-10. Default is 1.\n\nextra_argvlist, optionalList with any extra arguments to pass to nosetests.\n\n\n\nReturns\n\nsuccessboolReturns True if running the benchmarks works, False if an error\noccurred.\n\n\n\n\nNotes\nBenchmarks are like tests, but have names starting with \u201cbench\u201d instead\nof \u201ctest\u201d, and can be found under the \u201cbenchmarks\u201d sub-directory of the\nmodule.\nEach NumPy module exposes bench in its namespace to run all benchmarks\nfor it.\nExamples\n&gt;&gt;&gt; success = np.lib.bench() \nRunning benchmarks for numpy.lib\n...\nusing 562341 items:\nunique:\n0.11\nunique1d:\n0.11\nratio: 1.0\nnUnique: 56230 == 56230\n...\nOK\n\n\n&gt;&gt;&gt; success \nTrue\n\n\n", "parameters": ["Parameters", "label{\u2018fast\u2019, \u2018full\u2019, \u2018\u2019, attribute identifier}, optional", "verboseint, optional", "extra_argvlist, optional", "Returns", "successbool"], "returns": "successboolReturns True if running the benchmarks works, False if an erroroccurred.", "examples": ["; success = np.lib.bench() \nRunning benchmarks for numpy.lib\n...\nusing 562341 items:\nunique:\n0.11\nunique1d:\n0.11\nratio: 1.0\nnUnique: 56230 == 56230\n...\nOK\n\n", "; success = np.lib.bench() \nRunning benchmarks for numpy.lib\n...\nusing 562341 items:\nunique:\n0.11\nunique1d:\n0.11\nratio: 1.0\nnUnique: 56230 == 56230\n...\nOK\n", "; success \nTrue\n\n", "; success \nTrue\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.basis_name", "code": "\nPolynomial.basis_name = None\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.basis_name", "code": "\nLegendre.basis_name = 'P'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.basis_name", "code": "\nLaguerre.basis_name = 'L'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.basis_name", "code": "\nHermiteE.basis_name = 'He'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.basis_name", "code": "\nHermite.basis_name = 'H'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.basis_name", "code": "\nChebyshev.basis_name = 'T'\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.basis", "code": "\nclassmethod HermiteE.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.basis", "code": "\nclassmethod Polynomial.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.basis", "code": "\nclassmethod Legendre.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.basis", "code": "\nclassmethod Hermite.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.basis", "code": "\nclassmethod Chebyshev.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.basis", "code": "\nclassmethod Laguerre.basis(deg, domain=None, window=None)[source]\u00b6", "description": "Series basis polynomial of degree deg.\nReturns the series representing the basis polynomial of degree deg.\n\nNew in version 1.7.0.\n\n\nParameters\n\ndegintDegree of the basis polynomial for the series. Must be &gt;= 0.\n\ndomain{None, array_like}, optionalIf given, the array must be of the form [beg, end], where\nbeg and end are the endpoints of the domain. If None is\ngiven then the class domain is used. The default is None.\n\nwindow{None, array_like}, optionalIf given, the resulting array must be if the form\n[beg, end], where beg and end are the endpoints of\nthe window. If None is given then the class window is used. The\ndefault is None.\n\n\n\nReturns\n\nnew_seriesseriesA series with the coefficient of the deg term set to one and\nall others zero.\n\n\n\n\n", "parameters": ["Parameters", "degint", "domain{None, array_like}, optional", "window{None, array_like}, optional", "Returns", "new_seriesseries"], "returns": "new_seriesseriesA series with the coefficient of the deg term set to one andall others zero.", "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.baseclass", "code": "\nproperty masked_array.baseclass\u00b6", "description": "Class of the underlying data (read-only).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.base_repr", "code": "\nnumpy.base_repr(number, base=2, padding=0)[source]\u00b6", "description": "Return a string representation of a number in the given base system.\n\nParameters\n\nnumberintThe value to convert. Positive and negative values are handled.\n\nbaseint, optionalConvert number to the base number system. The valid range is 2-36,\nthe default value is 2.\n\npaddingint, optionalNumber of zeros padded on the left. Default is 0 (no padding).\n\n\n\nReturns\n\noutstrString representation of number in base system.\n\n\n\n\n\nSee also\n\nbinary_reprFaster version of base_repr for base 2.\n\n\n\nExamples\n&gt;&gt;&gt; np.base_repr(5)\n'101'\n&gt;&gt;&gt; np.base_repr(6, 5)\n'11'\n&gt;&gt;&gt; np.base_repr(7, base=5, padding=3)\n'00012'\n\n\n&gt;&gt;&gt; np.base_repr(10, base=16)\n'A'\n&gt;&gt;&gt; np.base_repr(32, base=16)\n'20'\n\n\n", "parameters": ["Parameters", "numberint", "baseint, optional", "paddingint, optional", "Returns", "outstr"], "returns": "outstrString representation of number in base system.", "examples": ["; np.base_repr(5)\n'101'\n; np.base_repr(6, 5)\n'11'\n; np.base_repr(7, base=5, padding=3)\n'00012'\n\n", "; np.base_repr(5)\n'101'\n; np.base_repr(6, 5)\n'11'\n; np.base_repr(7, base=5, padding=3)\n'00012'\n", "; np.base_repr(10, base=16)\n'A'\n; np.base_repr(32, base=16)\n'20'\n\n", "; np.base_repr(10, base=16)\n'A'\n; np.base_repr(32, base=16)\n'20'\n"]},
{"library": "numpy", "item_id": "numpy.record.base", "code": "\nrecord.base\u00b6", "description": "base object\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.base", "code": "\nndarray.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.matrix.base", "code": "\nmatrix.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.base", "code": "\nMaskType.base\u00b6", "description": "base object\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.base", "code": "\nrecarray.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.memmap.base", "code": "\nmemmap.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.base", "code": "\nMaskedArray.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.base", "code": "\nmasked_array.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.generic.base", "code": "\ngeneric.base\u00b6", "description": "base object\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.base", "code": "\ndtype.base\u00b6", "description": "Returns dtype for the base element of the subarrays,\nregardless of their dimension or shape.\n\nSee also\ndtype.subdtype\n\nExamples\n&gt;&gt;&gt; x = numpy.dtype('8f')\n&gt;&gt;&gt; x.base\ndtype('float32')\n\n\n&gt;&gt;&gt; x =  numpy.dtype('i2')\n&gt;&gt;&gt; x.base\ndtype('int16')\n\n\n", "parameters": [], "returns": [], "examples": ["; x = numpy.dtype('8f')\n; x.base\ndtype('float32')\n\n", "; x = numpy.dtype('8f')\n; x.base\ndtype('float32')\n", "; x =  numpy.dtype('i2')\n; x.base\ndtype('int16')\n\n", "; x =  numpy.dtype('i2')\n; x.base\ndtype('int16')\n"]},
{"library": "numpy", "item_id": "numpy.chararray.base", "code": "\nchararray.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.base", "code": "\nchararray.base\u00b6", "description": "Base object if memory is from some other object.\nExamples\nThe base of an array that owns its memory is None:\n&gt;&gt;&gt; x = np.array([1,2,3,4])\n&gt;&gt;&gt; x.base is None\nTrue\n\n\nSlicing creates a view, whose memory is shared with x:\n&gt;&gt;&gt; y = x[2:]\n&gt;&gt;&gt; y.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n\n", "; x = np.array([1,2,3,4])\n; x.base is None\nTrue\n", "; y = x[2:]\n; y.base is x\nTrue\n\n", "; y = x[2:]\n; y.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.flatiter.base", "code": "\nflatiter.base\u00b6", "description": "A reference to the array that is iterated over.\nExamples\n&gt;&gt;&gt; x = np.arange(5)\n&gt;&gt;&gt; fl = x.flat\n&gt;&gt;&gt; fl.base is x\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(5)\n; fl = x.flat\n; fl.base is x\nTrue\n\n", "; x = np.arange(5)\n; fl = x.flat\n; fl.base is x\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.average", "code": "\nnumpy.ma.average(a, axis=None, weights=None, returned=False)[source]\u00b6", "description": "Return the weighted average of array over the given axis.\n\nParameters\n\naarray_likeData to be averaged.\nMasked entries are not taken into account in the computation.\n\naxisint, optionalAxis along which to average a. If None, averaging is done over\nthe flattened array.\n\nweightsarray_like, optionalThe importance that each element has in the computation of the average.\nThe weights array can either be 1-D (in which case its length must be\nthe size of a along the given axis) or of the same shape as a.\nIf weights=None, then all data in a are assumed to have a\nweight equal to one.  The 1-D calculation is:\navg = sum(a * weights) / sum(weights)\n\n\nThe only constraint on weights is that sum(weights) must not be 0.\n\nreturnedbool, optionalFlag indicating whether a tuple (result, sum of weights)\nshould be returned as output (True), or just the result (False).\nDefault is False.\n\n\n\nReturns\n\naverage, [sum_of_weights](tuple of) scalar or MaskedArrayThe average along the specified axis. When returned is True,\nreturn a tuple with the average as the first element and the sum\nof the weights as the second element. The return type is np.float64\nif a is of integer type and floats smaller than float64, or the\ninput data-type, otherwise. If returned, sum_of_weights is always\nfloat64.\n\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n&gt;&gt;&gt; np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n\n\n&gt;&gt;&gt; x = np.ma.arange(6.).reshape(3, 2)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[0., 1.],\n        [2., 3.],\n        [4., 5.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n&gt;&gt;&gt; avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\n             mask=[False, False],\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "weightsarray_like, optional", "returnedbool, optional", "Returns", "average, [sum_of_weights](tuple of) scalar or MaskedArray"], "returns": "average, [sum_of_weights](tuple of) scalar or MaskedArrayThe average along the specified axis. When returned is True,return a tuple with the average as the first element and the sumof the weights as the second element. The return type is np.float64if a is of integer type and floats smaller than float64, or theinput data-type, otherwise. If returned, sum_of_weights is alwaysfloat64.", "examples": ["; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n; np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n\n", "; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])\n; np.ma.average(a, weights=[3, 1, 0, 0])\n1.25\n", "; x = np.ma.arange(6.).reshape(3, 2)\n; x\nmasked_array(\n  data=[[0., 1.],\n        [2., 3.],\n        [4., 5.]],\n  mask=False,\n  fill_value=1e+20)\n; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n; avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\n             mask=[False, False],\n       fill_value=1e+20)\n\n", "; x = np.ma.arange(6.).reshape(3, 2)\n; x\nmasked_array(\n  data=[[0., 1.],\n        [2., 3.],\n        [4., 5.]],\n  mask=False,\n  fill_value=1e+20)\n; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],\n...                                 returned=True)\n; avg\nmasked_array(data=[2.6666666666666665, 3.6666666666666665],\n             mask=[False, False],\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.average", "code": "\nnumpy.average(a, axis=None, weights=None, returned=False)[source]\u00b6", "description": "Compute the weighted average along the specified axis.\n\nParameters\n\naarray_likeArray containing data to be averaged. If a is not an array, a\nconversion is attempted.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which to average a.  The default,\naxis=None, will average over all of the elements of the input array.\nIf axis is negative it counts from the last to the first axis.\n\nNew in version 1.7.0.\n\nIf axis is a tuple of ints, averaging is performed on all of the axes\nspecified in the tuple instead of a single axis or all the axes as\nbefore.\n\nweightsarray_like, optionalAn array of weights associated with the values in a. Each value in\na contributes to the average according to its associated weight.\nThe weights array can either be 1-D (in which case its length must be\nthe size of a along the given axis) or of the same shape as a.\nIf weights=None, then all data in a are assumed to have a\nweight equal to one.  The 1-D calculation is:\navg = sum(a * weights) / sum(weights)\n\n\nThe only constraint on weights is that sum(weights) must not be 0.\n\nreturnedbool, optionalDefault is False. If True, the tuple (average, sum_of_weights)\nis returned, otherwise only the average is returned.\nIf weights=None, sum_of_weights is equivalent to the number of\nelements over which the average is taken.\n\n\n\nReturns\n\nretval, [sum_of_weights]array_type or doubleReturn the average along the specified axis. When returned is True,\nreturn a tuple with the average as the first element and the sum\nof the weights as the second element. sum_of_weights is of the\nsame type as retval. The result dtype follows a genereal pattern.\nIf weights is None, the result dtype will be that of a , or float64\nif a is integral. Otherwise, if weights is not None and a is non-\nintegral, the result type will be the type of lowest precision capable of\nrepresenting values of both a and weights. If a happens to be\nintegral, the previous rules still applies but the result dtype will\nat least be float64.\n\n\n\nRaises\n\nZeroDivisionErrorWhen all weights along axis are zero. See numpy.ma.average for a\nversion robust to this type of error.\n\nTypeErrorWhen the length of 1D weights is not the same as the shape of a\nalong axis.\n\n\n\n\n\nSee also\nmean\n\nma.averageaverage for masked arrays \u2013 useful if your data contains \u201cmissing\u201d values\n\nnumpy.result_typeReturns the type that results from applying the numpy type promotion rules to the arguments.\n\n\n\nExamples\n&gt;&gt;&gt; data = np.arange(1, 5)\n&gt;&gt;&gt; data\narray([1, 2, 3, 4])\n&gt;&gt;&gt; np.average(data)\n2.5\n&gt;&gt;&gt; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n4.0\n\n\n&gt;&gt;&gt; data = np.arange(6).reshape((3,2))\n&gt;&gt;&gt; data\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n&gt;&gt;&gt; np.average(data, axis=1, weights=[1./4, 3./4])\narray([0.75, 2.75, 4.75])\n&gt;&gt;&gt; np.average(data, weights=[1./4, 3./4])\nTraceback (most recent call last):\n    ...\nTypeError: Axis must be specified when shapes of a and weights differ.\n\n\n&gt;&gt;&gt; a = np.ones(5, dtype=np.float128)\n&gt;&gt;&gt; w = np.ones(5, dtype=np.complex64)\n&gt;&gt;&gt; avg = np.average(a, weights=w)\n&gt;&gt;&gt; print(avg.dtype)\ncomplex256\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "weightsarray_like, optional", "returnedbool, optional", "Returns", "retval, [sum_of_weights]array_type or double", "Raises", "ZeroDivisionError", "TypeError"], "returns": "retval, [sum_of_weights]array_type or doubleReturn the average along the specified axis. When returned is True,return a tuple with the average as the first element and the sumof the weights as the second element. sum_of_weights is of thesame type as retval. The result dtype follows a genereal pattern.If weights is None, the result dtype will be that of a , or float64if a is integral. Otherwise, if weights is not None and a is non-integral, the result type will be the type of lowest precision capable ofrepresenting values of both a and weights. If a happens to beintegral, the previous rules still applies but the result dtype willat least be float64.", "examples": ["; data = np.arange(1, 5)\n; data\narray([1, 2, 3, 4])\n; np.average(data)\n2.5\n; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n4.0\n\n", "; data = np.arange(1, 5)\n; data\narray([1, 2, 3, 4])\n; np.average(data)\n2.5\n; np.average(np.arange(1, 11), weights=np.arange(10, 0, -1))\n4.0\n", "; data = np.arange(6).reshape((3,2))\n; data\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n; np.average(data, axis=1, weights=[1./4, 3./4])\narray([0.75, 2.75, 4.75])\n; np.average(data, weights=[1./4, 3./4])\nTraceback (most recent call last):\n    ...\nTypeError: Axis must be specified when shapes of a and weights differ.\n\n", "; data = np.arange(6).reshape((3,2))\n; data\narray([[0, 1],\n       [2, 3],\n       [4, 5]])\n; np.average(data, axis=1, weights=[1./4, 3./4])\narray([0.75, 2.75, 4.75])\n; np.average(data, weights=[1./4, 3./4])\nTraceback (most recent call last):\n    ...\nTypeError: Axis must be specified when shapes of a and weights differ.\n", "; a = np.ones(5, dtype=np.float128)\n; w = np.ones(5, dtype=np.complex64)\n; avg = np.average(a, weights=w)\n; print(avg.dtype)\ncomplex256\n\n", "; a = np.ones(5, dtype=np.float128)\n; w = np.ones(5, dtype=np.complex64)\n; avg = np.average(a, weights=w)\n; print(avg.dtype)\ncomplex256\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.bartlett", "code": "\nnumpy.bartlett(M)[source]\u00b6", "description": "Return the Bartlett window.\nThe Bartlett window is very similar to a triangular window, except\nthat the end points are at zero.  It is often used in signal\nprocessing for tapering a signal, without generating too much\nripple in the frequency domain.\n\nParameters\n\nMintNumber of points in the output window. If zero or less, an\nempty array is returned.\n\n\n\nReturns\n\noutarrayThe triangular window, with the maximum value normalized to one\n(the value one appears only if the number of samples is odd), with\nthe first and last samples equal to zero.\n\n\n\n\n\nSee also\nblackman, hamming, hanning, kaiser\n\nNotes\nThe Bartlett window is defined as\n\n\nMost references to the Bartlett window come from the signal\nprocessing literature, where it is used as one of many windowing\nfunctions for smoothing values.  Note that convolution with this\nwindow produces linear interpolation.  It is also known as an\napodization (which means\u201dremoving the foot\u201d, i.e. smoothing\ndiscontinuities at the beginning and end of the sampled signal) or\ntapering function. The fourier transform of the Bartlett is the product\nof two sinc functions.\nNote the excellent discussion in Kanasewich.\nReferences\n\n1\nM.S. Bartlett, \u201cPeriodogram Analysis and Continuous Spectra\u201d,\nBiometrika 37, 1-16, 1950.\n\n2\nE.R. Kanasewich, \u201cTime Sequence Analysis in Geophysics\u201d,\nThe University of Alberta Press, 1975, pp. 109-110.\n\n3\nA.V. Oppenheim and R.W. Schafer, \u201cDiscrete-Time Signal\nProcessing\u201d, Prentice-Hall, 1999, pp. 468-471.\n\n4\nWikipedia, \u201cWindow function\u201d,\nhttps://en.wikipedia.org/wiki/Window_function\n\n5\nW.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,\n\u201cNumerical Recipes\u201d, Cambridge University Press, 1986, page 429.\n\n\nExamples\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n\n\nPlot the window and its frequency response (requires SciPy and matplotlib):\n&gt;&gt;&gt; from numpy.fft import fft, fftshift\n&gt;&gt;&gt; window = np.bartlett(51)\n&gt;&gt;&gt; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Bartlett window\")\nText(0.5, 1.0, 'Bartlett window')\n&gt;&gt;&gt; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n&gt;&gt;&gt; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n&gt;&gt;&gt; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n&gt;&gt;&gt; A = fft(window, 2048) / 25.5\n&gt;&gt;&gt; mag = np.abs(fftshift(A))\n&gt;&gt;&gt; freq = np.linspace(-0.5, 0.5, len(A))\n&gt;&gt;&gt; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n&gt;&gt;&gt; response = np.clip(response, -100, 100)\n&gt;&gt;&gt; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n&gt;&gt;&gt; plt.title(\"Frequency response of Bartlett window\")\nText(0.5, 1.0, 'Frequency response of Bartlett window')\n&gt;&gt;&gt; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n&gt;&gt;&gt; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n&gt;&gt;&gt; _ = plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "Mint", "Returns", "outarray"], "returns": "outarrayThe triangular window, with the maximum value normalized to one(the value one appears only if the number of samples is odd), withthe first and last samples equal to zero.", "examples": ["; import matplotlib.pyplot as plt\n; np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n\n", "; import matplotlib.pyplot as plt\n; np.bartlett(12)\narray([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary\n        0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,\n        0.18181818,  0.        ])\n", "; from numpy.fft import fft, fftshift\n; window = np.bartlett(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Bartlett window\")\nText(0.5, 1.0, 'Bartlett window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n\n", "; from numpy.fft import fft, fftshift\n; window = np.bartlett(51)\n; plt.plot(window)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Bartlett window\")\nText(0.5, 1.0, 'Bartlett window')\n; plt.ylabel(\"Amplitude\")\nText(0, 0.5, 'Amplitude')\n; plt.xlabel(\"Sample\")\nText(0.5, 0, 'Sample')\n; plt.show()\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Bartlett window\")\nText(0.5, 1.0, 'Frequency response of Bartlett window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; _ = plt.axis('tight')\n; plt.show()\n\n", "; plt.figure()\n&lt;Figure size 640x480 with 0 Axes&gt;\n; A = fft(window, 2048) / 25.5\n; mag = np.abs(fftshift(A))\n; freq = np.linspace(-0.5, 0.5, len(A))\n; with np.errstate(divide='ignore', invalid='ignore'):\n...     response = 20 * np.log10(mag)\n...\n; response = np.clip(response, -100, 100)\n; plt.plot(freq, response)\n[&lt;matplotlib.lines.Line2D object at 0x...&gt;]\n; plt.title(\"Frequency response of Bartlett window\")\nText(0.5, 1.0, 'Frequency response of Bartlett window')\n; plt.ylabel(\"Magnitude [dB]\")\nText(0, 0.5, 'Magnitude [dB]')\n; plt.xlabel(\"Normalized frequency [cycles per sample]\")\nText(0.5, 0, 'Normalized frequency [cycles per sample]')\n; _ = plt.axis('tight')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.atleast_3d", "code": "\nnumpy.atleast_3d(*arys)[source]\u00b6", "description": "View inputs as arrays with at least three dimensions.\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more array-like sequences.  Non-array inputs are converted to\narrays.  Arrays that already have three or more dimensions are\npreserved.\n\n\n\nReturns\n\nres1, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 3.  Copies are\navoided where possible, and views with three or more dimensions are\nreturned.  For example, a 1-D array of shape (N,) becomes a view\nof shape (1, N, 1), and a 2-D array of shape (M, N) becomes a\nview of shape (M, N, 1).\n\n\n\n\n\nSee also\natleast_1d, atleast_2d\n\nExamples\n&gt;&gt;&gt; np.atleast_3d(3.0)\narray([[[3.]]])\n\n\n&gt;&gt;&gt; x = np.arange(3.0)\n&gt;&gt;&gt; np.atleast_3d(x).shape\n(1, 3, 1)\n\n\n&gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)\n&gt;&gt;&gt; np.atleast_3d(x).shape\n(4, 3, 1)\n&gt;&gt;&gt; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n\n&gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "res1, res2, \u2026ndarray"], "returns": "res1, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 3.  Copies areavoided where possible, and views with three or more dimensions arereturned.  For example, a 1-D array of shape (N,) becomes a viewof shape (1, N, 1), and a 2-D array of shape (M, N) becomes aview of shape (M, N, 1).", "examples": ["; np.atleast_3d(3.0)\narray([[[3.]]])\n\n", "; np.atleast_3d(3.0)\narray([[[3.]]])\n", "; x = np.arange(3.0)\n; np.atleast_3d(x).shape\n(1, 3, 1)\n\n", "; x = np.arange(3.0)\n; np.atleast_3d(x).shape\n(1, 3, 1)\n", "; x = np.arange(12.0).reshape(4,3)\n; np.atleast_3d(x).shape\n(4, 3, 1)\n; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n", "; x = np.arange(12.0).reshape(4,3)\n; np.atleast_3d(x).shape\n(4, 3, 1)\n; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n", "; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n\n", "; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n"]},
{"library": "numpy", "item_id": "numpy.ma.atleast_3d", "code": "\nnumpy.ma.atleast_3d(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_allargs object&gt;\u00b6", "description": "\nView inputs as arrays with at least three dimensions.\n\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more array-like sequences.  Non-array inputs are converted to\narrays.  Arrays that already have three or more dimensions are\npreserved.\n\n\n\nReturns\n\nres1, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 3.  Copies are\navoided where possible, and views with three or more dimensions are\nreturned.  For example, a 1-D array of shape (N,) becomes a view\nof shape (1, N, 1), and a 2-D array of shape (M, N) becomes a\nview of shape (M, N, 1).\n\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; np.atleast_3d(3.0)\narray([[[3.]]])\n\n\n&gt;&gt;&gt; x = np.arange(3.0)\n&gt;&gt;&gt; np.atleast_3d(x).shape\n(1, 3, 1)\n\n\n&gt;&gt;&gt; x = np.arange(12.0).reshape(4,3)\n&gt;&gt;&gt; np.atleast_3d(x).shape\n(4, 3, 1)\n&gt;&gt;&gt; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n\n&gt;&gt;&gt; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "res1, res2, \u2026ndarray"], "returns": "res1, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 3.  Copies areavoided where possible, and views with three or more dimensions arereturned.  For example, a 1-D array of shape (N,) becomes a viewof shape (1, N, 1), and a 2-D array of shape (M, N) becomes aview of shape (M, N, 1).", "examples": ["; np.atleast_3d(3.0)\narray([[[3.]]])\n\n", "; np.atleast_3d(3.0)\narray([[[3.]]])\n", "; x = np.arange(3.0)\n; np.atleast_3d(x).shape\n(1, 3, 1)\n\n", "; x = np.arange(3.0)\n; np.atleast_3d(x).shape\n(1, 3, 1)\n", "; x = np.arange(12.0).reshape(4,3)\n; np.atleast_3d(x).shape\n(4, 3, 1)\n; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n\n", "; x = np.arange(12.0).reshape(4,3)\n; np.atleast_3d(x).shape\n(4, 3, 1)\n; np.atleast_3d(x).base is x.base  # x is a reshape, so not base itself\nTrue\n", "; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n\n", "; for arr in np.atleast_3d([1, 2], [[1, 2]], [[[1, 2]]]):\n...     print(arr, arr.shape) \n...\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1]\n  [2]]] (1, 2, 1)\n[[[1 2]]] (1, 1, 2)\n"]},
{"library": "numpy", "item_id": "numpy.ma.atleast_2d", "code": "\nnumpy.ma.atleast_2d(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_allargs object&gt;\u00b6", "description": "\nView inputs as arrays with at least two dimensions.\n\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more array-like sequences.  Non-array inputs are converted\nto arrays.  Arrays that already have two or more dimensions are\npreserved.\n\n\n\nReturns\n\nres, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 2.\nCopies are avoided where possible, and views with two or more\ndimensions are returned.\n\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; np.atleast_2d(3.0)\narray([[3.]])\n\n\n&gt;&gt;&gt; x = np.arange(3.0)\n&gt;&gt;&gt; np.atleast_2d(x)\narray([[0., 1., 2.]])\n&gt;&gt;&gt; np.atleast_2d(x).base is x\nTrue\n\n\n&gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "res, res2, \u2026ndarray"], "returns": "res, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 2.Copies are avoided where possible, and views with two or moredimensions are returned.", "examples": ["; np.atleast_2d(3.0)\narray([[3.]])\n\n", "; np.atleast_2d(3.0)\narray([[3.]])\n", "; x = np.arange(3.0)\n; np.atleast_2d(x)\narray([[0., 1., 2.]])\n; np.atleast_2d(x).base is x\nTrue\n\n", "; x = np.arange(3.0)\n; np.atleast_2d(x)\narray([[0., 1., 2.]])\n; np.atleast_2d(x).base is x\nTrue\n", "; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n\n", "; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n"]},
{"library": "numpy", "item_id": "numpy.ma.atleast_1d", "code": "\nnumpy.ma.atleast_1d(*args, **kwargs) = &lt;numpy.ma.extras._fromnxfunction_allargs object&gt;\u00b6", "description": "\nConvert inputs to arrays with at least one dimension.\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.\n\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more input arrays.\n\n\n\nReturns\n\nretndarrayAn array, or list of arrays, each with a.ndim &gt;= 1.\nCopies are made only if necessary.\n\n\n\n\nNotes\nThe function is applied to both the _data and the _mask, if any.\nExamples\n&gt;&gt;&gt; np.atleast_1d(1.0)\narray([1.])\n\n\n&gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)\n&gt;&gt;&gt; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n&gt;&gt;&gt; np.atleast_1d(x) is x\nTrue\n\n\n&gt;&gt;&gt; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "retndarray"], "returns": "retndarrayAn array, or list of arrays, each with a.ndim &gt;= 1.Copies are made only if necessary.", "examples": ["; np.atleast_1d(1.0)\narray([1.])\n\n", "; np.atleast_1d(1.0)\narray([1.])\n", "; x = np.arange(9.0).reshape(3,3)\n; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n; np.atleast_1d(x) is x\nTrue\n\n", "; x = np.arange(9.0).reshape(3,3)\n; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n; np.atleast_1d(x) is x\nTrue\n", "; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n\n", "; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n"]},
{"library": "numpy", "item_id": "numpy.ufunc.at", "code": "\nufunc.at(a, indices, b=None)\u00b6", "description": "Performs unbuffered in place operation on operand \u2018a\u2019 for elements\nspecified by \u2018indices\u2019. For addition ufunc, this method is equivalent to\na[indices] += b, except that results are accumulated for elements that\nare indexed more than once. For example, a[[0,0]] += 1 will only\nincrement the first element once because of buffering, whereas\nadd.at(a, [0,0], 1) will increment the first element twice.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeThe array to perform in place operation on.\n\nindicesarray_like or tupleArray like index object or slice object for indexing into first\noperand. If first operand has multiple dimensions, indices can be a\ntuple of array like index objects or slice objects.\n\nbarray_likeSecond operand for ufuncs requiring two operands. Operand must be\nbroadcastable over first operand after indexing or slicing.\n\n\n\n\nExamples\nSet items 0 and 1 to their negative values:\n&gt;&gt;&gt; a = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; np.negative.at(a, [0, 1])\n&gt;&gt;&gt; a\narray([-1, -2,  3,  4])\n\n\nIncrement items 0 and 1, and increment item 2 twice:\n&gt;&gt;&gt; a = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; np.add.at(a, [0, 1, 2, 2], 1)\n&gt;&gt;&gt; a\narray([2, 3, 5, 4])\n\n\nAdd items 0 and 1 in first array to second array,\nand store results in first array:\n&gt;&gt;&gt; a = np.array([1, 2, 3, 4])\n&gt;&gt;&gt; b = np.array([1, 2])\n&gt;&gt;&gt; np.add.at(a, [0, 1], b)\n&gt;&gt;&gt; a\narray([2, 4, 3, 4])\n\n\n", "parameters": ["Parameters", "aarray_like", "indicesarray_like or tuple", "barray_like"], "returns": [], "examples": ["; a = np.array([1, 2, 3, 4])\n; np.negative.at(a, [0, 1])\n; a\narray([-1, -2,  3,  4])\n\n", "; a = np.array([1, 2, 3, 4])\n; np.negative.at(a, [0, 1])\n; a\narray([-1, -2,  3,  4])\n", "; a = np.array([1, 2, 3, 4])\n; np.add.at(a, [0, 1, 2, 2], 1)\n; a\narray([2, 3, 5, 4])\n\n", "; a = np.array([1, 2, 3, 4])\n; np.add.at(a, [0, 1, 2, 2], 1)\n; a\narray([2, 3, 5, 4])\n", "; a = np.array([1, 2, 3, 4])\n; b = np.array([1, 2])\n; np.add.at(a, [0, 1], b)\n; a\narray([2, 4, 3, 4])\n\n", "; a = np.array([1, 2, 3, 4])\n; b = np.array([1, 2])\n; np.add.at(a, [0, 1], b)\n; a\narray([2, 4, 3, 4])\n"]},
{"library": "numpy", "item_id": "numpy.atleast_1d", "code": "\nnumpy.atleast_1d(*arys)[source]\u00b6", "description": "Convert inputs to arrays with at least one dimension.\nScalar inputs are converted to 1-dimensional arrays, whilst\nhigher-dimensional inputs are preserved.\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more input arrays.\n\n\n\nReturns\n\nretndarrayAn array, or list of arrays, each with a.ndim &gt;= 1.\nCopies are made only if necessary.\n\n\n\n\n\nSee also\natleast_2d, atleast_3d\n\nExamples\n&gt;&gt;&gt; np.atleast_1d(1.0)\narray([1.])\n\n\n&gt;&gt;&gt; x = np.arange(9.0).reshape(3,3)\n&gt;&gt;&gt; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n&gt;&gt;&gt; np.atleast_1d(x) is x\nTrue\n\n\n&gt;&gt;&gt; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "retndarray"], "returns": "retndarrayAn array, or list of arrays, each with a.ndim &gt;= 1.Copies are made only if necessary.", "examples": ["; np.atleast_1d(1.0)\narray([1.])\n\n", "; np.atleast_1d(1.0)\narray([1.])\n", "; x = np.arange(9.0).reshape(3,3)\n; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n; np.atleast_1d(x) is x\nTrue\n\n", "; x = np.arange(9.0).reshape(3,3)\n; np.atleast_1d(x)\narray([[0., 1., 2.],\n       [3., 4., 5.],\n       [6., 7., 8.]])\n; np.atleast_1d(x) is x\nTrue\n", "; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n\n", "; np.atleast_1d(1, [3, 4])\n[array([1]), array([3, 4])]\n"]},
{"library": "numpy", "item_id": "numpy.record.astype", "code": "\nrecord.astype()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.atleast_2d", "code": "\nnumpy.atleast_2d(*arys)[source]\u00b6", "description": "View inputs as arrays with at least two dimensions.\n\nParameters\n\narys1, arys2, \u2026array_likeOne or more array-like sequences.  Non-array inputs are converted\nto arrays.  Arrays that already have two or more dimensions are\npreserved.\n\n\n\nReturns\n\nres, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 2.\nCopies are avoided where possible, and views with two or more\ndimensions are returned.\n\n\n\n\n\nSee also\natleast_1d, atleast_3d\n\nExamples\n&gt;&gt;&gt; np.atleast_2d(3.0)\narray([[3.]])\n\n\n&gt;&gt;&gt; x = np.arange(3.0)\n&gt;&gt;&gt; np.atleast_2d(x)\narray([[0., 1., 2.]])\n&gt;&gt;&gt; np.atleast_2d(x).base is x\nTrue\n\n\n&gt;&gt;&gt; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n\n\n", "parameters": ["Parameters", "arys1, arys2, \u2026array_like", "Returns", "res, res2, \u2026ndarray"], "returns": "res, res2, \u2026ndarrayAn array, or list of arrays, each with a.ndim &gt;= 2.Copies are avoided where possible, and views with two or moredimensions are returned.", "examples": ["; np.atleast_2d(3.0)\narray([[3.]])\n\n", "; np.atleast_2d(3.0)\narray([[3.]])\n", "; x = np.arange(3.0)\n; np.atleast_2d(x)\narray([[0., 1., 2.]])\n; np.atleast_2d(x).base is x\nTrue\n\n", "; x = np.arange(3.0)\n; np.atleast_2d(x)\narray([[0., 1., 2.]])\n; np.atleast_2d(x).base is x\nTrue\n", "; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n\n", "; np.atleast_2d(1, [1, 2], [[1, 2]])\n[array([[1]]), array([[1, 2]]), array([[1, 2]])]\n"]},
{"library": "numpy", "item_id": "numpy.recarray.astype", "code": "\nrecarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.astype", "code": "\nndarray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.astype", "code": "\nMaskType.astype()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.astype", "code": "\nMaskedArray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.astype", "code": "\nmemmap.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.astype", "code": "\nmasked_array.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.lib.user_array.container.astype", "code": "\ncontainer.astype(self, typecode)[source]\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.astype", "code": "\nmatrix.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.generic.astype", "code": "\ngeneric.astype()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.astype", "code": "\nchararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.astype", "code": "\nchararray.astype(dtype, order='K', casting='unsafe', subok=True, copy=True)\u00b6", "description": "Copy of the array, cast to a specified type.\n\nParameters\n\ndtypestr or dtypeTypecode or data-type to which the array is cast.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optionalControls the memory layout order of the result.\n\u2018C\u2019 means C order, \u2018F\u2019 means Fortran order, \u2018A\u2019\nmeans \u2018F\u2019 order if all the arrays are Fortran contiguous,\n\u2018C\u2019 order otherwise, and \u2018K\u2019 means as close to the\norder the array elements appear in memory as possible.\nDefault is \u2018K\u2019.\n\ncasting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optionalControls what kind of data casting may occur. Defaults to \u2018unsafe\u2019\nfor backwards compatibility.\n\n\n\u2018no\u2019 means the data types should not be cast at all.\n\u2018equiv\u2019 means only byte-order changes are allowed.\n\u2018safe\u2019 means only casts which can preserve values are allowed.\n\u2018same_kind\u2019 means only safe casts or casts within a kind,\nlike float64 to float32, are allowed.\n\u2018unsafe\u2019 means any data conversions may be done.\n\n\n\nsubokbool, optionalIf True, then sub-classes will be passed-through (default), otherwise\nthe returned array will be forced to be a base-class array.\n\ncopybool, optionalBy default, astype always returns a newly allocated array. If this\nis set to false, and the dtype, order, and subok\nrequirements are satisfied, the input array is returned instead\nof a copy.\n\n\n\nReturns\n\narr_tndarrayUnless copy is False and the other conditions for returning the input\narray are satisfied (see description for copy input parameter), arr_t\nis a new array of the same shape as the input array, with dtype, order\ngiven by dtype, order.\n\n\n\nRaises\n\nComplexWarningWhen casting from complex to float or int. To avoid this,\none should use a.real.astype(t).\n\n\n\n\nNotes\n\nChanged in version 1.17.0: Casting between a simple data type and a structured one is possible only\nfor \u201cunsafe\u201d casting.  Casting to multiple fields is allowed, but\ncasting from multiple fields is not.\n\n\nChanged in version 1.9.0: Casting from numeric to string types in \u2018safe\u2019 casting mode requires\nthat the string dtype length is long enough to store the max\ninteger/float value converted.\n\nExamples\n&gt;&gt;&gt; x = np.array([1, 2, 2.5])\n&gt;&gt;&gt; x\narray([1. ,  2. ,  2.5])\n\n\n&gt;&gt;&gt; x.astype(int)\narray([1, 2, 2])\n\n\n", "parameters": ["Parameters", "dtypestr or dtype", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019, \u2018K\u2019}, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "subokbool, optional", "copybool, optional", "Returns", "arr_tndarray", "Raises", "ComplexWarning"], "returns": "arr_tndarrayUnless copy is False and the other conditions for returning the inputarray are satisfied (see description for copy input parameter), arr_tis a new array of the same shape as the input array, with dtype, ordergiven by dtype, order.", "examples": ["; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n\n", "; x = np.array([1, 2, 2.5])\n; x\narray([1. ,  2. ,  2.5])\n", "; x.astype(int)\narray([1, 2, 2])\n\n", "; x.astype(int)\narray([1, 2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_warns", "code": "\nnumpy.testing.assert_warns(warning_class, *args, **kwargs)[source]\u00b6", "description": "Fail unless the given callable throws the specified warning.\nA warning of class warning_class should be thrown by the callable when\ninvoked with arguments args and keyword arguments kwargs.\nIf a different type of warning is thrown, it will not be caught.\nIf called with all arguments other than the warning class omitted, may be\nused as a context manager:\n\n\nwith assert_warns(SomeWarning):do_something()\n\n\n\nThe ability to be used as a context manager is new in NumPy v1.11.0.\n\nNew in version 1.4.0.\n\n\nParameters\n\nwarning_classclassThe class defining the warning that func is expected to throw.\n\nfunccallableThe callable to test.\n\n*argsArgumentsArguments passed to func.\n\n**kwargsKwargsKeyword arguments passed to func.\n\n\n\nReturns\n\nThe value returned by `func`.\n\n\n\n", "parameters": ["Parameters", "warning_classclass", "funccallable", "*argsArguments", "**kwargsKwargs", "Returns", "The value returned by `func`."], "returns": "The value returned by `func`.", "examples": []},
{"library": "numpy", "item_id": "numpy.testing.assert_string_equal", "code": "\nnumpy.testing.assert_string_equal(actual, desired)[source]\u00b6", "description": "Test if two strings are equal.\nIf the given strings are equal, assert_string_equal does nothing.\nIf they are not equal, an AssertionError is raised, and the diff\nbetween the strings is shown.\n\nParameters\n\nactualstrThe string to test for equality against the expected string.\n\ndesiredstrThe expected string.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.testing.assert_string_equal('abc', 'abc')\n&gt;&gt;&gt; np.testing.assert_string_equal('abc', 'abcd')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n...\nAssertionError: Differences in strings:\n- abc+ abcd?    +\n\n\n", "parameters": ["Parameters", "actualstr", "desiredstr"], "returns": [], "examples": ["; np.testing.assert_string_equal('abc', 'abc')\n; np.testing.assert_string_equal('abc', 'abcd')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n...\nAssertionError: Differences in strings:\n- abc+ abcd?    +\n\n", "; np.testing.assert_string_equal('abc', 'abc')\n; np.testing.assert_string_equal('abc', 'abcd')\nTraceback (most recent call last):\n  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\n...\nAssertionError: Differences in strings:\n- abc+ abcd?    +\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_raises_regex", "code": "\nnumpy.testing.assert_raises_regex(exception_class, expected_regexp, callable, *args, **kwargs) assert_raises_regex(exception_class, expected_regexp)[source]\u00b6", "description": "Fail unless an exception of class exception_class and with message that\nmatches expected_regexp is thrown by callable when invoked with arguments\nargs and keyword arguments kwargs.\nAlternatively, can be used as a context manager like assert_raises.\nName of this function adheres to Python 3.2+ reference, but should work in\nall versions down to 2.6.\nNotes\n\nNew in version 1.9.0.\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.assert_raises", "code": "\nnumpy.testing.assert_raises(exception_class, callable, *args, **kwargs) assert_raises(exception_class)[source]\u00b6", "description": "Fail unless an exception of class exception_class is thrown\nby callable when invoked with arguments args and keyword\narguments kwargs. If a different type of exception is\nthrown, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an\nunexpected exception.\nAlternatively, assert_raises can be used as a context manager:\n&gt;&gt;&gt; from numpy.testing import assert_raises\n&gt;&gt;&gt; with assert_raises(ZeroDivisionError):\n...     1 / 0\n\n\nis equivalent to\n&gt;&gt;&gt; def div(x, y):\n...     return x / y\n&gt;&gt;&gt; assert_raises(ZeroDivisionError, div, 1, 0)\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.assert_equal", "code": "\nnumpy.testing.assert_equal(actual, desired, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two objects are not equal.\nGiven two objects (scalars, lists, tuples, dictionaries or numpy arrays),\ncheck that all elements of these objects are equal. An exception is raised\nat the first conflicting values.\nWhen one of actual and desired is a scalar and the other is array_like,\nthe function checks that each element of the array_like object is equal to\nthe scalar.\nThis function handles NaN comparisons as if NaN was a \u201cnormal\u201d number.\nThat is, no assertion is raised if both objects have NaNs in the same\npositions.  This is in contrast to the IEEE standard on NaNs, which says\nthat NaN compared to anything must return False.\n\nParameters\n\nactualarray_likeThe object to check.\n\ndesiredarray_likeThe expected object.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired are not equal.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.testing.assert_equal([4,5], [4,6])\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal:\nitem=1\n ACTUAL: 5\n DESIRED: 6\n\n\nThe following comparison does not raise an exception.  There are NaNs\nin the inputs, but they are in the same positions.\n&gt;&gt;&gt; np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan])\n\n\n", "parameters": ["Parameters", "actualarray_like", "desiredarray_like", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; np.testing.assert_equal([4,5], [4,6])\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal:\nitem=1\n ACTUAL: 5\n DESIRED: 6\n\n", "; np.testing.assert_equal([4,5], [4,6])\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal:\nitem=1\n ACTUAL: 5\n DESIRED: 6\n", "; np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan])\n\n", "; np.testing.assert_equal(np.array([1.0, 2.0, np.nan]), [1, 2, np.nan])\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_array_max_ulp", "code": "\nnumpy.testing.assert_array_max_ulp(a, b, maxulp=1, dtype=None)[source]\u00b6", "description": "Check that all items of arrays differ in at most N Units in the Last Place.\n\nParameters\n\na, barray_likeInput arrays to be compared.\n\nmaxulpint, optionalThe maximum number of units in the last place that elements of a and\nb can differ. Default is 1.\n\ndtypedtype, optionalData-type to convert a and b to if given. Default is None.\n\n\n\nReturns\n\nretndarrayArray containing number of representable floating point numbers between\nitems in a and b.\n\n\n\nRaises\n\nAssertionErrorIf one or more elements differ by more than maxulp.\n\n\n\n\n\nSee also\n\nassert_array_almost_equal_nulpCompare two arrays relatively to their spacing.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.linspace(0., 1., 100)\n&gt;&gt;&gt; res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))\n\n\n", "parameters": ["Parameters", "a, barray_like", "maxulpint, optional", "dtypedtype, optional", "Returns", "retndarray", "Raises", "AssertionError"], "returns": "retndarrayArray containing number of representable floating point numbers betweenitems in a and b.", "examples": ["; a = np.linspace(0., 1., 100)\n; res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))\n\n", "; a = np.linspace(0., 1., 100)\n; res = np.testing.assert_array_max_ulp(a, np.arcsin(np.sin(a)))\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_array_less", "code": "\nnumpy.testing.assert_array_less(x, y, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two array_like objects are not ordered by less\nthan.\nGiven two array_like objects, check that the shape is equal and all\nelements of the first object are strictly smaller than those of the\nsecond object. An exception is raised at shape mismatch or incorrectly\nordered values. Shape mismatch does not raise if an object has zero\ndimension. In contrast to the standard usage in numpy, NaNs are\ncompared, no assertion is raised if both objects have NaNs in the same\npositions.\n\nParameters\n\nxarray_likeThe smaller object to check.\n\nyarray_likeThe larger object to compare.\n\nerr_msgstringThe error message to be printed in case of failure.\n\nverboseboolIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired objects are not equal.\n\n\n\n\n\nSee also\n\nassert_array_equaltests objects for equality\n\nassert_array_almost_equaltest objects for equality up to precision\n\n\n\nExamples\n&gt;&gt;&gt; np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n&gt;&gt;&gt; np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 33.3%\nMax absolute difference: 1.\nMax relative difference: 0.5\n x: array([ 1.,  1., nan])\n y: array([ 1.,  2., nan])\n\n\n&gt;&gt;&gt; np.testing.assert_array_less([1.0, 4.0], 3)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 50%\nMax absolute difference: 2.\nMax relative difference: 0.66666667\n x: array([1., 4.])\n y: array(3)\n\n\n&gt;&gt;&gt; np.testing.assert_array_less([1.0, 2.0, 3.0], [4])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\n(shapes (3,), (1,) mismatch)\n x: array([1., 2., 3.])\n y: array([4])\n\n\n", "parameters": ["Parameters", "xarray_like", "yarray_like", "err_msgstring", "verbosebool", "Raises", "AssertionError"], "returns": [], "examples": ["; np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n; np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 33.3%\nMax absolute difference: 1.\nMax relative difference: 0.5\n x: array([ 1.,  1., nan])\n y: array([ 1.,  2., nan])\n\n", "; np.testing.assert_array_less([1.0, 1.0, np.nan], [1.1, 2.0, np.nan])\n; np.testing.assert_array_less([1.0, 1.0, np.nan], [1, 2.0, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 33.3%\nMax absolute difference: 1.\nMax relative difference: 0.5\n x: array([ 1.,  1., nan])\n y: array([ 1.,  2., nan])\n", "; np.testing.assert_array_less([1.0, 4.0], 3)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 50%\nMax absolute difference: 2.\nMax relative difference: 0.66666667\n x: array([1., 4.])\n y: array(3)\n\n", "; np.testing.assert_array_less([1.0, 4.0], 3)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\nMismatch: 50%\nMax absolute difference: 2.\nMax relative difference: 0.66666667\n x: array([1., 4.])\n y: array(3)\n", "; np.testing.assert_array_less([1.0, 2.0, 3.0], [4])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\n(shapes (3,), (1,) mismatch)\n x: array([1., 2., 3.])\n y: array([4])\n\n", "; np.testing.assert_array_less([1.0, 2.0, 3.0], [4])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not less-ordered\n(shapes (3,), (1,) mismatch)\n x: array([1., 2., 3.])\n y: array([4])\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_array_equal", "code": "\nnumpy.testing.assert_array_equal(x, y, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two array_like objects are not equal.\nGiven two array_like objects, check that the shape is equal and all\nelements of these objects are equal (but see the Notes for the special\nhandling of a scalar). An exception is raised at shape mismatch or\nconflicting values. In contrast to the standard usage in numpy, NaNs\nare compared like numbers, no assertion is raised if both objects have\nNaNs in the same positions.\nThe usual caution for verifying equality with floating point numbers is\nadvised.\n\nParameters\n\nxarray_likeThe actual object to check.\n\nyarray_likeThe desired, expected object.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired objects are not equal.\n\n\n\n\n\nSee also\n\nassert_allcloseCompare two array_like objects for equality with desired relative and/or absolute precision.\n\n\nassert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\nNotes\nWhen one of x and y is a scalar and the other is array_like, the\nfunction checks that each element of the array_like object is equal to\nthe scalar.\nExamples\nThe first assert does not raise an exception:\n&gt;&gt;&gt; np.testing.assert_array_equal([1.0,2.33333,np.nan],\n...                               [np.exp(0),2.33333, np.nan])\n\n\nAssert fails with numerical imprecision with floats:\n&gt;&gt;&gt; np.testing.assert_array_equal([1.0,np.pi,np.nan],\n...                               [1, np.sqrt(np.pi)**2, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not equal\nMismatch: 33.3%\nMax absolute difference: 4.4408921e-16\nMax relative difference: 1.41357986e-16\n x: array([1.      , 3.141593,      nan])\n y: array([1.      , 3.141593,      nan])\n\n\nUse assert_allclose or one of the nulp (number of floating point values)\nfunctions for these cases instead:\n&gt;&gt;&gt; np.testing.assert_allclose([1.0,np.pi,np.nan],\n...                            [1, np.sqrt(np.pi)**2, np.nan],\n...                            rtol=1e-10, atol=0)\n\n\nAs mentioned in the Notes section, assert_array_equal has special\nhandling for scalars. Here the test checks that each value in x is 3:\n&gt;&gt;&gt; x = np.full((2, 5), fill_value=3)\n&gt;&gt;&gt; np.testing.assert_array_equal(x, 3)\n\n\n", "parameters": ["Parameters", "xarray_like", "yarray_like", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; np.testing.assert_array_equal([1.0,2.33333,np.nan],\n...                               [np.exp(0),2.33333, np.nan])\n\n", "; np.testing.assert_array_equal([1.0,2.33333,np.nan],\n...                               [np.exp(0),2.33333, np.nan])\n", "; np.testing.assert_array_equal([1.0,np.pi,np.nan],\n...                               [1, np.sqrt(np.pi)**2, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not equal\nMismatch: 33.3%\nMax absolute difference: 4.4408921e-16\nMax relative difference: 1.41357986e-16\n x: array([1.      , 3.141593,      nan])\n y: array([1.      , 3.141593,      nan])\n\n", "; np.testing.assert_array_equal([1.0,np.pi,np.nan],\n...                               [1, np.sqrt(np.pi)**2, np.nan])\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not equal\nMismatch: 33.3%\nMax absolute difference: 4.4408921e-16\nMax relative difference: 1.41357986e-16\n x: array([1.      , 3.141593,      nan])\n y: array([1.      , 3.141593,      nan])\n", "; np.testing.assert_allclose([1.0,np.pi,np.nan],\n...                            [1, np.sqrt(np.pi)**2, np.nan],\n...                            rtol=1e-10, atol=0)\n\n", "; np.testing.assert_allclose([1.0,np.pi,np.nan],\n...                            [1, np.sqrt(np.pi)**2, np.nan],\n...                            rtol=1e-10, atol=0)\n", "; x = np.full((2, 5), fill_value=3)\n; np.testing.assert_array_equal(x, 3)\n\n", "; x = np.full((2, 5), fill_value=3)\n; np.testing.assert_array_equal(x, 3)\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_array_almost_equal_nulp", "code": "\nnumpy.testing.assert_array_almost_equal_nulp(x, y, nulp=1)[source]\u00b6", "description": "Compare two arrays relatively to their spacing.\nThis is a relatively robust method to compare two arrays whose amplitude\nis variable.\n\nParameters\n\nx, yarray_likeInput arrays.\n\nnulpint, optionalThe maximum number of unit in the last place for tolerance (see Notes).\nDefault is 1.\n\n\n\nReturns\n\nNone\n\n\nRaises\n\nAssertionErrorIf the spacing between x and y for one or more elements is larger\nthan nulp.\n\n\n\n\n\nSee also\n\nassert_array_max_ulpCheck that all items of arrays differ in at most N Units in the Last Place.\n\nspacingReturn the distance between x and the nearest adjacent number.\n\n\n\nNotes\nAn assertion is raised if the following condition is not met:\nabs(x - y) &lt;= nulps * spacing(maximum(abs(x), abs(y)))\n\n\nExamples\n&gt;&gt;&gt; x = np.array([1., 1e-10, 1e-20])\n&gt;&gt;&gt; eps = np.finfo(x.dtype).eps\n&gt;&gt;&gt; np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x)\n\n\n&gt;&gt;&gt; np.testing.assert_array_almost_equal_nulp(x, x*eps + x)\nTraceback (most recent call last):\n  ...\nAssertionError: X and Y are not equal to 1 ULP (max is 2)\n\n\n", "parameters": ["Parameters", "x, yarray_like", "nulpint, optional", "Returns", "None", "Raises", "AssertionError"], "returns": "None", "examples": ["; x = np.array([1., 1e-10, 1e-20])\n; eps = np.finfo(x.dtype).eps\n; np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x)\n\n", "; x = np.array([1., 1e-10, 1e-20])\n; eps = np.finfo(x.dtype).eps\n; np.testing.assert_array_almost_equal_nulp(x, x*eps/2 + x)\n", "; np.testing.assert_array_almost_equal_nulp(x, x*eps + x)\nTraceback (most recent call last):\n  ...\nAssertionError: X and Y are not equal to 1 ULP (max is 2)\n\n", "; np.testing.assert_array_almost_equal_nulp(x, x*eps + x)\nTraceback (most recent call last):\n  ...\nAssertionError: X and Y are not equal to 1 ULP (max is 2)\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_array_almost_equal", "code": "\nnumpy.testing.assert_array_almost_equal(x, y, decimal=6, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two objects are not equal up to desired\nprecision.\n\nNote\nIt is recommended to use one of assert_allclose,\nassert_array_almost_equal_nulp or assert_array_max_ulp\ninstead of this function for more consistent floating point\ncomparisons.\n\nThe test verifies identical shapes and that the elements of actual and\ndesired satisfy.\n\nabs(desired-actual) &lt; 1.5 * 10**(-decimal)\n\nThat is a looser test than originally documented, but agrees with what the\nactual implementation did up to rounding vagaries. An exception is raised\nat shape mismatch or conflicting values. In contrast to the standard usage\nin numpy, NaNs are compared like numbers, no assertion is raised if both\nobjects have NaNs in the same positions.\n\nParameters\n\nxarray_likeThe actual object to check.\n\nyarray_likeThe desired, expected object.\n\ndecimalint, optionalDesired precision, default is 6.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired are not equal up to specified precision.\n\n\n\n\n\nSee also\n\nassert_allcloseCompare two array_like objects for equality with desired relative and/or absolute precision.\n\n\nassert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\nExamples\nthe first assert does not raise an exception\n&gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n...                                      [1.0,2.333,np.nan])\n\n\n&gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33339,np.nan], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nMismatch: 33.3%\nMax absolute difference: 6.e-05\nMax relative difference: 2.57136612e-05\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33339,     nan])\n\n\n&gt;&gt;&gt; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33333, 5], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nx and y nan location mismatch:\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33333, 5.     ])\n\n\n", "parameters": ["Parameters", "xarray_like", "yarray_like", "decimalint, optional", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n...                                      [1.0,2.333,np.nan])\n\n", "; np.testing.assert_array_almost_equal([1.0,2.333,np.nan],\n...                                      [1.0,2.333,np.nan])\n", "; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33339,np.nan], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nMismatch: 33.3%\nMax absolute difference: 6.e-05\nMax relative difference: 2.57136612e-05\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33339,     nan])\n\n", "; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33339,np.nan], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nMismatch: 33.3%\nMax absolute difference: 6.e-05\nMax relative difference: 2.57136612e-05\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33339,     nan])\n", "; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33333, 5], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nx and y nan location mismatch:\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33333, 5.     ])\n\n", "; np.testing.assert_array_almost_equal([1.0,2.33333,np.nan],\n...                                      [1.0,2.33333, 5], decimal=5)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 5 decimals\nx and y nan location mismatch:\n x: array([1.     , 2.33333,     nan])\n y: array([1.     , 2.33333, 5.     ])\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_approx_equal", "code": "\nnumpy.testing.assert_approx_equal(actual, desired, significant=7, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two items are not equal up to significant\ndigits.\n\nNote\nIt is recommended to use one of assert_allclose,\nassert_array_almost_equal_nulp or assert_array_max_ulp\ninstead of this function for more consistent floating point\ncomparisons.\n\nGiven two numbers, check that they are approximately equal.\nApproximately equal is defined as the number of significant digits\nthat agree.\n\nParameters\n\nactualscalarThe object to check.\n\ndesiredscalarThe expected object.\n\nsignificantint, optionalDesired precision, default is 7.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired are not equal up to specified precision.\n\n\n\n\n\nSee also\n\nassert_allcloseCompare two array_like objects for equality with desired relative and/or absolute precision.\n\n\nassert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\nExamples\n&gt;&gt;&gt; np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n&gt;&gt;&gt; np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n...                                significant=8)\n&gt;&gt;&gt; np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n...                                significant=8)\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal to 8 significant digits:\n ACTUAL: 1.234567e-21\n DESIRED: 1.2345672e-21\n\n\nthe evaluated condition that raises the exception is\n&gt;&gt;&gt; abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) &gt;= 10**-(8-1)\nTrue\n\n\n", "parameters": ["Parameters", "actualscalar", "desiredscalar", "significantint, optional", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n; np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n...                                significant=8)\n; np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n...                                significant=8)\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal to 8 significant digits:\n ACTUAL: 1.234567e-21\n DESIRED: 1.2345672e-21\n\n", "; np.testing.assert_approx_equal(0.12345677777777e-20, 0.1234567e-20)\n; np.testing.assert_approx_equal(0.12345670e-20, 0.12345671e-20,\n...                                significant=8)\n; np.testing.assert_approx_equal(0.12345670e-20, 0.12345672e-20,\n...                                significant=8)\nTraceback (most recent call last):\n    ...\nAssertionError:\nItems are not equal to 8 significant digits:\n ACTUAL: 1.234567e-21\n DESIRED: 1.2345672e-21\n", "; abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) &gt;= 10**-(8-1)\nTrue\n\n", "; abs(0.12345670e-20/1e-21 - 0.12345672e-20/1e-21) &gt;= 10**-(8-1)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_almost_equal", "code": "\nnumpy.testing.assert_almost_equal(actual, desired, decimal=7, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two items are not equal up to desired\nprecision.\n\nNote\nIt is recommended to use one of assert_allclose,\nassert_array_almost_equal_nulp or assert_array_max_ulp\ninstead of this function for more consistent floating point\ncomparisons.\n\nThe test verifies that the elements of actual and desired satisfy.\n\nabs(desired-actual) &lt; 1.5 * 10**(-decimal)\n\nThat is a looser test than originally documented, but agrees with what the\nactual implementation in assert_array_almost_equal did up to rounding\nvagaries. An exception is raised at conflicting values. For ndarrays this\ndelegates to assert_array_almost_equal\n\nParameters\n\nactualarray_likeThe object to check.\n\ndesiredarray_likeThe expected object.\n\ndecimalint, optionalDesired precision, default is 7.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired are not equal up to specified precision.\n\n\n\n\n\nSee also\n\nassert_allcloseCompare two array_like objects for equality with desired relative and/or absolute precision.\n\n\nassert_array_almost_equal_nulp, assert_array_max_ulp, assert_equal\n\nExamples\n&gt;&gt;&gt; import numpy.testing as npt\n&gt;&gt;&gt; npt.assert_almost_equal(2.3333333333333, 2.33333334)\n&gt;&gt;&gt; npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 10 decimals\n ACTUAL: 2.3333333333333\n DESIRED: 2.33333334\n\n\n&gt;&gt;&gt; npt.assert_almost_equal(np.array([1.0,2.3333333333333]),\n...                         np.array([1.0,2.33333334]), decimal=9)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 9 decimals\nMismatch: 50%\nMax absolute difference: 6.66669964e-09\nMax relative difference: 2.85715698e-09\n x: array([1.         , 2.333333333])\n y: array([1.        , 2.33333334])\n\n\n", "parameters": ["Parameters", "actualarray_like", "desiredarray_like", "decimalint, optional", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; import numpy.testing as npt\n; npt.assert_almost_equal(2.3333333333333, 2.33333334)\n; npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 10 decimals\n ACTUAL: 2.3333333333333\n DESIRED: 2.33333334\n\n", "; import numpy.testing as npt\n; npt.assert_almost_equal(2.3333333333333, 2.33333334)\n; npt.assert_almost_equal(2.3333333333333, 2.33333334, decimal=10)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 10 decimals\n ACTUAL: 2.3333333333333\n DESIRED: 2.33333334\n", "; npt.assert_almost_equal(np.array([1.0,2.3333333333333]),\n...                         np.array([1.0,2.33333334]), decimal=9)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 9 decimals\nMismatch: 50%\nMax absolute difference: 6.66669964e-09\nMax relative difference: 2.85715698e-09\n x: array([1.         , 2.333333333])\n y: array([1.        , 2.33333334])\n\n", "; npt.assert_almost_equal(np.array([1.0,2.3333333333333]),\n...                         np.array([1.0,2.33333334]), decimal=9)\nTraceback (most recent call last):\n    ...\nAssertionError:\nArrays are not almost equal to 9 decimals\nMismatch: 50%\nMax absolute difference: 6.66669964e-09\nMax relative difference: 2.85715698e-09\n x: array([1.         , 2.333333333])\n y: array([1.        , 2.33333334])\n"]},
{"library": "numpy", "item_id": "numpy.testing.assert_allclose", "code": "\nnumpy.testing.assert_allclose(actual, desired, rtol=1e-07, atol=0, equal_nan=True, err_msg='', verbose=True)[source]\u00b6", "description": "Raises an AssertionError if two objects are not equal up to desired\ntolerance.\nThe test is equivalent to allclose(actual, desired, rtol, atol) (note\nthat allclose has different default values). It compares the difference\nbetween actual and desired to atol + rtol * abs(desired).\n\nNew in version 1.5.0.\n\n\nParameters\n\nactualarray_likeArray obtained.\n\ndesiredarray_likeArray desired.\n\nrtolfloat, optionalRelative tolerance.\n\natolfloat, optionalAbsolute tolerance.\n\nequal_nanbool, optional.If True, NaNs will compare equal.\n\nerr_msgstr, optionalThe error message to be printed in case of failure.\n\nverbosebool, optionalIf True, the conflicting values are appended to the error message.\n\n\n\nRaises\n\nAssertionErrorIf actual and desired are not equal up to specified precision.\n\n\n\n\n\nSee also\nassert_array_almost_equal_nulp, assert_array_max_ulp\n\nExamples\n&gt;&gt;&gt; x = [1e-5, 1e-3, 1e-1]\n&gt;&gt;&gt; y = np.arccos(np.cos(x))\n&gt;&gt;&gt; np.testing.assert_allclose(x, y, rtol=1e-5, atol=0)\n\n\n", "parameters": ["Parameters", "actualarray_like", "desiredarray_like", "rtolfloat, optional", "atolfloat, optional", "equal_nanbool, optional.", "err_msgstr, optional", "verbosebool, optional", "Raises", "AssertionError"], "returns": [], "examples": ["; x = [1e-5, 1e-3, 1e-1]\n; y = np.arccos(np.cos(x))\n; np.testing.assert_allclose(x, y, rtol=1e-5, atol=0)\n\n", "; x = [1e-5, 1e-3, 1e-1]\n; y = np.arccos(np.cos(x))\n; np.testing.assert_allclose(x, y, rtol=1e-5, atol=0)\n"]},
{"library": "numpy", "item_id": "numpy.asscalar", "code": "\nnumpy.asscalar(a)[source]\u00b6", "description": "Convert an array of size 1 to its scalar equivalent.\n\nDeprecated since version 1.16: Deprecated, use numpy.ndarray.item() instead.\n\n\nParameters\n\nandarrayInput array of size 1.\n\n\n\nReturns\n\noutscalarScalar representation of a. The output data type is the same type\nreturned by the input\u2019s item method.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.asscalar(np.array([24]))\n24\n\n\n", "parameters": ["Parameters", "andarray", "Returns", "outscalar"], "returns": "outscalarScalar representation of a. The output data type is the same typereturned by the input\u2019s item method.", "examples": ["; np.asscalar(np.array([24]))\n24\n\n", "; np.asscalar(np.array([24]))\n24\n"]},
{"library": "numpy", "item_id": "numpy.asmatrix", "code": "\nnumpy.asmatrix(data, dtype=None)[source]\u00b6", "description": "Interpret the input as a matrix.\nUnlike matrix, asmatrix does not make a copy if the input is already\na matrix or an ndarray.  Equivalent to matrix(data, copy=False).\n\nParameters\n\ndataarray_likeInput data.\n\ndtypedata-typeData-type of the output matrix.\n\n\n\nReturns\n\nmatmatrixdata interpreted as a matrix.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([[1, 2], [3, 4]])\n\n\n&gt;&gt;&gt; m = np.asmatrix(x)\n\n\n&gt;&gt;&gt; x[0,0] = 5\n\n\n&gt;&gt;&gt; m\nmatrix([[5, 2],\n        [3, 4]])\n\n\n", "parameters": ["Parameters", "dataarray_like", "dtypedata-type", "Returns", "matmatrix"], "returns": "matmatrixdata interpreted as a matrix.", "examples": ["; x = np.array([[1, 2], [3, 4]])\n\n", "; x = np.array([[1, 2], [3, 4]])\n", "; m = np.asmatrix(x)\n\n", "; m = np.asmatrix(x)\n", "; x[0,0] = 5\n\n", "; x[0,0] = 5\n", "; m\nmatrix([[5, 2],\n        [3, 4]])\n\n", "; m\nmatrix([[5, 2],\n        [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.asfortranarray", "code": "\nnumpy.asfortranarray(a, dtype=None)[source]\u00b6", "description": "Return an array (ndim &gt;= 1) laid out in Fortran order in memory.\n\nParameters\n\naarray_likeInput array.\n\ndtypestr or dtype object, optionalBy default, the data-type is inferred from the input data.\n\n\n\nReturns\n\noutndarrayThe input a in Fortran, or column-major, order.\n\n\n\n\n\nSee also\n\nascontiguousarrayConvert input to a contiguous (C order) array.\n\nasanyarrayConvert input to an ndarray with either row or column-major memory order.\n\nrequireReturn an ndarray that satisfies requirements.\n\nndarray.flagsInformation about the memory layout of the array.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; y = np.asfortranarray(x)\n&gt;&gt;&gt; x.flags['F_CONTIGUOUS']\nFalse\n&gt;&gt;&gt; y.flags['F_CONTIGUOUS']\nTrue\n\n\nNote: This function returns an array with at least one-dimension (1-d) \nso it will not preserve 0-d arrays.\n", "parameters": ["Parameters", "aarray_like", "dtypestr or dtype object, optional", "Returns", "outndarray"], "returns": "outndarrayThe input a in Fortran, or column-major, order.", "examples": ["; x = np.arange(6).reshape(2,3)\n; y = np.asfortranarray(x)\n; x.flags['F_CONTIGUOUS']\nFalse\n; y.flags['F_CONTIGUOUS']\nTrue\n\n", "; x = np.arange(6).reshape(2,3)\n; y = np.asfortranarray(x)\n; x.flags['F_CONTIGUOUS']\nFalse\n; y.flags['F_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.asfarray", "code": "\nnumpy.asfarray(a, dtype=&lt;class 'numpy.float64'&gt;)[source]\u00b6", "description": "Return an array converted to a float type.\n\nParameters\n\naarray_likeThe input array.\n\ndtypestr or dtype object, optionalFloat type code to coerce input array a.  If dtype is one of the\n\u2018int\u2019 dtypes, it is replaced with float64.\n\n\n\nReturns\n\noutndarrayThe input a as a float ndarray.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.asfarray([2, 3])\narray([2.,  3.])\n&gt;&gt;&gt; np.asfarray([2, 3], dtype='float')\narray([2.,  3.])\n&gt;&gt;&gt; np.asfarray([2, 3], dtype='int8')\narray([2.,  3.])\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypestr or dtype object, optional", "Returns", "outndarray"], "returns": "outndarrayThe input a as a float ndarray.", "examples": ["; np.asfarray([2, 3])\narray([2.,  3.])\n; np.asfarray([2, 3], dtype='float')\narray([2.,  3.])\n; np.asfarray([2, 3], dtype='int8')\narray([2.,  3.])\n\n", "; np.asfarray([2, 3])\narray([2.,  3.])\n; np.asfarray([2, 3], dtype='float')\narray([2.,  3.])\n; np.asfarray([2, 3], dtype='int8')\narray([2.,  3.])\n"]},
{"library": "numpy", "item_id": "numpy.asarray_chkfinite", "code": "\nnumpy.asarray_chkfinite(a, dtype=None, order=None)[source]\u00b6", "description": "Convert the input to an array, checking for NaNs or Infs.\n\nParameters\n\naarray_likeInput data, in any form that can be converted to an array.  This\nincludes lists, lists of tuples, tuples, tuples of tuples, tuples\nof lists and ndarrays.  Success requires no NaNs or Infs.\n\ndtypedata-type, optionalBy default, the data-type is inferred from the input data.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to use row-major (C-style) or\ncolumn-major (Fortran-style) memory representation.\nDefaults to \u2018C\u2019.\n\n\n\nReturns\n\noutndarrayArray interpretation of a.  No copy is performed if the input\nis already an ndarray.  If a is a subclass of ndarray, a base\nclass ndarray is returned.\n\n\n\nRaises\n\nValueErrorRaises ValueError if a contains NaN (Not a Number) or Inf (Infinity).\n\n\n\n\n\nSee also\n\nasarrayCreate and array.\n\nasanyarraySimilar function which passes through subclasses.\n\nascontiguousarrayConvert input to a contiguous array.\n\nasfarrayConvert input to a floating point ndarray.\n\nasfortranarrayConvert input to an ndarray with column-major memory order.\n\nfromiterCreate an array from an iterator.\n\nfromfunctionConstruct an array by executing a function on grid positions.\n\n\n\nExamples\nConvert a list into an array.  If all elements are finite\nasarray_chkfinite is identical to asarray.\n&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n\n\nRaises ValueError if array_like contains Nans or Infs.\n&gt;&gt;&gt; a = [1, 2, np.inf]\n&gt;&gt;&gt; try:\n...     np.asarray_chkfinite(a)\n... except ValueError:\n...     print('ValueError')\n...\nValueError\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outndarray", "Raises", "ValueError"], "returns": "outndarrayArray interpretation of a.  No copy is performed if the inputis already an ndarray.  If a is a subclass of ndarray, a baseclass ndarray is returned.", "examples": ["; a = [1, 2]\n; np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n\n", "; a = [1, 2]\n; np.asarray_chkfinite(a, dtype=float)\narray([1., 2.])\n", "; a = [1, 2, np.inf]\n; try:\n...     np.asarray_chkfinite(a)\n... except ValueError:\n...     print('ValueError')\n...\nValueError\n\n", "; a = [1, 2, np.inf]\n; try:\n...     np.asarray_chkfinite(a)\n... except ValueError:\n...     print('ValueError')\n...\nValueError\n"]},
{"library": "numpy", "item_id": "numpy.ma.asarray", "code": "\nnumpy.ma.asarray(a, dtype=None, order=None)[source]\u00b6", "description": "Convert the input to a masked array of the given data-type.\nNo copy is performed if the input is already an ndarray. If a is\na subclass of MaskedArray, a base class MaskedArray is returned.\n\nParameters\n\naarray_likeInput data, in any form that can be converted to a masked array. This\nincludes lists, lists of tuples, tuples, tuples of tuples, tuples\nof lists, ndarrays and masked arrays.\n\ndtypedtype, optionalBy default, the data-type is inferred from the input data.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to use row-major (\u2018C\u2019) or column-major (\u2018FORTRAN\u2019) memory\nrepresentation.  Default is \u2018C\u2019.\n\n\n\nReturns\n\noutMaskedArrayMasked array interpretation of a.\n\n\n\n\n\nSee also\n\nasanyarraySimilar to asarray, but conserves subclasses.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)\n&gt;&gt;&gt; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n&gt;&gt;&gt; np.ma.asarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; type(np.ma.asarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedtype, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outMaskedArray"], "returns": "outMaskedArrayMasked array interpretation of a.", "examples": ["; x = np.arange(10.).reshape(2, 5)\n; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n; np.ma.asarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n; type(np.ma.asarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n\n", "; x = np.arange(10.).reshape(2, 5)\n; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n; np.ma.asarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n; type(np.ma.asarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.core.defchararray.asarray", "code": "\nnumpy.core.defchararray.asarray(obj, itemsize=None, unicode=None, order=None)[source]\u00b6", "description": "Convert the input to a chararray, copying the data only if\nnecessary.\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. str.endswith) and infix operators (e.g. +, *,``%``)\n\n\n\nParameters\n\nobjarray of str or unicode-like\nitemsizeint, optionalitemsize is the number of characters per scalar in the\nresulting array.  If itemsize is None, and obj is an\nobject array or a Python list, the itemsize will be\nautomatically determined.  If itemsize is provided and obj\nis of type str or unicode, then the obj string will be\nchunked into itemsize pieces.\n\nunicodebool, optionalWhen true, the resulting chararray can contain Unicode\ncharacters, when false only 8-bit characters.  If unicode is\nNone and obj is one of the following:\n\n\na chararray,\nan ndarray of type str or \u2018unicode`\na Python str or unicode object,\n\n\nthen the unicode setting of the output array will be\nautomatically determined.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalSpecify the order of the array.  If order is \u2018C\u2019 (default), then the\narray will be in C-contiguous order (last-index varies the\nfastest).  If order is \u2018F\u2019, then the returned array\nwill be in Fortran-contiguous order (first-index varies the\nfastest).\n\n\n\n\n", "parameters": ["Parameters", "objarray of str or unicode-like", "itemsizeint, optional", "unicodebool, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ascontiguousarray", "code": "\nnumpy.ascontiguousarray(a, dtype=None)[source]\u00b6", "description": "Return a contiguous array (ndim &gt;= 1) in memory (C order).\n\nParameters\n\naarray_likeInput array.\n\ndtypestr or dtype object, optionalData-type of returned array.\n\n\n\nReturns\n\noutndarrayContiguous array of same shape and content as a, with type dtype\nif specified.\n\n\n\n\n\nSee also\n\nasfortranarrayConvert input to an ndarray with column-major memory order.\n\nrequireReturn an ndarray that satisfies requirements.\n\nndarray.flagsInformation about the memory layout of the array.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; np.ascontiguousarray(x, dtype=np.float32)\narray([[0., 1., 2.],\n       [3., 4., 5.]], dtype=float32)\n&gt;&gt;&gt; x.flags['C_CONTIGUOUS']\nTrue\n\n\nNote: This function returns an array with at least one-dimension (1-d) \nso it will not preserve 0-d arrays.\n", "parameters": ["Parameters", "aarray_like", "dtypestr or dtype object, optional", "Returns", "outndarray"], "returns": "outndarrayContiguous array of same shape and content as a, with type dtypeif specified.", "examples": ["; x = np.arange(6).reshape(2,3)\n; np.ascontiguousarray(x, dtype=np.float32)\narray([[0., 1., 2.],\n       [3., 4., 5.]], dtype=float32)\n; x.flags['C_CONTIGUOUS']\nTrue\n\n", "; x = np.arange(6).reshape(2,3)\n; np.ascontiguousarray(x, dtype=np.float32)\narray([[0., 1., 2.],\n       [3., 4., 5.]], dtype=float32)\n; x.flags['C_CONTIGUOUS']\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.char.asarray", "code": "\nnumpy.char.asarray(obj, itemsize=None, unicode=None, order=None)\u00b6", "description": "Convert the input to a chararray, copying the data only if\nnecessary.\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. str.endswith) and infix operators (e.g. +, *,``%``)\n\n\n\nParameters\n\nobjarray of str or unicode-like\nitemsizeint, optionalitemsize is the number of characters per scalar in the\nresulting array.  If itemsize is None, and obj is an\nobject array or a Python list, the itemsize will be\nautomatically determined.  If itemsize is provided and obj\nis of type str or unicode, then the obj string will be\nchunked into itemsize pieces.\n\nunicodebool, optionalWhen true, the resulting chararray can contain Unicode\ncharacters, when false only 8-bit characters.  If unicode is\nNone and obj is one of the following:\n\n\na chararray,\nan ndarray of type str or \u2018unicode`\na Python str or unicode object,\n\n\nthen the unicode setting of the output array will be\nautomatically determined.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalSpecify the order of the array.  If order is \u2018C\u2019 (default), then the\narray will be in C-contiguous order (last-index varies the\nfastest).  If order is \u2018F\u2019, then the returned array\nwill be in Fortran-contiguous order (first-index varies the\nfastest).\n\n\n\n\n", "parameters": ["Parameters", "objarray of str or unicode-like", "itemsizeint, optional", "unicodebool, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.asanyarray", "code": "\nnumpy.ma.asanyarray(a, dtype=None)[source]\u00b6", "description": "Convert the input to a masked array, conserving subclasses.\nIf a is a subclass of MaskedArray, its class is conserved.\nNo copy is performed if the input is already an ndarray.\n\nParameters\n\naarray_likeInput data, in any form that can be converted to an array.\n\ndtypedtype, optionalBy default, the data-type is inferred from the input data.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to use row-major (\u2018C\u2019) or column-major (\u2018FORTRAN\u2019) memory\nrepresentation.  Default is \u2018C\u2019.\n\n\n\nReturns\n\noutMaskedArrayMaskedArray interpretation of a.\n\n\n\n\n\nSee also\n\nasarraySimilar to asanyarray, but does not conserve subclass.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)\n&gt;&gt;&gt; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n&gt;&gt;&gt; np.ma.asanyarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n&gt;&gt;&gt; type(np.ma.asanyarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedtype, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outMaskedArray"], "returns": "outMaskedArrayMaskedArray interpretation of a.", "examples": ["; x = np.arange(10.).reshape(2, 5)\n; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n; np.ma.asanyarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n; type(np.ma.asanyarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n\n", "; x = np.arange(10.).reshape(2, 5)\n; x\narray([[0., 1., 2., 3., 4.],\n       [5., 6., 7., 8., 9.]])\n; np.ma.asanyarray(x)\nmasked_array(\n  data=[[0., 1., 2., 3., 4.],\n        [5., 6., 7., 8., 9.]],\n  mask=False,\n  fill_value=1e+20)\n; type(np.ma.asanyarray(x))\n&lt;class 'numpy.ma.core.MaskedArray'&gt;\n"]},
{"library": "numpy", "item_id": "numpy.asanyarray", "code": "\nnumpy.asanyarray(a, dtype=None, order=None)[source]\u00b6", "description": "Convert the input to an ndarray, but pass ndarray subclasses through.\n\nParameters\n\naarray_likeInput data, in any form that can be converted to an array.  This\nincludes scalars, lists, lists of tuples, tuples, tuples of tuples,\ntuples of lists, and ndarrays.\n\ndtypedata-type, optionalBy default, the data-type is inferred from the input data.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to use row-major (C-style) or column-major\n(Fortran-style) memory representation.  Defaults to \u2018C\u2019.\n\n\n\nReturns\n\noutndarray or an ndarray subclassArray interpretation of a.  If a is an ndarray or a subclass\nof ndarray, it is returned as-is and no copy is performed.\n\n\n\n\n\nSee also\n\nasarraySimilar function which always returns ndarrays.\n\nascontiguousarrayConvert input to a contiguous array.\n\nasfarrayConvert input to a floating point ndarray.\n\nasfortranarrayConvert input to an ndarray with column-major memory order.\n\nasarray_chkfiniteSimilar function which checks input for NaNs and Infs.\n\nfromiterCreate an array from an iterator.\n\nfromfunctionConstruct an array by executing a function on grid positions.\n\n\n\nExamples\nConvert a list into an array:\n&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; np.asanyarray(a)\narray([1, 2])\n\n\nInstances of ndarray subclasses are passed through as-is:\n&gt;&gt;&gt; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n&gt;&gt;&gt; np.asanyarray(a) is a\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outndarray or an ndarray subclass"], "returns": "outndarray or an ndarray subclassArray interpretation of a.  If a is an ndarray or a subclassof ndarray, it is returned as-is and no copy is performed.", "examples": ["; a = [1, 2]\n; np.asanyarray(a)\narray([1, 2])\n\n", "; a = [1, 2]\n; np.asanyarray(a)\narray([1, 2])\n", "; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n; np.asanyarray(a) is a\nTrue\n\n", "; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n; np.asanyarray(a) is a\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.asarray", "code": "\nnumpy.asarray(a, dtype=None, order=None)[source]\u00b6", "description": "Convert the input to an array.\n\nParameters\n\naarray_likeInput data, in any form that can be converted to an array.  This\nincludes lists, lists of tuples, tuples, tuples of tuples, tuples\nof lists and ndarrays.\n\ndtypedata-type, optionalBy default, the data-type is inferred from the input data.\n\norder{\u2018C\u2019, \u2018F\u2019}, optionalWhether to use row-major (C-style) or\ncolumn-major (Fortran-style) memory representation.\nDefaults to \u2018C\u2019.\n\n\n\nReturns\n\noutndarrayArray interpretation of a.  No copy is performed if the input\nis already an ndarray with matching dtype and order.  If a is a\nsubclass of ndarray, a base class ndarray is returned.\n\n\n\n\n\nSee also\n\nasanyarraySimilar function which passes through subclasses.\n\nascontiguousarrayConvert input to a contiguous array.\n\nasfarrayConvert input to a floating point ndarray.\n\nasfortranarrayConvert input to an ndarray with column-major memory order.\n\nasarray_chkfiniteSimilar function which checks input for NaNs and Infs.\n\nfromiterCreate an array from an iterator.\n\nfromfunctionConstruct an array by executing a function on grid positions.\n\n\n\nExamples\nConvert a list into an array:\n&gt;&gt;&gt; a = [1, 2]\n&gt;&gt;&gt; np.asarray(a)\narray([1, 2])\n\n\nExisting arrays are not copied:\n&gt;&gt;&gt; a = np.array([1, 2])\n&gt;&gt;&gt; np.asarray(a) is a\nTrue\n\n\nIf dtype is set, array is copied only if dtype does not match:\n&gt;&gt;&gt; a = np.array([1, 2], dtype=np.float32)\n&gt;&gt;&gt; np.asarray(a, dtype=np.float32) is a\nTrue\n&gt;&gt;&gt; np.asarray(a, dtype=np.float64) is a\nFalse\n\n\nContrary to asanyarray, ndarray subclasses are not passed through:\n&gt;&gt;&gt; issubclass(np.recarray, np.ndarray)\nTrue\n&gt;&gt;&gt; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n&gt;&gt;&gt; np.asarray(a) is a\nFalse\n&gt;&gt;&gt; np.asanyarray(a) is a\nTrue\n\n\n", "parameters": ["Parameters", "aarray_like", "dtypedata-type, optional", "order{\u2018C\u2019, \u2018F\u2019}, optional", "Returns", "outndarray"], "returns": "outndarrayArray interpretation of a.  No copy is performed if the inputis already an ndarray with matching dtype and order.  If a is asubclass of ndarray, a base class ndarray is returned.", "examples": ["; a = [1, 2]\n; np.asarray(a)\narray([1, 2])\n\n", "; a = [1, 2]\n; np.asarray(a)\narray([1, 2])\n", "; a = np.array([1, 2])\n; np.asarray(a) is a\nTrue\n\n", "; a = np.array([1, 2])\n; np.asarray(a) is a\nTrue\n", "; a = np.array([1, 2], dtype=np.float32)\n; np.asarray(a, dtype=np.float32) is a\nTrue\n; np.asarray(a, dtype=np.float64) is a\nFalse\n\n", "; a = np.array([1, 2], dtype=np.float32)\n; np.asarray(a, dtype=np.float32) is a\nTrue\n; np.asarray(a, dtype=np.float64) is a\nFalse\n", "; issubclass(np.recarray, np.ndarray)\nTrue\n; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n; np.asarray(a) is a\nFalse\n; np.asanyarray(a) is a\nTrue\n\n", "; issubclass(np.recarray, np.ndarray)\nTrue\n; a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)\n; np.asarray(a) is a\nFalse\n; np.asanyarray(a) is a\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.lib.Arrayterator", "code": "\nclass numpy.lib.Arrayterator(var, buf_size=None)[source]\u00b6", "description": "Buffered iterator for big arrays.\nArrayterator creates a buffered iterator for reading big arrays in small\ncontiguous blocks. The class is useful for objects stored in the\nfile system. It allows iteration over the object without reading\neverything in memory; instead, small blocks are read and iterated over.\nArrayterator can be used with any object that supports multidimensional\nslices. This includes NumPy arrays, but also variables from\nScientific.IO.NetCDF or pynetcdf for example.\n\nParameters\n\nvararray_likeThe object to iterate over.\n\nbuf_sizeint, optionalThe buffer size. If buf_size is supplied, the maximum amount of\ndata that will be read into memory is buf_size elements.\nDefault is None, which will read as many element as possible\ninto memory.\n\n\n\n\n\nSee also\n\nndenumerateMultidimensional array iterator.\n\nflatiterFlat array iterator.\n\nmemmapCreate a memory-map to an array stored in a binary file on disk.\n\n\n\nNotes\nThe algorithm works by first finding a \u201crunning dimension\u201d, along which\nthe blocks will be extracted. Given an array of dimensions\n(d1, d2, ..., dn), e.g. if buf_size is smaller than d1, the\nfirst dimension will be used. If, on the other hand,\nd1 &lt; buf_size &lt; d1*d2 the second dimension will be used, and so on.\nBlocks are extracted along this dimension, and when the last block is\nreturned the process continues from the next dimension, until all\nelements have been read.\nExamples\n&gt;&gt;&gt; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n&gt;&gt;&gt; a_itor = np.lib.Arrayterator(a, 2)\n&gt;&gt;&gt; a_itor.shape\n(3, 4, 5, 6)\n\n\nNow we can iterate over a_itor, and it will return arrays of size\ntwo. Since buf_size was smaller than any dimension, the first\ndimension will be iterated over first:\n&gt;&gt;&gt; for subarr in a_itor:\n...     if not subarr.all():\n...         print(subarr, subarr.shape) \n&gt;&gt;&gt; # [[[[0 1]]]] (1, 1, 1, 2)\n\n\n\nAttributes\n\nvar\nbuf_size\nstart\nstop\nstep\nshapeThe shape of the array to be iterated over.\n\nflatA 1-D flat iterator for Arrayterator objects.\n\n\n\n\n", "parameters": ["Parameters", "vararray_like", "buf_sizeint, optional", "Attributes", "var", "buf_size", "start", "stop", "step", "shape", "flat"], "returns": [], "examples": ["; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n; a_itor = np.lib.Arrayterator(a, 2)\n; a_itor.shape\n(3, 4, 5, 6)\n\n", "; a = np.arange(3 * 4 * 5 * 6).reshape(3, 4, 5, 6)\n; a_itor = np.lib.Arrayterator(a, 2)\n; a_itor.shape\n(3, 4, 5, 6)\n", "; for subarr in a_itor:\n...     if not subarr.all():\n...         print(subarr, subarr.shape) \n; # [[[[0 1]]]] (1, 1, 1, 2)\n\n", "; for subarr in a_itor:\n...     if not subarr.all():\n...         print(subarr, subarr.shape) \n; # [[[[0 1]]]] (1, 1, 1, 2)\n"]},
{"library": "numpy", "item_id": "numpy.lib.stride_tricks.as_strided", "code": "\nnumpy.lib.stride_tricks.as_strided(x, shape=None, strides=None, subok=False, writeable=True)[source]\u00b6", "description": "Create a view into the array with the given shape and strides.\n\nWarning\nThis function has to be used with extreme care, see notes.\n\n\nParameters\n\nxndarrayArray to create a new.\n\nshapesequence of int, optionalThe shape of the new array. Defaults to x.shape.\n\nstridessequence of int, optionalThe strides of the new array. Defaults to x.strides.\n\nsubokbool, optional\nNew in version 1.10.\n\nIf True, subclasses are preserved.\n\nwriteablebool, optional\nNew in version 1.12.\n\nIf set to False, the returned array will always be readonly.\nOtherwise it will be writable if the original array was. It\nis advisable to set this to False if possible (see Notes).\n\n\n\nReturns\n\nviewndarray\n\n\n\n\nSee also\n\nbroadcast_tobroadcast an array to a given shape.\n\nreshapereshape an array.\n\n\n\nNotes\nas_strided creates a view into the array given the exact strides\nand shape. This means it manipulates the internal data structure of\nndarray and, if done incorrectly, the array elements can point to\ninvalid memory and can corrupt results or crash your program.\nIt is advisable to always use the original x.strides when\ncalculating new strides to avoid reliance on a contiguous memory\nlayout.\nFurthermore, arrays created with this function often contain self\noverlapping memory, so that two elements are identical.\nVectorized write operations on such arrays will typically be\nunpredictable. They may even give different results for small, large,\nor transposed arrays.\nSince writing to these arrays has to be tested and done with great\ncare, you may want to use writeable=False to avoid accidental write\noperations.\nFor these reasons it is advisable to avoid as_strided when\npossible.\n", "parameters": ["Parameters", "xndarray", "shapesequence of int, optional", "stridessequence of int, optional", "subokbool, optional", "writeablebool, optional", "Returns", "viewndarray"], "returns": "viewndarray", "examples": []},
{"library": "numpy", "item_id": "numpy.array_str", "code": "\nnumpy.array_str(a, max_line_width=None, precision=None, suppress_small=None)[source]\u00b6", "description": "Return a string representation of the data in an array.\nThe data in the array is returned as a single string.  This function is\nsimilar to array_repr, the difference being that array_repr also\nreturns information on the kind of array and its data type.\n\nParameters\n\nandarrayInput array.\n\nmax_line_widthint, optionalInserts newlines if text is longer than max_line_width.\nDefaults to numpy.get_printoptions()['linewidth'].\n\nprecisionint, optionalFloating point precision.\nDefaults to numpy.get_printoptions()['precision'].\n\nsuppress_smallbool, optionalRepresent numbers \u201cvery close\u201d to zero as zero; default is False.\nVery close is defined by precision: if the precision is 8, e.g.,\nnumbers smaller (in absolute value) than 5e-9 are represented as\nzero.\nDefaults to numpy.get_printoptions()['suppress'].\n\n\n\n\n\nSee also\narray2string, array_repr, set_printoptions\n\nExamples\n&gt;&gt;&gt; np.array_str(np.arange(3))\n'[0 1 2]'\n\n\n", "parameters": ["Parameters", "andarray", "max_line_widthint, optional", "precisionint, optional", "suppress_smallbool, optional"], "returns": [], "examples": ["; np.array_str(np.arange(3))\n'[0 1 2]'\n\n", "; np.array_str(np.arange(3))\n'[0 1 2]'\n"]},
{"library": "numpy", "item_id": "numpy.polynomial.polyutils.as_series", "code": "\nnumpy.polynomial.polyutils.as_series(alist, trim=True)[source]\u00b6", "description": "Return argument as a list of 1-d arrays.\nThe returned list contains array(s) of dtype double, complex double, or\nobject.  A 1-d argument of shape (N,) is parsed into N arrays of\nsize one; a 2-d argument of shape (M,N) is parsed into M arrays\nof size N (i.e., is \u201cparsed by row\u201d); and a higher dimensional array\nraises a Value Error if it is not first reshaped into either a 1-d or 2-d\narray.\n\nParameters\n\nalistarray_likeA 1- or 2-d array_like\n\ntrimboolean, optionalWhen True, trailing zeros are removed from the inputs.\nWhen False, the inputs are passed through intact.\n\n\n\nReturns\n\n[a1, a2,\u2026]list of 1-D arraysA copy of the input data as a list of 1-d arrays.\n\n\n\nRaises\n\nValueErrorRaised when as_series cannot convert its input to 1-d arrays, or at\nleast one of the resulting arrays is empty.\n\n\n\n\nExamples\n&gt;&gt;&gt; from numpy.polynomial import polyutils as pu\n&gt;&gt;&gt; a = np.arange(4)\n&gt;&gt;&gt; pu.as_series(a)\n[array([0.]), array([1.]), array([2.]), array([3.])]\n&gt;&gt;&gt; b = np.arange(6).reshape((2,3))\n&gt;&gt;&gt; pu.as_series(b)\n[array([0., 1., 2.]), array([3., 4., 5.])]\n\n\n&gt;&gt;&gt; pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))\n[array([1.]), array([0., 1., 2.]), array([0., 1.])]\n\n\n&gt;&gt;&gt; pu.as_series([2, [1.1, 0.]])\n[array([2.]), array([1.1])]\n\n\n&gt;&gt;&gt; pu.as_series([2, [1.1, 0.]], trim=False)\n[array([2.]), array([1.1, 0. ])]\n\n\n", "parameters": ["Parameters", "alistarray_like", "trimboolean, optional", "Returns", "[a1, a2,\u2026]list of 1-D arrays", "Raises", "ValueError"], "returns": "[a1, a2,\u2026]list of 1-D arraysA copy of the input data as a list of 1-d arrays.", "examples": ["; from numpy.polynomial import polyutils as pu\n; a = np.arange(4)\n; pu.as_series(a)\n[array([0.]), array([1.]), array([2.]), array([3.])]\n; b = np.arange(6).reshape((2,3))\n; pu.as_series(b)\n[array([0., 1., 2.]), array([3., 4., 5.])]\n\n", "; from numpy.polynomial import polyutils as pu\n; a = np.arange(4)\n; pu.as_series(a)\n[array([0.]), array([1.]), array([2.]), array([3.])]\n; b = np.arange(6).reshape((2,3))\n; pu.as_series(b)\n[array([0., 1., 2.]), array([3., 4., 5.])]\n", "; pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))\n[array([1.]), array([0., 1., 2.]), array([0., 1.])]\n\n", "; pu.as_series((1, np.arange(3), np.arange(2, dtype=np.float16)))\n[array([1.]), array([0., 1., 2.]), array([0., 1.])]\n", "; pu.as_series([2, [1.1, 0.]])\n[array([2.]), array([1.1])]\n\n", "; pu.as_series([2, [1.1, 0.]])\n[array([2.]), array([1.1])]\n", "; pu.as_series([2, [1.1, 0.]], trim=False)\n[array([2.]), array([1.1, 0. ])]\n\n", "; pu.as_series([2, [1.1, 0.]], trim=False)\n[array([2.]), array([1.1, 0. ])]\n"]},
{"library": "numpy", "item_id": "numpy.ctypeslib.as_array", "code": "\nnumpy.ctypeslib.as_array(obj, shape=None)[source]\u00b6", "description": "Create a numpy array from a ctypes array or POINTER.\nThe numpy array shares the memory with the ctypes object.\nThe shape parameter must be given if converting from a ctypes POINTER.\nThe shape parameter is ignored if converting from a ctypes array\n", "parameters": ["Parameters", "dtypedtype", "Returns", "ctype", "Raises", "NotImplementedError", "Parameters", "libnamestr", "loader_pathstr", "Returns", "ctypes.cdll[libpath]library object", "Raises", "OSError", "Parameters", "libnamestr", "loader_pathstr", "Returns", "ctypes.cdll[libpath]library object", "Raises", "OSError", "Parameters", "dtypedata-type, optional", "ndimint, optional", "shapetuple of ints, optional", "flagsstr or tuple of str", "Returns", "klassndpointer type object", "Raises", "TypeError"], "returns": "ctypeA ctype scalar, union, array, or struct", "examples": ["; clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,\n...                                                  ndim=1,\n...                                                  flags='C_CONTIGUOUS')]\n... \n; clib.somefunc(np.array([1, 2, 3], dtype=np.float64))\n... \n\n", "; clib.somefunc.argtypes = [np.ctypeslib.ndpointer(dtype=np.float64,\n...                                                  ndim=1,\n...                                                  flags='C_CONTIGUOUS')]\n... \n; clib.somefunc(np.array([1, 2, 3], dtype=np.float64))\n... \n"]},
{"library": "numpy", "item_id": "numpy.array_split", "code": "\nnumpy.array_split(ary, indices_or_sections, axis=0)[source]\u00b6", "description": "Split an array into multiple sub-arrays.\nPlease refer to the split documentation.  The only difference\nbetween these functions is that array_split allows\nindices_or_sections to be an integer that does not equally\ndivide the axis. For an array of length l that should be split\ninto n sections, it returns l % n sub-arrays of size l//n + 1\nand the rest of size l//n.\n\nSee also\n\nsplitSplit array into multiple sub-arrays of equal size.\n\n\n\nExamples\n&gt;&gt;&gt; x = np.arange(8.0)\n&gt;&gt;&gt; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n\n&gt;&gt;&gt; x = np.arange(7.0)\n&gt;&gt;&gt; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.arange(8.0)\n; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n\n", "; x = np.arange(8.0)\n; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.,  5.]), array([6.,  7.])]\n", "; x = np.arange(7.0)\n; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]\n\n", "; x = np.arange(7.0)\n; np.array_split(x, 3)\n    [array([0.,  1.,  2.]), array([3.,  4.]), array([5.,  6.])]\n"]},
{"library": "numpy", "item_id": "numpy.array_repr", "code": "\nnumpy.array_repr(arr, max_line_width=None, precision=None, suppress_small=None)[source]\u00b6", "description": "Return the string representation of an array.\n\nParameters\n\narrndarrayInput array.\n\nmax_line_widthint, optionalInserts newlines if text is longer than max_line_width.\nDefaults to numpy.get_printoptions()['linewidth'].\n\nprecisionint, optionalFloating point precision.\nDefaults to numpy.get_printoptions()['precision'].\n\nsuppress_smallbool, optionalRepresent numbers \u201cvery close\u201d to zero as zero; default is False.\nVery close is defined by precision: if the precision is 8, e.g.,\nnumbers smaller (in absolute value) than 5e-9 are represented as\nzero.\nDefaults to numpy.get_printoptions()['suppress'].\n\n\n\nReturns\n\nstringstrThe string representation of an array.\n\n\n\n\n\nSee also\narray_str, array2string, set_printoptions\n\nExamples\n&gt;&gt;&gt; np.array_repr(np.array([1,2]))\n'array([1, 2])'\n&gt;&gt;&gt; np.array_repr(np.ma.array([0.]))\n'MaskedArray([0.])'\n&gt;&gt;&gt; np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'\n\n\n&gt;&gt;&gt; x = np.array([1e-6, 4e-7, 2, 3])\n&gt;&gt;&gt; np.array_repr(x, precision=6, suppress_small=True)\n'array([0.000001,  0.      ,  2.      ,  3.      ])'\n\n\n", "parameters": ["Parameters", "arrndarray", "max_line_widthint, optional", "precisionint, optional", "suppress_smallbool, optional", "Returns", "stringstr"], "returns": "stringstrThe string representation of an array.", "examples": ["; np.array_repr(np.array([1,2]))\n'array([1, 2])'\n; np.array_repr(np.ma.array([0.]))\n'MaskedArray([0.])'\n; np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'\n\n", "; np.array_repr(np.array([1,2]))\n'array([1, 2])'\n; np.array_repr(np.ma.array([0.]))\n'MaskedArray([0.])'\n; np.array_repr(np.array([], np.int32))\n'array([], dtype=int32)'\n", "; x = np.array([1e-6, 4e-7, 2, 3])\n; np.array_repr(x, precision=6, suppress_small=True)\n'array([0.000001,  0.      ,  2.      ,  3.      ])'\n\n", "; x = np.array([1e-6, 4e-7, 2, 3])\n; np.array_repr(x, precision=6, suppress_small=True)\n'array([0.000001,  0.      ,  2.      ,  3.      ])'\n"]},
{"library": "numpy", "item_id": "numpy.array_equiv", "code": "\nnumpy.array_equiv(a1, a2)[source]\u00b6", "description": "Returns True if input arrays are shape consistent and all elements equal.\nShape consistent means they are either the same shape, or one input array\ncan be broadcasted to create the same shape as the other one.\n\nParameters\n\na1, a2array_likeInput arrays.\n\n\n\nReturns\n\noutboolTrue if equivalent, False otherwise.\n\n\n\n\nExamples\n&gt;&gt;&gt; np.array_equiv([1, 2], [1, 2])\nTrue\n&gt;&gt;&gt; np.array_equiv([1, 2], [1, 3])\nFalse\n\n\nShowing the shape equivalence:\n&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 2]])\nTrue\n&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\nFalse\n\n\n&gt;&gt;&gt; np.array_equiv([1, 2], [[1, 2], [1, 3]])\nFalse\n\n\n", "parameters": ["Parameters", "a1, a2array_like", "Returns", "outbool"], "returns": "outboolTrue if equivalent, False otherwise.", "examples": ["; np.array_equiv([1, 2], [1, 2])\nTrue\n; np.array_equiv([1, 2], [1, 3])\nFalse\n\n", "; np.array_equiv([1, 2], [1, 2])\nTrue\n; np.array_equiv([1, 2], [1, 3])\nFalse\n", "; np.array_equiv([1, 2], [[1, 2], [1, 2]])\nTrue\n; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\nFalse\n\n", "; np.array_equiv([1, 2], [[1, 2], [1, 2]])\nTrue\n; np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])\nFalse\n", "; np.array_equiv([1, 2], [[1, 2], [1, 3]])\nFalse\n\n", "; np.array_equiv([1, 2], [[1, 2], [1, 3]])\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.array_equal", "code": "\nnumpy.array_equal(a1, a2)[source]\u00b6", "description": "True if two arrays have the same shape and elements, False otherwise.\n\nParameters\n\na1, a2array_likeInput arrays.\n\n\n\nReturns\n\nbboolReturns True if the arrays are equal.\n\n\n\n\n\nSee also\n\nallcloseReturns True if two arrays are element-wise equal within a tolerance.\n\narray_equivReturns True if input arrays are shape consistent and all elements equal.\n\n\n\nExamples\n&gt;&gt;&gt; np.array_equal([1, 2], [1, 2])\nTrue\n&gt;&gt;&gt; np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n&gt;&gt;&gt; np.array_equal([1, 2], [1, 2, 3])\nFalse\n&gt;&gt;&gt; np.array_equal([1, 2], [1, 4])\nFalse\n\n\n", "parameters": ["Parameters", "a1, a2array_like", "Returns", "bbool"], "returns": "bboolReturns True if the arrays are equal.", "examples": ["; np.array_equal([1, 2], [1, 2])\nTrue\n; np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n; np.array_equal([1, 2], [1, 2, 3])\nFalse\n; np.array_equal([1, 2], [1, 4])\nFalse\n\n", "; np.array_equal([1, 2], [1, 2])\nTrue\n; np.array_equal(np.array([1, 2]), np.array([1, 2]))\nTrue\n; np.array_equal([1, 2], [1, 2, 3])\nFalse\n; np.array_equal([1, 2], [1, 4])\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.array2string", "code": "\nnumpy.array2string(a, max_line_width=None, precision=None, suppress_small=None, separator=' ', prefix='', style=&lt;no value&gt;, formatter=None, threshold=None, edgeitems=None, sign=None, floatmode=None, suffix='', **kwarg)[source]\u00b6", "description": "Return a string representation of an array.\n\nParameters\n\naarray_likeInput array.\n\nmax_line_widthint, optionalInserts newlines if text is longer than max_line_width.\nDefaults to numpy.get_printoptions()['linewidth'].\n\nprecisionint or None, optionalFloating point precision.\nDefaults to numpy.get_printoptions()['precision'].\n\nsuppress_smallbool, optionalRepresent numbers \u201cvery close\u201d to zero as zero; default is False.\nVery close is defined by precision: if the precision is 8, e.g.,\nnumbers smaller (in absolute value) than 5e-9 are represented as\nzero.\nDefaults to numpy.get_printoptions()['suppress'].\n\nseparatorstr, optionalInserted between elements.\n\nprefixstr, optional\nsuffix: str, optionalThe length of the prefix and suffix strings are used to respectively\nalign and wrap the output. An array is typically printed as:\nprefix + array2string(a) + suffix\n\n\nThe output is left-padded by the length of the prefix string, and\nwrapping is forced at the column max_line_width - len(suffix).\nIt should be noted that the content of prefix and suffix strings are\nnot included in the output.\n\nstyle_NoValue, optionalHas no effect, do not use.\n\nDeprecated since version 1.14.0.\n\n\nformatterdict of callables, optionalIf not None, the keys should indicate the type(s) that the respective\nformatting function applies to.  Callables should return a string.\nTypes that are not specified (by their corresponding keys) are handled\nby the default formatters.  Individual types for which a formatter\ncan be set are:\n\n\u2018bool\u2019\n\u2018int\u2019\n\u2018timedelta\u2019 : a numpy.timedelta64\n\u2018datetime\u2019 : a numpy.datetime64\n\u2018float\u2019\n\u2018longfloat\u2019 : 128-bit floats\n\u2018complexfloat\u2019\n\u2018longcomplexfloat\u2019 : composed of two 128-bit floats\n\u2018void\u2019 : type numpy.void\n\u2018numpystr\u2019 : types numpy.string_ and numpy.unicode_\n\u2018str\u2019 : all other strings\n\nOther keys that can be used to set a group of types at once are:\n\n\u2018all\u2019 : sets all types\n\u2018int_kind\u2019 : sets \u2018int\u2019\n\u2018float_kind\u2019 : sets \u2018float\u2019 and \u2018longfloat\u2019\n\u2018complex_kind\u2019 : sets \u2018complexfloat\u2019 and \u2018longcomplexfloat\u2019\n\u2018str_kind\u2019 : sets \u2018str\u2019 and \u2018numpystr\u2019\n\n\nthresholdint, optionalTotal number of array elements which trigger summarization\nrather than full repr.\nDefaults to numpy.get_printoptions()['threshold'].\n\nedgeitemsint, optionalNumber of array items in summary at beginning and end of\neach dimension.\nDefaults to numpy.get_printoptions()['edgeitems'].\n\nsignstring, either \u2018-\u2018, \u2018+\u2019, or \u2018 \u2018, optionalControls printing of the sign of floating-point types. If \u2018+\u2019, always\nprint the sign of positive values. If \u2018 \u2018, always prints a space\n(whitespace character) in the sign position of positive values.  If\n\u2018-\u2018, omit the sign character of positive values.\nDefaults to numpy.get_printoptions()['sign'].\n\nfloatmodestr, optionalControls the interpretation of the precision option for\nfloating-point types.\nDefaults to numpy.get_printoptions()['floatmode'].\nCan take the following values:\n\n\u2018fixed\u2019: Always print exactly precision fractional digits,\neven if this would print more or fewer digits than\nnecessary to specify the value uniquely.\n\u2018unique\u2019: Print the minimum number of fractional digits necessary\nto represent each value uniquely. Different elements may\nhave a different number of digits.  The value of the\nprecision option is ignored.\n\u2018maxprec\u2019: Print at most precision fractional digits, but if\nan element can be uniquely represented with fewer digits\nonly print it with that many.\n\u2018maxprec_equal\u2019: Print at most precision fractional digits,\nbut if every element in the array can be uniquely\nrepresented with an equal number of fewer digits, use that\nmany digits for all elements.\n\n\nlegacystring or False, optionalIf set to the string \u20181.13\u2019 enables 1.13 legacy printing mode. This\napproximates numpy 1.13 print output by including a space in the sign\nposition of floats and different behavior for 0d arrays. If set to\nFalse, disables legacy mode. Unrecognized strings will be ignored\nwith a warning for forward compatibility.\n\nNew in version 1.14.0.\n\n\n\n\nReturns\n\narray_strstrString representation of the array.\n\n\n\nRaises\n\nTypeErrorif a callable in formatter does not return a string.\n\n\n\n\n\nSee also\narray_str, array_repr, set_printoptions, get_printoptions\n\nNotes\nIf a formatter is specified for a certain type, the precision keyword is\nignored for that type.\nThis is a very flexible function; array_repr and array_str are using\narray2string internally so keywords with the same name should work\nidentically in all three functions.\nExamples\n&gt;&gt;&gt; x = np.array([1e-16,1,2,3])\n&gt;&gt;&gt; np.array2string(x, precision=2, separator=',',\n...                       suppress_small=True)\n'[0.,1.,2.,3.]'\n\n\n&gt;&gt;&gt; x  = np.arange(3.)\n&gt;&gt;&gt; np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n'[0.00 1.00 2.00]'\n\n\n&gt;&gt;&gt; x  = np.arange(3)\n&gt;&gt;&gt; np.array2string(x, formatter={'int':lambda x: hex(x)})\n'[0x0 0x1 0x2]'\n\n\n", "parameters": ["Parameters", "aarray_like", "max_line_widthint, optional", "precisionint or None, optional", "suppress_smallbool, optional", "separatorstr, optional", "prefixstr, optional", "suffix: str, optional", "style_NoValue, optional", "formatterdict of callables, optional", "thresholdint, optional", "edgeitemsint, optional", "signstring, either \u2018-\u2018, \u2018+\u2019, or \u2018 \u2018, optional", "floatmodestr, optional", "legacystring or False, optional", "Returns", "array_strstr", "Raises", "TypeError"], "returns": "array_strstrString representation of the array.", "examples": ["; x = np.array([1e-16,1,2,3])\n; np.array2string(x, precision=2, separator=',',\n...                       suppress_small=True)\n'[0.,1.,2.,3.]'\n\n", "; x = np.array([1e-16,1,2,3])\n; np.array2string(x, precision=2, separator=',',\n...                       suppress_small=True)\n'[0.,1.,2.,3.]'\n", "; x  = np.arange(3.)\n; np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n'[0.00 1.00 2.00]'\n\n", "; x  = np.arange(3.)\n; np.array2string(x, formatter={'float_kind':lambda x: \"%.2f\" % x})\n'[0.00 1.00 2.00]'\n", "; x  = np.arange(3)\n; np.array2string(x, formatter={'int':lambda x: hex(x)})\n'[0x0 0x1 0x2]'\n\n", "; x  = np.arange(3)\n; np.array2string(x, formatter={'int':lambda x: hex(x)})\n'[0x0 0x1 0x2]'\n"]},
{"library": "numpy", "item_id": "numpy.ma.array", "code": "\nnumpy.ma.array(data, dtype=None, copy=False, order=None, mask=False, fill_value=None, keep_mask=True, hard_mask=False, shrink=True, subok=True, ndmin=0)[source]\u00b6", "description": "An array class with possibly masked values.\nMasked values of True exclude the corresponding element from any\ncomputation.\nConstruction:\nx = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,\n                ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,\n                shrink=True, order=None)\n\n\n\nParameters\n\ndataarray_likeInput data.\n\nmasksequence, optionalMask. Must be convertible to an array of booleans with the same\nshape as data. True indicates a masked (i.e. invalid) data.\n\ndtypedtype, optionalData type of the output.\nIf dtype is None, the type of the data argument (data.dtype)\nis used. If dtype is not None and different from data.dtype,\na copy is performed.\n\ncopybool, optionalWhether to copy the input data (True), or to use a reference instead.\nDefault is False.\n\nsubokbool, optionalWhether to return a subclass of MaskedArray if possible (True) or a\nplain MaskedArray. Default is True.\n\nndminint, optionalMinimum number of dimensions. Default is 0.\n\nfill_valuescalar, optionalValue used to fill in the masked values when necessary.\nIf None, a default based on the data-type is used.\n\nkeep_maskbool, optionalWhether to combine mask with the mask of the input data, if any\n(True), or to use only mask for the output (False). Default is True.\n\nhard_maskbool, optionalWhether to use a hard mask or not. With a hard mask, masked values\ncannot be unmasked. Default is False.\n\nshrinkbool, optionalWhether to force compression of an empty mask. Default is True.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optionalSpecify the order of the array.  If order is \u2018C\u2019, then the array\nwill be in C-contiguous order (last-index varies the fastest).\nIf order is \u2018F\u2019, then the returned array will be in\nFortran-contiguous order (first-index varies the fastest).\nIf order is \u2018A\u2019 (default), then the returned array may be\nin any order (either C-, Fortran-contiguous, or even discontiguous),\nunless a copy is required, in which case it will be C-contiguous.\n\n\n\n\n", "parameters": ["Parameters", "dataarray_like", "masksequence, optional", "dtypedtype, optional", "copybool, optional", "subokbool, optional", "ndminint, optional", "fill_valuescalar, optional", "keep_maskbool, optional", "hard_maskbool, optional", "shrinkbool, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.core.records.array", "code": "\nnumpy.core.records.array(obj, dtype=None, shape=None, offset=0, strides=None, formats=None, names=None, titles=None, aligned=False, byteorder=None, copy=True)[source]\u00b6", "description": "Construct a record array from a wide-variety of objects.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.core.defchararray.array", "code": "\nnumpy.core.defchararray.array(obj, itemsize=None, copy=True, unicode=None, order=None)[source]\u00b6", "description": "Create a chararray.\n\nNote\nThis class is provided for numarray backward-compatibility.\nNew code (not concerned with numarray compatibility) should use\narrays of type string_ or unicode_ and use the free functions\nin numpy.char for fast\nvectorized string operations instead.\n\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. str.endswith) and infix operators (e.g. +, *, %)\n\n\n\nParameters\n\nobjarray of str or unicode-like\nitemsizeint, optionalitemsize is the number of characters per scalar in the\nresulting array.  If itemsize is None, and obj is an\nobject array or a Python list, the itemsize will be\nautomatically determined.  If itemsize is provided and obj\nis of type str or unicode, then the obj string will be\nchunked into itemsize pieces.\n\ncopybool, optionalIf true (default), then the object is copied.  Otherwise, a copy\nwill only be made if __array__ returns a copy, if obj is a\nnested sequence, or if a copy is needed to satisfy any of the other\nrequirements (itemsize, unicode, order, etc.).\n\nunicodebool, optionalWhen true, the resulting chararray can contain Unicode\ncharacters, when false only 8-bit characters.  If unicode is\nNone and obj is one of the following:\n\n\na chararray,\nan ndarray of type str or unicode\na Python str or unicode object,\n\n\nthen the unicode setting of the output array will be\nautomatically determined.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optionalSpecify the order of the array.  If order is \u2018C\u2019 (default), then the\narray will be in C-contiguous order (last-index varies the\nfastest).  If order is \u2018F\u2019, then the returned array\nwill be in Fortran-contiguous order (first-index varies the\nfastest).  If order is \u2018A\u2019, then the returned array may\nbe in any order (either C-, Fortran-contiguous, or even\ndiscontiguous).\n\n\n\n\n", "parameters": ["Parameters", "objarray of str or unicode-like", "itemsizeint, optional", "copybool, optional", "unicodebool, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.array", "code": "\nnumpy.array(object, dtype=None, copy=True, order='K', subok=False, ndmin=0)\u00b6", "description": "Create an array.\n\nParameters\n\nobjectarray_likeAn array, any object exposing the array interface, an object whose\n__array__ method returns an array, or any (nested) sequence.\n\ndtypedata-type, optionalThe desired data-type for the array.  If not given, then the type will\nbe determined as the minimum type required to hold the objects in the\nsequence.\n\ncopybool, optionalIf true (default), then the object is copied.  Otherwise, a copy will\nonly be made if __array__ returns a copy, if obj is a nested sequence,\nor if a copy is needed to satisfy any of the other requirements\n(dtype, order, etc.).\n\norder{\u2018K\u2019, \u2018A\u2019, \u2018C\u2019, \u2018F\u2019}, optionalSpecify the memory layout of the array. If object is not an array, the\nnewly created array will be in C order (row major) unless \u2018F\u2019 is\nspecified, in which case it will be in Fortran order (column major).\nIf object is an array the following holds.\n\n\n\n\n\n\n\norder\nno copy\ncopy=True\n\n\n\n\u2018K\u2019\nunchanged\nF &amp; C order preserved, otherwise most similar order\n\n\u2018A\u2019\nunchanged\nF order if input is F and not C, otherwise C order\n\n\u2018C\u2019\nC order\nC order\n\n\u2018F\u2019\nF order\nF order\n\n\n\nWhen copy=False and a copy is made for other reasons, the result is\nthe same as if copy=True, with some exceptions for A, see the\nNotes section. The default order is \u2018K\u2019.\n\nsubokbool, optionalIf True, then sub-classes will be passed-through, otherwise\nthe returned array will be forced to be a base-class array (default).\n\nndminint, optionalSpecifies the minimum number of dimensions that the resulting\narray should have.  Ones will be pre-pended to the shape as\nneeded to meet this requirement.\n\n\n\nReturns\n\noutndarrayAn array object satisfying the specified requirements.\n\n\n\n\n\nSee also\n\nempty_likeReturn an empty array with shape and type of input.\n\nones_likeReturn an array of ones with shape and type of input.\n\nzeros_likeReturn an array of zeros with shape and type of input.\n\nfull_likeReturn a new array with shape of input filled with value.\n\nemptyReturn a new uninitialized array.\n\nonesReturn a new array setting values to one.\n\nzerosReturn a new array setting values to zero.\n\nfullReturn a new array of given shape filled with value.\n\n\n\nNotes\nWhen order is \u2018A\u2019 and object is an array in neither \u2018C\u2019 nor \u2018F\u2019 order,\nand a copy is forced by a change in dtype, then the order of the result is\nnot necessarily \u2018C\u2019 as expected. This is likely a bug.\nExamples\n&gt;&gt;&gt; np.array([1, 2, 3])\narray([1, 2, 3])\n\n\nUpcasting:\n&gt;&gt;&gt; np.array([1, 2, 3.0])\narray([ 1.,  2.,  3.])\n\n\nMore than one dimension:\n&gt;&gt;&gt; np.array([[1, 2], [3, 4]])\narray([[1, 2],\n       [3, 4]])\n\n\nMinimum dimensions 2:\n&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)\narray([[1, 2, 3]])\n\n\nType provided:\n&gt;&gt;&gt; np.array([1, 2, 3], dtype=complex)\narray([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n\nData-type consisting of more than one element:\n&gt;&gt;&gt; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])\n&gt;&gt;&gt; x['a']\narray([1, 3])\n\n\nCreating an array from sub-classes:\n&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))\narray([[1, 2],\n       [3, 4]])\n\n\n&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)\nmatrix([[1, 2],\n        [3, 4]])\n\n\n", "parameters": ["Parameters", "objectarray_like", "dtypedata-type, optional", "copybool, optional", "order{\u2018K\u2019, \u2018A\u2019, \u2018C\u2019, \u2018F\u2019}, optional", "subokbool, optional", "ndminint, optional", "Returns", "outndarray"], "returns": "outndarrayAn array object satisfying the specified requirements.", "examples": ["; np.array([1, 2, 3])\narray([1, 2, 3])\n\n", "; np.array([1, 2, 3])\narray([1, 2, 3])\n", "; np.array([1, 2, 3.0])\narray([ 1.,  2.,  3.])\n\n", "; np.array([1, 2, 3.0])\narray([ 1.,  2.,  3.])\n", "; np.array([[1, 2], [3, 4]])\narray([[1, 2],\n       [3, 4]])\n\n", "; np.array([[1, 2], [3, 4]])\narray([[1, 2],\n       [3, 4]])\n", "; np.array([1, 2, 3], ndmin=2)\narray([[1, 2, 3]])\n\n", "; np.array([1, 2, 3], ndmin=2)\narray([[1, 2, 3]])\n", "; np.array([1, 2, 3], dtype=complex)\narray([ 1.+0.j,  2.+0.j,  3.+0.j])\n\n", "; np.array([1, 2, 3], dtype=complex)\narray([ 1.+0.j,  2.+0.j,  3.+0.j])\n", "; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])\n; x['a']\narray([1, 3])\n\n", "; x = np.array([(1,2),(3,4)],dtype=[('a','&lt;i4'),('b','&lt;i4')])\n; x['a']\narray([1, 3])\n", "; np.array(np.mat('1 2; 3 4'))\narray([[1, 2],\n       [3, 4]])\n\n", "; np.array(np.mat('1 2; 3 4'))\narray([[1, 2],\n       [3, 4]])\n", "; np.array(np.mat('1 2; 3 4'), subok=True)\nmatrix([[1, 2],\n        [3, 4]])\n\n", "; np.array(np.mat('1 2; 3 4'), subok=True)\nmatrix([[1, 2],\n        [3, 4]])\n"]},
{"library": "numpy", "item_id": "numpy.char.array", "code": "\nnumpy.char.array(obj, itemsize=None, copy=True, unicode=None, order=None)\u00b6", "description": "Create a chararray.\n\nNote\nThis class is provided for numarray backward-compatibility.\nNew code (not concerned with numarray compatibility) should use\narrays of type string_ or unicode_ and use the free functions\nin numpy.char for fast\nvectorized string operations instead.\n\nVersus a regular NumPy array of type str or unicode, this\nclass adds the following functionality:\n\n\nvalues automatically have whitespace removed from the end\nwhen indexed\ncomparison operators automatically remove whitespace from the\nend when comparing values\nvectorized string operations are provided as methods\n(e.g. str.endswith) and infix operators (e.g. +, *, %)\n\n\n\nParameters\n\nobjarray of str or unicode-like\nitemsizeint, optionalitemsize is the number of characters per scalar in the\nresulting array.  If itemsize is None, and obj is an\nobject array or a Python list, the itemsize will be\nautomatically determined.  If itemsize is provided and obj\nis of type str or unicode, then the obj string will be\nchunked into itemsize pieces.\n\ncopybool, optionalIf true (default), then the object is copied.  Otherwise, a copy\nwill only be made if __array__ returns a copy, if obj is a\nnested sequence, or if a copy is needed to satisfy any of the other\nrequirements (itemsize, unicode, order, etc.).\n\nunicodebool, optionalWhen true, the resulting chararray can contain Unicode\ncharacters, when false only 8-bit characters.  If unicode is\nNone and obj is one of the following:\n\n\na chararray,\nan ndarray of type str or unicode\na Python str or unicode object,\n\n\nthen the unicode setting of the output array will be\nautomatically determined.\n\norder{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optionalSpecify the order of the array.  If order is \u2018C\u2019 (default), then the\narray will be in C-contiguous order (last-index varies the\nfastest).  If order is \u2018F\u2019, then the returned array\nwill be in Fortran-contiguous order (first-index varies the\nfastest).  If order is \u2018A\u2019, then the returned array may\nbe in any order (either C-, Fortran-contiguous, or even\ndiscontiguous).\n\n\n\n\n", "parameters": ["Parameters", "objarray of str or unicode-like", "itemsizeint, optional", "copybool, optional", "unicodebool, optional", "order{\u2018C\u2019, \u2018F\u2019, \u2018A\u2019}, optional"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.around", "code": "\nnumpy.ma.around(a, *args, **kwargs) = &lt;numpy.ma.core._MaskedUnaryOperation object&gt;\u00b6", "description": "Round an array to the given number of decimals.\n\nSee also\n\naroundequivalent function; see for details.\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked", "code": "\nnumpy.ma.masked\u00b6", "description": "The masked constant is a special case of MaskedArray,\nwith a float datatype and a null shape. It is used to test whether a\nspecific entry of a masked array is masked, or to mask one or several\nentries of a masked array:\n&gt;&gt;&gt; x = ma.array([1, 2, 3], mask=[0, 1, 0])\n&gt;&gt;&gt; x[1] is ma.masked\nTrue\n&gt;&gt;&gt; x[-1] = ma.masked\n&gt;&gt;&gt; x\nmasked_array(data = [1 -- --],\n             mask = [False  True  True],\n       fill_value = 999999)\n\n\n", "parameters": [], "returns": [], "examples": ["; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n\n", "; for dt in [np.int32, np.int64, np.float64, np.complex128]:\n...     np.ma.array([0, 1], dtype=dt).get_fill_value()\n...\n999999\n999999\n1e+20\n(1e+20+0j)\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n\n", "; x = np.ma.array([0, 1.], fill_value=-np.inf)\n; x.fill_value\n-inf\n; x.fill_value = np.pi\n; x.fill_value\n3.1415926535897931 # may vary\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n\n", "; x.fill_value = None\n; x.fill_value\n1e+20\n"]},
{"library": "numpy", "item_id": "numpy.argwhere", "code": "\nnumpy.argwhere(a)[source]\u00b6", "description": "Find the indices of array elements that are non-zero, grouped by element.\n\nParameters\n\naarray_likeInput data.\n\n\n\nReturns\n\nindex_array(N, a.ndim) ndarrayIndices of elements that are non-zero. Indices are grouped by element.\nThis array will have shape (N, a.ndim) where N is the number of\nnon-zero items.\n\n\n\n\n\nSee also\nwhere, nonzero\n\nNotes\nnp.argwhere(a) is almost the same as np.transpose(np.nonzero(a)),\nbut produces a result of the correct shape for a 0D array.\nThe output of argwhere is not suitable for indexing arrays.\nFor this purpose use nonzero(a) instead.\nExamples\n&gt;&gt;&gt; x = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n&gt;&gt;&gt; np.argwhere(x&gt;1)\narray([[0, 2],\n       [1, 0],\n       [1, 1],\n       [1, 2]])\n\n\n", "parameters": ["Parameters", "aarray_like", "Returns", "index_array(N, a.ndim) ndarray"], "returns": "index_array(N, a.ndim) ndarrayIndices of elements that are non-zero. Indices are grouped by element.This array will have shape (N, a.ndim) where N is the number ofnon-zero items.", "examples": ["; x = np.arange(6).reshape(2,3)\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.argwhere(x&gt;1)\narray([[0, 2],\n       [1, 0],\n       [1, 1],\n       [1, 2]])\n\n", "; x = np.arange(6).reshape(2,3)\n; x\narray([[0, 1, 2],\n       [3, 4, 5]])\n; np.argwhere(x&gt;1)\narray([[0, 2],\n       [1, 0],\n       [1, 1],\n       [1, 2]])\n"]},
{"library": "numpy", "item_id": "numpy.around", "code": "\nnumpy.around(a, decimals=0, out=None)[source]\u00b6", "description": "Evenly round to the given number of decimals.\n\nParameters\n\naarray_likeInput data.\n\ndecimalsint, optionalNumber of decimal places to round to (default: 0).  If\ndecimals is negative, it specifies the number of positions to\nthe left of the decimal point.\n\noutndarray, optionalAlternative output array in which to place the result. It must have\nthe same shape as the expected output, but the type of the output\nvalues will be cast if necessary. See ufuncs-output-type for more\ndetails.\n\n\n\nReturns\n\nrounded_arrayndarrayAn array of the same type as a, containing the rounded values.\nUnless out was specified, a new array is created.  A reference to\nthe result is returned.\nThe real and imaginary parts of complex numbers are rounded\nseparately.  The result of rounding a float is a float.\n\n\n\n\n\nSee also\n\nndarray.roundequivalent method\n\n\nceil, fix, floor, rint, trunc\n\nNotes\nFor values exactly halfway between rounded decimal values, NumPy\nrounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,\n-0.5 and 0.5 round to 0.0, etc.\nnp.around uses a fast but sometimes inexact algorithm to round\nfloating-point datatypes. For positive decimals it is equivalent to\nnp.true_divide(np.rint(a * 10**decimals), 10**decimals), which has\nerror due to the inexact representation of decimal fractions in the IEEE\nfloating point standard [1] and errors introduced when scaling by powers\nof ten. For instance, note the extra \u201c1\u201d in the following:\n&gt;&gt;&gt; np.round(56294995342131.5, 3)\n56294995342131.51\n\n\nIf your goal is to print such values with a fixed number of decimals, it is\npreferable to use numpy\u2019s float printing routines to limit the number of\nprinted decimals:\n&gt;&gt;&gt; np.format_float_positional(56294995342131.5, precision=3)\n'56294995342131.5'\n\n\nThe float printing routines use an accurate but much more computationally\ndemanding algorithm to compute the number of digits after the decimal\npoint.\nAlternatively, Python\u2019s builtin round function uses a more accurate\nbut slower algorithm for 64-bit floating point values:\n&gt;&gt;&gt; round(56294995342131.5, 3)\n56294995342131.5\n&gt;&gt;&gt; np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997\n(16.06, 16.05)\n\n\nReferences\n\n1\n\u201cLecture Notes on the Status of IEEE 754\u201d, William Kahan,\nhttps://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF\n\n2\n\u201cHow Futile are Mindless Assessments of\nRoundoff in Floating-Point Computation?\u201d, William Kahan,\nhttps://people.eecs.berkeley.edu/~wkahan/Mindless.pdf\n\n\nExamples\n&gt;&gt;&gt; np.around([0.37, 1.64])\narray([0.,  2.])\n&gt;&gt;&gt; np.around([0.37, 1.64], decimals=1)\narray([0.4,  1.6])\n&gt;&gt;&gt; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\narray([0.,  2.,  2.,  4.,  4.])\n&gt;&gt;&gt; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\narray([ 1,  2,  3, 11])\n&gt;&gt;&gt; np.around([1,2,3,11], decimals=-1)\narray([ 0,  0,  0, 10])\n\n\n", "parameters": ["Parameters", "aarray_like", "decimalsint, optional", "outndarray, optional", "Returns", "rounded_arrayndarray"], "returns": "rounded_arrayndarrayAn array of the same type as a, containing the rounded values.Unless out was specified, a new array is created.  A reference tothe result is returned.The real and imaginary parts of complex numbers are roundedseparately.  The result of rounding a float is a float.", "examples": ["; np.around([0.37, 1.64])\narray([0.,  2.])\n; np.around([0.37, 1.64], decimals=1)\narray([0.4,  1.6])\n; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\narray([0.,  2.,  2.,  4.,  4.])\n; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\narray([ 1,  2,  3, 11])\n; np.around([1,2,3,11], decimals=-1)\narray([ 0,  0,  0, 10])\n\n", "; np.around([0.37, 1.64])\narray([0.,  2.])\n; np.around([0.37, 1.64], decimals=1)\narray([0.4,  1.6])\n; np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value\narray([0.,  2.,  2.,  4.,  4.])\n; np.around([1,2,3,11], decimals=1) # ndarray of ints is returned\narray([ 1,  2,  3, 11])\n; np.around([1,2,3,11], decimals=-1)\narray([ 0,  0,  0, 10])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.argsort", "code": "\nrecarray.argsort(axis=-1, kind=None, order=None)\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.argsort", "code": "\nrecord.argsort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.argsort", "code": "\nmemmap.argsort(axis=-1, kind=None, order=None)\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.argsort", "code": "\nndarray.argsort(axis=-1, kind=None, order=None)\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.argsort", "code": "\nmatrix.argsort(axis=-1, kind=None, order=None)\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.argsort", "code": "\nMaskType.argsort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.argsort", "code": "\nMaskedArray.argsort(self, axis=&lt;no value&gt;, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.\n\nParameters\n\naxisint, optionalAxis along which to sort. If None, the default, the flattened array\nis used.\n\nChanged in version 1.13.0: Previously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\narr.ndim &gt; 1, to avoid a FutureWarning.\n\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nindex_arrayndarray, intArray of indices that sort a along the specified axis.\nIn other words, a[index_array] yields a sorted a.\n\n\n\n\n\nSee also\n\nMaskedArray.sortDescribes sorting algorithms used.\n\nlexsortIndirect stable sort with multiple keys.\n\nnumpy.ndarray.sortInplace sort.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.argsort()\narray([1, 0, 2])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "index_arrayndarray, int"], "returns": "index_arrayndarray, intArray of indices that sort a along the specified axis.In other words, a[index_array] yields a sorted a.", "examples": ["; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n\n", "; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.argsort", "code": "\nmasked_array.argsort(self, axis=&lt;no value&gt;, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.\n\nParameters\n\naxisint, optionalAxis along which to sort. If None, the default, the flattened array\nis used.\n\nChanged in version 1.13.0: Previously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\narr.ndim &gt; 1, to avoid a FutureWarning.\n\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nindex_arrayndarray, intArray of indices that sort a along the specified axis.\nIn other words, a[index_array] yields a sorted a.\n\n\n\n\n\nSee also\n\nMaskedArray.sortDescribes sorting algorithms used.\n\nlexsortIndirect stable sort with multiple keys.\n\nnumpy.ndarray.sortInplace sort.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.argsort()\narray([1, 0, 2])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "index_arrayndarray, int"], "returns": "index_arrayndarray, intArray of indices that sort a along the specified axis.In other words, a[index_array] yields a sorted a.", "examples": ["; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n\n", "; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n"]},
{"library": "numpy", "item_id": "numpy.generic.argsort", "code": "\ngeneric.argsort()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.argsort", "code": "\nchararray.argsort(axis=-1, kind=None, order=None)[source]\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.argsort", "code": "\nchararray.argsort(axis=-1, kind=None, order=None)\u00b6", "description": "Returns the indices that would sort this array.\nRefer to numpy.argsort for full documentation.\n\nSee also\n\nnumpy.argsortequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.argsort", "code": "\nnumpy.ma.argsort(a, axis=&lt;no value&gt;, kind=None, order=None, endwith=True, fill_value=None)[source]\u00b6", "description": "Return an ndarray of indices that sort the array along the\nspecified axis.  Masked values are filled beforehand to\nfill_value.\n\nParameters\n\naxisint, optionalAxis along which to sort. If None, the default, the flattened array\nis used.\n\nChanged in version 1.13.0: Previously, the default was documented to be -1, but that was\nin error. At some future date, the default will change to -1, as\noriginally intended.\nUntil then, the axis should be given explicitly when\narr.ndim &gt; 1, to avoid a FutureWarning.\n\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalThe sorting algorithm used.\n\norderlist, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  Not all fields need be\nspecified.\n\nendwith{True, False}, optionalWhether missing values (if any) should be treated as the largest values\n(True) or the smallest values (False)\nWhen the array contains unmasked values at the same extremes of the\ndatatype, the ordering of these values and the masked values is\nundefined.\n\nfill_value{var}, optionalValue used internally for the masked values.\nIf fill_value is not None, it supersedes endwith.\n\n\n\nReturns\n\nindex_arrayndarray, intArray of indices that sort a along the specified axis.\nIn other words, a[index_array] yields a sorted a.\n\n\n\n\n\nSee also\n\nMaskedArray.sortDescribes sorting algorithms used.\n\nlexsortIndirect stable sort with multiple keys.\n\nnumpy.ndarray.sortInplace sort.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nExamples\n&gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])\n&gt;&gt;&gt; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n&gt;&gt;&gt; a.argsort()\narray([1, 0, 2])\n\n\n", "parameters": ["Parameters", "axisint, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderlist, optional", "endwith{True, False}, optional", "fill_value{var}, optional", "Returns", "index_arrayndarray, int"], "returns": "index_arrayndarray, intArray of indices that sort a along the specified axis.In other words, a[index_array] yields a sorted a.", "examples": ["; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n\n", "; a = np.ma.array([3,2,1], mask=[False, False, True])\n; a\nmasked_array(data=[3, 2, --],\n             mask=[False, False,  True],\n       fill_value=999999)\n; a.argsort()\narray([1, 0, 2])\n"]},
{"library": "numpy", "item_id": "numpy.argsort", "code": "\nnumpy.argsort(a, axis=-1, kind=None, order=None)[source]\u00b6", "description": "Returns the indices that would sort an array.\nPerform an indirect sort along the given axis using the algorithm specified\nby the kind keyword. It returns an array of indices of the same shape as\na that index data along the given axis in sorted order.\n\nParameters\n\naarray_likeArray to sort.\n\naxisint or None, optionalAxis along which to sort.  The default is -1 (the last axis). If None,\nthe flattened array is used.\n\nkind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optionalSorting algorithm. The default is \u2018quicksort\u2019. Note that both \u2018stable\u2019\nand \u2018mergesort\u2019 use timsort under the covers and, in general, the\nactual implementation will vary with data type. The \u2018mergesort\u2019 option\nis retained for backwards compatibility.\n\nChanged in version 1.15.0.: The \u2018stable\u2019 option was added.\n\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument specifies\nwhich fields to compare first, second, etc.  A single field can\nbe specified as a string, and not all fields need be specified,\nbut unspecified fields will still be used, in the order in which\nthey come up in the dtype, to break ties.\n\n\n\nReturns\n\nindex_arrayndarray, intArray of indices that sort a along the specified axis.\nIf a is one-dimensional, a[index_array] yields a sorted a.\nMore generally, np.take_along_axis(a, index_array, axis=axis)\nalways yields the sorted a, irrespective of dimensionality.\n\n\n\n\n\nSee also\n\nsortDescribes sorting algorithms used.\n\nlexsortIndirect stable sort with multiple keys.\n\nndarray.sortInplace sort.\n\nargpartitionIndirect partial sort.\n\ntake_along_axisApply index_array from argsort to an array as if by calling sort.\n\n\n\nNotes\nSee sort for notes on the different sorting algorithms.\nAs of NumPy 1.4.0 argsort works with real/complex arrays containing\nnan values. The enhanced sort order is documented in sort.\nExamples\nOne dimensional array:\n&gt;&gt;&gt; x = np.array([3, 1, 2])\n&gt;&gt;&gt; np.argsort(x)\narray([1, 2, 0])\n\n\nTwo-dimensional array:\n&gt;&gt;&gt; x = np.array([[0, 3], [2, 2]])\n&gt;&gt;&gt; x\narray([[0, 3],\n       [2, 2]])\n\n\n&gt;&gt;&gt; ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n&gt;&gt;&gt; ind\narray([[0, 1],\n       [1, 0]])\n&gt;&gt;&gt; np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\narray([[0, 2],\n       [2, 3]])\n\n\n&gt;&gt;&gt; ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n&gt;&gt;&gt; ind\narray([[0, 1],\n       [0, 1]])\n&gt;&gt;&gt; np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\narray([[0, 3],\n       [2, 2]])\n\n\nIndices of the sorted elements of a N-dimensional array:\n&gt;&gt;&gt; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n&gt;&gt;&gt; ind\n(array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n&gt;&gt;&gt; x[ind]  # same as np.sort(x, axis=None)\narray([0, 2, 2, 3])\n\n\nSorting with keys:\n&gt;&gt;&gt; x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n&gt;&gt;&gt; x\narray([(1, 0), (0, 1)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n\n&gt;&gt;&gt; np.argsort(x, order=('x','y'))\narray([1, 0])\n\n\n&gt;&gt;&gt; np.argsort(x, order=('y','x'))\narray([0, 1])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint or None, optional", "kind{\u2018quicksort\u2019, \u2018mergesort\u2019, \u2018heapsort\u2019, \u2018stable\u2019}, optional", "orderstr or list of str, optional", "Returns", "index_arrayndarray, int"], "returns": "index_arrayndarray, intArray of indices that sort a along the specified axis.If a is one-dimensional, a[index_array] yields a sorted a.More generally, np.take_along_axis(a, index_array, axis=axis)always yields the sorted a, irrespective of dimensionality.", "examples": ["; x = np.array([3, 1, 2])\n; np.argsort(x)\narray([1, 2, 0])\n\n", "; x = np.array([3, 1, 2])\n; np.argsort(x)\narray([1, 2, 0])\n", "; x = np.array([[0, 3], [2, 2]])\n; x\narray([[0, 3],\n       [2, 2]])\n\n", "; x = np.array([[0, 3], [2, 2]])\n; x\narray([[0, 3],\n       [2, 2]])\n", "; ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n; ind\narray([[0, 1],\n       [1, 0]])\n; np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\narray([[0, 2],\n       [2, 3]])\n\n", "; ind = np.argsort(x, axis=0)  # sorts along first axis (down)\n; ind\narray([[0, 1],\n       [1, 0]])\n; np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)\narray([[0, 2],\n       [2, 3]])\n", "; ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n; ind\narray([[0, 1],\n       [0, 1]])\n; np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\narray([[0, 3],\n       [2, 2]])\n\n", "; ind = np.argsort(x, axis=1)  # sorts along last axis (across)\n; ind\narray([[0, 1],\n       [0, 1]])\n; np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)\narray([[0, 3],\n       [2, 2]])\n", "; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n; ind\n(array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n; x[ind]  # same as np.sort(x, axis=None)\narray([0, 2, 2, 3])\n\n", "; ind = np.unravel_index(np.argsort(x, axis=None), x.shape)\n; ind\n(array([0, 1, 1, 0]), array([0, 0, 1, 1]))\n; x[ind]  # same as np.sort(x, axis=None)\narray([0, 2, 2, 3])\n", "; x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n; x\narray([(1, 0), (0, 1)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n\n", "; x = np.array([(1, 0), (0, 1)], dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n; x\narray([(1, 0), (0, 1)],\n      dtype=[('x', '&lt;i4'), ('y', '&lt;i4')])\n", "; np.argsort(x, order=('x','y'))\narray([1, 0])\n\n", "; np.argsort(x, order=('x','y'))\narray([1, 0])\n", "; np.argsort(x, order=('y','x'))\narray([0, 1])\n\n", "; np.argsort(x, order=('y','x'))\narray([0, 1])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.argpartition", "code": "\nndarray.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.argpartition", "code": "\nrecarray.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.argpartition", "code": "\nmemmap.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.argpartition", "code": "\nmatrix.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.argpartition", "code": "\nmasked_array.argpartition(kth, axis=-1, kind='introselect', order=None)[source]\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.argpartition", "code": "\nchararray.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.argmin", "code": "\nrecord.argmin()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.argmin", "code": "\nrecarray.argmin(axis=None, out=None)\u00b6", "description": "Return indices of the minimum values along the given axis of a.\nRefer to numpy.argmin for detailed documentation.\n\nSee also\n\nnumpy.argminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.argpartition", "code": "\nchararray.argpartition(kth, axis=-1, kind='introselect', order=None)\u00b6", "description": "Returns the indices that would partition this array.\nRefer to numpy.argpartition for full documentation.\n\nNew in version 1.8.0.\n\n\nSee also\n\nnumpy.argpartitionequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.argpartition", "code": "\nnumpy.argpartition(a, kth, axis=-1, kind='introselect', order=None)[source]\u00b6", "description": "Perform an indirect partition along the given axis using the\nalgorithm specified by the kind keyword. It returns an array of\nindices of the same shape as a that index data along the given\naxis in partitioned order.\n\nNew in version 1.8.0.\n\n\nParameters\n\naarray_likeArray to sort.\n\nkthint or sequence of intsElement index to partition by. The k-th element will be in its\nfinal sorted position and all smaller elements will be moved\nbefore it and all larger elements behind it. The order all\nelements in the partitions is undefined. If provided with a\nsequence of k-th it will partition all of them into their sorted\nposition at once.\n\naxisint or None, optionalAxis along which to sort. The default is -1 (the last axis). If\nNone, the flattened array is used.\n\nkind{\u2018introselect\u2019}, optionalSelection algorithm. Default is \u2018introselect\u2019\n\norderstr or list of str, optionalWhen a is an array with fields defined, this argument\nspecifies which fields to compare first, second, etc. A single\nfield can be specified as a string, and not all fields need be\nspecified, but unspecified fields will still be used, in the\norder in which they come up in the dtype, to break ties.\n\n\n\nReturns\n\nindex_arrayndarray, intArray of indices that partition a along the specified axis.\nIf a is one-dimensional, a[index_array] yields a partitioned a.\nMore generally, np.take_along_axis(a, index_array, axis=a) always\nyields the partitioned a, irrespective of dimensionality.\n\n\n\n\n\nSee also\n\npartitionDescribes partition algorithms used.\n\nndarray.partitionInplace partition.\n\nargsortFull indirect sort.\n\ntake_along_axisApply index_array from argpartition to an array as if by calling partition.\n\n\n\nNotes\nSee partition for notes on the different selection algorithms.\nExamples\nOne dimensional array:\n&gt;&gt;&gt; x = np.array([3, 4, 2, 1])\n&gt;&gt;&gt; x[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n&gt;&gt;&gt; x[np.argpartition(x, (1, 3))]\narray([1, 2, 3, 4])\n\n\n&gt;&gt;&gt; x = [3, 4, 2, 1]\n&gt;&gt;&gt; np.array(x)[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n\n\nMulti-dimensional array:\n&gt;&gt;&gt; x = np.array([[3, 4, 2], [1, 3, 1]])\n&gt;&gt;&gt; index_array = np.argpartition(x, kth=1, axis=-1)\n&gt;&gt;&gt; np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)\narray([[2, 3, 4],\n       [1, 1, 3]])\n\n\n", "parameters": ["Parameters", "aarray_like", "kthint or sequence of ints", "axisint or None, optional", "kind{\u2018introselect\u2019}, optional", "orderstr or list of str, optional", "Returns", "index_arrayndarray, int"], "returns": "index_arrayndarray, intArray of indices that partition a along the specified axis.If a is one-dimensional, a[index_array] yields a partitioned a.More generally, np.take_along_axis(a, index_array, axis=a) alwaysyields the partitioned a, irrespective of dimensionality.", "examples": ["; x = np.array([3, 4, 2, 1])\n; x[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n; x[np.argpartition(x, (1, 3))]\narray([1, 2, 3, 4])\n\n", "; x = np.array([3, 4, 2, 1])\n; x[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n; x[np.argpartition(x, (1, 3))]\narray([1, 2, 3, 4])\n", "; x = [3, 4, 2, 1]\n; np.array(x)[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n\n", "; x = [3, 4, 2, 1]\n; np.array(x)[np.argpartition(x, 3)]\narray([2, 1, 3, 4])\n", "; x = np.array([[3, 4, 2], [1, 3, 1]])\n; index_array = np.argpartition(x, kth=1, axis=-1)\n; np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)\narray([[2, 3, 4],\n       [1, 1, 3]])\n\n", "; x = np.array([[3, 4, 2], [1, 3, 1]])\n; index_array = np.argpartition(x, kth=1, axis=-1)\n; np.take_along_axis(x, index_array, axis=-1)  # same as np.partition(x, kth=1)\narray([[2, 3, 4],\n       [1, 1, 3]])\n"]},
{"library": "numpy", "item_id": "numpy.ndarray.argmin", "code": "\nndarray.argmin(axis=None, out=None)\u00b6", "description": "Return indices of the minimum values along the given axis of a.\nRefer to numpy.argmin for detailed documentation.\n\nSee also\n\nnumpy.argminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.argmin", "code": "\nmatrix.argmin(self, axis=None, out=None)[source]\u00b6", "description": "Indexes of the minimum values along an axis.\nReturn the indexes of the first occurrences of the minimum values\nalong the specified axis.  If axis is None, the index is for the\nflattened matrix.\n\nParameters\n\nSee `numpy.argmin` for complete descriptions.\n\n\n\n\nSee also\nnumpy.argmin\n\nNotes\nThis is the same as ndarray.argmin, but returns a matrix object\nwhere ndarray.argmin would return an ndarray.\nExamples\n&gt;&gt;&gt; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n&gt;&gt;&gt; x.argmin()\n11\n&gt;&gt;&gt; x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n&gt;&gt;&gt; x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n\n", "parameters": ["Parameters", "See `numpy.argmin` for complete descriptions."], "returns": [], "examples": ["; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n; x.argmin()\n11\n; x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n; x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n", "; x = -np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[  0,  -1,  -2,  -3],\n        [ -4,  -5,  -6,  -7],\n        [ -8,  -9, -10, -11]])\n; x.argmin()\n11\n; x.argmin(0)\nmatrix([[2, 2, 2, 2]])\n; x.argmin(1)\nmatrix([[3],\n        [3],\n        [3]])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.argmin", "code": "\nmemmap.argmin(axis=None, out=None)\u00b6", "description": "Return indices of the minimum values along the given axis of a.\nRefer to numpy.argmin for detailed documentation.\n\nSee also\n\nnumpy.argminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.argmin", "code": "\nMaskedArray.argmin(self, axis=None, fill_value=None, out=None)[source]\u00b6", "description": "Return array of indices to the minimum values along the given axis.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nndarray or scalarIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n&gt;&gt;&gt; x.shape = (2,2)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "ndarray or scalar"], "returns": "ndarray or scalarIf multi-dimension input, returns a new ndarray of indices to theminimum values along the given axis.  Otherwise, returns a scalarof index to the minimum values along the given axis.", "examples": ["; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n", "; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.argmin", "code": "\nMaskType.argmin()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.argmin", "code": "\nmasked_array.argmin(self, axis=None, fill_value=None, out=None)[source]\u00b6", "description": "Return array of indices to the minimum values along the given axis.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nndarray or scalarIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n&gt;&gt;&gt; x.shape = (2,2)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "ndarray or scalar"], "returns": "ndarray or scalarIf multi-dimension input, returns a new ndarray of indices to theminimum values along the given axis.  Otherwise, returns a scalarof index to the minimum values along the given axis.", "examples": ["; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n", "; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n"]},
{"library": "numpy", "item_id": "numpy.generic.argmin", "code": "\ngeneric.argmin()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.argmin", "code": "\nchararray.argmin(axis=None, out=None)\u00b6", "description": "Return indices of the minimum values along the given axis of a.\nRefer to numpy.argmin for detailed documentation.\n\nSee also\n\nnumpy.argminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.argmin", "code": "\nchararray.argmin(axis=None, out=None)\u00b6", "description": "Return indices of the minimum values along the given axis of a.\nRefer to numpy.argmin for detailed documentation.\n\nSee also\n\nnumpy.argminequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.argmin", "code": "\nnumpy.argmin(a, axis=None, out=None)[source]\u00b6", "description": "Returns the indices of the minimum values along an axis.\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalBy default, the index is into the flattened array, otherwise\nalong the specified axis.\n\noutarray, optionalIf provided, the result will be inserted into this array. It should\nbe of the appropriate shape and dtype.\n\n\n\nReturns\n\nindex_arrayndarray of intsArray of indices into the array. It has the same shape as a.shape\nwith the dimension along axis removed.\n\n\n\n\n\nSee also\nndarray.argmin, argmax\n\naminThe minimum value along a given axis.\n\nunravel_indexConvert a flat index into an index tuple.\n\ntake_along_axisApply np.expand_dims(index_array, axis) from argmin to an array as if by calling min.\n\n\n\nNotes\nIn case of multiple occurrences of the minimum values, the indices\ncorresponding to the first occurrence are returned.\nExamples\n&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10\n&gt;&gt;&gt; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; np.argmin(a)\n0\n&gt;&gt;&gt; np.argmin(a, axis=0)\narray([0, 0, 0])\n&gt;&gt;&gt; np.argmin(a, axis=1)\narray([0, 0])\n\n\nIndices of the minimum elements of a N-dimensional array:\n&gt;&gt;&gt; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)\n&gt;&gt;&gt; ind\n(0, 0)\n&gt;&gt;&gt; a[ind]\n10\n\n\n&gt;&gt;&gt; b = np.arange(6) + 10\n&gt;&gt;&gt; b[4] = 10\n&gt;&gt;&gt; b\narray([10, 11, 12, 13, 10, 15])\n&gt;&gt;&gt; np.argmin(b)  # Only the first occurrence is returned.\n0\n\n\n&gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])\n&gt;&gt;&gt; index_array = np.argmin(x, axis=-1)\n&gt;&gt;&gt; # Same as np.min(x, axis=-1, keepdims=True)\n&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[2],\n       [0]])\n&gt;&gt;&gt; # Same as np.max(x, axis=-1)\n&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([2, 0])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "outarray, optional", "Returns", "index_arrayndarray of ints"], "returns": "index_arrayndarray of intsArray of indices into the array. It has the same shape as a.shapewith the dimension along axis removed.", "examples": ["; a = np.arange(6).reshape(2,3) + 10\n; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n; np.argmin(a)\n0\n; np.argmin(a, axis=0)\narray([0, 0, 0])\n; np.argmin(a, axis=1)\narray([0, 0])\n\n", "; a = np.arange(6).reshape(2,3) + 10\n; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n; np.argmin(a)\n0\n; np.argmin(a, axis=0)\narray([0, 0, 0])\n; np.argmin(a, axis=1)\narray([0, 0])\n", "; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)\n; ind\n(0, 0)\n; a[ind]\n10\n\n", "; ind = np.unravel_index(np.argmin(a, axis=None), a.shape)\n; ind\n(0, 0)\n; a[ind]\n10\n", "; b = np.arange(6) + 10\n; b[4] = 10\n; b\narray([10, 11, 12, 13, 10, 15])\n; np.argmin(b)  # Only the first occurrence is returned.\n0\n\n", "; b = np.arange(6) + 10\n; b[4] = 10\n; b\narray([10, 11, 12, 13, 10, 15])\n; np.argmin(b)  # Only the first occurrence is returned.\n0\n", "; x = np.array([[4,2,3], [1,0,3]])\n; index_array = np.argmin(x, axis=-1)\n; # Same as np.min(x, axis=-1, keepdims=True)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[2],\n       [0]])\n; # Same as np.max(x, axis=-1)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([2, 0])\n\n", "; x = np.array([[4,2,3], [1,0,3]])\n; index_array = np.argmin(x, axis=-1)\n; # Same as np.min(x, axis=-1, keepdims=True)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[2],\n       [0]])\n; # Same as np.max(x, axis=-1)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([2, 0])\n"]},
{"library": "numpy", "item_id": "numpy.recarray.argmax", "code": "\nrecarray.argmax(axis=None, out=None)\u00b6", "description": "Return indices of the maximum values along the given axis.\nRefer to numpy.argmax for full documentation.\n\nSee also\n\nnumpy.argmaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.record.argmax", "code": "\nrecord.argmax()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.argmax", "code": "\nndarray.argmax(axis=None, out=None)\u00b6", "description": "Return indices of the maximum values along the given axis.\nRefer to numpy.argmax for full documentation.\n\nSee also\n\nnumpy.argmaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.argmin", "code": "\nnumpy.ma.argmin(self, axis=None, fill_value=None, out=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Return array of indices to the minimum values along the given axis.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nminimum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nndarray or scalarIf multi-dimension input, returns a new ndarray of indices to the\nminimum values along the given axis.  Otherwise, returns a scalar\nof index to the minimum values along the given axis.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n&gt;&gt;&gt; x.shape = (2,2)\n&gt;&gt;&gt; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n&gt;&gt;&gt; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "ndarray or scalar"], "returns": "ndarray or scalarIf multi-dimension input, returns a new ndarray of indices to theminimum values along the given axis.  Otherwise, returns a scalarof index to the minimum values along the given axis.", "examples": ["; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n\n", "; x = np.ma.array(np.arange(4), mask=[1,1,0,0])\n; x.shape = (2,2)\n; x\nmasked_array(\n  data=[[--, --],\n        [2, 3]],\n  mask=[[ True,  True],\n        [False, False]],\n  fill_value=999999)\n; x.argmin(axis=0, fill_value=-1)\narray([0, 0])\n; x.argmin(axis=0, fill_value=9)\narray([1, 1])\n"]},
{"library": "numpy", "item_id": "numpy.memmap.argmax", "code": "\nmemmap.argmax(axis=None, out=None)\u00b6", "description": "Return indices of the maximum values along the given axis.\nRefer to numpy.argmax for full documentation.\n\nSee also\n\nnumpy.argmaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.argmax", "code": "\nmasked_array.argmax(self, axis=None, fill_value=None, out=None)[source]\u00b6", "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nindex_array{integer_array}\n\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; a.argmax()\n5\n&gt;&gt;&gt; a.argmax(0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.argmax(1)\narray([2, 2])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "index_array{integer_array}"], "returns": "index_array{integer_array}", "examples": ["; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n\n", "; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.matrix.argmax", "code": "\nmatrix.argmax(self, axis=None, out=None)[source]\u00b6", "description": "Indexes of the maximum values along an axis.\nReturn the indexes of the first occurrences of the maximum values\nalong the specified axis.  If axis is None, the index is for the\nflattened matrix.\n\nParameters\n\nSee `numpy.argmax` for complete descriptions\n\n\n\n\nSee also\nnumpy.argmax\n\nNotes\nThis is the same as ndarray.argmax, but returns a matrix object\nwhere ndarray.argmax would return an ndarray.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.argmax()\n11\n&gt;&gt;&gt; x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n&gt;&gt;&gt; x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n\n", "parameters": ["Parameters", "See `numpy.argmax` for complete descriptions"], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.argmax()\n11\n; x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n; x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.argmax()\n11\n; x.argmax(0)\nmatrix([[2, 2, 2, 2]])\n; x.argmax(1)\nmatrix([[3],\n        [3],\n        [3]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.argmax", "code": "\nMaskType.argmax()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.argmax", "code": "\ngeneric.argmax()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.argmax", "code": "\nMaskedArray.argmax(self, axis=None, fill_value=None, out=None)[source]\u00b6", "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nindex_array{integer_array}\n\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; a.argmax()\n5\n&gt;&gt;&gt; a.argmax(0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.argmax(1)\narray([2, 2])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "index_array{integer_array}"], "returns": "index_array{integer_array}", "examples": ["; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n\n", "; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.char.chararray.argmax", "code": "\nchararray.argmax(axis=None, out=None)\u00b6", "description": "Return indices of the maximum values along the given axis.\nRefer to numpy.argmax for full documentation.\n\nSee also\n\nnumpy.argmaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.argmax", "code": "\nnumpy.argmax(a, axis=None, out=None)[source]\u00b6", "description": "Returns the indices of the maximum values along an axis.\n\nParameters\n\naarray_likeInput array.\n\naxisint, optionalBy default, the index is into the flattened array, otherwise\nalong the specified axis.\n\noutarray, optionalIf provided, the result will be inserted into this array. It should\nbe of the appropriate shape and dtype.\n\n\n\nReturns\n\nindex_arrayndarray of intsArray of indices into the array. It has the same shape as a.shape\nwith the dimension along axis removed.\n\n\n\n\n\nSee also\nndarray.argmax, argmin\n\namaxThe maximum value along a given axis.\n\nunravel_indexConvert a flat index into an index tuple.\n\ntake_along_axisApply np.expand_dims(index_array, axis) from argmax to an array as if by calling max.\n\n\n\nNotes\nIn case of multiple occurrences of the maximum values, the indices\ncorresponding to the first occurrence are returned.\nExamples\n&gt;&gt;&gt; a = np.arange(6).reshape(2,3) + 10\n&gt;&gt;&gt; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n&gt;&gt;&gt; np.argmax(a)\n5\n&gt;&gt;&gt; np.argmax(a, axis=0)\narray([1, 1, 1])\n&gt;&gt;&gt; np.argmax(a, axis=1)\narray([2, 2])\n\n\nIndexes of the maximal elements of a N-dimensional array:\n&gt;&gt;&gt; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)\n&gt;&gt;&gt; ind\n(1, 2)\n&gt;&gt;&gt; a[ind]\n15\n\n\n&gt;&gt;&gt; b = np.arange(6)\n&gt;&gt;&gt; b[1] = 5\n&gt;&gt;&gt; b\narray([0, 5, 2, 3, 4, 5])\n&gt;&gt;&gt; np.argmax(b)  # Only the first occurrence is returned.\n1\n\n\n&gt;&gt;&gt; x = np.array([[4,2,3], [1,0,3]])\n&gt;&gt;&gt; index_array = np.argmax(x, axis=-1)\n&gt;&gt;&gt; # Same as np.max(x, axis=-1, keepdims=True)\n&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[4],\n       [3]])\n&gt;&gt;&gt; # Same as np.max(x, axis=-1)\n&gt;&gt;&gt; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([4, 3])\n\n\n", "parameters": ["Parameters", "aarray_like", "axisint, optional", "outarray, optional", "Returns", "index_arrayndarray of ints"], "returns": "index_arrayndarray of intsArray of indices into the array. It has the same shape as a.shapewith the dimension along axis removed.", "examples": ["; a = np.arange(6).reshape(2,3) + 10\n; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n; np.argmax(a)\n5\n; np.argmax(a, axis=0)\narray([1, 1, 1])\n; np.argmax(a, axis=1)\narray([2, 2])\n\n", "; a = np.arange(6).reshape(2,3) + 10\n; a\narray([[10, 11, 12],\n       [13, 14, 15]])\n; np.argmax(a)\n5\n; np.argmax(a, axis=0)\narray([1, 1, 1])\n; np.argmax(a, axis=1)\narray([2, 2])\n", "; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)\n; ind\n(1, 2)\n; a[ind]\n15\n\n", "; ind = np.unravel_index(np.argmax(a, axis=None), a.shape)\n; ind\n(1, 2)\n; a[ind]\n15\n", "; b = np.arange(6)\n; b[1] = 5\n; b\narray([0, 5, 2, 3, 4, 5])\n; np.argmax(b)  # Only the first occurrence is returned.\n1\n\n", "; b = np.arange(6)\n; b[1] = 5\n; b\narray([0, 5, 2, 3, 4, 5])\n; np.argmax(b)  # Only the first occurrence is returned.\n1\n", "; x = np.array([[4,2,3], [1,0,3]])\n; index_array = np.argmax(x, axis=-1)\n; # Same as np.max(x, axis=-1, keepdims=True)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[4],\n       [3]])\n; # Same as np.max(x, axis=-1)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([4, 3])\n\n", "; x = np.array([[4,2,3], [1,0,3]])\n; index_array = np.argmax(x, axis=-1)\n; # Same as np.max(x, axis=-1, keepdims=True)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1)\narray([[4],\n       [3]])\n; # Same as np.max(x, axis=-1)\n; np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1)\narray([4, 3])\n"]},
{"library": "numpy", "item_id": "numpy.chararray.argmax", "code": "\nchararray.argmax(axis=None, out=None)\u00b6", "description": "Return indices of the maximum values along the given axis.\nRefer to numpy.argmax for full documentation.\n\nSee also\n\nnumpy.argmaxequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.argmax", "code": "\nnumpy.ma.argmax(self, axis=None, fill_value=None, out=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns array of indices of the maximum values along the given axis.\nMasked values are treated as if they had the value fill_value.\n\nParameters\n\naxis{None, integer}If None, the index is into the flattened array, otherwise along\nthe specified axis\n\nfill_value{var}, optionalValue used to fill in the masked values.  If None, the output of\nmaximum_fill_value(self._data) is used instead.\n\nout{None, array}, optionalArray into which the result can be placed. Its type is preserved\nand it must be of the right shape to hold the output.\n\n\n\nReturns\n\nindex_array{integer_array}\n\n\n\nExamples\n&gt;&gt;&gt; a = np.arange(6).reshape(2,3)\n&gt;&gt;&gt; a.argmax()\n5\n&gt;&gt;&gt; a.argmax(0)\narray([1, 1, 1])\n&gt;&gt;&gt; a.argmax(1)\narray([2, 2])\n\n\n", "parameters": ["Parameters", "axis{None, integer}", "fill_value{var}, optional", "out{None, array}, optional", "Returns", "index_array{integer_array}"], "returns": "index_array{integer_array}", "examples": ["; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n\n", "; a = np.arange(6).reshape(2,3)\n; a.argmax()\n5\n; a.argmax(0)\narray([1, 1, 1])\n; a.argmax(1)\narray([2, 2])\n"]},
{"library": "numpy", "item_id": "numpy.arctanh", "code": "\nnumpy.arctanh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arctanh'&gt;\u00b6", "description": "Inverse hyperbolic tangent element-wise.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarArray of the same shape as x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nemath.arctanh\n\nNotes\narctanh is a multivalued function: for each x there are infinitely\nmany numbers z such that tanh(z) = x. The convention is to return\nthe z whose imaginary part lies in [-pi/2, pi/2].\nFor real-valued input data types, arctanh always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, arctanh is a complex analytical function\nthat has branch cuts [-1, -inf] and [1, inf] and is continuous from\nabove on the former and from below on the latter.\nThe inverse hyperbolic tangent is also known as atanh or tanh^-1.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cInverse hyperbolic function\u201d,\nhttps://en.wikipedia.org/wiki/Arctanh\n\n\nExamples\n&gt;&gt;&gt; np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarArray of the same shape as x.This is a scalar if x is a scalar.", "examples": ["; np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])\n\n", "; np.arctanh([0, -0.5])\narray([ 0.        , -0.54930614])\n"]},
{"library": "numpy", "item_id": "numpy.arctan2", "code": "\nnumpy.arctan2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arctan2'&gt;\u00b6", "description": "Element-wise arc tangent of x1/x2 choosing the quadrant correctly.\nThe quadrant (i.e., branch) is chosen so that arctan2(x1, x2) is\nthe signed angle in radians between the ray ending at the origin and\npassing through the point (1,0), and the ray ending at the origin and\npassing through the point (x2, x1).  (Note the role reversal: the\n\u201cy-coordinate\u201d is the first function parameter, the \u201cx-coordinate\u201d\nis the second.)  By IEEE convention, this function is defined for\nx2 = +/-0 and for either or both of x1 and x2 = +/-inf (see\nNotes for specific values).\nThis function is not defined for complex-valued arguments; for the\nso-called argument of complex values, use angle.\n\nParameters\n\nx1array_like, real-valuedy-coordinates.\n\nx2array_like, real-valuedx-coordinates. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nanglendarrayArray of angles in radians, in the range [-pi, pi].\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\n\nSee also\narctan, tan, angle\n\nNotes\narctan2 is identical to the atan2 function of the underlying\nC library.  The following special values are defined in the C\nstandard: [1]\n\n\n\n\n\n\n\nx1\nx2\narctan2(x1,x2)\n\n\n\n+/- 0\n+0\n+/- 0\n\n+/- 0\n-0\n+/- pi\n\n&gt; 0\n+/-inf\n+0 / +pi\n\n&lt; 0\n+/-inf\n-0 / -pi\n\n+/-inf\n+inf\n+/- (pi/4)\n\n+/-inf\n-inf\n+/- (3*pi/4)\n\n\n\nNote that +0 and -0 are distinct floating point numbers, as are +inf\nand -inf.\nReferences\n\n1\nISO/IEC standard 9899:1999, \u201cProgramming language C.\u201d\n\n\nExamples\nConsider four points in different quadrants:\n&gt;&gt;&gt; x = np.array([-1, +1, +1, -1])\n&gt;&gt;&gt; y = np.array([-1, -1, +1, +1])\n&gt;&gt;&gt; np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\n\nNote the order of the parameters. arctan2 is defined also when x2 = 0\nand at several other special points, obtaining values in\nthe range [-pi, pi]:\n&gt;&gt;&gt; np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n&gt;&gt;&gt; np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([ 0.        ,  3.14159265,  0.78539816])\n\n\n", "parameters": ["Parameters", "x1array_like, real-valued", "x2array_like, real-valued", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "anglendarray"], "returns": "anglendarrayArray of angles in radians, in the range [-pi, pi].This is a scalar if both x1 and x2 are scalars.", "examples": ["; x = np.array([-1, +1, +1, -1])\n; y = np.array([-1, -1, +1, +1])\n; np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n\n", "; x = np.array([-1, +1, +1, -1])\n; y = np.array([-1, -1, +1, +1])\n; np.arctan2(y, x) * 180 / np.pi\narray([-135.,  -45.,   45.,  135.])\n", "; np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n; np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([ 0.        ,  3.14159265,  0.78539816])\n\n", "; np.arctan2([1., -1.], [0., 0.])\narray([ 1.57079633, -1.57079633])\n; np.arctan2([0., 0., np.inf], [+0., -0., np.inf])\narray([ 0.        ,  3.14159265,  0.78539816])\n"]},
{"library": "numpy", "item_id": "numpy.arcsinh", "code": "\nnumpy.arcsinh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arcsinh'&gt;\u00b6", "description": "Inverse hyperbolic sine element-wise.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarArray of the same shape as x.\nThis is a scalar if x is a scalar.\n\n\n\n\nNotes\narcsinh is a multivalued function: for each x there are infinitely\nmany numbers z such that sinh(z) = x. The convention is to return the\nz whose imaginary part lies in [-pi/2, pi/2].\nFor real-valued input data types, arcsinh always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nreturns nan and sets the invalid floating point error flag.\nFor complex-valued input, arccos is a complex analytical function that\nhas branch cuts [1j, infj] and [-1j, -infj] and is continuous from\nthe right on the former and from the left on the latter.\nThe inverse hyperbolic sine is also known as asinh or sinh^-1.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cInverse hyperbolic function\u201d,\nhttps://en.wikipedia.org/wiki/Arcsinh\n\n\nExamples\n&gt;&gt;&gt; np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarArray of the same shape as x.This is a scalar if x is a scalar.", "examples": ["; np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])\n\n", "; np.arcsinh(np.array([np.e, 10.0]))\narray([ 1.72538256,  2.99822295])\n"]},
{"library": "numpy", "item_id": "numpy.arcsin", "code": "\nnumpy.arcsin(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arcsin'&gt;\u00b6", "description": "Inverse sine, element-wise.\n\nParameters\n\nxarray_likey-coordinate on the unit circle.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nanglendarrayThe inverse sine of each element in x, in radians and in the\nclosed interval [-pi/2, pi/2].\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\nsin, cos, arccos, tan, arctan, arctan2, emath.arcsin\n\nNotes\narcsin is a multivalued function: for each x there are infinitely\nmany numbers z such that .  The convention is to\nreturn the angle z whose real part lies in [-pi/2, pi/2].\nFor real-valued input data types, arcsin always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, arcsin is a complex analytic function that\nhas, by convention, the branch cuts [-inf, -1] and [1, inf]  and is\ncontinuous from above on the former and from below on the latter.\nThe inverse sine is also known as asin or sin^{-1}.\nReferences\nAbramowitz, M. and Stegun, I. A., Handbook of Mathematical Functions,\n10th printing, New York: Dover, 1964, pp. 79ff.\nhttp://www.math.sfu.ca/~cbm/aands/\nExamples\n&gt;&gt;&gt; np.arcsin(1)     # pi/2\n1.5707963267948966\n&gt;&gt;&gt; np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n&gt;&gt;&gt; np.arcsin(0)\n0.0\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "anglendarray"], "returns": "anglendarrayThe inverse sine of each element in x, in radians and in theclosed interval [-pi/2, pi/2].This is a scalar if x is a scalar.", "examples": ["; np.arcsin(1)     # pi/2\n1.5707963267948966\n; np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n; np.arcsin(0)\n0.0\n\n", "; np.arcsin(1)     # pi/2\n1.5707963267948966\n; np.arcsin(-1)    # -pi/2\n-1.5707963267948966\n; np.arcsin(0)\n0.0\n"]},
{"library": "numpy", "item_id": "numpy.arccosh", "code": "\nnumpy.arccosh(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arccosh'&gt;\u00b6", "description": "Inverse hyperbolic cosine, element-wise.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\narccoshndarrayArray of the same shape as x.\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\ncosh, arcsinh, sinh, arctanh, tanh\n\nNotes\narccosh is a multivalued function: for each x there are infinitely\nmany numbers z such that cosh(z) = x. The convention is to return the\nz whose imaginary part lies in [-pi, pi] and the real part in\n[0, inf].\nFor real-valued input data types, arccosh always returns real output.\nFor each value that cannot be expressed as a real number or infinity, it\nyields nan and sets the invalid floating point error flag.\nFor complex-valued input, arccosh is a complex analytical function that\nhas a branch cut [-inf, 1] and is continuous from above on it.\nReferences\n\n1\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 86. http://www.math.sfu.ca/~cbm/aands/\n\n2\nWikipedia, \u201cInverse hyperbolic function\u201d,\nhttps://en.wikipedia.org/wiki/Arccosh\n\n\nExamples\n&gt;&gt;&gt; np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n&gt;&gt;&gt; np.arccosh(1)\n0.0\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "arccoshndarray"], "returns": "arccoshndarrayArray of the same shape as x.This is a scalar if x is a scalar.", "examples": ["; np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n; np.arccosh(1)\n0.0\n\n", "; np.arccosh([np.e, 10.0])\narray([ 1.65745445,  2.99322285])\n; np.arccosh(1)\n0.0\n"]},
{"library": "numpy", "item_id": "numpy.arctan", "code": "\nnumpy.arctan(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arctan'&gt;\u00b6", "description": "Trigonometric inverse tangent, element-wise.\nThe inverse of tan, so that if y = tan(x) then x = arctan(y).\n\nParameters\n\nxarray_like\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\noutndarray or scalarOut has the same shape as x.  Its real part is in\n[-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2).\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\n\narctan2The \u201cfour quadrant\u201d arctan of the angle formed by (x, y) and the positive x-axis.\n\nangleArgument of complex values.\n\n\n\nNotes\narctan is a multi-valued function: for each x there are infinitely\nmany numbers z such that tan(z) = x.  The convention is to return\nthe angle z whose real part lies in [-pi/2, pi/2].\nFor real-valued input data types, arctan always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, arctan is a complex analytic function that\nhas [1j, infj] and [-1j, -infj] as branch cuts, and is continuous\nfrom the left on the former and from the right on the latter.\nThe inverse tangent is also known as atan or tan^{-1}.\nReferences\nAbramowitz, M. and Stegun, I. A., Handbook of Mathematical Functions,\n10th printing, New York: Dover, 1964, pp. 79.\nhttp://www.math.sfu.ca/~cbm/aands/\nExamples\nWe expect the arctan of 0 to be 0, and of 1 to be pi/4:\n&gt;&gt;&gt; np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n\n&gt;&gt;&gt; np.pi/4\n0.78539816339744828\n\n\nPlot arctan:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.linspace(-10, 10)\n&gt;&gt;&gt; plt.plot(x, np.arctan(x))\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "outndarray or scalar"], "returns": "outndarray or scalarOut has the same shape as x.  Its real part is in[-pi/2, pi/2] (arctan(+/-inf) returns +/-pi/2).This is a scalar if x is a scalar.", "examples": ["; np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n\n", "; np.arctan([0, 1])\narray([ 0.        ,  0.78539816])\n", "; np.pi/4\n0.78539816339744828\n\n", "; np.pi/4\n0.78539816339744828\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-10, 10)\n; plt.plot(x, np.arctan(x))\n; plt.axis('tight')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-10, 10)\n; plt.plot(x, np.arctan(x))\n; plt.axis('tight')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.arccos", "code": "\nnumpy.arccos(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'arccos'&gt;\u00b6", "description": "Trigonometric inverse cosine, element-wise.\nThe inverse of cos so that, if y = cos(x), then x = arccos(y).\n\nParameters\n\nxarray_likex-coordinate on the unit circle.\nFor real arguments, the domain is [-1, 1].\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nanglendarrayThe angle of the ray intersecting the unit circle at the given\nx-coordinate in radians [0, pi].\nThis is a scalar if x is a scalar.\n\n\n\n\n\nSee also\ncos, arctan, arcsin, emath.arccos\n\nNotes\narccos is a multivalued function: for each x there are infinitely\nmany numbers z such that cos(z) = x. The convention is to return\nthe angle z whose real part lies in [0, pi].\nFor real-valued input data types, arccos always returns real output.\nFor each value that cannot be expressed as a real number or infinity,\nit yields nan and sets the invalid floating point error flag.\nFor complex-valued input, arccos is a complex analytic function that\nhas branch cuts [-inf, -1] and [1, inf] and is continuous from\nabove on the former and from below on the latter.\nThe inverse cos is also known as acos or cos^-1.\nReferences\nM. Abramowitz and I.A. Stegun, \u201cHandbook of Mathematical Functions\u201d,\n10th printing, 1964, pp. 79. http://www.math.sfu.ca/~cbm/aands/\nExamples\nWe expect the arccos of 1 to be 0, and of -1 to be pi:\n&gt;&gt;&gt; np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\n\nPlot arccos:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; x = np.linspace(-1, 1, num=100)\n&gt;&gt;&gt; plt.plot(x, np.arccos(x))\n&gt;&gt;&gt; plt.axis('tight')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "anglendarray"], "returns": "anglendarrayThe angle of the ray intersecting the unit circle at the givenx-coordinate in radians [0, pi].This is a scalar if x is a scalar.", "examples": ["; np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n\n", "; np.arccos([1, -1])\narray([ 0.        ,  3.14159265])\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-1, 1, num=100)\n; plt.plot(x, np.arccos(x))\n; plt.axis('tight')\n; plt.show()\n\n", "; import matplotlib.pyplot as plt\n; x = np.linspace(-1, 1, num=100)\n; plt.plot(x, np.arccos(x))\n; plt.axis('tight')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.arange", "code": "\nnumpy.arange([start, ]stop, [step, ]dtype=None)\u00b6", "description": "Return evenly spaced values within a given interval.\nValues are generated within the half-open interval [start, stop)\n(in other words, the interval including start but excluding stop).\nFor integer arguments the function is equivalent to the Python built-in\nrange function, but returns an ndarray rather than a list.\nWhen using a non-integer step, such as 0.1, the results will often not\nbe consistent.  It is better to use numpy.linspace for these cases.\n\nParameters\n\nstartnumber, optionalStart of interval.  The interval includes this value.  The default\nstart value is 0.\n\nstopnumberEnd of interval.  The interval does not include this value, except\nin some cases where step is not an integer and floating point\nround-off affects the length of out.\n\nstepnumber, optionalSpacing between values.  For any output out, this is the distance\nbetween two adjacent values, out[i+1] - out[i].  The default\nstep size is 1.  If step is specified as a position argument,\nstart must also be given.\n\ndtypedtypeThe type of the output array.  If dtype is not given, infer the data\ntype from the other input arguments.\n\n\n\nReturns\n\narangendarrayArray of evenly spaced values.\nFor floating point arguments, the length of the result is\nceil((stop - start)/step).  Because of floating point overflow,\nthis rule may result in the last element of out being greater\nthan stop.\n\n\n\n\n\nSee also\n\nnumpy.linspaceEvenly spaced numbers with careful handling of endpoints.\n\nnumpy.ogridArrays of evenly spaced numbers in N-dimensions.\n\nnumpy.mgridGrid-shaped arrays of evenly spaced numbers in N-dimensions.\n\n\n\nExamples\n&gt;&gt;&gt; np.arange(3)\narray([0, 1, 2])\n&gt;&gt;&gt; np.arange(3.0)\narray([ 0.,  1.,  2.])\n&gt;&gt;&gt; np.arange(3,7)\narray([3, 4, 5, 6])\n&gt;&gt;&gt; np.arange(3,7,2)\narray([3, 5])\n\n\n", "parameters": ["Parameters", "startnumber, optional", "stopnumber", "stepnumber, optional", "dtypedtype", "Returns", "arangendarray"], "returns": "arangendarrayArray of evenly spaced values.For floating point arguments, the length of the result isceil((stop - start)/step).  Because of floating point overflow,this rule may result in the last element of out being greaterthan stop.", "examples": ["; np.arange(3)\narray([0, 1, 2])\n; np.arange(3.0)\narray([ 0.,  1.,  2.])\n; np.arange(3,7)\narray([3, 4, 5, 6])\n; np.arange(3,7,2)\narray([3, 5])\n\n", "; np.arange(3)\narray([0, 1, 2])\n; np.arange(3.0)\narray([ 0.,  1.,  2.])\n; np.arange(3,7)\narray([3, 4, 5, 6])\n; np.arange(3,7,2)\narray([3, 5])\n"]},
{"library": "numpy", "item_id": "numpy.ma.arange", "code": "\nnumpy.ma.arange([start, ]stop, [step, ]dtype=None) = &lt;numpy.ma.core._convert2ma object&gt;\u00b6", "description": "Return evenly spaced values within a given interval.\nValues are generated within the half-open interval [start, stop)\n(in other words, the interval including start but excluding stop).\nFor integer arguments the function is equivalent to the Python built-in\nrange function, but returns an ndarray rather than a list.\nWhen using a non-integer step, such as 0.1, the results will often not\nbe consistent.  It is better to use numpy.linspace for these cases.\n\nParameters\n\nstartnumber, optionalStart of interval.  The interval includes this value.  The default\nstart value is 0.\n\nstopnumberEnd of interval.  The interval does not include this value, except\nin some cases where step is not an integer and floating point\nround-off affects the length of out.\n\nstepnumber, optionalSpacing between values.  For any output out, this is the distance\nbetween two adjacent values, out[i+1] - out[i].  The default\nstep size is 1.  If step is specified as a position argument,\nstart must also be given.\n\ndtypedtypeThe type of the output array.  If dtype is not given, infer the data\ntype from the other input arguments.\n\n\n\nReturns\n\narangendarrayArray of evenly spaced values.\nFor floating point arguments, the length of the result is\nceil((stop - start)/step).  Because of floating point overflow,\nthis rule may result in the last element of out being greater\nthan stop.\n\n\n\n\n\nSee also\n\nnumpy.linspaceEvenly spaced numbers with careful handling of endpoints.\n\nnumpy.ogridArrays of evenly spaced numbers in N-dimensions.\n\nnumpy.mgridGrid-shaped arrays of evenly spaced numbers in N-dimensions.\n\n\n\nExamples\n&gt;&gt;&gt; np.arange(3)\narray([0, 1, 2])\n&gt;&gt;&gt; np.arange(3.0)\narray([ 0.,  1.,  2.])\n&gt;&gt;&gt; np.arange(3,7)\narray([3, 4, 5, 6])\n&gt;&gt;&gt; np.arange(3,7,2)\narray([3, 5])\n\n\n", "parameters": ["Parameters", "startnumber, optional", "stopnumber", "stepnumber, optional", "dtypedtype", "Returns", "arangendarray"], "returns": "arangendarrayArray of evenly spaced values.For floating point arguments, the length of the result isceil((stop - start)/step).  Because of floating point overflow,this rule may result in the last element of out being greaterthan stop.", "examples": ["; np.arange(3)\narray([0, 1, 2])\n; np.arange(3.0)\narray([ 0.,  1.,  2.])\n; np.arange(3,7)\narray([3, 4, 5, 6])\n; np.arange(3,7,2)\narray([3, 5])\n\n", "; np.arange(3)\narray([0, 1, 2])\n; np.arange(3.0)\narray([ 0.,  1.,  2.])\n; np.arange(3,7)\narray([3, 4, 5, 6])\n; np.arange(3,7,2)\narray([3, 5])\n"]},
{"library": "numpy", "item_id": "numpy.ma.apply_along_axis", "code": "\nnumpy.ma.apply_along_axis(func1d, axis, arr, *args, **kwargs)[source]\u00b6", "description": "Apply a function to 1-D slices along the given axis.\nExecute func1d(a, *args) where func1d operates on 1-D arrays and a\nis a 1-D slice of arr along axis.\nThis is equivalent to (but faster than) the following use of ndindex and\ns_, which sets each of ii, jj, and kk to a tuple of indices:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        f = func1d(arr[ii + s_[:,] + kk])\n        Nj = f.shape\n        for jj in ndindex(Nj):\n            out[ii + jj + kk] = f[jj]\n\n\nEquivalently, eliminating the inner loop, this can be expressed as:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])\n\n\n\nParameters\n\nfunc1dfunction (M,) -&gt; (Nj\u2026)This function should accept 1-D arrays. It is applied to 1-D\nslices of arr along the specified axis.\n\naxisintegerAxis along which arr is sliced.\n\narrndarray (Ni\u2026, M, Nk\u2026)Input array.\n\nargsanyAdditional arguments to func1d.\n\nkwargsanyAdditional named arguments to func1d.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\noutndarray  (Ni\u2026, Nj\u2026, Nk\u2026)The output array. The shape of out is identical to the shape of\narr, except along the axis dimension. This axis is removed, and\nreplaced with new dimensions equal to the shape of the return value\nof func1d. So if func1d returns a scalar out will have one\nfewer dimensions than arr.\n\n\n\n\n\nSee also\n\napply_over_axesApply a function repeatedly over multiple axes.\n\n\n\nExamples\n&gt;&gt;&gt; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n&gt;&gt;&gt; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n&gt;&gt;&gt; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\n\nFor a function that returns a 1D array, the number of dimensions in\noutarr is the same as arr.\n&gt;&gt;&gt; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n&gt;&gt;&gt; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\n\nFor a function that returns a higher dimensional array, those dimensions\nare inserted in place of the axis dimension.\n&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n&gt;&gt;&gt; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n\n\n", "parameters": ["Parameters", "func1dfunction (M,) -&gt; (Nj\u2026)", "axisinteger", "arrndarray (Ni\u2026, M, Nk\u2026)", "argsany", "kwargsany", "Returns", "outndarray  (Ni\u2026, Nj\u2026, Nk\u2026)"], "returns": "outndarray  (Ni\u2026, Nj\u2026, Nk\u2026)The output array. The shape of out is identical to the shape ofarr, except along the axis dimension. This axis is removed, andreplaced with new dimensions equal to the shape of the return valueof func1d. So if func1d returns a scalar out will have onefewer dimensions than arr.", "examples": ["; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\n", "; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n", "; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\n", "; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n", "; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n\n", "; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n"]},
{"library": "numpy", "item_id": "numpy.apply_over_axes", "code": "\nnumpy.apply_over_axes(func, a, axes)[source]\u00b6", "description": "Apply a function repeatedly over multiple axes.\nfunc is called as res = func(a, axis), where axis is the first\nelement of axes.  The result res of the function call must have\neither the same dimensions as a or one less dimension.  If res\nhas one less dimension than a, a dimension is inserted before\naxis.  The call to func is then repeated for each axis in axes,\nwith res as the first argument.\n\nParameters\n\nfuncfunctionThis function must take two arguments, func(a, axis).\n\naarray_likeInput array.\n\naxesarray_likeAxes over which func is applied; the elements must be integers.\n\n\n\nReturns\n\napply_over_axisndarrayThe output array.  The number of dimensions is the same as a,\nbut the shape can be different.  This depends on whether func\nchanges the shape of its output with respect to its input.\n\n\n\n\n\nSee also\n\napply_along_axisApply a function to 1-D slices of an array along the given axis.\n\n\n\nNotes\nThis function is equivalent to tuple axis arguments to reorderable ufuncs\nwith keepdims=True. Tuple axis arguments to ufuncs have been available since\nversion 1.7.0.\nExamples\n&gt;&gt;&gt; a = np.arange(24).reshape(2,3,4)\n&gt;&gt;&gt; a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n\nSum over axes 0 and 2. The result has same number of dimensions\nas the original array:\n&gt;&gt;&gt; np.apply_over_axes(np.sum, a, [0,2])\narray([[[ 60],\n        [ 92],\n        [124]]])\n\n\nTuple axis arguments to ufuncs are equivalent:\n&gt;&gt;&gt; np.sum(a, axis=(0,2), keepdims=True)\narray([[[ 60],\n        [ 92],\n        [124]]])\n\n\n", "parameters": ["Parameters", "funcfunction", "aarray_like", "axesarray_like", "Returns", "apply_over_axisndarray"], "returns": "apply_over_axisndarrayThe output array.  The number of dimensions is the same as a,but the shape can be different.  This depends on whether funcchanges the shape of its output with respect to its input.", "examples": ["; a = np.arange(24).reshape(2,3,4)\n; a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n\n", "; a = np.arange(24).reshape(2,3,4)\n; a\narray([[[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]],\n       [[12, 13, 14, 15],\n        [16, 17, 18, 19],\n        [20, 21, 22, 23]]])\n", "; np.apply_over_axes(np.sum, a, [0,2])\narray([[[ 60],\n        [ 92],\n        [124]]])\n\n", "; np.apply_over_axes(np.sum, a, [0,2])\narray([[[ 60],\n        [ 92],\n        [124]]])\n", "; np.sum(a, axis=(0,2), keepdims=True)\narray([[[ 60],\n        [ 92],\n        [124]]])\n\n", "; np.sum(a, axis=(0,2), keepdims=True)\narray([[[ 60],\n        [ 92],\n        [124]]])\n"]},
{"library": "numpy", "item_id": "numpy.lib.recfunctions.append_fields", "code": "\nnumpy.lib.recfunctions.append_fields(base, names, data, dtypes=None, fill_value=-1, usemask=True, asrecarray=False)[source]\u00b6", "description": "Add new fields to an existing array.\nThe names of the fields are given with the names arguments,\nthe corresponding values with the data arguments.\nIf a single field is appended, names, data and dtypes do not have\nto be lists but just values.\n\nParameters\n\nbasearrayInput array to extend.\n\nnamesstring, sequenceString or sequence of strings corresponding to the names\nof the new fields.\n\ndataarray or sequence of arraysArray or sequence of arrays storing the fields to add to the base.\n\ndtypessequence of datatypes, optionalDatatype or sequence of datatypes.\nIf None, the datatypes are estimated from the data.\n\nfill_value{float}, optionalFilling value used to pad missing data on the shorter arrays.\n\nusemask{False, True}, optionalWhether to return a masked array or not.\n\nasrecarray{False, True}, optionalWhether to return a recarray (MaskedRecords) or not.\n\n\n\n\n", "parameters": ["Parameters", "basearray", "namesstring, sequence", "dataarray or sequence of arrays", "dtypessequence of datatypes, optional", "fill_value{float}, optional", "usemask{False, True}, optional", "asrecarray{False, True}, optional", "Parameters", "funcfunction", "arrndarray", "Returns", "outndarray", "Parameters", "dstndarray", "srcndarray", "zero_unassignedbool, optional", "Parameters", "basearray", "drop_namesstring or sequence", "usemask{False, True}, optional", "asrecarraystring or sequence, optional", "Parameters", "aarray-like", "key{string, None}, optional", "ignoremask{True, False}, optional", "return_index{False, True}, optional", "Parameters", "adtypenp.dtype", "lastnameoptional", "parentsdictionary", "Parameters", "adtypedtype", "Parameters", "adtypedtype", "Parameters", "key{string, sequence}", "r1, r2arrays", "jointype{\u2018inner\u2019, \u2018outer\u2019, \u2018leftouter\u2019}, optional", "r1postfixstring, optional", "r2postfixstring, optional", "defaults{dictionary}, optional", "usemask{True, False}, optional", "asrecarray{False, True}, optional", "Parameters", "seqarrayssequence of ndarrays", "fill_value{float}, optional", "flatten{False, True}, optional", "usemask{False, True}, optional", "asrecarray{False, True}, optional", "Parameters", "basearray", "namesstring, sequence", "dataarray or sequence of arrays", "dtypessequence of datatypes, optional", "Returns", "appended_arraynp.recarray", "Parameters", "inputndarray", "outputndarray", "Parameters", "basendarray", "namemapperdictionary", "Parameters", "andarray or dtype", "alignboolean", "recurseboolean", "Returns", "repackedndarray or dtype", "Parameters", "andarray", "required_dtypedtype", "Returns", "outndarray", "Parameters", "arraysarray or sequence", "defaultsdictionary, optional", "usemask{True, False}, optional", "asrecarray{False, True}, optional", "autoconvert{False, True}, optional", "Parameters", "arrndarray", "dtypedtype, optional", "copybool, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "Returns", "unstructuredndarray", "Parameters", "arrndarray", "dtypedtype, optional", "nameslist of strings, optional", "alignboolean, optional", "copybool, optional", "casting{\u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, \u2018unsafe\u2019}, optional", "Returns", "structuredndarray"], "returns": "outndarrayResult of the recution operation", "examples": ["; from numpy.lib import recfunctions as rfn\n; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],\n...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])\n; rfn.apply_along_fields(np.mean, b)\narray([ 2.66666667,  5.33333333,  8.66666667, 11.        ])\n; rfn.apply_along_fields(np.mean, b[['x', 'z']])\narray([ 3. ,  5.5,  9. , 11. ])\n\n", "; from numpy.lib import recfunctions as rfn\n; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],\n...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])\n; rfn.apply_along_fields(np.mean, b)\narray([ 2.66666667,  5.33333333,  8.66666667, 11.        ])\n; rfn.apply_along_fields(np.mean, b[['x', 'z']])\narray([ 3. ,  5.5,  9. , 11. ])\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))],\n...   dtype=[('a', np.int64), ('b', [('ba', np.double), ('bb', np.int64)])])\n; rfn.drop_fields(a, 'a')\narray([((2., 3),), ((5., 6),)],\n      dtype=[('b', [('ba', '&lt;f8'), ('bb', '&lt;i8')])])\n; rfn.drop_fields(a, 'ba')\narray([(1, (3,)), (4, (6,))], dtype=[('a', '&lt;i8'), ('b', [('bb', '&lt;i8')])])\n; rfn.drop_fields(a, ['ba', 'bb'])\narray([(1,), (4,)], dtype=[('a', '&lt;i8')])\n\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, (2, 3.0)), (4, (5, 6.0))],\n...   dtype=[('a', np.int64), ('b', [('ba', np.double), ('bb', np.int64)])])\n; rfn.drop_fields(a, 'a')\narray([((2., 3),), ((5., 6),)],\n      dtype=[('b', [('ba', '&lt;f8'), ('bb', '&lt;i8')])])\n; rfn.drop_fields(a, 'ba')\narray([(1, (3,)), (4, (6,))], dtype=[('a', '&lt;i8'), ('b', [('bb', '&lt;i8')])])\n; rfn.drop_fields(a, ['ba', 'bb'])\narray([(1,), (4,)], dtype=[('a', '&lt;i8')])\n", "; from numpy.lib import recfunctions as rfn\n; ndtype = [('a', int)]\n; a = np.ma.array([1, 1, 1, 2, 2, 3, 3],\n...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype)\n; rfn.find_duplicates(a, ignoremask=True, return_index=True)\n(masked_array(data=[(1,), (1,), (2,), (2,)],\n             mask=[(False,), (False,), (False,), (False,)],\n       fill_value=(999999,),\n            dtype=[('a', '&lt;i8')]), array([0, 1, 3, 4]))\n\n", "; from numpy.lib import recfunctions as rfn\n; ndtype = [('a', int)]\n; a = np.ma.array([1, 1, 1, 2, 2, 3, 3],\n...         mask=[0, 0, 1, 0, 0, 0, 1]).view(ndtype)\n; rfn.find_duplicates(a, ignoremask=True, return_index=True)\n(masked_array(data=[(1,), (1,), (2,), (2,)],\n             mask=[(False,), (False,), (False,), (False,)],\n       fill_value=(999999,),\n            dtype=[('a', '&lt;i8')]), array([0, 1, 3, 4]))\n", "; from numpy.lib import recfunctions as rfn\n; ndtype = np.dtype([('a', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])])\n; rfn.flatten_descr(ndtype)\n(('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))\n\n", "; from numpy.lib import recfunctions as rfn\n; ndtype = np.dtype([('a', '&lt;i4'), ('b', [('ba', '&lt;f8'), ('bb', '&lt;i4')])])\n; rfn.flatten_descr(ndtype)\n(('a', dtype('int32')), ('ba', dtype('float64')), ('bb', dtype('int32')))\n", "; from numpy.lib import recfunctions as rfn\n; ndtype =  np.dtype([('A', int),\n...                     ('B', [('BA', int),\n...                            ('BB', [('BBA', int), ('BBB', int)])])])\n; rfn.get_fieldstructure(ndtype)\n... # XXX: possible regression, order of BBA and BBB is swapped\n{'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}\n\n", "; from numpy.lib import recfunctions as rfn\n; ndtype =  np.dtype([('A', int),\n...                     ('B', [('BA', int),\n...                            ('BB', [('BBA', int), ('BBB', int)])])])\n; rfn.get_fieldstructure(ndtype)\n... # XXX: possible regression, order of BBA and BBB is swapped\n{'A': [], 'B': [], 'BA': ['B'], 'BB': ['B'], 'BBA': ['B', 'BB'], 'BBB': ['B', 'BB']}\n", "; from numpy.lib import recfunctions as rfn\n; rfn.get_names(np.empty((1,), dtype=int))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n\n", "; from numpy.lib import recfunctions as rfn\n; rfn.get_names(np.empty((1,), dtype=int))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n", "; rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)]))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])\n; rfn.get_names(adtype)\n('a', ('b', ('ba', 'bb')))\n\n", "; rfn.get_names(np.empty((1,), dtype=[('A',int), ('B', float)]))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])\n; rfn.get_names(adtype)\n('a', ('b', ('ba', 'bb')))\n", "; from numpy.lib import recfunctions as rfn\n; rfn.get_names_flat(np.empty((1,), dtype=int)) is None\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', float)]))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])\n; rfn.get_names_flat(adtype)\n('a', 'b', 'ba', 'bb')\n\n", "; from numpy.lib import recfunctions as rfn\n; rfn.get_names_flat(np.empty((1,), dtype=int)) is None\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; rfn.get_names_flat(np.empty((1,), dtype=[('A',int), ('B', float)]))\nTraceback (most recent call last):\n    ...\nAttributeError: 'numpy.ndarray' object has no attribute 'names'\n; adtype = np.dtype([('a', int), ('b', [('ba', int), ('bb', int)])])\n; rfn.get_names_flat(adtype)\n('a', 'b', 'ba', 'bb')\n", "; from numpy.lib import recfunctions as rfn\n; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))\narray([( 1, 10.), ( 2, 20.), (-1, 30.)],\n      dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])\n\n", "; from numpy.lib import recfunctions as rfn\n; rfn.merge_arrays((np.array([1, 2]), np.array([10., 20., 30.])))\narray([( 1, 10.), ( 2, 20.), (-1, 30.)],\n      dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])\n", "; rfn.merge_arrays((np.array([1, 2], dtype=np.int64),\n...         np.array([10., 20., 30.])), usemask=False)\n array([(1, 10.0), (2, 20.0), (-1, 30.0)],\n         dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])\n; rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]),\n...               np.array([10., 20., 30.])),\n...              usemask=False, asrecarray=True)\nrec.array([( 1, 10.), ( 2, 20.), (-1, 30.)],\n          dtype=[('a', '&lt;i8'), ('f1', '&lt;f8')])\n\n", "; rfn.merge_arrays((np.array([1, 2], dtype=np.int64),\n...         np.array([10., 20., 30.])), usemask=False)\n array([(1, 10.0), (2, 20.0), (-1, 30.0)],\n         dtype=[('f0', '&lt;i8'), ('f1', '&lt;f8')])\n; rfn.merge_arrays((np.array([1, 2]).view([('a', np.int64)]),\n...               np.array([10., 20., 30.])),\n...              usemask=False, asrecarray=True)\nrec.array([( 1, 10.), ( 2, 20.), (-1, 30.)],\n          dtype=[('a', '&lt;i8'), ('f1', '&lt;f8')])\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)])\n; b = np.zeros((3,), dtype=a.dtype)\n; rfn.recursive_fill_fields(a, b)\narray([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A', '&lt;i8'), ('B', '&lt;f8')])\n\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, 10.), (2, 20.)], dtype=[('A', np.int64), ('B', np.float64)])\n; b = np.zeros((3,), dtype=a.dtype)\n; rfn.recursive_fill_fields(a, b)\narray([(1, 10.), (2, 20.), (0,  0.)], dtype=[('A', '&lt;i8'), ('B', '&lt;f8')])\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))],\n...   dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])])\n; rfn.rename_fields(a, {'a':'A', 'bb':'BB'})\narray([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))],\n      dtype=[('A', '&lt;i8'), ('b', [('ba', '&lt;f8'), ('BB', '&lt;f8', (2,))])])\n\n", "; from numpy.lib import recfunctions as rfn\n; a = np.array([(1, (2, [3.0, 30.])), (4, (5, [6.0, 60.]))],\n...   dtype=[('a', int),('b', [('ba', float), ('bb', (float, 2))])])\n; rfn.rename_fields(a, {'a':'A', 'bb':'BB'})\narray([(1, (2., [ 3., 30.])), (4, (5., [ 6., 60.]))],\n      dtype=[('A', '&lt;i8'), ('b', [('ba', '&lt;f8'), ('BB', '&lt;f8', (2,))])])\n", "; from numpy.lib import recfunctions as rfn\n; def print_offsets(d):\n...     print(\"offsets:\", [d.fields[name][1] for name in d.names])\n...     print(\"itemsize:\", d.itemsize)\n...\n; dt = np.dtype('u1, &lt;i8, &lt;f8', align=True)\n; dt\ndtype({'names':['f0','f1','f2'], 'formats':['u1','&lt;i8','&lt;f8'], 'offsets':[0,8,16], 'itemsize':24}, align=True)\n; print_offsets(dt)\noffsets: [0, 8, 16]\nitemsize: 24\n; packed_dt = rfn.repack_fields(dt)\n; packed_dt\ndtype([('f0', 'u1'), ('f1', '&lt;i8'), ('f2', '&lt;f8')])\n; print_offsets(packed_dt)\noffsets: [0, 1, 9]\nitemsize: 17\n\n", "; from numpy.lib import recfunctions as rfn\n; def print_offsets(d):\n...     print(\"offsets:\", [d.fields[name][1] for name in d.names])\n...     print(\"itemsize:\", d.itemsize)\n...\n; dt = np.dtype('u1, &lt;i8, &lt;f8', align=True)\n; dt\ndtype({'names':['f0','f1','f2'], 'formats':['u1','&lt;i8','&lt;f8'], 'offsets':[0,8,16], 'itemsize':24}, align=True)\n; print_offsets(dt)\noffsets: [0, 8, 16]\nitemsize: 24\n; packed_dt = rfn.repack_fields(dt)\n; packed_dt\ndtype([('f0', 'u1'), ('f1', '&lt;i8'), ('f2', '&lt;f8')])\n; print_offsets(packed_dt)\noffsets: [0, 1, 9]\nitemsize: 17\n", "; from numpy.lib import recfunctions as rfn\n; a = np.ones(4, dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'u1')])\n; rfn.require_fields(a, [('b', 'f4'), ('c', 'u1')])\narray([(1., 1), (1., 1), (1., 1), (1., 1)],\n  dtype=[('b', '&lt;f4'), ('c', 'u1')])\n; rfn.require_fields(a, [('b', 'f4'), ('newf', 'u1')])\narray([(1., 0), (1., 0), (1., 0), (1., 0)],\n  dtype=[('b', '&lt;f4'), ('newf', 'u1')])\n\n", "; from numpy.lib import recfunctions as rfn\n; a = np.ones(4, dtype=[('a', 'i4'), ('b', 'f8'), ('c', 'u1')])\n; rfn.require_fields(a, [('b', 'f4'), ('c', 'u1')])\narray([(1., 1), (1., 1), (1., 1), (1., 1)],\n  dtype=[('b', '&lt;f4'), ('c', 'u1')])\n; rfn.require_fields(a, [('b', 'f4'), ('newf', 'u1')])\narray([(1., 0), (1., 0), (1., 0), (1., 0)],\n  dtype=[('b', '&lt;f4'), ('newf', 'u1')])\n", "; from numpy.lib import recfunctions as rfn\n; x = np.array([1, 2,])\n; rfn.stack_arrays(x) is x\nTrue\n; z = np.array([('A', 1), ('B', 2)], dtype=[('A', '|S3'), ('B', float)])\n; zz = np.array([('a', 10., 100.), ('b', 20., 200.), ('c', 30., 300.)],\n...   dtype=[('A', '|S3'), ('B', np.double), ('C', np.double)])\n; test = rfn.stack_arrays((z,zz))\n; test\nmasked_array(data=[(b'A', 1.0, --), (b'B', 2.0, --), (b'a', 10.0, 100.0),\n                   (b'b', 20.0, 200.0), (b'c', 30.0, 300.0)],\n             mask=[(False, False,  True), (False, False,  True),\n                   (False, False, False), (False, False, False),\n                   (False, False, False)],\n       fill_value=(b'N/A', 1.e+20, 1.e+20),\n            dtype=[('A', 'S3'), ('B', '&lt;f8'), ('C', '&lt;f8')])\n\n", "; from numpy.lib import recfunctions as rfn\n; x = np.array([1, 2,])\n; rfn.stack_arrays(x) is x\nTrue\n; z = np.array([('A', 1), ('B', 2)], dtype=[('A', '|S3'), ('B', float)])\n; zz = np.array([('a', 10., 100.), ('b', 20., 200.), ('c', 30., 300.)],\n...   dtype=[('A', '|S3'), ('B', np.double), ('C', np.double)])\n; test = rfn.stack_arrays((z,zz))\n; test\nmasked_array(data=[(b'A', 1.0, --), (b'B', 2.0, --), (b'a', 10.0, 100.0),\n                   (b'b', 20.0, 200.0), (b'c', 30.0, 300.0)],\n             mask=[(False, False,  True), (False, False,  True),\n                   (False, False, False), (False, False, False),\n                   (False, False, False)],\n       fill_value=(b'N/A', 1.e+20, 1.e+20),\n            dtype=[('A', 'S3'), ('B', '&lt;f8'), ('C', '&lt;f8')])\n", "; from numpy.lib import recfunctions as rfn\n; a = np.zeros(4, dtype=[('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])\n; a\narray([(0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.]),\n       (0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.])],\n      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])\n; rfn.structured_to_unstructured(a)\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n\n", "; from numpy.lib import recfunctions as rfn\n; a = np.zeros(4, dtype=[('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])\n; a\narray([(0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.]),\n       (0, (0., 0), [0., 0.]), (0, (0., 0), [0., 0.])],\n      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])\n; rfn.structured_to_unstructured(a)\narray([[0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0.]])\n", "; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],\n...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])\n; np.mean(rfn.structured_to_unstructured(b[['x', 'z']]), axis=-1)\narray([ 3. ,  5.5,  9. , 11. ])\n\n", "; b = np.array([(1, 2, 5), (4, 5, 7), (7, 8 ,11), (10, 11, 12)],\n...              dtype=[('x', 'i4'), ('y', 'f4'), ('z', 'f8')])\n; np.mean(rfn.structured_to_unstructured(b[['x', 'z']]), axis=-1)\narray([ 3. ,  5.5,  9. , 11. ])\n", "; from numpy.lib import recfunctions as rfn\n; dt = np.dtype([('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])\n; a = np.arange(20).reshape((4,5))\n; a\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n; rfn.unstructured_to_structured(a, dt)\narray([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]),\n       (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])],\n      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])\n\n", "; from numpy.lib import recfunctions as rfn\n; dt = np.dtype([('a', 'i4'), ('b', 'f4,u2'), ('c', 'f4', 2)])\n; a = np.arange(20).reshape((4,5))\n; a\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14],\n       [15, 16, 17, 18, 19]])\n; rfn.unstructured_to_structured(a, dt)\narray([( 0, ( 1.,  2), [ 3.,  4.]), ( 5, ( 6.,  7), [ 8.,  9.]),\n       (10, (11., 12), [13., 14.]), (15, (16., 17), [18., 19.])],\n      dtype=[('a', '&lt;i4'), ('b', [('f0', '&lt;f4'), ('f1', '&lt;u2')]), ('c', '&lt;f4', (2,))])\n"]},
{"library": "numpy", "item_id": "numpy.ma.append", "code": "\nnumpy.ma.append(a, b, axis=None)[source]\u00b6", "description": "Append values to the end of an array.\n\nNew in version 1.9.0.\n\n\nParameters\n\naarray_likeValues are appended to a copy of this array.\n\nbarray_likeThese values are appended to a copy of a.  It must be of the\ncorrect shape (the same shape as a, excluding axis).  If axis\nis not specified, b can be any shape and will be flattened\nbefore use.\n\naxisint, optionalThe axis along which v are appended.  If axis is not given,\nboth a and b are flattened before use.\n\n\n\nReturns\n\nappendMaskedArrayA copy of a with b appended to axis.  Note that append\ndoes not occur in-place: a new array is allocated and filled.  If\naxis is None, the result is a flattened array.\n\n\n\n\n\nSee also\n\nnumpy.appendEquivalent function in the top-level NumPy module.\n\n\n\nExamples\n&gt;&gt;&gt; import numpy.ma as ma\n&gt;&gt;&gt; a = ma.masked_values([1, 2, 3], 2)\n&gt;&gt;&gt; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n&gt;&gt;&gt; ma.append(a, b)\nmasked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],\n             mask=[False,  True, False, False, False, False,  True, False,\n                   False],\n       fill_value=999999)\n\n\n", "parameters": ["Parameters", "aarray_like", "barray_like", "axisint, optional", "Returns", "appendMaskedArray"], "returns": "appendMaskedArrayA copy of a with b appended to axis.  Note that appenddoes not occur in-place: a new array is allocated and filled.  Ifaxis is None, the result is a flattened array.", "examples": ["; import numpy.ma as ma\n; a = ma.masked_values([1, 2, 3], 2)\n; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n; ma.append(a, b)\nmasked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],\n             mask=[False,  True, False, False, False, False,  True, False,\n                   False],\n       fill_value=999999)\n\n", "; import numpy.ma as ma\n; a = ma.masked_values([1, 2, 3], 2)\n; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)\n; ma.append(a, b)\nmasked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],\n             mask=[False,  True, False, False, False, False,  True, False,\n                   False],\n       fill_value=999999)\n"]},
{"library": "numpy", "item_id": "numpy.apply_along_axis", "code": "\nnumpy.apply_along_axis(func1d, axis, arr, *args, **kwargs)[source]\u00b6", "description": "Apply a function to 1-D slices along the given axis.\nExecute func1d(a, *args) where func1d operates on 1-D arrays and a\nis a 1-D slice of arr along axis.\nThis is equivalent to (but faster than) the following use of ndindex and\ns_, which sets each of ii, jj, and kk to a tuple of indices:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        f = func1d(arr[ii + s_[:,] + kk])\n        Nj = f.shape\n        for jj in ndindex(Nj):\n            out[ii + jj + kk] = f[jj]\n\n\nEquivalently, eliminating the inner loop, this can be expressed as:\nNi, Nk = a.shape[:axis], a.shape[axis+1:]\nfor ii in ndindex(Ni):\n    for kk in ndindex(Nk):\n        out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])\n\n\n\nParameters\n\nfunc1dfunction (M,) -&gt; (Nj\u2026)This function should accept 1-D arrays. It is applied to 1-D\nslices of arr along the specified axis.\n\naxisintegerAxis along which arr is sliced.\n\narrndarray (Ni\u2026, M, Nk\u2026)Input array.\n\nargsanyAdditional arguments to func1d.\n\nkwargsanyAdditional named arguments to func1d.\n\nNew in version 1.9.0.\n\n\n\n\nReturns\n\noutndarray  (Ni\u2026, Nj\u2026, Nk\u2026)The output array. The shape of out is identical to the shape of\narr, except along the axis dimension. This axis is removed, and\nreplaced with new dimensions equal to the shape of the return value\nof func1d. So if func1d returns a scalar out will have one\nfewer dimensions than arr.\n\n\n\n\n\nSee also\n\napply_over_axesApply a function repeatedly over multiple axes.\n\n\n\nExamples\n&gt;&gt;&gt; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n&gt;&gt;&gt; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n&gt;&gt;&gt; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\n\nFor a function that returns a 1D array, the number of dimensions in\noutarr is the same as arr.\n&gt;&gt;&gt; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n&gt;&gt;&gt; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\n\nFor a function that returns a higher dimensional array, those dimensions\nare inserted in place of the axis dimension.\n&gt;&gt;&gt; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n&gt;&gt;&gt; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n\n\n", "parameters": ["Parameters", "func1dfunction (M,) -&gt; (Nj\u2026)", "axisinteger", "arrndarray (Ni\u2026, M, Nk\u2026)", "argsany", "kwargsany", "Returns", "outndarray  (Ni\u2026, Nj\u2026, Nk\u2026)"], "returns": "outndarray  (Ni\u2026, Nj\u2026, Nk\u2026)The output array. The shape of out is identical to the shape ofarr, except along the axis dimension. This axis is removed, andreplaced with new dimensions equal to the shape of the return valueof func1d. So if func1d returns a scalar out will have onefewer dimensions than arr.", "examples": ["; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n\n", "; def my_func(a):\n...     \"\"\"Average first and last element of a 1-D array\"\"\"\n...     return (a[0] + a[-1]) * 0.5\n; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(my_func, 0, b)\narray([4., 5., 6.])\n; np.apply_along_axis(my_func, 1, b)\narray([2.,  5.,  8.])\n", "; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n\n", "; b = np.array([[8,1,7], [4,3,9], [5,2,6]])\n; np.apply_along_axis(sorted, 1, b)\narray([[1, 7, 8],\n       [3, 4, 9],\n       [2, 5, 6]])\n", "; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n\n", "; b = np.array([[1,2,3], [4,5,6], [7,8,9]])\n; np.apply_along_axis(np.diag, -1, b)\narray([[[1, 0, 0],\n        [0, 2, 0],\n        [0, 0, 3]],\n       [[4, 0, 0],\n        [0, 5, 0],\n        [0, 0, 6]],\n       [[7, 0, 0],\n        [0, 8, 0],\n        [0, 0, 9]]])\n"]},
{"library": "numpy", "item_id": "numpy.append", "code": "\nnumpy.append(arr, values, axis=None)[source]\u00b6", "description": "Append values to the end of an array.\n\nParameters\n\narrarray_likeValues are appended to a copy of this array.\n\nvaluesarray_likeThese values are appended to a copy of arr.  It must be of the\ncorrect shape (the same shape as arr, excluding axis).  If\naxis is not specified, values can be any shape and will be\nflattened before use.\n\naxisint, optionalThe axis along which values are appended.  If axis is not\ngiven, both arr and values are flattened before use.\n\n\n\nReturns\n\nappendndarrayA copy of arr with values appended to axis.  Note that\nappend does not occur in-place: a new array is allocated and\nfilled.  If axis is None, out is a flattened array.\n\n\n\n\n\nSee also\n\ninsertInsert elements into an array.\n\ndeleteDelete elements from an array.\n\n\n\nExamples\n&gt;&gt;&gt; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, ..., 7, 8, 9])\n\n\nWhen axis is specified, values must have the correct shape.\n&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n&gt;&gt;&gt; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\nTraceback (most recent call last):\n    ...\nValueError: all the input arrays must have same number of dimensions\n\n\n", "parameters": ["Parameters", "arrarray_like", "valuesarray_like", "axisint, optional", "Returns", "appendndarray"], "returns": "appendndarrayA copy of arr with values appended to axis.  Note thatappend does not occur in-place: a new array is allocated andfilled.  If axis is None, out is a flattened array.", "examples": ["; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, ..., 7, 8, 9])\n\n", "; np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])\narray([1, 2, 3, ..., 7, 8, 9])\n", "; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\nTraceback (most recent call last):\n    ...\nValueError: all the input arrays must have same number of dimensions\n\n", "; np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n; np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)\nTraceback (most recent call last):\n    ...\nValueError: all the input arrays must have same number of dimensions\n"]},
{"library": "numpy", "item_id": "numpy.record.any", "code": "\nrecord.any()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskType.any", "code": "\nMaskType.any()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.any", "code": "\nrecarray.any(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.any", "code": "\nndarray.any(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.any", "code": "\nMaskedArray.any(self, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nMasked values are considered as False during computation.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.ndarray.anycorresponding function for ndarrays\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.any", "code": "\ngeneric.any()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.any", "code": "\nmasked_array.any(self, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nMasked values are considered as False during computation.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.ndarray.anycorresponding function for ndarrays\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.any", "code": "\nmatrix.any(self, axis=None, out=None)[source]\u00b6", "description": "Test whether any array element along a given axis evaluates to True.\nRefer to numpy.any for full documentation.\n\nParameters\n\naxisint, optionalAxis along which logical OR is performed\n\noutndarray, optionalOutput to existing array instead of creating new one, must have\nsame shape as expected output\n\n\n\nReturns\n\nanybool, ndarrayReturns a single bool if axis is None; otherwise,\nreturns ndarray\n\n\n\n\n", "parameters": ["Parameters", "axisint, optional", "outndarray, optional", "Returns", "anybool, ndarray"], "returns": "anybool, ndarrayReturns a single bool if axis is None; otherwise,returns ndarray", "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.any", "code": "\nmemmap.any(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.chararray.any", "code": "\nchararray.any(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.any", "code": "\nchararray.any(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.any", "code": "\nnumpy.any(a, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Test whether any array element along a given axis evaluates to True.\nReturns single boolean unless axis is not None\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which a logical OR reduction is performed.\nThe default (axis=None) is to perform a logical OR over all\nthe dimensions of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a reduction is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\noutndarray, optionalAlternate output array in which to place the result.  It must have\nthe same shape as the expected output and its type is preserved\n(e.g., if it is of type float, then it will remain so, returning\n1.0 for True and 0.0 for False, regardless of the type of a).\nSee ufuncs-output-type for more details.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the any method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nanybool or ndarrayA new boolean or ndarray is returned unless out is specified,\nin which case a reference to out is returned.\n\n\n\n\n\nSee also\n\nndarray.anyequivalent method\n\nallTest whether all elements along a given axis evaluate to True.\n\n\n\nNotes\nNot a Number (NaN), positive infinity and negative infinity evaluate\nto True because these are not equal to zero.\nExamples\n&gt;&gt;&gt; np.any([[True, False], [True, True]])\nTrue\n\n\n&gt;&gt;&gt; np.any([[True, False], [False, False]], axis=0)\narray([ True, False])\n\n\n&gt;&gt;&gt; np.any([-1, 0, 5])\nTrue\n\n\n&gt;&gt;&gt; np.any(np.nan)\nTrue\n\n\n&gt;&gt;&gt; o=np.array(False)\n&gt;&gt;&gt; z=np.any([-1, 4, 5], out=o)\n&gt;&gt;&gt; z, o\n(array(True), array(True))\n&gt;&gt;&gt; # Check now that z is a reference to o\n&gt;&gt;&gt; z is o\nTrue\n&gt;&gt;&gt; id(z), id(o) # identity of z and o              \n(191614240, 191614240)\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "anybool or ndarray"], "returns": "anybool or ndarrayA new boolean or ndarray is returned unless out is specified,in which case a reference to out is returned.", "examples": ["; np.any([[True, False], [True, True]])\nTrue\n\n", "; np.any([[True, False], [True, True]])\nTrue\n", "; np.any([[True, False], [False, False]], axis=0)\narray([ True, False])\n\n", "; np.any([[True, False], [False, False]], axis=0)\narray([ True, False])\n", "; np.any([-1, 0, 5])\nTrue\n\n", "; np.any([-1, 0, 5])\nTrue\n", "; np.any(np.nan)\nTrue\n\n", "; np.any(np.nan)\nTrue\n", "; o=np.array(False)\n; z=np.any([-1, 4, 5], out=o)\n; z, o\n(array(True), array(True))\n; # Check now that z is a reference to o\n; z is o\nTrue\n; id(z), id(o) # identity of z and o              \n(191614240, 191614240)\n\n", "; o=np.array(False)\n; z=np.any([-1, 4, 5], out=o)\n; z, o\n(array(True), array(True))\n; # Check now that z is a reference to o\n; z is o\nTrue\n; id(z), id(o) # identity of z and o              \n(191614240, 191614240)\n"]},
{"library": "numpy", "item_id": "numpy.ma.any", "code": "\nnumpy.ma.any(self, axis=None, out=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns True if any of the elements of a evaluate to True.\nMasked values are considered as False during computation.\nRefer to numpy.any for full documentation.\n\nSee also\n\nnumpy.ndarray.anycorresponding function for ndarrays\n\nnumpy.anyequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.anomalies", "code": "\nnumpy.ma.anomalies(self, axis=None, dtype=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.\n\nParameters\n\naxisint, optionalAxis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference.\n\ndtypedtype, optional\nType to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same as\nthe array type.\n\n\n\n\n\n\n\nSee also\n\nmeanCompute the mean of the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3])\n&gt;&gt;&gt; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "axisint, optional", "dtypedtype, optional", "Type to use in computing the variance. For arrays of integer type"], "returns": [], "examples": ["; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n", "; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.anom", "code": "\nMaskedArray.anom(self, axis=None, dtype=None)[source]\u00b6", "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.\n\nParameters\n\naxisint, optionalAxis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference.\n\ndtypedtype, optional\nType to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same as\nthe array type.\n\n\n\n\n\n\n\nSee also\n\nmeanCompute the mean of the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3])\n&gt;&gt;&gt; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "axisint, optional", "dtypedtype, optional", "Type to use in computing the variance. For arrays of integer type"], "returns": [], "examples": ["; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n", "; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.masked_array.anom", "code": "\nmasked_array.anom(self, axis=None, dtype=None)[source]\u00b6", "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.\n\nParameters\n\naxisint, optionalAxis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference.\n\ndtypedtype, optional\nType to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same as\nthe array type.\n\n\n\n\n\n\n\nSee also\n\nmeanCompute the mean of the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3])\n&gt;&gt;&gt; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "axisint, optional", "dtypedtype, optional", "Type to use in computing the variance. For arrays of integer type"], "returns": [], "examples": ["; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n", "; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.ma.anom", "code": "\nnumpy.ma.anom(self, axis=None, dtype=None) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Compute the anomalies (deviations from the arithmetic mean)\nalong the given axis.\nReturns an array of anomalies, with the same shape as the input and\nwhere the arithmetic mean is computed along the given axis.\n\nParameters\n\naxisint, optionalAxis over which the anomalies are taken.\nThe default is to use the mean of the flattened array as reference.\n\ndtypedtype, optional\nType to use in computing the variance. For arrays of integer typethe default is float32; for arrays of float types it is the same as\nthe array type.\n\n\n\n\n\n\n\nSee also\n\nmeanCompute the mean of the array.\n\n\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1,2,3])\n&gt;&gt;&gt; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n\n", "parameters": ["Parameters", "axisint, optional", "dtypedtype, optional", "Type to use in computing the variance. For arrays of integer type"], "returns": [], "examples": ["; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n\n", "; a = np.ma.array([1,2,3])\n; a.anom()\nmasked_array(data=[-1.,  0.,  1.],\n             mask=False,\n       fill_value=1e+20)\n"]},
{"library": "numpy", "item_id": "numpy.angle", "code": "\nnumpy.angle(z, deg=False)[source]\u00b6", "description": "Return the angle of the complex argument.\n\nParameters\n\nzarray_likeA complex number or sequence of complex numbers.\n\ndegbool, optionalReturn angle in degrees if True, radians if False (default).\n\n\n\nReturns\n\nanglendarray or scalarThe counterclockwise angle from the positive real axis on the complex\nplane in the range (-pi, pi], with dtype as numpy.float64.\n\n..versionchanged:: 1.16.0This function works on subclasses of ndarray like ma.array.\n\n\n\n\n\n\n\nSee also\narctan2, absolute\n\nExamples\n&gt;&gt;&gt; np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n&gt;&gt;&gt; np.angle(1+1j, deg=True)                  # in degrees\n45.0\n\n\n", "parameters": ["Parameters", "zarray_like", "degbool, optional", "Returns", "anglendarray or scalar", "..versionchanged:: 1.16.0"], "returns": "anglendarray or scalarThe counterclockwise angle from the positive real axis on the complexplane in the range (-pi, pi], with dtype as numpy.float64...versionchanged:: 1.16.0This function works on subclasses of ndarray like ma.array.", "examples": ["; np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n; np.angle(1+1j, deg=True)                  # in degrees\n45.0\n\n", "; np.angle([1.0, 1.0j, 1+1j])               # in radians\narray([ 0.        ,  1.57079633,  0.78539816]) # may vary\n; np.angle(1+1j, deg=True)                  # in degrees\n45.0\n"]},
{"library": "numpy", "item_id": "numpy.amin", "code": "\nnumpy.amin(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)[source]\u00b6", "description": "Return the minimum of an array or minimum along an axis.\n\nParameters\n\naarray_likeInput data.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which to operate.  By default, flattened input is\nused.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, the minimum is selected over multiple axes,\ninstead of a single axis or all the axes as before.\n\noutndarray, optionalAlternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output.\nSee ufuncs-output-type for more details.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the amin method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\ninitialscalar, optionalThe maximum value of an output element. Must be present to allow\ncomputation on empty slice. See reduce for details.\n\nNew in version 1.15.0.\n\n\nwherearray_like of bool, optionalElements to compare for the minimum. See reduce\nfor details.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\naminndarray or scalarMinimum of a. If axis is None, the result is a scalar value.\nIf axis is given, the result is an array of dimension\na.ndim - 1.\n\n\n\n\n\nSee also\n\namaxThe maximum value of an array along a given axis, propagating any NaNs.\n\nnanminThe minimum value of an array along a given axis, ignoring any NaNs.\n\nminimumElement-wise minimum of two arrays, propagating any NaNs.\n\nfminElement-wise minimum of two arrays, ignoring any NaNs.\n\nargminReturn the indices of the minimum values.\n\n\nnanmax, maximum, fmax\n\nNotes\nNaN values are propagated, that is if at least one item is NaN, the\ncorresponding min value will be NaN as well. To ignore NaN values\n(MATLAB behavior), please use nanmin.\nDon\u2019t use amin for element-wise comparison of 2 arrays; when\na.shape[0] is 2, minimum(a[0], a[1]) is faster than\namin(a, axis=0).\nExamples\n&gt;&gt;&gt; a = np.arange(4).reshape((2,2))\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; np.amin(a)           # Minimum of the flattened array\n0\n&gt;&gt;&gt; np.amin(a, axis=0)   # Minima along the first axis\narray([0, 1])\n&gt;&gt;&gt; np.amin(a, axis=1)   # Minima along the second axis\narray([0, 2])\n&gt;&gt;&gt; np.amin(a, where=[False, True], initial=10, axis=0)\narray([10,  1])\n\n\n&gt;&gt;&gt; b = np.arange(5, dtype=float)\n&gt;&gt;&gt; b[2] = np.NaN\n&gt;&gt;&gt; np.amin(b)\nnan\n&gt;&gt;&gt; np.amin(b, where=~np.isnan(b), initial=10)\n0.0\n&gt;&gt;&gt; np.nanmin(b)\n0.0\n\n\n&gt;&gt;&gt; np.min([[-50], [10]], axis=-1, initial=0)\narray([-50,   0])\n\n\nNotice that the initial value is used as one of the elements for which the\nminimum is determined, unlike for the default argument Python\u2019s max\nfunction, which is only used for empty iterables.\nNotice that this isn\u2019t the same as Python\u2019s default argument.\n&gt;&gt;&gt; np.min([6], initial=5)\n5\n&gt;&gt;&gt; min([6], default=5)\n6\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "outndarray, optional", "keepdimsbool, optional", "initialscalar, optional", "wherearray_like of bool, optional", "Returns", "aminndarray or scalar"], "returns": "aminndarray or scalarMinimum of a. If axis is None, the result is a scalar value.If axis is given, the result is an array of dimensiona.ndim - 1.", "examples": ["; a = np.arange(4).reshape((2,2))\n; a\narray([[0, 1],\n       [2, 3]])\n; np.amin(a)           # Minimum of the flattened array\n0\n; np.amin(a, axis=0)   # Minima along the first axis\narray([0, 1])\n; np.amin(a, axis=1)   # Minima along the second axis\narray([0, 2])\n; np.amin(a, where=[False, True], initial=10, axis=0)\narray([10,  1])\n\n", "; a = np.arange(4).reshape((2,2))\n; a\narray([[0, 1],\n       [2, 3]])\n; np.amin(a)           # Minimum of the flattened array\n0\n; np.amin(a, axis=0)   # Minima along the first axis\narray([0, 1])\n; np.amin(a, axis=1)   # Minima along the second axis\narray([0, 2])\n; np.amin(a, where=[False, True], initial=10, axis=0)\narray([10,  1])\n", "; b = np.arange(5, dtype=float)\n; b[2] = np.NaN\n; np.amin(b)\nnan\n; np.amin(b, where=~np.isnan(b), initial=10)\n0.0\n; np.nanmin(b)\n0.0\n\n", "; b = np.arange(5, dtype=float)\n; b[2] = np.NaN\n; np.amin(b)\nnan\n; np.amin(b, where=~np.isnan(b), initial=10)\n0.0\n; np.nanmin(b)\n0.0\n", "; np.min([[-50], [10]], axis=-1, initial=0)\narray([-50,   0])\n\n", "; np.min([[-50], [10]], axis=-1, initial=0)\narray([-50,   0])\n", "; np.min([6], initial=5)\n5\n; min([6], default=5)\n6\n\n", "; np.min([6], initial=5)\n5\n; min([6], default=5)\n6\n"]},
{"library": "numpy", "item_id": "numpy.amax", "code": "\nnumpy.amax(a, axis=None, out=None, keepdims=&lt;no value&gt;, initial=&lt;no value&gt;, where=&lt;no value&gt;)[source]\u00b6", "description": "Return the maximum of an array or maximum along an axis.\n\nParameters\n\naarray_likeInput data.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which to operate.  By default, flattened input is\nused.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, the maximum is selected over multiple axes,\ninstead of a single axis or all the axes as before.\n\noutndarray, optionalAlternative output array in which to place the result.  Must\nbe of the same shape and buffer length as the expected output.\nSee ufuncs-output-type for more details.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the amax method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\ninitialscalar, optionalThe minimum value of an output element. Must be present to allow\ncomputation on empty slice. See reduce for details.\n\nNew in version 1.15.0.\n\n\nwherearray_like of bool, optionalElements to compare for the maximum. See reduce\nfor details.\n\nNew in version 1.17.0.\n\n\n\n\nReturns\n\namaxndarray or scalarMaximum of a. If axis is None, the result is a scalar value.\nIf axis is given, the result is an array of dimension\na.ndim - 1.\n\n\n\n\n\nSee also\n\naminThe minimum value of an array along a given axis, propagating any NaNs.\n\nnanmaxThe maximum value of an array along a given axis, ignoring any NaNs.\n\nmaximumElement-wise maximum of two arrays, propagating any NaNs.\n\nfmaxElement-wise maximum of two arrays, ignoring any NaNs.\n\nargmaxReturn the indices of the maximum values.\n\n\nnanmin, minimum, fmin\n\nNotes\nNaN values are propagated, that is if at least one item is NaN, the\ncorresponding max value will be NaN as well. To ignore NaN values\n(MATLAB behavior), please use nanmax.\nDon\u2019t use amax for element-wise comparison of 2 arrays; when\na.shape[0] is 2, maximum(a[0], a[1]) is faster than\namax(a, axis=0).\nExamples\n&gt;&gt;&gt; a = np.arange(4).reshape((2,2))\n&gt;&gt;&gt; a\narray([[0, 1],\n       [2, 3]])\n&gt;&gt;&gt; np.amax(a)           # Maximum of the flattened array\n3\n&gt;&gt;&gt; np.amax(a, axis=0)   # Maxima along the first axis\narray([2, 3])\n&gt;&gt;&gt; np.amax(a, axis=1)   # Maxima along the second axis\narray([1, 3])\n&gt;&gt;&gt; np.amax(a, where=[False, True], initial=-1, axis=0)\narray([-1,  3])\n&gt;&gt;&gt; b = np.arange(5, dtype=float)\n&gt;&gt;&gt; b[2] = np.NaN\n&gt;&gt;&gt; np.amax(b)\nnan\n&gt;&gt;&gt; np.amax(b, where=~np.isnan(b), initial=-1)\n4.0\n&gt;&gt;&gt; np.nanmax(b)\n4.0\n\n\nYou can use an initial value to compute the maximum of an empty slice, or\nto initialize it to a different value:\n&gt;&gt;&gt; np.max([[-50], [10]], axis=-1, initial=0)\narray([ 0, 10])\n\n\nNotice that the initial value is used as one of the elements for which the\nmaximum is determined, unlike for the default argument Python\u2019s max\nfunction, which is only used for empty iterables.\n&gt;&gt;&gt; np.max([5], initial=6)\n6\n&gt;&gt;&gt; max([5], default=6)\n5\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "outndarray, optional", "keepdimsbool, optional", "initialscalar, optional", "wherearray_like of bool, optional", "Returns", "amaxndarray or scalar"], "returns": "amaxndarray or scalarMaximum of a. If axis is None, the result is a scalar value.If axis is given, the result is an array of dimensiona.ndim - 1.", "examples": ["; a = np.arange(4).reshape((2,2))\n; a\narray([[0, 1],\n       [2, 3]])\n; np.amax(a)           # Maximum of the flattened array\n3\n; np.amax(a, axis=0)   # Maxima along the first axis\narray([2, 3])\n; np.amax(a, axis=1)   # Maxima along the second axis\narray([1, 3])\n; np.amax(a, where=[False, True], initial=-1, axis=0)\narray([-1,  3])\n; b = np.arange(5, dtype=float)\n; b[2] = np.NaN\n; np.amax(b)\nnan\n; np.amax(b, where=~np.isnan(b), initial=-1)\n4.0\n; np.nanmax(b)\n4.0\n\n", "; a = np.arange(4).reshape((2,2))\n; a\narray([[0, 1],\n       [2, 3]])\n; np.amax(a)           # Maximum of the flattened array\n3\n; np.amax(a, axis=0)   # Maxima along the first axis\narray([2, 3])\n; np.amax(a, axis=1)   # Maxima along the second axis\narray([1, 3])\n; np.amax(a, where=[False, True], initial=-1, axis=0)\narray([-1,  3])\n; b = np.arange(5, dtype=float)\n; b[2] = np.NaN\n; np.amax(b)\nnan\n; np.amax(b, where=~np.isnan(b), initial=-1)\n4.0\n; np.nanmax(b)\n4.0\n", "; np.max([[-50], [10]], axis=-1, initial=0)\narray([ 0, 10])\n\n", "; np.max([[-50], [10]], axis=-1, initial=0)\narray([ 0, 10])\n", "; np.max([5], initial=6)\n6\n; max([5], default=6)\n5\n\n", "; np.max([5], initial=6)\n6\n; max([5], default=6)\n5\n"]},
{"library": "numpy", "item_id": "term-along-an-axis", "code": "along an axis", "description": "Axes are defined for arrays with more than one dimension.  A\n2-dimensional array has two corresponding axes: the first running\nvertically downwards across rows (axis 0), and the second running\nhorizontally across columns (axis 1).\nMany operations can take place along one of these axes.  For example,\nwe can sum each row of an array, in which case we operate along\ncolumns, or axis 1:\n&gt;&gt;&gt; x = np.arange(12).reshape((3,4))\n\n&gt;&gt;&gt; x\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n&gt;&gt;&gt; x.sum(axis=1)\narray([ 6, 22, 38])\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.allequal", "code": "\nnumpy.ma.allequal(a, b, fill_value=True)[source]\u00b6", "description": "Return True if all entries of a and b are equal, using\nfill_value as a truth value where either or both are masked.\n\nParameters\n\na, barray_likeInput arrays to compare.\n\nfill_valuebool, optionalWhether masked values in a or b are considered equal (True) or not\n(False).\n\n\n\nReturns\n\nyboolReturns True if the two arrays are equal within the given\ntolerance, False otherwise. If either array contains NaN,\nthen False is returned.\n\n\n\n\n\nSee also\nall, any, numpy.ma.allclose\n\nExamples\n&gt;&gt;&gt; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n\n\n&gt;&gt;&gt; b = np.array([1e10, 1e-7, -42.0])\n&gt;&gt;&gt; b\narray([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n&gt;&gt;&gt; np.ma.allequal(a, b, fill_value=False)\nFalse\n&gt;&gt;&gt; np.ma.allequal(a, b)\nTrue\n\n\n", "parameters": ["Parameters", "a, barray_like", "fill_valuebool, optional", "Returns", "ybool"], "returns": "yboolReturns True if the two arrays are equal within the giventolerance, False otherwise. If either array contains NaN,then False is returned.", "examples": ["; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n\n", "; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n", "; b = np.array([1e10, 1e-7, -42.0])\n; b\narray([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n; np.ma.allequal(a, b, fill_value=False)\nFalse\n; np.ma.allequal(a, b)\nTrue\n\n", "; b = np.array([1e10, 1e-7, -42.0])\n; b\narray([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])\n; np.ma.allequal(a, b, fill_value=False)\nFalse\n; np.ma.allequal(a, b)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.allclose", "code": "\nnumpy.ma.allclose(a, b, masked_equal=True, rtol=1e-05, atol=1e-08)[source]\u00b6", "description": "Returns True if two arrays are element-wise equal within a tolerance.\nThis function is equivalent to allclose except that masked values\nare treated as equal (default) or unequal, depending on the masked_equal\nargument.\n\nParameters\n\na, barray_likeInput arrays to compare.\n\nmasked_equalbool, optionalWhether masked values in a and b are considered equal (True) or not\n(False). They are considered equal by default.\n\nrtolfloat, optionalRelative tolerance. The relative difference is equal to rtol * b.\nDefault is 1e-5.\n\natolfloat, optionalAbsolute tolerance. The absolute difference is equal to atol.\nDefault is 1e-8.\n\n\n\nReturns\n\nyboolReturns True if the two arrays are equal within the given\ntolerance, False otherwise. If either array contains NaN, then\nFalse is returned.\n\n\n\n\n\nSee also\nall, any\n\nnumpy.allclosethe non-masked allclose.\n\n\n\nNotes\nIf the following equation is element-wise True, then allclose returns\nTrue:\nabsolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))\n\n\nReturn True if all elements of a and b are equal subject to\ngiven tolerances.\nExamples\n&gt;&gt;&gt; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n&gt;&gt;&gt; b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; np.ma.allclose(a, b)\nFalse\n\n\n&gt;&gt;&gt; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; np.ma.allclose(a, b)\nTrue\n&gt;&gt;&gt; np.ma.allclose(a, b, masked_equal=False)\nFalse\n\n\nMasked values are not compared directly.\n&gt;&gt;&gt; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n&gt;&gt;&gt; np.ma.allclose(a, b)\nTrue\n&gt;&gt;&gt; np.ma.allclose(a, b, masked_equal=False)\nFalse\n\n\n", "parameters": ["Parameters", "a, barray_like", "masked_equalbool, optional", "rtolfloat, optional", "atolfloat, optional", "Returns", "ybool"], "returns": "yboolReturns True if the two arrays are equal within the giventolerance, False otherwise. If either array contains NaN, thenFalse is returned.", "examples": ["; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n; b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nFalse\n\n", "; a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])\n; a\nmasked_array(data=[10000000000.0, 1e-07, --],\n             mask=[False, False,  True],\n       fill_value=1e+20)\n; b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nFalse\n", "; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n; b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nTrue\n; np.ma.allclose(a, b, masked_equal=False)\nFalse\n\n", "; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n; b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nTrue\n; np.ma.allclose(a, b, masked_equal=False)\nFalse\n", "; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n; b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nTrue\n; np.ma.allclose(a, b, masked_equal=False)\nFalse\n\n", "; a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])\n; b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])\n; np.ma.allclose(a, b)\nTrue\n; np.ma.allclose(a, b, masked_equal=False)\nFalse\n"]},
{"library": "numpy", "item_id": "numpy.distutils.misc_util.get_numpy_include_dirs", "code": "\nnumpy.distutils.misc_util.get_numpy_include_dirs()[source]\u00b6", "description": "", "parameters": ["Parameters", "pkgnamestr", "dirssequence, optional", "Returns", "infodict", "Raises", "PkgNotFound", "Parameters", "pkgnamestr", "dirssequence, optional", "Returns", "pkginfoclass instance", "Raises", "PkgNotFound", "Returns", "outint"], "returns": "infodictThe dictionary with build information.", "examples": ["; npymath_info = np.distutils.misc_util.get_info('npymath')\n; npymath_info                                    \n{'define_macros': [], 'libraries': ['npymath'], 'library_dirs':\n['.../numpy/core/lib'], 'include_dirs': ['.../numpy/core/include']}\n\n", "; npymath_info = np.distutils.misc_util.get_info('npymath')\n; npymath_info                                    \n{'define_macros': [], 'libraries': ['npymath'], 'library_dirs':\n['.../numpy/core/lib'], 'include_dirs': ['.../numpy/core/include']}\n"]},
{"library": "numpy", "item_id": "numpy.allclose", "code": "\nnumpy.allclose(a, b, rtol=1e-05, atol=1e-08, equal_nan=False)[source]\u00b6", "description": "Returns True if two arrays are element-wise equal within a tolerance.\nThe tolerance values are positive, typically very small numbers.  The\nrelative difference (rtol * abs(b)) and the absolute difference\natol are added together to compare against the absolute difference\nbetween a and b.\nNaNs are treated as equal if they are in the same place and if\nequal_nan=True.  Infs are treated as equal if they are in the same\nplace and of the same sign in both arrays.\n\nParameters\n\na, barray_likeInput arrays to compare.\n\nrtolfloatThe relative tolerance parameter (see Notes).\n\natolfloatThe absolute tolerance parameter (see Notes).\n\nequal_nanboolWhether to compare NaN\u2019s as equal.  If True, NaN\u2019s in a will be\nconsidered equal to NaN\u2019s in b in the output array.\n\nNew in version 1.10.0.\n\n\n\n\nReturns\n\nallcloseboolReturns True if the two arrays are equal within the given\ntolerance; False otherwise.\n\n\n\n\n\nSee also\nisclose, all, any, equal\n\nNotes\nIf the following equation is element-wise True, then allclose returns\nTrue.\n\nabsolute(a - b) &lt;= (atol + rtol * absolute(b))\n\nThe above equation is not symmetric in a and b, so that\nallclose(a, b) might be different from allclose(b, a) in\nsome rare cases.\nThe comparison of a and b uses standard broadcasting, which\nmeans that a and b need not have the same shape in order for\nallclose(a, b) to evaluate to True.  The same is true for\nequal but not array_equal.\nExamples\n&gt;&gt;&gt; np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n&gt;&gt;&gt; np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n&gt;&gt;&gt; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue\n\n\n", "parameters": ["Parameters", "a, barray_like", "rtolfloat", "atolfloat", "equal_nanbool", "Returns", "allclosebool"], "returns": "allcloseboolReturns True if the two arrays are equal within the giventolerance; False otherwise.", "examples": ["; np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n; np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n; np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n; np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue\n\n", "; np.allclose([1e10,1e-7], [1.00001e10,1e-8])\nFalse\n; np.allclose([1e10,1e-8], [1.00001e10,1e-9])\nTrue\n; np.allclose([1e10,1e-8], [1.0001e10,1e-9])\nFalse\n; np.allclose([1.0, np.nan], [1.0, np.nan])\nFalse\n; np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.record.all", "code": "\nrecord.all()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.recarray.all", "code": "\nrecarray.all(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if all elements evaluate to True.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.allequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.all", "code": "\nndarray.all(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if all elements evaluate to True.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.allequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.all", "code": "\nmatrix.all(self, axis=None, out=None)[source]\u00b6", "description": "Test whether all matrix elements along a given axis evaluate to True.\n\nParameters\n\nSee `numpy.all` for complete descriptions\n\n\n\n\nSee also\nnumpy.all\n\nNotes\nThis is the same as ndarray.all, but it returns a matrix object.\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n&gt;&gt;&gt; (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]])\n&gt;&gt;&gt; (x == y).all()\nFalse\n&gt;&gt;&gt; (x == y).all(0)\nmatrix([[False, False, False, False]])\n&gt;&gt;&gt; (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]])\n\n\n", "parameters": ["Parameters", "See `numpy.all` for complete descriptions"], "returns": [], "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n; (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]])\n; (x == y).all()\nFalse\n; (x == y).all(0)\nmatrix([[False, False, False, False]])\n; (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; y = x[0]; y\nmatrix([[0, 1, 2, 3]])\n; (x == y)\nmatrix([[ True,  True,  True,  True],\n        [False, False, False, False],\n        [False, False, False, False]])\n; (x == y).all()\nFalse\n; (x == y).all(0)\nmatrix([[False, False, False, False]])\n; (x == y).all(1)\nmatrix([[ True],\n        [False],\n        [False]])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskType.all", "code": "\nMaskType.all()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.all", "code": "\ngeneric.all()\u00b6", "description": "Not implemented (virtual attribute)\nClass generic exists solely to derive numpy scalars from, and possesses,\nalbeit unimplemented, all the attributes of the ndarray class\nso as to provide a uniform API.\nSee also the corresponding attribute of the derived class of interest.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.memmap.all", "code": "\nmemmap.all(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if all elements evaluate to True.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.allequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.masked_array.all", "code": "\nmasked_array.all(self, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns True if all elements evaluate to True.\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is masked.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.ndarray.allcorresponding function for ndarrays\n\nnumpy.allequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; np.ma.array([1,2,3]).all()\nTrue\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=True)\n&gt;&gt;&gt; (a.all() is np.ma.masked)\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n\n", "; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.all", "code": "\nMaskedArray.all(self, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Returns True if all elements evaluate to True.\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is masked.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.ndarray.allcorresponding function for ndarrays\n\nnumpy.allequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; np.ma.array([1,2,3]).all()\nTrue\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=True)\n&gt;&gt;&gt; (a.all() is np.ma.masked)\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n\n", "; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.chararray.all", "code": "\nchararray.all(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if all elements evaluate to True.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.allequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.char.chararray.all", "code": "\nchararray.all(axis=None, out=None, keepdims=False)\u00b6", "description": "Returns True if all elements evaluate to True.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.allequivalent function\n\n\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.all", "code": "\nnumpy.all(a, axis=None, out=None, keepdims=&lt;no value&gt;)[source]\u00b6", "description": "Test whether all array elements along a given axis evaluate to True.\n\nParameters\n\naarray_likeInput array or object that can be converted to an array.\n\naxisNone or int or tuple of ints, optionalAxis or axes along which a logical AND reduction is performed.\nThe default (axis=None) is to perform a logical AND over all\nthe dimensions of the input array. axis may be negative, in\nwhich case it counts from the last to the first axis.\n\nNew in version 1.7.0.\n\nIf this is a tuple of ints, a reduction is performed on multiple\naxes, instead of a single axis or all the axes as before.\n\noutndarray, optionalAlternate output array in which to place the result.\nIt must have the same shape as the expected output and its\ntype is preserved (e.g., if dtype(out) is float, the result\nwill consist of 0.0\u2019s and 1.0\u2019s). See ufuncs-output-type for more\ndetails.\n\nkeepdimsbool, optionalIf this is set to True, the axes which are reduced are left\nin the result as dimensions with size one. With this option,\nthe result will broadcast correctly against the input array.\nIf the default value is passed, then keepdims will not be\npassed through to the all method of sub-classes of\nndarray, however any non-default value will be.  If the\nsub-class\u2019 method does not implement keepdims any\nexceptions will be raised.\n\n\n\nReturns\n\nallndarray, boolA new boolean or array is returned unless out is specified,\nin which case a reference to out is returned.\n\n\n\n\n\nSee also\n\nndarray.allequivalent method\n\nanyTest whether any element along a given axis evaluates to True.\n\n\n\nNotes\nNot a Number (NaN), positive infinity and negative infinity\nevaluate to True because these are not equal to zero.\nExamples\n&gt;&gt;&gt; np.all([[True,False],[True,True]])\nFalse\n\n\n&gt;&gt;&gt; np.all([[True,False],[True,True]], axis=0)\narray([ True, False])\n\n\n&gt;&gt;&gt; np.all([-1, 4, 5])\nTrue\n\n\n&gt;&gt;&gt; np.all([1.0, np.nan])\nTrue\n\n\n&gt;&gt;&gt; o=np.array(False)\n&gt;&gt;&gt; z=np.all([-1, 4, 5], out=o)\n&gt;&gt;&gt; id(z), id(o), z\n(28293632, 28293632, array(True)) # may vary\n\n\n", "parameters": ["Parameters", "aarray_like", "axisNone or int or tuple of ints, optional", "outndarray, optional", "keepdimsbool, optional", "Returns", "allndarray, bool"], "returns": "allndarray, boolA new boolean or array is returned unless out is specified,in which case a reference to out is returned.", "examples": ["; np.all([[True,False],[True,True]])\nFalse\n\n", "; np.all([[True,False],[True,True]])\nFalse\n", "; np.all([[True,False],[True,True]], axis=0)\narray([ True, False])\n\n", "; np.all([[True,False],[True,True]], axis=0)\narray([ True, False])\n", "; np.all([-1, 4, 5])\nTrue\n\n", "; np.all([-1, 4, 5])\nTrue\n", "; np.all([1.0, np.nan])\nTrue\n\n", "; np.all([1.0, np.nan])\nTrue\n", "; o=np.array(False)\n; z=np.all([-1, 4, 5], out=o)\n; id(z), id(o), z\n(28293632, 28293632, array(True)) # may vary\n\n", "; o=np.array(False)\n; z=np.all([-1, 4, 5], out=o)\n; id(z), id(o), z\n(28293632, 28293632, array(True)) # may vary\n"]},
{"library": "numpy", "item_id": "numpy.ma.all", "code": "\nnumpy.ma.all(self, axis=None, out=None, keepdims=&lt;no value&gt;) = &lt;numpy.ma.core._frommethod object&gt;\u00b6", "description": "Returns True if all elements evaluate to True.\nThe output array is masked where all the values along the given axis\nare masked: if the output would have been a scalar and that all the\nvalues are masked, then the output is masked.\nRefer to numpy.all for full documentation.\n\nSee also\n\nnumpy.ndarray.allcorresponding function for ndarrays\n\nnumpy.allequivalent function\n\n\n\nExamples\n&gt;&gt;&gt; np.ma.array([1,2,3]).all()\nTrue\n&gt;&gt;&gt; a = np.ma.array([1,2,3], mask=True)\n&gt;&gt;&gt; (a.all() is np.ma.masked)\nTrue\n\n\n", "parameters": [], "returns": [], "examples": ["; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n\n", "; np.ma.array([1,2,3]).all()\nTrue\n; a = np.ma.array([1,2,3], mask=True)\n; (a.all() is np.ma.masked)\nTrue\n"]},
{"library": "numpy", "item_id": "numpy.dtype.alignment", "code": "\ndtype.alignment\u00b6", "description": "The required alignment (bytes) of this data-type according to the compiler.\nMore information is available in the C-API section of the manual.\nExamples\n&gt;&gt;&gt; x = np.dtype('i4')\n&gt;&gt;&gt; x.alignment\n4\n\n\n&gt;&gt;&gt; x = np.dtype(float)\n&gt;&gt;&gt; x.alignment\n8\n\n\n", "parameters": [], "returns": [], "examples": ["; x = np.dtype('i4')\n; x.alignment\n4\n\n", "; x = np.dtype('i4')\n; x.alignment\n4\n", "; x = np.dtype(float)\n; x.alignment\n8\n\n", "; x = np.dtype(float)\n; x.alignment\n8\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.PCG64.advance", "code": "\nPCG64.advance(delta)\u00b6", "description": "Advance the underlying RNG as-if delta draws have occurred.\n\nParameters\n\ndeltainteger, positiveNumber of draws to advance the RNG. Must be less than the\nsize state variable in the underlying RNG.\n\n\n\nReturns\n\nselfPCG64RNG advanced delta steps\n\n\n\n\nNotes\nAdvancing a RNG updates the underlying RNG state as-if a given\nnumber of calls to the underlying RNG have been made. In general\nthere is not a one-to-one relationship between the number output\nrandom values from a particular distribution and the number of\ndraws from the core RNG.  This occurs for two reasons:\n\nThe random values are simulated using a rejection-based method\nand so, on average, more than one value from the underlying\nRNG is required to generate an single draw.\nThe number of bits required to generate a simulated value\ndiffers from the number of bits generated by the underlying\nRNG.  For example, two 16-bit integer values can be simulated\nfrom a single draw of a 32-bit RNG.\n\nAdvancing the RNG state resets any pre-computed random numbers.\nThis is required to ensure exact reproducibility.\n", "parameters": ["Parameters", "deltainteger, positive", "Returns", "selfPCG64"], "returns": "selfPCG64RNG advanced delta steps", "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.random.Philox.advance", "code": "\nPhilox.advance(delta)\u00b6", "description": "Advance the underlying RNG as-if delta draws have occurred.\n\nParameters\n\ndeltainteger, positiveNumber of draws to advance the RNG. Must be less than the\nsize state variable in the underlying RNG.\n\n\n\nReturns\n\nselfPhiloxRNG advanced delta steps\n\n\n\n\nNotes\nAdvancing a RNG updates the underlying RNG state as-if a given\nnumber of calls to the underlying RNG have been made. In general\nthere is not a one-to-one relationship between the number output\nrandom values from a particular distribution and the number of\ndraws from the core RNG.  This occurs for two reasons:\n\nThe random values are simulated using a rejection-based method\nand so, on average, more than one value from the underlying\nRNG is required to generate an single draw.\nThe number of bits required to generate a simulated value\ndiffers from the number of bits generated by the underlying\nRNG.  For example, two 16-bit integer values can be simulated\nfrom a single draw of a 32-bit RNG.\n\nAdvancing the RNG state resets any pre-computed random numbers.\nThis is required to ensure exact reproducibility.\n", "parameters": ["Parameters", "deltainteger, positive", "Returns", "selfPhilox"], "returns": "selfPhiloxRNG advanced delta steps", "examples": []},
{"library": "numpy", "item_id": "numpy.char.add", "code": "\nnumpy.char.add(x1, x2)\u00b6", "description": "Return element-wise string concatenation for two arrays of str or unicode.\nArrays x1 and x2 must have the same shape.\n\nParameters\n\nx1array_like of str or unicodeInput array.\n\nx2array_like of str or unicodeInput array.\n\n\n\nReturns\n\naddndarrayOutput array of string_ or unicode_, depending on input types\nof the same shape as x1 and x2.\n\n\n\n\n", "parameters": ["Parameters", "x1array_like of str or unicode", "x2array_like of str or unicode", "Returns", "addndarray"], "returns": "addndarrayOutput array of string_ or unicode_, depending on input typesof the same shape as x1 and x2.", "examples": []},
{"library": "numpy", "item_id": "numpy.add", "code": "\nnumpy.add(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'add'&gt;\u00b6", "description": "Add arguments element-wise.\n\nParameters\n\nx1, x2array_likeThe arrays to be added. If x1.shape != x2.shape, they must be broadcastable to a common shape (which becomes the shape of the output).\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\naddndarray or scalarThe sum of x1 and x2, element-wise.\nThis is a scalar if both x1 and x2 are scalars.\n\n\n\n\nNotes\nEquivalent to x1 + x2 in terms of array broadcasting.\nExamples\n&gt;&gt;&gt; np.add(1.0, 4.0)\n5.0\n&gt;&gt;&gt; x1 = np.arange(9.0).reshape((3, 3))\n&gt;&gt;&gt; x2 = np.arange(3.0)\n&gt;&gt;&gt; np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])\n\n\n", "parameters": ["Parameters", "x1, x2array_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "addndarray or scalar"], "returns": "addndarray or scalarThe sum of x1 and x2, element-wise.This is a scalar if both x1 and x2 are scalars.", "examples": ["; np.add(1.0, 4.0)\n5.0\n; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])\n\n", "; np.add(1.0, 4.0)\n5.0\n; x1 = np.arange(9.0).reshape((3, 3))\n; x2 = np.arange(3.0)\n; np.add(x1, x2)\narray([[  0.,   2.,   4.],\n       [  3.,   5.,   7.],\n       [  6.,   8.,  10.]])\n"]},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.DataSource.abspath", "code": "\nDataSource.abspath(self, path)[source]\u00b6", "description": "Return absolute path of file in the DataSource directory.\nIf path is an URL, then abspath will return either the location\nthe file exists locally or the location it would exist when opened\nusing the open method.\n\nParameters\n\npathstrCan be a local file or a remote URL.\n\n\n\nReturns\n\noutstrComplete path, including the DataSource destination directory.\n\n\n\n\nNotes\nThe functionality is based on os.path.abspath.\n", "parameters": ["Parameters", "pathstr", "Returns", "outstr"], "returns": "outstrComplete path, including the DataSource destination directory.", "examples": []},
{"library": "numpy", "item_id": "numpy.ufunc.accumulate", "code": "\nufunc.accumulate(array, axis=0, dtype=None, out=None)\u00b6", "description": "Accumulate the result of applying the operator to all elements.\nFor a one-dimensional array, accumulate produces results equivalent to:\nr = np.empty(len(A))\nt = op.identity        # op = the ufunc being applied to A's  elements\nfor i in range(len(A)):\n    t = op(t, A[i])\n    r[i] = t\nreturn r\n\n\nFor example, add.accumulate() is equivalent to np.cumsum().\nFor a multi-dimensional array, accumulate is applied along only one\naxis (axis zero by default; see Examples below) so repeated use is\nnecessary if one wants to accumulate over multiple axes.\n\nParameters\n\narrayarray_likeThe array to act on.\n\naxisint, optionalThe axis along which to apply the accumulation; default is zero.\n\ndtypedata-type code, optionalThe data-type used to represent the intermediate results. Defaults\nto the data-type of the output array if such is provided, or the\nthe data-type of the input array if no output array is provided.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If not provided or None,\na freshly-allocated array is returned. For consistency with\nufunc.__call__, if given as a keyword, this may be wrapped in a\n1-element tuple.\n\nChanged in version 1.13.0: Tuples are allowed for keyword argument.\n\n\n\n\nReturns\n\nrndarrayThe accumulated values. If out was supplied, r is a reference to\nout.\n\n\n\n\nExamples\n1-D array examples:\n&gt;&gt;&gt; np.add.accumulate([2, 3, 5])\narray([ 2,  5, 10])\n&gt;&gt;&gt; np.multiply.accumulate([2, 3, 5])\narray([ 2,  6, 30])\n\n\n2-D array examples:\n&gt;&gt;&gt; I = np.eye(2)\n&gt;&gt;&gt; I\narray([[1.,  0.],\n       [0.,  1.]])\n\n\nAccumulate along axis 0 (rows), down columns:\n&gt;&gt;&gt; np.add.accumulate(I, 0)\narray([[1.,  0.],\n       [1.,  1.]])\n&gt;&gt;&gt; np.add.accumulate(I) # no axis specified = axis zero\narray([[1.,  0.],\n       [1.,  1.]])\n\n\nAccumulate along axis 1 (columns), through rows:\n&gt;&gt;&gt; np.add.accumulate(I, 1)\narray([[1.,  1.],\n       [0.,  1.]])\n\n\n", "parameters": ["Parameters", "arrayarray_like", "axisint, optional", "dtypedata-type code, optional", "outndarray, None, or tuple of ndarray and None, optional", "Returns", "rndarray"], "returns": "rndarrayThe accumulated values. If out was supplied, r is a reference toout.", "examples": ["; np.add.accumulate([2, 3, 5])\narray([ 2,  5, 10])\n; np.multiply.accumulate([2, 3, 5])\narray([ 2,  6, 30])\n\n", "; np.add.accumulate([2, 3, 5])\narray([ 2,  5, 10])\n; np.multiply.accumulate([2, 3, 5])\narray([ 2,  6, 30])\n", "; I = np.eye(2)\n; I\narray([[1.,  0.],\n       [0.,  1.]])\n\n", "; I = np.eye(2)\n; I\narray([[1.,  0.],\n       [0.,  1.]])\n", "; np.add.accumulate(I, 0)\narray([[1.,  0.],\n       [1.,  1.]])\n; np.add.accumulate(I) # no axis specified = axis zero\narray([[1.,  0.],\n       [1.,  1.]])\n\n", "; np.add.accumulate(I, 0)\narray([[1.,  0.],\n       [1.,  1.]])\n; np.add.accumulate(I) # no axis specified = axis zero\narray([[1.,  0.],\n       [1.,  1.]])\n", "; np.add.accumulate(I, 1)\narray([[1.,  1.],\n       [0.,  1.]])\n\n", "; np.add.accumulate(I, 1)\narray([[1.,  1.],\n       [0.,  1.]])\n"]},
{"library": "numpy", "item_id": "numpy.absolute", "code": "\nnumpy.absolute(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj]) = &lt;ufunc 'absolute'&gt;\u00b6", "description": "Calculate the absolute value element-wise.\nnp.abs is a shorthand for this function.\n\nParameters\n\nxarray_likeInput array.\n\noutndarray, None, or tuple of ndarray and None, optionalA location into which the result is stored. If provided, it must have\na shape that the inputs broadcast to. If not provided or None,\na freshly-allocated array is returned. A tuple (possible only as a\nkeyword argument) must have length equal to the number of outputs.\n\nwherearray_like, optionalThis condition is broadcast over the input. At locations where the\ncondition is True, the out array will be set to the ufunc result.\nElsewhere, the out array will retain its original value.\nNote that if an uninitialized out array is created via the default\nout=None, locations within it where the condition is False will\nremain uninitialized.\n\n**kwargsFor other keyword-only arguments, see the\nufunc docs.\n\n\n\nReturns\n\nabsolutendarrayAn ndarray containing the absolute value of\neach element in x.  For complex input, a + ib, the\nabsolute value is .\nThis is a scalar if x is a scalar.\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.array([-1.2, 1.2])\n&gt;&gt;&gt; np.absolute(x)\narray([ 1.2,  1.2])\n&gt;&gt;&gt; np.absolute(1.2 + 1j)\n1.5620499351813308\n\n\nPlot the function over [-10, 10]:\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n\n\n&gt;&gt;&gt; x = np.linspace(start=-10, stop=10, num=101)\n&gt;&gt;&gt; plt.plot(x, np.absolute(x))\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\nPlot the function over the complex plane:\n&gt;&gt;&gt; xx = x + 1j * x[:, np.newaxis]\n&gt;&gt;&gt; plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n&gt;&gt;&gt; plt.show()\n\n\n\n\n\n", "parameters": ["Parameters", "xarray_like", "outndarray, None, or tuple of ndarray and None, optional", "wherearray_like, optional", "**kwargs", "Returns", "absolutendarray"], "returns": "absolutendarrayAn ndarray containing the absolute value ofeach element in x.  For complex input, a + ib, theabsolute value is .This is a scalar if x is a scalar.", "examples": ["; x = np.array([-1.2, 1.2])\n; np.absolute(x)\narray([ 1.2,  1.2])\n; np.absolute(1.2 + 1j)\n1.5620499351813308\n\n", "; x = np.array([-1.2, 1.2])\n; np.absolute(x)\narray([ 1.2,  1.2])\n; np.absolute(1.2 + 1j)\n1.5620499351813308\n", "; import matplotlib.pyplot as plt\n\n", "; import matplotlib.pyplot as plt\n", "; x = np.linspace(start=-10, stop=10, num=101)\n; plt.plot(x, np.absolute(x))\n; plt.show()\n\n", "; x = np.linspace(start=-10, stop=10, num=101)\n; plt.plot(x, np.absolute(x))\n; plt.show()\n", "; xx = x + 1j * x[:, np.newaxis]\n; plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n; plt.show()\n\n", "; xx = x + 1j * x[:, np.newaxis]\n; plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap='gray')\n; plt.show()\n"]},
{"library": "numpy", "item_id": "numpy.matrix.A1", "code": "\nproperty matrix.A1\u00b6", "description": "Return self as a flattened ndarray.\nEquivalent to np.asarray(x).ravel()\n\nParameters\n\nNone\n\n\nReturns\n\nretndarrayself, 1-D, as an ndarray\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retndarray"], "returns": "retndarrayself, 1-D, as an ndarray", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA1()\narray([ 0,  1,  2, ...,  9, 10, 11])\n"]},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__xor__", "code": "\nMaskedArray.__xor__(self, value, /)\u00b6", "description": "Return self^value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__xor__", "code": "\nndarray.__xor__(self, value, /)\u00b6", "description": "Return self^value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.matrix.A", "code": "\nproperty matrix.A\u00b6", "description": "Return self as an ndarray object.\nEquivalent to np.asarray(self).\n\nParameters\n\nNone\n\n\nReturns\n\nretndarrayself as an ndarray\n\n\n\n\nExamples\n&gt;&gt;&gt; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n&gt;&gt;&gt; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n\n", "parameters": ["Parameters", "None", "Returns", "retndarray"], "returns": "retndarrayself as an ndarray", "examples": ["; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n\n", "; x = np.matrix(np.arange(12).reshape((3,4))); x\nmatrix([[ 0,  1,  2,  3],\n        [ 4,  5,  6,  7],\n        [ 8,  9, 10, 11]])\n; x.getA()\narray([[ 0,  1,  2,  3],\n       [ 4,  5,  6,  7],\n       [ 8,  9, 10, 11]])\n"]},
{"library": "numpy", "item_id": "c.PyArray_NDIM", "code": "\nint PyArray_NDIM(PyArrayObject\u00a0*arr)\u00b6", "description": "The number of dimensions in the array.\n", "parameters": ["Parameters"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__truediv__", "code": "\nndarray.__truediv__(self, value, /)\u00b6", "description": "Return self/value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__truediv__", "code": "\nMaskedArray.__truediv__(self, other)[source]\u00b6", "description": "Divide other into self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__sub__", "code": "\nndarray.__sub__(self, value, /)\u00b6", "description": "Return self-value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__sub__", "code": "\nMaskedArray.__sub__(self, other)[source]\u00b6", "description": "Subtract other from self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__str__", "code": "\nndarray.__str__(self, /)\u00b6", "description": "Return str(self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__str__", "code": "\nMaskedArray.__str__(self)[source]\u00b6", "description": "Return str(self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__setstate__", "code": "\nndarray.__setstate__(state, /)\u00b6", "description": "For unpickling.\nThe state argument must be a sequence that contains the following\nelements:\n\nParameters\n\nversionintoptional pickle version. If omitted defaults to 0.\n\nshapetuple\ndtypedata-type\nisFortranbool\nrawdatastring or lista binary string with the data (or a list if \u2018a\u2019 is an object array)\n\n\n\n\n", "parameters": ["Parameters", "versionint", "shapetuple", "dtypedata-type", "isFortranbool", "rawdatastring or list"], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__setstate__", "code": "\ngeneric.__setstate__()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.__setstate__", "code": "\ndtype.__setstate__()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__setmask__", "code": "\nMaskedArray.__setmask__(self, mask, copy=False)[source]\u00b6", "description": "Set the mask.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__setstate__", "code": "\nMaskedArray.__setstate__(self, state)[source]\u00b6", "description": "Restore the internal state of the masked array, for\npickling purposes.  state is typically the output of the\n__getstate__ output, and is a 5-tuple:\n\nclass name\na tuple giving the shape of the data\na typecode for the data\na binary string for the data\na binary string for the mask.\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__setitem__", "code": "\nndarray.__setitem__(self, key, value, /)\u00b6", "description": "Set self[key] to value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__setitem__", "code": "\nMaskedArray.__setitem__(self, indx, value)[source]\u00b6", "description": "x.__setitem__(i, y) &lt;==&gt; x[i]=y\nSet item described by index. If value is masked, masks those\nlocations.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rxor__", "code": "\nMaskedArray.__rxor__(self, value, /)\u00b6", "description": "Return value^self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__rshift__", "code": "\nndarray.__rshift__(self, value, /)\u00b6", "description": "Return self&gt;&gt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rshift__", "code": "\nMaskedArray.__rshift__(self, value, /)\u00b6", "description": "Return self&gt;&gt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rtruediv__", "code": "\nMaskedArray.__rtruediv__(self, other)[source]\u00b6", "description": "Divide self into other, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rrshift__", "code": "\nMaskedArray.__rrshift__(self, value, /)\u00b6", "description": "Return value&gt;&gt;self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rpow__", "code": "\nMaskedArray.__rpow__(self, other)[source]\u00b6", "description": "Raise other to the power self, masking the potential NaNs/Infs\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rsub__", "code": "\nMaskedArray.__rsub__(self, other)[source]\u00b6", "description": "Subtract self from other, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ror__", "code": "\nMaskedArray.__ror__(self, value, /)\u00b6", "description": "Return value|self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rmul__", "code": "\nMaskedArray.__rmul__(self, other)[source]\u00b6", "description": "Multiply other by self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__repr__", "code": "\nndarray.__repr__(self, /)\u00b6", "description": "Return repr(self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rlshift__", "code": "\nMaskedArray.__rlshift__(self, value, /)\u00b6", "description": "Return value&lt;&lt;self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__repr__", "code": "\nMaskedArray.__repr__(self)[source]\u00b6", "description": "Literal string representation.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__reduce__", "code": "\nndarray.__reduce__()\u00b6", "description": "For pickling.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__reduce__", "code": "\nMaskedArray.__reduce__(self)[source]\u00b6", "description": "Return a 3-tuple for pickling a MaskedArray.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rmod__", "code": "\nMaskedArray.__rmod__(self, value, /)\u00b6", "description": "Return value%self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__reduce__", "code": "\ngeneric.__reduce__()\u00b6", "description": "Helper for pickle.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.dtype.__reduce__", "code": "\ndtype.__reduce__()\u00b6", "description": "Helper for pickle.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rdivmod__", "code": "\nMaskedArray.__rdivmod__(self, value, /)\u00b6", "description": "Return divmod(value, self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__rand__", "code": "\nMaskedArray.__rand__(self, value, /)\u00b6", "description": "Return value&amp;self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__pow__", "code": "\nndarray.__pow__(self, value, mod=None, /)\u00b6", "description": "Return pow(self, value, mod).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__pow__", "code": "\nMaskedArray.__pow__(self, other)[source]\u00b6", "description": "Raise self to the power other, masking the potential NaNs/Infs\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__pos__", "code": "\nndarray.__pos__(self, /)\u00b6", "description": "+self\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__or__", "code": "\nndarray.__or__(self, value, /)\u00b6", "description": "Return self|value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__radd__", "code": "\nMaskedArray.__radd__(self, other)[source]\u00b6", "description": "Add other to self, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__or__", "code": "\nMaskedArray.__or__(self, value, /)\u00b6", "description": "Return self|value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__new__", "code": "\nndarray.__new__(*args, **kwargs)\u00b6", "description": "Create and return a new object.  See help(type) for accurate signature.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__new__", "code": "\nstatic MaskedArray.__new__(cls, data=None, mask=False, dtype=None, copy=False, subok=True, ndmin=0, fill_value=None, keep_mask=True, hard_mask=None, shrink=True, order=None, **options)[source]\u00b6", "description": "Create a new masked array from scratch.\nNotes\nA masked array can also be created by taking a .view(MaskedArray).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ne__", "code": "\nndarray.__ne__(self, value, /)\u00b6", "description": "Return self!=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ne__", "code": "\nMaskedArray.__ne__(self, other)[source]\u00b6", "description": "Check whether other does not equal self elementwise.\nWhen either of the elements is masked, the result is masked as well,\nbut the underlying boolean data are still set, with self and other\nconsidered equal if both are masked, and unequal otherwise.\nFor structured arrays, all fields are combined, with masked values\nignored. The result is masked if all fields were masked, with self\nand other considered equal only if both were fully masked.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__mod__", "code": "\nMaskedArray.__mod__(self, value, /)\u00b6", "description": "Return self%value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__neg__", "code": "\nndarray.__neg__(self, /)\u00b6", "description": "-self\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__mul__", "code": "\nndarray.__mul__(self, value, /)\u00b6", "description": "Return self*value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__mul__", "code": "\nMaskedArray.__mul__(self, other)[source]\u00b6", "description": "Multiply self by other, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__mod__", "code": "\nndarray.__mod__(self, value, /)\u00b6", "description": "Return self%value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__matmul__", "code": "\nndarray.__matmul__(self, value, /)\u00b6", "description": "Return self@value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__lt__", "code": "\nndarray.__lt__(self, value, /)\u00b6", "description": "Return self&lt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__lt__", "code": "\nMaskedArray.__lt__(self, value, /)\u00b6", "description": "Return self&lt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__long__", "code": "\nMaskedArray.__long__(self)[source]\u00b6", "description": "Convert to long.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__len__", "code": "\nndarray.__len__(self, /)\u00b6", "description": "Return len(self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__lshift__", "code": "\nndarray.__lshift__(self, value, /)\u00b6", "description": "Return self&lt;&lt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__le__", "code": "\nndarray.__le__(self, value, /)\u00b6", "description": "Return self&lt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__lshift__", "code": "\nMaskedArray.__lshift__(self, value, /)\u00b6", "description": "Return self&lt;&lt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__len__", "code": "\nMaskedArray.__len__(self, /)\u00b6", "description": "Return len(self).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__le__", "code": "\nMaskedArray.__le__(self, value, /)\u00b6", "description": "Return self&lt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ixor__", "code": "\nndarray.__ixor__(self, value, /)\u00b6", "description": "Return self^=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__itruediv__", "code": "\nndarray.__itruediv__(self, value, /)\u00b6", "description": "Return self/=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ixor__", "code": "\nMaskedArray.__ixor__(self, value, /)\u00b6", "description": "Return self^=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__itruediv__", "code": "\nMaskedArray.__itruediv__(self, other)[source]\u00b6", "description": "True divide self by other in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ipow__", "code": "\nndarray.__ipow__(self, value, /)\u00b6", "description": "Return self**=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__isub__", "code": "\nndarray.__isub__(self, value, /)\u00b6", "description": "Return self-=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__isub__", "code": "\nMaskedArray.__isub__(self, other)[source]\u00b6", "description": "Subtract other from self in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__irshift__", "code": "\nndarray.__irshift__(self, value, /)\u00b6", "description": "Return self&gt;&gt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__irshift__", "code": "\nMaskedArray.__irshift__(self, value, /)\u00b6", "description": "Return self&gt;&gt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ipow__", "code": "\nMaskedArray.__ipow__(self, other)[source]\u00b6", "description": "Raise self to the power other, in place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ior__", "code": "\nndarray.__ior__(self, value, /)\u00b6", "description": "Return self|=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__int__", "code": "\nMaskedArray.__int__(self)[source]\u00b6", "description": "Convert to int.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__imul__", "code": "\nMaskedArray.__imul__(self, other)[source]\u00b6", "description": "Multiply self by other in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__invert__", "code": "\nndarray.__invert__(self, /)\u00b6", "description": "~self\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__int__", "code": "\nndarray.__int__(self)\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__imul__", "code": "\nndarray.__imul__(self, value, /)\u00b6", "description": "Return self*=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__imod__", "code": "\nMaskedArray.__imod__(self, value, /)\u00b6", "description": "Return self%=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__imod__", "code": "\nndarray.__imod__(self, value, /)\u00b6", "description": "Return self%=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ior__", "code": "\nMaskedArray.__ior__(self, value, /)\u00b6", "description": "Return self|=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ilshift__", "code": "\nMaskedArray.__ilshift__(self, value, /)\u00b6", "description": "Return self&lt;&lt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ilshift__", "code": "\nndarray.__ilshift__(self, value, /)\u00b6", "description": "Return self&lt;&lt;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__ifloordiv__", "code": "\nndarray.__ifloordiv__(self, value, /)\u00b6", "description": "Return self//=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__ifloordiv__", "code": "\nMaskedArray.__ifloordiv__(self, other)[source]\u00b6", "description": "Floor divide self by other in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__idiv__", "code": "\nMaskedArray.__idiv__(self, other)[source]\u00b6", "description": "Divide self by other in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__iand__", "code": "\nndarray.__iand__(self, value, /)\u00b6", "description": "Return self&amp;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__iand__", "code": "\nMaskedArray.__iand__(self, value, /)\u00b6", "description": "Return self&amp;=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__iadd__", "code": "\nMaskedArray.__iadd__(self, other)[source]\u00b6", "description": "Add other to self in-place.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__gt__", "code": "\nndarray.__gt__(self, value, /)\u00b6", "description": "Return self&gt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__iadd__", "code": "\nndarray.__iadd__(self, value, /)\u00b6", "description": "Return self+=value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__gt__", "code": "\nMaskedArray.__gt__(self, value, /)\u00b6", "description": "Return self&gt;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__getstate__", "code": "\nMaskedArray.__getstate__(self)[source]\u00b6", "description": "Return the internal state of the masked array, for pickling\npurposes.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__getitem__", "code": "\nndarray.__getitem__(self, key, /)\u00b6", "description": "Return self[key].\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__copy__", "code": "\nndarray.__copy__()\u00b6", "description": "Used if copy.copy is called on an array. Returns a copy of the array.\nEquivalent to a.copy(order='K').\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__copy__", "code": "\nMaskedArray.__copy__()\u00b6", "description": "Used if copy.copy is called on an array. Returns a copy of the array.\nEquivalent to a.copy(order='K').\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__contains__", "code": "\nndarray.__contains__(self, key, /)\u00b6", "description": "Return key in self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__contains__", "code": "\nMaskedArray.__contains__(self, key, /)\u00b6", "description": "Return key in self.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.testing.suppress_warnings.__call__", "code": "\nsuppress_warnings.__call__(self, func)[source]\u00b6", "description": "Function decorator to apply certain suppressions to a whole\nfunction.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.vectorize.__call__", "code": "\nvectorize.__call__(self, *args, **kwargs)[source]\u00b6", "description": "Return arrays with the results of pyfunc broadcast (vectorized) over\nargs and kwargs not in excluded.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.polynomial.Polynomial.__call__", "code": "\nPolynomial.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite.Hermite.__call__", "code": "\nHermite.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.legendre.Legendre.__call__", "code": "\nLegendre.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.laguerre.Laguerre.__call__", "code": "\nLaguerre.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.hermite_e.HermiteE.__call__", "code": "\nHermiteE.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.polynomial.chebyshev.Chebyshev.__call__", "code": "\nChebyshev.__call__(self, arg)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.errstate.__call__", "code": "\nerrstate.__call__(self, func)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.poly1d.__call__", "code": "\npoly1d.__call__(self, val)[source]\u00b6", "description": "Call self as a function.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__complex__", "code": "\nndarray.__complex__()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__bool__", "code": "\nndarray.__bool__(self, /)\u00b6", "description": "self != 0\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__bool__", "code": "\nMaskedArray.__bool__(self, /)\u00b6", "description": "self != 0\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__array_wrap__", "code": "\nndarray.__array_wrap__()\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__array_wrap__", "code": "\nMaskedArray.__array_wrap__(self, obj, context=None)[source]\u00b6", "description": "Special hook for ufuncs.\nWraps the numpy array and sets the mask according to context.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__array_priority__", "code": "\nMaskedArray.__array_priority__ = 15\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__array_wrap__", "code": "\ngeneric.__array_wrap__()\u00b6", "description": "sc.__array_wrap__(obj) return scalar from array\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__array_struct__", "code": "\ngeneric.__array_struct__\u00b6", "description": "Array protocol: struct\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__array_priority__", "code": "\ngeneric.__array_priority__\u00b6", "description": "Array priority.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__array__", "code": "\nndarray.__array__()\u00b6", "description": "Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__array_interface__", "code": "\ngeneric.__array_interface__\u00b6", "description": "Array protocol: Python side\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__array__", "code": "\nMaskedArray.__array__()\u00b6", "description": "Returns either a new reference to self if dtype is not given or a new array\nof provided data type if dtype is different from the current dtype of the\narray.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.generic.__array__", "code": "\ngeneric.__array__()\u00b6", "description": "sc.__array__(dtype) return 0-dim array from scalar with specified dtype\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "c.castfunc", "code": "\nvoid castfunc(void*\u00a0from, void*\u00a0to, npy_intp\u00a0n, void*\u00a0fromarr, void*\u00a0toarr)\u00b6", "description": "Cast n elements from one type to another. The data to\ncast from is in a contiguous, correctly-swapped and aligned chunk\nof memory pointed to by from. The buffer to cast to is also\ncontiguous, correctly-swapped and aligned. The fromarr and toarr\narguments should only be used for flexible-element-sized arrays\n(string, unicode, void).\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.class.__array_ufunc__", "code": "\nclass.__array_ufunc__(ufunc, method, *inputs, **kwargs)\u00b6", "description": "\nNew in version 1.13.\n\nAny class, ndarray subclass or not, can define this method or set it to\nNone in order to override the behavior of NumPy\u2019s ufuncs. This works\nquite similarly to Python\u2019s __mul__ and other binary operation routines.\n\nufunc is the ufunc object that was called.\nmethod is a string indicating which Ufunc method was called\n(one of \"__call__\", \"reduce\", \"reduceat\",\n\"accumulate\", \"outer\", \"inner\").\ninputs is a tuple of the input arguments to the ufunc.\nkwargs is a dictionary containing the optional input arguments\nof the ufunc. If given, any out arguments, both positional\nand keyword, are passed as a tuple in kwargs. See the\ndiscussion in Universal functions (ufunc) for details.\n\nThe method should return either the result of the operation, or\nNotImplemented if the operation requested is not implemented.\nIf one of the input or output arguments has a __array_ufunc__\nmethod, it is executed instead of the ufunc.  If more than one of the\narguments implements __array_ufunc__, they are tried in the\norder: subclasses before superclasses, inputs before outputs, otherwise\nleft to right. The first routine returning something other than\nNotImplemented determines the result. If all of the\n__array_ufunc__ operations return NotImplemented, a\nTypeError is raised.\n\nNote\nWe intend to re-implement numpy functions as (generalized)\nUfunc, in which case it will become possible for them to be\noverridden by the __array_ufunc__ method.  A prime candidate is\nmatmul, which currently is not a Ufunc, but could be\nrelatively easily be rewritten as a (set of) generalized Ufuncs. The\nsame may happen with functions such as median,\namin, and argsort.\n\nLike with some other special methods in python, such as __hash__ and\n__iter__, it is possible to indicate that your class does not\nsupport ufuncs by setting __array_ufunc__ = None. Ufuncs always raise\nTypeError when called on an object that sets\n__array_ufunc__ = None.\nThe presence of __array_ufunc__ also influences how\nndarray handles binary operations like arr + obj and arr\n&lt; obj when arr is an ndarray and obj is an instance\nof a custom class. There are two possibilities. If\nobj.__array_ufunc__ is present and not None, then\nndarray.__add__ and friends will delegate to the ufunc machinery,\nmeaning that arr + obj becomes np.add(arr, obj), and then\nadd invokes obj.__array_ufunc__. This is useful if you\nwant to define an object that acts like an array.\nAlternatively, if obj.__array_ufunc__ is set to None, then as a\nspecial case, special methods like ndarray.__add__ will notice this\nand unconditionally raise TypeError. This is useful if you want to\ncreate objects that interact with arrays via binary operations, but\nare not themselves arrays. For example, a units handling system might have\nan object m representing the \u201cmeters\u201d unit, and want to support the\nsyntax arr * m to represent that the array has units of \u201cmeters\u201d, but\nnot want to otherwise interact with arrays via ufuncs or otherwise. This\ncan be done by setting __array_ufunc__ = None and defining __mul__\nand __rmul__ methods. (Note that this means that writing an\n__array_ufunc__ that always returns NotImplemented is not\nquite the same as setting __array_ufunc__ = None: in the former\ncase, arr + obj will raise TypeError, while in the latter\ncase it is possible to define a __radd__ method to prevent this.)\nThe above does not hold for in-place operators, for which ndarray\nnever returns NotImplemented.  Hence, arr += obj would always\nlead to a TypeError.  This is because for arrays in-place operations\ncannot generically be replaced by a simple reverse operation.  (For\ninstance, by default, arr += obj would be translated to arr =\narr + obj, i.e., arr would be replaced, contrary to what is expected\nfor in-place array operations.)\n\nNote\nIf you define __array_ufunc__:\n\nIf you are not a subclass of ndarray, we recommend your\nclass define special methods like __add__ and __lt__ that\ndelegate to ufuncs just like ndarray does.  An easy way to do this\nis to subclass from NDArrayOperatorsMixin.\nIf you subclass ndarray, we recommend that you put all your\noverride logic in __array_ufunc__ and not also override special\nmethods. This ensures the class hierarchy is determined in only one\nplace rather than separately by the ufunc machinery and by the binary\noperation rules (which gives preference to special methods of\nsubclasses; the alternative way to enforce a one-place only hierarchy,\nof setting __array_ufunc__ to None, would seem very\nunexpected and thus confusing, as then the subclass would not work at\nall with ufuncs).\nndarray defines its own __array_ufunc__, which,\nevaluates the ufunc if no arguments have overrides, and returns\nNotImplemented otherwise. This may be useful for subclasses\nfor which __array_ufunc__ converts any instances of its own\nclass to ndarray: it can then pass these on to its\nsuperclass using super().__array_ufunc__(*inputs, **kwargs),\nand finally return the results after possible back-conversion. The\nadvantage of this practice is that it ensures that it is possible\nto have a hierarchy of subclasses that extend the behaviour. See\nSubclassing ndarray for details.\n\n\n\nNote\nIf a class defines the __array_ufunc__ method,\nthis disables the __array_wrap__,\n__array_prepare__, __array_priority__ mechanism\ndescribed below for ufuncs (which may eventually be deprecated).\n\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__and__", "code": "\nndarray.__and__(self, value, /)\u00b6", "description": "Return self&amp;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__and__", "code": "\nMaskedArray.__and__(self, value, /)\u00b6", "description": "Return self&amp;value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__add__", "code": "\nMaskedArray.__add__(self, other)[source]\u00b6", "description": "Add self to other, and return a new masked array.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__abs__", "code": "\nndarray.__abs__(self)\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ndarray.__add__", "code": "\nndarray.__add__(self, value, /)\u00b6", "description": "Return self+value.\n", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "numpy.ma.MaskedArray.__abs__", "code": "\nMaskedArray.__abs__(self)\u00b6", "description": "", "parameters": [], "returns": [], "examples": []},
{"library": "numpy", "item_id": "None", "code": "None", "description": [], "parameters": [], "returns": [], "examples": []}
]