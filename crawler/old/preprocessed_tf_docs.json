[{"id": "tf.function", "type": "function", "code": "tf.function(func=None,input_signature=None,autograph=True,experimental_implements=None,experimental_autograph_options=None,experimental_relax_shapes=False,experimental_compile=None)", "summary": "Compiles a function into a callable TensorFlow graph.", "description": "", "code-info": {"name": "tf.function", "parameters": [{"name": "func", "is_optional": true, "type": "others", "default_value": "None", "description": "the function to be compiled. If func is None, tf.function returns\na decorator that can be invoked with a single argument - func. In other\nwords, tf.function(input_signature=...)(func) is equivalent to\ntf.function(func, input_signature=...). The former can be used as\ndecorator."}, {"name": "input_signature", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A possibly nested sequence of tf.TensorSpec objects\nspecifying the shapes and dtypes of the Tensors that will be supplied to\nthis function. If None, a separate function is instantiated for each\ninferred input signature.  If input_signature is specified, every input to\nfunc must be a Tensor, and func cannot accept **kwargs."}, {"name": "autograph", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether autograph should be applied on func before tracing a\ngraph. Data-dependent control flow requires autograph=True. For more\ninformation, see the tf.function and AutoGraph guide."}, {"name": "experimental_implements", "is_optional": true, "type": "string", "default_value": "None", "description": "If provided, contains a name of a \"known\" function\nthis implements. For example \"mycompany.my_recurrent_cell\".\nThis is stored as an attribute in inference function,\nwhich can then be detected when processing serialized function.\nSee\nhttps://github.com/tensorflow/community/blob/master/rfcs/20190610-standardizing-composite_ops.md\nfor details.  For an example of utilizing this attribute see:\nhttps://github.com/tensorflow/tensorflow/blob/master/tensorflow/compiler/mlir/lite/transforms/prepare_composite_functions_tf.cc\nThe code above automatically detects and substitutes function that\nimplements \"embedded_matmul\" and allows TFLite to substitute its own\nimplementations. For instance, a tensorflow user can use this\nattribute to mark that their function also implements\nembedded_matmul`` (perhaps more efficiently!)\nby specifying it using this flag.\n\n\n\n@tf.function(experimental_implements=\"embedded_matmul\"):\ndef embedding_matmul(a, b):\n   # custom implementation here\n\n\n"}, {"name": "experimental_autograph_options", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tuple of\ntf.autograph.experimental.Feature values."}, {"name": "experimental_relax_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": "When True, tf.function may generate fewer,\ngraphs that are less specialized on input shapes."}, {"name": "experimental_compile", "is_optional": true, "type": "others", "default_value": "None", "description": "If True, the function is always compiled by\nXLA. XLA may be more efficient in some\ncases (e.g. TPU, XLA_GPU, dense tensor computations)."}]}},
{"id": "tf.gather_nd", "type": "function", "code": "tf.gather_nd(params,indices,batch_dims=0,name=None)", "summary": "Gather slices from params into a Tensor with shape specified by indices.", "description": "", "code-info": {"name": "tf.gather_nd", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A Tensor. The tensor from which to gather values."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor.\nname: A name for the operation (optional)."}, {"name": "batch_dims", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer or a scalar 'Tensor'. The number of batch dimensions.\n\n\nReturns:\n\nA Tensor. Has the same type as params.\n\n          "}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\nbatch_dims: An integer or a scalar 'Tensor'. The number of batch dimensions."}]}},
{"id": "tf.fill", "type": "function", "code": "tf.fill(dims,value,name=None)", "summary": "Creates a tensor filled with a scalar value.", "description": "", "code-info": {"name": "tf.fill", "parameters": [{"name": "dims", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. 1-D.\nRepresents the shape of the output tensor."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 0-D (scalar). Value to fill the returned tensor.\n@compatibility(numpy) Equivalent to np.full @end_compatibility"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.fingerprint", "type": "function", "code": "tf.fingerprint(data,method='farmhash64',name=None)", "summary": "Generates fingerprint values.", "description": "", "code-info": {"name": "tf.fingerprint", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have rank 1 or higher."}, {"name": "method", "is_optional": true, "type": "string", "default_value": "'farmhash64'", "description": "A Tensor of type tf.string. Fingerprint method used by this op.\nCurrently available method is farmhash64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.gather", "type": "function", "code": "tf.gather(params,indices,validate_indices=None,axis=None,batch_dims=0,name=None)", "summary": "Gather slices from params axis axis according to indices.", "description": "", "code-info": {"name": "tf.gather", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "The Tensor from which to gather values. Must be at least rank\naxis + 1."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "The index Tensor.  Must be one of the following types: int32,\nint64. Must be in range [0, params.shape[axis])."}, {"name": "validate_indices", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated, does nothing."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64. The\naxis in params to gather indices from. Must be greater than or equal\nto batch_dims.  Defaults to the first non-batch dimension. Supports\nnegative indexes."}, {"name": "batch_dims", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer.  The number of batch dimensions.  Must be less\nthan rank(indices)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.foldl", "type": "function", "code": "tf.foldl(fn,elems,initializer=None,parallel_iterations=10,back_prop=True,swap_memory=False,name=None)", "summary": "foldl on the list of tensors unpacked from elems on dimension 0.", "description": "", "code-info": {"name": "tf.foldl", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "The callable to be performed."}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "A tensor or (possibly nested) sequence of tensors, each of which will\nbe unpacked along their first dimension.  The nested sequence of the\nresulting slices will be the first argument to fn."}, {"name": "initializer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) A tensor or (possibly nested) sequence of tensors,\nas the initial value for the accumulator."}, {"name": "parallel_iterations", "is_optional": true, "type": "int", "default_value": "10", "description": "(optional) The number of iterations allowed to run in\nparallel."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) True enables support for back propagation."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "(optional) True enables GPU-CPU memory swapping."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) Name prefix for the returned tensors."}]}},
{"id": "tf.expand_dims", "type": "function", "code": "tf.expand_dims(input,axis,name=None)", "summary": "Returns a tensor with an additional dimension inserted at index axis.", "description": "", "code-info": {"name": "tf.expand_dims", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axis", "is_optional": false, "type": "int", "description": "Integer specifying the dimension index at which to expand the\nshape of input. Given an input of D dimensions, axis must be in range\n[-(D+1), D] (inclusive)."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional string. The name of the output Tensor."}]}},
{"id": "tf.eye", "type": "function", "code": "tf.eye(num_rows,num_columns=None,batch_shape=None,dtype=tf.dtypes.float32,name=None)", "summary": "Construct an identity matrix, or a batch of matrices.", "description": "", "code-info": {"name": "tf.eye", "parameters": [{"name": "num_rows", "is_optional": false, "type": "tensor", "description": "Non-negative int32 scalar Tensor giving the number of rows\nin each batch matrix."}, {"name": "num_columns", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional non-negative int32 scalar Tensor giving the number\nof columns in each batch matrix.  Defaults to num_rows."}, {"name": "batch_shape", "is_optional": true, "type": "int", "default_value": "None", "description": " A list or tuple of Python integers or a 1-D int32 Tensor.\nIf provided, the returned Tensor will have leading batch dimensions of\nthis shape."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": " The type of an element in the resulting Tensor"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this Op.  Defaults to \"eye\"."}]}},
{"id": "tf.executing_eagerly", "type": "function", "code": "tf.executing_eagerly()", "summary": "Checks whether the current thread has eager execution enabled.", "description": "", "code-info": {"name": "tf.executing_eagerly", "parameters": []}},
{"id": "tf.foldr", "type": "function", "code": "tf.foldr(fn,elems,initializer=None,parallel_iterations=10,back_prop=True,swap_memory=False,name=None)", "summary": "foldr on the list of tensors unpacked from elems on dimension 0.", "description": "", "code-info": {"name": "tf.foldr", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "The callable to be performed."}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "A tensor or (possibly nested) sequence of tensors, each of which will\nbe unpacked along their first dimension.  The nested sequence of the\nresulting slices will be the first argument to fn."}, {"name": "initializer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) A tensor or (possibly nested) sequence of tensors,\nas the initial value for the accumulator."}, {"name": "parallel_iterations", "is_optional": true, "type": "int", "default_value": "10", "description": "(optional) The number of iterations allowed to run in\nparallel."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) True enables support for back propagation."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "(optional) True enables GPU-CPU memory swapping."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) Name prefix for the returned tensors."}]}},
{"id": "tf.einsum", "type": "function", "code": "tf.einsum(equation,*inputs,**kwargs)", "summary": "Tensor contraction over specified indices and outer product.", "description": "", "code-info": {"name": "tf.einsum", "parameters": [{"name": "equation", "is_optional": false, "type": "string", "description": "a str describing the contraction, in the same format as\nnumpy.einsum."}, {"name": "*inputs", "is_optional": false, "type": "tensor", "description": "the inputs to contract (each one a Tensor), whose shapes should\nbe consistent with equation."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "  - optimize: Optimization strategy to use to find contraction path using\nopt_einsum. Must be 'greedy', 'optimal', 'branch-2', 'branch-all' or\n  'auto'. (optional, default: 'greedy')."}]}},
{"id": "tf.extract_volume_patches", "type": "function", "code": "tf.extract_volume_patches(input,ksizes,strides,padding,name=None)", "summary": "Extract patches from input and put them in the \"depth\" output dimension. 3D extension of extract_image_patches.", "description": "", "code-info": {"name": "tf.extract_volume_patches", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64.\n5-D Tensor with shape [batch, in_planes, in_rows, in_cols, depth]."}, {"name": "ksizes", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 5.\nThe size of the sliding window for each dimension of input."}, {"name": "strides", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 5.\n1-D of length 5. How far the centers of two consecutive patches are in\ninput. Must be: [1, stride_planes, stride_rows, stride_cols, 1]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use.\n\nWe specify the size-related attributes as:\n\n\n\n      ksizes = [1, ksize_planes, ksize_rows, ksize_cols, 1]\n      strides = [1, stride_planes, strides_rows, strides_cols, 1]\n\n\n"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.ensure_shape", "type": "function", "code": "tf.ensure_shape(x,shape,name=None)", "summary": "Updates the shape of a tensor and checks at runtime that the shape holds.", "description": "", "code-info": {"name": "tf.ensure_shape", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A TensorShape representing the shape of this tensor, a\nTensorShapeProto, a list, a tuple, or None."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to \"EnsureShape\"."}]}},
{"id": "tf.eigvals", "type": "function", "code": "tf.eigvals(tensor,name=None)", "summary": "Computes the eigenvalues of one or more matrices.", "description": "", "code-info": {"name": "tf.eigvals", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., N, N]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.linalg.LinearOperatorAdjoint", "type": "class", "code": "tf.linalg.LinearOperatorAdjoint(operator,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name=None)", "summary": "LinearOperator representing the adjoint of another operator.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorAdjoint", "parameters": [{"name": "operator", "is_optional": false, "type": "others", "description": "LinearOperator object."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator. Default is operator.name +\n\"_adjoint\"."}]}},
{"id": "tf.eig", "type": "function", "code": "tf.eig(tensor,name=None)", "summary": "Computes the eigen decomposition of a batch of matrices.", "description": "", "code-info": {"name": "tf.eig", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., N, N]. Only the lower triangular part of\neach inner inner matrix is referenced."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.compat.v1.train.batch", "type": "function", "code": "tf.compat.v1.train.batch(tensors,batch_size,num_threads=1,capacity=32,enqueue_many=False,shapes=None,dynamic_pad=False,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Creates batches of tensors in tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.batch", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "The list or dictionary of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "The new batch size pulled from the queue."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of threads enqueuing tensors.  The batching will\nbe nondeterministic if num_threads &gt; 1."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. The maximum number of elements in the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensors is a single example."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensors."}, {"name": "dynamic_pad", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  Allow variable dimensions in input shapes.\nThe given dimensions are padded upon dequeue so that tensors within a\nbatch have the same shapes."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.keras.callbacks.TerminateOnNaN", "type": "function", "code": "tf.keras.callbacks.TerminateOnNaN()", "summary": "Callback that terminates training when a NaN loss is encountered.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.TerminateOnNaN", "parameters": []}},
{"id": "tf.keras.callbacks.TensorBoard", "type": "function", "code": "tf.keras.callbacks.TensorBoard(log_dir='logs',histogram_freq=0,write_graph=True,write_images=False,update_freq='epoch',profile_batch=2,embeddings_freq=0,embeddings_metadata=None,**kwargs)", "summary": "Enable visualizations for TensorBoard.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.TensorBoard", "parameters": [{"name": "log_dir", "is_optional": true, "type": "string", "default_value": "'logs'", "description": "the path of the directory where to save the log files to be\nparsed by TensorBoard."}, {"name": "histogram_freq", "is_optional": true, "type": "int", "default_value": "0", "description": "frequency (in epochs) at which to compute activation and\nweight histograms for the layers of the model. If set to 0, histograms\nwon't be computed. Validation data (or split) must be specified for\nhistogram visualizations."}, {"name": "write_graph", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to visualize the graph in TensorBoard. The log file\ncan become quite large when write_graph is set to True."}, {"name": "write_images", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to write model weights to visualize as image in\nTensorBoard."}, {"name": "update_freq", "is_optional": true, "type": "string", "default_value": "'epoch'", "description": "'batch' or 'epoch' or integer. When using 'batch',\nwrites the losses and metrics to TensorBoard after each batch. The same\napplies for 'epoch'. If using an integer, let's say 1000, the\ncallback will write the metrics and losses to TensorBoard every 1000\nbatches. Note that writing too frequently to TensorBoard can slow down\nyour training."}, {"name": "profile_batch", "is_optional": true, "type": "int", "default_value": "2", "description": "Profile the batch to sample compute characteristics. By\ndefault, it will profile the second batch. Set profile_batch=0 to\ndisable profiling. Must run in TensorFlow eager mode."}, {"name": "embeddings_freq", "is_optional": true, "type": "int", "default_value": "0", "description": "frequency (in epochs) at which embedding layers will\nbe visualized. If set to 0, embeddings won't be visualized."}, {"name": "embeddings_metadata", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.callbacks.RemoteMonitor", "type": "function", "code": "tf.keras.callbacks.RemoteMonitor(root='http://localhost:9000',path='/publish/epoch/end/',field='data',headers=None,send_as_json=False)", "summary": "Callback used to stream events to a server.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.RemoteMonitor", "parameters": [{"name": "root", "is_optional": true, "type": "string", "default_value": "'http://localhost:9000'", "description": "String; root url of the target server."}, {"name": "path", "is_optional": true, "type": "string", "default_value": "'/publish/epoch/end/'", "description": "String; path relative to root to which the events will be sent."}, {"name": "field", "is_optional": true, "type": "string", "default_value": "'data'", "description": "String; JSON field under which the data will be stored.\nThe field is used only if the payload is sent within a form\n(i.e. send_as_json is set to False)."}, {"name": "headers", "is_optional": true, "type": "others", "default_value": "None", "description": "Dictionary; optional custom HTTP headers."}, {"name": "send_as_json", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean; whether the request should be\nsent as application/json."}]}},
{"id": "tf.train.load_checkpoint", "type": "function", "code": "tf.train.load_checkpoint(ckpt_dir_or_file)", "summary": "Returns CheckpointReader for checkpoint found in ckpt_dir_or_file.", "description": "", "code-info": {"name": "tf.train.load_checkpoint", "parameters": [{"name": "ckpt_dir_or_file", "is_optional": false, "type": "others", "description": "Directory with checkpoints file or path to checkpoint\nfile."}]}},
{"id": "tf.train.list_variables", "type": "function", "code": "tf.train.list_variables(ckpt_dir_or_file)", "summary": "Returns list of all variables in the checkpoint.", "description": "", "code-info": {"name": "tf.train.list_variables", "parameters": [{"name": "ckpt_dir_or_file", "is_optional": false, "type": "others", "description": "Directory with checkpoints file or path to checkpoint."}]}},
{"id": "tf.train.latest_checkpoint", "type": "function", "code": "tf.train.latest_checkpoint(checkpoint_dir,latest_filename=None)", "summary": "Finds the filename of latest saved checkpoint file.", "description": "", "code-info": {"name": "tf.train.latest_checkpoint", "parameters": [{"name": "checkpoint_dir", "is_optional": false, "type": "others", "description": "Directory where the variables were saved."}, {"name": "latest_filename", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the protocol buffer file that\ncontains the list of most recent checkpoint filenames.\nSee the corresponding argument to Saver.save()."}]}},
{"id": "tf.train.get_checkpoint_state", "type": "function", "code": "tf.train.get_checkpoint_state(checkpoint_dir,latest_filename=None)", "summary": "Returns CheckpointState proto from the \"checkpoint\" file.", "description": "", "code-info": {"name": "tf.train.get_checkpoint_state", "parameters": [{"name": "checkpoint_dir", "is_optional": false, "type": "others", "description": "The directory of checkpoints."}, {"name": "latest_filename", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name of the checkpoint file.  Default to\n'checkpoint'."}]}},
{"id": "tf.train.ExponentialMovingAverage", "type": "class", "code": "tf.train.ExponentialMovingAverage(decay,num_updates=None,zero_debias=False,name='ExponentialMovingAverage')", "summary": "Maintains moving averages of variables by employing an exponential decay.", "description": "", "code-info": {"name": "tf.train.ExponentialMovingAverage", "parameters": [{"name": "decay", "is_optional": false, "type": "float", "description": "Float.  The decay to use."}, {"name": "num_updates", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional count of number of updates applied to variables."}, {"name": "zero_debias", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, zero debias moving-averages that are initialized\nwith tensors."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ExponentialMovingAverage'", "description": "String. Optional prefix name to use for the name of ops added in\napply()."}]}},
{"id": "tf.xla.experimental.compile", "type": "function", "code": "tf.xla.experimental.compile(computation,inputs=None)", "summary": "Builds an operator that compiles and runs computation with XLA.", "description": "", "code-info": {"name": "tf.xla.experimental.compile", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds a computation to apply to the\ninput. If the function takes n inputs, 'inputs' should be a list of n\ntensors.\n\ncomputation may return a list of operations and tensors.  Tensors must\ncome before operations in the returned list.  The return value of\ncompile is a list of tensors corresponding to the tensors from the\noutput of computation.\n\nAll Operations returned from computation will be executed when\nevaluating any of the returned output tensors."}, {"name": "inputs", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of inputs or None (equivalent to an empty list). Each input\ncan be a nested structure containing values that are convertible to\ntensors. Note that passing an N-dimension list of compatible values will\nresult in a N-dimension list of scalar tensors rather than a single Rank-N\ntensors. If you need different behavior, convert part of inputs to tensors\nwith tf.convert_to_tensor."}]}},
{"id": "tf.xla.experimental.jit_scope", "type": "function", "code": "tf.xla.experimental.jit_scope(*args,**kwds)", "summary": "Enable or disable JIT compilation of operators within the scope.", "description": "", "code-info": {"name": "tf.xla.experimental.jit_scope", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwds", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "importioimportnumpyclassNumpyWrapper", "type": "function", "code": "importioimportnumpyclassNumpyWrapper(tf.train.experimental.PythonState):def__init__(self,array):self.array=arraydefserialize(self):string_file=io.BytesIO()try:numpy.save(string_file,self.array,allow_pickle=False)serialized=string_file.getvalue()finally:string_file.close()returnserializeddefdeserialize(self,string_value):string_file=io.BytesIO(string_value)try:self.array=numpy.load(string_file,allow_pickle=False)finally:string_file.close()", "summary": "A mixin for putting Python state in an object-based checkpoint.", "description": "", "code-info": {"name": "importioimportnumpyclassNumpyWrapper", "parameters": [{"name": "tf.train.experimental.PythonState):def__init_", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.train.experimental.enable_mixed_precision_graph_rewrite", "type": "function", "code": "tf.train.experimental.enable_mixed_precision_graph_rewrite(opt,loss_scale='dynamic')", "summary": "Enable mixed precision via a graph rewrite.", "description": "", "code-info": {"name": "tf.train.experimental.enable_mixed_precision_graph_rewrite", "parameters": [{"name": "opt", "is_optional": false, "type": "others", "description": "An instance of a tf.keras.optimizers.Optimizer."}, {"name": "loss_scale", "is_optional": true, "type": "string", "default_value": "'dynamic'", "description": "Either an int/float, the string \"dynamic\", or an instance of a\ntf.mixed_precision.experimental.LossScale. The loss scale to use. It is\nrecommended to keep this as its default value of \"dynamic\", which will\nadjust the scaling automatically to prevent Inf or NaN values."}]}},
{"id": "tf.train.experimental.disable_mixed_precision_graph_rewrite", "type": "function", "code": "tf.train.experimental.disable_mixed_precision_graph_rewrite()", "summary": "Disables the mixed precision graph rewrite.", "description": "", "code-info": {"name": "tf.train.experimental.disable_mixed_precision_graph_rewrite", "parameters": []}},
{"id": "tf.train.ClusterSpec", "type": "class", "code": "tf.train.ClusterSpec(cluster)", "summary": "Represents a cluster as a set of \"tasks\", organized into \"jobs\".", "description": "", "code-info": {"name": "tf.train.ClusterSpec", "parameters": [{"name": "cluster", "is_optional": false, "type": "string", "description": "A dictionary mapping one or more job names to (i) a list of\nnetwork addresses, or (ii) a dictionary mapping integer task indices to\nnetwork addresses; or a tf.train.ClusterDef protocol buffer."}]}},
{"id": "tf.train.load_variable", "type": "function", "code": "tf.train.load_variable(ckpt_dir_or_file,name)", "summary": "Returns the tensor value of the given variable in the checkpoint.", "description": "", "code-info": {"name": "tf.train.load_variable", "parameters": [{"name": "ckpt_dir_or_file", "is_optional": false, "type": "others", "description": "Directory with checkpoints file or path to checkpoint."}, {"name": "name", "is_optional": false, "type": "string", "description": "Name of the variable to return."}]}},
{"id": "tf.train.Coordinator", "type": "class", "code": "tf.train.Coordinator(clean_stop_exception_types=None)", "summary": "A coordinator for threads.", "description": "", "code-info": {"name": "tf.train.Coordinator", "parameters": [{"name": "clean_stop_exception_types", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tuple of Exception types that should\ncause a clean stop of the coordinator. If an exception of one of these\ntypes is reported to request_stop(ex) the coordinator will behave as\nif request_stop(None) was called.  Defaults to\n(tf.errors.OutOfRangeError,) which is used by input queues to signal\nthe end of input. When feeding training data from a Python iterator it\nis common to add StopIteration to this list."}]}},
{"id": "tf.train.checkpoints_iterator", "type": "function", "code": "tf.train.checkpoints_iterator(checkpoint_dir,min_interval_secs=0,timeout=None,timeout_fn=None)", "summary": "Continuously yield new checkpoint files as they appear.", "description": "", "code-info": {"name": "tf.train.checkpoints_iterator", "parameters": [{"name": "checkpoint_dir", "is_optional": false, "type": "others", "description": "The directory in which checkpoints are saved."}, {"name": "min_interval_secs", "is_optional": true, "type": "int", "default_value": "0", "description": "The minimum number of seconds between yielding\ncheckpoints."}, {"name": "timeout", "is_optional": true, "type": "others", "default_value": "None", "description": "The maximum number of seconds to wait between checkpoints. If left\nas None, then the process will wait indefinitely."}, {"name": "timeout_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional function to call after a timeout.  If the function\nreturns True, then it means that no new checkpoints will be generated and\nthe iterator will exit.  The function is called with no arguments."}]}},
{"id": "tf.train.Checkpoint", "type": "class", "code": "tf.train.Checkpoint(**kwargs)", "summary": "Groups trackable objects, saving and restoring them.", "description": "", "code-info": {"name": "tf.train.Checkpoint", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": "Keyword arguments are set as attributes of this object, and are\nsaved with the checkpoint. Values must be trackable objects."}]}},
{"id": "tf.train.CheckpointManager", "type": "class", "code": "tf.train.CheckpointManager(checkpoint,directory,max_to_keep,keep_checkpoint_every_n_hours=None,checkpoint_name='ckpt')", "summary": "Deletes old checkpoints.", "description": "", "code-info": {"name": "tf.train.CheckpointManager", "parameters": [{"name": "checkpoint", "is_optional": false, "type": "others", "description": "The tf.train.Checkpoint instance to save and manage\ncheckpoints for."}, {"name": "directory", "is_optional": false, "type": "others", "description": "The path to a directory in which to write checkpoints. A\nspecial file named \"checkpoint\" is also written to this directory (in a\nhuman-readable text format) which contains the state of the\nCheckpointManager."}, {"name": "max_to_keep", "is_optional": false, "type": "int", "description": "An integer, the number of checkpoints to keep. Unless\npreserved by keep_checkpoint_every_n_hours, checkpoints will be\ndeleted from the active set, oldest first, until only max_to_keep\ncheckpoints remain. If None, no checkpoints are deleted and everything\nstays in the active set. Note that max_to_keep=None will keep all\ncheckpoint paths in memory and in the checkpoint state protocol buffer\non disk."}, {"name": "keep_checkpoint_every_n_hours", "is_optional": true, "type": "others", "default_value": "None", "description": "Upon removal from the active set, a\ncheckpoint will be preserved if it has been at least\nkeep_checkpoint_every_n_hours since the last preserved checkpoint. The\ndefault setting of None does not preserve any checkpoints in this way."}, {"name": "checkpoint_name", "is_optional": true, "type": "string", "default_value": "'ckpt'", "description": "Custom name for the checkpoint file."}]}},
{"id": "tf.tpu.experimental.shutdown_tpu_system", "type": "function", "code": "tf.tpu.experimental.shutdown_tpu_system(cluster_resolver=None)", "summary": "Shuts down the TPU devices.", "description": "", "code-info": {"name": "tf.tpu.experimental.shutdown_tpu_system", "parameters": [{"name": "cluster_resolver", "is_optional": true, "type": "string", "default_value": "None", "description": "A tf.distribute.cluster_resolver.TPUClusterResolver,\nwhich provides information about the TPU cluster."}]}},
{"id": "tf.tpu.experimental.DeviceAssignment", "type": "class", "code": "tf.tpu.experimental.DeviceAssignment(topology,core_assignment)", "summary": "Mapping from logical cores in a computation to the physical TPU topology.", "description": "", "code-info": {"name": "tf.tpu.experimental.DeviceAssignment", "parameters": [{"name": "topology", "is_optional": false, "type": "others", "description": "A Topology object that describes the physical TPU topology."}, {"name": "core_assignment", "is_optional": false, "type": "others", "description": "A logical to physical core mapping, represented as a\nrank 3 numpy array. See the description of the core_assignment\nproperty for more details."}]}},
{"id": "tf.tpu.experimental.initialize_tpu_system", "type": "function", "code": "tf.tpu.experimental.initialize_tpu_system(cluster_resolver=None)", "summary": "Initialize the TPU devices.", "description": "", "code-info": {"name": "tf.tpu.experimental.initialize_tpu_system", "parameters": [{"name": "cluster_resolver", "is_optional": true, "type": "string", "default_value": "None", "description": "A tf.distribute.cluster_resolver.TPUClusterResolver,\nwhich provides information about the TPU cluster."}]}},
{"id": "tf.test.TestCase.failureException", "type": "function", "code": "tf.test.TestCase.failureException(*args,**kwargs)", "summary": "Assertion failed.", "description": "", "code-info": {"name": "tf.test.TestCase.failureException", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.test.TestCase", "type": "function", "code": "tf.test.TestCase(methodName='runTest')", "summary": "Base class for tests that need to test TensorFlow.", "description": "", "code-info": {"name": "tf.test.TestCase", "parameters": [{"name": "methodName", "is_optional": true, "type": "string", "default_value": "'runTest'", "description": ""}]}},
{"id": "tf.test.main", "type": "function", "code": "tf.test.main(argv=None)", "summary": "Runs all unit tests.", "description": "", "code-info": {"name": "tf.test.main", "parameters": [{"name": "argv", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.test.is_gpu_available", "type": "function", "code": "tf.test.is_gpu_available(cuda_only=False,min_cuda_compute_capability=None)", "summary": "Returns whether TensorFlow can access a GPU. (deprecated)", "description": "", "code-info": {"name": "tf.test.is_gpu_available", "parameters": [{"name": "cuda_only", "is_optional": true, "type": "bool", "default_value": "False", "description": "limit the search to CUDA GPUs."}, {"name": "min_cuda_compute_capability", "is_optional": true, "type": "others", "default_value": "None", "description": "a (major,minor) pair that indicates the minimum\nCUDA compute capability required, or None if no requirement."}]}},
{"id": "tf.test.is_built_with_rocm", "type": "function", "code": "tf.test.is_built_with_rocm()", "summary": "Returns whether TensorFlow was built with ROCm (GPU) support.", "description": "", "code-info": {"name": "tf.test.is_built_with_rocm", "parameters": []}},
{"id": "tf.test.is_built_with_gpu_support", "type": "function", "code": "tf.test.is_built_with_gpu_support()", "summary": "Returns whether TensorFlow was built with GPU (i.e. CUDA or ROCm) support.", "description": "", "code-info": {"name": "tf.test.is_built_with_gpu_support", "parameters": []}},
{"id": "tf.test.gpu_device_name", "type": "function", "code": "tf.test.gpu_device_name()", "summary": "Returns the name of a GPU device if available or the empty string.", "description": "", "code-info": {"name": "tf.test.gpu_device_name", "parameters": []}},
{"id": "tf.test.benchmark_config", "type": "function", "code": "tf.test.benchmark_config()", "summary": "Returns a tf.compat.v1.ConfigProto for disabling the dependency optimizer.", "description": "", "code-info": {"name": "tf.test.benchmark_config", "parameters": []}},
{"id": "tf.test.Benchmark", "type": "function", "code": "tf.test.Benchmark()", "summary": "Abstract class that provides helpers for TensorFlow benchmarks.", "description": "", "code-info": {"name": "tf.test.Benchmark", "parameters": []}},
{"id": "tf.test.is_built_with_cuda", "type": "function", "code": "tf.test.is_built_with_cuda()", "summary": "Returns whether TensorFlow was built with CUDA (GPU) support.", "description": "", "code-info": {"name": "tf.test.is_built_with_cuda", "parameters": []}},
{"id": "tf.sysconfig.get_link_flags", "type": "function", "code": "tf.sysconfig.get_link_flags()", "summary": "Get the link flags for custom operators.", "description": "", "code-info": {"name": "tf.sysconfig.get_link_flags", "parameters": []}},
{"id": "tf.test.compute_gradient", "type": "function", "code": "tf.test.compute_gradient(f,x,delta=0.001)", "summary": "Computes the theoretical and numeric Jacobian of f.", "description": "", "code-info": {"name": "tf.test.compute_gradient", "parameters": [{"name": "f", "is_optional": false, "type": "others", "description": "the function."}, {"name": "x", "is_optional": false, "type": "others", "description": "a list arguments for the function"}, {"name": "delta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "(optional) perturbation used to compute numeric Jacobian."}]}},
{"id": "tf.sysconfig.get_include", "type": "function", "code": "tf.sysconfig.get_include()", "summary": "Get the directory containing the TensorFlow C++ header files.", "description": "", "code-info": {"name": "tf.sysconfig.get_include", "parameters": []}},
{"id": "tf.sysconfig.get_lib", "type": "function", "code": "tf.sysconfig.get_lib()", "summary": "Get the directory containing the TensorFlow framework library.", "description": "", "code-info": {"name": "tf.sysconfig.get_lib", "parameters": []}},
{"id": "tf.test.assert_equal_graph_def", "type": "function", "code": "tf.test.assert_equal_graph_def(expected,actual)", "summary": "Asserts that two GraphDefs are (mostly) the same.", "description": "", "code-info": {"name": "tf.test.assert_equal_graph_def", "parameters": [{"name": "expected", "is_optional": false, "type": "others", "description": "The GraphDef we expected."}, {"name": "actual", "is_optional": false, "type": "others", "description": "The GraphDef we have."}]}},
{"id": "tf.test.create_local_cluster", "type": "function", "code": "tf.test.create_local_cluster(num_workers,num_ps,protocol='grpc',worker_config=None,ps_config=None)", "summary": "Create and start local servers and return the associated Server objects.", "description": "", "code-info": {"name": "tf.test.create_local_cluster", "parameters": [{"name": "num_workers", "is_optional": false, "type": "others", "description": "Number of worker servers to start."}, {"name": "num_ps", "is_optional": false, "type": "others", "description": "Number of PS servers to start."}, {"name": "protocol", "is_optional": true, "type": "string", "default_value": "'grpc'", "description": "Communication protocol. Allowed values are documented in the\ndocumentation of tf.distribute.Server."}, {"name": "worker_config", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) tf.ConfigProto to initialize workers. Can be\nused to instantiate multiple devices etc."}, {"name": "ps_config", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) tf.ConfigProto to initialize PS servers."}]}},
{"id": "tf.summary.experimental.write_raw_pb", "type": "function", "code": "tf.summary.experimental.write_raw_pb(tensor,step=None,name=None)", "summary": "Writes a summary using raw tf.compat.v1.Summary protocol buffers.", "description": "", "code-info": {"name": "tf.summary.experimental.write_raw_pb", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "the string Tensor holding one or more serialized Summary protobufs"}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string name for this op."}]}},
{"id": "tf.sysconfig.get_compile_flags", "type": "function", "code": "tf.sysconfig.get_compile_flags()", "summary": "Get the compilation flags for custom operators.", "description": "", "code-info": {"name": "tf.sysconfig.get_compile_flags", "parameters": []}},
{"id": "tf.summary.experimental.set_step", "type": "function", "code": "tf.summary.experimental.set_step(step)", "summary": "Sets the default summary step for the current thread.", "description": "", "code-info": {"name": "tf.summary.experimental.set_step", "parameters": [{"name": "step", "is_optional": false, "type": "others", "description": "An int64-castable default step value, or None to unset."}]}},
{"id": "tf.summary.trace_on", "type": "function", "code": "tf.summary.trace_on(graph=True,profiler=False)", "summary": "Starts a trace to record computation graphs and profiling information.", "description": "", "code-info": {"name": "tf.summary.trace_on", "parameters": [{"name": "graph", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, enables collection of executed graphs. It includes ones from\ntf.function invocation and ones from the legacy graph mode. The default\nis True."}, {"name": "profiler", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, enables the advanced profiler. Enabling profiler\nimplicitly enables the graph collection. The profiler may incur a high\nmemory overhead. The default is False."}]}},
{"id": "tf.summary.experimental.get_step", "type": "function", "code": "tf.summary.experimental.get_step()", "summary": "Returns the default summary step for the current thread.", "description": "", "code-info": {"name": "tf.summary.experimental.get_step", "parameters": []}},
{"id": "tf.summary.trace_off", "type": "function", "code": "tf.summary.trace_off()", "summary": "Stops the current trace and discards any collected information.", "description": "", "code-info": {"name": "tf.summary.trace_off", "parameters": []}},
{"id": "tf.summary.write", "type": "function", "code": "tf.summary.write(tag,tensor,step=None,metadata=None,name=None)", "summary": "Writes a generic summary to the default SummaryWriter if one exists.", "description": "", "code-info": {"name": "tf.summary.write", "parameters": [{"name": "tag", "is_optional": false, "type": "string", "description": "string tag used to identify the summary (e.g. in TensorBoard), usually\ngenerated with tf.summary.summary_scope"}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "the Tensor holding the summary data to write or a callable that\nreturns this Tensor. If a callable is passed, it will only be called when\na default SummaryWriter exists and the recording condition specified by\nrecord_if() is met."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "metadata", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional SummaryMetadata, as a proto or serialized bytes"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string name for this op."}]}},
{"id": "tf.summary.trace_export", "type": "function", "code": "tf.summary.trace_export(name,step=None,profiler_outdir=None)", "summary": "Stops and exports the active trace as a Summary and/or profile file.", "description": "", "code-info": {"name": "tf.summary.trace_export", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the summary to be written."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "profiler_outdir", "is_optional": true, "type": "others", "default_value": "None", "description": "Output directory for profiler. It is required when profiler\nis enabled when trace was started. Otherwise, it is ignored."}]}},
{"id": "tf.summary.text", "type": "function", "code": "tf.summary.text(name,data,step=None,description=None)", "summary": "Write a text summary.", "description": "", "code-info": {"name": "tf.summary.text", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for this summary. The summary tag used for TensorBoard will\nbe this name prefixed by any active name scopes."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A UTF-8 string tensor value."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "description", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional long-form description for this summary, as a\nconstant str. Markdown is supported. Defaults to empty."}]}},
{"id": "tf.summary.scalar", "type": "function", "code": "tf.summary.scalar(name,data,step=None,description=None)", "summary": "Write a scalar summary.", "description": "", "code-info": {"name": "tf.summary.scalar", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for this summary. The summary tag used for TensorBoard will\nbe this name prefixed by any active name scopes."}, {"name": "data", "is_optional": false, "type": "float", "description": "A real numeric scalar value, convertible to a float32 Tensor."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "description", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional long-form description for this summary, as a\nconstant str. Markdown is supported. Defaults to empty."}]}},
{"id": "tf.summary.image", "type": "function", "code": "tf.summary.image(name,data,step=None,max_outputs=3,description=None)", "summary": "Write an image summary.", "description": "", "code-info": {"name": "tf.summary.image", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for this summary. The summary tag used for TensorBoard will\nbe this name prefixed by any active name scopes."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor representing pixel data with shape [k, h, w, c],\nwhere k is the number of images, h and w are the height and\nwidth of the images, and c is the number of channels, which\nshould be 1, 2, 3, or 4 (grayscale, grayscale with alpha, RGB, RGBA).\nAny of the dimensions may be statically unknown (i.e., None).\nFloating point data will be clipped to the range [0,1)."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "max_outputs", "is_optional": true, "type": "int", "default_value": "3", "description": "Optional int or rank-0 integer Tensor. At most this\nmany images will be emitted at each step. When more than\nmax_outputs many images are provided, the first max_outputs many\nimages will be used and the rest silently discarded."}, {"name": "description", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional long-form description for this summary, as a\nconstant str. Markdown is supported. Defaults to empty."}]}},
{"id": "tf.summary.histogram", "type": "function", "code": "tf.summary.histogram(name,data,step=None,buckets=None,description=None)", "summary": "Write a histogram summary.", "description": "", "code-info": {"name": "tf.summary.histogram", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for this summary. The summary tag used for TensorBoard will\nbe this name prefixed by any active name scopes."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor of any shape. Must be castable to float64."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "buckets", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional positive int. The output will have this\nmany buckets, except in two edge cases. If there is no data, then\nthere are no buckets. If there is data but all points have the\nsame value, then there is one bucket whose left and right\nendpoints are the same."}, {"name": "description", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional long-form description for this summary, as a\nconstant str. Markdown is supported. Defaults to empty."}]}},
{"id": "tf.summary.flush", "type": "function", "code": "tf.summary.flush(writer=None,name=None)", "summary": "Forces summary writer to send any buffered data to storage.", "description": "", "code-info": {"name": "tf.summary.flush", "parameters": [{"name": "writer", "is_optional": true, "type": "others", "default_value": "None", "description": "The tf.summary.SummaryWriter resource to flush.\nThe thread default will be used if this parameter is None.\nOtherwise a tf.no_op is returned."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_split_with_offsets", "type": "function", "code": "tf.strings.unicode_split_with_offsets(input,input_encoding,errors='replace',replacement_char=65533,name=None)", "summary": "Splits each string into a sequence of code points with start offsets.", "description": "", "code-info": {"name": "tf.strings.unicode_split_with_offsets", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N dimensional potentially ragged string tensor with shape\n[D1...DN].  N must be statically known."}, {"name": "input_encoding", "is_optional": false, "type": "string", "description": "String name for the unicode encoding that should be used to\ndecode each string."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "Specifies the response when an input string can't be converted\nusing the indicated encoding. One of:\n\n'strict': Raise an exception for any illegal substrings.\n'replace': Replace illegal substrings with replacement_char.\n'ignore': Skip illegal substrings.\n"}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "The replacement codepoint to be used in place of invalid\nsubstrings in input when errors='replace'."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_transcode", "type": "function", "code": "tf.strings.unicode_transcode(input,input_encoding,output_encoding,errors='replace',replacement_char=65533,replace_control_characters=False,name=None)", "summary": "Transcode the input text from a source encoding to a destination encoding.", "description": "", "code-info": {"name": "tf.strings.unicode_transcode", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nThe text to be processed. Can have any shape."}, {"name": "input_encoding", "is_optional": false, "type": "string", "description": "A string.\nText encoding of the input strings. This is any of the encodings supported\nby ICU ucnv algorithmic converters. Examples: \"UTF-16\", \"US ASCII\", \"UTF-8\"."}, {"name": "output_encoding", "is_optional": false, "type": "string", "description": "A string from: \"UTF-8\", \"UTF-16-BE\", \"UTF-32-BE\".\nThe unicode encoding to use in the output. Must be one of\n\"UTF-8\", \"UTF-16-BE\", \"UTF-32-BE\". Multi-byte encodings will be big-endian."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "An optional string from: \"strict\", \"replace\", \"ignore\". Defaults to \"replace\".\nError handling policy when there is invalid formatting found in the input.\nThe value of 'strict' will cause the operation to produce a InvalidArgument\nerror on any invalid input formatting. A value of 'replace' (the default) will\ncause the operation to replace any invalid formatting in the input with the\nreplacement_char codepoint. A value of 'ignore' will cause the operation to\nskip any invalid formatting in the input and produce no corresponding output\ncharacter."}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "An optional int. Defaults to 65533.\nThe replacement character codepoint to be used in place of any invalid\nformatting in the input when errors='replace'. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character is\n0xFFFD or U+65533.)\n\nNote that for UTF-8, passing a replacement character expressible in 1 byte, such\nas ' ', will preserve string alignment to the source since invalid bytes will be\nreplaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte\nreplacement character will preserve byte alignment to the source."}, {"name": "replace_control_characters", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nWhether to replace the C0 control characters (00-1F) with the\nreplacement_char. Default is false."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.summary.create_noop_writer", "type": "function", "code": "tf.summary.create_noop_writer()", "summary": "Returns a summary writer that does nothing.", "description": "", "code-info": {"name": "tf.summary.create_noop_writer", "parameters": []}},
{"id": "tf.summary.create_file_writer", "type": "function", "code": "tf.summary.create_file_writer(logdir,max_queue=None,flush_millis=None,filename_suffix=None,name=None)", "summary": "Creates a summary file writer for the given log directory.", "description": "", "code-info": {"name": "tf.summary.create_file_writer", "parameters": [{"name": "logdir", "is_optional": false, "type": "string", "description": "a string specifying the directory in which to write an event file."}, {"name": "max_queue", "is_optional": true, "type": "others", "default_value": "None", "description": "the largest number of summaries to keep in a queue; will\nflush once the queue gets bigger than this. Defaults to 10."}, {"name": "flush_millis", "is_optional": true, "type": "others", "default_value": "None", "description": "the largest interval between flushes. Defaults to 120,000."}, {"name": "filename_suffix", "is_optional": true, "type": "string", "default_value": "None", "description": "optional suffix for the event file name. Defaults to .v2."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "a name for the op that creates the writer."}]}},
{"id": "tf.summary.audio", "type": "function", "code": "tf.summary.audio(name,data,sample_rate,step=None,max_outputs=3,encoding=None,description=None)", "summary": "Write an audio summary.", "description": "", "code-info": {"name": "tf.summary.audio", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for this summary. The summary tag used for TensorBoard will\nbe this name prefixed by any active name scopes."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor representing audio data with shape [k, t, c],\nwhere k is the number of audio clips, t is the number of\nframes, and c is the number of channels. Elements should be\nfloating-point values in [-1.0, 1.0]. Any of the dimensions may\nbe statically unknown (i.e., None)."}, {"name": "sample_rate", "is_optional": false, "type": "tensor", "description": "An int or rank-0 int32 Tensor that represents the\nsample rate, in Hz. Must be positive."}, {"name": "step", "is_optional": true, "type": "others", "default_value": "None", "description": "Explicit int64-castable monotonic step value for this summary. If\nomitted, this defaults to tf.summary.experimental.get_step(), which must\nnot be None."}, {"name": "max_outputs", "is_optional": true, "type": "int", "default_value": "3", "description": "Optional int or rank-0 integer Tensor. At most this\nmany audio clips will be emitted at each step. When more than\nmax_outputs many clips are provided, the first max_outputs\nmany clips will be used and the rest silently discarded."}, {"name": "encoding", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constant str for the desired encoding. Only \"wav\"\nis currently supported, but this is not guaranteed to remain the\ndefault, so if you want \"wav\" in particular, set this explicitly."}, {"name": "description", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional long-form description for this summary, as a\nconstant str. Markdown is supported. Defaults to empty."}]}},
{"id": "tf.strings.upper", "type": "function", "code": "tf.strings.upper(input,encoding='',name=None)", "summary": "TODO: add doc.", "description": "", "code-info": {"name": "tf.strings.upper", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string."}, {"name": "encoding", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unsorted_segment_join", "type": "function", "code": "tf.strings.unsorted_segment_join(inputs,segment_ids,num_segments,separator='',name=None)", "summary": "Joins the elements of inputs based on segment_ids.", "description": "", "code-info": {"name": "tf.strings.unsorted_segment_join", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. The input to be joined."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor whose shape is a prefix of data.shape.  Negative segment ids are not\nsupported."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA scalar."}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nThe separator to use when joining."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_split", "type": "function", "code": "tf.strings.unicode_split(input,input_encoding,errors='replace',replacement_char=65533,name=None)", "summary": "Splits each string in input into a sequence of Unicode code points.", "description": "", "code-info": {"name": "tf.strings.unicode_split", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N dimensional potentially ragged string tensor with shape\n[D1...DN].  N must be statically known."}, {"name": "input_encoding", "is_optional": false, "type": "string", "description": "String name for the unicode encoding that should be used to\ndecode each string."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "Specifies the response when an input string can't be converted\nusing the indicated encoding. One of:\n\n'strict': Raise an exception for any illegal substrings.\n'replace': Replace illegal substrings with replacement_char.\n'ignore': Skip illegal substrings.\n"}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "The replacement codepoint to be used in place of invalid\nsubstrings in input when errors='replace'."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_script", "type": "function", "code": "tf.strings.unicode_script(input,name=None)", "summary": "Determine the script codes of a given tensor of Unicode integer code points.", "description": "", "code-info": {"name": "tf.strings.unicode_script", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32. A Tensor of int32 Unicode code points."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_encode", "type": "function", "code": "tf.strings.unicode_encode(input,output_encoding,errors='replace',replacement_char=65533,name=None)", "summary": "Encodes each sequence of Unicode code points in input into a string.", "description": "", "code-info": {"name": "tf.strings.unicode_encode", "parameters": [{"name": "input", "is_optional": false, "type": "int", "description": "An N+1 dimensional potentially ragged integer tensor with shape\n[D1...DN, num_chars]."}, {"name": "output_encoding", "is_optional": false, "type": "others", "description": "Unicode encoding that should be used to encode each\ncodepoint sequence.  Can be \"UTF-8\", \"UTF-16-BE\", or \"UTF-32-BE\"."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "Specifies the response when an invalid codepoint is encountered\n(optional). One of:\n    * 'replace': Replace invalid codepoint with the\n      replacement_char. (default)\n    * 'ignore': Skip invalid codepoints.\n    * 'strict': Raise an exception for any invalid codepoint."}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "The replacement character codepoint to be used in place of\nany invalid input when errors='replace'. Any valid unicode codepoint may\nbe used. The default value is the default unicode replacement character\nwhich is 0xFFFD (U+65533)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_decode_with_offsets", "type": "function", "code": "tf.strings.unicode_decode_with_offsets(input,input_encoding,errors='replace',replacement_char=65533,replace_control_characters=False,name=None)", "summary": "Decodes each string into a sequence of code points with start offsets.", "description": "", "code-info": {"name": "tf.strings.unicode_decode_with_offsets", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N dimensional potentially ragged string tensor with shape\n[D1...DN].  N must be statically known."}, {"name": "input_encoding", "is_optional": false, "type": "string", "description": "String name for the unicode encoding that should be used to\ndecode each string."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "Specifies the response when an input string can't be converted\nusing the indicated encoding. One of:\n\n'strict': Raise an exception for any illegal substrings.\n'replace': Replace illegal substrings with replacement_char.\n'ignore': Skip illegal substrings.\n"}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "The replacement codepoint to be used in place of invalid\nsubstrings in input when errors='replace'; and in place of C0 control\ncharacters in input when replace_control_characters=True."}, {"name": "replace_control_characters", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to replace the C0 control characters\n(U+0000 - U+001F) with the replacement_char."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.unicode_decode", "type": "function", "code": "tf.strings.unicode_decode(input,input_encoding,errors='replace',replacement_char=65533,replace_control_characters=False,name=None)", "summary": "Decodes each string in input into a sequence of Unicode code points.", "description": "", "code-info": {"name": "tf.strings.unicode_decode", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N dimensional potentially ragged string tensor with shape\n[D1...DN].  N must be statically known."}, {"name": "input_encoding", "is_optional": false, "type": "string", "description": "String name for the unicode encoding that should be used to\ndecode each string."}, {"name": "errors", "is_optional": true, "type": "string", "default_value": "'replace'", "description": "Specifies the response when an input string can't be converted\nusing the indicated encoding. One of:\n\n'strict': Raise an exception for any illegal substrings.\n'replace': Replace illegal substrings with replacement_char.\n'ignore': Skip illegal substrings.\n"}, {"name": "replacement_char", "is_optional": true, "type": "int", "default_value": "65533", "description": "The replacement codepoint to be used in place of invalid\nsubstrings in input when errors='replace'; and in place of C0 control\ncharacters in input when replace_control_characters=True."}, {"name": "replace_control_characters", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to replace the C0 control characters\n(U+0000 - U+001F) with the replacement_char."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.to_number", "type": "function", "code": "tf.strings.to_number(input,out_type=tf.dtypes.float32,name=None)", "summary": "Converts each string in the input Tensor to the specified numeric type.", "description": "", "code-info": {"name": "tf.strings.to_number", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string."}, {"name": "out_type", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "An optional tf.DType from: tf.float32, tf.float64, tf.int32,\ntf.int64. Defaults to tf.float32.\nThe numeric type to interpret each string in string_tensor as."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.to_hash_bucket_strong", "type": "function", "code": "tf.strings.to_hash_bucket_strong(input,num_buckets,key,name=None)", "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.", "description": "", "code-info": {"name": "tf.strings.to_hash_bucket_strong", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. The strings to assign a hash bucket."}, {"name": "num_buckets", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1. The number of buckets."}, {"name": "key", "is_optional": false, "type": "others", "description": "A list of ints.\nThe key used to seed the hash function, passed as a list of two uint64\nelements."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.to_hash_bucket_fast", "type": "function", "code": "tf.strings.to_hash_bucket_fast(input,num_buckets,name=None)", "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.", "description": "", "code-info": {"name": "tf.strings.to_hash_bucket_fast", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. The strings to assign a hash bucket."}, {"name": "num_buckets", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1. The number of buckets."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.substr", "type": "function", "code": "tf.strings.substr(input,pos,len,unit='BYTE',name=None)", "summary": "Return substrings from Tensor of strings.", "description": "", "code-info": {"name": "tf.strings.substr", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. Tensor of strings"}, {"name": "pos", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nScalar defining the position of first character in each substring"}, {"name": "len", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as pos.\nScalar defining the number of characters to include in each substring"}, {"name": "unit", "is_optional": true, "type": "string", "default_value": "'BYTE'", "description": "An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is used to create the substring.  One of: \"BYTE\" (for\ndefining position and length by bytes) or \"UTF8_CHAR\" (for the UTF-8\nencoded Unicode code points).  The default is \"BYTE\". Results are undefined if\nunit=UTF8_CHAR and the input strings do not contain structurally valid\nUTF-8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.to_hash_bucket", "type": "function", "code": "tf.strings.to_hash_bucket(input,num_buckets,name=None)", "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.", "description": "", "code-info": {"name": "tf.strings.to_hash_bucket", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string."}, {"name": "num_buckets", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1. The number of buckets."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.regex_replace", "type": "function", "code": "tf.strings.regex_replace(input,pattern,rewrite,replace_global=True,name=None)", "summary": "Replace elements of input matching regex pattern with rewrite.", "description": "", "code-info": {"name": "tf.strings.regex_replace", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "string Tensor, the source strings to process."}, {"name": "pattern", "is_optional": false, "type": "tensor", "description": "string or scalar string Tensor, regular expression to use,\nsee more details at https://github.com/google/re2/wiki/Syntax"}, {"name": "rewrite", "is_optional": false, "type": "tensor", "description": "string or scalar string Tensor, value to use in match\nreplacement, supports backslash-escaped digits (\\1 to \\9) can be to insert\ntext matching corresponding parenthesized group."}, {"name": "replace_global", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, if True replace all non-overlapping matches,\nelse replace only the first match."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.ngrams", "type": "function", "code": "tf.strings.ngrams(data,ngram_width,separator='',pad_values=None,padding_width=None,preserve_short_sequences=False,name=None)", "summary": "Create a tensor of n-grams based on data.", "description": "", "code-info": {"name": "tf.strings.ngrams", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor or RaggedTensor containing the source data for the ngrams."}, {"name": "ngram_width", "is_optional": false, "type": "others", "description": "The width(s) of the ngrams to create. If this is a list or\ntuple, the op will return ngrams of all specified arities in list order.\nValues must be non-Tensor integers greater than 0."}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "''", "description": "The separator string used between ngram elements. Must be a\nstring constant, not a Tensor."}, {"name": "pad_values", "is_optional": true, "type": "others", "default_value": "None", "description": "A tuple of (left_pad_value, right_pad_value), a single string,\nor None. If None, no padding will be added; if a single string, then that\nstring will be used for both left and right padding. Values must be Python\nstrings."}, {"name": "padding_width", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, padding_width pad values will be added to both\nsides of each sequence. Defaults to ngram_width-1. Must be greater than\n\n(Note that 1-grams are never padded, regardless of this value.)\n"}, {"name": "preserve_short_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, then ensure that at least one ngram is\ngenerated for each input sequence.  In particular, if an input sequence is\nshorter than min(ngram_width) + 2*pad_width, then generate a single\nngram containing the entire sequence.  If false, then no ngrams are\ngenerated for these short input sequences."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The op name."}]}},
{"id": "tf.strings.regex_full_match", "type": "function", "code": "tf.strings.regex_full_match(input,pattern,name=None)", "summary": "Check if the input matches the regex pattern.", "description": "", "code-info": {"name": "tf.strings.regex_full_match", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nA string tensor of the text to be processed."}, {"name": "pattern", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nA scalar string tensor containing the regular expression to match the input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.lower", "type": "function", "code": "tf.strings.lower(input,encoding='',name=None)", "summary": "TODO: add doc.", "description": "", "code-info": {"name": "tf.strings.lower", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string."}, {"name": "encoding", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.split", "type": "function", "code": "tf.strings.split(input,sep=None,maxsplit=-1,name=None)", "summary": "Split elements of input based on sep into a RaggedTensor.", "description": "", "code-info": {"name": "tf.strings.split", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A string Tensor of rank N, the strings to split.  If\nrank(input) is not known statically, then it is assumed to be 1."}, {"name": "sep", "is_optional": true, "type": "tensor", "default_value": "None", "description": "0-D string Tensor, the delimiter string."}, {"name": "maxsplit", "is_optional": true, "type": "others", "default_value": "-1", "description": "An int. If maxsplit &gt; 0, limit of the split of the result."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.reduce_join", "type": "function", "code": "tf.strings.reduce_join(inputs,axis=None,keepdims=False,separator='',name=None)", "summary": "Joins all strings into a single string, or joins along an axis.", "description": "", "code-info": {"name": "tf.strings.reduce_join", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A tf.string tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "Which axis to join along. The default behavior is to join all\nelements, producing a scalar."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "''", "description": "a string added between each string being joined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.length", "type": "function", "code": "tf.strings.length(input,unit='BYTE',name=None)", "summary": "", "description": "", "code-info": {"name": "tf.strings.length", "parameters": [{"name": "input", "is_optional": false, "type": "others", "description": ""}, {"name": "unit", "is_optional": true, "type": "string", "default_value": "'BYTE'", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.strings.strip", "type": "function", "code": "tf.strings.strip(input,name=None)", "summary": "Strip leading and trailing whitespaces from the Tensor.", "description": "", "code-info": {"name": "tf.strings.strip", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. A string Tensor of any shape."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.join", "type": "function", "code": "tf.strings.join(inputs,separator='',name=None)", "summary": "Joins the strings in the given list of string tensors into one tensor;", "description": "", "code-info": {"name": "tf.strings.join", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of at least 1 Tensor objects with type string.\nA list of string tensors.  The tensors must all have the same shape,\nor be scalars.  Scalars may be mixed in; these will be broadcast to the shape\nof non-scalar inputs."}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nstring, an optional join separator."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.bytes_split", "type": "function", "code": "tf.strings.bytes_split(input,name=None)", "summary": "Split string elements of input into bytes.", "description": "", "code-info": {"name": "tf.strings.bytes_split", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A string Tensor or RaggedTensor: the strings to split.  Must\nhave a statically known rank (N)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.format", "type": "function", "code": "tf.strings.format(template,inputs,placeholder='{}',summarize=3,name=None)", "summary": "Formats a string template using a list of tensors.", "description": "", "code-info": {"name": "tf.strings.format", "parameters": [{"name": "template", "is_optional": false, "type": "tensor", "description": "A string template to format tensor values into."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects, or a single Tensor.\nThe list of tensors to format into the template string. If a solitary\ntensor is passed in, the input tensor will automatically be wrapped as a\nlist."}, {"name": "placeholder", "is_optional": true, "type": "string", "default_value": "'{}'", "description": "An optional string. Defaults to {}.\nAt each placeholder occurring in the template, a subsequent tensor\nwill be inserted."}, {"name": "summarize", "is_optional": true, "type": "int", "default_value": "3", "description": "An optional int. Defaults to 3.\nWhen formatting the tensors, show the first and last summarize\nentries of each tensor dimension (recursively). If set to -1, all\nelements of the tensor will be shown."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strings.as_string", "type": "function", "code": "tf.strings.as_string(input,precision=-1,scientific=False,shortest=False,width=-1,fill='',name=None)", "summary": "Converts each entry in the given tensor to strings.", "description": "", "code-info": {"name": "tf.strings.as_string", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, complex64, complex128, float32, float64, bool."}, {"name": "precision", "is_optional": true, "type": "others", "default_value": "-1", "description": "An optional int. Defaults to -1.\nThe post-decimal precision to use for floating point numbers.\nOnly used if precision &gt; -1."}, {"name": "scientific", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nUse scientific notation for floating point numbers."}, {"name": "shortest", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nUse shortest representation (either scientific or standard) for\nfloating point numbers."}, {"name": "width", "is_optional": true, "type": "others", "default_value": "-1", "description": "An optional int. Defaults to -1.\nPad pre-decimal numbers to this width.\nApplies to both floating point and integer numbers.\nOnly used if width &gt; -1."}, {"name": "fill", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nThe value to pad if width &gt; -1.  If empty, pads with spaces.\nAnother typical value is '0'.  String cannot be longer than 1 character."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.to_dense", "type": "function", "code": "tf.sparse.to_dense(sp_input,default_value=None,validate_indices=True,name=None)", "summary": "Converts a SparseTensor into a dense tensor.", "description": "", "code-info": {"name": "tf.sparse.to_dense", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "default_value", "is_optional": true, "type": "float", "default_value": "None", "description": "Scalar value to set for indices not specified in\nsp_input.  Defaults to zero."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean value.  If True, indices are checked to make\nsure they are sorted in lexicographic order and that there are no repeats."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}]}},
{"id": "tf.sparse.softmax", "type": "function", "code": "tf.sparse.softmax(sp_input,name=None)", "summary": "Applies softmax to a batched N-D SparseTensor.", "description": "", "code-info": {"name": "tf.sparse.softmax", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "N-D SparseTensor, where N &gt;= 2."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "optional name of the operation."}]}},
{"id": "tf.sparse.to_indicator", "type": "function", "code": "tf.sparse.to_indicator(sp_input,vocab_size,name=None)", "summary": "Converts a SparseTensor of ids into a dense bool indicator tensor.", "description": "", "code-info": {"name": "tf.sparse.to_indicator", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "A SparseTensor with values property of type int32 or\nint64."}, {"name": "vocab_size", "is_optional": false, "type": "tensor", "description": "A scalar int64 Tensor (or Python int) containing the new size\nof the last dimension, all(0 &lt;= sp_input.values &lt; vocab_size)."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.slice", "type": "function", "code": "tf.sparse.slice(sp_input,start,size,name=None)", "summary": "Slice a SparseTensor based on the start and `size.", "description": "", "code-info": {"name": "tf.sparse.slice", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to split."}, {"name": "start", "is_optional": false, "type": "tensor", "description": "1-D. tensor represents the start of the slice."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "1-D. tensor represents the size of the slice."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.segment_sum", "type": "function", "code": "tf.sparse.segment_sum(data,indices,segment_ids,num_segments=None,name=None)", "summary": "Computes the sum along sparse segments of a tensor.", "description": "", "code-info": {"name": "tf.sparse.segment_sum", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.split", "type": "function", "code": "tf.sparse.split(sp_input=None,num_split=None,axis=None,name=None)", "summary": "Split a SparseTensor into num_split tensors along axis.", "description": "", "code-info": {"name": "tf.sparse.split", "parameters": [{"name": "sp_input", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The SparseTensor to split."}, {"name": "num_split", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. The number of ways to split."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 0-D int32 Tensor. The dimension along which to split."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.sparse_dense_matmul", "type": "function", "code": "tf.sparse.sparse_dense_matmul(sp_a,b,adjoint_a=False,adjoint_b=False,name=None)", "summary": "Multiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\".", "description": "", "code-info": {"name": "tf.sparse.sparse_dense_matmul", "parameters": [{"name": "sp_a", "is_optional": false, "type": "tensor", "description": "SparseTensor A, of rank 2."}, {"name": "b", "is_optional": false, "type": "others", "description": "A dense Matrix with the same dtype as sp_a."}, {"name": "adjoint_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "Use the adjoint of A in the matrix multiply.  If A is complex,\nthis is transpose(conj(A)).  Otherwise it's transpose(A)."}, {"name": "adjoint_b", "is_optional": true, "type": "bool", "default_value": "False", "description": "Use the adjoint of B in the matrix multiply.  If B is complex,\nthis is transpose(conj(B)).  Otherwise it's transpose(B)."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.transpose", "type": "function", "code": "tf.sparse.transpose(sp_input,perm=None,name=None)", "summary": "Transposes a SparseTensor", "description": "", "code-info": {"name": "tf.sparse.transpose", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "perm", "is_optional": true, "type": "others", "default_value": "None", "description": "A permutation of the dimensions of sp_input."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.SparseTensor", "type": "class", "code": "tf.sparse.SparseTensor(indices,values,dense_shape)", "summary": "Represents a sparse tensor.", "description": "", "code-info": {"name": "tf.sparse.SparseTensor", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "A 2-D int64 tensor of shape [N, ndims], which specifies the\nindices of the elements in the sparse tensor that contain nonzero values\n(elements are zero-indexed). For example, indices=[[1,3], [2,4]] specifies\nthat the elements with indexes of [1,3] and [2,4] have nonzero values."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A 1-D tensor of any type and shape [N], which supplies the\nvalues for each element in indices. For example, given indices=[[1,3],\n[2,4]], the parameter values=[18, 3.6] specifies that element [1,3] of\nthe sparse tensor has a value of 18, and element [2,4] of the tensor has a\nvalue of 3.6."}, {"name": "dense_shape", "is_optional": false, "type": "tensor", "description": "A 1-D int64 tensor of shape [ndims], which specifies the\ndense_shape of the sparse tensor. Takes a list indicating the number of\nelements in each dimension. For example, dense_shape=[3,6] specifies a\ntwo-dimensional 3x6 tensor, dense_shape=[2,3,4] specifies a\nthree-dimensional 2x3x4 tensor, and dense_shape=[9] specifies a\none-dimensional tensor with 9 elements."}]}},
{"id": "tf.sparse.segment_sqrt_n", "type": "function", "code": "tf.sparse.segment_sqrt_n(data,indices,segment_ids,num_segments=None,name=None)", "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt(N).", "description": "", "code-info": {"name": "tf.sparse.segment_sqrt_n", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.retain", "type": "function", "code": "tf.sparse.retain(sp_input,to_retain)", "summary": "Retains specified non-empty values within a SparseTensor.", "description": "", "code-info": {"name": "tf.sparse.retain", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor with N non-empty elements."}, {"name": "to_retain", "is_optional": false, "type": "bool", "description": "A bool vector of length N with M true values."}]}},
{"id": "tf.sparse.reshape", "type": "function", "code": "tf.sparse.reshape(sp_input,shape,name=None)", "summary": "Reshapes a SparseTensor to represent values in a new dense shape.", "description": "", "code-info": {"name": "tf.sparse.reshape", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D (vector) int64 Tensor specifying the new dense shape of the\nrepresented SparseTensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.reorder", "type": "function", "code": "tf.sparse.reorder(sp_input,name=None)", "summary": "Reorders a SparseTensor into the canonical, row-major ordering.", "description": "", "code-info": {"name": "tf.sparse.reorder", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.minimum", "type": "function", "code": "tf.sparse.minimum(sp_a,sp_b,name=None)", "summary": "Returns the element-wise min of two SparseTensors.", "description": "", "code-info": {"name": "tf.sparse.minimum", "parameters": [{"name": "sp_a", "is_optional": false, "type": "tensor", "description": "a SparseTensor operand whose dtype is real, and indices\nlexicographically ordered."}, {"name": "sp_b", "is_optional": false, "type": "tensor", "description": "the other SparseTensor operand with the same requirements (and the\nsame shape)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "optional name of the operation."}]}},
{"id": "tf.sparse.segment_mean", "type": "function", "code": "tf.sparse.segment_mean(data,indices,segment_ids,num_segments=None,name=None)", "summary": "Computes the mean along sparse segments of a tensor.", "description": "", "code-info": {"name": "tf.sparse.segment_mean", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.reduce_sum", "type": "function", "code": "tf.sparse.reduce_sum(sp_input,axis=None,keepdims=None,output_is_sparse=False,name=None)", "summary": "Computes the sum of elements across dimensions of a SparseTensor.", "description": "", "code-info": {"name": "tf.sparse.reduce_sum", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "output_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, returns a SparseTensor instead of a dense\nTensor (the default)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.maximum", "type": "function", "code": "tf.sparse.maximum(sp_a,sp_b,name=None)", "summary": "Returns the element-wise max of two SparseTensors.", "description": "", "code-info": {"name": "tf.sparse.maximum", "parameters": [{"name": "sp_a", "is_optional": false, "type": "tensor", "description": "a SparseTensor operand whose dtype is real, and indices\nlexicographically ordered."}, {"name": "sp_b", "is_optional": false, "type": "tensor", "description": "the other SparseTensor operand with the same requirements (and the\nsame shape)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "optional name of the operation."}]}},
{"id": "tf.sparse.reset_shape", "type": "function", "code": "tf.sparse.reset_shape(sp_input,new_shape=None)", "summary": "Resets the shape of a SparseTensor with indices and values unchanged.", "description": "", "code-info": {"name": "tf.sparse.reset_shape", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "new_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "None or a vector representing the new shape for the returned\nSparseTensor."}]}},
{"id": "tf.sparse.reduce_max", "type": "function", "code": "tf.sparse.reduce_max(sp_input,axis=None,keepdims=None,output_is_sparse=False,name=None)", "summary": "Computes the max of elements across dimensions of a SparseTensor.", "description": "", "code-info": {"name": "tf.sparse.reduce_max", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "output_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, returns a SparseTensor instead of a dense\nTensor (the default)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.mask", "type": "function", "code": "tf.sparse.mask(a,mask_indices,name=None)", "summary": "Masks elements of IndexedSlices.", "description": "", "code-info": {"name": "tf.sparse.mask", "parameters": [{"name": "a", "is_optional": false, "type": "others", "description": "An IndexedSlices instance."}, {"name": "mask_indices", "is_optional": false, "type": "others", "description": "Indices of elements to mask."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sparse.from_dense", "type": "function", "code": "tf.sparse.from_dense(tensor,name=None)", "summary": "Converts a dense tensor into a sparse tensor.", "description": "", "code-info": {"name": "tf.sparse.from_dense", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A dense Tensor to be converted to a SparseTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}]}},
{"id": "tf.sparse.expand_dims", "type": "function", "code": "tf.sparse.expand_dims(sp_input,axis=None,name=None)", "summary": "Inserts a dimension of 1 into a tensor's shape.", "description": "", "code-info": {"name": "tf.sparse.expand_dims", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "A SparseTensor."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "0-D (scalar). Specifies the dimension index at which to expand the\nshape of input. Must be in the range [-rank(sp_input) - 1,\nrank(sp_input)]."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The name of the output SparseTensor."}]}},
{"id": "tf.sparse.fill_empty_rows", "type": "function", "code": "tf.sparse.fill_empty_rows(sp_input,default_value,name=None)", "summary": "Fills empty rows in the input 2-D SparseTensor with a default value.", "description": "", "code-info": {"name": "tf.sparse.fill_empty_rows", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "A SparseTensor with shape [N, M]."}, {"name": "default_value", "is_optional": false, "type": "others", "description": "The value to fill for empty rows, with the same type as\nsp_input."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.sparse.eye", "type": "function", "code": "tf.sparse.eye(num_rows,num_columns=None,dtype=tf.dtypes.float32,name=None)", "summary": "Creates a two-dimensional sparse tensor with ones along the diagonal.", "description": "", "code-info": {"name": "tf.sparse.eye", "parameters": [{"name": "num_rows", "is_optional": false, "type": "tensor", "description": "Non-negative integer or int32 scalar tensor giving the number\nof rows in the resulting matrix."}, {"name": "num_columns", "is_optional": true, "type": "int", "default_value": "None", "description": "Optional non-negative integer or int32 scalar tensor giving\nthe number of columns in the resulting matrix. Defaults to num_rows."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "The type of element in the resulting Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this Op. Defaults to \"eye\"."}]}},
{"id": "tf.sparse.cross", "type": "function", "code": "tf.sparse.cross(inputs,name=None)", "summary": "Generates sparse cross from a list of sparse and dense tensors.", "description": "", "code-info": {"name": "tf.sparse.cross", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "An iterable of Tensor or SparseTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}]}},
{"id": "tf.sparse.concat", "type": "function", "code": "tf.sparse.concat(axis,sp_inputs,expand_nonconcat_dims=False,name=None)", "summary": "Concatenates a list of SparseTensor along the specified dimension. (deprecated arguments)", "description": "", "code-info": {"name": "tf.sparse.concat", "parameters": [{"name": "axis", "is_optional": false, "type": "others", "description": "Dimension to concatenate along. Must be in range [-rank, rank),\nwhere rank is the number of dimensions in each input SparseTensor."}, {"name": "sp_inputs", "is_optional": false, "type": "tensor", "description": "List of SparseTensor to concatenate.\nname: A name prefix for the returned tensors (optional).\nexpand_nonconcat_dim: Whether to allow the expansion in the non-concat\ndimensions. Defaulted to False.\nconcat_dim: The old (deprecated) name for axis."}, {"name": "expand_nonconcat_dims", "is_optional": true, "type": "bool", "default_value": "False", "description": "alias for expand_nonconcat_dim\n\n\nReturns:\n\nA SparseTensor with the concatenated output.\n\nRaises:\n\n\nTypeError: If sp_inputs is not a list of SparseTensor.\n\n\n          "}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional).\nexpand_nonconcat_dim: Whether to allow the expansion in the non-concat\ndimensions. Defaulted to False.\nconcat_dim: The old (deprecated) name for axis.\nexpand_nonconcat_dims: alias for expand_nonconcat_dim"}]}},
{"id": "tf.sparse.cross_hashed", "type": "function", "code": "tf.sparse.cross_hashed(inputs,num_buckets=0,hash_key=None,name=None)", "summary": "Generates hashed sparse cross from a list of sparse and dense tensors.", "description": "", "code-info": {"name": "tf.sparse.cross_hashed", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "An iterable of Tensor or SparseTensor."}, {"name": "num_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "An int that is &gt;= 0.\noutput = hashed_value%num_buckets if num_buckets &gt; 0 else hashed_value."}, {"name": "hash_key", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer hash_key that will be used by the FingerprintCat64\nfunction. If not given, will use a default key."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}]}},
{"id": "tf.sparse.add", "type": "function", "code": "tf.sparse.add(a,b,threshold=0)", "summary": "Adds two tensors, at least one of each is a SparseTensor.", "description": "", "code-info": {"name": "tf.sparse.add", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "The first operand; SparseTensor or Tensor."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "The second operand; SparseTensor or Tensor. At least one operand\nmust be sparse."}, {"name": "threshold", "is_optional": true, "type": "int", "default_value": "0", "description": "A 0-D Tensor. The magnitude threshold that determines if an\noutput value/index pair takes space. Its dtype should match that of the\nvalues if they are real; if the latter are complex64/complex128, then the\ndtype should be float32/float64, correspondingly."}]}},
{"id": "tf.signal.stft", "type": "function", "code": "tf.signal.stft(signals,frame_length,frame_step,fft_length=None,window_fn=tf.signal.hann_window,pad_end=False,name=None)", "summary": "Computes the Short-time Fourier Transform of signals.", "description": "", "code-info": {"name": "tf.signal.stft", "parameters": [{"name": "signals", "is_optional": false, "type": "tensor", "description": "A [..., samples] float32/float64 Tensor of real-valued\nsignals."}, {"name": "frame_length", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor. The window length in samples."}, {"name": "frame_step", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor. The number of samples to step."}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An integer scalar Tensor. The size of the FFT to apply.\nIf not provided, uses the smallest power of 2 enclosing frame_length."}, {"name": "window_fn", "is_optional": true, "type": "others", "default_value": "tf.signal.hann_window", "description": "A callable that takes a window length and a dtype keyword\nargument and returns a [window_length] Tensor of samples in the\nprovided datatype. If set to None, no windowing is used."}, {"name": "pad_end", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to pad the end of signals with zeros when the provided\nframe length and step produces a frame that lies partially past its end."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.rfft3d", "type": "function", "code": "tf.signal.rfft3d(input_tensor,fft_length=None,name=None)", "summary": "3D real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.rfft3d", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [3]. The FFT length for each dimension.\nTcomplex: An optional tf.DType from: tf.complex64, tf.complex128. Defaults to tf.complex64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.rfft2d", "type": "function", "code": "tf.signal.rfft2d(input_tensor,fft_length=None,name=None)", "summary": "2D real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.rfft2d", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [2]. The FFT length for each dimension.\nTcomplex: An optional tf.DType from: tf.complex64, tf.complex128. Defaults to tf.complex64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.irfft2d", "type": "function", "code": "tf.signal.irfft2d(input_tensor,fft_length=None,name=None)", "summary": "Inverse 2D real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.irfft2d", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [2]. The FFT length for each dimension.\nTreal: An optional tf.DType from: tf.float32, tf.float64. Defaults to tf.float32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.irfft", "type": "function", "code": "tf.signal.irfft(input_tensor,fft_length=None,name=None)", "summary": "Inverse real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.irfft", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [1]. The FFT length.\nTreal: An optional tf.DType from: tf.float32, tf.float64. Defaults to tf.float32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.irfft3d", "type": "function", "code": "tf.signal.irfft3d(input_tensor,fft_length=None,name=None)", "summary": "Inverse 3D real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.irfft3d", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [3]. The FFT length for each dimension.\nTreal: An optional tf.DType from: tf.float32, tf.float64. Defaults to tf.float32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.linear_to_mel_weight_matrix", "type": "function", "code": "tf.signal.linear_to_mel_weight_matrix(num_mel_bins=20,num_spectrogram_bins=129,sample_rate=8000,lower_edge_hertz=125.0,upper_edge_hertz=3800.0,dtype=tf.dtypes.float32,name=None)", "summary": "Returns a matrix to warp linear scale spectrograms to the mel scale.", "description": "", "code-info": {"name": "tf.signal.linear_to_mel_weight_matrix", "parameters": [{"name": "num_mel_bins", "is_optional": true, "type": "int", "default_value": "20", "description": "Python int. How many bands in the resulting mel spectrum."}, {"name": "num_spectrogram_bins", "is_optional": true, "type": "int", "default_value": "129", "description": "An integer Tensor. How many bins there are in the\nsource spectrogram data, which is understood to be fft_size // 2 + 1,\ni.e. the spectrogram only contains the nonredundant FFT bins."}, {"name": "sample_rate", "is_optional": true, "type": "int", "default_value": "8000", "description": "An integer or float Tensor. Samples per second of the input\nsignal used to create the spectrogram. Used to figure out the frequencies\ncorresponding to each spectrogram bin, which dictates how they are mapped\ninto the mel scale."}, {"name": "lower_edge_hertz", "is_optional": true, "type": "float", "default_value": "125.0", "description": "Python float. Lower bound on the frequencies to be\nincluded in the mel spectrum. This corresponds to the lower edge of the\nlowest triangular band."}, {"name": "upper_edge_hertz", "is_optional": true, "type": "float", "default_value": "3800.0", "description": "Python float. The desired top edge of the highest\nfrequency band."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The DType of the result matrix. Must be a floating point type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.rfft", "type": "function", "code": "tf.signal.rfft(input_tensor,fft_length=None,name=None)", "summary": "Real-valued fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.rfft", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "others", "description": ""}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nAn int32 tensor of shape [1]. The FFT length.\nTcomplex: An optional tf.DType from: tf.complex64, tf.complex128. Defaults to tf.complex64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.overlap_and_add", "type": "function", "code": "tf.signal.overlap_and_add(signal,frame_step,name=None)", "summary": "Reconstructs a signal from a framed representation.", "description": "", "code-info": {"name": "tf.signal.overlap_and_add", "parameters": [{"name": "signal", "is_optional": false, "type": "tensor", "description": "A [..., frames, frame_length] Tensor. All dimensions may be\nunknown, and rank must be at least 2."}, {"name": "frame_step", "is_optional": false, "type": "tensor", "description": "An integer or scalar Tensor denoting overlap offsets. Must be\nless than or equal to frame_length."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.mfccs_from_log_mel_spectrograms", "type": "function", "code": "tf.signal.mfccs_from_log_mel_spectrograms(log_mel_spectrograms,name=None)", "summary": "Computes MFCCs of log_mel_spectrograms.", "description": "", "code-info": {"name": "tf.signal.mfccs_from_log_mel_spectrograms", "parameters": [{"name": "log_mel_spectrograms", "is_optional": false, "type": "tensor", "description": "A [..., num_mel_bins] float32/float64 Tensor\nof log-magnitude mel-scale spectrograms."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.ifft2d", "type": "function", "code": "tf.signal.ifft2d(input,name=None)", "summary": "Inverse 2D fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.ifft2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.ifft", "type": "function", "code": "tf.signal.ifft(input,name=None)", "summary": "Inverse fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.ifft", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.ifft3d", "type": "function", "code": "tf.signal.ifft3d(input,name=None)", "summary": "Inverse 3D fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.ifft3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.inverse_stft", "type": "function", "code": "tf.signal.inverse_stft(stfts,frame_length,frame_step,fft_length=None,window_fn=tf.signal.hann_window,name=None)", "summary": "Computes the inverse Short-time Fourier Transform of stfts.", "description": "", "code-info": {"name": "tf.signal.inverse_stft", "parameters": [{"name": "stfts", "is_optional": false, "type": "others", "description": "A complex64/complex128 [..., frames, fft_unique_bins]\nTensor of STFT bins representing a batch of fft_length-point STFTs\nwhere fft_unique_bins is fft_length // 2 + 1"}, {"name": "frame_length", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor. The window length in samples."}, {"name": "frame_step", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor. The number of samples to step."}, {"name": "fft_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An integer scalar Tensor. The size of the FFT that produced\nstfts. If not provided, uses the smallest power of 2 enclosing\nframe_length."}, {"name": "window_fn", "is_optional": true, "type": "others", "default_value": "tf.signal.hann_window", "description": "A callable that takes a window length and a dtype keyword\nargument and returns a [window_length] Tensor of samples in the\nprovided datatype. If set to None, no windowing is used."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.ifftshift", "type": "function", "code": "tf.signal.ifftshift(x,axes=None,name=None)", "summary": "The inverse of fftshift.", "description": "", "code-info": {"name": "tf.signal.ifftshift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor, input tensor."}, {"name": "axes", "is_optional": true, "type": "others", "default_value": "None", "description": "int or shape tuple Axes over which to calculate. Defaults to None,\nwhich shifts all axes."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.inverse_stft_window_fn", "type": "function", "code": "tf.signal.inverse_stft_window_fn(frame_step,forward_window_fn=tf.signal.hann_window,name=None)", "summary": "Generates a window function that can be used in inverse_stft.", "description": "", "code-info": {"name": "tf.signal.inverse_stft_window_fn", "parameters": [{"name": "frame_step", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor. The number of samples to step."}, {"name": "forward_window_fn", "is_optional": true, "type": "others", "default_value": "tf.signal.hann_window", "description": "window_fn used in the forward transform, stft."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.hann_window", "type": "function", "code": "tf.signal.hann_window(window_length,periodic=True,dtype=tf.dtypes.float32,name=None)", "summary": "Generate a Hann window.", "description": "", "code-info": {"name": "tf.signal.hann_window", "parameters": [{"name": "window_length", "is_optional": false, "type": "tensor", "description": "A scalar Tensor indicating the window length to generate."}, {"name": "periodic", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool Tensor indicating whether to generate a periodic or\nsymmetric window. Periodic windows are typically used for spectral\nanalysis while symmetric windows are typically used for digital\nfilter design."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The data type to produce. Must be a floating point type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.hamming_window", "type": "function", "code": "tf.signal.hamming_window(window_length,periodic=True,dtype=tf.dtypes.float32,name=None)", "summary": "Generate a Hamming window.", "description": "", "code-info": {"name": "tf.signal.hamming_window", "parameters": [{"name": "window_length", "is_optional": false, "type": "tensor", "description": "A scalar Tensor indicating the window length to generate."}, {"name": "periodic", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool Tensor indicating whether to generate a periodic or\nsymmetric window. Periodic windows are typically used for spectral\nanalysis while symmetric windows are typically used for digital\nfilter design."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The data type to produce. Must be a floating point type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.frame", "type": "function", "code": "tf.signal.frame(signal,frame_length,frame_step,pad_end=False,pad_value=0,axis=-1,name=None)", "summary": "Expands signal's axis dimension into frames of frame_length.", "description": "", "code-info": {"name": "tf.signal.frame", "parameters": [{"name": "signal", "is_optional": false, "type": "tensor", "description": "A [..., samples, ...] Tensor. The rank and dimensions\nmay be unknown. Rank must be at least 1."}, {"name": "frame_length", "is_optional": false, "type": "int", "description": "The frame length in samples. An integer or scalar Tensor."}, {"name": "frame_step", "is_optional": false, "type": "int", "description": "The frame hop size in samples. An integer or scalar Tensor."}, {"name": "pad_end", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to pad the end of signal with pad_value."}, {"name": "pad_value", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional scalar Tensor to use where the input signal\ndoes not exist when pad_end is True."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "-1", "description": "A scalar integer Tensor indicating the axis to frame. Defaults to\nthe last axis. Supports negative values for indexing from the end."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.fftshift", "type": "function", "code": "tf.signal.fftshift(x,axes=None,name=None)", "summary": "Shift the zero-frequency component to the center of the spectrum.", "description": "", "code-info": {"name": "tf.signal.fftshift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor, input tensor."}, {"name": "axes", "is_optional": true, "type": "others", "default_value": "None", "description": "int or shape tuple, optional Axes over which to shift.  Default is\nNone, which shifts all axes."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.fft3d", "type": "function", "code": "tf.signal.fft3d(input,name=None)", "summary": "3D fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.fft3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.idct", "type": "function", "code": "tf.signal.idct(input,type=2,n=None,axis=-1,norm=None,name=None)", "summary": "Computes the 1D Inverse Discrete Cosine Transform (DCT) of input.", "description": "", "code-info": {"name": "tf.signal.idct", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A [..., samples] float32/float64 Tensor containing the\nsignals to take the DCT of."}, {"name": "type", "is_optional": true, "type": "int", "default_value": "2", "description": "The IDCT type to perform. Must be 1, 2 or 3."}, {"name": "n", "is_optional": true, "type": "others", "default_value": "None", "description": "For future expansion. The length of the transform. Must be None."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "For future expansion. The axis to compute the DCT along. Must be -1."}, {"name": "norm", "is_optional": true, "type": "others", "default_value": "None", "description": "The normalization to apply. None for no normalization or 'ortho'\nfor orthonormal normalization."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.signal.fft2d", "type": "function", "code": "tf.signal.fft2d(input,name=None)", "summary": "2D fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.fft2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.fft", "type": "function", "code": "tf.signal.fft(input,name=None)", "summary": "Fast Fourier transform.", "description": "", "code-info": {"name": "tf.signal.fft", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nA complex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.signal.dct", "type": "function", "code": "tf.signal.dct(input,type=2,n=None,axis=-1,norm=None,name=None)", "summary": "Computes the 1D Discrete Cosine Transform (DCT) of input.", "description": "", "code-info": {"name": "tf.signal.dct", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A [..., samples] float32/float64 Tensor containing the\nsignals to take the DCT of."}, {"name": "type", "is_optional": true, "type": "int", "default_value": "2", "description": "The DCT type to perform. Must be 1, 2 or 3."}, {"name": "n", "is_optional": true, "type": "others", "default_value": "None", "description": "The length of the transform. If length is less than sequence length,\nonly the first n elements of the sequence are considered for the DCT.\nIf n is greater than the sequence length, zeros are padded and then\nthe DCT is computed as usual."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "For future expansion. The axis to compute the DCT along. Must be -1."}, {"name": "norm", "is_optional": true, "type": "others", "default_value": "None", "description": "The normalization to apply. None for no normalization or 'ortho'\nfor orthonormal normalization."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name for the operation."}]}},
{"id": "tf.sets.union", "type": "function", "code": "tf.sets.union(a,b,validate_indices=True)", "summary": "Compute set union of elements in last dimension of a and b.", "description": "", "code-info": {"name": "tf.sets.union", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as b. If sparse, indices\nmust be sorted in row-major order."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as a. If sparse, indices\nmust be sorted in row-major order."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to validate the order and range of sparse indices\nin a and b."}]}},
{"id": "tf.sets.size", "type": "function", "code": "tf.sets.size(a,validate_indices=True)", "summary": "Compute number of unique elements along last dimension of a.", "description": "", "code-info": {"name": "tf.sets.size", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "SparseTensor, with indices sorted in row-major order."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to validate the order and range of sparse indices\nin a."}]}},
{"id": "tf.sets.intersection", "type": "function", "code": "tf.sets.intersection(a,b,validate_indices=True)", "summary": "Compute set intersection of elements in last dimension of a and b.", "description": "", "code-info": {"name": "tf.sets.intersection", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as b. If sparse, indices\nmust be sorted in row-major order."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as a. If sparse, indices\nmust be sorted in row-major order."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to validate the order and range of sparse indices\nin a and b."}]}},
{"id": "tf.saved_model.save", "type": "function", "code": "tf.saved_model.save(obj,export_dir,signatures=None,options=None)", "summary": "Exports the Trackable object obj to SavedModel format.", "description": "", "code-info": {"name": "tf.saved_model.save", "parameters": [{"name": "obj", "is_optional": false, "type": "others", "description": "A trackable object to export."}, {"name": "export_dir", "is_optional": false, "type": "others", "description": "A directory in which to write the SavedModel."}, {"name": "signatures", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional, either a tf.function with an input signature\nspecified or the result of f.get_concrete_function on a\n@tf.function-decorated function f, in which case f will be used to\ngenerate a signature for the SavedModel under the default serving\nsignature key. signatures may also be a dictionary, in which case it\nmaps from signature keys to either tf.function instances with input\nsignatures or concrete functions. The keys of such a dictionary may be\narbitrary strings, but will typically be from the\ntf.saved_model.signature_constants module."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional, tf.saved_model.SaveOptions object that specifies\noptions for saving."}]}},
{"id": "tf.sets.difference", "type": "function", "code": "tf.sets.difference(a,b,aminusb=True,validate_indices=True)", "summary": "Compute set difference of elements in last dimension of a and b.", "description": "", "code-info": {"name": "tf.sets.difference", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as b. If sparse, indices\nmust be sorted in row-major order."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor of the same type as a. If sparse, indices\nmust be sorted in row-major order."}, {"name": "aminusb", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to subtract b from a, vs vice versa."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to validate the order and range of sparse indices\nin a and b."}]}},
{"id": "tf.saved_model.SaveOptions", "type": "function", "code": "tf.saved_model.SaveOptions(namespace_whitelist=None,save_debug_info=False)", "summary": "Options for saving to SavedModel.", "description": "", "code-info": {"name": "tf.saved_model.SaveOptions", "parameters": [{"name": "namespace_whitelist", "is_optional": true, "type": "string", "default_value": "None", "description": "List of strings containing op namespaces to whitelist\nwhen saving a model. Saving an object that uses namespaced ops must\nexplicitly add all namespaces to the whitelist. The namespaced ops must\nbe registered into the framework when loading the SavedModel."}, {"name": "save_debug_info", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean indicating whether debug information is saved.\nIf True, then a debug/saved_model_debug_info.pb file will be written\nwith the contents of a GraphDebugInfo binary protocol buffer containing\nstack trace information for all ops and functions that are saved."}]}},
{"id": "tf.saved_model.load", "type": "function", "code": "tf.saved_model.load(export_dir,tags=None)", "summary": "Load a SavedModel from export_dir.", "description": "", "code-info": {"name": "tf.saved_model.load", "parameters": [{"name": "export_dir", "is_optional": false, "type": "others", "description": "The SavedModel directory to load from."}, {"name": "tags", "is_optional": true, "type": "others", "default_value": "None", "description": "A tag or sequence of tags identifying the MetaGraph to load. Optional\nif the SavedModel contains a single MetaGraph, as for those exported from\ntf.saved_model.load."}]}},
{"id": "tf.saved_model.contains_saved_model", "type": "function", "code": "tf.saved_model.contains_saved_model(export_dir)", "summary": "Checks whether the provided export directory could contain a SavedModel.", "description": "", "code-info": {"name": "tf.saved_model.contains_saved_model", "parameters": [{"name": "export_dir", "is_optional": false, "type": "string", "description": "Absolute string path to possible export location. For example,\n        '/my/foo/model'."}]}},
{"id": "tf.saved_model.Asset", "type": "function", "code": "tf.saved_model.Asset(path)", "summary": "Represents a file asset to hermetically include in a SavedModel.", "description": "", "code-info": {"name": "tf.saved_model.Asset", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.random.experimental.get_global_generator", "type": "function", "code": "tf.random.experimental.get_global_generator()", "summary": "", "description": "", "code-info": {"name": "tf.random.experimental.get_global_generator", "parameters": []}},
{"id": "tf.random.experimental.create_rng_state", "type": "function", "code": "tf.random.experimental.create_rng_state(seed,algorithm)", "summary": "Creates a RNG state.", "description": "", "code-info": {"name": "tf.random.experimental.create_rng_state", "parameters": [{"name": "seed", "is_optional": false, "type": "tensor", "description": "an integer or 1-D tensor."}, {"name": "algorithm", "is_optional": false, "type": "int", "description": "an integer representing the RNG algorithm."}]}},
{"id": "tf.random.experimental.Generator", "type": "class", "code": "tf.random.experimental.Generator(copy_from=None,state=None,alg=None)", "summary": "Random-number generator.", "description": "", "code-info": {"name": "tf.random.experimental.Generator", "parameters": [{"name": "copy_from", "is_optional": true, "type": "others", "default_value": "None", "description": "a generator to be copied from."}, {"name": "state", "is_optional": true, "type": "others", "default_value": "None", "description": "a vector of dtype STATE_TYPE representing the initial state of the\nRNG, whose length and semantics are algorithm-specific."}, {"name": "alg", "is_optional": true, "type": "others", "default_value": "None", "description": "the RNG algorithm. Possible values are RNG_ALG_PHILOX for the\nPhilox algorithm and RNG_ALG_THREEFRY for the ThreeFry\nalgorithm (see paper 'Parallel Random Numbers: As Easy as 1, 2, 3'\n[https://www.thesalmons.org/john/random123/papers/random123sc11.pdf]).\nNote RNG_ALG_PHILOX guarantees the same numbers are produced (given\nthe same random state) across all architextures (CPU, GPU, XLA etc)."}]}},
{"id": "tf.random.experimental.set_global_generator", "type": "function", "code": "tf.random.experimental.set_global_generator(generator)", "summary": "Replaces the global generator with another Generator object.", "description": "", "code-info": {"name": "tf.random.experimental.set_global_generator", "parameters": [{"name": "generator", "is_optional": false, "type": "others", "description": "the new Generator object."}]}},
{"id": "tf.random.uniform", "type": "function", "code": "tf.random.uniform(shape,minval=0,maxval=None,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Outputs random values from a uniform distribution.", "description": "", "code-info": {"name": "tf.random.uniform", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "minval", "is_optional": true, "type": "int", "default_value": "0", "description": "A Tensor or Python value of type dtype, broadcastable with\nmaxval. The lower bound on the range of random values to generate\n(inclusive).  Defaults to 0."}, {"name": "maxval", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor or Python value of type dtype, broadcastable with\nminval. The upper bound on the range of random values to generate\n(exclusive). Defaults to 1 if dtype is floating point."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The type of the output: float16, float32, float64, int32,\nor int64."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used in combination with tf.random.set_seed to\ncreate a reproducible sequence of tensors across multiple calls."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.shuffle", "type": "function", "code": "tf.random.shuffle(value,seed=None,name=None)", "summary": "Randomly shuffles a tensor along its first dimension.", "description": "", "code-info": {"name": "tf.random.shuffle", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor to be shuffled."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distribution.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.uniform_candidate_sampler", "type": "function", "code": "tf.random.uniform_candidate_sampler(true_classes,num_true,num_sampled,unique,range_max,seed=None,name=None)", "summary": "Samples a set of classes using a uniform base distribution.", "description": "", "code-info": {"name": "tf.random.uniform_candidate_sampler", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample. The\nsampled_candidates return value will have shape [num_sampled]. If\nunique=True, num_sampled must be less than or equal to range_max."}, {"name": "unique", "is_optional": false, "type": "bool", "description": "A bool. Determines whether all sampled classes in a batch are\nunique."}, {"name": "range_max", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. An operation-specific seed. Default is 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.truncated_normal", "type": "function", "code": "tf.random.truncated_normal(shape,mean=0.0,stddev=1.0,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Outputs random values from a truncated normal distribution.", "description": "", "code-info": {"name": "tf.random.truncated_normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A 0-D Tensor or Python value of type dtype. The mean of the\ntruncated normal distribution."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A 0-D Tensor or Python value of type dtype. The standard deviation\nof the normal distribution, before truncation."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "The type of the output."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distribution.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.stateless_uniform", "type": "function", "code": "tf.random.stateless_uniform(shape,seed,minval=0,maxval=None,dtype=tf.dtypes.float32,name=None)", "summary": "Outputs deterministic pseudorandom values from a uniform distribution.", "description": "", "code-info": {"name": "tf.random.stateless_uniform", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "seed", "is_optional": false, "type": "tensor", "description": "A shape [2] integer Tensor of seeds to the random number generator."}, {"name": "minval", "is_optional": true, "type": "int", "default_value": "0", "description": "A 0-D Tensor or Python value of type dtype. The lower bound on the\nrange of random values to generate.  Defaults to 0."}, {"name": "maxval", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 0-D Tensor or Python value of type dtype. The upper bound on the\nrange of random values to generate.  Defaults to 1 if dtype is floating\npoint."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The type of the output: float16, float32, float64, int32, or\nint64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.stateless_truncated_normal", "type": "function", "code": "tf.random.stateless_truncated_normal(shape,seed,mean=0.0,stddev=1.0,dtype=tf.dtypes.float32,name=None)", "summary": "Outputs deterministic pseudorandom values, truncated normally distributed.", "description": "", "code-info": {"name": "tf.random.stateless_truncated_normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "seed", "is_optional": false, "type": "tensor", "description": "A shape [2] integer Tensor of seeds to the random number generator."}, {"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A 0-D Tensor or Python value of type dtype. The mean of the\ntruncated normal distribution."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A 0-D Tensor or Python value of type dtype. The standard deviation\nof the normal distribution, before truncation."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "The type of the output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.stateless_normal", "type": "function", "code": "tf.random.stateless_normal(shape,seed,mean=0.0,stddev=1.0,dtype=tf.dtypes.float32,name=None)", "summary": "Outputs deterministic pseudorandom values from a normal distribution.", "description": "", "code-info": {"name": "tf.random.stateless_normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "seed", "is_optional": false, "type": "tensor", "description": "A shape [2] integer Tensor of seeds to the random number generator."}, {"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A 0-D Tensor or Python value of type dtype. The mean of the normal\ndistribution."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A 0-D Tensor or Python value of type dtype. The standard deviation\nof the normal distribution."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "The type of the output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.stateless_categorical", "type": "function", "code": "tf.random.stateless_categorical(logits,num_samples,seed,dtype=tf.dtypes.int64,name=None)", "summary": "Draws deterministic pseudorandom samples from a categorical distribution.", "description": "", "code-info": {"name": "tf.random.stateless_categorical", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "2-D Tensor with shape [batch_size, num_classes].  Each slice\n[i, :] represents the unnormalized log-probabilities for all classes."}, {"name": "num_samples", "is_optional": false, "type": "others", "description": "0-D.  Number of independent samples to draw for each row slice."}, {"name": "seed", "is_optional": false, "type": "tensor", "description": "A shape [2] integer Tensor of seeds to the random number generator."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.int64", "description": "integer type to use for the output. Defaults to int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.random.gamma", "type": "function", "code": "tf.random.gamma(shape,alpha,beta=None,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Draws shape samples from each of the given Gamma distribution(s).", "description": "", "code-info": {"name": "tf.random.gamma", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output samples\nto be drawn per alpha/beta-parameterized distribution."}, {"name": "alpha", "is_optional": false, "type": "tensor", "description": "A Tensor or Python value or N-D array of type dtype. alpha\nprovides the shape parameter(s) describing the gamma distribution(s) to\nsample. Must be broadcastable with beta."}, {"name": "beta", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor or Python value or N-D array of type dtype. Defaults to 1.\nbeta provides the inverse scale parameter(s) of the gamma\ndistribution(s) to sample. Must be broadcastable with alpha."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The type of alpha, beta, and the output: float16, float32, or\nfloat64."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distributions.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.random.fixed_unigram_candidate_sampler", "type": "function", "code": "tf.random.fixed_unigram_candidate_sampler(true_classes,num_true,num_sampled,unique,range_max,vocab_file='',distortion=1.0,num_reserved_ids=0,num_shards=1,shard=0,unigrams=(),seed=None,name=None)", "summary": "Samples a set of classes using the provided (fixed) base distribution.", "description": "", "code-info": {"name": "tf.random.fixed_unigram_candidate_sampler", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample."}, {"name": "unique", "is_optional": false, "type": "bool", "description": "A bool. Determines whether all sampled classes in a batch are\nunique."}, {"name": "range_max", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "vocab_file", "is_optional": true, "type": "string", "default_value": "''", "description": "Each valid line in this file (which should have a CSV-like\nformat) corresponds to a valid word ID. IDs are in sequential order,\nstarting from num_reserved_ids. The last entry in each line is expected\nto be a value corresponding to the count or relative probability. Exactly\none of vocab_file and unigrams needs to be passed to this operation."}, {"name": "distortion", "is_optional": true, "type": "others", "default_value": "1.0", "description": "The distortion is used to skew the unigram probability\ndistribution.  Each weight is first raised to the distortion's power\nbefore adding to the internal unigram distribution. As a result,\ndistortion = 1.0 gives regular unigram sampling (as defined by the vocab\nfile), and distortion = 0.0 gives a uniform distribution."}, {"name": "num_reserved_ids", "is_optional": true, "type": "int", "default_value": "0", "description": "Optionally some reserved IDs can be added in the range\n[0, num_reserved_ids) by the users. One use case is that a special\nunknown word token is used as ID 0. These IDs will have a sampling\nprobability of 0."}, {"name": "num_shards", "is_optional": true, "type": "int", "default_value": "1", "description": "A sampler can be used to sample from a subset of the original\nrange in order to speed up the whole computation through parallelism. This\nparameter (together with shard) indicates the number of partitions that\nare being used in the overall computation."}, {"name": "shard", "is_optional": true, "type": "int", "default_value": "0", "description": "A sampler can be used to sample from a subset of the original range\nin order to speed up the whole computation through parallelism. This\nparameter (together with num_shards) indicates the particular partition\nnumber of the operation, when partitioning is being used."}, {"name": "unigrams", "is_optional": false, "type": "others", "description": "A list of unigram counts or probabilities, one per ID in\nsequential order. Exactly one of vocab_file and unigrams should be\npassed to this operation.\nseed: An int. An operation-specific seed. Default is 0.\nname: A name for the operation (optional)."}]}},
{"id": "tf.random.normal", "type": "function", "code": "tf.random.normal(shape,mean=0.0,stddev=1.0,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Outputs random values from a normal distribution.", "description": "", "code-info": {"name": "tf.random.normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output tensor."}, {"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A Tensor or Python value of type dtype, broadcastable with stddev.\nThe mean of the normal distribution."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A Tensor or Python value of type dtype, broadcastable with mean.\nThe standard deviation of the normal distribution."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "The type of the output."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distribution.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.poisson", "type": "function", "code": "tf.random.poisson(shape,lam,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Draws shape samples from each of the given Poisson distribution(s).", "description": "", "code-info": {"name": "tf.random.poisson", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output samples\nto be drawn per \"rate\"-parameterized distribution."}, {"name": "lam", "is_optional": false, "type": "tensor", "description": "A Tensor or Python value or N-D array of type dtype.\nlam provides the rate parameter(s) describing the poisson\ndistribution(s) to sample."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The type of the output: float16, float32, float64, int32 or\nint64."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distributions.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.random.log_uniform_candidate_sampler", "type": "function", "code": "tf.random.log_uniform_candidate_sampler(true_classes,num_true,num_sampled,unique,range_max,seed=None,name=None)", "summary": "Samples a set of classes using a log-uniform (Zipfian) base distribution.", "description": "", "code-info": {"name": "tf.random.log_uniform_candidate_sampler", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample."}, {"name": "unique", "is_optional": false, "type": "bool", "description": "A bool. Determines whether all sampled classes in a batch are\nunique."}, {"name": "range_max", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. An operation-specific seed. Default is 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random.all_candidate_sampler", "type": "function", "code": "tf.random.all_candidate_sampler(true_classes,num_true,num_sampled,unique,seed=None,name=None)", "summary": "Generate the set of all classes.", "description": "", "code-info": {"name": "tf.random.all_candidate_sampler", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of possible classes."}, {"name": "unique", "is_optional": false, "type": "bool", "description": "A bool. Ignored.\nunique."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. An operation-specific seed. Default is 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.ragged.stack_dynamic_partitions", "type": "function", "code": "tf.ragged.stack_dynamic_partitions(data,partitions,num_partitions,name=None)", "summary": "Stacks dynamic partitions of a Tensor or RaggedTensor.", "description": "", "code-info": {"name": "tf.ragged.stack_dynamic_partitions", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor or RaggedTensor containing the values to stack."}, {"name": "partitions", "is_optional": false, "type": "tensor", "description": "An int32 or int64 Tensor or RaggedTensor specifying the\npartition that each slice of data should be added to.\npartitions.shape must be a prefix of data.shape.  Values must be\ngreater than or equal to zero, and less than num_partitions.\npartitions is not required to be sorted."}, {"name": "num_partitions", "is_optional": false, "type": "float", "description": "An int32 or int64 scalar specifying the number of\npartitions to output.  This determines the number of rows in output."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}]}},
{"id": "tf.random.categorical", "type": "function", "code": "tf.random.categorical(logits,num_samples,dtype=None,seed=None,name=None)", "summary": "Draws samples from a categorical distribution.", "description": "", "code-info": {"name": "tf.random.categorical", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "2-D Tensor with shape [batch_size, num_classes].  Each slice\n[i, :] represents the unnormalized log-probabilities for all classes."}, {"name": "num_samples", "is_optional": false, "type": "others", "description": "0-D.  Number of independent samples to draw for each row slice."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "None", "description": "integer type to use for the output. Defaults to int64."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distribution.\nSee tf.compat.v1.set_random_seed for behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.ragged.stack", "type": "function", "code": "tf.ragged.stack(values,axis=0,name=None)", "summary": "Stacks a list of rank-R tensors into one rank-(R+1) RaggedTensor.", "description": "", "code-info": {"name": "tf.ragged.stack", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A list of tf.Tensor or tf.RaggedTensor.  May not be empty. All\nvalues must have the same rank and the same dtype; but unlike\ntf.stack, they can have arbitrary dimension sizes."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "A python integer, indicating the dimension along which to stack.\n(Note: Unlike tf.stack, the axis parameter must be statically known.)\nNegative values are supported only if the rank of at least one\nvalues value is statically known."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}]}},
{"id": "tf.ragged.segment_ids_to_row_splits", "type": "function", "code": "tf.ragged.segment_ids_to_row_splits(segment_ids,num_segments=None,out_type=None,name=None)", "summary": "Generates the RaggedTensor row_splits corresponding to a segmentation.", "description": "", "code-info": {"name": "tf.ragged.segment_ids_to_row_splits", "parameters": [{"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor."}, {"name": "num_segments", "is_optional": true, "type": "int", "default_value": "None", "description": "A scalar integer indicating the number of segments.  Defaults\nto max(segment_ids) + 1 (or zero if segment_ids is empty)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "None", "description": "The dtype for the return value.  Defaults to segment_ids.dtype,\nor tf.int64 if segment_ids does not have a dtype."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}]}},
{"id": "tf.random.learned_unigram_candidate_sampler", "type": "function", "code": "tf.random.learned_unigram_candidate_sampler(true_classes,num_true,num_sampled,unique,range_max,seed=None,name=None)", "summary": "Samples a set of classes from a distribution learned during training.", "description": "", "code-info": {"name": "tf.random.learned_unigram_candidate_sampler", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample."}, {"name": "unique", "is_optional": false, "type": "bool", "description": "A bool. Determines whether all sampled classes in a batch are\nunique."}, {"name": "range_max", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. An operation-specific seed. Default is 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.ragged.row_splits_to_segment_ids", "type": "function", "code": "tf.ragged.row_splits_to_segment_ids(splits,name=None,out_type=None)", "summary": "Generates the segmentation corresponding to a RaggedTensor row_splits.", "description": "", "code-info": {"name": "tf.ragged.row_splits_to_segment_ids", "parameters": [{"name": "splits", "is_optional": false, "type": "tensor", "description": "A sorted 1-D integer Tensor.  splits[0] must be zero."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "None", "description": "The dtype for the return value.  Defaults to splits.dtype,\nor tf.int64 if splits does not have a dtype."}]}},
{"id": "tf.random.set_seed", "type": "function", "code": "tf.random.set_seed(seed)", "summary": "Sets the global random seed.", "description": "", "code-info": {"name": "tf.random.set_seed", "parameters": [{"name": "seed", "is_optional": false, "type": "int", "description": "integer."}]}},
{"id": "tf.ragged.range", "type": "function", "code": "tf.ragged.range(starts,limits=None,deltas=1,dtype=None,name=None,row_splits_dtype=tf.dtypes.int64)", "summary": "Returns a RaggedTensor containing the specified sequences of numbers.", "description": "", "code-info": {"name": "tf.ragged.range", "parameters": [{"name": "starts", "is_optional": false, "type": "tensor", "description": "Vector or scalar Tensor.  Specifies the first entry for each range\nif limits is not None; otherwise, specifies the range limits, and the\nfirst entries default to 0."}, {"name": "limits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Vector or scalar Tensor.  Specifies the exclusive upper limits for\neach range."}, {"name": "deltas", "is_optional": true, "type": "int", "default_value": "1", "description": "Vector or scalar Tensor.  Specifies the increment for each range.\nDefaults to 1."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The type of the elements of the resulting tensor.  If not specified,\nthen a value is chosen based on the other args."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation."}, {"name": "row_splits_dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.int64", "description": "dtype for the returned RaggedTensor's row_splits\ntensor.  One of tf.int32 or tf.int64."}]}},
{"id": "tf.queue.PriorityQueue", "type": "class", "code": "tf.queue.PriorityQueue(capacity,types,shapes=None,names=None,shared_name=None,name='priority_queue')", "summary": "A queue implementation that dequeues elements in prioritized order.\n\nInherits From: QueueBase", "description": "", "code-info": {"name": "tf.queue.PriorityQueue", "parameters": [{"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The upper bound on the number of elements\nthat may be stored in this queue."}, {"name": "types", "is_optional": false, "type": "others", "description": " A list of DType objects. The length of types must equal\nthe number of tensors in each queue element, except the first priority\nelement.  The first tensor in each element is the priority,\nwhich must be type int64."}, {"name": "shapes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A list of fully-defined TensorShape objects,\nwith the same length as types, or None."}, {"name": "names", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A list of strings naming the components in the queue\nwith the same length as dtypes, or None.  If specified, the dequeue\nmethods return a dictionary with the names as keys."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If non-empty, this queue will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'priority_queue'", "description": "Optional name for the queue operation."}]}},
{"id": "tf.ragged.constant", "type": "function", "code": "tf.ragged.constant(pylist,dtype=None,ragged_rank=None,inner_shape=None,name=None,row_splits_dtype=tf.dtypes.int64)", "summary": "Constructs a constant RaggedTensor from a nested Python list.", "description": "", "code-info": {"name": "tf.ragged.constant", "parameters": [{"name": "pylist", "is_optional": false, "type": "others", "description": "A nested list, tuple or np.ndarray.  Any nested element that\nis not a list, tuple or np.ndarray must be a scalar value\ncompatible with dtype."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The type of elements for the returned RaggedTensor.  If not\nspecified, then a default is chosen based on the scalar values in\npylist."}, {"name": "ragged_rank", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer specifying the ragged rank of the returned\nRaggedTensor.  Must be nonnegative and less than K. Defaults to\nmax(0, K - 1) if inner_shape is not specified.  Defaults to `max(0, K\n\n1 - len(inner_shape))ifinner_shape` is specified.\n"}, {"name": "inner_shape", "is_optional": true, "type": "int", "default_value": "None", "description": "A tuple of integers specifying the shape for individual inner\nvalues in the returned RaggedTensor.  Defaults to () if ragged_rank\nis not specified.  If ragged_rank is specified, then a default is chosen\nbased on the contents of pylist."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}, {"name": "row_splits_dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.int64", "description": "data type for the constructed RaggedTensor's row_splits.\nOne of tf.int32 or tf.int64."}]}},
{"id": "tf.ragged.boolean_mask", "type": "function", "code": "tf.ragged.boolean_mask(data,mask,name=None)", "summary": "Applies a boolean mask to data without flattening the mask dimensions.", "description": "", "code-info": {"name": "tf.ragged.boolean_mask", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A potentially ragged tensor."}, {"name": "mask", "is_optional": false, "type": "tensor", "description": "A potentially ragged boolean tensor.  mask's shape must be a prefix\nof data's shape.  rank(mask) must be known statically."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensor (optional)."}]}},
{"id": "tf.queue.RandomShuffleQueue", "type": "class", "code": "tf.queue.RandomShuffleQueue(capacity,min_after_dequeue,dtypes,shapes=None,names=None,seed=None,shared_name=None,name='random_shuffle_queue')", "summary": "A queue implementation that dequeues elements in a random order.\n\nInherits From: QueueBase", "description": "", "code-info": {"name": "tf.queue.RandomShuffleQueue", "parameters": [{"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The upper bound on the number of elements\nthat may be stored in this queue."}, {"name": "min_after_dequeue", "is_optional": false, "type": "int", "description": "An integer (described above)."}, {"name": "dtypes", "is_optional": false, "type": "others", "description": " A list of DType objects. The length of dtypes must equal\nthe number of tensors in each queue element."}, {"name": "shapes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A list of fully-defined TensorShape objects\nwith the same length as dtypes, or None."}, {"name": "names", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A list of string naming the components in the queue\nwith the same length as dtypes, or None.  If specified the dequeue\nmethods return a dictionary with the names as keys."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If non-empty, this queue will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'random_shuffle_queue'", "description": "Optional name for the queue operation."}]}},
{"id": "tf.queue.QueueBase", "type": "class", "code": "tf.queue.QueueBase(dtypes,shapes,names,queue_ref)", "summary": "Base class for queue implementations.", "description": "", "code-info": {"name": "tf.queue.QueueBase", "parameters": [{"name": "dtypes", "is_optional": false, "type": "others", "description": " A list of types.  The length of dtypes must equal the number\nof tensors in each element."}, {"name": "shapes", "is_optional": false, "type": "tensor", "description": "Constraints on the shapes of tensors in an element:\nA list of shape tuples or None. This list is the same length\nas dtypes.  If the shape of any tensors in the element are constrained,\nall must be; shapes can be None if the shapes should not be constrained."}, {"name": "names", "is_optional": false, "type": "string", "description": "Optional list of names.  If provided, the enqueue() and\ndequeue() methods will use dictionaries with these names as keys.\nMust be None or a list or tuple of the same length as dtypes."}, {"name": "queue_ref", "is_optional": false, "type": "others", "description": "The queue reference, i.e. the output of the queue op."}]}},
{"id": "tf.ragged.map_flat_values", "type": "function", "code": "tf.ragged.map_flat_values(op,*args,**kwargs)", "summary": "Applies op to the values of one or more RaggedTensors.", "description": "", "code-info": {"name": "tf.ragged.map_flat_values", "parameters": [{"name": "op", "is_optional": false, "type": "others", "description": "The operation that should be applied to the RaggedTensor flat_values.\nop is typically an element-wise operation (such as math_ops.add), but\nany operation that preserves the size of the outermost dimension can be\nused.  I.e., shape[0] of the value returned by op must match\nshape[0] of the RaggedTensors' flat_values tensors."}, {"name": "*args", "is_optional": false, "type": "others", "description": "Arguments for op."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Keyword arguments for op."}]}},
{"id": "tf.queue.FIFOQueue", "type": "class", "code": "tf.queue.FIFOQueue(capacity,dtypes,shapes=None,names=None,shared_name=None,name='fifo_queue')", "summary": "A queue implementation that dequeues elements in first-in first-out order.\n\nInherits From: QueueBase", "description": "", "code-info": {"name": "tf.queue.FIFOQueue", "parameters": [{"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The upper bound on the number of elements\nthat may be stored in this queue."}, {"name": "dtypes", "is_optional": false, "type": "others", "description": " A list of DType objects. The length of dtypes must equal\nthe number of tensors in each queue element."}, {"name": "shapes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A list of fully-defined TensorShape objects\nwith the same length as dtypes, or None."}, {"name": "names", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A list of string naming the components in the queue\nwith the same length as dtypes, or None.  If specified the dequeue\nmethods return a dictionary with the names as keys."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If non-empty, this queue will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'fifo_queue'", "description": "Optional name for the queue operation."}]}},
{"id": "tf.queue.PaddingFIFOQueue", "type": "class", "code": "tf.queue.PaddingFIFOQueue(capacity,dtypes,shapes,names=None,shared_name=None,name='padding_fifo_queue')", "summary": "A FIFOQueue that supports batching variable-sized tensors by padding.\n\nInherits From: QueueBase", "description": "", "code-info": {"name": "tf.queue.PaddingFIFOQueue", "parameters": [{"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The upper bound on the number of elements\nthat may be stored in this queue."}, {"name": "dtypes", "is_optional": false, "type": "others", "description": " A list of DType objects. The length of dtypes must equal\nthe number of tensors in each queue element."}, {"name": "shapes", "is_optional": false, "type": "tensor", "description": "A list of TensorShape objects, with the same length as\ndtypes.  Any dimension in the TensorShape containing value\nNone is dynamic and allows values to be enqueued with\nvariable size in that dimension."}, {"name": "names", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A list of string naming the components in the queue\nwith the same length as dtypes, or None.  If specified the dequeue\nmethods return a dictionary with the names as keys."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If non-empty, this queue will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'padding_fifo_queue'", "description": "Optional name for the queue operation."}]}},
{"id": "tf.quantization.quantize", "type": "function", "code": "tf.quantization.quantize(input,min_range,max_range,T,mode='MIN_COMBINED',round_mode='HALF_AWAY_FROM_ZERO',name=None,narrow_range=False,axis=None,ensure_minimum_range=0.01)", "summary": "Quantize the 'input' tensor of type float to 'output' tensor of type 'T'.", "description": "", "code-info": {"name": "tf.quantization.quantize", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "min_range", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe minimum value of the quantization range. This value may be adjusted by the\nop depending on other parameters. The adjusted value is written to output_min.\nIf the axis attribute is specified, this must be a 1-D tensor whose size\nmatches the axis dimension of the input and output tensors."}, {"name": "max_range", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe maximum value of the quantization range. This value may be adjusted by the\nop depending on other parameters. The adjusted value is written to output_max.\nIf the axis attribute is specified, this must be a 1-D tensor whose size\nmatches the axis dimension of the input and output tensors."}, {"name": "T", "is_optional": false, "type": "others", "description": "A tf.DType from: tf.qint8, tf.quint8, tf.qint32, tf.qint16, tf.quint16."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'MIN_COMBINED'", "description": "An optional string from: \"MIN_COMBINED\", \"MIN_FIRST\", \"SCALED\". Defaults to \"MIN_COMBINED\"."}, {"name": "round_mode", "is_optional": true, "type": "string", "default_value": "'HALF_AWAY_FROM_ZERO'", "description": "An optional string from: \"HALF_AWAY_FROM_ZERO\", \"HALF_TO_EVEN\". Defaults to \"HALF_AWAY_FROM_ZERO\".\nnarrow_range: An optional bool. Defaults to False.\naxis: An optional int. Defaults to -1.\nensure_minimum_range: An optional float. Defaults to 0.01."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA tuple of Tensor objects (output, output_min, output_max).\n\n\noutput: A Tensor of type T.\noutput_min: A Tensor of type float32.\noutput_max: A Tensor of type float32.\n\n\n          "}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to -1."}, {"name": "ensure_minimum_range", "is_optional": true, "type": "float", "default_value": "0.01", "description": "An optional float. Defaults to 0.01.\nname: A name for the operation (optional)."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_vars_gradient", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_vars_gradient(gradients,inputs,min,max,num_bits=8,narrow_range=False,name=None)", "summary": "Compute gradients for a FakeQuantWithMinMaxVars operation.", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_vars_gradient", "parameters": [{"name": "gradients", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nBackpropagated gradients above the FakeQuantWithMinMaxVars operation."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nValues passed as inputs to the FakeQuantWithMinMaxVars operation.\nmin, max: Quantization interval, scalar floats."}, {"name": "min", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "max", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8.\nThe bitwidth of the quantization; between 2 and 8, inclusive."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nWhether to quantize into 2^num_bits - 1 distinct values."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.quantize_and_dequantize", "type": "function", "code": "tf.quantization.quantize_and_dequantize(input,input_min,input_max,signed_input=True,num_bits=8,range_given=False,round_mode='HALF_TO_EVEN',name=None,narrow_range=False,axis=None)", "summary": "Quantizes then dequantizes a tensor.", "description": "", "code-info": {"name": "tf.quantization.quantize_and_dequantize", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor to quantize and dequantize."}, {"name": "input_min", "is_optional": false, "type": "others", "description": "If range_given=True, the minimum input value, that needs to be\nrepresented in the quantized representation. If axis is specified, this\nshould be a vector of minimum values for each slice along axis."}, {"name": "input_max", "is_optional": false, "type": "others", "description": "If range_given=True, the maximum input value that needs to be\nrepresented in the quantized representation. If axis is specified, this\nshould be a vector of maximum values for each slice along axis."}, {"name": "signed_input", "is_optional": true, "type": "bool", "default_value": "True", "description": "True if the quantization is signed or unsigned."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "The bitwidth of the quantization."}, {"name": "range_given", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true use input_min and input_max for the range of the\ninput, otherwise determine min and max from the input Tensor."}, {"name": "round_mode", "is_optional": true, "type": "string", "default_value": "'HALF_TO_EVEN'", "description": "Rounding mode when rounding from float values to quantized ones.\none of ['HALF_TO_EVEN', 'HALF_UP']"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, then the absolute value of the quantized minimum\nvalue is the same as the quantized maximum value, instead of 1 greater.\ni.e. for 8 bit quantization, the minimum value is -127 instead of -128."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer. If specified, refers to a dimension of the input tensor, such\nthat quantization will be per slice along that dimension."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_vars", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_vars(inputs,min,max,num_bits=8,narrow_range=False,name=None)", "summary": "Fake-quantize the 'inputs' tensor of type float via global float scalars min", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_vars", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "min", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "max", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.quantized_concat", "type": "function", "code": "tf.quantization.quantized_concat(concat_dim,values,input_mins,input_maxes,name=None)", "summary": "Concatenates quantized tensors along one dimension.", "description": "", "code-info": {"name": "tf.quantization.quantized_concat", "parameters": [{"name": "concat_dim", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\n0-D.  The dimension along which to concatenate.  Must be in the\nrange [0, rank(values))."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A list of at least 2 Tensor objects with the same type.\nThe N Tensors to concatenate. Their ranks and types must match,\nand their sizes must match in all dimensions except concat_dim."}, {"name": "input_mins", "is_optional": false, "type": "tensor", "description": "A list with the same length as values of Tensor objects with type float32.\nThe minimum scalar values for each of the input tensors."}, {"name": "input_maxes", "is_optional": false, "type": "tensor", "description": "A list with the same length as values of Tensor objects with type float32.\nThe maximum scalar values for each of the input tensors."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient(gradients,inputs,min,max,num_bits=8,narrow_range=False,name=None)", "summary": "Compute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient", "parameters": [{"name": "gradients", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nBackpropagated gradients above the FakeQuantWithMinMaxVars operation,\nshape one of: [d], [b, d],  [b, h, w, d]."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nValues passed as inputs to the FakeQuantWithMinMaxVars operation, shape\nsame as gradients.\nmin, max: Quantization interval, floats of shape [d]."}, {"name": "min", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "max", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8.\nThe bitwidth of the quantization; between 2 and 16, inclusive."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nWhether to quantize into 2^num_bits - 1 distinct values."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_vars_per_channel", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_vars_per_channel(inputs,min,max,num_bits=8,narrow_range=False,name=None)", "summary": "Fake-quantize the 'inputs' tensor of type float and one of the shapes: [d],", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_vars_per_channel", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "min", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "max", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_args", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_args(inputs,min=-6,max=6,num_bits=8,narrow_range=False,name=None)", "summary": "Fake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same type.", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_args", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "min", "is_optional": true, "type": "float", "default_value": "-6", "description": "An optional float. Defaults to -6."}, {"name": "max", "is_optional": true, "type": "int", "default_value": "6", "description": "An optional float. Defaults to 6."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.quantization.dequantize", "type": "function", "code": "tf.quantization.dequantize(input,min_range,max_range,mode='MIN_COMBINED',name=None,axis=None,narrow_range=False)", "summary": "Dequantize the 'input' tensor into a float Tensor.", "description": "", "code-info": {"name": "tf.quantization.dequantize", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16."}, {"name": "min_range", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe minimum scalar value possibly produced for the input."}, {"name": "max_range", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe maximum scalar value possibly produced for the input."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'MIN_COMBINED'", "description": "An optional string from: \"MIN_COMBINED\", \"MIN_FIRST\", \"SCALED\". Defaults to \"MIN_COMBINED\".\nnarrow_range: An optional bool. Defaults to False.\naxis: An optional int. Defaults to -1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type float32.\n\n          "}, {"name": "axis", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional int. Defaults to -1.\nname: A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type float32.\n\n          "}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\naxis: An optional int. Defaults to -1.\nname: A name for the operation (optional)."}]}},
{"id": "tf.nn.swish", "type": "function", "code": "tf.nn.swish(features)", "summary": "Computes the Swish activation function: x * sigmoid(x).", "description": "", "code-info": {"name": "tf.nn.swish", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor representing preactivation values.\nname: A name for the operation (optional)."}]}},
{"id": "tf.nn.sufficient_statistics", "type": "function", "code": "tf.nn.sufficient_statistics(x,axes,shift=None,keepdims=False,name=None)", "summary": "Calculate the sufficient statistics for the mean and variance of x.", "description": "", "code-info": {"name": "tf.nn.sufficient_statistics", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axes", "is_optional": false, "type": "others", "description": "Array of ints. Axes along which to compute mean and variance."}, {"name": "shift", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor containing the value by which to shift the data for\nnumerical stability, or None if no shift is to be performed. A shift\nclose to the true mean provides the most numerically stable results."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "produce statistics with the same dimensionality as the input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operations that compute the sufficient stats."}]}},
{"id": "tf.nn.sparse_softmax_cross_entropy_with_logits", "type": "function", "code": "tf.nn.sparse_softmax_cross_entropy_with_logits(labels,logits,name=None)", "summary": "Computes sparse softmax cross entropy between logits and labels.", "description": "", "code-info": {"name": "tf.nn.sparse_softmax_cross_entropy_with_logits", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "Tensor of shape [d_0, d_1, ..., d_{r-1}] (where r is rank of\nlabels and result) and dtype int32 or int64. Each entry in labels\nmust be an index in [0, num_classes). Other values will raise an\nexception when this op is run on CPU, and return NaN for corresponding\nloss and gradient rows on GPU."}, {"name": "logits", "is_optional": false, "type": "others", "description": "Unscaled log probabilities of shape [d_0, d_1, ..., d_{r-1},\nnum_classes] and dtype float16, float32, or float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.with_space_to_batch", "type": "function", "code": "tf.nn.with_space_to_batch(input,dilation_rate,padding,op,filter_shape=None,spatial_dims=None,data_format=None)", "summary": "Performs op on the space-to-batch representation of input.", "description": "", "code-info": {"name": "tf.nn.with_space_to_batch", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "Tensor of rank &gt; max(spatial_dims)."}, {"name": "dilation_rate", "is_optional": false, "type": "tensor", "description": "int32 Tensor of known shape [num_spatial_dims]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "str constant equal to \"VALID\" or \"SAME\""}, {"name": "op", "is_optional": false, "type": "others", "description": "Function that maps (input, num_spatial_dims, padding) -&gt; output"}, {"name": "filter_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "If padding = \"SAME\", specifies the shape of the convolution\nkernel/pooling window as an integer Tensor of shape [&gt;=num_spatial_dims].\nIf padding = \"VALID\", filter_shape is ignored and need not be specified."}, {"name": "spatial_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Monotonically increasing sequence of num_spatial_dims\nintegers (which are &gt;= 1) specifying the spatial dimensions of input\nand output.  Defaults to: range(1, num_spatial_dims+1)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\"."}]}},
{"id": "tf.quantization.fake_quant_with_min_max_args_gradient", "type": "function", "code": "tf.quantization.fake_quant_with_min_max_args_gradient(gradients,inputs,min=-6,max=6,num_bits=8,narrow_range=False,name=None)", "summary": "Compute gradients for a FakeQuantWithMinMaxArgs operation.", "description": "", "code-info": {"name": "tf.quantization.fake_quant_with_min_max_args_gradient", "parameters": [{"name": "gradients", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nBackpropagated gradients above the FakeQuantWithMinMaxArgs operation."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nValues passed as inputs to the FakeQuantWithMinMaxArgs operation."}, {"name": "min", "is_optional": true, "type": "float", "default_value": "-6", "description": "An optional float. Defaults to -6."}, {"name": "max", "is_optional": true, "type": "int", "default_value": "6", "description": "An optional float. Defaults to 6."}, {"name": "num_bits", "is_optional": true, "type": "int", "default_value": "8", "description": "An optional int. Defaults to 8."}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.weighted_moments", "type": "function", "code": "tf.nn.weighted_moments(x,axes,frequency_weights,keepdims=False,name=None)", "summary": "Returns the frequency-weighted mean and variance of x.", "description": "", "code-info": {"name": "tf.nn.weighted_moments", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor."}, {"name": "axes", "is_optional": false, "type": "tensor", "description": "1-d tensor of int32 values; these are the axes along which\nto compute mean and variance."}, {"name": "frequency_weights", "is_optional": false, "type": "tensor", "description": "A tensor of positive weights which can be\nbroadcast with x."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "Produce moments with the same dimensionality as the input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operation."}]}},
{"id": "tf.nn.weighted_cross_entropy_with_logits", "type": "function", "code": "tf.nn.weighted_cross_entropy_with_logits(labels,logits,pos_weight,name=None)", "summary": "Computes a weighted cross entropy.", "description": "", "code-info": {"name": "tf.nn.weighted_cross_entropy_with_logits", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of the same type and shape as logits."}, {"name": "logits", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32 or float64."}, {"name": "pos_weight", "is_optional": false, "type": "others", "description": "A coefficient to use on the positive examples."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.space_to_depth", "type": "function", "code": "tf.nn.space_to_depth(input,block_size,data_format='NHWC',name=None)", "summary": "SpaceToDepth for tensors of type T.", "description": "", "code-info": {"name": "tf.nn.space_to_depth", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "block_size", "is_optional": false, "type": "others", "description": "An int that is &gt;= 2. The size of the spatial block."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.softsign", "type": "function", "code": "tf.nn.softsign(features,name=None)", "summary": "Computes softsign: features / (abs(features) + 1).", "description": "", "code-info": {"name": "tf.nn.softsign", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.softmax_cross_entropy_with_logits", "type": "function", "code": "tf.nn.softmax_cross_entropy_with_logits(labels,logits,axis=-1,name=None)", "summary": "Computes softmax cross entropy between logits and labels.", "description": "", "code-info": {"name": "tf.nn.softmax_cross_entropy_with_logits", "parameters": [{"name": "labels", "is_optional": false, "type": "others", "description": "Each vector along the class dimension should hold a valid\nprobability distribution e.g. for the case in which labels are of shape\n[batch_size, num_classes], each row of labels[i] must be a valid\nprobability distribution."}, {"name": "logits", "is_optional": false, "type": "others", "description": "Per-label activations, typically a linear output. These activation\nenergies are interpreted as unnormalized log probabilities."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The class dimension. Defaulted to -1 which is the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.softmax", "type": "function", "code": "tf.nn.softmax(logits,axis=None,name=None)", "summary": "Computes softmax activations.", "description": "", "code-info": {"name": "tf.nn.softmax", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "A non-empty Tensor. Must be one of the following types: half,\nfloat32, float64."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimension softmax would be performed on. The default is -1 which\nindicates the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.sigmoid_cross_entropy_with_logits", "type": "function", "code": "tf.nn.sigmoid_cross_entropy_with_logits(labels=None,logits=None,name=None)", "summary": "Computes sigmoid cross entropy given logits.", "description": "", "code-info": {"name": "tf.nn.sigmoid_cross_entropy_with_logits", "parameters": [{"name": "labels", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of the same type and shape as logits."}, {"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type float32 or float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.RNNCellResidualWrapper", "type": "class", "code": "tf.nn.RNNCellResidualWrapper(*args,**kwargs)", "summary": "RNNCell wrapper that ensures cell inputs are added to the outputs.", "description": "", "code-info": {"name": "tf.nn.RNNCellResidualWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.nn.safe_embedding_lookup_sparse", "type": "function", "code": "tf.nn.safe_embedding_lookup_sparse(embedding_weights,sparse_ids,sparse_weights=None,combiner='mean',default_id=None,max_norm=None,name=None)", "summary": "Lookup embedding results, accounting for invalid IDs and empty features.", "description": "", "code-info": {"name": "tf.nn.safe_embedding_lookup_sparse", "parameters": [{"name": "embedding_weights", "is_optional": false, "type": "tensor", "description": " A list of P float Tensors or values representing\npartitioned embedding Tensors.  Alternatively, a PartitionedVariable\ncreated by partitioning along dimension 0.  The total unpartitioned shape\nshould be [e_0, e_1, ..., e_m], where e_0 represents the vocab size\nand e_1, ..., e_m are the embedding dimensions."}, {"name": "sparse_ids", "is_optional": false, "type": "tensor", "description": "SparseTensor of shape [d_0, d_1, ..., d_n] containing the\nids. d_0 is typically batch size."}, {"name": "sparse_weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "SparseTensor of same shape as sparse_ids, containing\nfloat weights corresponding to sparse_ids, or None if all weights are\nbe assumed to be 1.0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to combine embedding results for each\nentry. Currently \"mean\", \"sqrtn\" and \"sum\" are supported, with \"mean\" the\ndefault."}, {"name": "default_id", "is_optional": true, "type": "others", "default_value": "None", "description": "The id to use for an entry with no features."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, all embeddings are l2-normalized to max_norm before\ncombining."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.RNNCellDropoutWrapper", "type": "class", "code": "tf.nn.RNNCellDropoutWrapper(*args,**kwargs)", "summary": "Operator adding dropout to inputs and outputs of the given cell.", "description": "", "code-info": {"name": "tf.nn.RNNCellDropoutWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.nn.separable_conv2d", "type": "function", "code": "tf.nn.separable_conv2d(input,depthwise_filter,pointwise_filter,strides,padding,data_format=None,dilations=None,name=None)", "summary": "2-D convolution with separable filters.", "description": "", "code-info": {"name": "tf.nn.separable_conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape according to data_format."}, {"name": "depthwise_filter", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape [filter_height, filter_width,\nin_channels, channel_multiplier]. Contains in_channels convolutional\nfilters of depth 1."}, {"name": "pointwise_filter", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape [1, 1, channel_multiplier *\nin_channels, out_channels].  Pointwise filter to mix channels after\ndepthwise_filter has convolved spatially."}, {"name": "strides", "is_optional": false, "type": "string", "description": "1-D of size 4.  The strides for the depthwise convolution for each\ndimension of input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'.  The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "The data format for input. Either \"NHWC\" (default) or \"NCHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "1-D of size 2. The dilation rate in which we sample input values\nacross the height and width dimensions in atrous convolution. If it is\ngreater than 1, then all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.selu", "type": "function", "code": "tf.nn.selu(features,name=None)", "summary": "Computes scaled exponential linear: scale * alpha * (exp(features) - 1)", "description": "", "code-info": {"name": "tf.nn.selu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.scale_regularization_loss", "type": "function", "code": "tf.nn.scale_regularization_loss(regularization_loss)", "summary": "Scales the sum of the given regularization losses by number of replicas.", "description": "", "code-info": {"name": "tf.nn.scale_regularization_loss", "parameters": [{"name": "regularization_loss", "is_optional": false, "type": "others", "description": "Regularization loss."}]}},
{"id": "tf.nn.sampled_softmax_loss", "type": "function", "code": "tf.nn.sampled_softmax_loss(weights,biases,labels,inputs,num_sampled,num_classes,num_true=1,sampled_values=None,remove_accidental_hits=True,seed=None,name='sampled_softmax_loss')", "summary": "Computes and returns the sampled softmax training loss.", "description": "", "code-info": {"name": "tf.nn.sampled_softmax_loss", "parameters": [{"name": "weights", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes, dim], or a list of Tensor\nobjects whose concatenation along dimension 0 has shape [num_classes,\ndim].  The (possibly-sharded) class embeddings."}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes].  The class biases."}, {"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size, num_true]. The\ntarget classes.  Note that this format differs from the labels argument\nof nn.softmax_cross_entropy_with_logits."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [batch_size, dim].  The forward activations of\nthe input network."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample per batch."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "num_true", "is_optional": true, "type": "int", "default_value": "1", "description": "An int.  The number of target classes per training example."}, {"name": "sampled_values", "is_optional": true, "type": "others", "default_value": "None", "description": "a tuple of (sampled_candidates, true_expected_count,\nsampled_expected_count) returned by a *_candidate_sampler function.\n(if None, we default to log_uniform_candidate_sampler)"}, {"name": "remove_accidental_hits", "is_optional": true, "type": "bool", "default_value": "True", "description": " A bool.  whether to remove \"accidental hits\"\nwhere a sampled class equals one of the target classes.  Default is True."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "random seed for candidate sampling. Default to None, which doesn't set\nthe op-level random seed for candidate sampling."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sampled_softmax_loss'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.relu6", "type": "function", "code": "tf.nn.relu6(features,name=None)", "summary": "Computes Rectified Linear 6: min(max(features, 0), 6).", "description": "", "code-info": {"name": "tf.nn.relu6", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor with type float, double, int32, int64, uint8,\nint16, or int8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.RNNCellDeviceWrapper", "type": "class", "code": "tf.nn.RNNCellDeviceWrapper(*args,**kwargs)", "summary": "Operator that ensures an RNNCell runs on a particular device.", "description": "", "code-info": {"name": "tf.nn.RNNCellDeviceWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.nn.normalize_moments", "type": "function", "code": "tf.nn.normalize_moments(counts,mean_ss,variance_ss,shift,name=None)", "summary": "Calculate the mean and variance of based on the sufficient statistics.", "description": "", "code-info": {"name": "tf.nn.normalize_moments", "parameters": [{"name": "counts", "is_optional": false, "type": "tensor", "description": "A Tensor containing the total count of the data (one value)."}, {"name": "mean_ss", "is_optional": false, "type": "tensor", "description": "A Tensor containing the mean sufficient statistics: the (possibly\nshifted) sum of the elements to average over."}, {"name": "variance_ss", "is_optional": false, "type": "tensor", "description": "A Tensor containing the variance sufficient statistics: the\n(possibly shifted) squared sum of the data to compute the variance over."}, {"name": "shift", "is_optional": false, "type": "tensor", "description": "A Tensor containing the value by which the data is shifted for\nnumerical stability, or None if no shift was performed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operations that compute the moments."}]}},
{"id": "tf.nn.nce_loss", "type": "function", "code": "tf.nn.nce_loss(weights,biases,labels,inputs,num_sampled,num_classes,num_true=1,sampled_values=None,remove_accidental_hits=False,name='nce_loss')", "summary": "Computes and returns the noise-contrastive estimation training loss.", "description": "", "code-info": {"name": "tf.nn.nce_loss", "parameters": [{"name": "weights", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes, dim], or a list of Tensor\nobjects whose concatenation along dimension 0 has shape [num_classes,\ndim].  The (possibly-partitioned) class embeddings."}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes].  The class biases."}, {"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size, num_true]. The\ntarget classes."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [batch_size, dim].  The forward activations of\nthe input network."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of negative classes to randomly sample\nper batch. This single sample of negative classes is evaluated for each\nelement in the batch."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "num_true", "is_optional": true, "type": "int", "default_value": "1", "description": "An int.  The number of target classes per training example."}, {"name": "sampled_values", "is_optional": true, "type": "others", "default_value": "None", "description": "a tuple of (sampled_candidates, true_expected_count,\nsampled_expected_count) returned by a *_candidate_sampler function.\n(if None, we default to log_uniform_candidate_sampler)"}, {"name": "remove_accidental_hits", "is_optional": true, "type": "bool", "default_value": "False", "description": " A bool.  Whether to remove \"accidental hits\"\nwhere a sampled class equals one of the target classes.  If set to True,\nthis is a \"Sampled Logistic\" loss instead of NCE, and we are learning to\ngenerate log-odds instead of log probabilities.  See our Candidate\nSampling Algorithms Reference. Default is\n  False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'nce_loss'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.moments", "type": "function", "code": "tf.nn.moments(x,axes,shift=None,keepdims=False,name=None)", "summary": "Calculates the mean and variance of x.", "description": "", "code-info": {"name": "tf.nn.moments", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axes", "is_optional": false, "type": "others", "description": "Array of ints.  Axes along which to compute mean and\nvariance."}, {"name": "shift", "is_optional": true, "type": "others", "default_value": "None", "description": "Not used in the current implementation."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "produce moments with the same dimensionality as the input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operations that compute the moments."}]}},
{"id": "tf.nn.max_pool_with_argmax", "type": "function", "code": "tf.nn.max_pool_with_argmax(input,ksize,strides,padding,data_format='NHWC',output_dtype=tf.dtypes.int64,include_batch_in_index=False,name=None)", "summary": "Performs max pooling on the input and outputs both max values and indices.", "description": "", "code-info": {"name": "tf.nn.max_pool_with_argmax", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint32, uint8, int16, int8, int64, bfloat16, uint16, half,\nuint32, uint64.\n4-D with shape [batch, height, width, channels].  Input to pool over."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.\nThe size of the window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.\nThe stride of the sliding window for each dimension of the\ninput tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string, must be set to \"NHWC\". Defaults to\n\"NHWC\".\nSpecify the data format of the input and output data."}, {"name": "output_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64.\nDefaults to tf.int64.\nThe dtype of the returned argmax tensor."}, {"name": "include_batch_in_index", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional boolean. Defaults to False.\nWhether to include batch dimension in flattened index of argmax."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.relu", "type": "function", "code": "tf.nn.relu(features,name=None)", "summary": "Computes rectified linear: max(features, 0).", "description": "", "code-info": {"name": "tf.nn.relu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64, qint8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.max_pool3d", "type": "function", "code": "tf.nn.max_pool3d(input,ksize,strides,padding,data_format='NDHWC',name=None)", "summary": "Performs the max pooling on the input.", "description": "", "code-info": {"name": "tf.nn.max_pool3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 5-D Tensor of the format specified by data_format."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 3 or 5. The size of\nthe window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 3 or 5. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to \"NDHWC\".\nThe data format of the input and output data. With the default format\n\"NDHWC\", the data is stored in the order of: [batch, in_depth, in_height,\nin_width, in_channels]. Alternatively, the format could be \"NCDHW\", the\ndata storage order is: [batch, in_channels, in_depth, in_height,\nin_width]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.pool", "type": "function", "code": "tf.nn.pool(input,window_shape,pooling_type,strides=None,padding='VALID',data_format=None,dilations=None,name=None)", "summary": "Performs an N-D pooling operation.", "description": "", "code-info": {"name": "tf.nn.pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "Tensor of rank N+2, of shape [batch_size] + input_spatial_shape +\n[num_channels] if data_format does not start with \"NC\" (default), or\n[batch_size, num_channels] + input_spatial_shape if data_format starts\nwith \"NC\".  Pooling happens over the spatial dimensions only."}, {"name": "window_shape", "is_optional": false, "type": "others", "description": "Sequence of N ints &gt;= 1."}, {"name": "pooling_type", "is_optional": false, "type": "others", "description": "Specifies pooling operation, must be \"AVG\" or \"MAX\"."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. Sequence of N ints &gt;= 1.  Defaults to [1]*N. If any value of\nstrides is &gt; 1, then all values of dilation_rate must be 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'VALID'", "description": "The padding algorithm, must be \"SAME\" or \"VALID\". Defaults to \"SAME\".\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\". For\nN=3, the valid values are \"NDHWC\" (default) and \"NCDHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Dilation rate.  List of N ints &gt;= 1. Defaults to\n[1]*N.  If any value of dilation_rate is &gt; 1, then all values of strides\nmust be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional. Name of the op."}]}},
{"id": "tf.nn.max_pool2d", "type": "function", "code": "tf.nn.max_pool2d(input,ksize,strides,padding,data_format='NHWC',name=None)", "summary": "Performs the max pooling on the input.", "description": "", "code-info": {"name": "tf.nn.max_pool2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of the format specified by data_format."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The size of\nthe window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC', 'NCHW' and 'NCHW_VECT_C' are supported."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.nn.max_pool1d", "type": "function", "code": "tf.nn.max_pool1d(input,ksize,strides,padding,data_format='NWC',name=None)", "summary": "Performs the max pooling on the input.", "description": "", "code-info": {"name": "tf.nn.max_pool1d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 3-D Tensor of the format specified by data_format."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3. The size of the\nwindow for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3. The stride of\nthe sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NWC'", "description": "An optional string from: \"NWC\", \"NCW\". Defaults to \"NWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.max_pool", "type": "function", "code": "tf.nn.max_pool(input,ksize,strides,padding,data_format=None,name=None)", "summary": "Performs the max pooling on the input.", "description": "", "code-info": {"name": "tf.nn.max_pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": " Tensor of rank N+2, of shape [batch_size] + input_spatial_shape +\n[num_channels] if data_format does not start with \"NC\" (default), or\n[batch_size, num_channels] + input_spatial_shape if data_format starts\nwith \"NC\". Pooling happens over the spatial dimensions only."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, N or N+2. The size\nof the window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, N or N+2. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Specifies the channel dimension. For N=1 it can be\neither \"NWC\" (default) or \"NCW\", for N=2 it can be either \"NHWC\" (default)\nor \"NCHW\" and for N=3 either \"NDHWC\" (default) or \"NCDHW\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.nn.log_softmax", "type": "function", "code": "tf.nn.log_softmax(logits,axis=None,name=None)", "summary": "Computes log softmax activations.", "description": "", "code-info": {"name": "tf.nn.log_softmax", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "A non-empty Tensor. Must be one of the following types: half,\nfloat32, float64."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimension softmax would be performed on. The default is -1 which\nindicates the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.log_poisson_loss", "type": "function", "code": "tf.nn.log_poisson_loss(targets,log_input,compute_full_loss=False,name=None)", "summary": "Computes log Poisson loss given log_input.", "description": "", "code-info": {"name": "tf.nn.log_poisson_loss", "parameters": [{"name": "targets", "is_optional": false, "type": "tensor", "description": "A Tensor of the same type and shape as log_input."}, {"name": "log_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32 or float64."}, {"name": "compute_full_loss", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to compute the full loss. If false, a constant\nterm is dropped in favor of more efficient optimization."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.local_response_normalization", "type": "function", "code": "tf.nn.local_response_normalization(input,depth_radius=5,bias=1,alpha=1,beta=0.5,name=None)", "summary": "Local Response Normalization.", "description": "", "code-info": {"name": "tf.nn.local_response_normalization", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32.\n4-D."}, {"name": "depth_radius", "is_optional": true, "type": "int", "default_value": "5", "description": "An optional int. Defaults to 5.\n0-D.  Half-width of the 1-D normalization window."}, {"name": "bias", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional float. Defaults to 1.\nAn offset (usually positive to avoid dividing by 0)."}, {"name": "alpha", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional float. Defaults to 1.\nA scale factor, usually positive."}, {"name": "beta", "is_optional": true, "type": "float", "default_value": "0.5", "description": "An optional float. Defaults to 0.5. An exponent."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.fractional_max_pool", "type": "function", "code": "tf.nn.fractional_max_pool(value,pooling_ratio,pseudo_random=False,overlapping=False,seed=0,name=None)", "summary": "Performs fractional max pooling on the input.", "description": "", "code-info": {"name": "tf.nn.fractional_max_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, height, width, channels]."}, {"name": "pooling_ratio", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.\nPooling ratio for each dimension of value, currently only supports row\nand col dimension and should be &gt;= 1.0. For example, a valid pooling ratio\nlooks like [1.0, 1.44, 1.73, 1.0]. The first and last elements must be 1.0\nbecause we don't allow pooling on batch and channels dimensions.  1.44 and\n1.73 are pooling ratio on height and width dimensions respectively."}, {"name": "pseudo_random", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False. When set to True,\ngenerates the pooling sequence in a pseudorandom fashion, otherwise, in a\nrandom fashion. Check paper Benjamin Graham, Fractional\nMax-Pooling for difference between\npseudorandom and random."}, {"name": "overlapping", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False.  When set to True,\nit means when pooling, the values at the boundary of adjacent pooling\ncells are used by both cells. For example:\nindex  0  1  2  3  4\nvalue  20 5  16 3  7\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used\ntwice.  The result would be [20, 16] for fractional max pooling."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Defaults to 0.  If set to be non-zero, the\nrandom number generator is seeded by the given seed.  Otherwise it is\nseeded by a random seed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.l2_loss", "type": "function", "code": "tf.nn.l2_loss(t,name=None)", "summary": "L2 Loss.", "description": "", "code-info": {"name": "tf.nn.l2_loss", "parameters": [{"name": "t", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\nTypically 2-D, but may have any dimensions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.elu", "type": "function", "code": "tf.nn.elu(features,name=None)", "summary": "Computes exponential linear: exp(features) - 1 if &lt; 0, features otherwise.", "description": "", "code-info": {"name": "tf.nn.elu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.leaky_relu", "type": "function", "code": "tf.nn.leaky_relu(features,alpha=0.2,name=None)", "summary": "Compute the Leaky ReLU activation function.", "description": "", "code-info": {"name": "tf.nn.leaky_relu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor representing preactivation values. Must be one of\nthe following types: float16, float32, float64, int32, int64."}, {"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.2", "description": "Slope of the activation function at x &lt; 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.fractional_avg_pool", "type": "function", "code": "tf.nn.fractional_avg_pool(value,pooling_ratio,pseudo_random=False,overlapping=False,seed=0,name=None)", "summary": "Performs fractional average pooling on the input.", "description": "", "code-info": {"name": "tf.nn.fractional_avg_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, height, width, channels]."}, {"name": "pooling_ratio", "is_optional": false, "type": "float", "description": "A list of floats that has length &gt;= 4.  Pooling ratio for\neach dimension of value, currently only supports row and col dimension\nand should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0,\n1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't\nallow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling\nratio on height and width dimensions respectively."}, {"name": "pseudo_random", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False. When set to True,\ngenerates the pooling sequence in a pseudorandom fashion, otherwise, in a\nrandom fashion. Check paper Benjamin Graham, Fractional\nMax-Pooling for difference between\npseudorandom and random."}, {"name": "overlapping", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False.  When set to True,\nit means when pooling, the values at the boundary of adjacent pooling\ncells are used by both cells. For example:\nindex  0  1  2  3  4\nvalue  20 5  16 3  7\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used\ntwice.  The result would be [20, 16] for fractional avg pooling."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Defaults to 0.  If set to be non-zero, the\nrandom number generator is seeded by the given seed.  Otherwise it is\nseeded by a random seed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.erosion2d", "type": "function", "code": "tf.nn.erosion2d(value,filters,strides,padding,data_format,dilations,name=None)", "summary": "Computes the grayscale erosion of 4-D value and 3-D filters tensors.", "description": "", "code-info": {"name": "tf.nn.erosion2d", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, in_height, in_width, depth]."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as value.\n3-D with shape [filters_height, filters_width, depth]."}, {"name": "strides", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\n1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: [1, stride_height, stride_width, 1]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": false, "type": "string", "description": "A string, only \"NHWC\" is currently supported."}, {"name": "dilations", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\n1-D of length 4. The input stride for atrous morphological dilation.\nMust be: [1, rate_height, rate_width, 1]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional). If not specified \"erosion2d\"\nis used."}]}},
{"id": "tf.nn.embedding_lookup_sparse", "type": "function", "code": "tf.nn.embedding_lookup_sparse(params,sp_ids,sp_weights,combiner=None,max_norm=None,name=None)", "summary": "Computes embeddings for the given ids and weights.", "description": "", "code-info": {"name": "tf.nn.embedding_lookup_sparse", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A single tensor representing the complete embedding tensor, or a\nlist of P tensors all of same shape except for the first dimension,\nrepresenting sharded embedding tensors.  Alternatively, a\nPartitionedVariable, created by partitioning along dimension 0. Each\nelement must be appropriately sized for \"div\" partition_strategy."}, {"name": "sp_ids", "is_optional": false, "type": "tensor", "description": "N x M SparseTensor of int64 ids where N is typically batch size\nand M is arbitrary."}, {"name": "sp_weights", "is_optional": false, "type": "tensor", "description": "either a SparseTensor of float / double weights, or None to\nindicate all weights should be taken to be 1. If specified, sp_weights\nmust have exactly the same shape and indices as sp_ids."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "None", "description": "A string specifying the reduction op. Currently \"mean\", \"sqrtn\"\nand \"sum\" are supported. \"sum\" computes the weighted sum of the embedding\nresults for each row. \"mean\" is the weighted sum divided by the total\nweight. \"sqrtn\" is the weighted sum divided by the square root of the sum\nof the squares of the weights."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is larger\nthan this value, before combining."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}]}},
{"id": "tf.nn.embedding_lookup", "type": "function", "code": "tf.nn.embedding_lookup(params,ids,max_norm=None,name=None)", "summary": "Looks up ids in a list of embedding tensors.", "description": "", "code-info": {"name": "tf.nn.embedding_lookup", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A single tensor representing the complete embedding tensor, or a\nlist of P tensors all of same shape except for the first dimension,\nrepresenting sharded embedding tensors.  Alternatively, a\nPartitionedVariable, created by partitioning along dimension 0. Each\nelement must be appropriately sized for the 'div' partition_strategy."}, {"name": "ids", "is_optional": false, "type": "tensor", "description": "A Tensor with type int32 or int64 containing the ids to be looked\nup in params."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is larger\nthan this value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.dropout", "type": "function", "code": "tf.nn.dropout(x,rate,noise_shape=None,seed=None,name=None)", "summary": "Computes dropout: randomly sets elements to zero to prevent overfitting.", "description": "", "code-info": {"name": "tf.nn.dropout", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A floating point tensor."}, {"name": "rate", "is_optional": false, "type": "tensor", "description": "A scalar Tensor with the same type as x. The probability\nthat each element is dropped. For example, setting rate=0.1 would drop\n10% of input elements."}, {"name": "noise_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D Tensor of type int32, representing the\nshape for randomly generated keep/drop flags."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.random.set_seed for behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.depthwise_conv2d_backprop_input", "type": "function", "code": "tf.nn.depthwise_conv2d_backprop_input(input_sizes,filter,out_backprop,strides,padding,data_format='NHWC',dilations=[1,1,1,1],name=None)", "summary": "Computes the gradients of depthwise convolution with respect to the input.", "description": "", "code-info": {"name": "tf.nn.depthwise_conv2d_backprop_input", "parameters": [{"name": "input_sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAn integer vector representing the shape of input, based\non data_format.  For example, if data_format is 'NHWC' then\ninput is a 4-D [batch, height, width, channels] tensor."}, {"name": "filter", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\n4-D with shape\n[filter_height, filter_width, in_channels, depthwise_multiplier]."}, {"name": "out_backprop", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as filter.\n4-D with shape  based on data_format.\nFor example, if data_format is 'NHWC' then\nout_backprop shape is [batch, out_height, out_width, out_channels].\nGradients w.r.t. the output of the convolution."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\nof the convolution."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\". Defaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, channels, height, width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.ctc_loss", "type": "function", "code": "tf.nn.ctc_loss(labels,logits,label_length,logit_length,logits_time_major=True,unique=None,blank_index=None,name=None)", "summary": "Computes CTC (Connectionist Temporal Classification) loss.", "description": "", "code-info": {"name": "tf.nn.ctc_loss", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "tensor of shape [batch_size, max_label_seq_length] or SparseTensor"}, {"name": "logits", "is_optional": false, "type": "tensor", "description": "tensor of shape [frames, batch_size, num_labels], if\nlogits_time_major == False, shape is [batch_size, frames, num_labels]."}, {"name": "label_length", "is_optional": false, "type": "tensor", "description": "tensor of shape [batch_size], None if labels is SparseTensor\nLength of reference label sequence in labels."}, {"name": "logit_length", "is_optional": false, "type": "tensor", "description": "tensor of shape [batch_size] Length of input sequence in\nlogits."}, {"name": "logits_time_major", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) If True (default), logits is shaped [time,\nbatch, logits]. If False, shape is [batch, time, logits]"}, {"name": "unique", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Unique label indices as computed by\nctc_unique_labels(labels).  If supplied, enable a faster, memory efficient\nimplementation on TPU."}, {"name": "blank_index", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Set the class index to use for the blank label.\nNegative values will start from num_classes, ie, -1 will reproduce the\nctc_loss behavior of using num_classes - 1 for the blank symbol. There is\nsome memory/performance overhead to switching from the default of 0 as an\nadditional shifted copy of the logits may be created."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this Op. Defaults to \"ctc_loss_dense\"."}]}},
{"id": "tf.nn.depth_to_space", "type": "function", "code": "tf.nn.depth_to_space(input,block_size,data_format='NHWC',name=None)", "summary": "DepthToSpace for tensors of type T.", "description": "", "code-info": {"name": "tf.nn.depth_to_space", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "block_size", "is_optional": false, "type": "others", "description": "An int that is &gt;= 2.\nThe size of the spatial block, same as in Space2Depth."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.dilation2d", "type": "function", "code": "tf.nn.dilation2d(input,filters,strides,padding,data_format,dilations,name=None)", "summary": "Computes the grayscale dilation of 4-D input and 3-D filters tensors.", "description": "", "code-info": {"name": "tf.nn.dilation2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint32, uint8, int16, int8, int64, bfloat16, uint16, half,\nuint32, uint64.\n4-D with shape [batch, in_height, in_width, depth]."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\n3-D with shape [filter_height, filter_width, depth]."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints that has length &gt;= 4.\nThe stride of the sliding window for each dimension of the input\ntensor. Must be: [1, stride_height, stride_width, 1]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": false, "type": "string", "description": "A string, only \"NHWC\" is currently supported."}, {"name": "dilations", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\nThe input stride for atrous morphological dilation. Must be:\n[1, rate_height, rate_width, 1]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.ctc_greedy_decoder", "type": "function", "code": "tf.nn.ctc_greedy_decoder(inputs,sequence_length,merge_repeated=True)", "summary": "Performs greedy decoding on the logits given in input (best path).", "description": "", "code-info": {"name": "tf.nn.ctc_greedy_decoder", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "3-D float Tensor sized [max_time, batch_size, num_classes].\nThe logits."}, {"name": "sequence_length", "is_optional": false, "type": "others", "description": "1-D int32 vector containing sequence lengths, having size\n[batch_size]."}, {"name": "merge_repeated", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean.  Default: True."}]}},
{"id": "tf.nn.depthwise_conv2d_backprop_filter", "type": "function", "code": "tf.nn.depthwise_conv2d_backprop_filter(input,filter_sizes,out_backprop,strides,padding,data_format='NHWC',dilations=[1,1,1,1],name=None)", "summary": "Computes the gradients of depthwise convolution with respect to the filter.", "description": "", "code-info": {"name": "tf.nn.depthwise_conv2d_backprop_filter", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\n4-D with shape based on data_format.  For example, if\ndata_format is 'NHWC' then input is a 4-D [batch, in_height,\nin_width, in_channels] tensor."}, {"name": "filter_sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAn integer vector representing the tensor shape of filter,\nwhere filter is a 4-D\n[filter_height, filter_width, in_channels, depthwise_multiplier] tensor."}, {"name": "out_backprop", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\n4-D with shape  based on data_format.\nFor example, if data_format is 'NHWC' then\nout_backprop shape is [batch, out_height, out_width, out_channels].\nGradients w.r.t. the output of the convolution."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\nof the convolution."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\". Defaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, channels, height, width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.depthwise_conv2d", "type": "function", "code": "tf.nn.depthwise_conv2d(input,filter,strides,padding,data_format=None,dilations=None,name=None)", "summary": "Depthwise 2-D convolution.", "description": "", "code-info": {"name": "tf.nn.depthwise_conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "others", "description": "4-D with shape according to data_format."}, {"name": "filter", "is_optional": false, "type": "others", "description": "4-D with shape\n[filter_height, filter_width, in_channels, channel_multiplier]."}, {"name": "strides", "is_optional": false, "type": "string", "description": "1-D of size 4.  The stride of the sliding window for each\ndimension of input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "The data format for input. Either \"NHWC\" (default) or \"NCHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "1-D of size 2. The dilation rate in which we sample input values\nacross the height and width dimensions in atrous convolution. If it is\ngreater than 1, then all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.ctc_unique_labels", "type": "function", "code": "tf.nn.ctc_unique_labels(labels,name=None)", "summary": "Get unique labels and indices for batched labels for tf.nn.ctc_loss.", "description": "", "code-info": {"name": "tf.nn.ctc_unique_labels", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "tensor of shape [batch_size, max_label_length] padded with 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this Op. Defaults to \"ctc_unique_labels\"."}]}},
{"id": "tf.nn.crelu", "type": "function", "code": "tf.nn.crelu(features,axis=-1,name=None)", "summary": "Computes Concatenated ReLU.", "description": "", "code-info": {"name": "tf.nn.crelu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor with type float, double, int32, int64, uint8,\nint16, or int8.\nname: A name for the operation (optional)."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The axis that the output values are concatenated along. Default is -1.\n\n\nReturns:\n\nA Tensor with the same type as features.\n\n          "}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\naxis: The axis that the output values are concatenated along. Default is -1."}]}},
{"id": "tf.nn.conv_transpose", "type": "function", "code": "tf.nn.conv_transpose(input,filters,output_shape,strides,padding='SAME',data_format=None,dilations=None,name=None)", "summary": "The transpose of convolution.", "description": "", "code-info": {"name": "tf.nn.conv_transpose", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N+2 dimensional Tensor of shape\n[batch_size] + input_spatial_shape + [in_channels] if data_format does\nnot start with \"NC\" (default), or\n[batch_size, in_channels] + input_spatial_shape if data_format starts\nwith \"NC\". It must be one of the following types:\nhalf, bfloat16, float32, float64."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "An N+2 dimensional Tensor with the same type as input and\nshape spatial_filter_shape + [in_channels, out_channels]."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor representing the output shape of the\ndeconvolution op."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, N or N+2.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the spatial dimensions. By default\nthe N and C dimensions are set to 0. The dimension order is determined\nby the value of data_format, see below for details."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, N or N+2,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the spatial dimensions. By\ndefault the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional). If not specified \"conv_transpose\"\nis used."}]}},
{"id": "tf.nn.ctc_beam_search_decoder", "type": "function", "code": "tf.nn.ctc_beam_search_decoder(inputs,sequence_length,beam_width=100,top_paths=1)", "summary": "Performs beam search decoding on the logits given in input.", "description": "", "code-info": {"name": "tf.nn.ctc_beam_search_decoder", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "3-D float Tensor, size [max_time, batch_size, num_classes].\nThe logits."}, {"name": "sequence_length", "is_optional": false, "type": "others", "description": "1-D int32 vector containing sequence lengths, having size\n[batch_size]."}, {"name": "beam_width", "is_optional": true, "type": "int", "default_value": "100", "description": "An int scalar &gt;= 0 (beam search beam width)."}, {"name": "top_paths", "is_optional": true, "type": "int", "default_value": "1", "description": "An int scalar &gt;= 0, &lt;= beam_width (controls output size)."}]}},
{"id": "tf.nn.convolution", "type": "function", "code": "tf.nn.convolution(input,filters,strides=None,padding='VALID',data_format=None,dilations=None,name=None)", "summary": "Computes sums of N-D convolutions (actually cross-correlation).", "description": "", "code-info": {"name": "tf.nn.convolution", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An (N+2)-D Tensor of type T, of shape\n[batch_size] + input_spatial_shape + [in_channels] if data_format does\nnot start with \"NC\" (default), or\n[batch_size, in_channels] + input_spatial_shape if data_format starts\nwith \"NC\"."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "An (N+2)-D Tensor with the same type as input and shape\nspatial_filter_shape + [in_channels, out_channels].\npadding: A string, either \"VALID\" or \"SAME\". The padding algorithm."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.\nDefaults to [1]*N.  If any value of strides is &gt; 1, then all values of\ndilation_rate must be 1.\ndilations: Optional.  Sequence of N ints &gt;= 1.  Specifies the filter\nupsampling/input downsampling rate.  In the literature, the same parameter\nis sometimes called input stride or dilation.  The effective filter\nsize used for the convolution will be spatial_filter_shape +\n(spatial_filter_shape - 1) * (rate - 1), obtained by inserting\n(dilation_rate[i]-1) zeros between consecutive elements of the original\nfilter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,\nthen all values of strides must be 1.\nname: Optional name for the returned tensor.\ndata_format: A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\".\nfilters: Alias of filter.\ndilations: Alias of dilation_rate.\n\n\nReturns:\n\nA Tensor with the same type as input of shape\n`[batch_size] + output_spatial_shape + [out_channels]`\n\nif data_format is None or does not start with \"NC\", or\n`[batch_size, out_channels] + output_spatial_shape`\n\nif data_format starts with \"NC\",\nwhere output_spatial_shape depends on the value of padding.\n\nIf padding == \"SAME\":\n  output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])\n\nIf padding == \"VALID\":\n  output_spatial_shape[i] =\n    ceil((input_spatial_shape[i] -\n          (spatial_filter_shape[i]-1) * dilation_rate[i])\n         / strides[i]).\n\nRaises:\n\n\nValueError: If input/output depth does not match filters shape, if padding\nis other than \"VALID\" or \"SAME\", or if data_format is invalid.\n\n\n          "}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'VALID'", "description": "A string, either \"VALID\" or \"SAME\". The padding algorithm.\nstrides: Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.\nDefaults to [1]*N.  If any value of strides is &gt; 1, then all values of\ndilation_rate must be 1.\ndilations: Optional.  Sequence of N ints &gt;= 1.  Specifies the filter\nupsampling/input downsampling rate.  In the literature, the same parameter\nis sometimes called input stride or dilation.  The effective filter\nsize used for the convolution will be spatial_filter_shape +\n(spatial_filter_shape - 1) * (rate - 1), obtained by inserting\n(dilation_rate[i]-1) zeros between consecutive elements of the original\nfilter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,\nthen all values of strides must be 1.\nname: Optional name for the returned tensor."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\".\nfilters: Alias of filter."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Sequence of N ints &gt;= 1.  Specifies the filter\nupsampling/input downsampling rate.  In the literature, the same parameter\nis sometimes called input stride or dilation.  The effective filter\nsize used for the convolution will be spatial_filter_shape +\n(spatial_filter_shape - 1) * (rate - 1), obtained by inserting\n(dilation_rate[i]-1) zeros between consecutive elements of the original\nfilter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,\nthen all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor.\ndata_format: A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\".\nfilters: Alias of filter.\ndilations: Alias of dilation_rate."}]}},
{"id": "tf.nn.conv3d_transpose", "type": "function", "code": "tf.nn.conv3d_transpose(input,filters,output_shape,strides,padding='SAME',data_format='NDHWC',dilations=None,name=None)", "summary": "The transpose of conv3d.", "description": "", "code-info": {"name": "tf.nn.conv3d_transpose", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 5-D Tensor of type float and shape [batch, height, width,\nin_channels] for NHWC data format or [batch, in_channels, height,\nwidth] for NCHW data format."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 5-D Tensor with the same type as value and shape [height,\nwidth, output_channels, in_channels].  filter's in_channels dimension\nmust match that of value."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor representing the output shape of the\ndeconvolution op."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 3 or 5.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the D, H and W dimension. By\ndefault the N and C dimensions are set to 0. The dimension order is\ndetermined by the value of data_format, see below for details."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "A string. 'NDHWC' and 'NCDHW' are supported."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 3 or 5,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the D, H and W dimension.\nBy default the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details. Dilations in the batch and depth dimensions if a 5-d tensor\nmust be 1."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}]}},
{"id": "tf.nn.conv3d", "type": "function", "code": "tf.nn.conv3d(input,filters,strides,padding,data_format='NDHWC',dilations=None,name=None)", "summary": "Computes a 3-D convolution given 5-D input and filters tensors.", "description": "", "code-info": {"name": "tf.nn.conv3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\nShape [batch, in_depth, in_height, in_width, in_channels]."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\nShape [filter_depth, filter_height, filter_width, in_channels,\nout_channels]. in_channels must match between input and filters."}, {"name": "strides", "is_optional": false, "type": "tensor", "description": "A list of ints that has length &gt;= 5.\n1-D tensor of length 5. The stride of the sliding window for each\ndimension of input. Must have strides[0] = strides[4] = 1."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to \"NDHWC\".\nThe data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n  [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n  [batch, in_channels, in_depth, in_height, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of ints. Defaults to [1, 1, 1, 1, 1].\n1-D tensor of length 5.  The dilation factor for each dimension of\ninput. If set to k &gt; 1, there will be k-1 skipped cells between each\nfilter element on that dimension. The dimension order is determined by the\nvalue of data_format, see above for details. Dilations in the batch and\ndepth dimensions must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.conv1d_transpose", "type": "function", "code": "tf.nn.conv1d_transpose(input,filters,output_shape,strides,padding='SAME',data_format='NWC',dilations=None,name=None)", "summary": "The transpose of conv1d.", "description": "", "code-info": {"name": "tf.nn.conv1d_transpose", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 3-D Tensor of type float and shape\n[batch, in_width, in_channels] for NWC data format or\n[batch, in_channels, in_width] for NCW data format."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 3-D Tensor with the same type as value and shape\n[filter_width, output_channels, in_channels].  filter's\nin_channels dimension must match that of value."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor, containing three elements, representing the\noutput shape of the deconvolution op."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3.  The number of\nentries by which the filter is moved right at each step."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NWC'", "description": "A string. 'NWC' and 'NCW' are supported."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1 or 3 which\ndefaults to 1. The dilation factor for each dimension of input. If set to\nk &gt; 1, there will be k-1 skipped cells between each filter element on that\ndimension. Dilations in the batch and depth dimensions must be 1."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}]}},
{"id": "tf.nn.conv1d", "type": "function", "code": "tf.nn.conv1d(input,filters,stride,padding,data_format='NWC',dilations=None,name=None)", "summary": "Computes a 1-D convolution given 3-D input and filter tensors.", "description": "", "code-info": {"name": "tf.nn.conv1d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 3D Tensor.  Must be of type float16, float32, or float64."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 3D Tensor.  Must have the same type as input."}, {"name": "stride", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3.  The number of\nentries by which the filter is moved right at each step."}, {"name": "padding", "is_optional": false, "type": "others", "description": "'SAME' or 'VALID'"}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NWC'", "description": "An optional string from \"NWC\", \"NCW\".  Defaults to \"NWC\",\nthe data is stored in the order of [batch, in_width, in_channels].  The\n\"NCW\" format stores data as [batch, in_channels, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1 or 3 which\ndefaults to 1. The dilation factor for each dimension of input. If set to\nk &gt; 1, there will be k-1 skipped cells between each filter element on that\ndimension. Dilations in the batch and depth dimensions must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.compute_average_loss", "type": "function", "code": "tf.nn.compute_average_loss(per_example_loss,sample_weight=None,global_batch_size=None)", "summary": "Scales per-example losses with sample_weights and computes their average.", "description": "", "code-info": {"name": "tf.nn.compute_average_loss", "parameters": [{"name": "per_example_loss", "is_optional": false, "type": "others", "description": "Per-example loss."}, {"name": "sample_weight", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional weighting for each example."}, {"name": "global_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional global batch size value. Defaults to (size of\nfirst dimension of losses) * (number of replicas)."}]}},
{"id": "tf.nn.compute_accidental_hits", "type": "function", "code": "tf.nn.compute_accidental_hits(true_classes,sampled_candidates,num_true,seed=None,name=None)", "summary": "Compute the position ids in sampled_candidates matching true_classes.", "description": "", "code-info": {"name": "tf.nn.compute_accidental_hits", "parameters": [{"name": "true_classes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "sampled_candidates", "is_optional": false, "type": "tensor", "description": "A tensor of type int64 and shape [num_sampled].\nThe sampled_candidates output of CandidateSampler."}, {"name": "num_true", "is_optional": false, "type": "others", "description": "An int.  The number of target classes per training example."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. An operation-specific seed. Default is 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.collapse_repeated", "type": "function", "code": "tf.nn.collapse_repeated(labels,seq_length,name=None)", "summary": "Merge repeated labels into single labels.", "description": "", "code-info": {"name": "tf.nn.collapse_repeated", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "Tensor of shape [batch, max value in seq_length]"}, {"name": "seq_length", "is_optional": false, "type": "tensor", "description": "Tensor of shape [batch], sequence length of each batch element."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this Op. Defaults to \"collapse_repeated_labels\"."}]}},
{"id": "tf.nn.bias_add", "type": "function", "code": "tf.nn.bias_add(value,bias,data_format=None,name=None)", "summary": "Adds bias to value.", "description": "", "code-info": {"name": "tf.nn.bias_add", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor with type float, double, int64, int32, uint8,\nint16, int8, complex64, or complex128."}, {"name": "bias", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with size matching the channel dimension of value.\nMust be the same type as value unless value is a quantized type,\nin which case a different quantized type may be used."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. 'N...C' and 'NC...' are supported. If None (the\ndefault) is specified then 'N..C' is assumed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.conv2d_transpose", "type": "function", "code": "tf.nn.conv2d_transpose(input,filters,output_shape,strides,padding='SAME',data_format='NHWC',dilations=None,name=None)", "summary": "The transpose of conv2d.", "description": "", "code-info": {"name": "tf.nn.conv2d_transpose", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of type float and shape [batch, height, width,\nin_channels] for NHWC data format or [batch, in_channels, height,\nwidth] for NCHW data format."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor with the same type as input and shape [height,\nwidth, output_channels, in_channels].  filter's in_channels dimension\nmust match that of input."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor representing the output shape of the\ndeconvolution op."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the H and W dimension. By default\nthe N and C dimensions are set to 0. The dimension order is determined\nby the value of data_format, see below for details."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC' and 'NCHW' are supported."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 2 or 4,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the H and W dimension. By\ndefault the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details. Dilations in the batch and depth dimensions if a 4-d tensor\nmust be 1."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}]}},
{"id": "tf.nn.conv2d", "type": "function", "code": "tf.nn.conv2d(input,filters,strides,padding,data_format='NHWC',dilations=None,name=None)", "summary": "Computes a 2-D convolution given 4-D input and filters tensors.", "description": "", "code-info": {"name": "tf.nn.conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types:\nhalf, bfloat16, float32, float64.\nA 4-D tensor. The dimension order is interpreted according to the value\nof data_format, see below for details."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\nA 4-D tensor of shape\n[filter_height, filter_width, in_channels, out_channels]"}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the H and W dimension. By default\nthe N and C dimensions are set to 1. The dimension order is determined\nby the value of data_format, see below for details."}, {"name": "padding", "is_optional": false, "type": "string", "description": "Either the string \"SAME\" or \"VALID\" indicating the type of\npadding algorithm to use, or a list indicating the explicit paddings at\nthe start and end of each dimension. When explicit padding is used and\ndata_format is \"NHWC\", this should be in the form [[0, 0], [pad_top,\npad_bottom], [pad_left, pad_right], [0, 0]]. When explicit padding used\nand data_format is \"NCHW\", this should be in the form [[0, 0], [0, 0],\n[pad_top, pad_bottom], [pad_left, pad_right]]."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\".\nDefaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, channels, height, width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 2 or 4,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the H and W dimension. By\ndefault the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details. Dilations in the batch and depth dimensions if a 4-d tensor\nmust be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.batch_norm_with_global_normalization", "type": "function", "code": "tf.nn.batch_norm_with_global_normalization(input,mean,variance,beta,gamma,variance_epsilon,scale_after_normalization,name=None)", "summary": "Batch normalization.", "description": "", "code-info": {"name": "tf.nn.batch_norm_with_global_normalization", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 4D input Tensor."}, {"name": "mean", "is_optional": false, "type": "tensor", "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."}, {"name": "variance", "is_optional": false, "type": "tensor", "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."}, {"name": "beta", "is_optional": false, "type": "tensor", "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor."}, {"name": "gamma", "is_optional": false, "type": "tensor", "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor."}, {"name": "variance_epsilon", "is_optional": false, "type": "float", "description": "A small float number to avoid dividing by 0."}, {"name": "scale_after_normalization", "is_optional": false, "type": "tensor", "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.batch_normalization", "type": "function", "code": "tf.nn.batch_normalization(x,mean,variance,offset,scale,variance_epsilon,name=None)", "summary": "Batch normalization.", "description": "", "code-info": {"name": "tf.nn.batch_normalization", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input Tensor of arbitrary dimensionality."}, {"name": "mean", "is_optional": false, "type": "tensor", "description": "A mean Tensor."}, {"name": "variance", "is_optional": false, "type": "tensor", "description": "A variance Tensor."}, {"name": "offset", "is_optional": false, "type": "tensor", "description": "An offset Tensor, often denoted \\(\\beta\\) in equations, or\nNone. If present, will be added to the normalized tensor."}, {"name": "scale", "is_optional": false, "type": "tensor", "description": "A scale Tensor, often denoted \\(\\gamma\\) in equations, or\nNone. If present, the scale is applied to the normalized tensor."}, {"name": "variance_epsilon", "is_optional": false, "type": "float", "description": "A small float number to avoid dividing by 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.nn.avg_pool3d", "type": "function", "code": "tf.nn.avg_pool3d(input,ksize,strides,padding,data_format='NDHWC',name=None)", "summary": "Performs the average pooling on the input.", "description": "", "code-info": {"name": "tf.nn.avg_pool3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 5-D Tensor of shape [batch, height, width, channels] and type\nfloat32, float64, qint8, quint8, or qint32."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 3 or 5. The size of\nthe window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 3 or 5. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "A string. 'NDHWC' and 'NCDHW' are supported."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.nn.avg_pool2d", "type": "function", "code": "tf.nn.avg_pool2d(input,ksize,strides,padding,data_format='NHWC',name=None)", "summary": "Performs the average pooling on the input.", "description": "", "code-info": {"name": "tf.nn.avg_pool2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of shape [batch, height, width, channels] and type\nfloat32, float64, qint8, quint8, or qint32."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The size of\nthe window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC' and 'NCHW' are supported."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.nn.avg_pool1d", "type": "function", "code": "tf.nn.avg_pool1d(input,ksize,strides,padding,data_format='NWC',name=None)", "summary": "Performs the average pooling on the input.", "description": "", "code-info": {"name": "tf.nn.avg_pool1d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A 3-D Tensor of the format specified by data_format."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3. The size of the\nwindow for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1 or 3. The stride of\nthe sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NWC'", "description": "An optional string from: \"NWC\", \"NCW\". Defaults to \"NWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.nn.avg_pool", "type": "function", "code": "tf.nn.avg_pool(input,ksize,strides,padding,data_format=None,name=None)", "summary": "Performs the avg pooling on the input.", "description": "", "code-info": {"name": "tf.nn.avg_pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": " Tensor of rank N+2, of shape [batch_size] + input_spatial_shape +\n[num_channels] if data_format does not start with \"NC\" (default), or\n[batch_size, num_channels] + input_spatial_shape if data_format starts\nwith \"NC\". Pooling happens over the spatial dimensions only."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, N or N+2. The size\nof the window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, N or N+2. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm. See\nthe \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Specifies the channel dimension. For N=1 it can be\neither \"NWC\" (default) or \"NCW\", for N=2 it can be either \"NHWC\" (default)\nor \"NCHW\" and for N=3 either \"NDHWC\" (default) or \"NCDHW\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.nn.atrous_conv2d_transpose", "type": "function", "code": "tf.nn.atrous_conv2d_transpose(value,filters,output_shape,rate,padding,name=None)", "summary": "The transpose of atrous_conv2d.", "description": "", "code-info": {"name": "tf.nn.atrous_conv2d_transpose", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of type float. It needs to be in the default NHWC\nformat. Its shape is [batch, in_height, in_width, in_channels]."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor with the same type as value and shape\n[filter_height, filter_width, out_channels, in_channels]. filters'\nin_channels dimension must match that of value. Atrous convolution is\nequivalent to standard convolution with upsampled filters with effective\nheight filter_height + (filter_height - 1) * (rate - 1) and effective\nwidth filter_width + (filter_width - 1) * (rate - 1), produced by\ninserting rate - 1 zeros along consecutive elements across the\nfilters' spatial dimensions."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor of shape representing the output shape of the\ndeconvolution op."}, {"name": "rate", "is_optional": false, "type": "string", "description": "A positive int32. The stride with which we sample input values across\nthe height and width dimensions. Equivalently, the rate by which we\nupsample the filter values by inserting zeros across the height and\nwidth dimensions. In the literature, the same parameter is sometimes\ncalled input stride or dilation."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}]}},
{"id": "tf.nn.atrous_conv2d", "type": "function", "code": "tf.nn.atrous_conv2d(value,filters,rate,padding,name=None)", "summary": "Atrous convolution (a.k.a. convolution with holes or dilated convolution).", "description": "", "code-info": {"name": "tf.nn.atrous_conv2d", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of type float. It needs to be in the default \"NHWC\"\nformat. Its shape is [batch, in_height, in_width, in_channels]."}, {"name": "filters", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor with the same type as value and shape\n[filter_height, filter_width, in_channels, out_channels]. filters'\nin_channels dimension must match that of value. Atrous convolution is\nequivalent to standard convolution with upsampled filters with effective\nheight filter_height + (filter_height - 1) * (rate - 1) and effective\nwidth filter_width + (filter_width - 1) * (rate - 1), produced by\ninserting rate - 1 zeros along consecutive elements across the\nfilters' spatial dimensions."}, {"name": "rate", "is_optional": false, "type": "string", "description": "A positive int32. The stride with which we sample input values across\nthe height and width dimensions. Equivalently, the rate by which we\nupsample the filter values by inserting zeros across the height and\nwidth dimensions. In the literature, the same parameter is sometimes\ncalled input stride or dilation."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}]}},
{"id": "tf.nest.assert_same_structure", "type": "function", "code": "tf.nest.assert_same_structure(nest1,nest2,check_types=True,expand_composites=False)", "summary": "Asserts that two structures are nested in the same way.", "description": "", "code-info": {"name": "tf.nest.assert_same_structure", "parameters": [{"name": "nest1", "is_optional": false, "type": "string", "description": "an arbitrarily nested structure."}, {"name": "nest2", "is_optional": false, "type": "string", "description": "an arbitrarily nested structure."}, {"name": "check_types", "is_optional": true, "type": "bool", "default_value": "True", "description": "if True (default) types of sequences are checked as well,\nincluding the keys of dictionaries. If set to False, for example a\nlist and a tuple of objects will look the same if they have the same\nsize. Note that namedtuples with identical name and fields are always\nconsidered to have the same shallow structure. Two types will also be\nconsidered the same if they are both list subtypes (which allows \"list\"\nand \"_ListWrapper\" from trackable dependency tracking to compare\nequal)."}, {"name": "expand_composites", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, then composite tensors such as tf.SparseTensor\nand tf.RaggedTensor are expanded into their component tensors."}]}},
{"id": "tf.nest.is_nested", "type": "function", "code": "tf.nest.is_nested(seq)", "summary": "Returns true if its input is a collections.abc.Sequence (except strings).", "description": "", "code-info": {"name": "tf.nest.is_nested", "parameters": [{"name": "seq", "is_optional": false, "type": "others", "description": "an input sequence."}]}},
{"id": "tf.nest.pack_sequence_as", "type": "function", "code": "tf.nest.pack_sequence_as(structure,flat_sequence,expand_composites=False)", "summary": "Returns a given flattened sequence packed into a given structure.", "description": "", "code-info": {"name": "tf.nest.pack_sequence_as", "parameters": [{"name": "structure", "is_optional": false, "type": "string", "description": "Nested structure, whose structure is given by nested lists,\ntuples, and dicts. Note: numpy arrays and strings are considered\nscalars."}, {"name": "flat_sequence", "is_optional": false, "type": "others", "description": "flat sequence to pack."}, {"name": "expand_composites", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, then composite tensors such as tf.SparseTensor\nand tf.RaggedTensor are expanded into their component tensors."}]}},
{"id": "tf.nest.map_structure", "type": "function", "code": "tf.nest.map_structure(func,*structure,**kwargs)", "summary": "Applies func to each entry in structure and returns a new structure.", "description": "", "code-info": {"name": "tf.nest.map_structure", "parameters": [{"name": "func", "is_optional": false, "type": "others", "description": "A callable that accepts as many arguments as there are structures."}, {"name": "*structure", "is_optional": false, "type": "float", "description": "scalar, or tuple or list of constructed scalars and/or other\ntuples/lists, or scalars.  Note: numpy arrays are considered as scalars."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Valid keyword args are:"}]}},
{"id": "tf.mlir.experimental.convert_graph_def", "type": "function", "code": "tf.mlir.experimental.convert_graph_def(graph_def,pass_pipeline='tf-standard-pipeline')", "summary": "Import a GraphDef and convert it to a textual MLIR module.", "description": "", "code-info": {"name": "tf.mlir.experimental.convert_graph_def", "parameters": [{"name": "graph_def", "is_optional": false, "type": "others", "description": "An object of type graph_pb2.GraphDef or a textual proto\nrepresentation of a valid GraphDef."}, {"name": "pass_pipeline", "is_optional": true, "type": "string", "default_value": "'tf-standard-pipeline'", "description": "A textual description of an MLIR Pass Pipeline to run on the\nmodule, see MLIR documentation for the\ntextual pass pipeline syntax."}]}},
{"id": "tf.mixed_precision.experimental.FixedLossScale", "type": "function", "code": "tf.mixed_precision.experimental.FixedLossScale(loss_scale_value)", "summary": "Loss scale with a fixed value.\n\nInherits From: LossScale", "description": "", "code-info": {"name": "tf.mixed_precision.experimental.FixedLossScale", "parameters": [{"name": "loss_scale_value", "is_optional": false, "type": "float", "description": "A Python float. Its ideal value varies depending on\nmodels to run. Choosing a too small loss_scale might affect model\nquality; a too big loss_scale might cause inf or nan. There is no single\nright loss_scale to apply. There is no harm choosing a relatively big\nnumber as long as no nan or inf is encountered in training."}]}},
{"id": "tf.nest.flatten", "type": "function", "code": "tf.nest.flatten(structure,expand_composites=False)", "summary": "Returns a flat list from a given nested structure.", "description": "", "code-info": {"name": "tf.nest.flatten", "parameters": [{"name": "structure", "is_optional": false, "type": "float", "description": "an arbitrarily nested structure or a scalar object. Note, numpy\narrays are considered scalars."}, {"name": "expand_composites", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, then composite tensors such as tf.SparseTensor\nand tf.RaggedTensor are expanded into their component tensors."}]}},
{"id": "tf.mixed_precision.experimental.LossScale", "type": "function", "code": "tf.mixed_precision.experimental.LossScale()", "summary": "Loss scale base class.", "description": "", "code-info": {"name": "tf.mixed_precision.experimental.LossScale", "parameters": []}},
{"id": "tf.math.zeta", "type": "function", "code": "tf.math.zeta(x,q,name=None)", "summary": "Compute the Hurwitz zeta function \\(\\zeta(x, q)\\).", "description": "", "code-info": {"name": "tf.math.zeta", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "q", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.mixed_precision.experimental.DynamicLossScale", "type": "class", "code": "tf.mixed_precision.experimental.DynamicLossScale(initial_loss_scale=(2**15),increment_period=2000,multiplier=2.0)", "summary": "Loss scale that dynamically adjusts itself.\n\nInherits From: LossScale", "description": "", "code-info": {"name": "tf.mixed_precision.experimental.DynamicLossScale", "parameters": [{"name": "initial_loss_scale", "is_optional": false, "type": "float", "description": "A Python float.  The loss scale to use at the\nbeginning. It's better to start this at a very high number, because a\nloss scale that is too high gets lowered far more quickly than a loss\nscale that is too low gets raised. The default is 2 ** 15, which is\napproximately half the maximum float16 value.\nincrement_period: Increases loss scale every increment_period\nconsecutive steps that finite gradients are encountered. If a nonfinite\ngradient is encountered, the count is reset back to zero.\nmultiplier: The multiplier to use when increasing or decreasing the loss\nscale."}]}},
{"id": "tf.math.zero_fraction", "type": "function", "code": "tf.math.zero_fraction(value,name=None)", "summary": "Returns the fraction of zeros in value.", "description": "", "code-info": {"name": "tf.math.zero_fraction", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A tensor of numeric type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.xlogy", "type": "function", "code": "tf.math.xlogy(x,y,name=None)", "summary": "Returns 0 if x == 0, and x * log(y) otherwise, elementwise.", "description": "", "code-info": {"name": "tf.math.xlogy", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, float32, float64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_sum", "type": "function", "code": "tf.math.unsorted_segment_sum(data,segment_ids,num_segments,name=None)", "summary": "Computes the sum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.unsorted_segment_sum", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.xdivy", "type": "function", "code": "tf.math.xdivy(x,y,name=None)", "summary": "Returns 0 if x == 0, and x / y otherwise, elementwise.", "description": "", "code-info": {"name": "tf.math.xdivy", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, float32, float64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_sqrt_n", "type": "function", "code": "tf.math.unsorted_segment_sqrt_n(data,segment_ids,num_segments,name=None)", "summary": "Computes the sum along segments of a tensor divided by the sqrt(N).", "description": "", "code-info": {"name": "tf.math.unsorted_segment_sqrt_n", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with floating point or complex dtype."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "An integer tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor.  The number of distinct segment\nIDs."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_prod", "type": "function", "code": "tf.math.unsorted_segment_prod(data,segment_ids,num_segments,name=None)", "summary": "Computes the product along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.unsorted_segment_prod", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_max", "type": "function", "code": "tf.math.unsorted_segment_max(data,segment_ids,num_segments,name=None)", "summary": "Computes the maximum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.unsorted_segment_max", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.truediv", "type": "function", "code": "tf.math.truediv(x,y,name=None)", "summary": "Divides x / y elementwise (using Python 3 division operator semantics).", "description": "", "code-info": {"name": "tf.math.truediv", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor numerator of numeric type."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor denominator of numeric type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.tan", "type": "function", "code": "tf.math.tan(x,name=None)", "summary": "Computes tan of x element-wise.", "description": "", "code-info": {"name": "tf.math.tan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_min", "type": "function", "code": "tf.math.unsorted_segment_min(data,segment_ids,num_segments,name=None)", "summary": "Computes the minimum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.unsorted_segment_min", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.subtract", "type": "function", "code": "tf.math.subtract(x,y,name=None)", "summary": "Returns x - y element-wise.", "description": "", "code-info": {"name": "tf.math.subtract", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.tanh", "type": "function", "code": "tf.math.tanh(x,name=None)", "summary": "Computes hyperbolic tangent of x element-wise.", "description": "", "code-info": {"name": "tf.math.tanh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.unsorted_segment_mean", "type": "function", "code": "tf.math.unsorted_segment_mean(data,segment_ids,num_segments,name=None)", "summary": "Computes the mean along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.unsorted_segment_mean", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with floating point or complex dtype."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "An integer tensor whose shape is a prefix of data.shape."}, {"name": "num_segments", "is_optional": false, "type": "tensor", "description": "An integer scalar Tensor.  The number of distinct segment\nIDs."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.top_k", "type": "function", "code": "tf.math.top_k(input,k=1,sorted=True,name=None)", "summary": "Finds values and indices of the k largest entries for the last dimension.", "description": "", "code-info": {"name": "tf.math.top_k", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "1-D or higher Tensor with last dimension at least k."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "1", "description": "0-D int32 Tensor.  Number of top elements to look for along the last\ndimension (along each row for matrices)."}, {"name": "sorted", "is_optional": true, "type": "bool", "default_value": "True", "description": "If true the resulting k elements will be sorted by the values in\ndescending order."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.math.sqrt", "type": "function", "code": "tf.math.sqrt(x,name=None)", "summary": "Computes square root of x element-wise.", "description": "", "code-info": {"name": "tf.math.sqrt", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.squared_difference", "type": "function", "code": "tf.math.squared_difference(x,y,name=None)", "summary": "Returns (x - y)(x - y) element-wise.", "description": "", "code-info": {"name": "tf.math.squared_difference", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.square", "type": "function", "code": "tf.math.square(x,name=None)", "summary": "Computes square of x element-wise.", "description": "", "code-info": {"name": "tf.math.square", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.sign", "type": "function", "code": "tf.math.sign(x,name=None)", "summary": "Returns an element-wise indication of the sign of a number.", "description": "", "code-info": {"name": "tf.math.sign", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.sinh", "type": "function", "code": "tf.math.sinh(x,name=None)", "summary": "Computes hyperbolic sine of x element-wise.", "description": "", "code-info": {"name": "tf.math.sinh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.softplus", "type": "function", "code": "tf.math.softplus(features,name=None)", "summary": "Computes softplus: log(exp(features) + 1).", "description": "", "code-info": {"name": "tf.math.softplus", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.sin", "type": "function", "code": "tf.math.sin(x,name=None)", "summary": "Computes sine of x element-wise.", "description": "", "code-info": {"name": "tf.math.sin", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.sigmoid", "type": "function", "code": "tf.math.sigmoid(x,name=None)", "summary": "Computes sigmoid of x element-wise.", "description": "", "code-info": {"name": "tf.math.sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor with type float16, float32, float64, complex64, or\ncomplex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.segment_min", "type": "function", "code": "tf.math.segment_min(data,segment_ids,name=None)", "summary": "Computes the minimum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.segment_min", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA 1-D tensor whose size is equal to the size of data's\nfirst dimension.  Values should be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.segment_sum", "type": "function", "code": "tf.math.segment_sum(data,segment_ids,name=None)", "summary": "Computes the sum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.segment_sum", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA 1-D tensor whose size is equal to the size of data's\nfirst dimension.  Values should be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.segment_prod", "type": "function", "code": "tf.math.segment_prod(data,segment_ids,name=None)", "summary": "Computes the product along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.segment_prod", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA 1-D tensor whose size is equal to the size of data's\nfirst dimension.  Values should be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.segment_mean", "type": "function", "code": "tf.math.segment_mean(data,segment_ids,name=None)", "summary": "Computes the mean along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.segment_mean", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA 1-D tensor whose size is equal to the size of data's\nfirst dimension.  Values should be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.rint", "type": "function", "code": "tf.math.rint(x,name=None)", "summary": "Returns element-wise integer closest to x.", "description": "", "code-info": {"name": "tf.math.rint", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.segment_max", "type": "function", "code": "tf.math.segment_max(data,segment_ids,name=None)", "summary": "Computes the maximum along segments of a tensor.", "description": "", "code-info": {"name": "tf.math.segment_max", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA 1-D tensor whose size is equal to the size of data's\nfirst dimension.  Values should be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.scalar_mul", "type": "function", "code": "tf.math.scalar_mul(scalar,x,name=None)", "summary": "Multiplies a scalar times a Tensor or IndexedSlices object.", "description": "", "code-info": {"name": "tf.math.scalar_mul", "parameters": [{"name": "scalar", "is_optional": false, "type": "tensor", "description": "A 0-D scalar Tensor. Must have known shape."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or IndexedSlices to be scaled."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.round", "type": "function", "code": "tf.math.round(x,name=None)", "summary": "Rounds the values of a tensor to the nearest integer, element-wise.", "description": "", "code-info": {"name": "tf.math.round", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type float16, float32, float64, int32, or int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_variance", "type": "function", "code": "tf.math.reduce_variance(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the variance of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_variance", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name scope for the associated operations (optional)."}]}},
{"id": "tf.math.reduce_min", "type": "function", "code": "tf.math.reduce_min(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the minimum of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_min", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have real numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_mean", "type": "function", "code": "tf.math.reduce_mean(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the mean of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_mean", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.rsqrt", "type": "function", "code": "tf.math.rsqrt(x,name=None)", "summary": "Computes reciprocal of square root of x element-wise.", "description": "", "code-info": {"name": "tf.math.rsqrt", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_std", "type": "function", "code": "tf.math.reduce_std(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the standard deviation of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_std", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name scope for the associated operations (optional)."}]}},
{"id": "tf.math.reduce_max", "type": "function", "code": "tf.math.reduce_max(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the maximum of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_max", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have real numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_sum", "type": "function", "code": "tf.math.reduce_sum(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the sum of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_sum", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_prod", "type": "function", "code": "tf.math.reduce_prod(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the product of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_prod", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_logsumexp", "type": "function", "code": "tf.math.reduce_logsumexp(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes log(sum(exp(elements across dimensions of a tensor))).", "description": "", "code-info": {"name": "tf.math.reduce_logsumexp", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_euclidean_norm", "type": "function", "code": "tf.math.reduce_euclidean_norm(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the Euclidean norm of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_euclidean_norm", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reduce_any", "type": "function", "code": "tf.math.reduce_any(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the \"logical or\" of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.reduce_any", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The boolean tensor to reduce."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reciprocal_no_nan", "type": "function", "code": "tf.math.reciprocal_no_nan(x,name=None)", "summary": "Performs a safe reciprocal operation, element wise.", "description": "", "code-info": {"name": "tf.math.reciprocal_no_nan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type float16, float32, float64 complex64 or\ncomplex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.reciprocal", "type": "function", "code": "tf.math.reciprocal(x,name=None)", "summary": "Computes the reciprocal of x element-wise.", "description": "", "code-info": {"name": "tf.math.reciprocal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.real", "type": "function", "code": "tf.math.real(input,name=None)", "summary": "Returns the real part of a complex (or real) tensor.", "description": "", "code-info": {"name": "tf.math.real", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have numeric type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.pow", "type": "function", "code": "tf.math.pow(x,y,name=None)", "summary": "Computes the power of one value to another.", "description": "", "code-info": {"name": "tf.math.pow", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type float16, float32, float64, int32, int64,\ncomplex64, or complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor of type float16, float32, float64, int32, int64,\ncomplex64, or complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.polyval", "type": "function", "code": "tf.math.polyval(coeffs,x,name=None)", "summary": "Computes the elementwise value of a polynomial.", "description": "", "code-info": {"name": "tf.math.polyval", "parameters": [{"name": "coeffs", "is_optional": false, "type": "tensor", "description": "A list of Tensor representing the coefficients of the polynomial."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor representing the variable of the polynomial."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.polygamma", "type": "function", "code": "tf.math.polygamma(a,x,name=None)", "summary": "Compute the polygamma function \\(\\psi^{(n)}(x)\\).", "description": "", "code-info": {"name": "tf.math.polygamma", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.multiply", "type": "function", "code": "tf.math.multiply(x,y,name=None)", "summary": "Returns x * y element-wise.", "description": "", "code-info": {"name": "tf.math.multiply", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.ndtri", "type": "function", "code": "tf.math.ndtri(x,name=None)", "summary": "Compute quantile of Standard Normal.", "description": "", "code-info": {"name": "tf.math.ndtri", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor with type float or double."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.multiply_no_nan", "type": "function", "code": "tf.math.multiply_no_nan(x,y,name=None)", "summary": "Computes the product of x and y and returns 0 if the y is zero, even if x is NaN or infinite.", "description": "", "code-info": {"name": "tf.math.multiply_no_nan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor whose dtype is compatible with x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.minimum", "type": "function", "code": "tf.math.minimum(x,y,name=None)", "summary": "Returns the min of x and y (i.e. x &lt; y ? x : y) element-wise.", "description": "", "code-info": {"name": "tf.math.minimum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.not_equal", "type": "function", "code": "tf.math.not_equal(x,y,name=None)", "summary": "Returns the truth value of (x != y) element-wise.", "description": "", "code-info": {"name": "tf.math.not_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tf.Tensor or tf.SparseTensor or tf.IndexedSlices."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A tf.Tensor or tf.SparseTensor or tf.IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.nextafter", "type": "function", "code": "tf.math.nextafter(x1,x2,name=None)", "summary": "Returns the next representable value of x1 in the direction of x2, element-wise.", "description": "", "code-info": {"name": "tf.math.nextafter", "parameters": [{"name": "x1", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32."}, {"name": "x2", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.negative", "type": "function", "code": "tf.math.negative(x,name=None)", "summary": "Computes numerical negative value element-wise.", "description": "", "code-info": {"name": "tf.math.negative", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.maximum", "type": "function", "code": "tf.math.maximum(x,y,name=None)", "summary": "Returns the max of x and y (i.e. x &gt; y ? x : y) element-wise.", "description": "", "code-info": {"name": "tf.math.maximum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.logical_and", "type": "function", "code": "tf.math.logical_and(x,y,name=None)", "summary": "Returns the truth value of x AND y element-wise.", "description": "", "code-info": {"name": "tf.math.logical_and", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.log", "type": "function", "code": "tf.math.log(x,name=None)", "summary": "Computes natural logarithm of x element-wise.", "description": "", "code-info": {"name": "tf.math.log", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.log1p", "type": "function", "code": "tf.math.log1p(x,name=None)", "summary": "Computes natural logarithm of (1 + x) element-wise.", "description": "", "code-info": {"name": "tf.math.log1p", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.lgamma", "type": "function", "code": "tf.math.lgamma(x,name=None)", "summary": "Computes the log of the absolute value of Gamma(x) element-wise.", "description": "", "code-info": {"name": "tf.math.lgamma", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.less_equal", "type": "function", "code": "tf.math.less_equal(x,y,name=None)", "summary": "Returns the truth value of (x &lt;= y) element-wise.", "description": "", "code-info": {"name": "tf.math.less_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.less", "type": "function", "code": "tf.math.less(x,y,name=None)", "summary": "Returns the truth value of (x &lt; y) element-wise.", "description": "", "code-info": {"name": "tf.math.less", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.logical_xor", "type": "function", "code": "tf.math.logical_xor(x,y,name='LogicalXor')", "summary": "Logical XOR function.", "description": "", "code-info": {"name": "tf.math.logical_xor", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor type bool."}, {"name": "y", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LogicalXor'", "description": ""}]}},
{"id": "tf.math.logical_or", "type": "function", "code": "tf.math.logical_or(x,y,name=None)", "summary": "Returns the truth value of x OR y element-wise.", "description": "", "code-info": {"name": "tf.math.logical_or", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.log_sigmoid", "type": "function", "code": "tf.math.log_sigmoid(x,name=None)", "summary": "Computes log sigmoid of x element-wise.", "description": "", "code-info": {"name": "tf.math.log_sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor with type float32 or float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.logical_not", "type": "function", "code": "tf.math.logical_not(x,name=None)", "summary": "Returns the truth value of NOT x element-wise.", "description": "", "code-info": {"name": "tf.math.logical_not", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.lbeta", "type": "function", "code": "tf.math.lbeta(x,name=None)", "summary": "Computes \\(ln(|Beta(x)|)\\), reducing along the last dimension.", "description": "", "code-info": {"name": "tf.math.lbeta", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A rank n + 1 Tensor, n &gt;= 0 with type float, or double."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.l2_normalize", "type": "function", "code": "tf.math.l2_normalize(x,axis=None,epsilon=1e-12,name=None)", "summary": "Normalizes along dimension axis using an L2 norm.", "description": "", "code-info": {"name": "tf.math.l2_normalize", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "Dimension along which to normalize.  A scalar or a vector of\nintegers."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-12", "description": "A lower bound value for the norm. Will use sqrt(epsilon) as the\ndivisor if norm &lt; sqrt(epsilon)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.math.is_strictly_increasing", "type": "function", "code": "tf.math.is_strictly_increasing(x,name=None)", "summary": "Returns True if x is strictly increasing.", "description": "", "code-info": {"name": "tf.math.is_strictly_increasing", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Numeric Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).\nDefaults to \"is_strictly_increasing\""}]}},
{"id": "tf.math.is_non_decreasing", "type": "function", "code": "tf.math.is_non_decreasing(x,name=None)", "summary": "Returns True if x is non-decreasing.", "description": "", "code-info": {"name": "tf.math.is_non_decreasing", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Numeric Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"is_non_decreasing\""}]}},
{"id": "tf.math.igammac", "type": "function", "code": "tf.math.igammac(a,x,name=None)", "summary": "Compute the upper regularized incomplete Gamma function Q(a, x).", "description": "", "code-info": {"name": "tf.math.igammac", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.is_inf", "type": "function", "code": "tf.math.is_inf(x,name=None)", "summary": "Returns which elements of x are Inf.", "description": "", "code-info": {"name": "tf.math.is_inf", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.is_finite", "type": "function", "code": "tf.math.is_finite(x,name=None)", "summary": "Returns which elements of x are finite.", "description": "", "code-info": {"name": "tf.math.is_finite", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.imag", "type": "function", "code": "tf.math.imag(input,name=None)", "summary": "Returns the imaginary part of a complex (or real) tensor.", "description": "", "code-info": {"name": "tf.math.imag", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float, double,\ncomplex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.is_nan", "type": "function", "code": "tf.math.is_nan(x,name=None)", "summary": "Returns which elements of x are NaN.", "description": "", "code-info": {"name": "tf.math.is_nan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.greater_equal", "type": "function", "code": "tf.math.greater_equal(x,y,name=None)", "summary": "Returns the truth value of (x &gt;= y) element-wise.", "description": "", "code-info": {"name": "tf.math.greater_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.invert_permutation", "type": "function", "code": "tf.math.invert_permutation(x,name=None)", "summary": "Computes the inverse permutation of a tensor.", "description": "", "code-info": {"name": "tf.math.invert_permutation", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. 1-D."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.igamma", "type": "function", "code": "tf.math.igamma(a,x,name=None)", "summary": "Compute the lower regularized incomplete Gamma function P(a, x).", "description": "", "code-info": {"name": "tf.math.igamma", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.greater", "type": "function", "code": "tf.math.greater(x,y,name=None)", "summary": "Returns the truth value of (x &gt; y) element-wise.", "description": "", "code-info": {"name": "tf.math.greater", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.in_top_k", "type": "function", "code": "tf.math.in_top_k(targets,predictions,k,name=None)", "summary": "Says whether the targets are in the top K predictions.", "description": "", "code-info": {"name": "tf.math.in_top_k", "parameters": [{"name": "targets", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA batch_size vector of class ids.\nk: An int. Number of top elements to look at for computing precision.\nname: A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type bool. Computed Precision at k as a bool Tensor.\n\n          "}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nA batch_size x classes tensor.\ntargets: A Tensor. Must be one of the following types: int32, int64.\nA batch_size vector of class ids."}, {"name": "k", "is_optional": false, "type": "others", "description": "An int. Number of top elements to look at for computing precision."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.floordiv", "type": "function", "code": "tf.math.floordiv(x,y,name=None)", "summary": "Divides x / y elementwise, rounding toward the most negative integer.", "description": "", "code-info": {"name": "tf.math.floordiv", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor numerator of real numeric type."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor denominator of real numeric type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.floor", "type": "function", "code": "tf.math.floor(x,name=None)", "summary": "Returns element-wise largest integer not greater than x.", "description": "", "code-info": {"name": "tf.math.floor", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.floormod", "type": "function", "code": "tf.math.floormod(x,y,name=None)", "summary": "Returns element-wise remainder of division. When x &lt; 0 xor y &lt; 0 is", "description": "", "code-info": {"name": "tf.math.floormod", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64, bfloat16, half, float32, float64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.exp", "type": "function", "code": "tf.math.exp(x,name=None)", "summary": "Computes exponential of x element-wise.  \\(y = e^x\\).", "description": "", "code-info": {"name": "tf.math.exp", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.erfc", "type": "function", "code": "tf.math.erfc(x,name=None)", "summary": "Computes the complementary error function of x element-wise.", "description": "", "code-info": {"name": "tf.math.erfc", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.expm1", "type": "function", "code": "tf.math.expm1(x,name=None)", "summary": "Computes exp(x) - 1 element-wise.", "description": "", "code-info": {"name": "tf.math.expm1", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.erfinv", "type": "function", "code": "tf.math.erfinv(x,name=None)", "summary": "Compute inverse error function.", "description": "", "code-info": {"name": "tf.math.erfinv", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor with type float or double."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.divide_no_nan", "type": "function", "code": "tf.math.divide_no_nan(x,y,name=None)", "summary": "Computes a safe divide which returns 0 if the y is zero.", "description": "", "code-info": {"name": "tf.math.divide_no_nan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor whose dtype is compatible with x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.divide", "type": "function", "code": "tf.math.divide(x,y,name=None)", "summary": "Computes Python style division of x by y.", "description": "", "code-info": {"name": "tf.math.divide", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": "y", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.math.erf", "type": "function", "code": "tf.math.erf(x,name=None)", "summary": "Computes the Gauss error function of x element-wise.", "description": "", "code-info": {"name": "tf.math.erf", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.equal", "type": "function", "code": "tf.math.equal(x,y,name=None)", "summary": "Returns the truth value of (x == y) element-wise.", "description": "", "code-info": {"name": "tf.math.equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tf.Tensor or tf.SparseTensor or tf.IndexedSlices."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A tf.Tensor or tf.SparseTensor or tf.IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.cosh", "type": "function", "code": "tf.math.cosh(x,name=None)", "summary": "Computes hyperbolic cosine of x element-wise.", "description": "", "code-info": {"name": "tf.math.cosh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.cumprod", "type": "function", "code": "tf.math.cumprod(x,axis=0,exclusive=False,reverse=False,name=None)", "summary": "Compute the cumulative product of the tensor x along axis.", "description": "", "code-info": {"name": "tf.math.cumprod", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint64, int32, uint8, uint16, int16, int8, complex64,\ncomplex128, qint8, quint8, qint32, half."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "A Tensor of type int32 (default: 0). Must be in the range\n[-rank(x), rank(x))."}, {"name": "exclusive", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, perform exclusive cumprod."}, {"name": "reverse", "is_optional": true, "type": "bool", "default_value": "False", "description": "A bool (default: False)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.cumulative_logsumexp", "type": "function", "code": "tf.math.cumulative_logsumexp(x,axis=0,exclusive=False,reverse=False,name=None)", "summary": "Compute the cumulative log-sum-exp of the tensor x along axis.", "description": "", "code-info": {"name": "tf.math.cumulative_logsumexp", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float16, float32,\nfloat64."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "A Tensor of type int32 or int64 (default: 0). Must be in the\nrange [-rank(x), rank(x))."}, {"name": "exclusive", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, perform exclusive cumulative log-sum-exp."}, {"name": "reverse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, performs the cumulative log-sum-exp in the reverse\ndirection."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.conj", "type": "function", "code": "tf.math.conj(x,name=None)", "summary": "Returns the complex conjugate of a complex number.", "description": "", "code-info": {"name": "tf.math.conj", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor to conjugate.  Must have numeric or variant type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.cumsum", "type": "function", "code": "tf.math.cumsum(x,axis=0,exclusive=False,reverse=False,name=None)", "summary": "Compute the cumulative sum of the tensor x along axis.", "description": "", "code-info": {"name": "tf.math.cumsum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint64, int32, uint8, uint16, int16, int8, complex64,\ncomplex128, qint8, quint8, qint32, half."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "A Tensor of type int32 (default: 0). Must be in the range\n[-rank(x), rank(x))."}, {"name": "exclusive", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, perform exclusive cumsum."}, {"name": "reverse", "is_optional": true, "type": "bool", "default_value": "False", "description": "A bool (default: False)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.digamma", "type": "function", "code": "tf.math.digamma(x,name=None)", "summary": "Computes Psi, the derivative of Lgamma (the log of the absolute value of", "description": "", "code-info": {"name": "tf.math.digamma", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.count_nonzero", "type": "function", "code": "tf.math.count_nonzero(input,axis=None,keepdims=None,dtype=tf.dtypes.int64,name=None)", "summary": "Computes number of nonzero elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.math.count_nonzero", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should be of numeric type, bool, or string."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input), rank(input))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "The output dtype; defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.cos", "type": "function", "code": "tf.math.cos(x,name=None)", "summary": "Computes cos of x element-wise.", "description": "", "code-info": {"name": "tf.math.cos", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.bessel_i1", "type": "function", "code": "tf.math.bessel_i1(x,name=None)", "summary": "Computes the Bessel i1 function of x element-wise.", "description": "", "code-info": {"name": "tf.math.bessel_i1", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor. Must be one of the following types: half,\nfloat32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.ceil", "type": "function", "code": "tf.math.ceil(x,name=None)", "summary": "Returns element-wise smallest integer not less than x.", "description": "", "code-info": {"name": "tf.math.ceil", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.bessel_i0e", "type": "function", "code": "tf.math.bessel_i0e(x,name=None)", "summary": "Computes the Bessel i0e function of x element-wise.", "description": "", "code-info": {"name": "tf.math.bessel_i0e", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.bincount", "type": "function", "code": "tf.math.bincount(arr,weights=None,minlength=None,maxlength=None,dtype=tf.dtypes.int32,name=None)", "summary": "Counts the number of occurrences of each value in an integer array.", "description": "", "code-info": {"name": "tf.math.bincount", "parameters": [{"name": "arr", "is_optional": false, "type": "tensor", "description": "An int32 tensor of non-negative values."}, {"name": "weights", "is_optional": true, "type": "others", "default_value": "None", "description": "If non-None, must be the same shape as arr. For each value in\narr, the bin will be incremented by the corresponding weight instead of\n1."}, {"name": "minlength", "is_optional": true, "type": "others", "default_value": "None", "description": "If given, ensures the output has length at least minlength,\npadding with zeros at the end if necessary."}, {"name": "maxlength", "is_optional": true, "type": "others", "default_value": "None", "description": "If given, skips values in arr that are equal or greater than\nmaxlength, ensuring that the output has length at most maxlength."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "If weights is None, determines the type of the output bins."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name scope for the associated operations (optional)."}]}},
{"id": "tf.math.betainc", "type": "function", "code": "tf.math.betainc(a,b,x,name=None)", "summary": "Compute the regularized incomplete beta integral \\(I_x(a, b)\\).", "description": "", "code-info": {"name": "tf.math.betainc", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.confusion_matrix", "type": "function", "code": "tf.math.confusion_matrix(labels,predictions,num_classes=None,weights=None,dtype=tf.dtypes.int32,name=None)", "summary": "Computes the confusion matrix from predictions and labels.", "description": "", "code-info": {"name": "tf.math.confusion_matrix", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "1-D Tensor of real labels for the classification task."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "1-D Tensor of predictions for a given classification."}, {"name": "num_classes", "is_optional": true, "type": "others", "default_value": "None", "description": "The possible number of labels the classification task can\n         have. If this value is not provided, it will be calculated\n         using both predictions and labels array."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An optional Tensor whose shape matches predictions."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "Data type of the confusion matrix."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Scope name."}]}},
{"id": "tf.math.bessel_i1e", "type": "function", "code": "tf.math.bessel_i1e(x,name=None)", "summary": "Computes the Bessel i1e function of x element-wise.", "description": "", "code-info": {"name": "tf.math.bessel_i1e", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.bessel_i0", "type": "function", "code": "tf.math.bessel_i0(x,name=None)", "summary": "Computes the Bessel i0 function of x element-wise.", "description": "", "code-info": {"name": "tf.math.bessel_i0", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor. Must be one of the following types: half,\nfloat32, float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.atanh", "type": "function", "code": "tf.math.atanh(x,name=None)", "summary": "Computes inverse hyperbolic tangent of x element-wise.", "description": "", "code-info": {"name": "tf.math.atanh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.atan2", "type": "function", "code": "tf.math.atan2(y,x,name=None)", "summary": "Computes arctangent of y/x element-wise, respecting signs of the arguments.", "description": "", "code-info": {"name": "tf.math.atan2", "parameters": [{"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as y."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.atan", "type": "function", "code": "tf.math.atan(x,name=None)", "summary": "Computes the trignometric inverse tangent of x element-wise.", "description": "", "code-info": {"name": "tf.math.atan", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.asinh", "type": "function", "code": "tf.math.asinh(x,name=None)", "summary": "Computes inverse hyperbolic sine of x element-wise.", "description": "", "code-info": {"name": "tf.math.asinh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.asin", "type": "function", "code": "tf.math.asin(x,name=None)", "summary": "Computes the trignometric inverse sine of x element-wise.", "description": "", "code-info": {"name": "tf.math.asin", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.argmax", "type": "function", "code": "tf.math.argmax(input,axis=None,output_type=tf.dtypes.int64,name=None)", "summary": "Returns the index with the largest value across axes of a tensor.", "description": "", "code-info": {"name": "tf.math.argmax", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint32, uint8, int16, int8, complex64, int64, qint8,\nquint8, qint32, bfloat16, uint16, complex128, half, uint32,\nuint64."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range -rank(input), rank(input)).\nDescribes which axis of the input Tensor to reduce across. For vectors,\nuse axis = 0."}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to\ntf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.add_n", "type": "function", "code": "tf.math.add_n(inputs,name=None)", "summary": "Adds all input tensors element-wise.", "description": "", "code-info": {"name": "tf.math.add_n", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of tf.Tensor or tf.IndexedSlices objects, each with same\nshape and type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.add", "type": "function", "code": "tf.math.add(x,y,name=None)", "summary": "Returns x + y element-wise.", "description": "", "code-info": {"name": "tf.math.add", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, int16, int32, int64, complex64, complex128, string."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.acosh", "type": "function", "code": "tf.math.acosh(x,name=None)", "summary": "Computes inverse hyperbolic cosine of x element-wise.", "description": "", "code-info": {"name": "tf.math.acosh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.acos", "type": "function", "code": "tf.math.acos(x,name=None)", "summary": "Computes acos of x element-wise.", "description": "", "code-info": {"name": "tf.math.acos", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.argmin", "type": "function", "code": "tf.math.argmin(input,axis=None,output_type=tf.dtypes.int64,name=None)", "summary": "Returns the index with the smallest value across axes of a tensor.", "description": "", "code-info": {"name": "tf.math.argmin", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64,\nint32, uint8, int16, int8, complex64, int64, qint8,\nquint8, qint32, bfloat16, uint16, complex128, half, uint32,\nuint64."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range -rank(input), rank(input)).\nDescribes which axis of the input Tensor to reduce across. For vectors,\nuse axis = 0."}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to\ntf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.angle", "type": "function", "code": "tf.math.angle(input,name=None)", "summary": "Returns the element-wise argument of a complex (or real) tensor.", "description": "", "code-info": {"name": "tf.math.angle", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float, double,\ncomplex64, complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.accumulate_n", "type": "function", "code": "tf.math.accumulate_n(inputs,shape=None,tensor_dtype=None,name=None)", "summary": "Returns the element-wise sum of a list of tensors.", "description": "", "code-info": {"name": "tf.math.accumulate_n", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects, each with same shape and type."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Expected shape of elements of inputs (optional). Also controls the\noutput shape of this op, which may affect type inference in other ops. A\nvalue of None means \"infer the input shape from the shapes in inputs\"."}, {"name": "tensor_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Expected data type of inputs (optional). A value of None\nmeans \"infer the input dtype from inputs[0]\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.math.abs", "type": "function", "code": "tf.math.abs(x,name=None)", "summary": "Computes the absolute value of a tensor.", "description": "", "code-info": {"name": "tf.math.abs", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor of type float16, float32, float64,\nint32, int64, complex64 or complex128."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.lookup.experimental.DenseHashTable", "type": "class", "code": "tf.lookup.experimental.DenseHashTable(key_dtype,value_dtype,default_value,empty_key,deleted_key,initial_num_buckets=None,name='MutableDenseHashTable',checkpoint=True)", "summary": "A generic mutable hash table implementation using tensors as backing store.", "description": "", "code-info": {"name": "tf.lookup.experimental.DenseHashTable", "parameters": [{"name": "key_dtype", "is_optional": false, "type": "tensor", "description": "the type of the key tensors."}, {"name": "value_dtype", "is_optional": false, "type": "tensor", "description": "the type of the value tensors."}, {"name": "default_value", "is_optional": false, "type": "others", "description": "The value to use if a key is missing in the table."}, {"name": "empty_key", "is_optional": false, "type": "others", "description": "the key to use to represent empty buckets internally. Must not\nbe used in insert, remove or lookup operations."}, {"name": "deleted_key", "is_optional": false, "type": "others", "description": "the key to use to represent deleted buckets internally. Must\nnot be used in insert, remove or lookup operations and be different from\nthe empty_key."}, {"name": "initial_num_buckets", "is_optional": true, "type": "others", "default_value": "None", "description": "the initial number of buckets."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'MutableDenseHashTable'", "description": "A name for the operation (optional)."}, {"name": "checkpoint", "is_optional": true, "type": "bool", "default_value": "True", "description": "if True, the contents of the table are saved to and restored\nfrom checkpoints. If shared_name is empty for a checkpointed table, it\nis shared using the table node name."}]}},
{"id": "tf.lookup.StaticVocabularyTable", "type": "class", "code": "tf.lookup.StaticVocabularyTable(initializer,num_oov_buckets,lookup_key_dtype=None,name=None)", "summary": "String to Id table wrapper that assigns out-of-vocabulary keys to buckets.", "description": "", "code-info": {"name": "tf.lookup.StaticVocabularyTable", "parameters": [{"name": "initializer", "is_optional": false, "type": "others", "description": "A TableInitializerBase object that contains the data used to\ninitialize the table. If None, then we only use out-of-vocab buckets."}, {"name": "num_oov_buckets", "is_optional": false, "type": "others", "description": "Number of buckets to use for out-of-vocabulary keys. Must\nbe greater than zero."}, {"name": "lookup_key_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Data type of keys passed to lookup. Defaults to\ninitializer.key_dtype if initializer is specified, otherwise\ntf.string. Must be string or integer, and must be castable to\ninitializer.key_dtype."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.lookup.TextFileInitializer", "type": "class", "code": "tf.lookup.TextFileInitializer(filename,key_dtype,key_index,value_dtype,value_index,vocab_size=None,delimiter='\\t',name=None)", "summary": "Table initializers from a text file.", "description": "", "code-info": {"name": "tf.lookup.TextFileInitializer", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "The filename of the text file to be used for initialization. The\npath must be accessible from wherever the graph is initialized (eg.\ntrainer or eval workers). The filename may be a scalar Tensor."}, {"name": "key_dtype", "is_optional": false, "type": "others", "description": "The key data type."}, {"name": "key_index", "is_optional": false, "type": "others", "description": "the index that represents information of a line to get the\ntable 'key' values from."}, {"name": "value_dtype", "is_optional": false, "type": "others", "description": "The value data type."}, {"name": "value_index", "is_optional": false, "type": "others", "description": "the index that represents information of a line to get the\ntable 'value' values from.'"}, {"name": "vocab_size", "is_optional": true, "type": "others", "default_value": "None", "description": "The number of elements in the file, if known."}, {"name": "delimiter", "is_optional": true, "type": "string", "default_value": "'\\t'", "description": "The delimiter to separate fields in a line."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.lite.experimental.load_delegate", "type": "function", "code": "tf.lite.experimental.load_delegate(library,options=None)", "summary": "Returns loaded Delegate object.", "description": "", "code-info": {"name": "tf.lite.experimental.load_delegate", "parameters": [{"name": "library", "is_optional": false, "type": "string", "description": "Name of shared library containing the\nTfLiteDelegate."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "Dictionary of options that are required to load the delegate. All\nkeys and values in the dictionary should be convertible to str. Consult\nthe documentation of the specific delegate for required and legal options.\n(default None)"}]}},
{"id": "tf.lookup.StaticHashTable", "type": "class", "code": "tf.lookup.StaticHashTable(initializer,default_value,name=None)", "summary": "A generic hash table that is immutable once initialized.", "description": "", "code-info": {"name": "tf.lookup.StaticHashTable", "parameters": [{"name": "initializer", "is_optional": false, "type": "others", "description": "The table initializer to use. See HashTable kernel for\nsupported key and value types."}, {"name": "default_value", "is_optional": false, "type": "others", "description": "The value to use if a key is missing in the table."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.lite.TargetSpec", "type": "function", "code": "tf.lite.TargetSpec(supported_ops=None,supported_types=None)", "summary": "Specification of target device.", "description": "", "code-info": {"name": "tf.lite.TargetSpec", "parameters": [{"name": "supported_ops", "is_optional": true, "type": "others", "default_value": "None", "description": "Experimental flag, subject to change. Set of OpsSet options\nsupported by the device. (default set([OpsSet.TFLITE_BUILTINS]))"}, {"name": "supported_types", "is_optional": true, "type": "others", "default_value": "None", "description": "List of types for constant values on the target device.\nSupported values are types exported by lite.constants. Frequently, an\noptimization choice is driven by the most compact (i.e. smallest)\ntype in this list (default [constants.FLOAT])"}]}},
{"id": "tf.linalg.tridiagonal_solve", "type": "function", "code": "tf.linalg.tridiagonal_solve(diagonals,rhs,diagonals_format='compact',transpose_rhs=False,conjugate_rhs=False,name=None,partial_pivoting=True)", "summary": "Solves tridiagonal systems of equations.", "description": "", "code-info": {"name": "tf.linalg.tridiagonal_solve", "parameters": [{"name": "diagonals", "is_optional": false, "type": "tensor", "description": "A Tensor or tuple of Tensors describing left-hand sides. The\nshape depends of diagonals_format, see description above. Must be\nfloat32, float64, complex64, or complex128."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [..., M] or [..., M, K] and with the same dtype as\ndiagonals. Note that if the shape of rhs and/or diags isn't known\nstatically, rhs will be treated as a matrix rather than a vector."}, {"name": "diagonals_format", "is_optional": true, "type": "string", "default_value": "'compact'", "description": "one of matrix, sequence, or compact. Default is\ncompact."}, {"name": "transpose_rhs", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, rhs is transposed before solving (has no effect\nif the shape of rhs is [..., M])."}, {"name": "conjugate_rhs", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, rhs is conjugated before solving."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op (optional)."}, {"name": "partial_pivoting", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to perform partial pivoting. True by default.\nPartial pivoting makes the procedure more stable, but slower. Partial\npivoting is unnecessary in some cases, including diagonally dominant and\nsymmetric positive definite matrices (see e.g. theorem 9.12 in [1])."}]}},
{"id": "tf.lite.RepresentativeDataset", "type": "function", "code": "tf.lite.RepresentativeDataset(input_gen)", "summary": "Representative dataset to evaluate optimizations.", "description": "", "code-info": {"name": "tf.lite.RepresentativeDataset", "parameters": [{"name": "input_gen", "is_optional": false, "type": "others", "description": "an input generator that can be used to generate input samples\nfor the model. This must be a callable object that returns an object\nthat supports the iter() protocol (e.g. a generator function). The\nelements generated must have same type and shape as inputs to the model."}]}},
{"id": "tf.lookup.KeyValueTensorInitializer", "type": "class", "code": "tf.lookup.KeyValueTensorInitializer(keys,values,key_dtype=None,value_dtype=None,name=None)", "summary": "Table initializers given keys and values tensors.", "description": "", "code-info": {"name": "tf.lookup.KeyValueTensorInitializer", "parameters": [{"name": "keys", "is_optional": false, "type": "tensor", "description": "The tensor for the keys."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "The tensor for the values."}, {"name": "key_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "The keys data type. Used when keys is a python array."}, {"name": "value_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "The values data type. Used when values is a python array."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.lite.Interpreter", "type": "function", "code": "tf.lite.Interpreter(model_path=None,model_content=None,experimental_delegates=None)", "summary": "Interpreter interface for TensorFlow Lite Models.", "description": "", "code-info": {"name": "tf.lite.Interpreter", "parameters": [{"name": "model_path", "is_optional": true, "type": "others", "default_value": "None", "description": "Path to TF-Lite Flatbuffer file."}, {"name": "model_content", "is_optional": true, "type": "others", "default_value": "None", "description": "Content of model."}, {"name": "experimental_delegates", "is_optional": true, "type": "others", "default_value": "None", "description": "Experimental. Subject to change. List of\nTfLiteDelegate\nobjects returned by lite.load_delegate()."}]}},
{"id": "tf.lite.TFLiteConverter", "type": "class", "code": "tf.lite.TFLiteConverter(funcs,trackable_obj=None)", "summary": "Converts a TensorFlow model into TensorFlow Lite model.", "description": "", "code-info": {"name": "tf.lite.TFLiteConverter", "parameters": [{"name": "funcs", "is_optional": false, "type": "tensor", "description": "List of TensorFlow ConcreteFunctions. The list should not contain\nduplicate elements."}, {"name": "trackable_obj", "is_optional": true, "type": "others", "default_value": "None", "description": "tf.AutoTrackable object associated with funcs. A\nreference to this object needs to be maintained so that Variables do not\nget garbage collected since functions have a weak reference to\nVariables. This is only required when the tf.AutoTrackable object is not\nmaintained by the user (e.g. from_saved_model)."}]}},
{"id": "tf.linalg.tridiagonal_matmul", "type": "function", "code": "tf.linalg.tridiagonal_matmul(diagonals,rhs,diagonals_format='compact',name=None)", "summary": "Multiplies tridiagonal matrix by matrix.", "description": "", "code-info": {"name": "tf.linalg.tridiagonal_matmul", "parameters": [{"name": "diagonals", "is_optional": false, "type": "tensor", "description": "A Tensor or tuple of Tensors describing left-hand sides. The\nshape depends of diagonals_format, see description above. Must be\nfloat32, float64, complex64, or complex128."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [..., M, N] and with the same dtype as diagonals."}, {"name": "diagonals_format", "is_optional": true, "type": "string", "default_value": "'compact'", "description": "one of sequence, or compact. Default is compact."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op (optional)."}]}},
{"id": "tf.linalg.trace", "type": "function", "code": "tf.linalg.trace(x,name=None)", "summary": "Compute the trace of a tensor x.", "description": "", "code-info": {"name": "tf.linalg.trace", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.tensor_diag_part", "type": "function", "code": "tf.linalg.tensor_diag_part(input,name=None)", "summary": "Returns the diagonal part of the tensor.", "description": "", "code-info": {"name": "tf.linalg.tensor_diag_part", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128.\nRank k tensor where k is even and not zero."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.solve", "type": "function", "code": "tf.linalg.solve(matrix,rhs,adjoint=False,name=None)", "summary": "Solves systems of linear equations.", "description": "", "code-info": {"name": "tf.linalg.solve", "parameters": [{"name": "matrix", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nShape is [..., M, M]."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as matrix.\nShape is [..., M, K]."}, {"name": "adjoint", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nBoolean indicating whether to solve with matrix or its (block-wise)\nadjoint."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.triangular_solve", "type": "function", "code": "tf.linalg.triangular_solve(matrix,rhs,lower=True,adjoint=False,name=None)", "summary": "Solves systems of linear equations with upper or lower triangular matrices by backsubstitution.", "description": "", "code-info": {"name": "tf.linalg.triangular_solve", "parameters": [{"name": "matrix", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nShape is [..., M, M]."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as matrix.\nShape is [..., M, K]."}, {"name": "lower", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nBoolean indicating whether the innermost matrices in matrix are\nlower or upper triangular."}, {"name": "adjoint", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nBoolean indicating whether to solve with matrix or its (block-wise)\n       adjoint."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.tensor_diag", "type": "function", "code": "tf.linalg.tensor_diag(diagonal,name=None)", "summary": "Returns a diagonal tensor with a given diagonal values.", "description": "", "code-info": {"name": "tf.linalg.tensor_diag", "parameters": [{"name": "diagonal", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int32, int64, complex64, complex128.\nRank k tensor where k is at most 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.svd", "type": "function", "code": "tf.linalg.svd(tensor,full_matrices=False,compute_uv=True,name=None)", "summary": "Computes the singular value decompositions of one or more matrices.", "description": "", "code-info": {"name": "tf.linalg.svd", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., M, N]. Let P be the minimum of M and\nN."}, {"name": "full_matrices", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, compute full-sized u and v. If false\n(the default), compute only the leading P singular vectors.\nIgnored if compute_uv is False."}, {"name": "compute_uv", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True then left and right singular vectors will be\ncomputed and returned in u and v, respectively. Otherwise, only the\nsingular values will be computed, which can be significantly faster."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.linalg.sqrtm", "type": "function", "code": "tf.linalg.sqrtm(input,name=None)", "summary": "Computes the matrix square root of one or more square matrices:", "description": "", "code-info": {"name": "tf.linalg.sqrtm", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nShape is [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.pinv", "type": "function", "code": "tf.linalg.pinv(a,rcond=None,validate_args=False,name=None)", "summary": "Compute the Moore-Penrose pseudo-inverse of one or more matrices.", "description": "", "code-info": {"name": "tf.linalg.pinv", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "(Batch of) float-like matrix-shaped Tensor(s) which are to be\npseudo-inverted."}, {"name": "rcond", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor of small singular value cutoffs.  Singular values smaller\n(in modulus) than rcond * largest_singular_value (again, in modulus) are\nset to zero. Must broadcast against tf.shape(a)[:-2].\nDefault value: 10. * max(num_rows, num_cols) * np.finfo(a.dtype).eps."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "When True, additional assertions might be embedded in the\ngraph.\nDefault value: False (i.e., no graph assertions are added)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str prefixed to ops created by this function.\nDefault value: 'pinv'."}]}},
{"id": "tf.linalg.slogdet", "type": "function", "code": "tf.linalg.slogdet(input,name=None)", "summary": "Computes the sign and the log of the absolute value of the determinant of", "description": "", "code-info": {"name": "tf.linalg.slogdet", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, float32, float64, complex64, complex128.\nShape is [N, M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.set_diag", "type": "function", "code": "tf.linalg.set_diag(input,diagonal,name='set_diag',k=0)", "summary": "Returns a batched matrix tensor with new batched diagonal values.", "description": "", "code-info": {"name": "tf.linalg.set_diag", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor with rank k + 1, where k &gt;= 1."}, {"name": "diagonal", "is_optional": false, "type": "tensor", "description": " A Tensor with rank k, when d_lower == d_upper, or k + 1,\notherwise. k &gt;= 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'set_diag'", "description": "A name for the operation (optional)."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "0", "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the\nmain diagonal, and negative value means subdiagonals. k can be a single\ninteger (for a single diagonal) or a pair of integers specifying the low\nand high ends of a matrix band. k[0] must not be larger than k[1]."}]}},
{"id": "tf.linalg.qr", "type": "function", "code": "tf.linalg.qr(input,full_matrices=False,name=None)", "summary": "Computes the QR decompositions of one or more matrices.", "description": "", "code-info": {"name": "tf.linalg.qr", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nA tensor of shape [..., M, N] whose inner-most 2 dimensions\nform matrices of size [M, N]. Let P be the minimum of M and N."}, {"name": "full_matrices", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf true, compute full-sized q and r. If false\n(the default), compute only the leading P columns of q."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.normalize", "type": "function", "code": "tf.linalg.normalize(tensor,ord='euclidean',axis=None,name=None)", "summary": "Normalizes tensor along dimension axis using specified norm.", "description": "", "code-info": {"name": "tf.linalg.normalize", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of types float32, float64, complex64, complex128"}, {"name": "ord", "is_optional": true, "type": "string", "default_value": "'euclidean'", "description": "Order of the norm. Supported values are 'fro', 'euclidean', 1,\n2, np.inf and any positive real number yielding the corresponding\np-norm. Default is 'euclidean' which is equivalent to Frobenius norm if\ntensor is a matrix and equivalent to 2-norm for vectors.\nSome restrictions apply: a) The Frobenius norm 'fro' is not defined for\nvectors, b) If axis is a 2-tuple (matrix norm), only 'euclidean',\n'fro', 1, 2, np.inf are supported. See the description of axis\non how to compute norms for a batch of vectors or matrices stored in a\ntensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "If axis is None (the default), the input is considered a vector\nand a single vector norm is computed over the entire set of values in the\ntensor, i.e. norm(tensor, ord=ord) is equivalent to\nnorm(reshape(tensor, [-1]), ord=ord). If axis is a Python integer, the\ninput is considered a batch of vectors, and axis determines the axis in\ntensor over which to compute vector norms. If axis is a 2-tuple of\nPython integers it is considered a batch of matrices and axis determines\nthe axes in tensor over which to compute a matrix norm.\nNegative indices are supported. Example: If you are passing a tensor that\ncan be either a matrix or a batch of matrices at runtime, pass\naxis=[-2,-1] instead of axis=None to make sure that matrix norms are\ncomputed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the op."}]}},
{"id": "tf.linalg.lu_solve", "type": "function", "code": "tf.linalg.lu_solve(lower_upper,perm,rhs,validate_args=False,name=None)", "summary": "Solves systems of linear eqns A X = RHS, given LU factorizations.", "description": "", "code-info": {"name": "tf.linalg.lu_solve", "parameters": [{"name": "lower_upper", "is_optional": false, "type": "others", "description": "lu as returned by tf.linalg.lu, i.e., if matmul(P,\nmatmul(L, U)) = X then lower_upper = L + U - eye."}, {"name": "perm", "is_optional": false, "type": "others", "description": "p as returned by tf.linag.lu, i.e., if matmul(P, matmul(L, U)) =\nX then perm = argmax(P)."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "Matrix-shaped float Tensor representing targets for which to solve;\nA X = RHS. To handle vector cases, use: lu_solve(..., rhs[...,\ntf.newaxis])[..., 0]."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool indicating whether arguments should be checked\nfor correctness. Note: this function does not verify the implied matrix is\nactually invertible, even when validate_args=True.\nDefault value: False (i.e., don't validate arguments)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str name given to ops managed by this object.\nDefault value: None (i.e., 'lu_solve')."}]}},
{"id": "tf.linalg.matrix_transpose", "type": "function", "code": "tf.linalg.matrix_transpose(a,name='matrix_transpose',conjugate=False)", "summary": "Transposes last two dimensions of tensor a.", "description": "", "code-info": {"name": "tf.linalg.matrix_transpose", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor with rank &gt;= 2."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'matrix_transpose'", "description": "A name for the operation (optional)."}, {"name": "conjugate", "is_optional": true, "type": "bool", "default_value": "False", "description": "Optional bool. Setting it to True is mathematically equivalent\nto tf.math.conj(tf.linalg.matrix_transpose(input))."}]}},
{"id": "tf.linalg.matrix_rank", "type": "function", "code": "tf.linalg.matrix_rank(a,tol=None,validate_args=False,name=None)", "summary": "Compute the matrix rank of one or more matrices.", "description": "", "code-info": {"name": "tf.linalg.matrix_rank", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "(Batch of) float-like matrix-shaped Tensor(s) which are to be\npseudo-inverted."}, {"name": "tol", "is_optional": true, "type": "others", "default_value": "None", "description": "Threshold below which the singular value is counted as 'zero'.\nDefault value: None (i.e., eps * max(rows, cols) * max(singular_val))."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "When True, additional assertions might be embedded in the\ngraph.\nDefault value: False (i.e., no graph assertions are added)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str prefixed to ops created by this function.\nDefault value: 'matrix_rank'."}]}},
{"id": "tf.linalg.lu_reconstruct", "type": "function", "code": "tf.linalg.lu_reconstruct(lower_upper,perm,validate_args=False,name=None)", "summary": "The reconstruct one or more matrices from their LU decomposition(s).", "description": "", "code-info": {"name": "tf.linalg.lu_reconstruct", "parameters": [{"name": "lower_upper", "is_optional": false, "type": "others", "description": "lu as returned by tf.linalg.lu, i.e., if matmul(P,\nmatmul(L, U)) = X then lower_upper = L + U - eye."}, {"name": "perm", "is_optional": false, "type": "others", "description": "p as returned by tf.linag.lu, i.e., if matmul(P, matmul(L, U)) =\nX then perm = argmax(P)."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool indicating whether arguments should be checked\nfor correctness.\nDefault value: False (i.e., don't validate arguments)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str name given to ops managed by this object.\nDefault value: None (i.e., 'lu_reconstruct')."}]}},
{"id": "tf.linalg.lu_matrix_inverse", "type": "function", "code": "tf.linalg.lu_matrix_inverse(lower_upper,perm,validate_args=False,name=None)", "summary": "Computes the inverse given the LU decomposition(s) of one or more matrices.", "description": "", "code-info": {"name": "tf.linalg.lu_matrix_inverse", "parameters": [{"name": "lower_upper", "is_optional": false, "type": "others", "description": "lu as returned by tf.linalg.lu, i.e., if matmul(P,\nmatmul(L, U)) = X then lower_upper = L + U - eye."}, {"name": "perm", "is_optional": false, "type": "others", "description": "p as returned by tf.linag.lu, i.e., if matmul(P, matmul(L, U)) =\nX then perm = argmax(P)."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool indicating whether arguments should be checked\nfor correctness. Note: this function does not verify the implied matrix is\nactually invertible, even when validate_args=True.\nDefault value: False (i.e., don't validate arguments)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str name given to ops managed by this object.\nDefault value: None (i.e., 'lu_matrix_inverse')."}]}},
{"id": "tf.linalg.matmul", "type": "function", "code": "tf.linalg.matmul(a,b,transpose_a=False,transpose_b=False,adjoint_a=False,adjoint_b=False,a_is_sparse=False,b_is_sparse=False,name=None)", "summary": "Multiplies matrix a by matrix b, producing a * b.", "description": "", "code-info": {"name": "tf.linalg.matmul", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "tf.Tensor of type float16, float32, float64, int32,\ncomplex64, complex128 and rank &gt; 1."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "tf.Tensor with same type and rank as a."}, {"name": "transpose_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is transposed before multiplication."}, {"name": "transpose_b", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, b is transposed before multiplication."}, {"name": "adjoint_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is conjugated and transposed before\nmultiplication."}, {"name": "adjoint_b", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, b is conjugated and transposed before\nmultiplication."}, {"name": "a_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is treated as a sparse matrix."}, {"name": "b_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, b is treated as a sparse matrix."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name for the operation (optional)."}]}},
{"id": "tf.linalg.lu", "type": "function", "code": "tf.linalg.lu(input,output_idx_type=tf.dtypes.int32,name=None)", "summary": "Computes the LU decomposition of one or more square matrices.", "description": "", "code-info": {"name": "tf.linalg.lu", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nA tensor of shape [..., M, M] whose inner-most 2 dimensions form matrices of\nsize [M, M]."}, {"name": "output_idx_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.matvec", "type": "function", "code": "tf.linalg.matvec(a,b,transpose_a=False,adjoint_a=False,a_is_sparse=False,b_is_sparse=False,name=None)", "summary": "Multiplies matrix a by vector b, producing a * b.", "description": "", "code-info": {"name": "tf.linalg.matvec", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "Tensor of type float16, float32, float64, int32, complex64,\ncomplex128 and rank &gt; 1."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "Tensor with same type as a and compatible dimensions."}, {"name": "transpose_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is transposed before multiplication."}, {"name": "adjoint_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is conjugated and transposed before\nmultiplication."}, {"name": "a_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, a is treated as a sparse matrix."}, {"name": "b_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, b is treated as a sparse matrix."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name for the operation (optional)."}]}},
{"id": "tf.linalg.lstsq", "type": "function", "code": "tf.linalg.lstsq(matrix,rhs,l2_regularizer=0.0,fast=True,name=None)", "summary": "Solves one or more linear least-squares problems.", "description": "", "code-info": {"name": "tf.linalg.lstsq", "parameters": [{"name": "matrix", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., M, N]."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., M, K]."}, {"name": "l2_regularizer", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "0-D double Tensor. Ignored if fast=False."}, {"name": "fast", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool. Defaults to True."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.linalg.logm", "type": "function", "code": "tf.linalg.logm(input,name=None)", "summary": "Computes the matrix logarithm of one or more square matrices:", "description": "", "code-info": {"name": "tf.linalg.logm", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: complex64, complex128.\nShape is [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.logdet", "type": "function", "code": "tf.linalg.logdet(matrix,name=None)", "summary": "Computes log of the determinant of a hermitian positive definite matrix.", "description": "", "code-info": {"name": "tf.linalg.logdet", "parameters": [{"name": "matrix", "is_optional": false, "type": "tensor", "description": " A Tensor. Must be float16, float32, float64, complex64,\nor complex128 with shape [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op.  Defaults to logdet."}]}},
{"id": "tf.linalg.LinearOperatorZeros", "type": "class", "code": "tf.linalg.LinearOperatorZeros(num_rows,num_columns=None,batch_shape=None,dtype=None,is_non_singular=False,is_self_adjoint=True,is_positive_definite=False,is_square=True,assert_proper_shapes=False,name='LinearOperatorZeros')", "summary": "LinearOperator acting like a [batch] zero matrix.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorZeros", "parameters": [{"name": "num_rows", "is_optional": false, "type": "tensor", "description": " Scalar non-negative integer Tensor.  Number of rows in the\ncorresponding zero matrix."}, {"name": "num_columns", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Scalar non-negative integer Tensor.  Number of columns in\nthe corresponding zero matrix. If None, defaults to the value of\nnum_rows."}, {"name": "batch_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Optional 1-D integer Tensor.  The shape of the leading\ndimensions.  If None, this operator has no leading dimensions."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": " Data type of the matrix that this operator represents."}, {"name": "is_non_singular", "is_optional": true, "type": "bool", "default_value": "False", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "bool", "default_value": "False", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "assert_proper_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": " Python bool.  If False, only perform static\nchecks that initialization and method arguments have proper shape.\nIf True, and static checks are inconclusive, add asserts to the graph."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorZeros'", "description": "A name for this LinearOperator"}]}},
{"id": "tf.linalg.LinearOperatorToeplitz", "type": "class", "code": "tf.linalg.LinearOperatorToeplitz(col,row,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorToeplitz')", "summary": "LinearOperator acting like a [batch] of toeplitz matrices.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorToeplitz", "parameters": [{"name": "col", "is_optional": false, "type": "tensor", "description": "Shape [B1,...,Bb, N] Tensor with b &gt;= 0 N &gt;= 0.\nThe first column of the operator. Allowed dtypes: float16, float32,\nfloat64, complex64, complex128. Note that the first entry of\ncol is assumed to be the same as the first entry of row."}, {"name": "row", "is_optional": false, "type": "tensor", "description": "Shape [B1,...,Bb, N] Tensor with b &gt;= 0 N &gt;= 0.\nThe first row of the operator. Allowed dtypes: float16, float32,\nfloat64, complex64, complex128. Note that the first entry of\nrow is assumed to be the same as the first entry of col."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If diag.dtype is real, this is auto-set to True."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorToeplitz'", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.LinearOperatorScaledIdentity", "type": "class", "code": "tf.linalg.LinearOperatorScaledIdentity(num_rows,multiplier,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=True,assert_proper_shapes=False,name='LinearOperatorScaledIdentity')", "summary": "LinearOperator acting like a scaled [batch] identity matrix A = c I.", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorScaledIdentity", "parameters": [{"name": "num_rows", "is_optional": false, "type": "tensor", "description": " Scalar non-negative integer Tensor.  Number of rows in the\ncorresponding identity matrix."}, {"name": "multiplier", "is_optional": false, "type": "tensor", "description": " Tensor of shape [B1,...,Bb], or [] (a scalar)."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "assert_proper_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": " Python bool.  If False, only perform static\nchecks that initialization and method arguments have proper shape.\nIf True, and static checks are inconclusive, add asserts to the graph."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorScaledIdentity'", "description": "A name for this LinearOperator"}]}},
{"id": "tf.linalg.LinearOperatorPermutation", "type": "function", "code": "tf.linalg.LinearOperatorPermutation(perm,dtype=tf.dtypes.float32,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorPermutation')", "summary": "LinearOperator acting like a [batch] of permutation matrices.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorPermutation", "parameters": [{"name": "perm", "is_optional": false, "type": "others", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": ""}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorPermutation'", "description": " A name to give this Op."}]}},
{"id": "tf.linalg.LinearOperatorLowRankUpdate", "type": "class", "code": "tf.linalg.LinearOperatorLowRankUpdate(base_operator,u,diag_update=None,v=None,is_diag_update_positive=None,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorLowRankUpdate')", "summary": "Perturb a LinearOperator with a rank K update.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorLowRankUpdate", "parameters": [{"name": "base_operator", "is_optional": false, "type": "others", "description": " Shape [B1,...,Bb, M, N]."}, {"name": "u", "is_optional": false, "type": "tensor", "description": " Shape [B1,...,Bb, M, K] Tensor of same dtype as base_operator.\nThis is U above."}, {"name": "diag_update", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Optional shape [B1,...,Bb, K] Tensor with same dtype\nas base_operator.  This is the diagonal of D above.\nDefaults to D being the identity operator."}, {"name": "v", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Optional Tensor of same dtype as u and shape [B1,...,Bb, N, K]\nDefaults to v = u, in which case the perturbation is symmetric.\nIf M != N, then v must be set since the perturbation is not square."}, {"name": "is_diag_update_positive", "is_optional": true, "type": "bool", "default_value": "None", "description": " Python bool.\nIf True, expect diag_update &gt; 0."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular.\nDefault is None, unless is_positive_definite is auto-set to be\nTrue (see below)."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  Default is None, unless base_operator is self-adjoint\nand v = None (meaning u=v), in which case this defaults to True."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite.\nDefault is None, unless base_operator is positive-definite\nv = None (meaning u=v), and is_diag_update_positive, in which case\nthis defaults to True.\nNote that we say an operator is positive definite when the quadratic\nform x^H A x has positive real part for all nonzero x."}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorLowRankUpdate'", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.LinearOperatorIdentity", "type": "class", "code": "tf.linalg.LinearOperatorIdentity(num_rows,batch_shape=None,dtype=None,is_non_singular=True,is_self_adjoint=True,is_positive_definite=True,is_square=True,assert_proper_shapes=False,name='LinearOperatorIdentity')", "summary": "LinearOperator acting like a [batch] square identity matrix.", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorIdentity", "parameters": [{"name": "num_rows", "is_optional": false, "type": "tensor", "description": " Scalar non-negative integer Tensor.  Number of rows in the\ncorresponding identity matrix."}, {"name": "batch_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Optional 1-D integer Tensor.  The shape of the leading\ndimensions.  If None, this operator has no leading dimensions."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": " Data type of the matrix that this operator represents."}, {"name": "is_non_singular", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "assert_proper_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": " Python bool.  If False, only perform static\nchecks that initialization and method arguments have proper shape.\nIf True, and static checks are inconclusive, add asserts to the graph."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorIdentity'", "description": "A name for this LinearOperator"}]}},
{"id": "tf.linalg.LinearOperatorKronecker", "type": "class", "code": "tf.linalg.LinearOperatorKronecker(operators,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name=None)", "summary": "Kronecker product between two LinearOperators.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorKronecker", "parameters": [{"name": "operators", "is_optional": false, "type": "others", "description": " Iterable of LinearOperator objects, each with\nthe same dtype and composable shape, representing the Kronecker\nfactors."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix\n  #Extension_for_non_symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator.  Default is the individual\noperators names joined with _x_."}]}},
{"id": "tf.linalg.LinearOperatorLowerTriangular", "type": "class", "code": "tf.linalg.LinearOperatorLowerTriangular(tril,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorLowerTriangular')", "summary": "LinearOperator acting like a [batch] square lower triangular matrix.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorLowerTriangular", "parameters": [{"name": "tril", "is_optional": false, "type": "others", "description": " Shape [B1,...,Bb, N, N] with b &gt;= 0, N &gt;= 0.\nThe lower triangular part of tril defines this operator.  The strictly\nupper triangle is ignored."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular.\nThis operator is non-singular if and only if its diagonal elements are\nall non-zero."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  This operator is self-adjoint only if it is diagonal with\nreal-valued diagonal entries.  In this case it is advised to use\nLinearOperatorDiag."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorLowerTriangular'", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.LinearOperatorInversion", "type": "class", "code": "tf.linalg.LinearOperatorInversion(operator,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name=None)", "summary": "LinearOperator representing the inverse of another operator.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorInversion", "parameters": [{"name": "operator", "is_optional": false, "type": "others", "description": "LinearOperator object. If operator.is_non_singular == False,\nan exception is raised.  We do allow operator.is_non_singular == None,\nin which case this operator will have is_non_singular == None.\nSimilarly for is_self_adjoint and is_positive_definite."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator. Default is operator.name +\n\"_inv\"."}]}},
{"id": "tf.linalg.LinearOperatorHouseholder", "type": "function", "code": "tf.linalg.LinearOperatorHouseholder(reflection_axis,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorHouseholder')", "summary": "LinearOperator acting like a [batch] of Householder transformations.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorHouseholder", "parameters": [{"name": "reflection_axis", "is_optional": false, "type": "others", "description": ""}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorHouseholder'", "description": " A name to give this Op."}]}},
{"id": "tf.linalg.LinearOperatorDiag", "type": "class", "code": "tf.linalg.LinearOperatorDiag(diag,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorDiag')", "summary": "LinearOperator acting like a [batch] square diagonal matrix.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorDiag", "parameters": [{"name": "diag", "is_optional": false, "type": "tensor", "description": " Shape [B1,...,Bb, N] Tensor with b &gt;= 0 N &gt;= 0.\nThe diagonal of the operator.  Allowed dtypes: float16, float32,\nfloat64, complex64, complex128."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If diag.dtype is real, this is auto-set to True."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorDiag'", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.LinearOperatorCirculant3D", "type": "class", "code": "tf.linalg.LinearOperatorCirculant3D(spectrum,input_output_dtype=tf.dtypes.complex64,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=True,name='LinearOperatorCirculant3D')", "summary": "LinearOperator acting like a nested block circulant matrix.", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorCirculant3D", "parameters": [{"name": "spectrum", "is_optional": false, "type": "tensor", "description": " Shape [B1,...,Bb, N] Tensor.  Allowed dtypes: float16,\nfloat32, float64, complex64, complex128.  Type can be different\nthan input_output_dtype"}, {"name": "input_output_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.complex64", "description": "dtype for input/output."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If spectrum is real, this will always be true."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the real part of all eigenvalues is positive.  We do not require\nthe operator to be self-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix\n  #Extension_for_non_symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorCirculant3D'", "description": " A name to prepend to all ops created by this class."}]}},
{"id": "tf.linalg.LinearOperatorCirculant", "type": "class", "code": "tf.linalg.LinearOperatorCirculant(spectrum,input_output_dtype=tf.dtypes.complex64,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=True,name='LinearOperatorCirculant')", "summary": "LinearOperator acting like a circulant matrix.", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorCirculant", "parameters": [{"name": "spectrum", "is_optional": false, "type": "tensor", "description": " Shape [B1,...,Bb, N] Tensor.  Allowed dtypes: float16,\nfloat32, float64, complex64, complex128.  Type can be different\nthan input_output_dtype"}, {"name": "input_output_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.complex64", "description": "dtype for input/output."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If spectrum is real, this will always be true."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix\n  #Extension_for_non_symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorCirculant'", "description": " A name to prepend to all ops created by this class."}]}},
{"id": "tf.linalg.LinearOperatorCirculant2D", "type": "class", "code": "tf.linalg.LinearOperatorCirculant2D(spectrum,input_output_dtype=tf.dtypes.complex64,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=True,name='LinearOperatorCirculant2D')", "summary": "LinearOperator acting like a block circulant matrix.", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorCirculant2D", "parameters": [{"name": "spectrum", "is_optional": false, "type": "tensor", "description": " Shape [B1,...,Bb, N] Tensor.  Allowed dtypes: float16,\nfloat32, float64, complex64, complex128.  Type can be different\nthan input_output_dtype"}, {"name": "input_output_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.complex64", "description": "dtype for input/output."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If spectrum is real, this will always be true."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix\n  #Extension_for_non_symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorCirculant2D'", "description": " A name to prepend to all ops created by this class."}]}},
{"id": "tf.linalg.LinearOperatorBlockDiag", "type": "class", "code": "tf.linalg.LinearOperatorBlockDiag(operators,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=True,name=None)", "summary": "Combines one or more LinearOperators in to a Block Diagonal matrix.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorBlockDiag", "parameters": [{"name": "operators", "is_optional": false, "type": "others", "description": " Iterable of LinearOperator objects, each with\nthe same dtype and composable shape."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "bool", "default_value": "True", "description": " Expect that this operator acts like square [batch] matrices.\nThis is true by default, and will raise a ValueError otherwise."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator.  Default is the individual\noperators names joined with _o_."}]}},
{"id": "tf.linalg.global_norm", "type": "function", "code": "tf.linalg.global_norm(t_list,name=None)", "summary": "Computes the global norm of multiple tensors.", "description": "", "code-info": {"name": "tf.linalg.global_norm", "parameters": [{"name": "t_list", "is_optional": false, "type": "tensor", "description": "A tuple or list of mixed Tensors, IndexedSlices, or None."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.LinearOperator", "type": "class", "code": "tf.linalg.LinearOperator(dtype,graph_parents=None,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name=None)", "summary": "Base class defining a [batch of] linear operator[s].\n\nInherits From: Module", "description": "", "code-info": {"name": "tf.linalg.LinearOperator", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": "The type of the this LinearOperator.  Arguments to matmul and\nsolve will have to be this type."}, {"name": "graph_parents", "is_optional": true, "type": "others", "default_value": "None", "description": "(Deprecated) Python list of graph prerequisites of this\nLinearOperator Typically tensors that are passed during initialization"}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose.  If dtype is real, this is equivalent to being symmetric."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.LinearOperatorFullMatrix", "type": "class", "code": "tf.linalg.LinearOperatorFullMatrix(matrix,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name='LinearOperatorFullMatrix')", "summary": "LinearOperator that wraps a [batch] matrix.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorFullMatrix", "parameters": [{"name": "matrix", "is_optional": false, "type": "others", "description": " Shape [B1,...,Bb, M, N] with b &gt;= 0, M, N &gt;= 0.\nAllowed dtypes: float16, float32, float64, complex64,\ncomplex128."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'LinearOperatorFullMatrix'", "description": "A name for this LinearOperator."}]}},
{"id": "tf.linalg.inv", "type": "function", "code": "tf.linalg.inv(input,adjoint=False,name=None)", "summary": "Computes the inverse of one or more square invertible matrices or their", "description": "", "code-info": {"name": "tf.linalg.inv", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nShape is [..., M, M]."}, {"name": "adjoint", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.LinearOperatorComposition", "type": "class", "code": "tf.linalg.LinearOperatorComposition(operators,is_non_singular=None,is_self_adjoint=None,is_positive_definite=None,is_square=None,name=None)", "summary": "Composes one or more LinearOperators.\n\nInherits From: LinearOperator", "description": "", "code-info": {"name": "tf.linalg.LinearOperatorComposition", "parameters": [{"name": "operators", "is_optional": false, "type": "others", "description": " Iterable of LinearOperator objects, each with\nthe same dtype and composable shape."}, {"name": "is_non_singular", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is non-singular."}, {"name": "is_self_adjoint", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is equal to its hermitian\ntranspose."}, {"name": "is_positive_definite", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator is positive definite,\nmeaning the quadratic form x^H A x has positive real part for all\nnonzero x.  Note that we do not require the operator to be\nself-adjoint to be positive-definite.  See:\nhttps://en.wikipedia.org/wiki/Positive-definite_matrix#Extension_for_non-symmetric_matrices"}, {"name": "is_square", "is_optional": true, "type": "others", "default_value": "None", "description": " Expect that this operator acts like square [batch] matrices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this LinearOperator.  Default is the individual\noperators names joined with _o_."}]}},
{"id": "tf.linalg.expm", "type": "function", "code": "tf.linalg.expm(input,name=None)", "summary": "Computes the matrix exponential of one or more square matrices.", "description": "", "code-info": {"name": "tf.linalg.expm", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be float16, float32, float64, complex64, or\ncomplex128 with shape [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op (optional)."}]}},
{"id": "tf.linalg.eigvalsh", "type": "function", "code": "tf.linalg.eigvalsh(tensor,name=None)", "summary": "Computes the eigenvalues of one or more self-adjoint matrices.", "description": "", "code-info": {"name": "tf.linalg.eigvalsh", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., N, N]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.linalg.eigh", "type": "function", "code": "tf.linalg.eigh(tensor,name=None)", "summary": "Computes the eigen decomposition of a batch of self-adjoint matrices.", "description": "", "code-info": {"name": "tf.linalg.eigh", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of shape [..., N, N]. Only the lower triangular part of\neach inner inner matrix is referenced."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string, optional name of the operation."}]}},
{"id": "tf.linalg.diag_part", "type": "function", "code": "tf.linalg.diag_part(input,name='diag_part',k=0,padding_value=0)", "summary": "Returns the batched diagonal part of a batched tensor.", "description": "", "code-info": {"name": "tf.linalg.diag_part", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor with rank k &gt;= 2."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'diag_part'", "description": "A name for the operation (optional)."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "0", "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the\nmain diagonal, and negative value means subdiagonals. k can be a single\ninteger (for a single diagonal) or a pair of integers specifying the low\nand high ends of a matrix band. k[0] must not be larger than k[1]."}, {"name": "padding_value", "is_optional": true, "type": "int", "default_value": "0", "description": "The value to fill the area outside the specified diagonal\nband with. Default is 0."}]}},
{"id": "tf.linalg.diag", "type": "function", "code": "tf.linalg.diag(diagonal,name='diag',k=0,num_rows=-1,num_cols=-1,padding_value=0)", "summary": "Returns a batched diagonal tensor with given batched diagonal values.", "description": "", "code-info": {"name": "tf.linalg.diag", "parameters": [{"name": "diagonal", "is_optional": false, "type": "tensor", "description": "A Tensor with rank k &gt;= 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'diag'", "description": "A name for the operation (optional)."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "0", "description": "Diagonal offset(s). Positive value means superdiagonal, 0 refers to the\nmain diagonal, and negative value means subdiagonals. k can be a single\ninteger (for a single diagonal) or a pair of integers specifying the low\nand high ends of a matrix band. k[0] must not be larger than k[1]."}, {"name": "num_rows", "is_optional": true, "type": "others", "default_value": "-1", "description": "The number of rows of the output matrix. If it is not provided,\nthe op assumes the output matrix is a square matrix and infers the matrix\nsize from d_lower, d_upper, and the innermost dimension of diagonal."}, {"name": "num_cols", "is_optional": true, "type": "others", "default_value": "-1", "description": "The number of columns of the output matrix. If it is not provided,\nthe op assumes the output matrix is a square matrix and infers the matrix\nsize from d_lower, d_upper, and the innermost dimension of diagonal."}, {"name": "padding_value", "is_optional": true, "type": "int", "default_value": "0", "description": "The value to fill the area outside the specified diagonal\nband with. Default is 0."}]}},
{"id": "tf.linalg.det", "type": "function", "code": "tf.linalg.det(input,name=None)", "summary": "Computes the determinant of one or more square matrices.", "description": "", "code-info": {"name": "tf.linalg.det", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, float32, float64, complex64, complex128.\nShape is [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.cross", "type": "function", "code": "tf.linalg.cross(a,b,name=None)", "summary": "Compute the pairwise cross product.", "description": "", "code-info": {"name": "tf.linalg.cross", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64.\nA tensor containing 3-element vectors."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as a.\nAnother tensor, of same type and shape as a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.cholesky_solve", "type": "function", "code": "tf.linalg.cholesky_solve(chol,rhs,name=None)", "summary": "Solves systems of linear eqns A X = RHS, given Cholesky factorizations.", "description": "", "code-info": {"name": "tf.linalg.cholesky_solve", "parameters": [{"name": "chol", "is_optional": false, "type": "tensor", "description": " A Tensor.  Must be float32 or float64, shape is [..., M, M].\nCholesky factorization of A, e.g. chol = tf.linalg.cholesky(A).\nFor that reason, only the lower triangular parts (including the diagonal)\nof the last two dimensions of chol are used.  The strictly upper part is\nassumed to be zero and not accessed."}, {"name": "rhs", "is_optional": false, "type": "tensor", "description": " A Tensor, same type as chol, shape is [..., M, K]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op.  Defaults to cholesky_solve."}]}},
{"id": "tf.linalg.adjoint", "type": "function", "code": "tf.linalg.adjoint(matrix,name=None)", "summary": "Transposes the last two dimensions of and conjugates tensor matrix.", "description": "", "code-info": {"name": "tf.linalg.adjoint", "parameters": [{"name": "matrix", "is_optional": false, "type": "tensor", "description": " A Tensor. Must be float16, float32, float64, complex64,\nor complex128 with shape [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op (optional)."}]}},
{"id": "tf.keras.wrappers.scikit_learn.KerasClassifier", "type": "function", "code": "tf.keras.wrappers.scikit_learn.KerasClassifier(build_fn=None,**sk_params)", "summary": "Implementation of the scikit-learn classifier API for Keras.", "description": "", "code-info": {"name": "tf.keras.wrappers.scikit_learn.KerasClassifier", "parameters": [{"name": "build_fn", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**sk_params", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.linalg.cholesky", "type": "function", "code": "tf.linalg.cholesky(input,name=None)", "summary": "Computes the Cholesky decomposition of one or more square matrices.", "description": "", "code-info": {"name": "tf.linalg.cholesky", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float64, float32, half, complex64, complex128.\nShape is [..., M, M]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.linalg.band_part", "type": "function", "code": "tf.linalg.band_part(input,num_lower,num_upper,name=None)", "summary": "Copy a tensor setting everything outside a central band in each innermost matrix", "description": "", "code-info": {"name": "tf.linalg.band_part", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Rank k tensor."}, {"name": "num_lower", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n0-D tensor. Number of subdiagonals to keep. If negative, keep entire\nlower triangle."}, {"name": "num_upper", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as num_lower.\n0-D tensor. Number of superdiagonals to keep. If negative, keep\nentire upper triangle."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.keras.wrappers.scikit_learn.KerasRegressor", "type": "function", "code": "tf.keras.wrappers.scikit_learn.KerasRegressor(build_fn=None,**sk_params)", "summary": "Implementation of the scikit-learn regressor API for Keras.", "description": "", "code-info": {"name": "tf.keras.wrappers.scikit_learn.KerasRegressor", "parameters": [{"name": "build_fn", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**sk_params", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.utils.to_categorical", "type": "function", "code": "tf.keras.utils.to_categorical(y,num_classes=None,dtype='float32')", "summary": "Converts a class vector (integers) to binary class matrix.", "description": "", "code-info": {"name": "tf.keras.utils.to_categorical", "parameters": [{"name": "y", "is_optional": false, "type": "others", "description": "class vector to be converted into a matrix\n(integers from 0 to num_classes)."}, {"name": "num_classes", "is_optional": true, "type": "others", "default_value": "None", "description": "total number of classes."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "'float32'", "description": "The data type expected by the input. Default: 'float32'."}]}},
{"id": "tf.keras.utils.serialize_keras_object", "type": "function", "code": "tf.keras.utils.serialize_keras_object(instance)", "summary": "Serialize Keras object into JSON.", "description": "", "code-info": {"name": "tf.keras.utils.serialize_keras_object", "parameters": [{"name": "instance", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.utils.register_keras_serializable", "type": "function", "code": "tf.keras.utils.register_keras_serializable(package='Custom',name=None)", "summary": "Registers an object with the Keras serialization framework.", "description": "", "code-info": {"name": "tf.keras.utils.register_keras_serializable", "parameters": [{"name": "package", "is_optional": true, "type": "string", "default_value": "'Custom'", "description": "The package that this class belongs to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name to serialize this class under in this package. If None, the\nclass's name will be used."}]}},
{"id": "tf.keras.utils.normalize", "type": "function", "code": "tf.keras.utils.normalize(x,axis=-1,order=2)", "summary": "Normalizes a Numpy array.", "description": "", "code-info": {"name": "tf.keras.utils.normalize", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "Numpy array to normalize."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "axis along which to normalize."}, {"name": "order", "is_optional": true, "type": "int", "default_value": "2", "description": "Normalization order (e.g. 2 for L2 norm)."}]}},
{"id": "tf.keras.utils.SequenceEnqueuer", "type": "function", "code": "tf.keras.utils.SequenceEnqueuer(sequence,use_multiprocessing=False)", "summary": "Base class to enqueue inputs.", "description": "", "code-info": {"name": "tf.keras.utils.SequenceEnqueuer", "parameters": [{"name": "sequence", "is_optional": false, "type": "others", "description": ""}, {"name": "use_multiprocessing", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.keras.utils.plot_model", "type": "function", "code": "tf.keras.utils.plot_model(model,to_file='model.png',show_shapes=False,show_layer_names=True,rankdir='TB',expand_nested=False,dpi=96)", "summary": "Converts a Keras model to dot format and save to a file.", "description": "", "code-info": {"name": "tf.keras.utils.plot_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "A Keras model instance"}, {"name": "to_file", "is_optional": true, "type": "string", "default_value": "'model.png'", "description": "File name of the plot image."}, {"name": "show_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to display shape information."}, {"name": "show_layer_names", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to display layer names."}, {"name": "rankdir", "is_optional": true, "type": "string", "default_value": "'TB'", "description": "rankdir argument passed to PyDot,\na string specifying the format of the plot:\n'TB' creates a vertical plot;\n'LR' creates a horizontal plot."}, {"name": "expand_nested", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to expand nested models into clusters."}, {"name": "dpi", "is_optional": true, "type": "int", "default_value": "96", "description": "Dots per inch."}]}},
{"id": "tf.keras.utils.multi_gpu_model", "type": "function", "code": "tf.keras.utils.multi_gpu_model(model,gpus,cpu_merge=True,cpu_relocation=False)", "summary": "Replicates a model on different GPUs. (deprecated)", "description": "", "code-info": {"name": "tf.keras.utils.multi_gpu_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "A Keras model instance. To avoid OOM errors,\nthis model could have been built on CPU, for instance\n(see usage example below)."}, {"name": "gpus", "is_optional": false, "type": "int", "description": "Integer &gt;= 2, number of on GPUs on which to create\nmodel replicas."}, {"name": "cpu_merge", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean value to identify whether to force\nmerging model weights under the scope of the CPU or not."}, {"name": "cpu_relocation", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean value to identify whether to\ncreate the model's weights under the scope of the CPU.\nIf the model is not defined under any preceding device\nscope, you can still rescue it by activating this option."}]}},
{"id": "tf.keras.utils.OrderedEnqueuer", "type": "function", "code": "tf.keras.utils.OrderedEnqueuer(sequence,use_multiprocessing=False,shuffle=False)", "summary": "Builds a Enqueuer from a Sequence.\n\nInherits From: SequenceEnqueuer", "description": "", "code-info": {"name": "tf.keras.utils.OrderedEnqueuer", "parameters": [{"name": "sequence", "is_optional": false, "type": "others", "description": "A tf.keras.utils.data_utils.Sequence object."}, {"name": "use_multiprocessing", "is_optional": true, "type": "bool", "default_value": "False", "description": "use multiprocessing if True, otherwise threading"}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to shuffle the data at the beginning of each epoch"}]}},
{"id": "tf.keras.utils.Progbar", "type": "function", "code": "tf.keras.utils.Progbar(target,width=30,verbose=1,interval=0.05,stateful_metrics=None,unit_name='step')", "summary": "Displays a progress bar.", "description": "", "code-info": {"name": "tf.keras.utils.Progbar", "parameters": [{"name": "target", "is_optional": false, "type": "others", "description": "Total number of steps expected, None if unknown."}, {"name": "width", "is_optional": true, "type": "int", "default_value": "30", "description": "Progress bar width on screen."}, {"name": "verbose", "is_optional": true, "type": "int", "default_value": "1", "description": "Verbosity mode, 0 (silent), 1 (verbose), 2 (semi-verbose)\nstateful_metrics: Iterable of string names of metrics that\nshould not be averaged over time. Metrics in this list\nwill be displayed as-is. All others will be averaged\nby the progbar before display."}, {"name": "interval", "is_optional": true, "type": "others", "default_value": "0.05", "description": "Minimum visual progress update interval (in seconds).\nunit_name: Display name for step counts (usually \"step\" or \"sample\").\n\n\nMethods\n\nadd\n\nView source\nadd(\n    n, values=None\n)\n\nupdate\n\nView source\nupdate(\n    current, values=None\n)\n\nUpdates the progress bar.\n\nArguments:\n\n\ncurrent: Index of current step.\nvalues: List of tuples:\n(name, value_for_last_step).\nIf name is in stateful_metrics,\nvalue_for_last_step will be displayed as-is.\nElse, an average of the metric over time will be displayed.\n\n\n          "}, {"name": "stateful_metrics", "is_optional": true, "type": "string", "default_value": "None", "description": "Iterable of string names of metrics that\nshould not be averaged over time. Metrics in this list\nwill be displayed as-is. All others will be averaged\nby the progbar before display.\ninterval: Minimum visual progress update interval (in seconds)."}, {"name": "unit_name", "is_optional": true, "type": "string", "default_value": "'step'", "description": "Display name for step counts (usually \"step\" or \"sample\")."}]}},
{"id": "tf.keras.utils.model_to_dot", "type": "function", "code": "tf.keras.utils.model_to_dot(model,show_shapes=False,show_layer_names=True,rankdir='TB',expand_nested=False,dpi=96,subgraph=False)", "summary": "Convert a Keras model to dot format.", "description": "", "code-info": {"name": "tf.keras.utils.model_to_dot", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "A Keras model instance."}, {"name": "show_shapes", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to display shape information."}, {"name": "show_layer_names", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to display layer names."}, {"name": "rankdir", "is_optional": true, "type": "string", "default_value": "'TB'", "description": "rankdir argument passed to PyDot,\na string specifying the format of the plot:\n'TB' creates a vertical plot;\n'LR' creates a horizontal plot."}, {"name": "expand_nested", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to expand nested models into clusters."}, {"name": "dpi", "is_optional": true, "type": "int", "default_value": "96", "description": "Dots per inch."}, {"name": "subgraph", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to return a pydot.Cluster instance."}]}},
{"id": "tf.keras.utils.HDF5Matrix", "type": "class", "code": "tf.keras.utils.HDF5Matrix(datapath,dataset,start=0,end=None,normalizer=None)", "summary": "Representation of HDF5 dataset to be used instead of a Numpy array.", "description": "", "code-info": {"name": "tf.keras.utils.HDF5Matrix", "parameters": [{"name": "datapath", "is_optional": false, "type": "string", "description": "string, path to a HDF5 file"}, {"name": "dataset", "is_optional": false, "type": "string", "description": "string, name of the HDF5 dataset in the file specified\nin datapath"}, {"name": "start", "is_optional": true, "type": "int", "default_value": "0", "description": "int, start of desired slice of the specified dataset"}, {"name": "end", "is_optional": true, "type": "others", "default_value": "None", "description": "int, end of desired slice of the specified dataset"}, {"name": "normalizer", "is_optional": true, "type": "others", "default_value": "None", "description": "function to be called on data when retrieved"}]}},
{"id": "tf.keras.utils.get_source_inputs", "type": "function", "code": "tf.keras.utils.get_source_inputs(tensor,layer=None,node_index=None)", "summary": "Returns the list of input tensors necessary to compute tensor.", "description": "", "code-info": {"name": "tf.keras.utils.get_source_inputs", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "The tensor to start from."}, {"name": "layer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Origin layer of the tensor. Will be\ndetermined via tensor._keras_history if not provided."}, {"name": "node_index", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Origin node index of the tensor."}]}},
{"id": "tf.keras.utils.get_file", "type": "function", "code": "tf.keras.utils.get_file(fname,origin,untar=False,md5_hash=None,file_hash=None,cache_subdir='datasets',hash_algorithm='auto',extract=False,archive_format='auto',cache_dir=None)", "summary": "Downloads a file from a URL if it not already in the cache.", "description": "", "code-info": {"name": "tf.keras.utils.get_file", "parameters": [{"name": "fname", "is_optional": false, "type": "string", "description": "Name of the file. If an absolute path /path/to/file.txt is\nspecified the file will be saved at that location."}, {"name": "origin", "is_optional": false, "type": "others", "description": "Original URL of the file."}, {"name": "untar", "is_optional": true, "type": "bool", "default_value": "False", "description": "Deprecated in favor of 'extract'.\nboolean, whether the file should be decompressed"}, {"name": "md5_hash", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated in favor of 'file_hash'.\nmd5 hash of the file for verification"}, {"name": "file_hash", "is_optional": true, "type": "string", "default_value": "None", "description": "The expected hash string of the file after download.\nThe sha256 and md5 hash algorithms are both supported."}, {"name": "cache_subdir", "is_optional": true, "type": "string", "default_value": "'datasets'", "description": "Subdirectory under the Keras cache dir where the file is\nsaved. If an absolute path /path/to/folder is\nspecified the file will be saved at that location."}, {"name": "hash_algorithm", "is_optional": true, "type": "string", "default_value": "'auto'", "description": "Select the hash algorithm to verify the file.\noptions are 'md5', 'sha256', and 'auto'.\nThe default 'auto' detects the hash algorithm in use."}, {"name": "extract", "is_optional": true, "type": "bool", "default_value": "False", "description": "True tries extracting the file as an Archive, like tar or zip."}, {"name": "archive_format", "is_optional": true, "type": "string", "default_value": "'auto'", "description": "Archive format to try for extracting the file.\nOptions are 'auto', 'tar', 'zip', and None.\n'tar' includes tar, tar.gz, and tar.bz files.\nThe default 'auto' is ['tar', 'zip'].\nNone or an empty list will return no matches found."}, {"name": "cache_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Location to store cached files, when None it\ndefaults to the Keras\n  Directory."}]}},
{"id": "tf.keras.utils.convert_all_kernels_in_model", "type": "function", "code": "tf.keras.utils.convert_all_kernels_in_model(model)", "summary": "Converts all convolution kernels in a model from Theano to TensorFlow.", "description": "", "code-info": {"name": "tf.keras.utils.convert_all_kernels_in_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "target model for the conversion."}]}},
{"id": "tf.keras.utils.GeneratorEnqueuer", "type": "function", "code": "tf.keras.utils.GeneratorEnqueuer(sequence,use_multiprocessing=False,random_seed=None)", "summary": "Builds a queue out of a data generator.\n\nInherits From: SequenceEnqueuer", "description": "", "code-info": {"name": "tf.keras.utils.GeneratorEnqueuer", "parameters": [{"name": "sequence", "is_optional": false, "type": "others", "description": ""}, {"name": "use_multiprocessing", "is_optional": true, "type": "bool", "default_value": "False", "description": "use multiprocessing if True, otherwise threading\nwait_time: time to sleep in-between calls to put()"}, {"name": "random_seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Initial seed for workers,\nwill be incremented by one for each worker."}]}},
{"id": "tf.keras.utils.custom_object_scope", "type": "function", "code": "tf.keras.utils.custom_object_scope(*args)", "summary": "Provides a scope that changes to _GLOBAL_CUSTOM_OBJECTS cannot escape.", "description": "", "code-info": {"name": "tf.keras.utils.custom_object_scope", "parameters": [{"name": "*args", "is_optional": false, "type": "string", "description": "Variable length list of dictionaries of name,\nclass pairs to add to custom objects."}]}},
{"id": "tf.keras.utils.CustomObjectScope", "type": "function", "code": "tf.keras.utils.CustomObjectScope(*args)", "summary": "Provides a scope that changes to _GLOBAL_CUSTOM_OBJECTS cannot escape.", "description": "", "code-info": {"name": "tf.keras.utils.CustomObjectScope", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.regularizers.l2", "type": "function", "code": "tf.keras.regularizers.l2(l=0.01)", "summary": "Create a regularizer that applies an L2 regularization penalty.", "description": "", "code-info": {"name": "tf.keras.regularizers.l2", "parameters": [{"name": "l", "is_optional": true, "type": "float", "default_value": "0.01", "description": "Float; L2 regularization factor."}]}},
{"id": "tf.keras.regularizers.serialize", "type": "function", "code": "tf.keras.regularizers.serialize(regularizer)", "summary": "", "description": "", "code-info": {"name": "tf.keras.regularizers.serialize", "parameters": [{"name": "regularizer", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.utils.get_custom_objects", "type": "function", "code": "tf.keras.utils.get_custom_objects()", "summary": "Retrieves a live reference to the global dictionary of custom objects.", "description": "", "code-info": {"name": "tf.keras.utils.get_custom_objects", "parameters": []}},
{"id": "tf.keras.regularizers.l1_l2", "type": "function", "code": "tf.keras.regularizers.l1_l2(l1=0.01,l2=0.01)", "summary": "Create a regularizer that applies both L1 and L2 penalties.", "description": "", "code-info": {"name": "tf.keras.regularizers.l1_l2", "parameters": [{"name": "l1", "is_optional": true, "type": "float", "default_value": "0.01", "description": "Float; L1 regularization factor."}, {"name": "l2", "is_optional": true, "type": "float", "default_value": "0.01", "description": "Float; L2 regularization factor."}]}},
{"id": "tf.keras.utils.deserialize_keras_object", "type": "function", "code": "tf.keras.utils.deserialize_keras_object(identifier,module_objects=None,custom_objects=None,printable_module_name='object')", "summary": "", "description": "", "code-info": {"name": "tf.keras.utils.deserialize_keras_object", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}, {"name": "module_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "printable_module_name", "is_optional": true, "type": "string", "default_value": "'object'", "description": ""}]}},
{"id": "tf.keras.regularizers.L1L2", "type": "function", "code": "tf.keras.regularizers.L1L2(l1=0.0,l2=0.0)", "summary": "A regularizer that applies both L1 and L2 regularization penalties.\n\nInherits From: Regularizer", "description": "", "code-info": {"name": "tf.keras.regularizers.L1L2", "parameters": [{"name": "l1", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float; L1 regularization factor."}, {"name": "l2", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float; L2 regularization factor."}]}},
{"id": "tf.keras.regularizers.l1", "type": "function", "code": "tf.keras.regularizers.l1(l=0.01)", "summary": "Create a regularizer that applies an L1 regularization penalty.", "description": "", "code-info": {"name": "tf.keras.regularizers.l1", "parameters": [{"name": "l", "is_optional": true, "type": "float", "default_value": "0.01", "description": "Float; L1 regularization factor."}]}},
{"id": "tf.keras.preprocessing.text.one_hot", "type": "function", "code": "tf.keras.preprocessing.text.one_hot(text,n,filters='!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\\t\\n',lower=True,split='')", "summary": "One-hot encodes a text into a list of word indexes of size n.", "description": "", "code-info": {"name": "tf.keras.preprocessing.text.one_hot", "parameters": [{"name": "text", "is_optional": false, "type": "string", "description": "Input text (string)."}, {"name": "n", "is_optional": false, "type": "others", "description": "int. Size of vocabulary."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "'!\"#$%&amp", "description": "list (or concatenation) of characters to filter out, such as\n    punctuation. Default: ``!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~\\t\\n``,\n    includes basic punctuation, tabs, and newlines.\nlower: boolean. Whether to set the text to lowercase.\nsplit: str. Separator for word splitting."}]}},
{"id": "tf.keras.regularizers.get", "type": "function", "code": "tf.keras.regularizers.get(identifier)", "summary": "", "description": "", "code-info": {"name": "tf.keras.regularizers.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.regularizers.deserialize", "type": "function", "code": "tf.keras.regularizers.deserialize(config,custom_objects=None)", "summary": "", "description": "", "code-info": {"name": "tf.keras.regularizers.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.keras.preprocessing.text.tokenizer_from_json", "type": "function", "code": "tf.keras.preprocessing.text.tokenizer_from_json(json_string)", "summary": "Parses a JSON tokenizer configuration file and returns a", "description": "", "code-info": {"name": "tf.keras.preprocessing.text.tokenizer_from_json", "parameters": [{"name": "json_string", "is_optional": false, "type": "string", "description": "JSON string encoding a tokenizer configuration."}]}},
{"id": "tf.keras.preprocessing.text.Tokenizer", "type": "function", "code": "tf.keras.preprocessing.text.Tokenizer(num_words=None,filters='!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\\t\\n',lower=True,split='',char_level=False,oov_token=None,document_count=0,**kwargs)", "summary": "Text tokenization utility class.", "description": "", "code-info": {"name": "tf.keras.preprocessing.text.Tokenizer", "parameters": [{"name": "num_words", "is_optional": true, "type": "others", "default_value": "None", "description": "the maximum number of words to keep, based\n    on word frequency. Only the most common `num_words-1` words will\n    be kept."}, {"name": "filters", "is_optional": true, "type": "string", "default_value": "'!\"#$%&amp", "description": "a string where each element is a character that will be\n    filtered from the texts. The default is all punctuation, plus\n    tabs and line breaks, minus the `'` character.\nlower: boolean. Whether to convert the texts to lowercase.\nsplit: str. Separator for word splitting.\nchar_level: if True, every character will be treated as a token.\noov_token: if given, it will be added to word_index and used to\n    replace out-of-vocabulary words during text_to_sequence calls"}]}},
{"id": "tf.keras.preprocessing.text.text_to_word_sequence", "type": "function", "code": "tf.keras.preprocessing.text.text_to_word_sequence(text,filters='!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\\t\\n',lower=True,split='')", "summary": "Converts a text to a sequence of words (or tokens).", "description": "", "code-info": {"name": "tf.keras.preprocessing.text.text_to_word_sequence", "parameters": [{"name": "text", "is_optional": false, "type": "string", "description": "Input text (string)."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "'!\"#$%&amp", "description": "list (or concatenation) of characters to filter out, such as\n    punctuation. Default: ``!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~\\t\\n``,\n    includes basic punctuation, tabs, and newlines.\nlower: boolean. Whether to convert the input to lowercase.\nsplit: str. Separator for word splitting."}]}},
{"id": "tf.keras.preprocessing.sequence.make_sampling_table", "type": "function", "code": "tf.keras.preprocessing.sequence.make_sampling_table(size,sampling_factor=1e-05)", "summary": "Generates a word rank-based probabilistic sampling table.", "description": "", "code-info": {"name": "tf.keras.preprocessing.sequence.make_sampling_table", "parameters": [{"name": "size", "is_optional": false, "type": "others", "description": "Int, number of possible words to sample."}, {"name": "sampling_factor", "is_optional": true, "type": "others", "default_value": "1e-05", "description": "The sampling factor in the word2vec formula."}]}},
{"id": "tf.keras.preprocessing.image.save_img", "type": "function", "code": "tf.keras.preprocessing.image.save_img(path,x,data_format=None,file_format=None,scale=True,**kwargs)", "summary": "Saves an image stored as a Numpy array to a path or file object.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.save_img", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "Path or file object."}, {"name": "x", "is_optional": false, "type": "others", "description": "Numpy array."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Image data format,\neither \"channels_first\" or \"channels_last\"."}, {"name": "file_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional file format override. If omitted, the\nformat to use is determined from the filename extension.\nIf a file object was used instead of a filename, this\nparameter should always be used."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to rescale image values to be within [0, 255]."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Additional keyword arguments passed to PIL.Image.save()."}]}},
{"id": "tf.keras.preprocessing.sequence.skipgrams", "type": "function", "code": "tf.keras.preprocessing.sequence.skipgrams(sequence,vocabulary_size,window_size=4,negative_samples=1.0,shuffle=True,categorical=False,sampling_table=None,seed=None)", "summary": "Generates skipgram word pairs.", "description": "", "code-info": {"name": "tf.keras.preprocessing.sequence.skipgrams", "parameters": [{"name": "sequence", "is_optional": false, "type": "others", "description": "A word sequence (sentence), encoded as a list\n    of word indices (integers). If using a `sampling_table`,\n    word indices are expected to match the rank\n    of the words in a reference dataset (e.g. 10 would encode\n    the 10-th most frequently occurring token).\n    Note that index 0 is expected to be a non-word and will be skipped."}, {"name": "vocabulary_size", "is_optional": false, "type": "others", "description": "Int, maximum possible word index + 1"}, {"name": "window_size", "is_optional": true, "type": "int", "default_value": "4", "description": "Int, size of sampling windows (technically half-window).\n    The window of a word `w_i` will be\n    `[i - window_size, i + window_size+1]`."}, {"name": "negative_samples", "is_optional": true, "type": "float", "default_value": "1.0", "description": "Float &gt;= 0. 0 for no negative (i.e. random) samples.\n    1 for same number as positive samples."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to shuffle the word couples before returning them."}, {"name": "categorical", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool. if False, labels will be\n    integers (eg. `[0, 1, 1 .. ]`),\n    if `True`, labels will be categorical, e.g.\n    `[[1,0],[0,1],[0,1] .. ]`."}, {"name": "sampling_table", "is_optional": true, "type": "others", "default_value": "None", "description": "1D array of size `vocabulary_size` where the entry i\n    encodes the probability to sample a word of rank i."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Random seed."}]}},
{"id": "tf.keras.preprocessing.text.hashing_trick", "type": "function", "code": "tf.keras.preprocessing.text.hashing_trick(text,n,hash_function=None,filters='!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\\\]^_`{|}~\\t\\n',lower=True,split='')", "summary": "Converts a text to a sequence of indexes in a fixed-size hashing space.", "description": "", "code-info": {"name": "tf.keras.preprocessing.text.hashing_trick", "parameters": [{"name": "text", "is_optional": false, "type": "string", "description": "Input text (string)."}, {"name": "n", "is_optional": false, "type": "others", "description": "Dimension of the hashing space."}, {"name": "hash_function", "is_optional": true, "type": "others", "default_value": "None", "description": "defaults to python `hash` function, can be 'md5' or\n    any function that takes in input a string and returns a int.\n    Note that 'hash' is not a stable hashing function, so\n    it is not consistent across different runs, while 'md5'\n    is a stable hashing function."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "'!\"#$%&amp", "description": "list (or concatenation) of characters to filter out, such as\n    punctuation. Default: ``!\"#$%&amp;()*+,-./:;&lt;=&gt;?@[\\]^_`{|}~\\t\\n``,\n    includes basic punctuation, tabs, and newlines.\nlower: boolean. Whether to set the text to lowercase.\nsplit: str. Separator for word splitting."}]}},
{"id": "tf.keras.preprocessing.sequence.pad_sequences", "type": "function", "code": "tf.keras.preprocessing.sequence.pad_sequences(sequences,maxlen=None,dtype='int32',padding='pre',truncating='pre',value=0.0)", "summary": "Pads sequences to the same length.", "description": "", "code-info": {"name": "tf.keras.preprocessing.sequence.pad_sequences", "parameters": [{"name": "sequences", "is_optional": false, "type": "others", "description": "List of lists, where each element is a sequence."}, {"name": "maxlen", "is_optional": true, "type": "others", "default_value": "None", "description": "Int, maximum length of all sequences."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "'int32'", "description": "Type of the output sequences.\n    To pad sequences with variable length strings, you can use `object`."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'pre'", "description": "String, 'pre' or 'post':\n    pad either before or after each sequence."}, {"name": "truncating", "is_optional": true, "type": "string", "default_value": "'pre'", "description": "String, 'pre' or 'post':\n    remove values from sequences larger than\n    `maxlen`, either at the beginning or at the end of the sequences."}, {"name": "value", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float or String, padding value."}]}},
{"id": "tf.keras.preprocessing.image.random_shift", "type": "function", "code": "tf.keras.preprocessing.image.random_shift(x,wrg,hrg,row_axis=1,col_axis=2,channel_axis=0,fill_mode='nearest',cval=0.0,interpolation_order=1)", "summary": "Performs a random spatial shift of a Numpy image tensor.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "wrg", "is_optional": false, "type": "float", "description": "Width shift range, as a float fraction of the width."}, {"name": "hrg", "is_optional": false, "type": "float", "description": "Height shift range, as a float fraction of the height."}, {"name": "row_axis", "is_optional": true, "type": "int", "default_value": "1", "description": "Index of axis for rows in the input tensor."}, {"name": "col_axis", "is_optional": true, "type": "int", "default_value": "2", "description": "Index of axis for columns in the input tensor."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Points outside the boundaries of the input\n    are filled according to the given mode\n    (one of `{'constant', 'nearest', 'reflect', 'wrap'}`)."}, {"name": "cval", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Value used for points outside the boundaries\n    of the input if `mode='constant'`."}, {"name": "interpolation_order", "is_optional": true, "type": "int", "default_value": "1", "description": "int, order of spline interpolation.\n    see `ndimage.interpolation.affine_transform`"}]}},
{"id": "tf.keras.preprocessing.sequence.TimeseriesGenerator", "type": "function", "code": "tf.keras.preprocessing.sequence.TimeseriesGenerator(data,targets,length,sampling_rate=1,stride=1,start_index=0,end_index=None,shuffle=False,reverse=False,batch_size=128)", "summary": "Utility class for generating batches of temporal data.\n\nInherits From: Sequence", "description": "", "code-info": {"name": "tf.keras.preprocessing.sequence.TimeseriesGenerator", "parameters": [{"name": "data", "is_optional": false, "type": "others", "description": "Indexable generator (such as list or Numpy array)\n    containing consecutive data points (timesteps).\n    The data should be at 2D, and axis 0 is expected\n    to be the time dimension."}, {"name": "targets", "is_optional": false, "type": "others", "description": "Targets corresponding to timesteps in `data`.\n    It should have same length as `data`."}, {"name": "length", "is_optional": false, "type": "others", "description": "Length of the output sequences (in number of timesteps)."}, {"name": "sampling_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "Period between successive individual timesteps\n    within sequences. For rate `r`, timesteps\n    `data[i]`, `data[i-r]`, ... `data[i - length]`\n    are used for create a sample sequence."}, {"name": "stride", "is_optional": true, "type": "int", "default_value": "1", "description": "Period between successive output sequences.\n    For stride `s`, consecutive output samples would\n    be centered around `data[i]`, `data[i+s]`, `data[i+2*s]`, etc."}, {"name": "start_index", "is_optional": true, "type": "int", "default_value": "0", "description": "Data points earlier than `start_index` will not be used\n    in the output sequences. This is useful to reserve part of the\n    data for test or validation."}, {"name": "end_index", "is_optional": true, "type": "others", "default_value": "None", "description": "Data points later than `end_index` will not be used\n    in the output sequences. This is useful to reserve part of the\n    data for test or validation."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to shuffle output samples,\n    or instead draw them in chronological order."}, {"name": "reverse", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean: if `true`, timesteps in each output sample will be\n    in reverse chronological order."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "128", "description": "Number of timeseries samples in each batch\n    (except maybe the last one)."}]}},
{"id": "tf.keras.preprocessing.image.random_channel_shift", "type": "function", "code": "tf.keras.preprocessing.image.random_channel_shift(x,intensity_range,channel_axis=0)", "summary": "Performs a random channel shift.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_channel_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "intensity_range", "is_optional": false, "type": "others", "description": "Transformation intensity."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}]}},
{"id": "tf.keras.preprocessing.image.random_zoom", "type": "function", "code": "tf.keras.preprocessing.image.random_zoom(x,zoom_range,row_axis=1,col_axis=2,channel_axis=0,fill_mode='nearest',cval=0.0,interpolation_order=1)", "summary": "Performs a random spatial zoom of a Numpy image tensor.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_zoom", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "zoom_range", "is_optional": false, "type": "float", "description": "Tuple of floats; zoom range for width and height."}, {"name": "row_axis", "is_optional": true, "type": "int", "default_value": "1", "description": "Index of axis for rows in the input tensor."}, {"name": "col_axis", "is_optional": true, "type": "int", "default_value": "2", "description": "Index of axis for columns in the input tensor."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Points outside the boundaries of the input\n    are filled according to the given mode\n    (one of `{'constant', 'nearest', 'reflect', 'wrap'}`)."}, {"name": "cval", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Value used for points outside the boundaries\n    of the input if `mode='constant'`."}, {"name": "interpolation_order", "is_optional": true, "type": "int", "default_value": "1", "description": "int, order of spline interpolation.\n    see `ndimage.interpolation.affine_transform`"}]}},
{"id": "tf.keras.preprocessing.image.random_rotation", "type": "function", "code": "tf.keras.preprocessing.image.random_rotation(x,rg,row_axis=1,col_axis=2,channel_axis=0,fill_mode='nearest',cval=0.0,interpolation_order=1)", "summary": "Performs a random rotation of a Numpy image tensor.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_rotation", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "rg", "is_optional": false, "type": "others", "description": "Rotation range, in degrees."}, {"name": "row_axis", "is_optional": true, "type": "int", "default_value": "1", "description": "Index of axis for rows in the input tensor."}, {"name": "col_axis", "is_optional": true, "type": "int", "default_value": "2", "description": "Index of axis for columns in the input tensor."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Points outside the boundaries of the input\n    are filled according to the given mode\n    (one of `{'constant', 'nearest', 'reflect', 'wrap'}`)."}, {"name": "cval", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Value used for points outside the boundaries\n    of the input if `mode='constant'`."}, {"name": "interpolation_order", "is_optional": true, "type": "int", "default_value": "1", "description": "int, order of spline interpolation.\n    see `ndimage.interpolation.affine_transform`"}]}},
{"id": "tf.keras.preprocessing.image.random_shear", "type": "function", "code": "tf.keras.preprocessing.image.random_shear(x,intensity,row_axis=1,col_axis=2,channel_axis=0,fill_mode='nearest',cval=0.0,interpolation_order=1)", "summary": "Performs a random spatial shear of a Numpy image tensor.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_shear", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "intensity", "is_optional": false, "type": "others", "description": "Transformation intensity in degrees."}, {"name": "row_axis", "is_optional": true, "type": "int", "default_value": "1", "description": "Index of axis for rows in the input tensor."}, {"name": "col_axis", "is_optional": true, "type": "int", "default_value": "2", "description": "Index of axis for columns in the input tensor."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Points outside the boundaries of the input\n    are filled according to the given mode\n    (one of `{'constant', 'nearest', 'reflect', 'wrap'}`)."}, {"name": "cval", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Value used for points outside the boundaries\n    of the input if `mode='constant'`."}, {"name": "interpolation_order", "is_optional": true, "type": "int", "default_value": "1", "description": "int, order of spline interpolation.\n    see `ndimage.interpolation.affine_transform`"}]}},
{"id": "tf.keras.preprocessing.image.random_brightness", "type": "function", "code": "tf.keras.preprocessing.image.random_brightness(x,brightness_range)", "summary": "Performs a random brightness shift.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.random_brightness", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "brightness_range", "is_optional": false, "type": "float", "description": "Tuple of floats; brightness range.\nchannel_axis: Index of axis for channels in the input tensor."}]}},
{"id": "tf.keras.preprocessing.image.Iterator", "type": "function", "code": "tf.keras.preprocessing.image.Iterator(n,batch_size,shuffle,seed)", "summary": "Base class for image data iterators.\n\nInherits From: Sequence", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.Iterator", "parameters": [{"name": "n", "is_optional": false, "type": "int", "description": "Integer, total number of samples in the dataset to loop over."}, {"name": "batch_size", "is_optional": false, "type": "int", "description": "Integer, size of a batch."}, {"name": "shuffle", "is_optional": false, "type": "bool", "description": "Boolean, whether to shuffle the data between epochs."}, {"name": "seed", "is_optional": false, "type": "others", "description": "Random seeding for data shuffling."}]}},
{"id": "tf.keras.preprocessing.image.NumpyArrayIterator", "type": "function", "code": "tf.keras.preprocessing.image.NumpyArrayIterator(x,y,image_data_generator,batch_size=32,shuffle=False,sample_weight=None,seed=None,data_format=None,save_to_dir=None,save_prefix='',save_format='png',subset=None,dtype=None)", "summary": "Iterator yielding data from a Numpy array.\n\nInherits From: Iterator", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.NumpyArrayIterator", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "Numpy array of input data or tuple.\nIf tuple, the second elements is either\nanother numpy array or a list of numpy arrays,\neach of which gets passed\nthrough as an output without any modifications."}, {"name": "y", "is_optional": false, "type": "others", "description": "Numpy array of targets data."}, {"name": "image_data_generator", "is_optional": false, "type": "others", "description": "Instance of ImageDataGenerator\nto use for random transformations and normalization."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "32", "description": "Integer, size of a batch."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether to shuffle the data between epochs."}, {"name": "sample_weight", "is_optional": true, "type": "others", "default_value": "None", "description": "Numpy array of sample weights."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Random seed for data shuffling."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "String, one of channels_first, channels_last."}, {"name": "save_to_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional directory where to save the pictures\nbeing yielded, in a viewable format. This is useful\nfor visualizing the random transformations being\napplied, for debugging purposes."}, {"name": "save_prefix", "is_optional": true, "type": "string", "default_value": "''", "description": "String prefix to use for saving sample\nimages (if save_to_dir is set)."}, {"name": "save_format", "is_optional": true, "type": "string", "default_value": "'png'", "description": "Format to use for saving sample images\n(if save_to_dir is set)."}, {"name": "subset", "is_optional": true, "type": "others", "default_value": "None", "description": "Subset of data (\"training\" or \"validation\") if\nvalidation_split is set in ImageDataGenerator."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Dtype to use for the generated arrays."}]}},
{"id": "tf.keras.preprocessing.image.load_img", "type": "function", "code": "tf.keras.preprocessing.image.load_img(path,grayscale=False,color_mode='rgb',target_size=None,interpolation='nearest')", "summary": "Loads an image into PIL format.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.load_img", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "Path to image file."}, {"name": "grayscale", "is_optional": true, "type": "bool", "default_value": "False", "description": "DEPRECATED use `color_mode=\"grayscale\"`."}, {"name": "color_mode", "is_optional": true, "type": "string", "default_value": "'rgb'", "description": "One of \"grayscale\", \"rgb\", \"rgba\". Default: \"rgb\".\n    The desired image format."}, {"name": "target_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Either `None` (default to original size)\n    or tuple of ints `(img_height, img_width)`."}, {"name": "interpolation", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Interpolation method used to resample the image if the\n    target size is different from that of the loaded image.\n    Supported methods are \"nearest\", \"bilinear\", and \"bicubic\".\n    If PIL version 1.1.3 or newer is installed, \"lanczos\" is also\n    supported. If PIL version 3.4.0 or newer is installed, \"box\" and\n    \"hamming\" are also supported. By default, \"nearest\" is used."}]}},
{"id": "tf.keras.preprocessing.image.DirectoryIterator", "type": "class", "code": "tf.keras.preprocessing.image.DirectoryIterator(directory,image_data_generator,target_size=(256,256),color_mode='rgb',classes=None,class_mode='categorical',batch_size=32,shuffle=True,seed=None,data_format=None,save_to_dir=None,save_prefix='',save_format='png',follow_links=False,subset=None,interpolation='nearest',dtype=None)", "summary": "Iterator capable of reading images from a directory on disk.\n\nInherits From: Iterator", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.DirectoryIterator", "parameters": [{"name": "directory", "is_optional": false, "type": "others", "description": "Path to the directory to read images from.\nEach subdirectory in this directory will be\nconsidered to contain images from one class,\nor alternatively you could specify class subdirectories\nvia the classes argument."}, {"name": "image_data_generator", "is_optional": false, "type": "others", "description": "Instance of ImageDataGenerator\nto use for random transformations and normalization."}, {"name": "target_size", "is_optional": false, "type": "int", "description": "tuple of integers, dimensions to resize input images to.\ncolor_mode: One of \"rgb\", \"rgba\", \"grayscale\".\nColor mode to read images.\nclasses: Optional list of strings, names of subdirectories\ncontaining images from each class (e.g. [\"dogs\", \"cats\"]).\nIt will be computed automatically if not set.\nclass_mode: Mode for yielding the targets:\n\"binary\": binary targets (if there are only two classes),\n\"categorical\": categorical targets,\n\"sparse\": integer targets,\n\"input\": targets are images identical to input images (mainly\n    used to work with autoencoders),\nNone: no targets get yielded (only input images are yielded).\nbatch_size: Integer, size of a batch.\nshuffle: Boolean, whether to shuffle the data between epochs.\nseed: Random seed for data shuffling.\ndata_format: String, one of channels_first, channels_last.\nsave_to_dir: Optional directory where to save the pictures\nbeing yielded, in a viewable format. This is useful\nfor visualizing the random transformations being\napplied, for debugging purposes.\nsave_prefix: String prefix to use for saving sample\nimages (if save_to_dir is set).\nsave_format: Format to use for saving sample images\n(if save_to_dir is set).\nsubset: Subset of data (\"training\" or \"validation\") if\nvalidation_split is set in ImageDataGenerator.\ninterpolation: Interpolation method used to resample the image if the\ntarget size is different from that of the loaded image.\nSupported methods are \"nearest\", \"bilinear\", and \"bicubic\".\nIf PIL version 1.1.3 or newer is installed, \"lanczos\" is also\nsupported. If PIL version 3.4.0 or newer is installed, \"box\" and\n\"hamming\" are also supported. By default, \"nearest\" is used.\ndtype: Dtype to use for generated arrays."}]}},
{"id": "tf.keras.preprocessing.image.img_to_array", "type": "function", "code": "tf.keras.preprocessing.image.img_to_array(img,data_format=None,dtype=None)", "summary": "Converts a PIL Image instance to a Numpy array.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.img_to_array", "parameters": [{"name": "img", "is_optional": false, "type": "others", "description": "PIL Image instance."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Image data format,\neither \"channels_first\" or \"channels_last\"."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Dtype to use for the returned array."}]}},
{"id": "tf.keras.preprocessing.image.ImageDataGenerator", "type": "function", "code": "tf.keras.preprocessing.image.ImageDataGenerator(featurewise_center=False,samplewise_center=False,featurewise_std_normalization=False,samplewise_std_normalization=False,zca_whitening=False,zca_epsilon=1e-06,rotation_range=0,width_shift_range=0.0,height_shift_range=0.0,brightness_range=None,shear_range=0.0,zoom_range=0.0,channel_shift_range=0.0,fill_mode='nearest',cval=0.0,horizontal_flip=False,vertical_flip=False,rescale=None,preprocessing_function=None,data_format=None,validation_split=0.0,dtype=None)", "summary": "Generate batches of tensor image data with real-time data augmentation.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.ImageDataGenerator", "parameters": [{"name": "featurewise_center", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.\nSet input mean to 0 over the dataset, feature-wise."}, {"name": "samplewise_center", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Set each sample mean to 0."}, {"name": "featurewise_std_normalization", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.\nDivide inputs by std of the dataset, feature-wise."}, {"name": "samplewise_std_normalization", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Divide each input by its std.\nzca_epsilon: epsilon for ZCA whitening. Default is 1e-6."}, {"name": "zca_whitening", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Apply ZCA whitening.\nrotation_range: Int. Degree range for random rotations.\nwidth_shift_range: Float, 1-D array-like or int\n\nfloat: fraction of total width, if &lt; 1, or pixels if &gt;= 1.\n1-D array-like: random elements from the array.\nint: integer number of pixels from interval\n(-width_shift_range, +width_shift_range)\nWith width_shift_range=2 possible values\nare integers [-1, 0, +1],\nsame as with width_shift_range=[-1, 0, +1],\nwhile with width_shift_range=1.0 possible values are floats\nin the interval [-1.0, +1.0).\n\nheight_shift_range: Float, 1-D array-like or int\n\nfloat: fraction of total height, if &lt; 1, or pixels if &gt;= 1.\n1-D array-like: random elements from the array.\nint: integer number of pixels from interval\n(-height_shift_range, +height_shift_range)\nWith height_shift_range=2 possible values\nare integers [-1, 0, +1],\nsame as with height_shift_range=[-1, 0, +1],\nwhile with height_shift_range=1.0 possible values are floats\nin the interval [-1.0, +1.0).\n\nbrightness_range: Tuple or list of two floats. Range for picking\na brightness shift value from.\nshear_range: Float. Shear Intensity\n(Shear angle in counter-clockwise direction in degrees)\nzoom_range: Float or [lower, upper]. Range for random zoom.\nIf a float, [lower, upper] = [1-zoom_range, 1+zoom_range].\nchannel_shift_range: Float. Range for random channel shifts.\nfill_mode: One of {\"constant\", \"nearest\", \"reflect\" or \"wrap\"}.\nDefault is 'nearest'.\nPoints outside the boundaries of the input are filled\naccording to the given mode:\n\n'constant': kkkkkkkk|abcd|kkkkkkkk (cval=k)\n'nearest':  aaaaaaaa|abcd|dddddddd\n'reflect':  abcddcba|abcd|dcbaabcd\n'wrap':  abcdabcd|abcd|abcdabcd\n\ncval: Float or Int.\nValue used for points outside the boundaries\nwhen fill_mode = \"constant\".\nhorizontal_flip: Boolean. Randomly flip inputs horizontally.\nvertical_flip: Boolean. Randomly flip inputs vertically.\nrescale: rescaling factor. Defaults to None.\nIf None or 0, no rescaling is applied,\notherwise we multiply the data by the value provided\n(after applying all other transformations).\npreprocessing_function: function that will be applied on each input.\nThe function will run after the image is resized and augmented.\nThe function should take one argument:\none image (Numpy tensor with rank 3),\nand should output a Numpy tensor with the same shape.\ndata_format: Image data format,\neither \"channels_first\" or \"channels_last\".\n\"channels_last\" mode means that the images should have shape\n(samples, height, width, channels),\n\"channels_first\" mode means that the images should have shape\n(samples, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\nvalidation_split: Float. Fraction of images reserved for validation\n(strictly between 0 and 1).\ndtype: Dtype to use for the generated arrays.\n\n\nExamples:\n\nExample of using .flow(x, y):\n(x_train, y_train), (x_test, y_test) = cifar10.load_data()\ny_train = np_utils.to_categorical(y_train, num_classes)\ny_test = np_utils.to_categorical(y_test, num_classes)\ndatagen = ImageDataGenerator(\n    featurewise_center=True,\n    featurewise_std_normalization=True,\n    rotation_range=20,\n    width_shift_range=0.2,\n    height_shift_range=0.2,\n    horizontal_flip=True)\n# compute quantities required for featurewise normalization\n# (std, mean, and principal components if ZCA whitening is applied)\ndatagen.fit(x_train)\n# fits the model on batches with real-time data augmentation:\nmodel.fit_generator(datagen.flow(x_train, y_train, batch_size=32),\n                    steps_per_epoch=len(x_train) / 32, epochs=epochs)\n# here's a more \"manual\" example\nfor e in range(epochs):\n    print('Epoch', e)\n    batches = 0\n    for x_batch, y_batch in datagen.flow(x_train, y_train, batch_size=32):\n        model.fit(x_batch, y_batch)\n        batches += 1\n        if batches &gt;= len(x_train) / 32:\n            # we need to break the loop by hand because\n            # the generator loops indefinitely\n            break\n\nExample of using .flow_from_directory(directory):\ntrain_datagen = ImageDataGenerator(\n        rescale=1./255,\n        shear_range=0.2,\n        zoom_range=0.2,\n        horizontal_flip=True)\ntest_datagen = ImageDataGenerator(rescale=1./255)\ntrain_generator = train_datagen.flow_from_directory(\n        'data/train',\n        target_size=(150, 150),\n        batch_size=32,\n        class_mode='binary')\nvalidation_generator = test_datagen.flow_from_directory(\n        'data/validation',\n        target_size=(150, 150),\n        batch_size=32,\n        class_mode='binary')\nmodel.fit_generator(\n        train_generator,\n        steps_per_epoch=2000,\n        epochs=50,\n        validation_data=validation_generator,\n        validation_steps=800)\n\nExample of transforming images and masks together.\n# we create two instances with the same arguments\ndata_gen_args = dict(featurewise_center=True,\n                     featurewise_std_normalization=True,\n                     rotation_range=90,\n                     width_shift_range=0.1,\n                     height_shift_range=0.1,\n                     zoom_range=0.2)\nimage_datagen = ImageDataGenerator(**data_gen_args)\nmask_datagen = ImageDataGenerator(**data_gen_args)\n# Provide the same seed and keyword arguments to the fit and flow methods\nseed = 1\nimage_datagen.fit(images, augment=True, seed=seed)\nmask_datagen.fit(masks, augment=True, seed=seed)\nimage_generator = image_datagen.flow_from_directory(\n    'data/images',\n    class_mode=None,\n    seed=seed)\nmask_generator = mask_datagen.flow_from_directory(\n    'data/masks',\n    class_mode=None,\n    seed=seed)\n# combine generators into one which yields image and masks\ntrain_generator = zip(image_generator, mask_generator)\nmodel.fit_generator(\n    train_generator,\n    steps_per_epoch=2000,\n    epochs=50)\n\nMethods\n\napply_transform\napply_transform(\n    x, transform_parameters\n)\n\nApplies a transformation to an image according to given parameters.\n\nArguments\nx: 3D tensor, single image.\ntransform_parameters: Dictionary with string - parameter pairs\n    describing the transformation.\n    Currently, the following parameters\n    from the dictionary are used:\n    - `'theta'`: Float. Rotation angle in degrees.\n    - `'tx'`: Float. Shift in the x direction.\n    - `'ty'`: Float. Shift in the y direction.\n    - `'shear'`: Float. Shear angle in degrees.\n    - `'zx'`: Float. Zoom in the x direction.\n    - `'zy'`: Float. Zoom in the y direction.\n    - `'flip_horizontal'`: Boolean. Horizontal flip.\n    - `'flip_vertical'`: Boolean. Vertical flip.\n    - `'channel_shift_intencity'`: Float. Channel shift intensity.\n    - `'brightness'`: Float. Brightness shift intensity.\n\nReturns\nA transformed version of the input (same shape).\n\nfit\nfit(\n    x, augment=False, rounds=1, seed=None\n)\n\nFits the data generator to some sample data.\n\nThis computes the internal data stats related to the\ndata-dependent transformations, based on an array of sample data.\n\nOnly required if featurewise_center or\nfeaturewise_std_normalization or zca_whitening are set to True.\n\nArguments\nx: Sample data. Should have rank 4.\n In case of grayscale data,\n the channels axis should have value 1, in case\n of RGB data, it should have value 3, and in case\n of RGBA data, it should have value 4.\naugment: Boolean (default: False).\n    Whether to fit on randomly augmented samples.\nrounds: Int (default: 1).\n    If using data augmentation (`augment=True`),\n    this is how many augmentation passes over the data to use.\nseed: Int (default: None). Random seed.\n\nflow\nflow(\n    x, y=None, batch_size=32, shuffle=True, sample_weight=None, seed=None,\n    save_to_dir=None, save_prefix='', save_format='png', subset=None\n)\n\nTakes data &amp; label arrays, generates batches of augmented data.\n\nArguments\nx: Input data. Numpy array of rank 4 or a tuple.\n    If tuple, the first element\n    should contain the images and the second element\n    another numpy array or a list of numpy arrays\n    that gets passed to the output\n    without any modifications.\n    Can be used to feed the model miscellaneous data\n    along with the images.\n    In case of grayscale data, the channels axis of the image array\n    should have value 1, in case\n    of RGB data, it should have value 3, and in case\n    of RGBA data, it should have value 4.\ny: Labels.\nbatch_size: Int (default: 32).\nshuffle: Boolean (default: True).\nsample_weight: Sample weights.\nseed: Int (default: None).\nsave_to_dir: None or str (default: None).\n    This allows you to optionally specify a directory\n    to which to save the augmented pictures being generated\n    (useful for visualizing what you are doing).\nsave_prefix: Str (default: `''`).\n    Prefix to use for filenames of saved pictures\n    (only relevant if `save_to_dir` is set).\nsave_format: one of \"png\", \"jpeg\"\n    (only relevant if `save_to_dir` is set). Default: \"png\".\nsubset: Subset of data (`\"training\"` or `\"validation\"`) if\n    `validation_split` is set in `ImageDataGenerator`.\n\nReturns\nAn `Iterator` yielding tuples of `(x, y)`\n    where `x` is a numpy array of image data\n    (in the case of a single image input) or a list\n    of numpy arrays (in the case with\n    additional inputs) and `y` is a numpy array\n    of corresponding labels. If 'sample_weight' is not None,\n    the yielded tuples are of the form `(x, y, sample_weight)`.\n    If `y` is None, only the numpy array `x` is returned.\n\nflow_from_dataframe\nflow_from_dataframe(\n    dataframe, directory=None, x_col='filename', y_col='class', weight_col=None,\n    target_size=(256, 256), color_mode='rgb', classes=None,\n    class_mode='categorical', batch_size=32, shuffle=True, seed=None,\n    save_to_dir=None, save_prefix='', save_format='png', subset=None,\n    interpolation='nearest', validate_filenames=True, **kwargs\n)\n\nTakes the dataframe and the path to a directory\n and generates batches of augmented/normalized data.\n\n**A simple tutorial can be found **here.\n\nArguments\ndataframe: Pandas dataframe containing the filepaths relative to\n    `directory` (or absolute paths if `directory` is None) of the\n    images in a string column. It should include other column/s\n    depending on the `class_mode`:\n    - if `class_mode` is `\"categorical\"` (default value) it must\n        include the `y_col` column with the class/es of each image.\n        Values in column can be string/list/tuple if a single class\n        or list/tuple if multiple classes.\n    - if `class_mode` is `\"binary\"` or `\"sparse\"` it must include\n        the given `y_col` column with class values as strings.\n    - if `class_mode` is `\"raw\"` or `\"multi_output\"` it should contain\n    the columns specified in `y_col`.\n    - if `class_mode` is `\"input\"` or `None` no extra column is needed.\ndirectory: string, path to the directory to read images from. If `None`,\n    data in `x_col` column should be absolute paths.\nx_col: string, column in `dataframe` that contains the filenames (or\n    absolute paths if `directory` is `None`).\ny_col: string or list, column/s in `dataframe` that has the target data.\nweight_col: string, column in `dataframe` that contains the sample\n    weights. Default: `None`.\ntarget_size: tuple of integers `(height, width)`, default: `(256, 256)`.\n    The dimensions to which all images found will be resized.\ncolor_mode: one of \"grayscale\", \"rgb\", \"rgba\". Default: \"rgb\".\n    Whether the images will be converted to have 1 or 3 color channels.\nclasses: optional list of classes (e.g. `['dogs', 'cats']`).\n    Default: None. If not provided, the list of classes will be\n    automatically inferred from the `y_col`,\n    which will map to the label indices, will be alphanumeric).\n    The dictionary containing the mapping from class names to class\n    indices can be obtained via the attribute `class_indices`.\nclass_mode: one of \"binary\", \"categorical\", \"input\", \"multi_output\",\n    \"raw\", sparse\" or None. Default: \"categorical\".\n    Mode for yielding the targets:\n    - `\"binary\"`: 1D numpy array of binary labels,\n    - `\"categorical\"`: 2D numpy array of one-hot encoded labels.\n        Supports multi-label output.\n    - `\"input\"`: images identical to input images (mainly used to\n        work with autoencoders),\n    - `\"multi_output\"`: list with the values of the different columns,\n    - `\"raw\"`: numpy array of values in `y_col` column(s),\n    - `\"sparse\"`: 1D numpy array of integer labels,\n    - `None`, no targets are returned (the generator will only yield\n        batches of image data, which is useful to use in\n        `model.predict_generator()`).\nbatch_size: size of the batches of data (default: 32).\nshuffle: whether to shuffle the data (default: True)\nseed: optional random seed for shuffling and transformations.\nsave_to_dir: None or str (default: None).\n    This allows you to optionally specify a directory\n    to which to save the augmented pictures being generated\n    (useful for visualizing what you are doing).\nsave_prefix: str. Prefix to use for filenames of saved pictures\n    (only relevant if `save_to_dir` is set).\nsave_format: one of \"png\", \"jpeg\"\n    (only relevant if `save_to_dir` is set). Default: \"png\".\nfollow_links: whether to follow symlinks inside class subdirectories\n    (default: False).\nsubset: Subset of data (`\"training\"` or `\"validation\"`) if\n    `validation_split` is set in `ImageDataGenerator`.\ninterpolation: Interpolation method used to resample the image if the\n    target size is different from that of the loaded image.\n    Supported methods are `\"nearest\"`, `\"bilinear\"`, and `\"bicubic\"`.\n    If PIL version 1.1.3 or newer is installed, `\"lanczos\"` is also\n    supported. If PIL version 3.4.0 or newer is installed, `\"box\"` and\n    `\"hamming\"` are also supported. By default, `\"nearest\"` is used.\nvalidate_filenames: Boolean, whether to validate image filenames in\n    `x_col`. If `True`, invalid images will be ignored. Disabling this\n    option can lead to speed-up in the execution of this function.\n    Default: `True`.\n\nReturns\nA `DataFrameIterator` yielding tuples of `(x, y)`\nwhere `x` is a numpy array containing a batch\nof images with shape `(batch_size, *target_size, channels)`\nand `y` is a numpy array of corresponding labels.\n\nflow_from_directory\nflow_from_directory(\n    directory, target_size=(256, 256), color_mode='rgb', classes=None,\n    class_mode='categorical', batch_size=32, shuffle=True, seed=None,\n    save_to_dir=None, save_prefix='', save_format='png', follow_links=False,\n    subset=None, interpolation='nearest'\n)\n\nTakes the path to a directory &amp; generates batches of augmented data.\n\nArguments\ndirectory: string, path to the target directory.\n    It should contain one subdirectory per class.\n    Any PNG, JPG, BMP, PPM or TIF images\n    inside each of the subdirectories directory tree\n    will be included in the generator.\n    See [this script](\n    https://gist.github.com/fchollet/0830affa1f7f19fd47b06d4cf89ed44d)\n    for more details.\ntarget_size: Tuple of integers `(height, width)`,\n    default: `(256, 256)`.\n    The dimensions to which all images found will be resized.\ncolor_mode: One of \"grayscale\", \"rgb\", \"rgba\". Default: \"rgb\".\n    Whether the images will be converted to\n    have 1, 3, or 4 channels.\nclasses: Optional list of class subdirectories\n    (e.g. `['dogs', 'cats']`). Default: None.\n    If not provided, the list of classes will be automatically\n    inferred from the subdirectory names/structure\n    under `directory`, where each subdirectory will\n    be treated as a different class\n    (and the order of the classes, which will map to the label\n    indices, will be alphanumeric).\n    The dictionary containing the mapping from class names to class\n    indices can be obtained via the attribute `class_indices`.\nclass_mode: One of \"categorical\", \"binary\", \"sparse\",\n    \"input\", or None. Default: \"categorical\".\n    Determines the type of label arrays that are returned:\n    - \"categorical\" will be 2D one-hot encoded labels,\n    - \"binary\" will be 1D binary labels,\n        \"sparse\" will be 1D integer labels,\n    - \"input\" will be images identical\n        to input images (mainly used to work with autoencoders).\n    - If None, no labels are returned\n      (the generator will only yield batches of image data,\n      which is useful to use with `model.predict_generator()`).\n      Please note that in case of class_mode None,\n      the data still needs to reside in a subdirectory\n      of `directory` for it to work correctly.\nbatch_size: Size of the batches of data (default: 32).\nshuffle: Whether to shuffle the data (default: True)\n    If set to False, sorts the data in alphanumeric order.\nseed: Optional random seed for shuffling and transformations.\nsave_to_dir: None or str (default: None).\n    This allows you to optionally specify\n    a directory to which to save\n    the augmented pictures being generated\n    (useful for visualizing what you are doing).\nsave_prefix: Str. Prefix to use for filenames of saved pictures\n    (only relevant if `save_to_dir` is set).\nsave_format: One of \"png\", \"jpeg\"\n    (only relevant if `save_to_dir` is set). Default: \"png\".\nfollow_links: Whether to follow symlinks inside\n    class subdirectories (default: False).\nsubset: Subset of data (`\"training\"` or `\"validation\"`) if\n    `validation_split` is set in `ImageDataGenerator`.\ninterpolation: Interpolation method used to\n    resample the image if the\n    target size is different from that of the loaded image.\n    Supported methods are `\"nearest\"`, `\"bilinear\"`,\n    and `\"bicubic\"`.\n    If PIL version 1.1.3 or newer is installed, `\"lanczos\"` is also\n    supported. If PIL version 3.4.0 or newer is installed,\n    `\"box\"` and `\"hamming\"` are also supported.\n    By default, `\"nearest\"` is used.\n\nReturns\nA `DirectoryIterator` yielding tuples of `(x, y)`\n    where `x` is a numpy array containing a batch\n    of images with shape `(batch_size, *target_size, channels)`\n    and `y` is a numpy array of corresponding labels.\n\nget_random_transform\nget_random_transform(\n    img_shape, seed=None\n)\n\nGenerates random parameters for a transformation.\n\nArguments\nseed: Random seed.\nimg_shape: Tuple of integers.\n    Shape of the image that is transformed.\n\nReturns\nA dictionary containing randomly chosen parameters describing the\ntransformation.\n\nrandom_transform\nrandom_transform(\n    x, seed=None\n)\n\nApplies a random transformation to an image.\n\nArguments\nx: 3D tensor, single image.\nseed: Random seed.\n\nReturns\nA randomly transformed version of the input (same shape).\n\nstandardize\nstandardize(\n    x\n)\n\nApplies the normalization configuration in-place to a batch of inputs.\n\nx is changed in-place since the function is mainly used internally\nto standarize images and feed them to your network. If a copy of x\nwould be created instead it would have a significant performance cost.\nIf you want to apply this method without changing the input in-place\nyou can call the method creating a copy before:\n\nstandarize(np.copy(x))\n\nArguments\nx: Batch of inputs to be normalized.\n\nReturns\nThe inputs, normalized.\n\n\n          "}, {"name": "zca_epsilon", "is_optional": true, "type": "others", "default_value": "1e-06", "description": "epsilon for ZCA whitening. Default is 1e-6.\nzca_whitening: Boolean. Apply ZCA whitening."}, {"name": "rotation_range", "is_optional": true, "type": "int", "default_value": "0", "description": "Int. Degree range for random rotations."}, {"name": "width_shift_range", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float, 1-D array-like or int\n\nfloat: fraction of total width, if &lt; 1, or pixels if &gt;= 1.\n1-D array-like: random elements from the array.\nint: integer number of pixels from interval\n(-width_shift_range, +width_shift_range)\nWith width_shift_range=2 possible values\nare integers [-1, 0, +1],\nsame as with width_shift_range=[-1, 0, +1],\nwhile with width_shift_range=1.0 possible values are floats\nin the interval [-1.0, +1.0).\n"}, {"name": "height_shift_range", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float, 1-D array-like or int\n\nfloat: fraction of total height, if &lt; 1, or pixels if &gt;= 1.\n1-D array-like: random elements from the array.\nint: integer number of pixels from interval\n(-height_shift_range, +height_shift_range)\nWith height_shift_range=2 possible values\nare integers [-1, 0, +1],\nsame as with height_shift_range=[-1, 0, +1],\nwhile with height_shift_range=1.0 possible values are floats\nin the interval [-1.0, +1.0).\n"}, {"name": "brightness_range", "is_optional": true, "type": "float", "default_value": "None", "description": "Tuple or list of two floats. Range for picking\na brightness shift value from."}, {"name": "shear_range", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float. Shear Intensity\n(Shear angle in counter-clockwise direction in degrees)"}, {"name": "zoom_range", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float or [lower, upper]. Range for random zoom.\nIf a float, [lower, upper] = [1-zoom_range, 1+zoom_range]."}, {"name": "channel_shift_range", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float. Range for random channel shifts."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "One of {\"constant\", \"nearest\", \"reflect\" or \"wrap\"}.\nDefault is 'nearest'.\nPoints outside the boundaries of the input are filled\naccording to the given mode:\n\n'constant': kkkkkkkk|abcd|kkkkkkkk (cval=k)\n'nearest':  aaaaaaaa|abcd|dddddddd\n'reflect':  abcddcba|abcd|dcbaabcd\n'wrap':  abcdabcd|abcd|abcdabcd\n"}, {"name": "cval", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float or Int.\nValue used for points outside the boundaries\nwhen fill_mode = \"constant\"."}, {"name": "horizontal_flip", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Randomly flip inputs horizontally."}, {"name": "vertical_flip", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Randomly flip inputs vertically."}, {"name": "rescale", "is_optional": true, "type": "others", "default_value": "None", "description": "rescaling factor. Defaults to None.\nIf None or 0, no rescaling is applied,\notherwise we multiply the data by the value provided\n(after applying all other transformations)."}, {"name": "preprocessing_function", "is_optional": true, "type": "others", "default_value": "None", "description": "function that will be applied on each input.\nThe function will run after the image is resized and augmented.\nThe function should take one argument:\none image (Numpy tensor with rank 3),\nand should output a Numpy tensor with the same shape."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Image data format,\neither \"channels_first\" or \"channels_last\".\n\"channels_last\" mode means that the images should have shape\n(samples, height, width, channels),\n\"channels_first\" mode means that the images should have shape\n(samples, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}, {"name": "validation_split", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float. Fraction of images reserved for validation\n(strictly between 0 and 1)."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Dtype to use for the generated arrays."}]}},
{"id": "tf.keras.preprocessing.image.array_to_img", "type": "function", "code": "tf.keras.preprocessing.image.array_to_img(x,data_format=None,scale=True,dtype=None)", "summary": "Converts a 3D Numpy array to a PIL Image instance.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.array_to_img", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "Input Numpy array."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Image data format.\neither \"channels_first\" or \"channels_last\"."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to rescale image values\nto be within [0, 255]."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Dtype to use."}]}},
{"id": "tf.keras.preprocessing.image.apply_affine_transform", "type": "function", "code": "tf.keras.preprocessing.image.apply_affine_transform(x,theta=0,tx=0,ty=0,shear=0,zx=1,zy=1,row_axis=0,col_axis=1,channel_axis=2,fill_mode='nearest',cval=0.0,order=1)", "summary": "Applies an affine transformation specified by the parameters given.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.apply_affine_transform", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "2D numpy array, single image."}, {"name": "theta", "is_optional": true, "type": "int", "default_value": "0", "description": "Rotation angle in degrees."}, {"name": "tx", "is_optional": true, "type": "int", "default_value": "0", "description": "Width shift."}, {"name": "ty", "is_optional": true, "type": "int", "default_value": "0", "description": "Heigh shift."}, {"name": "shear", "is_optional": true, "type": "int", "default_value": "0", "description": "Shear angle in degrees."}, {"name": "zx", "is_optional": true, "type": "int", "default_value": "1", "description": "Zoom in x direction."}, {"name": "zy", "is_optional": true, "type": "int", "default_value": "1", "description": "Zoom in y direction"}, {"name": "row_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for rows in the input image."}, {"name": "col_axis", "is_optional": true, "type": "int", "default_value": "1", "description": "Index of axis for columns in the input image."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "2", "description": "Index of axis for channels in the input image."}, {"name": "fill_mode", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "Points outside the boundaries of the input\n    are filled according to the given mode\n    (one of `{'constant', 'nearest', 'reflect', 'wrap'}`)."}, {"name": "cval", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Value used for points outside the boundaries\n    of the input if `mode='constant'`."}, {"name": "order", "is_optional": true, "type": "int", "default_value": "1", "description": "int, order of interpolation"}]}},
{"id": "tf.keras.optimizers.schedules.PiecewiseConstantDecay", "type": "function", "code": "tf.keras.optimizers.schedules.PiecewiseConstantDecay(boundaries,values,name=None)", "summary": "A LearningRateSchedule that uses a piecewise constant decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.PiecewiseConstantDecay", "parameters": [{"name": "boundaries", "is_optional": false, "type": "tensor", "description": "A list of Tensors or ints or floats with strictly\nincreasing entries, and with all elements having the same type as the\noptimizer step."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensors or floats or ints that specifies the\nvalues for the intervals defined by boundaries. It should have one\nmore element than boundaries, and all elements should have the same\ntype."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Optional name of the operation. Defaults to\n'PiecewiseConstant'."}]}},
{"id": "tf.keras.optimizers.schedules.PolynomialDecay", "type": "function", "code": "tf.keras.optimizers.schedules.PolynomialDecay(initial_learning_rate,decay_steps,end_learning_rate=0.0001,power=1.0,cycle=False,name=None)", "summary": "A LearningRateSchedule that uses a polynomial decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.PolynomialDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nMust be positive.  See the decay computation above."}, {"name": "end_learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.0001", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The minimal end learning rate."}, {"name": "power", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The power of the polynomial. Defaults to linear, 1.0."}, {"name": "cycle", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether or not it should cycle beyond decay_steps."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation. Defaults to\n'PolynomialDecay'."}]}},
{"id": "tf.keras.optimizers.schedules.serialize", "type": "function", "code": "tf.keras.optimizers.schedules.serialize(learning_rate_schedule)", "summary": "", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.serialize", "parameters": [{"name": "learning_rate_schedule", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "__call__", "type": "function", "code": "__call__(step)", "summary": "A serializable learning rate decay schedule.", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "step", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.optimizers.schedules.InverseTimeDecay", "type": "function", "code": "tf.keras.optimizers.schedules.InverseTimeDecay(initial_learning_rate,decay_steps,decay_rate,staircase=False,name=None)", "summary": "A LearningRateSchedule that uses an inverse time decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.InverseTimeDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "others", "description": "How often to apply decay."}, {"name": "decay_rate", "is_optional": false, "type": "others", "description": "A Python number.  The decay rate."}, {"name": "staircase", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to apply decay in a discrete staircase, as opposed to\ncontinuous, fashion."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'InverseTimeDecay'."}]}},
{"id": "tf.keras.preprocessing.image.apply_channel_shift", "type": "function", "code": "tf.keras.preprocessing.image.apply_channel_shift(x,intensity,channel_axis=0)", "summary": "Performs a channel shift.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.apply_channel_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "intensity", "is_optional": false, "type": "others", "description": "Transformation intensity."}, {"name": "channel_axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Index of axis for channels in the input tensor."}]}},
{"id": "tf.keras.preprocessing.image.apply_brightness_shift", "type": "function", "code": "tf.keras.preprocessing.image.apply_brightness_shift(x,brightness)", "summary": "Performs a brightness shift.", "description": "", "code-info": {"name": "tf.keras.preprocessing.image.apply_brightness_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor. Must be 3D."}, {"name": "brightness", "is_optional": false, "type": "float", "description": "Float. The new brightness value.\nchannel_axis: Index of axis for channels in the input tensor."}]}},
{"id": "tf.keras.optimizers.schedules.deserialize", "type": "function", "code": "tf.keras.optimizers.schedules.deserialize(config,custom_objects=None)", "summary": "", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.keras.optimizers.schedules.ExponentialDecay", "type": "function", "code": "tf.keras.optimizers.schedules.ExponentialDecay(initial_learning_rate,decay_steps,decay_rate,staircase=False,name=None)", "summary": "A LearningRateSchedule that uses an exponential decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.optimizers.schedules.ExponentialDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nMust be positive.  See the decay computation above."}, {"name": "decay_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a\nPython number.  The decay rate."}, {"name": "staircase", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  If True decay the learning rate at discrete\nintervals"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'ExponentialDecay'."}]}},
{"id": "tf.keras.optimizers.SGD", "type": "class", "code": "tf.keras.optimizers.SGD(learning_rate=0.01,momentum=0.0,nesterov=False,name='SGD',**kwargs)", "summary": "Stochastic gradient descent and momentum optimizer.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.SGD", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "float", "default_value": "0.01", "description": "float hyperparameter &gt;= 0. Learning rate."}, {"name": "momentum", "is_optional": true, "type": "float", "default_value": "0.0", "description": "float hyperparameter &gt;= 0 that accelerates SGD in the relevant\ndirection and dampens oscillations."}, {"name": "nesterov", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean. Whether to apply Nesterov momentum."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'SGD'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to 'SGD'."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.RMSprop", "type": "class", "code": "tf.keras.optimizers.RMSprop(learning_rate=0.001,rho=0.9,momentum=0.0,epsilon=1e-07,centered=False,name='RMSprop',**kwargs)", "summary": "Optimizer that implements the RMSprop algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.RMSprop", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "rho", "is_optional": true, "type": "others", "default_value": "0.9", "description": "Discounting factor for the history/coming gradient"}, {"name": "momentum", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar tensor."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-07", "description": "Small value to avoid zero denominator."}, {"name": "centered", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, gradients are normalized by the estimated variance of\nthe gradient; if False, by the uncentered second moment. Setting this to\nTrue may help with training, but is slightly more expensive in terms of\ncomputation and memory. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'RMSprop'", "description": "Optional name prefix for the operations created when applying\ngradients. Defaults to \"RMSprop\".  @compatibility(eager) When eager\nexecution is enabled, learning_rate, decay, momentum, and\nepsilon can each be a callable that takes no arguments and returns the\nactual value to use. This can be useful for changing these values across\ndifferent invocations of optimizer functions. @end_compatibility"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.Optimizer", "type": "class", "code": "tf.keras.optimizers.Optimizer(name,**kwargs)", "summary": "Updated base class for optimizers.", "description": "", "code-info": {"name": "tf.keras.optimizers.Optimizer", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A non-empty string.  The name to use for accumulators created\nfor the optimizer."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.Nadam", "type": "class", "code": "tf.keras.optimizers.Nadam(learning_rate=0.001,beta_1=0.9,beta_2=0.999,epsilon=1e-07,name='Nadam',**kwargs)", "summary": "Optimizer that implements the NAdam algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Nadam", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "beta_1", "is_optional": true, "type": "tensor", "default_value": "0.9", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 1st moment estimates."}, {"name": "beta_2", "is_optional": true, "type": "tensor", "default_value": "0.999", "description": "A float value or a constant float tensor. The exponential decay\nrate for the exponentially weighted infinity norm."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-07", "description": "A small constant for numerical stability."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Nadam'", "description": "Optional name for the operations created when applying gradients.\nDefaults to \"Adamax\"."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.get", "type": "function", "code": "tf.keras.optimizers.get(identifier)", "summary": "Retrieves a Keras Optimizer instance.", "description": "", "code-info": {"name": "tf.keras.optimizers.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": "Optimizer identifier, one of"}]}},
{"id": "tf.keras.optimizers.Ftrl", "type": "class", "code": "tf.keras.optimizers.Ftrl(learning_rate=0.001,learning_rate_power=-0.5,initial_accumulator_value=0.1,l1_regularization_strength=0.0,l2_regularization_strength=0.0,name='Ftrl',l2_shrinkage_regularization_strength=0.0,**kwargs)", "summary": "Optimizer that implements the FTRL algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Ftrl", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A float value or a constant float Tensor."}, {"name": "learning_rate_power", "is_optional": true, "type": "float", "default_value": "-0.5", "description": "A float value, must be less or equal to zero.\nControls how the learning rate decreases during training. Use zero for\na fixed learning rate."}, {"name": "initial_accumulator_value", "is_optional": true, "type": "others", "default_value": "0.1", "description": "The starting value for accumulators.\nOnly zero or positive values are allowed."}, {"name": "l1_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "l2_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Ftrl\"."}, {"name": "l2_shrinkage_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than\nor equal to zero. This differs from L2 above in that the L2 above is a\nstabilization penalty, whereas this L2 shrinkage is a magnitude penalty.\nThe FTRL formulation can be written as:\nw_{t+1} = argminw(\\hat{g}{1:t}w + L1||w||_1 + L2||w||_2^2), where\n\\hat{g} = g + (2L2_shrinkagew), and g is the gradient of the loss\nfunction w.r.t. the weights w.\nSpecifically, in the absence of L1 regularization, it is equivalent to\nthe following update rule:\nw_{t+1} = w_t - lr_t / (1 + 2L2lr_t) * g_t -\n        2L2_shrinkagelr_t / (1 + 2L2lr_t) * w_t\nwhere lr_t is the learning rate at t.\nWhen input is sparse shrinkage will only happen on the active weights.\\"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.serialize", "type": "function", "code": "tf.keras.optimizers.serialize(optimizer)", "summary": "", "description": "", "code-info": {"name": "tf.keras.optimizers.serialize", "parameters": [{"name": "optimizer", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.optimizers.deserialize", "type": "function", "code": "tf.keras.optimizers.deserialize(config,custom_objects=None)", "summary": "Inverse of the serialize function.", "description": "", "code-info": {"name": "tf.keras.optimizers.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": "Optimizer configuration dictionary."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names (strings) to custom\nobjects (classes and functions) to be considered during deserialization."}]}},
{"id": "tf.keras.optimizers.Adamax", "type": "class", "code": "tf.keras.optimizers.Adamax(learning_rate=0.001,beta_1=0.9,beta_2=0.999,epsilon=1e-07,name='Adamax',**kwargs)", "summary": "Optimizer that implements the Adamax algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Adamax", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "beta_1", "is_optional": true, "type": "tensor", "default_value": "0.9", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 1st moment estimates."}, {"name": "beta_2", "is_optional": true, "type": "tensor", "default_value": "0.999", "description": "A float value or a constant float tensor. The exponential decay\nrate for the exponentially weighted infinity norm."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-07", "description": "A small constant for numerical stability."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adamax'", "description": "Optional name for the operations created when applying gradients.\nDefaults to \"Adamax\"."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.Adam", "type": "class", "code": "tf.keras.optimizers.Adam(learning_rate=0.001,beta_1=0.9,beta_2=0.999,epsilon=1e-07,amsgrad=False,name='Adam',**kwargs)", "summary": "Optimizer that implements the Adam algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Adam", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "beta_1", "is_optional": true, "type": "tensor", "default_value": "0.9", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 1st moment estimates."}, {"name": "beta_2", "is_optional": true, "type": "tensor", "default_value": "0.999", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 2nd moment estimates."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-07", "description": "A small constant for numerical stability. This epsilon is\n\"epsilon hat\" in the Kingma and Ba paper (in the formula just before\nSection 2.1), not the epsilon in Algorithm 1 of the paper."}, {"name": "amsgrad", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean. Whether to apply AMSGrad variant of this algorithm from\nthe paper \"On the Convergence of Adam and beyond\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adam'", "description": "Optional name for the operations created when applying gradients.\nDefaults to \"Adam\"."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.Adagrad", "type": "class", "code": "tf.keras.optimizers.Adagrad(learning_rate=0.001,initial_accumulator_value=0.1,epsilon=1e-07,name='Adagrad',**kwargs)", "summary": "Optimizer that implements the Adagrad algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Adagrad", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "initial_accumulator_value", "is_optional": true, "type": "float", "default_value": "0.1", "description": "A floating point value.\nStarting value for the accumulators, must be non-negative."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "1e-07", "description": "A small floating point value to avoid zero denominator."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Adagrad\"."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.optimizers.Adadelta", "type": "class", "code": "tf.keras.optimizers.Adadelta(learning_rate=0.001,rho=0.95,epsilon=1e-07,name='Adadelta',**kwargs)", "summary": "Optimizer that implements the Adadelta algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.optimizers.Adadelta", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value. The learning rate.\nTo match the exact form in the original paper use 1.0."}, {"name": "rho", "is_optional": true, "type": "tensor", "default_value": "0.95", "description": "A Tensor or a floating point value. The decay rate."}, {"name": "epsilon", "is_optional": true, "type": "tensor", "default_value": "1e-07", "description": "A Tensor or a floating point value.  A constant epsilon used\n     to better conditioning the grad update."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adadelta'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Adadelta\"."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword arguments. Allowed to be {clipnorm, clipvalue, lr,\ndecay}. clipnorm is clip gradients by norm; clipvalue is clip\ngradients by value, decay is included for backward compatibility to\nallow time inverse decay of learning rate. lr is included for backward\ncompatibility, recommended to use learning_rate instead."}]}},
{"id": "tf.keras.models.model_from_yaml", "type": "function", "code": "tf.keras.models.model_from_yaml(yaml_string,custom_objects=None)", "summary": "Parses a yaml model configuration file and returns a model instance.", "description": "", "code-info": {"name": "tf.keras.models.model_from_yaml", "parameters": [{"name": "yaml_string", "is_optional": false, "type": "string", "description": "YAML string encoding a model configuration."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names\n(strings) to custom classes or functions to be\nconsidered during deserialization."}]}},
{"id": "tf.keras.models.model_from_json", "type": "function", "code": "tf.keras.models.model_from_json(json_string,custom_objects=None)", "summary": "Parses a JSON model configuration file and returns a model instance.", "description": "", "code-info": {"name": "tf.keras.models.model_from_json", "parameters": [{"name": "json_string", "is_optional": false, "type": "string", "description": "JSON string encoding a model configuration."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names\n(strings) to custom classes or functions to be\nconsidered during deserialization."}]}},
{"id": "tf.keras.models.save_model", "type": "function", "code": "tf.keras.models.save_model(model,filepath,overwrite=True,include_optimizer=True,save_format=None,signatures=None,options=None)", "summary": "Saves a model as a TensorFlow SavedModel or HDF5 file.", "description": "", "code-info": {"name": "tf.keras.models.save_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "Keras model instance to be saved."}, {"name": "filepath", "is_optional": false, "type": "string", "description": "One of the following:\n\nString, path where to save the model\nh5py.File object where to save the model\n"}, {"name": "overwrite", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether we should overwrite any existing model at the target\nlocation, or instead ask the user with a manual prompt."}, {"name": "include_optimizer", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, save optimizer's state together."}, {"name": "save_format", "is_optional": true, "type": "others", "default_value": "None", "description": "Either 'tf' or 'h5', indicating whether to save the model\nto Tensorflow SavedModel or HDF5. Defaults to 'tf' in TF 2.X, and 'h5'\nin TF 1.X."}, {"name": "signatures", "is_optional": true, "type": "others", "default_value": "None", "description": "Signatures to save with the SavedModel. Applicable to the 'tf'\nformat only. Please see the signatures argument in\ntf.saved_model.save for details."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tf.saved_model.SaveOptions object that specifies\noptions for saving to SavedModel."}]}},
{"id": "tf.keras.models.model_from_config", "type": "function", "code": "tf.keras.models.model_from_config(config,custom_objects=None)", "summary": "Instantiates a Keras model from its config.", "description": "", "code-info": {"name": "tf.keras.models.model_from_config", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": "Configuration dictionary."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names\n(strings) to custom classes or functions to be\nconsidered during deserialization."}]}},
{"id": "tf.keras.models.load_model", "type": "function", "code": "tf.keras.models.load_model(filepath,custom_objects=None,compile=True)", "summary": "Loads a model saved via save_model.", "description": "", "code-info": {"name": "tf.keras.models.load_model", "parameters": [{"name": "filepath", "is_optional": false, "type": "string", "description": "One of the following:\n\nString, path to the saved model\nh5py.File object from which to load the model\n"}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names\n(strings) to custom classes or functions to be\nconsidered during deserialization."}, {"name": "compile", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether to compile the model\nafter loading."}]}},
{"id": "tf.keras.mixed_precision.experimental.LossScaleOptimizer", "type": "class", "code": "tf.keras.mixed_precision.experimental.LossScaleOptimizer(optimizer,loss_scale)", "summary": "An optimizer that applies loss scaling.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.keras.mixed_precision.experimental.LossScaleOptimizer", "parameters": [{"name": "optimizer", "is_optional": false, "type": "others", "description": "The Optimizer instance to wrap."}, {"name": "loss_scale", "is_optional": false, "type": "others", "description": "The loss scale to scale the loss and gradients. This can\neither be an int/float to use a fixed loss scale, the string \"dynamic\"\nto use dynamic loss scaling, or an instance of a LossScale. The string\n\"dynamic\" equivalent to passing DynamicLossScale(), and passing an\nint/float is equivalent to passing a FixedLossScale with the given loss\nscale."}]}},
{"id": "tf.keras.models.clone_model", "type": "function", "code": "tf.keras.models.clone_model(model,input_tensors=None,clone_function=None)", "summary": "Clone any Model instance.", "description": "", "code-info": {"name": "tf.keras.models.clone_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "Instance of Model\n(could be a functional model or a Sequential model)."}, {"name": "input_tensors", "is_optional": true, "type": "tensor", "default_value": "None", "description": "optional list of input tensors or InputLayer objects\nto build the model upon. If not provided,\nplaceholders will be created."}, {"name": "clone_function", "is_optional": true, "type": "others", "default_value": "None", "description": "Callable to be used to clone each layer in the target\nmodel (except InputLayer instances). It takes as argument the layer\ninstance to be cloned, and returns the corresponding layer instance to\nbe used in the model copy. If unspecified, this callable defaults to\nthe following serialization/deserialization function:\nlambda layer: layer.__class__.from_config(layer.get_config()).\nBy passing a custom callable, you can customize your copy of the\nmodel, e.g. by wrapping certain layers of interest (you might want to\nreplace all LSTM instances with equivalent\nBidirectional(LSTM(...)) instances, for example)."}]}},
{"id": "tf.keras.mixed_precision.experimental.set_policy", "type": "function", "code": "tf.keras.mixed_precision.experimental.set_policy(policy)", "summary": "Sets the global Policy.", "description": "", "code-info": {"name": "tf.keras.mixed_precision.experimental.set_policy", "parameters": [{"name": "policy", "is_optional": false, "type": "string", "description": "A Policy, or a string that will be converted to a Policy.."}]}},
{"id": "tf.keras.metrics.TrueNegatives", "type": "function", "code": "tf.keras.metrics.TrueNegatives(thresholds=None,name=None,dtype=None)", "summary": "Calculates the number of true negatives.", "description": "", "code-info": {"name": "tf.keras.metrics.TrueNegatives", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) Defaults to 0.5. A float value or a python\nlist/tuple of float threshold values in [0, 1]. A threshold is compared\nwith prediction values to determine the truth value of predictions\n(i.e., above the threshold is true, below is false). One metric\nvalue is generated for each threshold value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.mixed_precision.experimental.Policy", "type": "class", "code": "tf.keras.mixed_precision.experimental.Policy(name,loss_scale=USE_DEFAULT)", "summary": "A dtype policy for a Keras layer.", "description": "", "code-info": {"name": "tf.keras.mixed_precision.experimental.Policy", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A string. Can be one of the following values:\n\nAny dtype name, such as 'float32' or 'float64'. Both the variable and\ncompute dtypes will be that dtype.\n'mixed_float16' or 'mixed_bfloat16': The compute dtype is float16 or\nbfloat16, while the variable dtype is float32. With 'mixed_float16',\na dynamic loss scale is used. These policies are used for mixed\nprecision training.\n'infer' (deprecated): Infer the compute and variable dtype from the\ninput dtype.\n"}, {"name": "loss_scale", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "A tf.mixed_precision.experimental.LossScale, an int (which\nuses a FixedLossScale), or the string \"dynamic\" (which uses a\nDynamicLossScale). Defaults to using no loss scaling unless name is\n\"mixed_float16\", in which case this defaults to \"dynamic\". Only\ntf.keras.Models, not layers, use the loss scale, and it is only used\nduring Model.fit, Model.train_on_batch, and other similar methods."}]}},
{"id": "tf.keras.metrics.top_k_categorical_accuracy", "type": "function", "code": "tf.keras.metrics.top_k_categorical_accuracy(y_true,y_pred,k=5)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.top_k_categorical_accuracy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}, {"name": "k", "is_optional": true, "type": "int", "default_value": "5", "description": ""}]}},
{"id": "tf.keras.metrics.TruePositives", "type": "function", "code": "tf.keras.metrics.TruePositives(thresholds=None,name=None,dtype=None)", "summary": "Calculates the number of true positives.", "description": "", "code-info": {"name": "tf.keras.metrics.TruePositives", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) Defaults to 0.5. A float value or a python\nlist/tuple of float threshold values in [0, 1]. A threshold is compared\nwith prediction values to determine the truth value of predictions\n(i.e., above the threshold is true, below is false). One metric\nvalue is generated for each threshold value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.mixed_precision.experimental.global_policy", "type": "function", "code": "tf.keras.mixed_precision.experimental.global_policy()", "summary": "Returns the global Policy.", "description": "", "code-info": {"name": "tf.keras.mixed_precision.experimental.global_policy", "parameters": []}},
{"id": "tf.keras.metrics.Sum", "type": "function", "code": "tf.keras.metrics.Sum(name='sum',dtype=None)", "summary": "Computes the (weighted) sum of the given values.", "description": "", "code-info": {"name": "tf.keras.metrics.Sum", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.TopKCategoricalAccuracy", "type": "function", "code": "tf.keras.metrics.TopKCategoricalAccuracy(k=5,name='top_k_categorical_accuracy',dtype=None)", "summary": "Computes how often targets are in the top K predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.TopKCategoricalAccuracy", "parameters": [{"name": "k", "is_optional": true, "type": "int", "default_value": "5", "description": "(Optional) Number of top elements to look at for computing accuracy.\nDefaults to 5."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'top_k_categorical_accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.sparse_categorical_accuracy", "type": "function", "code": "tf.keras.metrics.sparse_categorical_accuracy(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.sparse_categorical_accuracy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.metrics.SparseTopKCategoricalAccuracy", "type": "function", "code": "tf.keras.metrics.SparseTopKCategoricalAccuracy(k=5,name='sparse_top_k_categorical_accuracy',dtype=None)", "summary": "Computes how often integer targets are in the top K predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.SparseTopKCategoricalAccuracy", "parameters": [{"name": "k", "is_optional": true, "type": "int", "default_value": "5", "description": "(Optional) Number of top elements to look at for computing accuracy.\nDefaults to 5."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sparse_top_k_categorical_accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.SquaredHinge", "type": "function", "code": "tf.keras.metrics.SquaredHinge(name='squared_hinge',dtype=None)", "summary": "Computes the squared hinge metric between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.SquaredHinge", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'squared_hinge'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.SpecificityAtSensitivity", "type": "function", "code": "tf.keras.metrics.SpecificityAtSensitivity(sensitivity,num_thresholds=200,name=None,dtype=None)", "summary": "Computes the specificity at a given sensitivity.", "description": "", "code-info": {"name": "tf.keras.metrics.SpecificityAtSensitivity", "parameters": [{"name": "sensitivity", "is_optional": false, "type": "float", "description": "A scalar value in range [0, 1]."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "(Optional) Defaults to 200. The number of thresholds to\nuse for matching the given sensitivity."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.sparse_top_k_categorical_accuracy", "type": "function", "code": "tf.keras.metrics.sparse_top_k_categorical_accuracy(y_true,y_pred,k=5)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.sparse_top_k_categorical_accuracy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}, {"name": "k", "is_optional": true, "type": "int", "default_value": "5", "description": ""}]}},
{"id": "tf.keras.metrics.serialize", "type": "function", "code": "tf.keras.metrics.serialize(metric)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.serialize", "parameters": [{"name": "metric", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.metrics.SensitivityAtSpecificity", "type": "function", "code": "tf.keras.metrics.SensitivityAtSpecificity(specificity,num_thresholds=200,name=None,dtype=None)", "summary": "Computes the sensitivity at a given specificity.", "description": "", "code-info": {"name": "tf.keras.metrics.SensitivityAtSpecificity", "parameters": [{"name": "specificity", "is_optional": false, "type": "float", "description": "A scalar value in range [0, 1]."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "(Optional) Defaults to 200. The number of thresholds to\nuse for matching the given specificity."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.RootMeanSquaredError", "type": "function", "code": "tf.keras.metrics.RootMeanSquaredError(name='root_mean_squared_error',dtype=None)", "summary": "Computes root mean squared error metric between y_true and y_pred.\n\nInherits From: Mean", "description": "", "code-info": {"name": "tf.keras.metrics.RootMeanSquaredError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'root_mean_squared_error'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.SparseCategoricalAccuracy", "type": "function", "code": "tf.keras.metrics.SparseCategoricalAccuracy(name='sparse_categorical_accuracy',dtype=None)", "summary": "Calculates how often predictions matches integer labels.", "description": "", "code-info": {"name": "tf.keras.metrics.SparseCategoricalAccuracy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'sparse_categorical_accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.Precision", "type": "function", "code": "tf.keras.metrics.Precision(thresholds=None,top_k=None,class_id=None,name=None,dtype=None)", "summary": "Computes the precision of the predictions with respect to the labels.\n\nInherits From: Metric", "description": "", "code-info": {"name": "tf.keras.metrics.Precision", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) A float value or a python list/tuple of float\nthreshold values in [0, 1]. A threshold is compared with prediction\nvalues to determine the truth value of predictions (i.e., above the\nthreshold is true, below is false). One metric value is generated\nfor each threshold value. If neither thresholds nor top_k are set, the\ndefault is to calculate precision with thresholds=0.5."}, {"name": "top_k", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) Unset by default. An int value specifying the top-k\npredictions to consider when calculating precision."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "(Optional) Integer class ID for which we want binary metrics.\nThis must be in the half-open interval [0, num_classes), where\nnum_classes is the last dimension of predictions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.SparseCategoricalCrossentropy", "type": "function", "code": "tf.keras.metrics.SparseCategoricalCrossentropy(name='sparse_categorical_crossentropy',dtype=None,from_logits=False,axis=-1)", "summary": "Computes the crossentropy metric between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.SparseCategoricalCrossentropy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'sparse_categorical_crossentropy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional ) Whether y_pred is expected to be a logits tensor.\nBy default, we assume that y_pred encodes a probability distribution."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "(Optional) Defaults to -1. The dimension along which the metric is\ncomputed."}]}},
{"id": "tf.keras.metrics.Recall", "type": "function", "code": "tf.keras.metrics.Recall(thresholds=None,top_k=None,class_id=None,name=None,dtype=None)", "summary": "Computes the recall of the predictions with respect to the labels.\n\nInherits From: Metric", "description": "", "code-info": {"name": "tf.keras.metrics.Recall", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) A float value or a python list/tuple of float\nthreshold values in [0, 1]. A threshold is compared with prediction\nvalues to determine the truth value of predictions (i.e., above the\nthreshold is true, below is false). One metric value is generated\nfor each threshold value. If neither thresholds nor top_k are set, the\ndefault is to calculate recall with thresholds=0.5."}, {"name": "top_k", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) Unset by default. An int value specifying the top-k\npredictions to consider when calculating recall."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "(Optional) Integer class ID for which we want binary metrics.\nThis must be in the half-open interval [0, num_classes), where\nnum_classes is the last dimension of predictions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.PrecisionAtRecall", "type": "function", "code": "tf.keras.metrics.PrecisionAtRecall(recall,num_thresholds=200,name=None,dtype=None)", "summary": "Computes the precision at a given recall.", "description": "", "code-info": {"name": "tf.keras.metrics.PrecisionAtRecall", "parameters": [{"name": "recall", "is_optional": false, "type": "float", "description": "A scalar value in range [0, 1]."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "(Optional) Defaults to 200. The number of thresholds to\nuse for matching the given recall."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.Poisson", "type": "function", "code": "tf.keras.metrics.Poisson(name='poisson',dtype=None)", "summary": "Computes the Poisson metric between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.Poisson", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'poisson'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.MeanSquaredError", "type": "function", "code": "tf.keras.metrics.MeanSquaredError(name='mean_squared_error',dtype=None)", "summary": "Computes the mean squared error between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.MeanSquaredError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_squared_error'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.Metric", "type": "function", "code": "tf.keras.metrics.Metric(name=None,dtype=None,**kwargs)", "summary": "Encapsulates metric logic and state.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.metrics.Metric", "parameters": [{"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.metrics.MeanTensor", "type": "class", "code": "tf.keras.metrics.MeanTensor(name='mean_tensor',dtype=None)", "summary": "Computes the element-wise (weighted) mean of the given tensors.\n\nInherits From: Metric", "description": "", "code-info": {"name": "tf.keras.metrics.MeanTensor", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_tensor'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.MeanSquaredLogarithmicError", "type": "function", "code": "tf.keras.metrics.MeanSquaredLogarithmicError(name='mean_squared_logarithmic_error',dtype=None)", "summary": "Computes the mean squared logarithmic error between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.MeanSquaredLogarithmicError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_squared_logarithmic_error'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.MeanRelativeError", "type": "function", "code": "tf.keras.metrics.MeanRelativeError(normalizer,name=None,dtype=None)", "summary": "Computes the mean relative error by normalizing with the given values.\n\nInherits From: Mean", "description": "", "code-info": {"name": "tf.keras.metrics.MeanRelativeError", "parameters": [{"name": "normalizer", "is_optional": false, "type": "others", "description": "The normalizer values with same shape as predictions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.MeanAbsolutePercentageError", "type": "function", "code": "tf.keras.metrics.MeanAbsolutePercentageError(name='mean_absolute_percentage_error',dtype=None)", "summary": "Computes the mean absolute percentage error between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.MeanAbsolutePercentageError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_absolute_percentage_error'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.MeanAbsoluteError", "type": "function", "code": "tf.keras.metrics.MeanAbsoluteError(name='mean_absolute_error',dtype=None)", "summary": "Computes the mean absolute error between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.MeanAbsoluteError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_absolute_error'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.Mean", "type": "function", "code": "tf.keras.metrics.Mean(name='mean',dtype=None)", "summary": "Computes the (weighted) mean of the given values.", "description": "", "code-info": {"name": "tf.keras.metrics.Mean", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.LogCoshError", "type": "function", "code": "tf.keras.metrics.LogCoshError(name='logcosh',dtype=None)", "summary": "Computes the logarithm of the hyperbolic cosine of the prediction error.", "description": "", "code-info": {"name": "tf.keras.metrics.LogCoshError", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'logcosh'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.KLDivergence", "type": "function", "code": "tf.keras.metrics.KLDivergence(name='kullback_leibler_divergence',dtype=None)", "summary": "Computes Kullback-Leibler divergence metric between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.KLDivergence", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'kullback_leibler_divergence'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.MeanIoU", "type": "function", "code": "tf.keras.metrics.MeanIoU(num_classes,name=None,dtype=None)", "summary": "Computes the mean Intersection-Over-Union metric.\n\nInherits From: Metric", "description": "", "code-info": {"name": "tf.keras.metrics.MeanIoU", "parameters": [{"name": "num_classes", "is_optional": false, "type": "others", "description": "The possible number of labels the prediction task can have.\nThis value must be provided, since a confusion matrix of dimension =\n[num_classes, num_classes] will be allocated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.FalseNegatives", "type": "function", "code": "tf.keras.metrics.FalseNegatives(thresholds=None,name=None,dtype=None)", "summary": "Calculates the number of false negatives.", "description": "", "code-info": {"name": "tf.keras.metrics.FalseNegatives", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) Defaults to 0.5. A float value or a python\nlist/tuple of float threshold values in [0, 1]. A threshold is compared\nwith prediction values to determine the truth value of predictions\n(i.e., above the threshold is true, below is false). One metric\nvalue is generated for each threshold value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.deserialize", "type": "function", "code": "tf.keras.metrics.deserialize(config,custom_objects=None)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.keras.metrics.CosineSimilarity", "type": "function", "code": "tf.keras.metrics.CosineSimilarity(name='cosine_similarity',dtype=None,axis=-1)", "summary": "Computes the cosine similarity between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.CosineSimilarity", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'cosine_similarity'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "(Optional) Defaults to -1. The dimension along which the cosine\nsimilarity is computed."}]}},
{"id": "tf.keras.metrics.categorical_accuracy", "type": "function", "code": "tf.keras.metrics.categorical_accuracy(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.categorical_accuracy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.metrics.Hinge", "type": "function", "code": "tf.keras.metrics.Hinge(name='hinge',dtype=None)", "summary": "Computes the hinge metric between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.Hinge", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'hinge'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.CategoricalHinge", "type": "function", "code": "tf.keras.metrics.CategoricalHinge(name='categorical_hinge',dtype=None)", "summary": "Computes the categorical hinge metric between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.metrics.CategoricalHinge", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'categorical_hinge'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.metrics.get", "type": "function", "code": "tf.keras.metrics.get(identifier)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.metrics.FalsePositives", "type": "function", "code": "tf.keras.metrics.FalsePositives(thresholds=None,name=None,dtype=None)", "summary": "Calculates the number of false positives.", "description": "", "code-info": {"name": "tf.keras.metrics.FalsePositives", "parameters": [{"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) Defaults to 0.5. A float value or a python\nlist/tuple of float threshold values in [0, 1]. A threshold is compared\nwith prediction values to determine the truth value of predictions\n(i.e., above the threshold is true, below is false). One metric\nvalue is generated for each threshold value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.CategoricalCrossentropy", "type": "function", "code": "tf.keras.metrics.CategoricalCrossentropy(name='categorical_crossentropy',dtype=None,from_logits=False,label_smoothing=0)", "summary": "Computes the crossentropy metric between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.CategoricalCrossentropy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'categorical_crossentropy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional ) Whether y_pred is expected to be a logits tensor.\nBy default, we assume that y_pred encodes a probability distribution."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "Float in [0, 1]. When &gt; 0, label values are smoothed,\nmeaning the confidence on label values are relaxed. e.g.\nlabel_smoothing=0.2 means that we will use a value of 0.1 for label\n0 and 0.9 for label 1\""}]}},
{"id": "tf.keras.metrics.CategoricalAccuracy", "type": "function", "code": "tf.keras.metrics.CategoricalAccuracy(name='categorical_accuracy',dtype=None)", "summary": "Calculates how often predictions matches labels.", "description": "", "code-info": {"name": "tf.keras.metrics.CategoricalAccuracy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'categorical_accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}]}},
{"id": "tf.keras.metrics.binary_accuracy", "type": "function", "code": "tf.keras.metrics.binary_accuracy(y_true,y_pred,threshold=0.5)", "summary": "", "description": "", "code-info": {"name": "tf.keras.metrics.binary_accuracy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}, {"name": "threshold", "is_optional": true, "type": "others", "default_value": "0.5", "description": ""}]}},
{"id": "tf.keras.metrics.BinaryCrossentropy", "type": "function", "code": "tf.keras.metrics.BinaryCrossentropy(name='binary_crossentropy',dtype=None,from_logits=False,label_smoothing=0)", "summary": "Computes the crossentropy metric between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.metrics.BinaryCrossentropy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'binary_crossentropy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional )Whether output is expected to be a logits tensor.\nBy default, we consider that output encodes a probability distribution."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "(Optional) Float in [0, 1]. When &gt; 0, label values are\nsmoothed, meaning the confidence on label values are relaxed.\ne.g. label_smoothing=0.2 means that we will use a value of 0.1 for\nlabel 0 and 0.9 for label 1\""}]}},
{"id": "tf.keras.metrics.BinaryAccuracy", "type": "function", "code": "tf.keras.metrics.BinaryAccuracy(name='binary_accuracy',dtype=None,threshold=0.5)", "summary": "Calculates how often predictions matches labels.", "description": "", "code-info": {"name": "tf.keras.metrics.BinaryAccuracy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'binary_accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "(Optional) Float representing the threshold for deciding\nwhether prediction values are 1 or 0."}]}},
{"id": "tf.keras.metrics.AUC", "type": "function", "code": "tf.keras.metrics.AUC(num_thresholds=200,curve='ROC',summation_method='interpolation',name=None,dtype=None,thresholds=None,multi_label=False,label_weights=None)", "summary": "Computes the approximate AUC (Area under the curve) via a Riemann sum.\n\nInherits From: Metric", "description": "", "code-info": {"name": "tf.keras.metrics.AUC", "parameters": [{"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "(Optional) Defaults to 200. The number of thresholds to\nuse when discretizing the roc curve. Values must be &gt; 1."}, {"name": "curve", "is_optional": true, "type": "string", "default_value": "'ROC'", "description": "(Optional) Specifies the name of the curve to be computed, 'ROC'\n[default] or 'PR' for the Precision-Recall-curve."}, {"name": "summation_method", "is_optional": true, "type": "string", "default_value": "'interpolation'", "description": "(Optional) Specifies the Riemann summation method used\n(https://en.wikipedia.org/wiki/Riemann_sum): 'interpolation' [default],\napplies mid-point summation scheme for ROC. For PR-AUC, interpolates\n(true/false) positives but not the ratio that is precision (see Davis\n&amp; Goadrich 2006 for details); 'minoring' that applies left summation\nfor increasing intervals and right summation for decreasing intervals;\n'majoring' that does the opposite."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result."}, {"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional) A list of floating point values to use as the\nthresholds for discretizing the curve. If set, the num_thresholds\nparameter is ignored. Values should be in [0, 1]. Endpoint thresholds\nequal to {-epsilon, 1+epsilon} for a small positive epsilon value will\nbe automatically included with these to correctly handle predictions\nequal to exactly 0 or 1."}, {"name": "multi_label", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean indicating whether multilabel data should be\ntreated as such, wherein AUC is computed separately for each label and\nthen averaged across labels, or (when False) if the data should be\nflattened into a single label before AUC computation. In the latter\ncase, when multilabel data is passed to AUC, each label-prediction pair\nis treated as an individual data point. Should be set to False for\nmulti-class data."}, {"name": "label_weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) list, array, or tensor of non-negative weights\nused to compute AUCs for multilabel data. When multi_label is True,\nthe weights are applied to the individual label AUCs when they are\naveraged to produce the multi-label AUC. When it's False, they are used\nto weight the individual label predictions in computing the confusion\nmatrix on the flattened data. Note that this is unlike class_weights in\nthat class_weights weights the example depending on the value of its\nlabel, whereas label_weights depends only on the index of that label\nbefore flattening; therefore label_weights should not be used for\nmulti-class data."}]}},
{"id": "tf.keras.metrics.Accuracy", "type": "function", "code": "tf.keras.metrics.Accuracy(name='accuracy',dtype=None)", "summary": "Calculates how often predictions matches labels.", "description": "", "code-info": {"name": "tf.keras.metrics.Accuracy", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'accuracy'", "description": "(Optional) string name of the metric instance."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) data type of the metric result.\n**kwargs: The keyword arguments that are passed on to fn."}]}},
{"id": "tf.keras.losses.SparseCategoricalCrossentropy", "type": "function", "code": "tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False,reduction=losses_utils.ReductionV2.AUTO,name='sparse_categorical_crossentropy')", "summary": "Computes the crossentropy loss between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.losses.SparseCategoricalCrossentropy", "parameters": [{"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether y_pred is expected to be a logits tensor. By default,\nwe assume that y_pred encodes a probability distribution.\nNote: Using from_logits=True may be more numerically stable."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sparse_categorical_crossentropy'", "description": "Optional name for the op."}]}},
{"id": "tf.keras.losses.poisson", "type": "function", "code": "tf.keras.losses.poisson(y_true,y_pred)", "summary": "Computes the Poisson loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.poisson", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "Tensor of true targets."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "Tensor of predicted targets."}]}},
{"id": "tf.keras.losses.squared_hinge", "type": "function", "code": "tf.keras.losses.squared_hinge(y_true,y_pred)", "summary": "Computes the squared hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.squared_hinge", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": "The ground truth values. y_true values are expected to be -1 or 1.\nIf binary (0 or 1) labels are provided we will convert them to -1 or 1."}, {"name": "y_pred", "is_optional": false, "type": "others", "description": "The predicted values."}]}},
{"id": "tf.keras.losses.serialize", "type": "function", "code": "tf.keras.losses.serialize(loss)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.serialize", "parameters": [{"name": "loss", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.Poisson", "type": "function", "code": "tf.keras.losses.Poisson(reduction=losses_utils.ReductionV2.AUTO,name='poisson')", "summary": "Computes the Poisson loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.Poisson", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'poisson'", "description": ""}]}},
{"id": "tf.keras.losses.sparse_categorical_crossentropy", "type": "function", "code": "tf.keras.losses.sparse_categorical_crossentropy(y_true,y_pred,from_logits=False,axis=-1)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.sparse_categorical_crossentropy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": ""}]}},
{"id": "tf.keras.losses.MSE", "type": "function", "code": "tf.keras.losses.MSE(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.MSE", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.MeanSquaredLogarithmicError", "type": "function", "code": "tf.keras.losses.MeanSquaredLogarithmicError(reduction=losses_utils.ReductionV2.AUTO,name='mean_squared_logarithmic_error')", "summary": "Computes the mean squared logarithmic error between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.MeanSquaredLogarithmicError", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_squared_logarithmic_error'", "description": ""}]}},
{"id": "tf.keras.losses.SquaredHinge", "type": "function", "code": "tf.keras.losses.SquaredHinge(reduction=losses_utils.ReductionV2.AUTO,name='squared_hinge')", "summary": "Computes the squared hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.SquaredHinge", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'squared_hinge'", "description": ""}]}},
{"id": "tf.keras.losses.MAPE", "type": "function", "code": "tf.keras.losses.MAPE(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.MAPE", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.MSLE", "type": "function", "code": "tf.keras.losses.MSLE(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.MSLE", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.MeanSquaredError", "type": "function", "code": "tf.keras.losses.MeanSquaredError(reduction=losses_utils.ReductionV2.AUTO,name='mean_squared_error')", "summary": "Computes the mean of squares of errors between labels and predictions.", "description": "", "code-info": {"name": "tf.keras.losses.MeanSquaredError", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_squared_error'", "description": ""}]}},
{"id": "tf.keras.losses.MeanAbsolutePercentageError", "type": "function", "code": "tf.keras.losses.MeanAbsolutePercentageError(reduction=losses_utils.ReductionV2.AUTO,name='mean_absolute_percentage_error')", "summary": "Computes the mean absolute percentage error between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.MeanAbsolutePercentageError", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_absolute_percentage_error'", "description": ""}]}},
{"id": "tf.keras.losses.MeanAbsoluteError", "type": "function", "code": "tf.keras.losses.MeanAbsoluteError(reduction=losses_utils.ReductionV2.AUTO,name='mean_absolute_error')", "summary": "Computes the mean of absolute difference between labels and predictions.", "description": "", "code-info": {"name": "tf.keras.losses.MeanAbsoluteError", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'mean_absolute_error'", "description": ""}]}},
{"id": "tf.keras.losses.Loss", "type": "function", "code": "tf.keras.losses.Loss(reduction=losses_utils.ReductionV2.AUTO,name=None)", "summary": "Loss base class.", "description": "", "code-info": {"name": "tf.keras.losses.Loss", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}]}},
{"id": "tf.keras.losses.logcosh", "type": "function", "code": "tf.keras.losses.logcosh(y_true,y_pred)", "summary": "Logarithm of the hyperbolic cosine of the prediction error.", "description": "", "code-info": {"name": "tf.keras.losses.logcosh", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "tensor of true targets."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "tensor of predicted targets."}]}},
{"id": "tf.keras.losses.KLDivergence", "type": "function", "code": "tf.keras.losses.KLDivergence(reduction=losses_utils.ReductionV2.AUTO,name='kullback_leibler_divergence')", "summary": "Computes Kullback-Leibler divergence loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.KLDivergence", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'kullback_leibler_divergence'", "description": ""}]}},
{"id": "tf.keras.losses.KLD", "type": "function", "code": "tf.keras.losses.KLD(y_true,y_pred)", "summary": "Computes Kullback-Leibler divergence loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.KLD", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "Tensor of true targets."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "Tensor of predicted targets."}]}},
{"id": "tf.keras.losses.Huber", "type": "function", "code": "tf.keras.losses.Huber(delta=1.0,reduction=losses_utils.ReductionV2.AUTO,name='huber_loss')", "summary": "Computes the Huber loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.Huber", "parameters": [{"name": "delta", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A float, the point where the Huber loss function changes from a\nquadratic to linear."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'huber_loss'", "description": "Optional name for the op."}]}},
{"id": "tf.keras.losses.MAE", "type": "function", "code": "tf.keras.losses.MAE(y_true,y_pred)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.MAE", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.hinge", "type": "function", "code": "tf.keras.losses.hinge(y_true,y_pred)", "summary": "Computes the hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.hinge", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": "The ground truth values. y_true values are expected to be -1 or 1.\nIf binary (0 or 1) labels are provided they will be converted to -1 or 1."}, {"name": "y_pred", "is_optional": false, "type": "others", "description": "The predicted values."}]}},
{"id": "tf.keras.losses.LogCosh", "type": "function", "code": "tf.keras.losses.LogCosh(reduction=losses_utils.ReductionV2.AUTO,name='logcosh')", "summary": "Computes the logarithm of the hyperbolic cosine of the prediction error.", "description": "", "code-info": {"name": "tf.keras.losses.LogCosh", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'logcosh'", "description": ""}]}},
{"id": "tf.keras.losses.Hinge", "type": "function", "code": "tf.keras.losses.Hinge(reduction=losses_utils.ReductionV2.AUTO,name='hinge')", "summary": "Computes the hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.Hinge", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'hinge'", "description": ""}]}},
{"id": "tf.keras.losses.CosineSimilarity", "type": "function", "code": "tf.keras.losses.CosineSimilarity(axis=-1,reduction=losses_utils.ReductionV2.AUTO,name='cosine_similarity')", "summary": "Computes the cosine similarity between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.CosineSimilarity", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "(Optional) Defaults to -1. The dimension along which the cosine\nsimilarity is computed."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'cosine_similarity'", "description": "Optional name for the op."}]}},
{"id": "tf.keras.losses.CategoricalCrossentropy", "type": "function", "code": "tf.keras.losses.CategoricalCrossentropy(from_logits=False,label_smoothing=0,reduction=losses_utils.ReductionV2.AUTO,name='categorical_crossentropy')", "summary": "Computes the crossentropy loss between the labels and predictions.", "description": "", "code-info": {"name": "tf.keras.losses.CategoricalCrossentropy", "parameters": [{"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether y_pred is expected to be a logits tensor. By default,\nwe assume that y_pred encodes a probability distribution.\nNote: Using from_logits=True may be more numerically stable."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "Float in [0, 1]. When &gt; 0, label values are smoothed,\nmeaning the confidence on label values are relaxed. e.g.\nlabel_smoothing=0.2 means that we will use a value of 0.1 for label\n0 and 0.9 for label 1\""}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'categorical_crossentropy'", "description": "Optional name for the op."}]}},
{"id": "tf.keras.losses.get", "type": "function", "code": "tf.keras.losses.get(identifier)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.losses.categorical_crossentropy", "type": "function", "code": "tf.keras.losses.categorical_crossentropy(y_true,y_pred,from_logits=False,label_smoothing=0)", "summary": "Computes the categorical crossentropy loss.", "description": "", "code-info": {"name": "tf.keras.losses.categorical_crossentropy", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "tensor of true targets."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "tensor of predicted targets."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether y_pred is expected to be a logits tensor. By default,\nwe assume that y_pred encodes a probability distribution."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "Float in [0, 1]. If &gt; 0 then smooth the labels."}]}},
{"id": "tf.keras.losses.CategoricalHinge", "type": "function", "code": "tf.keras.losses.CategoricalHinge(reduction=losses_utils.ReductionV2.AUTO,name='categorical_hinge')", "summary": "Computes the categorical hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.CategoricalHinge", "parameters": [{"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'categorical_hinge'", "description": ""}]}},
{"id": "tf.keras.losses.deserialize", "type": "function", "code": "tf.keras.losses.deserialize(name,custom_objects=None)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.deserialize", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.keras.losses.BinaryCrossentropy", "type": "function", "code": "tf.keras.losses.BinaryCrossentropy(from_logits=False,label_smoothing=0,reduction=losses_utils.ReductionV2.AUTO,name='binary_crossentropy')", "summary": "Computes the cross-entropy loss between true labels and predicted labels.", "description": "", "code-info": {"name": "tf.keras.losses.BinaryCrossentropy", "parameters": [{"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to interpret y_pred as a tensor of\nlogit values. By default, we assume\nthat y_pred contains probabilities (i.e., values in [0, 1]).\nNote: Using from_logits=True may be more numerically stable."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "Float in [0, 1]. When 0, no smoothing occurs. When &gt; 0, we\ncompute the loss between the predicted labels and a smoothed version of\nthe true labels, where the smoothing squeezes the labels towards 0.5.\nLarger values of label_smoothing correspond to heavier smoothing."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.AUTO", "description": "(Optional) Type of tf.keras.losses.Reduction to apply to loss.\nDefault value is AUTO. AUTO indicates that the reduction option will\nbe determined by the usage context. For almost all cases this defaults to\nSUM_OVER_BATCH_SIZE.\nWhen used with tf.distribute.Strategy, outside of built-in training\nloops such as tf.keras compile and fit, using AUTO or\nSUM_OVER_BATCH_SIZE will raise an error. Please see\nhttps://www.tensorflow.org/tutorials/distribute/custom_training\nfor more details on this."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'binary_crossentropy'", "description": "(Optional) Name for the op."}]}},
{"id": "tf.keras.losses.cosine_similarity", "type": "function", "code": "tf.keras.losses.cosine_similarity(y_true,y_pred,axis=-1)", "summary": "Computes the cosine similarity between labels and predictions.", "description": "", "code-info": {"name": "tf.keras.losses.cosine_similarity", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "Tensor of true targets."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "Tensor of predicted targets."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Axis along which to determine similarity."}]}},
{"id": "tf.keras.losses.binary_crossentropy", "type": "function", "code": "tf.keras.losses.binary_crossentropy(y_true,y_pred,from_logits=False,label_smoothing=0)", "summary": "", "description": "", "code-info": {"name": "tf.keras.losses.binary_crossentropy", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": ""}, {"name": "y_pred", "is_optional": false, "type": "others", "description": ""}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": ""}]}},
{"id": "tf.keras.losses.categorical_hinge", "type": "function", "code": "tf.keras.losses.categorical_hinge(y_true,y_pred)", "summary": "Computes the categorical hinge loss between y_true and y_pred.", "description": "", "code-info": {"name": "tf.keras.losses.categorical_hinge", "parameters": [{"name": "y_true", "is_optional": false, "type": "others", "description": "The ground truth values. y_true values are expected to be -1 or 1.\nIf binary (0 or 1) labels are provided they will be converted to -1 or 1."}, {"name": "y_pred", "is_optional": false, "type": "others", "description": "The predicted values."}]}},
{"id": "tf.keras.layers.experimental.preprocessing.PreprocessingLayer", "type": "function", "code": "tf.keras.layers.experimental.preprocessing.PreprocessingLayer(trainable=True,name=None,dtype=None,dynamic=False,**kwargs)", "summary": "Base class for PreprocessingLayers.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.experimental.preprocessing.PreprocessingLayer", "parameters": [{"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dynamic", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.experimental.preprocessing.Normalization", "type": "function", "code": "tf.keras.layers.experimental.preprocessing.Normalization(axis=-1,dtype=None,**kwargs)", "summary": "Feature-wise normalization of the data.", "description": "", "code-info": {"name": "tf.keras.layers.experimental.preprocessing.Normalization", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Wrapper", "type": "function", "code": "tf.keras.layers.Wrapper(layer,**kwargs)", "summary": "Abstract wrapper base class.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Wrapper", "parameters": [{"name": "layer", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.UpSampling3D", "type": "function", "code": "tf.keras.layers.UpSampling3D(size=(2,2,2),data_format=None,**kwargs)", "summary": "Upsampling layer for 3D inputs.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.UpSampling3D", "parameters": [{"name": "size", "is_optional": false, "type": "int", "description": "Int, or tuple of 3 integers.\nThe upsampling factors for dim1, dim2 and dim3.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)\nwhile channels_first corresponds to inputs with shape\n(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}]}},
{"id": "tf.keras.layers.ZeroPadding3D", "type": "function", "code": "tf.keras.layers.ZeroPadding3D(padding=(1,1,1),data_format=None,**kwargs)", "summary": "Zero-padding layer for 3D data (spatial or spatio-temporal).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ZeroPadding3D", "parameters": [{"name": "padding", "is_optional": false, "type": "others", "description": "Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints."}]}},
{"id": "tf.keras.layers.ZeroPadding2D", "type": "function", "code": "tf.keras.layers.ZeroPadding2D(padding=(1,1),data_format=None,**kwargs)", "summary": "Zero-padding layer for 2D input (e.g. picture).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ZeroPadding2D", "parameters": [{"name": "padding", "is_optional": false, "type": "others", "description": "Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints."}]}},
{"id": "tf.keras.layers.ZeroPadding1D", "type": "function", "code": "tf.keras.layers.ZeroPadding1D(padding=1,**kwargs)", "summary": "Zero-padding layer for 1D input (e.g. temporal sequence).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ZeroPadding1D", "parameters": [{"name": "padding", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.experimental.preprocessing.TextVectorization", "type": "function", "code": "tf.keras.layers.experimental.preprocessing.TextVectorization(max_tokens=None,standardize=LOWER_AND_STRIP_PUNCTUATION,split=SPLIT_ON_WHITESPACE,ngrams=None,output_mode=INT,output_sequence_length=None,pad_to_max_tokens=True,**kwargs)", "summary": "Text vectorization layer.", "description": "", "code-info": {"name": "tf.keras.layers.experimental.preprocessing.TextVectorization", "parameters": [{"name": "max_tokens", "is_optional": true, "type": "others", "default_value": "None", "description": "The maximum size of the vocabulary for this layer. If None,\nthere is no cap on the size of the vocabulary."}, {"name": "standardize", "is_optional": true, "type": "others", "default_value": "LOWER_AND_STRIP_PUNCTUATION", "description": "Optional specification for standardization to apply to the\ninput text. Values can be None (no standardization),\n'lower_and_strip_punctuation' (lowercase and remove punctuation) or a\nCallable. Default is 'lower_and_strip_punctuation'."}, {"name": "split", "is_optional": true, "type": "others", "default_value": "SPLIT_ON_WHITESPACE", "description": "Optional specification for splitting the input text. Values can be\nNone (no splitting), 'whitespace' (split on ASCII whitespace), or a\nCallable. The default is 'whitespace'."}, {"name": "ngrams", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional specification for ngrams to create from the possibly-split\ninput text. Values can be None, an integer or tuple of integers; passing\nan integer will create ngrams up to that integer, and passing a tuple of\nintegers will create ngrams for the specified values in the tuple. Passing\nNone means that no ngrams will be created."}, {"name": "output_mode", "is_optional": true, "type": "others", "default_value": "INT", "description": "Optional specification for the output of the layer. Values can\nbe \"int\", \"binary\", \"count\" or \"tf-idf\", configuring the layer as follows:\n\"int\": Outputs integer indices, one integer index per split string\n  token.\n\"binary\": Outputs a single int array per batch, of either vocab_size or\n  max_tokens size, containing 1s in all elements where the token mapped\n  to that index exists at least once in the batch item.\n\"count\": As \"binary\", but the int array contains a count of the number\n  of times the token at that index appeared in the batch item.\n\"tf-idf\": As \"binary\", but the TF-IDF algorithm is applied to find the\n  value in each token slot."}, {"name": "output_sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "Only valid in INT mode. If set, the output will have\nits time dimension padded or truncated to exactly output_sequence_length\nvalues, resulting in a tensor of shape [batch_size,\noutput_sequence_length] regardless of how many tokens resulted from the\nsplitting step. Defaults to None."}, {"name": "pad_to_max_tokens", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.UpSampling2D", "type": "function", "code": "tf.keras.layers.UpSampling2D(size=(2,2),data_format=None,interpolation='nearest',**kwargs)", "summary": "Upsampling layer for 2D inputs.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.UpSampling2D", "parameters": [{"name": "size", "is_optional": false, "type": "int", "description": "Int, or tuple of 2 integers.\nThe upsampling factors for rows and columns.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ninterpolation: A string, one of nearest or bilinear."}]}},
{"id": "tf.keras.layers.SpatialDropout2D", "type": "function", "code": "tf.keras.layers.SpatialDropout2D(rate,data_format=None,**kwargs)", "summary": "Spatial 2D version of Dropout.\n\nInherits From: Dropout", "description": "", "code-info": {"name": "tf.keras.layers.SpatialDropout2D", "parameters": [{"name": "rate", "is_optional": false, "type": "float", "description": "Float between 0 and 1. Fraction of the input units to drop."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.UpSampling1D", "type": "function", "code": "tf.keras.layers.UpSampling1D(size=2,**kwargs)", "summary": "Upsampling layer for 1D inputs.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.UpSampling1D", "parameters": [{"name": "size", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Subtract", "type": "function", "code": "tf.keras.layers.Subtract(**kwargs)", "summary": "Layer that subtracts two inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Subtract", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.SpatialDropout3D", "type": "function", "code": "tf.keras.layers.SpatialDropout3D(rate,data_format=None,**kwargs)", "summary": "Spatial 3D version of Dropout.\n\nInherits From: Dropout", "description": "", "code-info": {"name": "tf.keras.layers.SpatialDropout3D", "parameters": [{"name": "rate", "is_optional": false, "type": "float", "description": "Float between 0 and 1. Fraction of the input units to drop."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.TimeDistributed", "type": "function", "code": "tf.keras.layers.TimeDistributed(layer,**kwargs)", "summary": "This wrapper allows to apply a layer to every temporal slice of an input.\n\nInherits From: Wrapper", "description": "", "code-info": {"name": "tf.keras.layers.TimeDistributed", "parameters": [{"name": "layer", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.subtract", "type": "function", "code": "tf.keras.layers.subtract(inputs,**kwargs)", "summary": "Functional interface to the Subtract layer.", "description": "", "code-info": {"name": "tf.keras.layers.subtract", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (exactly 2)."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.StackedRNNCells", "type": "function", "code": "tf.keras.layers.StackedRNNCells(cells,**kwargs)", "summary": "Wrapper allowing a stack of RNN cells to behave as a single cell.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.StackedRNNCells", "parameters": [{"name": "cells", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.SpatialDropout1D", "type": "function", "code": "tf.keras.layers.SpatialDropout1D(rate,**kwargs)", "summary": "Spatial 1D version of Dropout.\n\nInherits From: Dropout", "description": "", "code-info": {"name": "tf.keras.layers.SpatialDropout1D", "parameters": [{"name": "rate", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.ThresholdedReLU", "type": "function", "code": "tf.keras.layers.ThresholdedReLU(theta=1.0,**kwargs)", "summary": "Thresholded Rectified Linear Unit.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ThresholdedReLU", "parameters": [{"name": "theta", "is_optional": true, "type": "others", "default_value": "1.0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Softmax", "type": "function", "code": "tf.keras.layers.Softmax(axis=-1,**kwargs)", "summary": "Softmax activation function.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Softmax", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.RNN", "type": "function", "code": "tf.keras.layers.RNN(cell,return_sequences=False,return_state=False,go_backwards=False,stateful=False,unroll=False,time_major=False,**kwargs)", "summary": "Base class for recurrent layers.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.RNN", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "A RNN cell instance or a list of RNN cell instances.\nA RNN cell is a class that has:\n\nA call(input_at_t, states_at_t) method, returning\n(output_at_t, states_at_t_plus_1). The call method of the\ncell can also take the optional argument constants, see\nsection \"Note on passing external constants\" below.\nA state_size attribute. This can be a single integer\n(single state) in which case it is the size of the recurrent\nstate. This can also be a list/tuple of integers (one size per state).\nThe state_size can also be TensorShape or tuple/list of\nTensorShape, to represent high dimension state.\nA output_size attribute. This can be a single integer or a\nTensorShape, which represent the shape of the output. For backward\ncompatible reason, if this attribute is not available for the\ncell, the value will be inferred by the first element of the\nstate_size.\nA get_initial_state(inputs=None, batch_size=None, dtype=None)\nmethod that creates a tensor meant to be fed to call() as the\ninitial state, if the user didn't specify any initial state via other\nmeans. The returned initial state should have a shape of\n[batch_size, cell.state_size]. The cell might choose to create a\ntensor full of zeros, or full of other values based on the cell's\nimplementation.\ninputs is the input tensor to the RNN layer, which should\ncontain the batch size as its shape[0], and also dtype. Note that\nthe shape[0] might be None during the graph construction. Either\nthe inputs or the pair of batch_size and dtype are provided.\nbatch_size is a scalar tensor that represents the batch size\nof the inputs. dtype is tf.DType that represents the dtype of\nthe inputs.\nFor backward compatible reason, if this method is not implemented\nby the cell, the RNN layer will create a zero filled tensor with the\nsize of [batch_size, cell.state_size].\nIn the case that cell is a list of RNN cell instances, the cells\nwill be stacked on top of each other in the RNN, resulting in an\nefficient stacked RNN.\n"}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). Whether to return the last\noutput in the output sequence, or the full sequence."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). Whether to return the last state\nin addition to the output."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, process the input sequence backwards and return the\nreversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, the network will be unrolled, else a symbolic loop will be used.\nUnrolling can speed-up a RNN, although it tends to be more\nmemory-intensive. Unrolling is only suitable for short sequences."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.serialize", "type": "function", "code": "tf.keras.layers.serialize(layer)", "summary": "", "description": "", "code-info": {"name": "tf.keras.layers.serialize", "parameters": [{"name": "layer", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.SeparableConv2D", "type": "function", "code": "tf.keras.layers.SeparableConv2D(filters,kernel_size,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1),depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer='glorot_uniform',pointwise_initializer='glorot_uniform',bias_initializer='zeros',depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,**kwargs)", "summary": "Depthwise separable 2D convolution.", "description": "", "code-info": {"name": "tf.keras.layers.SeparableConv2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: An integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any strides value != 1.\ndepth_multiplier: The number of depthwise convolution output channels\nfor each input channel.\nThe total number of depthwise convolution output\nchannels will be equal to filters_in * depth_multiplier.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\ndepthwise_initializer: Initializer for the depthwise kernel matrix.\npointwise_initializer: Initializer for the pointwise kernel matrix.\nbias_initializer: Initializer for the bias vector.\ndepthwise_regularizer: Regularizer function applied to\nthe depthwise kernel matrix.\npointwise_regularizer: Regularizer function applied to\nthe pointwise kernel matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\")..\ndepthwise_constraint: Constraint function applied to\nthe depthwise kernel matrix.\npointwise_constraint: Constraint function applied to\nthe pointwise kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.SimpleRNNCell", "type": "function", "code": "tf.keras.layers.SimpleRNNCell(units,activation='tanh',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,**kwargs)", "summary": "Cell class for SimpleRNN.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.SimpleRNNCell", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs. Default:\nglorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix, used for the linear transformation of the recurrent state.\nDefault: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix. Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs. Default: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "others", "default_value": "0.0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.SeparableConv1D", "type": "function", "code": "tf.keras.layers.SeparableConv1D(filters,kernel_size,strides=1,padding='valid',data_format=None,dilation_rate=1,depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer='glorot_uniform',pointwise_initializer='glorot_uniform',bias_initializer='zeros',depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,**kwargs)", "summary": "Depthwise separable 1D convolution.", "description": "", "code-info": {"name": "tf.keras.layers.SeparableConv1D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A single integer specifying the spatial\ndimensions of the filters."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer specifying the strides\nof the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\", \"same\", or \"causal\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1."}, {"name": "depth_multiplier", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of depthwise convolution output channels for\neach input channel. The total number of depthwise convolution output\nchannels will be equal to num_filters_in * depth_multiplier."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "depthwise_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "An initializer for the depthwise convolution kernel."}, {"name": "pointwise_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "An initializer for the pointwise convolution kernel."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "An initializer for the bias vector. If None, the default\ninitializer will be used."}, {"name": "depthwise_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the depthwise\nconvolution kernel."}, {"name": "pointwise_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the pointwise\nconvolution kernel."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer function for the output."}, {"name": "depthwise_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional projection function to be applied to the\ndepthwise kernel after being updated by an Optimizer (e.g. used for\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training."}, {"name": "pointwise_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional projection function to be applied to the\npointwise kernel after being updated by an Optimizer."}, {"name": "bias_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.SimpleRNN", "type": "function", "code": "tf.keras.layers.SimpleRNN(units,activation='tanh',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,return_sequences=False,return_state=False,go_backwards=False,stateful=False,unroll=False,**kwargs)", "summary": "Fully-connected RNN where the output is to be fed back to input.\n\nInherits From: RNN", "description": "", "code-info": {"name": "tf.keras.layers.SimpleRNN", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs. Default:\nglorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix, used for the linear transformation of the recurrent state.\nDefault: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the output of the\nlayer (its \"activation\"). Default: None."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix.  Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for the linear transformation of the inputs.\nDefault: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for the linear transformation of the\nrecurrent state. Default: 0."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output\nin the output sequence, or the full sequence. Default: False."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state\nin addition to the output. Default: False"}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, process the input sequence backwards and return the\nreversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Reshape", "type": "function", "code": "tf.keras.layers.Reshape(target_shape,**kwargs)", "summary": "Reshapes an output to a certain shape.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Reshape", "parameters": [{"name": "target_shape", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.ReLU", "type": "function", "code": "tf.keras.layers.ReLU(max_value=None,negative_slope=0,threshold=0,**kwargs)", "summary": "Rectified Linear Unit activation function.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ReLU", "parameters": [{"name": "max_value", "is_optional": true, "type": "float", "default_value": "None", "description": "Float &gt;= 0. Maximum activation value."}, {"name": "negative_slope", "is_optional": true, "type": "int", "default_value": "0", "description": "Float &gt;= 0. Negative slope coefficient."}, {"name": "threshold", "is_optional": true, "type": "int", "default_value": "0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.RepeatVector", "type": "function", "code": "tf.keras.layers.RepeatVector(n,**kwargs)", "summary": "Repeats the input n times.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.RepeatVector", "parameters": [{"name": "n", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.PReLU", "type": "function", "code": "tf.keras.layers.PReLU(alpha_initializer='zeros',alpha_regularizer=None,alpha_constraint=None,shared_axes=None,**kwargs)", "summary": "Parametric Rectified Linear Unit.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.PReLU", "parameters": [{"name": "alpha_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer function for the weights."}, {"name": "alpha_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer for the weights."}, {"name": "alpha_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint for the weights."}, {"name": "shared_axes", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Permute", "type": "function", "code": "tf.keras.layers.Permute(dims,**kwargs)", "summary": "Permutes the dimensions of the input according to a given pattern.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Permute", "parameters": [{"name": "dims", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.multiply", "type": "function", "code": "tf.keras.layers.multiply(inputs,**kwargs)", "summary": "Functional interface to the Multiply layer.", "description": "", "code-info": {"name": "tf.keras.layers.multiply", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.Multiply", "type": "function", "code": "tf.keras.layers.Multiply(**kwargs)", "summary": "Layer that multiplies (element-wise) a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Multiply", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.MaxPool1D", "type": "function", "code": "tf.keras.layers.MaxPool1D(pool_size=2,strides=None,padding='valid',data_format='channels_last',**kwargs)", "summary": "Max pooling operation for temporal data.", "description": "", "code-info": {"name": "tf.keras.layers.MaxPool1D", "parameters": [{"name": "pool_size", "is_optional": true, "type": "int", "default_value": "2", "description": "Integer, size of the max pooling windows."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, or None. Factor by which to downscale.\nE.g. 2 will halve the input.\nIf None, it will default to pool_size."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.MaxPool2D", "type": "function", "code": "tf.keras.layers.MaxPool2D(pool_size=(2,2),strides=None,padding='valid',data_format=None,**kwargs)", "summary": "Max pooling operation for spatial data.", "description": "", "code-info": {"name": "tf.keras.layers.MaxPool2D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "integer or tuple of 2 integers,\nfactors by which to downscale (vertical, horizontal).\n(2, 2) will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.\nstrides: Integer, tuple of 2 integers, or None.\nStrides values.\nIf None, it will default to pool_size.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}]}},
{"id": "tf.keras.layers.Masking", "type": "function", "code": "tf.keras.layers.Masking(mask_value=0.0,**kwargs)", "summary": "Masks a sequence by using a mask value to skip timesteps.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Masking", "parameters": [{"name": "mask_value", "is_optional": true, "type": "others", "default_value": "0.0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.MaxPool3D", "type": "function", "code": "tf.keras.layers.MaxPool3D(pool_size=(2,2,2),strides=None,padding='valid',data_format=None,**kwargs)", "summary": "Max pooling operation for 3D data (spatial or spatio-temporal).", "description": "", "code-info": {"name": "tf.keras.layers.MaxPool3D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "Tuple of 3 integers,\nfactors by which to downscale (dim1, dim2, dim3).\n(2, 2, 2) will halve the size of the 3D input in each dimension.\nstrides: tuple of 3 integers, or None. Strides values.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)\nwhile channels_first corresponds to inputs with shape\n(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}]}},
{"id": "tf.keras.layers.Maximum", "type": "function", "code": "tf.keras.layers.Maximum(**kwargs)", "summary": "Layer that computes the maximum (element-wise) a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Maximum", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.minimum", "type": "function", "code": "tf.keras.layers.minimum(inputs,**kwargs)", "summary": "Functional interface to the Minimum layer.", "description": "", "code-info": {"name": "tf.keras.layers.minimum", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.LSTM", "type": "function", "code": "tf.keras.layers.LSTM(units,activation='tanh',recurrent_activation='sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=2,return_sequences=False,return_state=False,go_backwards=False,stateful=False,time_major=False,unroll=False,**kwargs)", "summary": "Long Short-Term Memory layer - Hochreiter 1997.\n\nInherits From: LSTM", "description": "", "code-info": {"name": "tf.keras.layers.LSTM", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh). If you pass None, no activation\nis applied (ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'sigmoid'", "description": "Activation function to use for the recurrent step.\nDefault: sigmoid (sigmoid). If you pass None, no activation is\napplied (ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix, used for\nthe linear transformation of the inputs. Default: glorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel weights\nmatrix, used for the linear transformation of the recurrent state.\nDefault: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean (default True). If True, add 1 to the bias of\nthe forget gate at initialization. Setting it to true will also force\nbias_initializer=\"zeros\". This is recommended in Jozefowicz et\n  al.."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the output of the\nlayer (its \"activation\"). Default: None."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix. Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs. Default: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for\nthe linear transformation of the recurrent state. Default: 0."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "2", "description": "Implementation mode, either 1 or 2. Mode 1 will structure\nits operations as a larger number of smaller dot products and additions,\nwhereas mode 2 will batch them into fewer, larger operations. These modes\nwill have different performance profiles on different hardware and for\ndifferent applications. Default: 2."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output. in the output\nsequence, or the full sequence. Default: False."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state in addition to the\noutput. Default: False."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, process the input sequence\nbackwards and return the reversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state for each sample\nat index i in a batch will be used as initial state for the sample of\nindex i in the following batch."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": "The shape format of the inputs and outputs tensors.\nIf True, the inputs and outputs will be in shape\n[timesteps, batch, feature], whereas in the False case, it will be\n[batch, timesteps, feature]. Using time_major = True is a bit more\nefficient because it avoids transposes at the beginning and end of the\nRNN calculation. However, most TensorFlow data is batch-major, so by\ndefault this function accepts input and emits output in batch-major\nform."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Minimum", "type": "function", "code": "tf.keras.layers.Minimum(**kwargs)", "summary": "Layer that computes the minimum (element-wise) a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Minimum", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.LocallyConnected1D", "type": "function", "code": "tf.keras.layers.LocallyConnected1D(filters,kernel_size,strides=1,padding='valid',data_format=None,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,implementation=1,**kwargs)", "summary": "Locally-connected layer for 1D inputs.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.LocallyConnected1D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nspecifying the length of the 1D convolution window."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer,\nspecifying the stride length of the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "Currently only supports \"valid\" (case-insensitive).\n\"same\" may be supported in the future."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, length).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe output of the layer (its \"activation\").."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.LSTMCell", "type": "function", "code": "tf.keras.layers.LSTMCell(units,activation='tanh',recurrent_activation='sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=2,**kwargs)", "summary": "Cell class for the LSTM layer.\n\nInherits From: LSTMCell", "description": "", "code-info": {"name": "tf.keras.layers.LSTMCell", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use. Default: hyperbolic tangent\n(tanh). If you pass None, no activation is applied (ie. \"linear\""}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'sigmoid'", "description": "Activation function to use for the recurrent step.\nDefault: sigmoid (sigmoid). If you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix, used for\nthe linear transformation of the inputs. Default: glorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel weights\nmatrix, used for the linear transformation of the recurrent state.\nDefault: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean (default True). If True, add 1 to the bias of\nthe forget gate at initialization. Setting it to true will also force\nbias_initializer=\"zeros\". This is recommended in Jozefowicz et\nal."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe recurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix. Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs. Default: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for\nthe linear transformation of the recurrent state. Default: 0."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.maximum", "type": "function", "code": "tf.keras.layers.maximum(inputs,**kwargs)", "summary": "Functional interface to the Maximum layer that computes", "description": "", "code-info": {"name": "tf.keras.layers.maximum", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2) of same shape."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.LeakyReLU", "type": "function", "code": "tf.keras.layers.LeakyReLU(alpha=0.3,**kwargs)", "summary": "Leaky version of a Rectified Linear Unit.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.LeakyReLU", "parameters": [{"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.3", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.LocallyConnected2D", "type": "function", "code": "tf.keras.layers.LocallyConnected2D(filters,kernel_size,strides=(1,1),padding='valid',data_format=None,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,implementation=1,**kwargs)", "summary": "Locally-connected layer for 2D inputs.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.LocallyConnected2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nwidth and height of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the width and height.\nCan be a single integer to specify the same value for\nall spatial dimensions.\npadding: Currently only support \"valid\" (case-insensitive).\n\"same\" will be supported in future.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix.\nbias_initializer: Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\").\nkernel_constraint: Constraint function applied to the kernel matrix.\nbias_constraint: Constraint function applied to the bias vector.\nimplementation: implementation mode, either 1, 2, or 3.\n1 loops over input spatial locations to perform the forward pass.\nIt is memory-efficient but performs a lot of (small) ops."}]}},
{"id": "tf.keras.layers.LayerNormalization", "type": "function", "code": "tf.keras.layers.LayerNormalization(axis=-1,epsilon=0.001,center=True,scale=True,beta_initializer='zeros',gamma_initializer='ones',beta_regularizer=None,gamma_regularizer=None,beta_constraint=None,gamma_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Layer normalization layer (Ba et al., 2016).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.LayerNormalization", "parameters": [{"name": "axis", "is_optional": true, "type": "int", "default_value": "-1", "description": "Integer or List/Tuple. The axis that should be normalized\n(typically the features axis)."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "Small float added to variance to avoid dividing by zero."}, {"name": "center", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, add offset of beta to normalized tensor.\nIf False, beta is ignored."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, multiply by gamma.\nIf False, gamma is not used.\nWhen the next layer is linear (also e.g. nn.relu),\nthis can be disabled since the scaling\nwill be done by the next layer."}, {"name": "beta_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the beta weight."}, {"name": "gamma_initializer", "is_optional": true, "type": "string", "default_value": "'ones'", "description": "Initializer for the gamma weight."}, {"name": "beta_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the beta weight."}, {"name": "gamma_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the gamma weight."}, {"name": "beta_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the beta weight."}, {"name": "gamma_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the gamma weight."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Layer", "type": "function", "code": "tf.keras.layers.Layer(trainable=True,name=None,dtype=None,dynamic=False,**kwargs)", "summary": "Base layer class.\n\nInherits From: Module", "description": "", "code-info": {"name": "tf.keras.layers.Layer", "parameters": [{"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer's variables should be trainable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String name of the layer."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "The dtype of the layer's computations and weights (default of\nNone means use tf.keras.backend.floatx in TensorFlow 2, or the type\nof the first input in TensorFlow 1)."}, {"name": "dynamic", "is_optional": true, "type": "bool", "default_value": "False", "description": "Set this to True if your layer should only be run eagerly, and\nshould not be used to generate a static computation graph.\nThis would be the case for a Tree-RNN or a recursive network,\nfor example, or generally for any layer that manipulates tensors\nusing Python control flow. If False, we assume that the layer can\nsafely be used to generate a static computation graph.\n\n\nRead-only properties:\n  name: The name of the layer (string).\n  dtype: The dtype of the layer's computations and weights. If mixed\n    precision is used with a tf.keras.mixed_precision.experimental.Policy,\n    this is instead just the dtype of the layer's weights, as the computations\n    are done in a different dtype.\n  updates: List of update ops of this layer.\n  losses: List of losses added by this layer.\n  trainable_weights: List of variables to be included in backprop.\n  non_trainable_weights: List of variables that should not be\n    included in backprop.\n  weights: The concatenation of the lists trainable_weights and\n    non_trainable_weights (in this order).\n\nMutable properties:\n\n\ntrainable: Whether the layer should be trained (boolean).\ninput_spec: Optional (list of) InputSpec object(s) specifying the\nconstraints on inputs that can be accepted by the layer.\n\n\nDtypes and casting\n\nEach layer has a dtype, which is typically the dtype of the layer's\ncomputations and variables. A layer's dtype can be queried via the\nLayer.dtype property. The dtype is specified with the dtype constructor\nargument. In TensorFlow 2, the dtype defaults to tf.keras.backend.floatx()\nif no dtype is passed. floatx() itself defaults to \"float32\". Additionally,\nlayers will cast their inputs to the layer's dtype in TensorFlow 2. When mixed\nprecision is used, layers may have different computation and variable dtypes.\nSee tf.keras.mixed_precision.experimental.Policy for details on layer\ndtypes.\n\nAttributes:\n\n\nactivity_regularizer:   Optional regularizer function for the output of this layer.\ndtype\ndynamic\ninput:   Retrieves the input tensor(s) of a layer.\n\nOnly applicable if the layer has exactly one input,\ni.e. if it is connected to one incoming layer.\ninput_mask:   Retrieves the input mask tensor(s) of a layer.\n\nOnly applicable if the layer has exactly one inbound node,\ni.e. if it is connected to one incoming layer.\ninput_shape:   Retrieves the input shape(s) of a layer.\n\nOnly applicable if the layer has exactly one input,\ni.e. if it is connected to one incoming layer, or if all inputs\nhave the same shape.\ninput_spec\nlosses:   Losses which are associated with this Layer.\n\nVariable regularization tensors are created when this property is accessed,\nso it is eager safe: accessing losses under a tf.GradientTape will\npropagate gradients back to the corresponding variables.\nmetrics\nname:   Returns the name of this module as passed or determined in the ctor.\n\nNOTE: This is not the same as the self.name_scope.name which includes\nparent module names.\nnon_trainable_variables\nnon_trainable_weights\noutput:   Retrieves the output tensor(s) of a layer.\n\nOnly applicable if the layer has exactly one output,\ni.e. if it is connected to one incoming layer.\noutput_mask:   Retrieves the output mask tensor(s) of a layer.\n\nOnly applicable if the layer has exactly one inbound node,\ni.e. if it is connected to one incoming layer.\noutput_shape:   Retrieves the output shape(s) of a layer.\n\nOnly applicable if the layer has one output,\nor if all outputs have the same shape.\ntrainable\ntrainable_variables:   Sequence of trainable variables owned by this module and its submodules.\nNote: this method uses reflection to find variables on the current instance\nand submodules. For performance reasons you may wish to cache the result\nof calling this method if you don't expect the return value to change.\ntrainable_weights\nupdates\nvariables:   Returns the list of all layer variables/weights.\n\nAlias of self.weights.\nweights:   Returns the list of all layer variables/weights.\n\n\nMethods\n\n__call__\n\nView source\n__call__(\n    inputs, *args, **kwargs\n)\n\nWraps call, applying pre- and post-processing steps.\n\nArguments:\n\n\ninputs: input tensor(s).\n*args: additional positional arguments to be passed to self.call."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "additional keyword arguments to be passed to self.call."}]}},
{"id": "tf.keras.layers.InputLayer", "type": "function", "code": "tf.keras.layers.InputLayer(input_shape=None,batch_size=None,dtype=None,input_tensor=None,sparse=False,name=None,ragged=False,**kwargs)", "summary": "Layer to be used as an entry point into a Network (a graph of layers).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.InputLayer", "parameters": [{"name": "input_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape tuple (not including the batch axis), or TensorShape\ninstance (not including the batch axis)."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "None", "description": "Optional input batch size (integer or None)."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Datatype of the input."}, {"name": "input_tensor", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional tensor to use as layer input\ninstead of creating a placeholder."}, {"name": "sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether the placeholder created is meant to be sparse.\nragged: Boolean, whether the placeholder created is meant to be ragged.\nIn this case, values of 'None' in the 'shape' argument represent\nragged dimensions. For more information about RaggedTensors, see\nhttps://www.tensorflow.org/guide/ragged_tensors."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the layer (string).\n\n\n          "}, {"name": "ragged", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Lambda", "type": "function", "code": "tf.keras.layers.Lambda(function,output_shape=None,mask=None,arguments=None,**kwargs)", "summary": "Wraps arbitrary expressions as a Layer object.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Lambda", "parameters": [{"name": "function", "is_optional": false, "type": "tensor", "description": "The function to be evaluated. Takes input tensor as first\nargument."}, {"name": "output_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Expected output shape from function. This argument can be\ninferred if not explicitly provided. Can be a tuple or function. If a\ntuple, it only specifies the first dimension onward;\nsample dimension is assumed either the same as the input: output_shape =\n(input_shape[0], ) + output_shape or, the input is None and\nthe sample dimension is also None: output_shape = (None, ) +\noutput_shape If a function, it specifies the entire shape as a function\nof the\ninput shape: output_shape = f(input_shape)"}, {"name": "mask", "is_optional": true, "type": "others", "default_value": "None", "description": "Either None (indicating no masking) or a callable with the same\nsignature as the compute_mask layer method, or a tensor that will be\nreturned as output mask regardless what the input is."}, {"name": "arguments", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GRUCell", "type": "function", "code": "tf.keras.layers.GRUCell(units,activation='tanh',recurrent_activation='sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=2,reset_after=True,**kwargs)", "summary": "Cell class for the GRU layer.\n\nInherits From: GRUCell", "description": "", "code-info": {"name": "tf.keras.layers.GRUCell", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use. Default: hyperbolic tangent\n(tanh). If you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'sigmoid'", "description": "Activation function to use for the recurrent step.\nDefault: sigmoid (sigmoid). If you pass None, no activation is\napplied (ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs. Default:\nglorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix, used for the linear transformation of the recurrent state.\nDefault: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix. Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for the\nlinear transformation of the inputs. Default: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for\nthe linear transformation of the recurrent state. Default: 0."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "2", "description": "Implementation mode, either 1 or 2.\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions, whereas mode 2 (default) will\nbatch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications. Default: 2."}, {"name": "reset_after", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GRU", "type": "function", "code": "tf.keras.layers.GRU(units,activation='tanh',recurrent_activation='sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=2,return_sequences=False,return_state=False,go_backwards=False,stateful=False,unroll=False,time_major=False,reset_after=True,**kwargs)", "summary": "Gated Recurrent Unit - Cho et al. 2014.\n\nInherits From: GRU", "description": "", "code-info": {"name": "tf.keras.layers.GRU", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'sigmoid'", "description": "Activation function to use\nfor the recurrent step.\nDefault: sigmoid (sigmoid).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, (default True), whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs. Default:\nglorot_uniform."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix, used for the linear transformation of the recurrent\nstate. Default: orthogonal."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector. Default: zeros."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix. Default: None."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector. Default:\nNone."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the output of the\nlayer (its \"activation\"). Default: None."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix. Default: None."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the recurrent_kernel\nweights matrix. Default: None."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector. Default:\nNone."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for the linear\ntransformation of the inputs. Default: 0."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1. Fraction of the units to drop for\nthe linear transformation of the recurrent state. Default: 0."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "2", "description": "Implementation mode, either 1 or 2.\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions, whereas mode 2 will\nbatch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications. Default: 2."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output\nin the output sequence, or the full sequence. Default: False."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state in addition to the\noutput. Default: False."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, process the input sequence backwards and return the\nreversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, the network will be unrolled,\nelse a symbolic loop will be used.\nUnrolling can speed-up a RNN,\nalthough it tends to be more memory-intensive.\nUnrolling is only suitable for short sequences."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": "The shape format of the inputs and outputs tensors.\nIf True, the inputs and outputs will be in shape\n[timesteps, batch, feature], whereas in the False case, it will be\n[batch, timesteps, feature]. Using time_major = True is a bit more\nefficient because it avoids transposes at the beginning and end of the\nRNN calculation. However, most TensorFlow data is batch-major, so by\ndefault this function accepts input and emits output in batch-major\nform."}, {"name": "reset_after", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.InputSpec", "type": "function", "code": "tf.keras.layers.InputSpec(dtype=None,shape=None,ndim=None,max_ndim=None,min_ndim=None,axes=None)", "summary": "Specifies the ndim, dtype and shape of every input to a layer.", "description": "", "code-info": {"name": "tf.keras.layers.InputSpec", "parameters": [{"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Expected DataType of the input."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape tuple, expected shape of the input\n(may include None for unchecked axes)."}, {"name": "ndim", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, expected rank of the input."}, {"name": "max_ndim", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, maximum rank of the input."}, {"name": "min_ndim", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, minimum rank of the input."}, {"name": "axes", "is_optional": true, "type": "int", "default_value": "None", "description": "Dictionary mapping integer axes to\na specific dimension value."}]}},
{"id": "tf.keras.layers.GlobalMaxPool3D", "type": "function", "code": "tf.keras.layers.GlobalMaxPool3D(data_format=None,**kwargs)", "summary": "Global Max pooling operation for 3D data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalMaxPool3D", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GlobalMaxPool2D", "type": "function", "code": "tf.keras.layers.GlobalMaxPool2D(data_format=None,**kwargs)", "summary": "Global max pooling operation for spatial data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalMaxPool2D", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GlobalAveragePooling3D", "type": "function", "code": "tf.keras.layers.GlobalAveragePooling3D(data_format=None,**kwargs)", "summary": "Global Average pooling operation for 3D data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalAveragePooling3D", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GlobalAveragePooling2D", "type": "function", "code": "tf.keras.layers.GlobalAveragePooling2D(data_format=None,**kwargs)", "summary": "Global average pooling operation for spatial data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalAveragePooling2D", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GlobalAveragePooling1D", "type": "function", "code": "tf.keras.layers.GlobalAveragePooling1D(data_format='channels_last',**kwargs)", "summary": "Global average pooling operation for temporal data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalAveragePooling1D", "parameters": [{"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GaussianNoise", "type": "function", "code": "tf.keras.layers.GaussianNoise(stddev,**kwargs)", "summary": "Apply additive zero-centered Gaussian noise.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.GaussianNoise", "parameters": [{"name": "stddev", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GlobalMaxPool1D", "type": "function", "code": "tf.keras.layers.GlobalMaxPool1D(data_format='channels_last',**kwargs)", "summary": "Global max pooling operation for temporal data.", "description": "", "code-info": {"name": "tf.keras.layers.GlobalMaxPool1D", "parameters": [{"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.GaussianDropout", "type": "function", "code": "tf.keras.layers.GaussianDropout(rate,**kwargs)", "summary": "Apply multiplicative 1-centered Gaussian noise.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.GaussianDropout", "parameters": [{"name": "rate", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.ELU", "type": "function", "code": "tf.keras.layers.ELU(alpha=1.0,**kwargs)", "summary": "Exponential Linear Unit.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ELU", "parameters": [{"name": "alpha", "is_optional": true, "type": "others", "default_value": "1.0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.deserialize", "type": "function", "code": "tf.keras.layers.deserialize(config,custom_objects=None)", "summary": "Instantiates a layer from a config dictionary.", "description": "", "code-info": {"name": "tf.keras.layers.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "string", "description": "dict of the form {'class_name': str, 'config': dict}"}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "dict mapping class names (or function names)\nof custom (non-Keras) objects to class/functions"}]}},
{"id": "tf.keras.layers.dot", "type": "function", "code": "tf.keras.layers.dot(inputs,axes,normalize=False,**kwargs)", "summary": "Functional interface to the Dot layer.", "description": "", "code-info": {"name": "tf.keras.layers.dot", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "axes", "is_optional": false, "type": "int", "description": "Integer or tuple of integers,\naxis or axes along which to take the dot product."}, {"name": "normalize", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to L2-normalize samples along the\ndot product axis before taking the dot product.\nIf set to True, then the output of the dot product\nis the cosine proximity between the two samples."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.Dot", "type": "function", "code": "tf.keras.layers.Dot(axes,normalize=False,**kwargs)", "summary": "Layer that computes a dot product between samples in two tensors.", "description": "", "code-info": {"name": "tf.keras.layers.Dot", "parameters": [{"name": "axes", "is_optional": false, "type": "int", "description": "Integer or tuple of integers,\naxis or axes along which to take the dot product."}, {"name": "normalize", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to L2-normalize samples along the\ndot product axis before taking the dot product.\nIf set to True, then the output of the dot product\nis the cosine proximity between the two samples."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.Flatten", "type": "function", "code": "tf.keras.layers.Flatten(data_format=None,**kwargs)", "summary": "Flattens the input. Does not affect the batch size.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Flatten", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Embedding", "type": "function", "code": "tf.keras.layers.Embedding(input_dim,output_dim,embeddings_initializer='uniform',embeddings_regularizer=None,activity_regularizer=None,embeddings_constraint=None,mask_zero=False,input_length=None,**kwargs)", "summary": "Turns positive integers (indexes) into dense vectors of fixed size.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Embedding", "parameters": [{"name": "input_dim", "is_optional": false, "type": "others", "description": "int &gt; 0. Size of the vocabulary,\ni.e. maximum integer index + 1."}, {"name": "output_dim", "is_optional": false, "type": "others", "description": "int &gt;= 0. Dimension of the dense embedding."}, {"name": "embeddings_initializer", "is_optional": true, "type": "string", "default_value": "'uniform'", "description": "Initializer for the embeddings matrix."}, {"name": "embeddings_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "embeddings_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe embeddings matrix."}, {"name": "mask_zero", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether or not the input value 0 is a special \"padding\"\nvalue that should be masked out.\nThis is useful when using recurrent layers\nwhich may take variable length input.\nIf this is True then all subsequent layers\nin the model need to support masking or an exception will be raised.\nIf mask_zero is set to True, as a consequence, index 0 cannot be\nused in the vocabulary (input_dim should equal size of\nvocabulary + 1)."}, {"name": "input_length", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Dropout", "type": "function", "code": "tf.keras.layers.Dropout(rate,noise_shape=None,seed=None,**kwargs)", "summary": "Applies Dropout to the input.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Dropout", "parameters": [{"name": "rate", "is_optional": false, "type": "float", "description": "Float between 0 and 1. Fraction of the input units to drop."}, {"name": "noise_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "1D integer tensor representing the shape of the\nbinary dropout mask that will be multiplied with the input.\nFor instance, if your inputs have shape\n(batch_size, timesteps, features) and\nyou want the dropout mask to be the same for all timesteps,\nyou can use noise_shape=(batch_size, 1, features)."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.DepthwiseConv2D", "type": "function", "code": "tf.keras.layers.DepthwiseConv2D(kernel_size,strides=(1,1),padding='valid',depth_multiplier=1,data_format=None,activation=None,use_bias=True,depthwise_initializer='glorot_uniform',bias_initializer='zeros',depthwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,bias_constraint=None,**kwargs)", "summary": "Depthwise separable 2D convolution.\n\nInherits From: Conv2D", "description": "", "code-info": {"name": "tf.keras.layers.DepthwiseConv2D", "parameters": [{"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of 'valid' or 'same' (case-insensitive).\ndepth_multiplier: The number of depthwise convolution output channels\nfor each input channel.\nThe total number of depthwise convolution output\nchannels will be equal to filters_in * depth_multiplier.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be 'channels_last'.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. 'linear' activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\ndepthwise_initializer: Initializer for the depthwise kernel matrix.\nbias_initializer: Initializer for the bias vector.\ndepthwise_regularizer: Regularizer function applied to\nthe depthwise kernel matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its 'activation').\ndepthwise_constraint: Constraint function applied to\nthe depthwise kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.Dense", "type": "function", "code": "tf.keras.layers.Dense(units,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "Just your regular densely-connected NN layer.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Dense", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe output of the layer (its \"activation\").."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.DenseFeatures", "type": "function", "code": "tf.keras.layers.DenseFeatures(feature_columns,trainable=True,name=None,**kwargs)", "summary": "A layer that produces a dense Tensor based on given feature_columns.\n\nInherits From: DenseFeatures", "description": "", "code-info": {"name": "tf.keras.layers.DenseFeatures", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns to use as\ninputs to your model. All items should be instances of classes derived\nfrom DenseColumn such as numeric_column, embedding_column,\nbucketized_column, indicator_column. If you have categorical\nfeatures, you can wrap them with an embedding_column or\nindicator_column."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": " Boolean, whether the layer's variables will be updated via\ngradient descent during training."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name to give to the DenseFeatures."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Keyword arguments to construct a layer."}]}},
{"id": "tf.keras.layers.Cropping3D", "type": "function", "code": "tf.keras.layers.Cropping3D(cropping=((1,1),(1,1),(1,1)),data_format=None,**kwargs)", "summary": "Cropping layer for 3D data (e.g. spatial or spatio-temporal).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Cropping3D", "parameters": [{"name": "cropping", "is_optional": false, "type": "others", "description": "Int, or tuple of 3 ints, or tuple of 3 tuples of 2 ints."}]}},
{"id": "tf.keras.layers.Conv3D", "type": "function", "code": "tf.keras.layers.Conv3D(filters,kernel_size,strides=(1,1,1),padding='valid',data_format=None,dilation_rate=(1,1,1),activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "3D convolution layer (e.g. spatial convolution over volumes).", "description": "", "code-info": {"name": "tf.keras.layers.Conv3D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the\ndepth, height and width of the 3D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the convolution along each spatial\ndimension.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)\nwhile channels_first corresponds to inputs with shape\n(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: an integer or tuple/list of 3 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix.\nbias_initializer: Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\")..\nkernel_constraint: Constraint function applied to the kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.Conv2DTranspose", "type": "function", "code": "tf.keras.layers.Conv2DTranspose(filters,kernel_size,strides=(1,1),padding='valid',output_padding=None,data_format=None,dilation_rate=(1,1),activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "Transposed convolution layer (sometimes called Deconvolution).\n\nInherits From: Conv2D", "description": "", "code-info": {"name": "tf.keras.layers.Conv2DTranspose", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of \"valid\" or \"same\" (case-insensitive).\noutput_padding: An integer or tuple/list of 2 integers,\nspecifying the amount of padding along the height and width\nof the output tensor.\nCan be a single integer to specify the same value for all\nspatial dimensions.\nThe amount of output padding along a given dimension must be\nlower than the stride along that same dimension.\nIf set to None (default), the output shape is inferred.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: an integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix.\nbias_initializer: Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\")..\nkernel_constraint: Constraint function applied to the kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.Conv2D", "type": "function", "code": "tf.keras.layers.Conv2D(filters,kernel_size,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1),activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "2D convolution layer (e.g. spatial convolution over images).", "description": "", "code-info": {"name": "tf.keras.layers.Conv2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: an integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix.\nbias_initializer: Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\")..\nkernel_constraint: Constraint function applied to the kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.Conv3DTranspose", "type": "function", "code": "tf.keras.layers.Conv3DTranspose(filters,kernel_size,strides=(1,1,1),padding='valid',output_padding=None,data_format=None,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "Transposed convolution layer (sometimes called Deconvolution).\n\nInherits From: Conv3D", "description": "", "code-info": {"name": "tf.keras.layers.Conv3DTranspose", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the\ndepth, height and width of the 3D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the convolution along the depth, height\n  and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: one of \"valid\" or \"same\" (case-insensitive).\noutput_padding: An integer or tuple/list of 3 integers,\nspecifying the amount of padding along the depth, height, and\nwidth.\nCan be a single integer to specify the same value for all\nspatial dimensions.\nThe amount of output padding along a given dimension must be\nlower than the stride along that same dimension.\nIf set to None (default), the output shape is inferred.\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: an integer or tuple/list of 3 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x).\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix.\nbias_initializer: Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to\nthe output of the layer (its \"activation\").\nkernel_constraint: Constraint function applied to the kernel matrix.\nbias_constraint: Constraint function applied to the bias vector."}]}},
{"id": "tf.keras.layers.Cropping2D", "type": "function", "code": "tf.keras.layers.Cropping2D(cropping=((0,0),(0,0)),data_format=None,**kwargs)", "summary": "Cropping layer for 2D input (e.g. picture).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Cropping2D", "parameters": [{"name": "cropping", "is_optional": false, "type": "others", "description": "Int, or tuple of 2 ints, or tuple of 2 tuples of 2 ints."}]}},
{"id": "tf.keras.layers.Cropping1D", "type": "function", "code": "tf.keras.layers.Cropping1D(cropping=(1,1),**kwargs)", "summary": "Cropping layer for 1D input (e.g. temporal sequence).\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Cropping1D", "parameters": [{"name": "cropping", "is_optional": false, "type": "others", "description": "Int or tuple of int (length 2)\nHow many units should be trimmed off at the beginning and end of\nthe cropping dimension (axis 1).\nIf a single int is provided, the same value will be used for both."}]}},
{"id": "tf.keras.layers.ConvLSTM2D", "type": "class", "code": "tf.keras.layers.ConvLSTM2D(filters,kernel_size,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1),activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,return_sequences=False,go_backwards=False,stateful=False,dropout=0.0,recurrent_dropout=0.0,**kwargs)", "summary": "Convolutional LSTM.", "description": "", "code-info": {"name": "tf.keras.layers.ConvLSTM2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of n integers, specifying the\ndimensions of the convolution window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of n integers,\nspecifying the strides of the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, time, ..., channels)\nwhile channels_first corresponds to\ninputs with shape (batch, time, channels, ...).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\".\ndilation_rate: An integer or tuple/list of n integers, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any strides value != 1.\nactivation: Activation function to use.\nBy default hyperbolic tangent activation function is applied\n(tanh(x)).\nrecurrent_activation: Activation function to use\nfor the recurrent step.\nuse_bias: Boolean, whether the layer uses a bias vector.\nkernel_initializer: Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs.\nrecurrent_initializer: Initializer for the recurrent_kernel\nweights matrix,\nused for the linear transformation of the recurrent state.\nbias_initializer: Initializer for the bias vector.\nunit_forget_bias: Boolean.\nIf True, add 1 to the bias of the forget gate at initialization.\nUse in combination with bias_initializer=\"zeros\".\nThis is recommended in Jozefowicz et al.\nkernel_regularizer: Regularizer function applied to\nthe kernel weights matrix.\nrecurrent_regularizer: Regularizer function applied to\nthe recurrent_kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to.\nkernel_constraint: Constraint function applied to\nthe kernel weights matrix.\nrecurrent_constraint: Constraint function applied to\nthe recurrent_kernel weights matrix.\nbias_constraint: Constraint function applied to the bias vector.\nreturn_sequences: Boolean. Whether to return the last output\nin the output sequence, or the full sequence.\ngo_backwards: Boolean (default False).\nIf True, process the input sequence backwards.\nstateful: Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch.\ndropout: Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the inputs.\nrecurrent_dropout: Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the recurrent state."}]}},
{"id": "tf.keras.layers.concatenate", "type": "function", "code": "tf.keras.layers.concatenate(inputs,axis=-1,**kwargs)", "summary": "Functional interface to the Concatenate layer.", "description": "", "code-info": {"name": "tf.keras.layers.concatenate", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Concatenation axis."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.Bidirectional", "type": "function", "code": "tf.keras.layers.Bidirectional(layer,merge_mode='concat',weights=None,backward_layer=None,**kwargs)", "summary": "Bidirectional wrapper for RNNs.\n\nInherits From: Wrapper", "description": "", "code-info": {"name": "tf.keras.layers.Bidirectional", "parameters": [{"name": "layer", "is_optional": false, "type": "others", "description": "Recurrent instance."}, {"name": "merge_mode", "is_optional": true, "type": "string", "default_value": "'concat'", "description": ""}, {"name": "weights", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "backward_layer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Conv1D", "type": "function", "code": "tf.keras.layers.Conv1D(filters,kernel_size,strides=1,padding='valid',data_format='channels_last',dilation_rate=1,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,**kwargs)", "summary": "1D convolution layer (e.g. temporal convolution).", "description": "", "code-info": {"name": "tf.keras.layers.Conv1D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space\n(i.e. the number of output filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nspecifying the length of the 1D convolution window."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer,\nspecifying the stride length of the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\", \"causal\" or \"same\" (case-insensitive).\n\"causal\" results in causal (dilated) convolutions, e.g. output[t]\ndoes not depend on input[t+1:]. Useful when modeling temporal data\nwhere the model should not violate the temporal order.\nSee WaveNet: A Generative Model for Raw Audio, section\n2.1."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string,\none of channels_last (default) or channels_first."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "an integer or tuple/list of a single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any strides value != 1."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function to use.\nIf you don't specify anything, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe output of the layer (its \"activation\").."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Concatenate", "type": "function", "code": "tf.keras.layers.Concatenate(axis=-1,**kwargs)", "summary": "Layer that concatenates a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Concatenate", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Axis along which to concatenate."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.BatchNormalization", "type": "function", "code": "tf.keras.layers.BatchNormalization(axis=-1,momentum=0.99,epsilon=0.001,center=True,scale=True,beta_initializer='zeros',gamma_initializer='ones',moving_mean_initializer='zeros',moving_variance_initializer='ones',beta_regularizer=None,gamma_regularizer=None,beta_constraint=None,gamma_constraint=None,renorm=False,renorm_clipping=None,renorm_momentum=0.99,fused=None,trainable=True,virtual_batch_size=None,adjustment=None,name=None,**kwargs)", "summary": "Normalize and scale inputs or activations. (Ioffe and Szegedy, 2014).", "description": "", "code-info": {"name": "tf.keras.layers.BatchNormalization", "parameters": [{"name": "axis", "is_optional": true, "type": "int", "default_value": "-1", "description": "Integer, the axis that should be normalized\n(typically the features axis).\nFor instance, after a Conv2D layer with\ndata_format=\"channels_first\",\nset axis=1 in BatchNormalization."}, {"name": "momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum for the moving average."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "Small float added to variance to avoid dividing by zero."}, {"name": "center", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, add offset of beta to normalized tensor.\nIf False, beta is ignored."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, multiply by gamma.\nIf False, gamma is not used.\nWhen the next layer is linear (also e.g. nn.relu),\nthis can be disabled since the scaling\nwill be done by the next layer."}, {"name": "beta_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the beta weight."}, {"name": "gamma_initializer", "is_optional": true, "type": "string", "default_value": "'ones'", "description": "Initializer for the gamma weight."}, {"name": "moving_mean_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the moving mean."}, {"name": "moving_variance_initializer", "is_optional": true, "type": "string", "default_value": "'ones'", "description": "Initializer for the moving variance."}, {"name": "beta_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the beta weight."}, {"name": "gamma_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the gamma weight."}, {"name": "beta_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the beta weight."}, {"name": "gamma_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the gamma weight."}, {"name": "renorm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use Batch Renormalization\n(https://arxiv.org/abs/1702.03275). This adds extra variables during\ntraining. The inference is the same for either value of this parameter."}, {"name": "renorm_clipping", "is_optional": true, "type": "others", "default_value": "None", "description": "A dictionary that may map keys 'rmax', 'rmin', 'dmax' to\nscalar Tensors used to clip the renorm correction. The correction\n(r, d) is used as corrected_value = normalized_value * r + d, with\nr clipped to [rmin, rmax], and d to [-dmax, dmax]. Missing rmax, rmin,\ndmax are set to inf, 0, inf, respectively."}, {"name": "renorm_momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum used to update the moving means and standard\ndeviations with renorm. Unlike momentum, this affects training\nand should be neither too small (which would add noise) nor too large\n(which would give stale estimates). Note that momentum is still applied\nto get the means and variances for inference."}, {"name": "fused", "is_optional": true, "type": "others", "default_value": "None", "description": "if True, use a faster, fused implementation, or raise a ValueError\nif the fused implementation cannot be used. If None, use the faster\nimplementation if possible. If False, do not used the fused\nimplementation."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, if True the variables will be marked as trainable."}, {"name": "virtual_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. By default, virtual_batch_size is None,\nwhich means batch normalization is performed across the whole batch. When\nvirtual_batch_size is not None, instead perform \"Ghost Batch\nNormalization\", which creates virtual sub-batches which are each\nnormalized separately (with shared gamma, beta, and moving statistics).\nMust divide the actual batch size during execution."}, {"name": "adjustment", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Average", "type": "function", "code": "tf.keras.layers.Average(**kwargs)", "summary": "Layer that averages a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Average", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Attention", "type": "function", "code": "tf.keras.layers.Attention(use_scale=False,**kwargs)", "summary": "Dot-product attention layer, a.k.a. Luong-style attention.", "description": "", "code-info": {"name": "tf.keras.layers.Attention", "parameters": [{"name": "use_scale", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.AveragePooling1D", "type": "function", "code": "tf.keras.layers.AveragePooling1D(pool_size=2,strides=None,padding='valid',data_format='channels_last',**kwargs)", "summary": "Average pooling for temporal data.", "description": "", "code-info": {"name": "tf.keras.layers.AveragePooling1D", "parameters": [{"name": "pool_size", "is_optional": true, "type": "int", "default_value": "2", "description": "Integer, size of the average pooling windows."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, or None. Factor by which to downscale.\nE.g. 2 will halve the input.\nIf None, it will default to pool_size."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.average", "type": "function", "code": "tf.keras.layers.average(inputs,**kwargs)", "summary": "Functional interface to the Average layer.", "description": "", "code-info": {"name": "tf.keras.layers.average", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.AlphaDropout", "type": "function", "code": "tf.keras.layers.AlphaDropout(rate,noise_shape=None,seed=None,**kwargs)", "summary": "Applies Alpha Dropout to the input.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.AlphaDropout", "parameters": [{"name": "rate", "is_optional": false, "type": "others", "description": ""}, {"name": "noise_shape", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.add", "type": "function", "code": "tf.keras.layers.add(inputs,**kwargs)", "summary": "Functional interface to the Add layer.", "description": "", "code-info": {"name": "tf.keras.layers.add", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of input tensors (at least 2)."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Standard layer keyword arguments."}]}},
{"id": "tf.keras.layers.AdditiveAttention", "type": "function", "code": "tf.keras.layers.AdditiveAttention(use_scale=True,**kwargs)", "summary": "Additive attention layer, a.k.a. Bahdanau-style attention.", "description": "", "code-info": {"name": "tf.keras.layers.AdditiveAttention", "parameters": [{"name": "use_scale", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Add", "type": "function", "code": "tf.keras.layers.Add(**kwargs)", "summary": "Layer that adds a list of inputs.", "description": "", "code-info": {"name": "tf.keras.layers.Add", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.AveragePooling3D", "type": "function", "code": "tf.keras.layers.AveragePooling3D(pool_size=(2,2,2),strides=None,padding='valid',data_format=None,**kwargs)", "summary": "Average pooling operation for 3D data (spatial or spatio-temporal).", "description": "", "code-info": {"name": "tf.keras.layers.AveragePooling3D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "tuple of 3 integers,\nfactors by which to downscale (dim1, dim2, dim3).\n(2, 2, 2) will halve the size of the 3D input in each dimension.\nstrides: tuple of 3 integers, or None. Strides values.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, spatial_dim1, spatial_dim2, spatial_dim3, channels)\nwhile channels_first corresponds to inputs with shape\n(batch, channels, spatial_dim1, spatial_dim2, spatial_dim3).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}]}},
{"id": "tf.keras.layers.AveragePooling2D", "type": "function", "code": "tf.keras.layers.AveragePooling2D(pool_size=(2,2),strides=None,padding='valid',data_format=None,**kwargs)", "summary": "Average pooling operation for spatial data.", "description": "", "code-info": {"name": "tf.keras.layers.AveragePooling2D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "integer or tuple of 2 integers,\nfactors by which to downscale (vertical, horizontal).\n(2, 2) will halve the input in both spatial dimension.\nIf only one integer is specified, the same window length\nwill be used for both dimensions.\nstrides: Integer, tuple of 2 integers, or None.\nStrides values.\nIf None, it will default to pool_size.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string,\none of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, height, width).\nIt defaults to the image_data_format value found in your\nKeras config file at ~/.keras/keras.json.\nIf you never set it, then it will be \"channels_last\"."}]}},
{"id": "tf.keras.layers.ActivityRegularization", "type": "function", "code": "tf.keras.layers.ActivityRegularization(l1=0.0,l2=0.0,**kwargs)", "summary": "Layer that applies an update to the cost function based input activity.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.ActivityRegularization", "parameters": [{"name": "l1", "is_optional": true, "type": "float", "default_value": "0.0", "description": "L1 regularization factor (positive float)."}, {"name": "l2", "is_optional": true, "type": "others", "default_value": "0.0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.Activation", "type": "function", "code": "tf.keras.layers.Activation(activation,**kwargs)", "summary": "Applies an activation function to an output.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.Activation", "parameters": [{"name": "activation", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.layers.AbstractRNNCell", "type": "function", "code": "tf.keras.layers.AbstractRNNCell(trainable=True,name=None,dtype=None,dynamic=False,**kwargs)", "summary": "Abstract object representing an RNN cell.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.keras.layers.AbstractRNNCell", "parameters": [{"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dynamic", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.initializers.VarianceScaling", "type": "function", "code": "tf.keras.initializers.VarianceScaling(scale=1.0,mode='fan_in',distribution='truncated_normal',seed=None)", "summary": "Initializer capable of adapting its scale to the shape of weights tensors.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.keras.initializers.VarianceScaling", "parameters": [{"name": "scale", "is_optional": true, "type": "float", "default_value": "1.0", "description": "Scaling factor (positive float)."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'fan_in'", "description": "One of \"fan_in\", \"fan_out\", \"fan_avg\"."}, {"name": "distribution", "is_optional": true, "type": "string", "default_value": "'truncated_normal'", "description": "Random distribution to use. One of \"truncated_normal\",\n\"untruncated_normal\" and  \"uniform\"."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "tf.keras.initializers.TruncatedNormal", "type": "function", "code": "tf.keras.initializers.TruncatedNormal(mean=0.0,stddev=0.05,seed=None)", "summary": "Initializer that generates a truncated normal distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.keras.initializers.TruncatedNormal", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values\nto generate."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "a python scalar or a scalar tensor. Standard deviation of the\nrandom values to generate."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "tf.keras.initializers.serialize", "type": "function", "code": "tf.keras.initializers.serialize(initializer)", "summary": "", "description": "", "code-info": {"name": "tf.keras.initializers.serialize", "parameters": [{"name": "initializer", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.initializers.Orthogonal", "type": "function", "code": "tf.keras.initializers.Orthogonal(gain=1.0,seed=None)", "summary": "Initializer that generates an orthogonal matrix.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.keras.initializers.Orthogonal", "parameters": [{"name": "gain", "is_optional": true, "type": "others", "default_value": "1.0", "description": "multiplicative factor to apply to the orthogonal matrix"}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "tf.keras.initializers.lecun_uniform", "type": "function", "code": "tf.keras.initializers.lecun_uniform(seed=None)", "summary": "LeCun uniform initializer.", "description": "", "code-info": {"name": "tf.keras.initializers.lecun_uniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.keras.initializers.lecun_normal", "type": "function", "code": "tf.keras.initializers.lecun_normal(seed=None)", "summary": "LeCun normal initializer.", "description": "", "code-info": {"name": "tf.keras.initializers.lecun_normal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.keras.initializers.GlorotUniform", "type": "function", "code": "tf.keras.initializers.GlorotUniform(seed=None)", "summary": "The Glorot uniform initializer, also called Xavier uniform initializer.\n\nInherits From: VarianceScaling", "description": "", "code-info": {"name": "tf.keras.initializers.GlorotUniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "__call__", "type": "function", "code": "__call__(shape,dtype=None)", "summary": "Initializer base class: all initializers inherit from this class.", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "Shape of the tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional dtype of the tensor. If not provided will return tensor\nof tf.float32."}]}},
{"id": "tf.keras.initializers.Identity", "type": "function", "code": "tf.keras.initializers.Identity(gain=1.0)", "summary": "Initializer that generates the identity matrix.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.keras.initializers.Identity", "parameters": [{"name": "gain", "is_optional": true, "type": "others", "default_value": "1.0", "description": "Multiplicative factor to apply to the identity matrix."}]}},
{"id": "tf.keras.initializers.get", "type": "function", "code": "tf.keras.initializers.get(identifier)", "summary": "", "description": "", "code-info": {"name": "tf.keras.initializers.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.experimental.terminate_keras_multiprocessing_pools", "type": "function", "code": "tf.keras.experimental.terminate_keras_multiprocessing_pools(grace_period=0.1,use_sigkill=False)", "summary": "Destroy Keras' multiprocessing pools to prevent deadlocks.", "description": "", "code-info": {"name": "tf.keras.experimental.terminate_keras_multiprocessing_pools", "parameters": [{"name": "grace_period", "is_optional": true, "type": "others", "default_value": "0.1", "description": "Time (in seconds) to wait for process cleanup to propagate."}, {"name": "use_sigkill", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean of whether or not to perform a cleanup pass using\nSIGKILL."}]}},
{"id": "tf.keras.initializers.he_uniform", "type": "function", "code": "tf.keras.initializers.he_uniform(seed=None)", "summary": "He uniform variance scaling initializer.", "description": "", "code-info": {"name": "tf.keras.initializers.he_uniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.keras.initializers.he_normal", "type": "function", "code": "tf.keras.initializers.he_normal(seed=None)", "summary": "He normal initializer.", "description": "", "code-info": {"name": "tf.keras.initializers.he_normal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.keras.initializers.GlorotNormal", "type": "function", "code": "tf.keras.initializers.GlorotNormal(seed=None)", "summary": "The Glorot normal initializer, also called Xavier normal initializer.\n\nInherits From: VarianceScaling", "description": "", "code-info": {"name": "tf.keras.initializers.GlorotNormal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.keras.initializers.deserialize", "type": "function", "code": "tf.keras.initializers.deserialize(config,custom_objects=None)", "summary": "Return an Initializer object from its config.", "description": "", "code-info": {"name": "tf.keras.initializers.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.keras.experimental.WideDeepModel", "type": "class", "code": "tf.keras.experimental.WideDeepModel(linear_model,dnn_model,activation=None,**kwargs)", "summary": "Wide &amp; Deep Model for regression and classification problems.\n\nInherits From: Model", "description": "", "code-info": {"name": "tf.keras.experimental.WideDeepModel", "parameters": [{"name": "linear_model", "is_optional": false, "type": "others", "description": "a premade LinearModel, its output must match the output of\nthe dnn model."}, {"name": "dnn_model", "is_optional": false, "type": "others", "description": "a tf.keras.Model, its output must match the output of the\nlinear model."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a linear\nactivation."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "The keyword arguments that are passed on to BaseLayer.init.\nAllowed keyword arguments include name."}]}},
{"id": "tf.keras.experimental.SequenceFeatures", "type": "function", "code": "tf.keras.experimental.SequenceFeatures(feature_columns,trainable=True,name=None,**kwargs)", "summary": "A layer for sequence input.", "description": "", "code-info": {"name": "tf.keras.experimental.SequenceFeatures", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable of dense sequence columns. Valid columns are\n\nembedding_column that wraps a sequence_categorical_column_with_*\nsequence_numeric_column.\n"}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer's variables will be updated via\ngradient descent during training."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name to give to the SequenceFeatures."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Keyword arguments to construct a layer."}]}},
{"id": "tf.keras.experimental.PeepholeLSTMCell", "type": "function", "code": "tf.keras.experimental.PeepholeLSTMCell(units,activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=1,**kwargs)", "summary": "Equivalent to LSTMCell class but adds peephole connections.\n\nInherits From: LSTMCell", "description": "", "code-info": {"name": "tf.keras.experimental.PeepholeLSTMCell", "parameters": [{"name": "units", "is_optional": false, "type": "others", "description": ""}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": ""}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'hard_sigmoid'", "description": ""}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": ""}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": ""}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": ""}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "kernel_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "recurrent_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "bias_constraint", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "0.0", "description": ""}, {"name": "recurrent_dropout", "is_optional": true, "type": "others", "default_value": "0.0", "description": ""}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.experimental.NoisyLinearCosineDecay", "type": "function", "code": "tf.keras.experimental.NoisyLinearCosineDecay(initial_learning_rate,decay_steps,initial_variance=1.0,variance_decay=0.55,num_periods=0.5,alpha=0.0,beta=0.001,name=None)", "summary": "A LearningRateSchedule that uses a noisy linear cosine decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.experimental.NoisyLinearCosineDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python\nnumber. The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nNumber of steps to decay over."}, {"name": "initial_variance", "is_optional": true, "type": "others", "default_value": "1.0", "description": "initial variance for the noise. See computation above."}, {"name": "variance_decay", "is_optional": true, "type": "others", "default_value": "0.55", "description": "decay for the noise's variance. See computation above."}, {"name": "num_periods", "is_optional": true, "type": "others", "default_value": "0.5", "description": "Number of periods in the cosine part of the decay.\nSee computation above."}, {"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.0", "description": "See computation above."}, {"name": "beta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "See computation above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'NoisyLinearCosineDecay'."}]}},
{"id": "tf.keras.experimental.LinearModel", "type": "class", "code": "tf.keras.experimental.LinearModel(units=1,activation=None,use_bias=True,kernel_initializer='glorot_uniform',bias_initializer='zeros',kernel_regularizer=None,bias_regularizer=None,**kwargs)", "summary": "Linear Model for regression and classification problems.\n\nInherits From: Model", "description": "", "code-info": {"name": "tf.keras.experimental.LinearModel", "parameters": [{"name": "units", "is_optional": true, "type": "int", "default_value": "1", "description": "Positive integer, output dimension without the batch size."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function to use.\nIf you don't specify anything, no activation is applied."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to calculate the bias/intercept for this model. If set\nto False, no bias/intercept will be used in calculations, e.g., the data\nis already centered."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrices."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "regularizer for kernel vectors."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "regularizer for bias vector."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "The keyword arguments that are passed on to BaseLayer.init."}]}},
{"id": "tf.keras.experimental.LinearCosineDecay", "type": "function", "code": "tf.keras.experimental.LinearCosineDecay(initial_learning_rate,decay_steps,num_periods=0.5,alpha=0.0,beta=0.001,name=None)", "summary": "A LearningRateSchedule that uses a linear cosine decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.experimental.LinearCosineDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python\nnumber. The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nNumber of steps to decay over."}, {"name": "num_periods", "is_optional": true, "type": "others", "default_value": "0.5", "description": "Number of periods in the cosine part of the decay.\nSee computation above."}, {"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.0", "description": "See computation above."}, {"name": "beta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "See computation above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'LinearCosineDecay'."}]}},
{"id": "tf.keras.experimental.CosineDecayRestarts", "type": "function", "code": "tf.keras.experimental.CosineDecayRestarts(initial_learning_rate,first_decay_steps,t_mul=2.0,m_mul=1.0,alpha=0.0,name=None)", "summary": "A LearningRateSchedule that uses a cosine decay schedule with restarts.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.experimental.CosineDecayRestarts", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python\nnumber. The initial learning rate."}, {"name": "first_decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python\nnumber. Number of steps to decay over."}, {"name": "t_mul", "is_optional": true, "type": "tensor", "default_value": "2.0", "description": "A scalar float32 or float64 Tensor or a Python number.\nUsed to derive the number of iterations in the i-th period"}, {"name": "m_mul", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A scalar float32 or float64 Tensor or a Python number.\nUsed to derive the initial learning rate of the i-th period:"}, {"name": "alpha", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar float32 or float64 Tensor or a Python number.\nMinimum learning rate value as a fraction of the initial_learning_rate."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String. Optional name of the operation.  Defaults to 'SGDRDecay'."}]}},
{"id": "tf.keras.estimator.model_to_estimator", "type": "function", "code": "tf.keras.estimator.model_to_estimator(keras_model=None,keras_model_path=None,custom_objects=None,model_dir=None,config=None,checkpoint_format='checkpoint')", "summary": "Constructs an Estimator instance from given keras model.", "description": "", "code-info": {"name": "tf.keras.estimator.model_to_estimator", "parameters": [{"name": "keras_model", "is_optional": true, "type": "others", "default_value": "None", "description": "A compiled Keras model object. This argument is mutually\nexclusive with keras_model_path."}, {"name": "keras_model_path", "is_optional": true, "type": "others", "default_value": "None", "description": "Path to a compiled Keras model saved on disk, in HDF5\nformat, which can be generated with the save() method of a Keras model.\nThis argument is mutually exclusive with keras_model."}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": "Dictionary for custom objects."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save Estimator model parameters, graph, summary\nfiles for TensorBoard, etc."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig to config Estimator."}, {"name": "checkpoint_format", "is_optional": true, "type": "string", "default_value": "'checkpoint'", "description": "Sets the format of the checkpoint saved by the estimator\nwhen training. May be saver or checkpoint, depending on whether to\nsave checkpoints from tf.compat.v1.train.Saver or tf.train.Checkpoint.\nThe default is checkpoint. Estimators use name-based tf.train.Saver\ncheckpoints, while Keras models use object-based checkpoints from\ntf.train.Checkpoint. Currently, saving object-based checkpoints from\nmodel_to_estimator is only supported by Functional and Sequential\nmodels."}]}},
{"id": "tf.keras.experimental.CosineDecay", "type": "function", "code": "tf.keras.experimental.CosineDecay(initial_learning_rate,decay_steps,alpha=0.0,name=None)", "summary": "A LearningRateSchedule that uses a cosine decay schedule.\n\nInherits From: LearningRateSchedule", "description": "", "code-info": {"name": "tf.keras.experimental.CosineDecay", "parameters": [{"name": "initial_learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a\nPython number. The initial learning rate."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nNumber of steps to decay over."}, {"name": "alpha", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar float32 or float64 Tensor or a Python number.\nMinimum learning rate value as a fraction of initial_learning_rate."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String. Optional name of the operation.  Defaults to 'CosineDecay'."}]}},
{"id": "tf.keras.datasets.mnist.load_data", "type": "function", "code": "tf.keras.datasets.mnist.load_data(path='mnist.npz')", "summary": "Loads the MNIST dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.mnist.load_data", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'mnist.npz'", "description": "path where to cache the dataset locally\n(relative to ~/.keras/datasets)."}]}},
{"id": "tf.keras.datasets.reuters.get_word_index", "type": "function", "code": "tf.keras.datasets.reuters.get_word_index(path='reuters_word_index.json')", "summary": "Retrieves the dictionary mapping word indices back to words.", "description": "", "code-info": {"name": "tf.keras.datasets.reuters.get_word_index", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'reuters_word_index.json'", "description": "where to cache the data (relative to ~/.keras/dataset)."}]}},
{"id": "tf.keras.datasets.reuters.load_data", "type": "function", "code": "tf.keras.datasets.reuters.load_data(path='reuters.npz',num_words=None,skip_top=0,maxlen=None,test_split=0.2,seed=113,start_char=1,oov_char=2,index_from=3,**kwargs)", "summary": "Loads the Reuters newswire classification dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.reuters.load_data", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'reuters.npz'", "description": "where to cache the data (relative to ~/.keras/dataset)."}, {"name": "num_words", "is_optional": true, "type": "others", "default_value": "None", "description": "max number of words to include. Words are ranked\nby how often they occur (in the training set) and only\nthe most frequent words are kept"}, {"name": "skip_top", "is_optional": true, "type": "int", "default_value": "0", "description": "skip the top N most frequently occurring words\n(which may not be informative)."}, {"name": "maxlen", "is_optional": true, "type": "others", "default_value": "None", "description": "truncate sequences after this length."}, {"name": "test_split", "is_optional": true, "type": "others", "default_value": "0.2", "description": "Fraction of the dataset to be used as test data."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "113", "description": "random seed for sample shuffling."}, {"name": "start_char", "is_optional": true, "type": "int", "default_value": "1", "description": "The start of a sequence will be marked with this character.\nSet to 1 because 0 is usually the padding character."}, {"name": "oov_char", "is_optional": true, "type": "int", "default_value": "2", "description": "words that were cut out because of the num_words\nor skip_top limit will be replaced with this character."}, {"name": "index_from", "is_optional": true, "type": "int", "default_value": "3", "description": "index actual words with this index and higher."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Used for backwards compatibility."}]}},
{"id": "tf.keras.datasets.imdb.load_data", "type": "function", "code": "tf.keras.datasets.imdb.load_data(path='imdb.npz',num_words=None,skip_top=0,maxlen=None,seed=113,start_char=1,oov_char=2,index_from=3,**kwargs)", "summary": "Loads the IMDB dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.imdb.load_data", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'imdb.npz'", "description": "where to cache the data (relative to ~/.keras/dataset)."}, {"name": "num_words", "is_optional": true, "type": "others", "default_value": "None", "description": "max number of words to include. Words are ranked\nby how often they occur (in the training set) and only\nthe most frequent words are kept"}, {"name": "skip_top", "is_optional": true, "type": "int", "default_value": "0", "description": "skip the top N most frequently occurring words\n(which may not be informative)."}, {"name": "maxlen", "is_optional": true, "type": "others", "default_value": "None", "description": "sequences longer than this will be filtered out."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "113", "description": "random seed for sample shuffling."}, {"name": "start_char", "is_optional": true, "type": "int", "default_value": "1", "description": "The start of a sequence will be marked with this character.\nSet to 1 because 0 is usually the padding character."}, {"name": "oov_char", "is_optional": true, "type": "int", "default_value": "2", "description": "words that were cut out because of the num_words\nor skip_top limit will be replaced with this character."}, {"name": "index_from", "is_optional": true, "type": "int", "default_value": "3", "description": "index actual words with this index and higher."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Used for backwards compatibility."}]}},
{"id": "tf.keras.datasets.fashion_mnist.load_data", "type": "function", "code": "tf.keras.datasets.fashion_mnist.load_data()", "summary": "Loads the Fashion-MNIST dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.fashion_mnist.load_data", "parameters": []}},
{"id": "tf.keras.datasets.cifar10.load_data", "type": "function", "code": "tf.keras.datasets.cifar10.load_data()", "summary": "Loads CIFAR10 dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.cifar10.load_data", "parameters": []}},
{"id": "tf.keras.datasets.imdb.get_word_index", "type": "function", "code": "tf.keras.datasets.imdb.get_word_index(path='imdb_word_index.json')", "summary": "Retrieves the dictionary mapping word indices back to words.", "description": "", "code-info": {"name": "tf.keras.datasets.imdb.get_word_index", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'imdb_word_index.json'", "description": "where to cache the data (relative to ~/.keras/dataset)."}]}},
{"id": "tf.keras.datasets.cifar100.load_data", "type": "function", "code": "tf.keras.datasets.cifar100.load_data(label_mode='fine')", "summary": "Loads CIFAR100 dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.cifar100.load_data", "parameters": [{"name": "label_mode", "is_optional": true, "type": "string", "default_value": "'fine'", "description": "one of \"fine\", \"coarse\"."}]}},
{"id": "tf.keras.constraints.UnitNorm", "type": "function", "code": "tf.keras.constraints.UnitNorm(axis=0)", "summary": "Constrains the weights incident to each hidden unit to have unit norm.\n\nInherits From: Constraint", "description": "", "code-info": {"name": "tf.keras.constraints.UnitNorm", "parameters": [{"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "integer, axis along which to calculate weight norms.\nFor instance, in a Dense layer the weight matrix\nhas shape (input_dim, output_dim),\nset axis to 0 to constrain each weight vector\nof length (input_dim,).\nIn a Conv2D layer with data_format=\"channels_last\",\nthe weight tensor has shape\n(rows, cols, input_depth, output_depth),\nset axis to [0, 1, 2]\nto constrain the weights of each filter tensor of size\n(rows, cols, input_depth)."}]}},
{"id": "tf.keras.datasets.boston_housing.load_data", "type": "function", "code": "tf.keras.datasets.boston_housing.load_data(path='boston_housing.npz',test_split=0.2,seed=113)", "summary": "Loads the Boston Housing dataset.", "description": "", "code-info": {"name": "tf.keras.datasets.boston_housing.load_data", "parameters": [{"name": "path", "is_optional": true, "type": "string", "default_value": "'boston_housing.npz'", "description": "path where to cache the dataset locally\n(relative to ~/.keras/datasets)."}, {"name": "test_split", "is_optional": true, "type": "others", "default_value": "0.2", "description": "fraction of the data to reserve as test set."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "113", "description": "Random seed for shuffling the data\nbefore computing the test split."}]}},
{"id": "tf.keras.constraints.serialize", "type": "function", "code": "tf.keras.constraints.serialize(constraint)", "summary": "", "description": "", "code-info": {"name": "tf.keras.constraints.serialize", "parameters": [{"name": "constraint", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "__call__", "type": "function", "code": "__call__(w)", "summary": "Constrains Conv2D kernel weights to be the same for each radius.\n\nInherits From: Constraint", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "w", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.constraints.MinMaxNorm", "type": "function", "code": "tf.keras.constraints.MinMaxNorm(min_value=0.0,max_value=1.0,rate=1.0,axis=0)", "summary": "MinMaxNorm weight constraint.\n\nInherits From: Constraint", "description": "", "code-info": {"name": "tf.keras.constraints.MinMaxNorm", "parameters": [{"name": "min_value", "is_optional": true, "type": "others", "default_value": "0.0", "description": "the minimum norm for the incoming weights."}, {"name": "max_value", "is_optional": true, "type": "others", "default_value": "1.0", "description": "the maximum norm for the incoming weights."}, {"name": "rate", "is_optional": true, "type": "string", "default_value": "1.0", "description": "rate for enforcing the constraint: weights will be\nrescaled to yield\n(1 - rate) * norm + rate * norm.clip(min_value, max_value).\nEffectively, this means that rate=1.0 stands for strict\nenforcement of the constraint, while rate&lt;1.0 means that\nweights will be rescaled at each step to slowly move\ntowards a value inside the desired interval."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "integer, axis along which to calculate weight norms.\nFor instance, in a Dense layer the weight matrix\nhas shape (input_dim, output_dim),\nset axis to 0 to constrain each weight vector\nof length (input_dim,).\nIn a Conv2D layer with data_format=\"channels_last\",\nthe weight tensor has shape\n(rows, cols, input_depth, output_depth),\nset axis to [0, 1, 2]\nto constrain the weights of each filter tensor of size\n(rows, cols, input_depth)."}]}},
{"id": "__call__", "type": "function", "code": "__call__(w)", "summary": "Constrains the weights to be non-negative.\n\nInherits From: Constraint", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "w", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.callbacks.ProgbarLogger", "type": "function", "code": "tf.keras.callbacks.ProgbarLogger(count_mode='samples',stateful_metrics=None)", "summary": "Callback that prints metrics to stdout.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.ProgbarLogger", "parameters": [{"name": "count_mode", "is_optional": true, "type": "string", "default_value": "'samples'", "description": "One of \"steps\" or \"samples\".\nWhether the progress bar should\ncount samples seen or steps (batches) seen."}, {"name": "stateful_metrics", "is_optional": true, "type": "string", "default_value": "None", "description": "Iterable of string names of metrics that\nshould not be averaged over an epoch.\nMetrics in this list will be logged as-is.\nAll others will be averaged over time (e.g. loss, etc)."}]}},
{"id": "tf.keras.callbacks.ReduceLROnPlateau", "type": "function", "code": "tf.keras.callbacks.ReduceLROnPlateau(monitor='val_loss',factor=0.1,patience=10,verbose=0,mode='auto',min_delta=0.0001,cooldown=0,min_lr=0,**kwargs)", "summary": "Reduce learning rate when a metric has stopped improving.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.ReduceLROnPlateau", "parameters": [{"name": "monitor", "is_optional": true, "type": "string", "default_value": "'val_loss'", "description": "quantity to be monitored."}, {"name": "factor", "is_optional": true, "type": "others", "default_value": "0.1", "description": "factor by which the learning rate will be reduced. new_lr = lr *\nfactor"}, {"name": "patience", "is_optional": true, "type": "int", "default_value": "10", "description": "number of epochs with no improvement after which learning rate\nwill be reduced."}, {"name": "verbose", "is_optional": true, "type": "int", "default_value": "0", "description": "int. 0: quiet, 1: update messages."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'auto'", "description": "one of {auto, min, max}. In min mode, lr will be reduced when the\nquantity monitored has stopped decreasing; in max mode it will be\nreduced when the quantity monitored has stopped increasing; in auto\nmode, the direction is automatically inferred from the name of the\nmonitored quantity."}, {"name": "min_delta", "is_optional": true, "type": "others", "default_value": "0.0001", "description": "threshold for measuring the new optimum, to only focus on\nsignificant changes."}, {"name": "cooldown", "is_optional": true, "type": "int", "default_value": "0", "description": "number of epochs to wait before resuming normal operation after\nlr has been reduced."}, {"name": "min_lr", "is_optional": true, "type": "int", "default_value": "0", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.constraints.deserialize", "type": "function", "code": "tf.keras.constraints.deserialize(config,custom_objects=None)", "summary": "", "description": "", "code-info": {"name": "tf.keras.constraints.deserialize", "parameters": [{"name": "config", "is_optional": false, "type": "others", "description": ""}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "__call__", "type": "function", "code": "__call__(w)", "summary": "", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "w", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.constraints.MaxNorm", "type": "function", "code": "tf.keras.constraints.MaxNorm(max_value=2,axis=0)", "summary": "MaxNorm weight constraint.\n\nInherits From: Constraint", "description": "", "code-info": {"name": "tf.keras.constraints.MaxNorm", "parameters": [{"name": "max_value", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "integer, axis along which to calculate weight norms.\nFor instance, in a Dense layer the weight matrix\nhas shape (input_dim, output_dim),\nset axis to 0 to constrain each weight vector\nof length (input_dim,).\nIn a Conv2D layer with data_format=\"channels_last\",\nthe weight tensor has shape\n(rows, cols, input_depth, output_depth),\nset axis to [0, 1, 2]\nto constrain the weights of each filter tensor of size\n(rows, cols, input_depth)."}]}},
{"id": "tf.keras.callbacks.ModelCheckpoint", "type": "function", "code": "tf.keras.callbacks.ModelCheckpoint(filepath,monitor='val_loss',verbose=0,save_best_only=False,save_weights_only=False,mode='auto',save_freq='epoch',**kwargs)", "summary": "Save the model after every epoch.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.ModelCheckpoint", "parameters": [{"name": "filepath", "is_optional": false, "type": "string", "description": "string, path to save the model file."}, {"name": "monitor", "is_optional": true, "type": "string", "default_value": "'val_loss'", "description": "quantity to monitor."}, {"name": "verbose", "is_optional": true, "type": "int", "default_value": "0", "description": "verbosity mode, 0 or 1."}, {"name": "save_best_only", "is_optional": true, "type": "bool", "default_value": "False", "description": "if save_best_only=True, the latest best model according\nto the quantity monitored will not be overwritten.\nIf filepath doesn't contain formatting options like {epoch} then\nfilepath will be overwritten by each new better model.\nmode: one of {auto, min, max}. If save_best_only=True, the decision to\noverwrite the current save file is made based on either the maximization\nor the minimization of the monitored quantity. For val_acc, this\nshould be max, for val_loss this should be min, etc. In auto\nmode, the direction is automatically inferred from the name of the\nmonitored quantity."}, {"name": "save_weights_only", "is_optional": true, "type": "bool", "default_value": "False", "description": "if True, then only the model's weights will be saved\n(model.save_weights(filepath)), else the full model is saved\n(model.save(filepath)).\nsave_freq: 'epoch' or integer. When using 'epoch', the callback saves\nthe model after each epoch. When using integer, the callback saves the\nmodel at end of a batch at which this many samples have been seen since\nlast saving. Note that if the saving isn't aligned to epochs, the\nmonitored metric may potentially be less reliable (it could reflect as\nlittle as 1 batch, since the metrics get reset every epoch). Defaults to\n'epoch'\n**kwargs: Additional arguments for backwards compatibility. Possible key\nis period.\n\n\nMethods\n\nset_model\n\nView source\nset_model(\n    model\n)\n\nset_params\n\nView source\nset_params(\n    params\n)\n\n\n          "}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'auto'", "description": "one of {auto, min, max}. If save_best_only=True, the decision to\noverwrite the current save file is made based on either the maximization\nor the minimization of the monitored quantity. For val_acc, this\nshould be max, for val_loss this should be min, etc. In auto\nmode, the direction is automatically inferred from the name of the\nmonitored quantity.\nsave_weights_only: if True, then only the model's weights will be saved\n(model.save_weights(filepath)), else the full model is saved\n(model.save(filepath))."}, {"name": "save_freq", "is_optional": true, "type": "string", "default_value": "'epoch'", "description": "'epoch' or integer. When using 'epoch', the callback saves\nthe model after each epoch. When using integer, the callback saves the\nmodel at end of a batch at which this many samples have been seen since\nlast saving. Note that if the saving isn't aligned to epochs, the\nmonitored metric may potentially be less reliable (it could reflect as\nlittle as 1 batch, since the metrics get reset every epoch). Defaults to\n'epoch'"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Additional arguments for backwards compatibility. Possible key\nis period."}]}},
{"id": "tf.keras.constraints.get", "type": "function", "code": "tf.keras.constraints.get(identifier)", "summary": "", "description": "", "code-info": {"name": "tf.keras.constraints.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.callbacks.LambdaCallback", "type": "function", "code": "tf.keras.callbacks.LambdaCallback(on_epoch_begin=None,on_epoch_end=None,on_batch_begin=None,on_batch_end=None,on_train_begin=None,on_train_end=None,**kwargs)", "summary": "Callback for creating simple, custom callbacks on-the-fly.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.LambdaCallback", "parameters": [{"name": "on_epoch_begin", "is_optional": true, "type": "others", "default_value": "None", "description": "called at the beginning of every epoch."}, {"name": "on_epoch_end", "is_optional": true, "type": "others", "default_value": "None", "description": "called at the end of every epoch."}, {"name": "on_batch_begin", "is_optional": true, "type": "others", "default_value": "None", "description": "called at the beginning of every batch."}, {"name": "on_batch_end", "is_optional": true, "type": "others", "default_value": "None", "description": "called at the end of every batch."}, {"name": "on_train_begin", "is_optional": true, "type": "others", "default_value": "None", "description": "called at the beginning of model training."}, {"name": "on_train_end", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.callbacks.LearningRateScheduler", "type": "function", "code": "tf.keras.callbacks.LearningRateScheduler(schedule,verbose=0)", "summary": "Learning rate scheduler.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.LearningRateScheduler", "parameters": [{"name": "schedule", "is_optional": false, "type": "others", "description": "a function that takes an epoch index as input\n(integer, indexed from 0) and returns a new\nlearning rate as output (float)."}, {"name": "verbose", "is_optional": true, "type": "int", "default_value": "0", "description": "int. 0: quiet, 1: update messages."}]}},
{"id": "tf.keras.callbacks.CSVLogger", "type": "function", "code": "tf.keras.callbacks.CSVLogger(filename,separator=',',append=False)", "summary": "Callback that streams epoch results to a csv file.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.CSVLogger", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "filename of the csv file, e.g. 'run/log.csv'."}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "append", "is_optional": true, "type": "bool", "default_value": "False", "description": "True: append if file exists (useful for continuing\ntraining). False: overwrite existing file,"}]}},
{"id": "tf.keras.callbacks.Callback", "type": "class", "code": "tf.keras.callbacks.Callback()", "summary": "Abstract base class used to build new callbacks.", "description": "", "code-info": {"name": "tf.keras.callbacks.Callback", "parameters": []}},
{"id": "tf.keras.callbacks.BaseLogger", "type": "function", "code": "tf.keras.callbacks.BaseLogger(stateful_metrics=None)", "summary": "Callback that accumulates epoch averages of metrics.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.BaseLogger", "parameters": [{"name": "stateful_metrics", "is_optional": true, "type": "string", "default_value": "None", "description": "Iterable of string names of metrics that\nshould not be averaged over an epoch.\nMetrics in this list will be logged as-is in on_epoch_end.\nAll others will be averaged in on_epoch_end."}]}},
{"id": "tf.keras.callbacks.History", "type": "function", "code": "tf.keras.callbacks.History()", "summary": "Callback that records events into a History object.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.History", "parameters": []}},
{"id": "tf.keras.callbacks.EarlyStopping", "type": "function", "code": "tf.keras.callbacks.EarlyStopping(monitor='val_loss',min_delta=0,patience=0,verbose=0,mode='auto',baseline=None,restore_best_weights=False)", "summary": "Stop training when a monitored quantity has stopped improving.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.keras.callbacks.EarlyStopping", "parameters": [{"name": "monitor", "is_optional": true, "type": "string", "default_value": "'val_loss'", "description": "Quantity to be monitored."}, {"name": "min_delta", "is_optional": true, "type": "int", "default_value": "0", "description": "Minimum change in the monitored quantity\nto qualify as an improvement, i.e. an absolute\nchange of less than min_delta, will count as no\nimprovement."}, {"name": "patience", "is_optional": true, "type": "int", "default_value": "0", "description": "Number of epochs with no improvement\nafter which training will be stopped."}, {"name": "verbose", "is_optional": true, "type": "int", "default_value": "0", "description": "verbosity mode."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'auto'", "description": "One of {\"auto\", \"min\", \"max\"}. In min mode,\ntraining will stop when the quantity\nmonitored has stopped decreasing; in max\nmode it will stop when the quantity\nmonitored has stopped increasing; in auto\nmode, the direction is automatically inferred\nfrom the name of the monitored quantity."}, {"name": "baseline", "is_optional": true, "type": "others", "default_value": "None", "description": "Baseline value for the monitored quantity.\nTraining will stop if the model doesn't show improvement over the\nbaseline."}, {"name": "restore_best_weights", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to restore model weights from\nthe epoch with the best value of the monitored quantity.\nIf False, the model weights obtained at the last step of\ntraining are used."}]}},
{"id": "tf.keras.backend.zeros_like", "type": "function", "code": "tf.keras.backend.zeros_like(x,dtype=None,name=None)", "summary": "Instantiates an all-zeros variable of the same shape as another tensor.", "description": "", "code-info": {"name": "tf.keras.backend.zeros_like", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Keras variable or Keras tensor."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "dtype of returned Keras variable.\n   None uses the dtype of x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name for the variable to create."}]}},
{"id": "tf.keras.backend.zeros", "type": "function", "code": "tf.keras.backend.zeros(shape,dtype=None,name=None)", "summary": "Instantiates an all-zeros variable and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.zeros", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "Tuple or list of integers, shape of returned Keras variable"}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "data type of returned Keras variable"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name of returned Keras variable"}]}},
{"id": "tf.keras.backend.variable", "type": "function", "code": "tf.keras.backend.variable(value,dtype=None,name=None,constraint=None)", "summary": "Instantiates a variable and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.variable", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "Numpy array, initial value of the tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor type."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name string for the tensor."}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional projection function to be\napplied to the variable after an optimizer update."}]}},
{"id": "tf.keras.backend.var", "type": "function", "code": "tf.keras.backend.var(x,axis=None,keepdims=False)", "summary": "Variance of a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.var", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to compute the variance."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.update_sub", "type": "function", "code": "tf.keras.backend.update_sub(x,decrement)", "summary": "Update the value of x by subtracting decrement.", "description": "", "code-info": {"name": "tf.keras.backend.update_sub", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "decrement", "is_optional": false, "type": "tensor", "description": "A tensor of same shape as x."}]}},
{"id": "tf.keras.backend.update_add", "type": "function", "code": "tf.keras.backend.update_add(x,increment)", "summary": "Update the value of x by adding increment.", "description": "", "code-info": {"name": "tf.keras.backend.update_add", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "increment", "is_optional": false, "type": "tensor", "description": "A tensor of same shape as x."}]}},
{"id": "tf.keras.backend.update", "type": "function", "code": "tf.keras.backend.update(x,new_x)", "summary": "", "description": "", "code-info": {"name": "tf.keras.backend.update", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": "new_x", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.backend.truncated_normal", "type": "function", "code": "tf.keras.backend.truncated_normal(shape,mean=0.0,stddev=1.0,dtype=None,seed=None)", "summary": "Returns a tensor with truncated random normal distribution of values.", "description": "", "code-info": {"name": "tf.keras.backend.truncated_normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A tuple of integers, the shape of tensor to create."}, {"name": "mean", "is_optional": true, "type": "others", "default_value": "0.0", "description": "Mean of the values."}, {"name": "stddev", "is_optional": true, "type": "others", "default_value": "1.0", "description": "Standard deviation of the values."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "String, dtype of returned tensor."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.transpose", "type": "function", "code": "tf.keras.backend.transpose(x)", "summary": "Transposes a tensor and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.transpose", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.std", "type": "function", "code": "tf.keras.backend.std(x,axis=None,keepdims=False)", "summary": "Standard deviation of a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.std", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to compute the standard deviation."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.temporal_padding", "type": "function", "code": "tf.keras.backend.temporal_padding(x,padding=(1,1))", "summary": "Pads the middle dimension of a 3D tensor.", "description": "", "code-info": {"name": "tf.keras.backend.temporal_padding", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "padding", "is_optional": false, "type": "int", "description": "Tuple of 2 integers, how many zeros to\nadd at the start and end of dim 1."}]}},
{"id": "tf.keras.backend.to_dense", "type": "function", "code": "tf.keras.backend.to_dense(tensor)", "summary": "Converts a sparse tensor into a dense tensor and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.to_dense", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A tensor instance (potentially sparse)."}]}},
{"id": "tf.keras.backend.switch", "type": "function", "code": "tf.keras.backend.switch(condition,then_expression,else_expression)", "summary": "Switches between two operations depending on a scalar value.", "description": "", "code-info": {"name": "tf.keras.backend.switch", "parameters": [{"name": "condition", "is_optional": false, "type": "tensor", "description": "tensor (int or bool)."}, {"name": "then_expression", "is_optional": false, "type": "tensor", "description": "either a tensor, or a callable that returns a tensor."}, {"name": "else_expression", "is_optional": false, "type": "tensor", "description": "either a tensor, or a callable that returns a tensor."}]}},
{"id": "tf.keras.backend.stop_gradient", "type": "function", "code": "tf.keras.backend.stop_gradient(variables)", "summary": "Returns variables but with zero gradient w.r.t. every other variable.", "description": "", "code-info": {"name": "tf.keras.backend.stop_gradient", "parameters": [{"name": "variables", "is_optional": false, "type": "tensor", "description": "Tensor or list of tensors to consider constant with respect\nto any other variable."}]}},
{"id": "tf.keras.backend.stack", "type": "function", "code": "tf.keras.backend.stack(x,axis=0)", "summary": "Stacks a list of rank R tensors into a rank R+1 tensor.", "description": "", "code-info": {"name": "tf.keras.backend.stack", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "List of tensors."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Axis along which to perform stacking."}]}},
{"id": "tf.keras.backend.tile", "type": "function", "code": "tf.keras.backend.tile(x,n)", "summary": "Creates a tensor by tiling x by n.", "description": "", "code-info": {"name": "tf.keras.backend.tile", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable"}, {"name": "n", "is_optional": false, "type": "int", "description": "A list of integer. The length must be the same as the number of\ndimensions in x."}]}},
{"id": "tf.keras.backend.sum", "type": "function", "code": "tf.keras.backend.sum(x,axis=None,keepdims=False)", "summary": "Sum of the values in a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.sum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to sum over."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.square", "type": "function", "code": "tf.keras.backend.square(x)", "summary": "Element-wise square.", "description": "", "code-info": {"name": "tf.keras.backend.square", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.sparse_categorical_crossentropy", "type": "function", "code": "tf.keras.backend.sparse_categorical_crossentropy(target,output,from_logits=False,axis=-1)", "summary": "Categorical crossentropy with integer targets.", "description": "", "code-info": {"name": "tf.keras.backend.sparse_categorical_crossentropy", "parameters": [{"name": "target", "is_optional": false, "type": "tensor", "description": "An integer tensor."}, {"name": "output", "is_optional": false, "type": "tensor", "description": "A tensor resulting from a softmax\n(unless from_logits is True, in which\ncase output is expected to be the logits)."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether output is the\nresult of a softmax, or is a tensor of logits."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Int specifying the channels axis. axis=-1 corresponds to data\nformat channels_last', andaxis=1corresponds to data formatchannels_first`."}]}},
{"id": "tf.keras.backend.squeeze", "type": "function", "code": "tf.keras.backend.squeeze(x,axis)", "summary": "Removes a 1-dimension from the tensor at index \"axis\".", "description": "", "code-info": {"name": "tf.keras.backend.squeeze", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": false, "type": "others", "description": "Axis to drop."}]}},
{"id": "tf.keras.backend.tanh", "type": "function", "code": "tf.keras.backend.tanh(x)", "summary": "Element-wise tanh.", "description": "", "code-info": {"name": "tf.keras.backend.tanh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.sqrt", "type": "function", "code": "tf.keras.backend.sqrt(x)", "summary": "Element-wise square root.", "description": "", "code-info": {"name": "tf.keras.backend.sqrt", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.spatial_3d_padding", "type": "function", "code": "tf.keras.backend.spatial_3d_padding(x,padding=((1,1),(1,1),(1,1)),data_format=None)", "summary": "Pads 5D tensor with zeros along the depth, height, width dimensions.", "description": "", "code-info": {"name": "tf.keras.backend.spatial_3d_padding", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "padding", "is_optional": false, "type": "others", "description": "Tuple of 3 tuples, padding pattern.\ndata_format: One of channels_last or channels_first."}]}},
{"id": "tf.keras.backend.spatial_2d_padding", "type": "function", "code": "tf.keras.backend.spatial_2d_padding(x,padding=((1,1),(1,1)),data_format=None)", "summary": "Pads the 2nd and 3rd dimensions of a 4D tensor.", "description": "", "code-info": {"name": "tf.keras.backend.spatial_2d_padding", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "padding", "is_optional": false, "type": "others", "description": "Tuple of 2 tuples, padding pattern.\ndata_format: One of channels_last or channels_first."}]}},
{"id": "tf.keras.backend.softsign", "type": "function", "code": "tf.keras.backend.softsign(x)", "summary": "Softsign of a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.softsign", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.sigmoid", "type": "function", "code": "tf.keras.backend.sigmoid(x)", "summary": "Element-wise sigmoid.", "description": "", "code-info": {"name": "tf.keras.backend.sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.sign", "type": "function", "code": "tf.keras.backend.sign(x)", "summary": "Element-wise sign.", "description": "", "code-info": {"name": "tf.keras.backend.sign", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.set_learning_phase", "type": "function", "code": "tf.keras.backend.set_learning_phase(value)", "summary": "Sets the learning phase to a fixed value.", "description": "", "code-info": {"name": "tf.keras.backend.set_learning_phase", "parameters": [{"name": "value", "is_optional": false, "type": "int", "description": "Learning phase value, either 0 or 1 (integers).\n   0 = test, 1 = train"}]}},
{"id": "tf.keras.backend.set_image_data_format", "type": "function", "code": "tf.keras.backend.set_image_data_format(data_format)", "summary": "Sets the value of the image data format convention.", "description": "", "code-info": {"name": "tf.keras.backend.set_image_data_format", "parameters": [{"name": "data_format", "is_optional": false, "type": "string", "description": "string. 'channels_first' or 'channels_last'.\nExample: python from keras import backend as K K.image_data_format() &gt;&gt;&gt;\n'channels_first' K.set_image_data_format('channels_last')\nK.image_data_format() &gt;&gt;&gt; 'channels_last'"}]}},
{"id": "tf.keras.backend.shape", "type": "function", "code": "tf.keras.backend.shape(x)", "summary": "Returns the symbolic shape of a tensor or variable.", "description": "", "code-info": {"name": "tf.keras.backend.shape", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.softplus", "type": "function", "code": "tf.keras.backend.softplus(x)", "summary": "Softplus of a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.softplus", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.softmax", "type": "function", "code": "tf.keras.backend.softmax(x,axis=-1)", "summary": "Softmax of a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.softmax", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The dimension softmax would be performed on.\nThe default is -1 which indicates the last dimension."}]}},
{"id": "tf.keras.backend.sin", "type": "function", "code": "tf.keras.backend.sin(x)", "summary": "Computes sin of x element-wise.", "description": "", "code-info": {"name": "tf.keras.backend.sin", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.set_floatx", "type": "function", "code": "tf.keras.backend.set_floatx(value)", "summary": "Sets the default float type.", "description": "", "code-info": {"name": "tf.keras.backend.set_floatx", "parameters": [{"name": "value", "is_optional": false, "type": "float", "description": "String; 'float16', 'float32', or 'float64'.\nExample: python from keras import backend as K K.floatx() &gt;&gt;&gt; 'float32'\nK.set_floatx('float16') K.floatx() &gt;&gt;&gt; 'float16'"}]}},
{"id": "tf.keras.backend.set_value", "type": "function", "code": "tf.keras.backend.set_value(x,value)", "summary": "Sets the value of a variable, from a Numpy array.", "description": "", "code-info": {"name": "tf.keras.backend.set_value", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor to set to a new value."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "Value to set the tensor to, as a Numpy array\n(of the same shape)."}]}},
{"id": "tf.keras.backend.separable_conv2d", "type": "function", "code": "tf.keras.backend.separable_conv2d(x,depthwise_kernel,pointwise_kernel,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1))", "summary": "2D convolution with separable filters.", "description": "", "code-info": {"name": "tf.keras.backend.separable_conv2d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "input tensor"}, {"name": "depthwise_kernel", "is_optional": false, "type": "others", "description": "convolution kernel for the depthwise convolution."}, {"name": "pointwise_kernel", "is_optional": false, "type": "others", "description": "kernel for the 1x1 convolution."}, {"name": "strides", "is_optional": false, "type": "string", "description": "strides tuple (length 2).\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\ndilation_rate: tuple of integers,\ndilation rates for the separable convolution."}]}},
{"id": "tf.keras.backend.reverse", "type": "function", "code": "tf.keras.backend.reverse(x,axes)", "summary": "Reverse a tensor along the specified axes.", "description": "", "code-info": {"name": "tf.keras.backend.reverse", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor to reverse."}, {"name": "axes", "is_optional": false, "type": "int", "description": "Integer or iterable of integers.\nAxes to reverse."}]}},
{"id": "tf.keras.backend.reset_uids", "type": "function", "code": "tf.keras.backend.reset_uids()", "summary": "Resets graph identifiers.", "description": "", "code-info": {"name": "tf.keras.backend.reset_uids", "parameters": []}},
{"id": "tf.keras.backend.set_epsilon", "type": "function", "code": "tf.keras.backend.set_epsilon(value)", "summary": "Sets the value of the fuzz factor used in numeric expressions.", "description": "", "code-info": {"name": "tf.keras.backend.set_epsilon", "parameters": [{"name": "value", "is_optional": false, "type": "float", "description": "float. New value of epsilon.\nExample: python from keras import backend as K K.epsilon() &gt;&gt;&gt; 1e-07\nK.set_epsilon(1e-05) K.epsilon() &gt;&gt;&gt; 1e-05"}]}},
{"id": "tf.keras.backend.round", "type": "function", "code": "tf.keras.backend.round(x)", "summary": "Element-wise rounding to the closest integer.", "description": "", "code-info": {"name": "tf.keras.backend.round", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.resize_volumes", "type": "function", "code": "tf.keras.backend.resize_volumes(x,depth_factor,height_factor,width_factor,data_format)", "summary": "Resizes the volume contained in a 5D tensor.", "description": "", "code-info": {"name": "tf.keras.backend.resize_volumes", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable to resize."}, {"name": "depth_factor", "is_optional": false, "type": "int", "description": "Positive integer."}, {"name": "height_factor", "is_optional": false, "type": "int", "description": "Positive integer."}, {"name": "width_factor", "is_optional": false, "type": "int", "description": "Positive integer."}, {"name": "data_format", "is_optional": false, "type": "others", "description": "One of \"channels_first\", \"channels_last\"."}]}},
{"id": "tf.keras.backend.resize_images", "type": "function", "code": "tf.keras.backend.resize_images(x,height_factor,width_factor,data_format,interpolation='nearest')", "summary": "Resizes the images contained in a 4D tensor.", "description": "", "code-info": {"name": "tf.keras.backend.resize_images", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable to resize."}, {"name": "height_factor", "is_optional": false, "type": "int", "description": "Positive integer."}, {"name": "width_factor", "is_optional": false, "type": "int", "description": "Positive integer."}, {"name": "data_format", "is_optional": false, "type": "others", "description": "One of \"channels_first\", \"channels_last\"."}, {"name": "interpolation", "is_optional": true, "type": "string", "default_value": "'nearest'", "description": "A string, one of nearest or bilinear."}]}},
{"id": "tf.keras.backend.reshape", "type": "function", "code": "tf.keras.backend.reshape(x,shape)", "summary": "Reshapes a tensor to the specified shape.", "description": "", "code-info": {"name": "tf.keras.backend.reshape", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "shape", "is_optional": false, "type": "others", "description": "Target shape tuple."}]}},
{"id": "tf.keras.backend.rnn", "type": "function", "code": "tf.keras.backend.rnn(step_function,inputs,initial_states,go_backwards=False,mask=None,constants=None,unroll=False,input_length=None,time_major=False,zero_output_for_mask=False)", "summary": "Iterates over the time dimension of a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.rnn", "parameters": [{"name": "step_function", "is_optional": false, "type": "tensor", "description": "RNN step function.\nArgs;\n    input; Tensor with shape (samples, ...) (no time dimension),\n        representing input for the batch of samples at a certain\n        time step.\n    states; List of tensors.\nReturns;\n    output; Tensor with shape (samples, output_dim)\n        (no time dimension).\n    new_states; List of tensors, same length and shapes\n        as 'states'. The first state in the list must be the\n        output tensor at the previous timestep."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor of temporal data of shape (samples, time, ...)\n(at least 3D), or nested tensors, and each of which has shape\n(samples, time, ...)."}, {"name": "initial_states", "is_optional": false, "type": "tensor", "description": "Tensor with shape (samples, state_size)\n(no time dimension), containing the initial values for the states used\nin the step function. In the case that state_size is in a nested\nshape, the shape of initial_states will also follow the nested\nstructure."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. If True, do the iteration over the time\ndimension in reverse order and return the reversed sequence."}, {"name": "mask", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Binary tensor with shape (samples, time, 1),\nwith a zero for every element that is masked."}, {"name": "constants", "is_optional": true, "type": "others", "default_value": "None", "description": "List of constant values passed at each step."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to unroll the RNN or to use a symbolic while_loop."}, {"name": "input_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An integer or a 1-D Tensor, depending on whether\nthe time dimension is fixed-length or not. In case of variable length\ninput, it is used for masking in case there's no mask specified."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. If true, the inputs and outputs will be in shape\n(timesteps, batch, ...), whereas in the False case, it will be\n(batch, timesteps, ...). Using time_major = True is a bit more\nefficient because it avoids transposes at the beginning and end of the\nRNN calculation. However, most TensorFlow data is batch-major, so by\ndefault this function accepts input and emits output in batch-major\nform."}, {"name": "zero_output_for_mask", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. If True, the output for masked timestep\nwill be zeros, whereas in the False case, output from previous\ntimestep is returned."}]}},
{"id": "tf.keras.backend.random_uniform", "type": "function", "code": "tf.keras.backend.random_uniform(shape,minval=0.0,maxval=1.0,dtype=None,seed=None)", "summary": "Returns a tensor with uniform distribution of values.", "description": "", "code-info": {"name": "tf.keras.backend.random_uniform", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A tuple of integers, the shape of tensor to create."}, {"name": "minval", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float, lower boundary of the uniform distribution\nto draw samples."}, {"name": "maxval", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A float, upper boundary of the uniform distribution\nto draw samples."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "String, dtype of returned tensor."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.random_normal_variable", "type": "function", "code": "tf.keras.backend.random_normal_variable(shape,mean,scale,dtype=None,name=None,seed=None)", "summary": "Instantiates a variable with values drawn from a normal distribution.", "description": "", "code-info": {"name": "tf.keras.backend.random_normal_variable", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "Tuple of integers, shape of returned Keras variable."}, {"name": "mean", "is_optional": false, "type": "float", "description": "Float, mean of the normal distribution."}, {"name": "scale", "is_optional": false, "type": "float", "description": "Float, standard deviation of the normal distribution."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "String, dtype of returned Keras variable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name of returned Keras variable."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.relu", "type": "function", "code": "tf.keras.backend.relu(x,alpha=0.0,max_value=None,threshold=0)", "summary": "Rectified linear unit.", "description": "", "code-info": {"name": "tf.keras.backend.relu", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "alpha", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A scalar, slope of negative section (default=0.)."}, {"name": "max_value", "is_optional": true, "type": "float", "default_value": "None", "description": "float. Saturation threshold."}, {"name": "threshold", "is_optional": true, "type": "int", "default_value": "0", "description": "float. Threshold value for thresholded activation."}]}},
{"id": "tf.keras.backend.random_uniform_variable", "type": "function", "code": "tf.keras.backend.random_uniform_variable(shape,low,high,dtype=None,name=None,seed=None)", "summary": "Instantiates a variable with values drawn from a uniform distribution.", "description": "", "code-info": {"name": "tf.keras.backend.random_uniform_variable", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "Tuple of integers, shape of returned Keras variable."}, {"name": "low", "is_optional": false, "type": "float", "description": "Float, lower boundary of the output interval."}, {"name": "high", "is_optional": false, "type": "float", "description": "Float, upper boundary of the output interval."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "String, dtype of returned Keras variable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name of returned Keras variable."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.repeat_elements", "type": "function", "code": "tf.keras.backend.repeat_elements(x,rep,axis)", "summary": "Repeats the elements of a tensor along an axis, like np.repeat.", "description": "", "code-info": {"name": "tf.keras.backend.repeat_elements", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "rep", "is_optional": false, "type": "int", "description": "Python integer, number of times to repeat."}, {"name": "axis", "is_optional": false, "type": "others", "description": "Axis along which to repeat."}]}},
{"id": "tf.keras.backend.repeat", "type": "function", "code": "tf.keras.backend.repeat(x,n)", "summary": "Repeats a 2D tensor.", "description": "", "code-info": {"name": "tf.keras.backend.repeat", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "n", "is_optional": false, "type": "int", "description": "Python integer, number of times to repeat."}]}},
{"id": "tf.keras.backend.random_normal", "type": "function", "code": "tf.keras.backend.random_normal(shape,mean=0.0,stddev=1.0,dtype=None,seed=None)", "summary": "Returns a tensor with normal distribution of values.", "description": "", "code-info": {"name": "tf.keras.backend.random_normal", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A tuple of integers, the shape of tensor to create."}, {"name": "mean", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float, mean of the normal distribution to draw samples."}, {"name": "stddev", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A float, standard deviation of the normal distribution\nto draw samples."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "String, dtype of returned tensor."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.random_binomial", "type": "function", "code": "tf.keras.backend.random_binomial(shape,p=0.0,dtype=None,seed=None)", "summary": "Returns a tensor with random binomial distribution of values.", "description": "", "code-info": {"name": "tf.keras.backend.random_binomial", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A tuple of integers, the shape of tensor to create."}, {"name": "p", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float, 0. &lt;= p &lt;= 1, probability of binomial distribution."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "String, dtype of returned tensor."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, random seed."}]}},
{"id": "tf.keras.backend.prod", "type": "function", "code": "tf.keras.backend.prod(x,axis=None,keepdims=False)", "summary": "Multiplies the values in a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.prod", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to compute the product."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.print_tensor", "type": "function", "code": "tf.keras.backend.print_tensor(x,message='')", "summary": "Prints message and the tensor value when evaluated.", "description": "", "code-info": {"name": "tf.keras.backend.print_tensor", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor to print."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "''", "description": "Message to print jointly with the tensor."}]}},
{"id": "tf.keras.backend.pow", "type": "function", "code": "tf.keras.backend.pow(x,a)", "summary": "Element-wise exponentiation.", "description": "", "code-info": {"name": "tf.keras.backend.pow", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "a", "is_optional": false, "type": "int", "description": "Python integer."}]}},
{"id": "tf.keras.backend.pool3d", "type": "function", "code": "tf.keras.backend.pool3d(x,pool_size,strides=(1,1,1),padding='valid',data_format=None,pool_mode='max')", "summary": "3D Pooling.", "description": "", "code-info": {"name": "tf.keras.backend.pool3d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "tuple of 3 integers."}, {"name": "strides", "is_optional": false, "type": "int", "description": "tuple of 3 integers.\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\npool_mode: string, \"max\" or \"avg\"."}]}},
{"id": "tf.keras.backend.pool2d", "type": "function", "code": "tf.keras.backend.pool2d(x,pool_size,strides=(1,1),padding='valid',data_format=None,pool_mode='max')", "summary": "2D Pooling.", "description": "", "code-info": {"name": "tf.keras.backend.pool2d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "tuple of 2 integers."}, {"name": "strides", "is_optional": false, "type": "int", "description": "tuple of 2 integers.\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\npool_mode: string, \"max\" or \"avg\"."}]}},
{"id": "tf.keras.backend.placeholder", "type": "function", "code": "tf.keras.backend.placeholder(shape=None,ndim=None,dtype=None,sparse=False,name=None,ragged=False)", "summary": "Instantiates a placeholder tensor and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.placeholder", "parameters": [{"name": "shape", "is_optional": true, "type": "int", "default_value": "None", "description": "Shape of the placeholder\n(integer tuple, may include None entries)."}, {"name": "ndim", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Number of axes of the tensor.\nAt least one of {shape, ndim} must be specified.\nIf both are specified, shape is used."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Placeholder type."}, {"name": "sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether the placeholder should have a sparse type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name string for the placeholder."}, {"name": "ragged", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether the placeholder should have a ragged type.\nIn this case, values of 'None' in the 'shape' argument represent\nragged dimensions. For more information about RaggedTensors, see this\nguide."}]}},
{"id": "tf.keras.backend.ones_like", "type": "function", "code": "tf.keras.backend.ones_like(x,dtype=None,name=None)", "summary": "Instantiates an all-ones variable of the same shape as another tensor.", "description": "", "code-info": {"name": "tf.keras.backend.ones_like", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Keras variable or tensor."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "String, dtype of returned Keras variable.\n None uses the dtype of x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name for the variable to create."}]}},
{"id": "tf.keras.backend.permute_dimensions", "type": "function", "code": "tf.keras.backend.permute_dimensions(x,pattern)", "summary": "Permutes axes in a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.permute_dimensions", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "pattern", "is_optional": false, "type": "others", "description": "A tuple of\ndimension indices, e.g. (0, 2, 1)."}]}},
{"id": "tf.keras.backend.not_equal", "type": "function", "code": "tf.keras.backend.not_equal(x,y)", "summary": "Element-wise inequality between two tensors.", "description": "", "code-info": {"name": "tf.keras.backend.not_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.one_hot", "type": "function", "code": "tf.keras.backend.one_hot(indices,num_classes)", "summary": "Computes the one-hot representation of an integer tensor.", "description": "", "code-info": {"name": "tf.keras.backend.one_hot", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "nD integer tensor of shape\n(batch_size, dim1, dim2, ... dim(n-1))"}, {"name": "num_classes", "is_optional": false, "type": "int", "description": "Integer, number of classes to consider."}]}},
{"id": "tf.keras.backend.mean", "type": "function", "code": "tf.keras.backend.mean(x,axis=None,keepdims=False)", "summary": "Mean of a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.mean", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "A list of integer. Axes to compute the mean."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1 for each entry in axis. If keepdims is True,\nthe reduced dimensions are retained with length 1."}]}},
{"id": "tf.keras.backend.ndim", "type": "function", "code": "tf.keras.backend.ndim(x)", "summary": "Returns the number of axes in a tensor, as an integer.", "description": "", "code-info": {"name": "tf.keras.backend.ndim", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.moving_average_update", "type": "function", "code": "tf.keras.backend.moving_average_update(x,value,momentum)", "summary": "Compute the moving average of a variable.", "description": "", "code-info": {"name": "tf.keras.backend.moving_average_update", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "A tensor with the same shape as variable."}, {"name": "momentum", "is_optional": false, "type": "others", "description": "The moving average momentum."}]}},
{"id": "tf.keras.backend.ones", "type": "function", "code": "tf.keras.backend.ones(shape,dtype=None,name=None)", "summary": "Instantiates an all-ones variable and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.ones", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "Tuple of integers, shape of returned Keras variable."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "String, data type of returned Keras variable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name of returned Keras variable."}]}},
{"id": "tf.keras.backend.name_scope", "type": "function", "code": "tf.keras.backend.name_scope(name)", "summary": "A context manager for use when defining a Python op.", "description": "", "code-info": {"name": "tf.keras.backend.name_scope", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The prefix to use on all names created within the name scope."}]}},
{"id": "tf.keras.backend.min", "type": "function", "code": "tf.keras.backend.min(x,axis=None,keepdims=False)", "summary": "Minimum value in a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.min", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to find minimum values."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.normalize_batch_in_training", "type": "function", "code": "tf.keras.backend.normalize_batch_in_training(x,gamma,beta,reduction_axes,epsilon=0.001)", "summary": "Computes mean and std for batch then apply batch_normalization on batch.", "description": "", "code-info": {"name": "tf.keras.backend.normalize_batch_in_training", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor or variable."}, {"name": "gamma", "is_optional": false, "type": "tensor", "description": "Tensor by which to scale the input."}, {"name": "beta", "is_optional": false, "type": "tensor", "description": "Tensor with which to center the input."}, {"name": "reduction_axes", "is_optional": false, "type": "int", "description": "iterable of integers,\naxes over which to normalize."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "0.001", "description": "Fuzz factor."}]}},
{"id": "tf.keras.backend.minimum", "type": "function", "code": "tf.keras.backend.minimum(x,y)", "summary": "Element-wise minimum of two tensors.", "description": "", "code-info": {"name": "tf.keras.backend.minimum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.maximum", "type": "function", "code": "tf.keras.backend.maximum(x,y)", "summary": "Element-wise maximum of two tensors.", "description": "", "code-info": {"name": "tf.keras.backend.maximum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.max", "type": "function", "code": "tf.keras.backend.max(x,axis=None,keepdims=False)", "summary": "Maximum value in a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.max", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer, the axis to find maximum values."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether to keep the dimensions or not.\nIf keepdims is False, the rank of the tensor is reduced\nby 1. If keepdims is True,\nthe reduced dimension is retained with length 1."}]}},
{"id": "tf.keras.backend.map_fn", "type": "function", "code": "tf.keras.backend.map_fn(fn,elems,name=None,dtype=None)", "summary": "Map the function fn over the elements elems and return the outputs.", "description": "", "code-info": {"name": "tf.keras.backend.map_fn", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "Callable that will be called upon each element in elems"}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "tensor"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string name for the map node in the graph"}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Output data type."}]}},
{"id": "tf.keras.backend.manual_variable_initialization", "type": "function", "code": "tf.keras.backend.manual_variable_initialization(value)", "summary": "Sets the manual variable initialization flag.", "description": "", "code-info": {"name": "tf.keras.backend.manual_variable_initialization", "parameters": [{"name": "value", "is_optional": false, "type": "bool", "description": "Python boolean."}]}},
{"id": "tf.keras.backend.log", "type": "function", "code": "tf.keras.backend.log(x)", "summary": "Element-wise log.", "description": "", "code-info": {"name": "tf.keras.backend.log", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.local_conv2d", "type": "function", "code": "tf.keras.backend.local_conv2d(inputs,kernel,kernel_size,strides,output_shape,data_format=None)", "summary": "Apply 2D conv with un-shared weights.", "description": "", "code-info": {"name": "tf.keras.backend.local_conv2d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "4D tensor with shape:\n(batch_size, filters, new_rows, new_cols)\nif data_format='channels_first'\nor 4D tensor with shape:\n(batch_size, new_rows, new_cols, filters)\nif data_format='channels_last'."}, {"name": "kernel", "is_optional": false, "type": "others", "description": "the unshared weight for convolution,\nwith shape (output_items, feature_dim, filters)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "a tuple of 2 integers, specifying the\nwidth and height of the 2D convolution window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "a tuple of 2 integers, specifying the strides\nof the convolution along the width and height."}, {"name": "output_shape", "is_optional": false, "type": "others", "description": "a tuple with (output_row, output_col)."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "the data format, channels_first or channels_last."}]}},
{"id": "tf.keras.backend.local_conv1d", "type": "function", "code": "tf.keras.backend.local_conv1d(inputs,kernel,kernel_size,strides,data_format=None)", "summary": "Apply 1D conv with un-shared weights.", "description": "", "code-info": {"name": "tf.keras.backend.local_conv1d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "3D tensor with shape:\n(batch_size, steps, input_dim)\nif data_format is \"channels_last\" or\n(batch_size, input_dim, steps)\nif data_format is \"channels_first\"."}, {"name": "kernel", "is_optional": false, "type": "others", "description": "the unshared weight for convolution,\nwith shape (output_length, feature_dim, filters)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "a tuple of a single integer,\nspecifying the length of the 1D convolution window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "a tuple of a single integer,\nspecifying the stride length of the convolution."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "the data format, channels_first or channels_last."}]}},
{"id": "tf.keras.backend.less_equal", "type": "function", "code": "tf.keras.backend.less_equal(x,y)", "summary": "Element-wise truth value of (x &lt;= y).", "description": "", "code-info": {"name": "tf.keras.backend.less_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.in_train_phase", "type": "function", "code": "tf.keras.backend.in_train_phase(x,alt,training=None)", "summary": "Selects x in train phase, and alt otherwise.", "description": "", "code-info": {"name": "tf.keras.backend.in_train_phase", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "What to return in train phase\n(tensor or callable that returns a tensor)."}, {"name": "alt", "is_optional": false, "type": "tensor", "description": "What to return otherwise\n(tensor or callable that returns a tensor)."}, {"name": "training", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional scalar tensor\n(or Python boolean, or Python integer)\nspecifying the learning phase."}]}},
{"id": "tf.keras.backend.learning_phase", "type": "function", "code": "tf.keras.backend.learning_phase()", "summary": "Returns the learning phase flag.", "description": "", "code-info": {"name": "tf.keras.backend.learning_phase", "parameters": []}},
{"id": "tf.keras.backend.is_sparse", "type": "function", "code": "tf.keras.backend.is_sparse(tensor)", "summary": "Returns whether a tensor is a sparse tensor.", "description": "", "code-info": {"name": "tf.keras.backend.is_sparse", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A tensor instance."}]}},
{"id": "tf.keras.backend.less", "type": "function", "code": "tf.keras.backend.less(x,y)", "summary": "Element-wise truth value of (x &lt; y).", "description": "", "code-info": {"name": "tf.keras.backend.less", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.l2_normalize", "type": "function", "code": "tf.keras.backend.l2_normalize(x,axis=None)", "summary": "Normalizes a tensor wrt the L2 norm alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.l2_normalize", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "axis along which to perform normalization."}]}},
{"id": "tf.keras.backend.is_keras_tensor", "type": "function", "code": "tf.keras.backend.is_keras_tensor(x)", "summary": "Returns whether x is a Keras tensor.", "description": "", "code-info": {"name": "tf.keras.backend.is_keras_tensor", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A candidate tensor."}]}},
{"id": "tf.keras.backend.in_top_k", "type": "function", "code": "tf.keras.backend.in_top_k(predictions,targets,k)", "summary": "Returns whether the targets are in the top k predictions.", "description": "", "code-info": {"name": "tf.keras.backend.in_top_k", "parameters": [{"name": "predictions", "is_optional": false, "type": "tensor", "description": "A tensor of shape (batch_size, classes) and type float32."}, {"name": "targets", "is_optional": false, "type": "tensor", "description": "A 1D tensor of length batch_size and type int32 or int64."}, {"name": "k", "is_optional": false, "type": "others", "description": "An int, number of top elements to consider."}]}},
{"id": "tf.keras.backend.greater_equal", "type": "function", "code": "tf.keras.backend.greater_equal(x,y)", "summary": "Element-wise truth value of (x &gt;= y).", "description": "", "code-info": {"name": "tf.keras.backend.greater_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.hard_sigmoid", "type": "function", "code": "tf.keras.backend.hard_sigmoid(x)", "summary": "Segment-wise linear approximation of sigmoid.", "description": "", "code-info": {"name": "tf.keras.backend.hard_sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.int_shape", "type": "function", "code": "tf.keras.backend.int_shape(x)", "summary": "Returns the shape of tensor or variable as a tuple of int or None entries.", "description": "", "code-info": {"name": "tf.keras.backend.int_shape", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.greater", "type": "function", "code": "tf.keras.backend.greater(x,y)", "summary": "Element-wise truth value of (x &gt; y).", "description": "", "code-info": {"name": "tf.keras.backend.greater", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.image_data_format", "type": "function", "code": "tf.keras.backend.image_data_format()", "summary": "Returns the default image data format convention.", "description": "", "code-info": {"name": "tf.keras.backend.image_data_format", "parameters": []}},
{"id": "tf.keras.backend.gradients", "type": "function", "code": "tf.keras.backend.gradients(loss,variables)", "summary": "Returns the gradients of loss w.r.t. variables.", "description": "", "code-info": {"name": "tf.keras.backend.gradients", "parameters": [{"name": "loss", "is_optional": false, "type": "tensor", "description": "Scalar tensor to minimize."}, {"name": "variables", "is_optional": false, "type": "others", "description": "List of variables."}]}},
{"id": "tf.keras.backend.in_test_phase", "type": "function", "code": "tf.keras.backend.in_test_phase(x,alt,training=None)", "summary": "Selects x in test phase, and alt otherwise.", "description": "", "code-info": {"name": "tf.keras.backend.in_test_phase", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "What to return in test phase\n(tensor or callable that returns a tensor)."}, {"name": "alt", "is_optional": false, "type": "tensor", "description": "What to return otherwise\n(tensor or callable that returns a tensor)."}, {"name": "training", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional scalar tensor\n(or Python boolean, or Python integer)\nspecifying the learning phase."}]}},
{"id": "tf.keras.backend.get_value", "type": "function", "code": "tf.keras.backend.get_value(x)", "summary": "Returns the value of a variable.", "description": "", "code-info": {"name": "tf.keras.backend.get_value", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "input variable."}]}},
{"id": "tf.keras.backend.get_uid", "type": "function", "code": "tf.keras.backend.get_uid(prefix='')", "summary": "Associates a string prefix with an integer counter in a TensorFlow graph.", "description": "", "code-info": {"name": "tf.keras.backend.get_uid", "parameters": [{"name": "prefix", "is_optional": true, "type": "string", "default_value": "''", "description": "String prefix to index."}]}},
{"id": "tf.keras.backend.gather", "type": "function", "code": "tf.keras.backend.gather(reference,indices)", "summary": "Retrieves the elements of indices indices in the tensor reference.", "description": "", "code-info": {"name": "tf.keras.backend.gather", "parameters": [{"name": "reference", "is_optional": false, "type": "tensor", "description": "A tensor."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "An integer tensor of indices."}]}},
{"id": "tf.keras.backend.function", "type": "function", "code": "tf.keras.backend.function(inputs,outputs,updates=None,name=None,**kwargs)", "summary": "Instantiates a Keras function.", "description": "", "code-info": {"name": "tf.keras.backend.function", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "List of placeholder tensors."}, {"name": "outputs", "is_optional": false, "type": "tensor", "description": "List of output tensors."}, {"name": "updates", "is_optional": true, "type": "others", "default_value": "None", "description": "List of update ops."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name of function."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Passed to tf.Session.run."}]}},
{"id": "tf.keras.backend.foldr", "type": "function", "code": "tf.keras.backend.foldr(fn,elems,initializer=None,name=None)", "summary": "Reduce elems using fn to combine them from right to left.", "description": "", "code-info": {"name": "tf.keras.backend.foldr", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "Callable that will be called upon each element in elems and an\naccumulator, for instance lambda acc, x: acc + x"}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "tensor"}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "The first value used (elems[-1] in case of None)"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string name for the foldr node in the graph"}]}},
{"id": "tf.keras.backend.foldl", "type": "function", "code": "tf.keras.backend.foldl(fn,elems,initializer=None,name=None)", "summary": "Reduce elems using fn to combine them from left to right.", "description": "", "code-info": {"name": "tf.keras.backend.foldl", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "Callable that will be called upon each element in elems and an\naccumulator, for instance lambda acc, x: acc + x"}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "tensor"}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "The first value used (elems[0] in case of None)"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string name for the foldl node in the graph"}]}},
{"id": "tf.keras.backend.expand_dims", "type": "function", "code": "tf.keras.backend.expand_dims(x,axis=-1)", "summary": "Adds a 1-sized dimension at index \"axis\".", "description": "", "code-info": {"name": "tf.keras.backend.expand_dims", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Position where to add a new axis."}]}},
{"id": "tf.keras.backend.eval", "type": "function", "code": "tf.keras.backend.eval(x)", "summary": "Evaluates the value of a variable.", "description": "", "code-info": {"name": "tf.keras.backend.eval", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "A variable."}]}},
{"id": "tf.keras.backend.equal", "type": "function", "code": "tf.keras.backend.equal(x,y)", "summary": "Element-wise equality between two tensors.", "description": "", "code-info": {"name": "tf.keras.backend.equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.epsilon", "type": "function", "code": "tf.keras.backend.epsilon()", "summary": "Returns the value of the fuzz factor used in numeric expressions.", "description": "", "code-info": {"name": "tf.keras.backend.epsilon", "parameters": []}},
{"id": "tf.keras.backend.floatx", "type": "function", "code": "tf.keras.backend.floatx()", "summary": "Returns the default float type, as a string.", "description": "", "code-info": {"name": "tf.keras.backend.floatx", "parameters": []}},
{"id": "tf.keras.backend.flatten", "type": "function", "code": "tf.keras.backend.flatten(x)", "summary": "Flatten a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.flatten", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.exp", "type": "function", "code": "tf.keras.backend.exp(x)", "summary": "Element-wise exponential.", "description": "", "code-info": {"name": "tf.keras.backend.exp", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.eye", "type": "function", "code": "tf.keras.backend.eye(size,dtype=None,name=None)", "summary": "Instantiate an identity matrix and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.eye", "parameters": [{"name": "size", "is_optional": false, "type": "int", "description": "Integer, number of rows/columns."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "String, data type of returned Keras variable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, name of returned Keras variable."}]}},
{"id": "tf.keras.backend.elu", "type": "function", "code": "tf.keras.backend.elu(x,alpha=1.0)", "summary": "Exponential linear unit.", "description": "", "code-info": {"name": "tf.keras.backend.elu", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable to compute the activation function for."}, {"name": "alpha", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A scalar, slope of negative section."}]}},
{"id": "tf.keras.backend.cumprod", "type": "function", "code": "tf.keras.backend.cumprod(x,axis=0)", "summary": "Cumulative product of the values in a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.cumprod", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer, the axis to compute the product."}]}},
{"id": "tf.keras.backend.dtype", "type": "function", "code": "tf.keras.backend.dtype(x)", "summary": "Returns the dtype of a Keras tensor or variable, as a string.", "description": "", "code-info": {"name": "tf.keras.backend.dtype", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.dropout", "type": "function", "code": "tf.keras.backend.dropout(x,level,noise_shape=None,seed=None)", "summary": "Sets entries in x to zero at random, while scaling the entire tensor.", "description": "", "code-info": {"name": "tf.keras.backend.dropout", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "tensor"}, {"name": "level", "is_optional": false, "type": "tensor", "description": "fraction of the entries in the tensor\nthat will be set to 0."}, {"name": "noise_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "shape for randomly generated keep/drop flags,\nmust be broadcastable to the shape of x"}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "random seed to ensure determinism."}]}},
{"id": "tf.keras.backend.depthwise_conv2d", "type": "function", "code": "tf.keras.backend.depthwise_conv2d(x,depthwise_kernel,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1))", "summary": "2D convolution with separable filters.", "description": "", "code-info": {"name": "tf.keras.backend.depthwise_conv2d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "input tensor"}, {"name": "depthwise_kernel", "is_optional": false, "type": "others", "description": "convolution kernel for the depthwise convolution."}, {"name": "strides", "is_optional": false, "type": "string", "description": "strides tuple (length 2).\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\ndilation_rate: tuple of integers,\ndilation rates for the separable convolution."}]}},
{"id": "tf.keras.backend.cumsum", "type": "function", "code": "tf.keras.backend.cumsum(x,axis=0)", "summary": "Cumulative sum of the values in a tensor, alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.cumsum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer, the axis to compute the sum."}]}},
{"id": "tf.keras.backend.ctc_label_dense_to_sparse", "type": "function", "code": "tf.keras.backend.ctc_label_dense_to_sparse(labels,label_lengths)", "summary": "Converts CTC labels from dense to sparse.", "description": "", "code-info": {"name": "tf.keras.backend.ctc_label_dense_to_sparse", "parameters": [{"name": "labels", "is_optional": false, "type": "others", "description": "dense CTC labels."}, {"name": "label_lengths", "is_optional": false, "type": "others", "description": "length of the labels."}]}},
{"id": "tf.keras.backend.dot", "type": "function", "code": "tf.keras.backend.dot(x,y)", "summary": "Multiplies 2 tensors (and/or variables) and returns a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.dot", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.conv2d_transpose", "type": "function", "code": "tf.keras.backend.conv2d_transpose(x,kernel,output_shape,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1))", "summary": "2D deconvolution (i.e.", "description": "", "code-info": {"name": "tf.keras.backend.conv2d_transpose", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "kernel", "is_optional": false, "type": "tensor", "description": "kernel tensor."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "1D int tensor for the output shape."}, {"name": "strides", "is_optional": false, "type": "string", "description": "strides tuple.\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\ndilation_rate: Tuple of 2 integers."}]}},
{"id": "tf.keras.backend.cos", "type": "function", "code": "tf.keras.backend.cos(x)", "summary": "Computes cos of x element-wise.", "description": "", "code-info": {"name": "tf.keras.backend.cos", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.count_params", "type": "function", "code": "tf.keras.backend.count_params(x)", "summary": "Returns the static number of elements in a variable or tensor.", "description": "", "code-info": {"name": "tf.keras.backend.count_params", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Variable or tensor."}]}},
{"id": "tf.keras.backend.conv1d", "type": "function", "code": "tf.keras.backend.conv1d(x,kernel,strides=1,padding='valid',data_format=None,dilation_rate=1)", "summary": "1D convolution.", "description": "", "code-info": {"name": "tf.keras.backend.conv1d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "kernel", "is_optional": false, "type": "tensor", "description": "kernel tensor."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "stride integer."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "string, \"same\", \"causal\" or \"valid\"."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "string, one of \"channels_last\", \"channels_first\"."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "integer dilate rate."}]}},
{"id": "tf.keras.backend.conv3d", "type": "function", "code": "tf.keras.backend.conv3d(x,kernel,strides=(1,1,1),padding='valid',data_format=None,dilation_rate=(1,1,1))", "summary": "3D convolution.", "description": "", "code-info": {"name": "tf.keras.backend.conv3d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "kernel", "is_optional": false, "type": "tensor", "description": "kernel tensor."}, {"name": "strides", "is_optional": false, "type": "string", "description": "strides tuple.\npadding: string, \"same\" or \"valid\".\ndata_format: string, \"channels_last\" or \"channels_first\".\ndilation_rate: tuple of 3 integers."}]}},
{"id": "tf.keras.backend.constant", "type": "function", "code": "tf.keras.backend.constant(value,dtype=None,shape=None,name=None)", "summary": "Creates a constant tensor.", "description": "", "code-info": {"name": "tf.keras.backend.constant", "parameters": [{"name": "value", "is_optional": false, "type": "others", "description": "A constant value (or list)"}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The type of the elements of the resulting tensor."}, {"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional dimensions of resulting tensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the tensor."}]}},
{"id": "tf.keras.backend.conv2d", "type": "function", "code": "tf.keras.backend.conv2d(x,kernel,strides=(1,1),padding='valid',data_format=None,dilation_rate=(1,1))", "summary": "2D convolution.", "description": "", "code-info": {"name": "tf.keras.backend.conv2d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "kernel", "is_optional": false, "type": "tensor", "description": "kernel tensor."}, {"name": "strides", "is_optional": false, "type": "string", "description": "strides tuple.\npadding: string, \"same\" or \"valid\".\ndata_format: \"channels_last\" or \"channels_first\".\ndilation_rate: tuple of 2 integers."}]}},
{"id": "tf.keras.backend.ctc_decode", "type": "function", "code": "tf.keras.backend.ctc_decode(y_pred,input_length,greedy=True,beam_width=100,top_paths=1)", "summary": "Decodes the output of a softmax.", "description": "", "code-info": {"name": "tf.keras.backend.ctc_decode", "parameters": [{"name": "y_pred", "is_optional": false, "type": "tensor", "description": "tensor (samples, time_steps, num_categories)\ncontaining the prediction, or output of the softmax."}, {"name": "input_length", "is_optional": false, "type": "tensor", "description": "tensor (samples, ) containing the sequence length for\neach batch item in y_pred."}, {"name": "greedy", "is_optional": true, "type": "bool", "default_value": "True", "description": "perform much faster best-path search if true.\nThis does not use a dictionary."}, {"name": "beam_width", "is_optional": true, "type": "int", "default_value": "100", "description": "if greedy is false: a beam search decoder will be used\nwith a beam of this width."}, {"name": "top_paths", "is_optional": true, "type": "int", "default_value": "1", "description": "if greedy is false,\nhow many of the most probable paths will be returned."}]}},
{"id": "tf.keras.backend.ctc_batch_cost", "type": "function", "code": "tf.keras.backend.ctc_batch_cost(y_true,y_pred,input_length,label_length)", "summary": "Runs CTC loss algorithm on each batch element.", "description": "", "code-info": {"name": "tf.keras.backend.ctc_batch_cost", "parameters": [{"name": "y_true", "is_optional": false, "type": "tensor", "description": "tensor (samples, max_string_length)\ncontaining the truth labels."}, {"name": "y_pred", "is_optional": false, "type": "tensor", "description": "tensor (samples, time_steps, num_categories)\ncontaining the prediction, or output of the softmax."}, {"name": "input_length", "is_optional": false, "type": "tensor", "description": "tensor (samples, 1) containing the sequence length for\neach batch item in y_pred."}, {"name": "label_length", "is_optional": false, "type": "tensor", "description": "tensor (samples, 1) containing the sequence length for\neach batch item in y_true."}]}},
{"id": "tf.keras.backend.clip", "type": "function", "code": "tf.keras.backend.clip(x,min_value,max_value)", "summary": "Element-wise value clipping.", "description": "", "code-info": {"name": "tf.keras.backend.clip", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "min_value", "is_optional": false, "type": "tensor", "description": "Python float, integer, or tensor."}, {"name": "max_value", "is_optional": false, "type": "tensor", "description": "Python float, integer, or tensor."}]}},
{"id": "tf.keras.backend.concatenate", "type": "function", "code": "tf.keras.backend.concatenate(tensors,axis=-1)", "summary": "Concatenates a list of tensors alongside the specified axis.", "description": "", "code-info": {"name": "tf.keras.backend.concatenate", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "list of tensors to concatenate."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "concatenation axis."}]}},
{"id": "tf.keras.backend.clear_session", "type": "function", "code": "tf.keras.backend.clear_session()", "summary": "Destroys the current TF graph and creates a new one.", "description": "", "code-info": {"name": "tf.keras.backend.clear_session", "parameters": []}},
{"id": "tf.keras.backend.cast", "type": "function", "code": "tf.keras.backend.cast(x,dtype)", "summary": "Casts a tensor to a different dtype and returns it.", "description": "", "code-info": {"name": "tf.keras.backend.cast", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Keras tensor (or variable)."}, {"name": "dtype", "is_optional": false, "type": "float", "description": "String, either ('float16', 'float32', or 'float64')."}]}},
{"id": "tf.keras.backend.bias_add", "type": "function", "code": "tf.keras.backend.bias_add(x,bias,data_format=None)", "summary": "Adds a bias vector to a tensor.", "description": "", "code-info": {"name": "tf.keras.backend.bias_add", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "bias", "is_optional": false, "type": "tensor", "description": "Bias tensor to add."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "string, \"channels_last\" or \"channels_first\"."}]}},
{"id": "tf.keras.backend.categorical_crossentropy", "type": "function", "code": "tf.keras.backend.categorical_crossentropy(target,output,from_logits=False,axis=-1)", "summary": "Categorical crossentropy between an output tensor and a target tensor.", "description": "", "code-info": {"name": "tf.keras.backend.categorical_crossentropy", "parameters": [{"name": "target", "is_optional": false, "type": "tensor", "description": "A tensor of the same shape as output."}, {"name": "output", "is_optional": false, "type": "tensor", "description": "A tensor resulting from a softmax\n(unless from_logits is True, in which\ncase output is expected to be the logits)."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean, whether output is the\nresult of a softmax, or is a tensor of logits."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "Int specifying the channels axis. axis=-1 corresponds to data\nformat channels_last', andaxis=1corresponds to data formatchannels_first`."}]}},
{"id": "tf.keras.backend.cast_to_floatx", "type": "function", "code": "tf.keras.backend.cast_to_floatx(x)", "summary": "Cast a Numpy array to the default Keras float type.", "description": "", "code-info": {"name": "tf.keras.backend.cast_to_floatx", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Numpy array or TensorFlow tensor."}]}},
{"id": "tf.keras.backend.binary_crossentropy", "type": "function", "code": "tf.keras.backend.binary_crossentropy(target,output,from_logits=False)", "summary": "Binary crossentropy between an output tensor and a target tensor.", "description": "", "code-info": {"name": "tf.keras.backend.binary_crossentropy", "parameters": [{"name": "target", "is_optional": false, "type": "tensor", "description": "A tensor with the same shape as output."}, {"name": "output", "is_optional": false, "type": "tensor", "description": "A tensor."}, {"name": "from_logits", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether output is expected to be a logits tensor.\nBy default, we consider that output\nencodes a probability distribution."}]}},
{"id": "tf.keras.backend.batch_dot", "type": "function", "code": "tf.keras.backend.batch_dot(x,y,axes=None)", "summary": "Batchwise dot product.", "description": "", "code-info": {"name": "tf.keras.backend.batch_dot", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Keras tensor or variable with ndim &gt;= 2."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Keras tensor or variable with ndim &gt;= 2."}, {"name": "axes", "is_optional": true, "type": "int", "default_value": "None", "description": "Tuple or list of integers with target dimensions, or single integer.\nThe sizes of x.shape[axes[0]] and y.shape[axes[1]] should be equal."}]}},
{"id": "tf.keras.backend.batch_set_value", "type": "function", "code": "tf.keras.backend.batch_set_value(tuples)", "summary": "Sets the values of many tensor variables at once.", "description": "", "code-info": {"name": "tf.keras.backend.batch_set_value", "parameters": [{"name": "tuples", "is_optional": false, "type": "tensor", "description": "a list of tuples (tensor, value).\nvalue should be a Numpy array."}]}},
{"id": "tf.keras.backend.batch_normalization", "type": "function", "code": "tf.keras.backend.batch_normalization(x,mean,var,beta,gamma,axis=-1,epsilon=0.001)", "summary": "Applies batch normalization on x given mean, var, beta and gamma.", "description": "", "code-info": {"name": "tf.keras.backend.batch_normalization", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor or variable."}, {"name": "mean", "is_optional": false, "type": "others", "description": "Mean of batch."}, {"name": "var", "is_optional": false, "type": "others", "description": "Variance of batch."}, {"name": "beta", "is_optional": false, "type": "tensor", "description": "Tensor with which to center the input."}, {"name": "gamma", "is_optional": false, "type": "tensor", "description": "Tensor by which to scale the input."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "-1", "description": "Integer, the axis that should be normalized.\n(typically the features axis)."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "0.001", "description": "Fuzz factor."}]}},
{"id": "tf.keras.backend.batch_get_value", "type": "function", "code": "tf.keras.backend.batch_get_value(tensors)", "summary": "Returns the value of more than one tensor variable.", "description": "", "code-info": {"name": "tf.keras.backend.batch_get_value", "parameters": [{"name": "tensors", "is_optional": false, "type": "others", "description": "list of ops to run."}]}},
{"id": "tf.keras.backend.backend", "type": "function", "code": "tf.keras.backend.backend()", "summary": "Publicly accessible method for determining the current backend.", "description": "", "code-info": {"name": "tf.keras.backend.backend", "parameters": []}},
{"id": "tf.keras.backend.batch_flatten", "type": "function", "code": "tf.keras.backend.batch_flatten(x)", "summary": "Turn a nD tensor into a 2D tensor with same 0th dimension.", "description": "", "code-info": {"name": "tf.keras.backend.batch_flatten", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable."}]}},
{"id": "tf.keras.backend.abs", "type": "function", "code": "tf.keras.backend.abs(x)", "summary": "Element-wise absolute value.", "description": "", "code-info": {"name": "tf.keras.backend.abs", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}]}},
{"id": "tf.keras.backend.arange", "type": "function", "code": "tf.keras.backend.arange(start,stop=None,step=1,dtype='int32')", "summary": "Creates a 1D tensor containing a sequence of integers.", "description": "", "code-info": {"name": "tf.keras.backend.arange", "parameters": [{"name": "start", "is_optional": false, "type": "others", "description": "Start value."}, {"name": "stop", "is_optional": true, "type": "others", "default_value": "None", "description": "Stop value."}, {"name": "step", "is_optional": true, "type": "int", "default_value": "1", "description": "Difference between two successive values."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "'int32'", "description": "Integer dtype to use."}]}},
{"id": "tf.keras.backend.argmax", "type": "function", "code": "tf.keras.backend.argmax(x,axis=-1)", "summary": "Returns the index of the maximum value along an axis.", "description": "", "code-info": {"name": "tf.keras.backend.argmax", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "axis along which to perform the reduction."}]}},
{"id": "tf.keras.backend.any", "type": "function", "code": "tf.keras.backend.any(x,axis=None,keepdims=False)", "summary": "Bitwise reduction (logical OR).", "description": "", "code-info": {"name": "tf.keras.backend.any", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "axis along which to perform the reduction."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether the drop or broadcast the reduction axes."}]}},
{"id": "tf.keras.backend.all", "type": "function", "code": "tf.keras.backend.all(x,axis=None,keepdims=False)", "summary": "Bitwise reduction (logical AND).", "description": "", "code-info": {"name": "tf.keras.backend.all", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "axis along which to perform the reduction."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether the drop or broadcast the reduction axes."}]}},
{"id": "tf.keras.applications.xception.decode_predictions", "type": "function", "code": "tf.keras.applications.xception.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.xception.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.xception.preprocess_input", "type": "function", "code": "tf.keras.applications.xception.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.xception.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.vgg19.preprocess_input", "type": "function", "code": "tf.keras.applications.vgg19.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.vgg19.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.vgg19.decode_predictions", "type": "function", "code": "tf.keras.applications.vgg19.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.vgg19.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.backend.argmin", "type": "function", "code": "tf.keras.backend.argmin(x,axis=-1)", "summary": "Returns the index of the minimum value along an axis.", "description": "", "code-info": {"name": "tf.keras.backend.argmin", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor or variable."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "axis along which to perform the reduction."}]}},
{"id": "tf.keras.applications.vgg16.decode_predictions", "type": "function", "code": "tf.keras.applications.vgg16.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.vgg16.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.vgg16.preprocess_input", "type": "function", "code": "tf.keras.applications.vgg16.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.vgg16.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.resnet_v2.preprocess_input", "type": "function", "code": "tf.keras.applications.resnet_v2.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.resnet_v2.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.resnet_v2.decode_predictions", "type": "function", "code": "tf.keras.applications.resnet_v2.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.resnet_v2.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.resnet.decode_predictions", "type": "function", "code": "tf.keras.applications.resnet.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.resnet.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.resnet.preprocess_input", "type": "function", "code": "tf.keras.applications.resnet.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.resnet.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.nasnet.preprocess_input", "type": "function", "code": "tf.keras.applications.nasnet.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.nasnet.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.mobilenet_v2.preprocess_input", "type": "function", "code": "tf.keras.applications.mobilenet_v2.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.mobilenet_v2.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.nasnet.decode_predictions", "type": "function", "code": "tf.keras.applications.nasnet.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.nasnet.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.inception_resnet_v2.preprocess_input", "type": "function", "code": "tf.keras.applications.inception_resnet_v2.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.inception_resnet_v2.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.mobilenet_v2.decode_predictions", "type": "function", "code": "tf.keras.applications.mobilenet_v2.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.mobilenet_v2.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.inception_v3.preprocess_input", "type": "function", "code": "tf.keras.applications.inception_v3.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.inception_v3.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.mobilenet.preprocess_input", "type": "function", "code": "tf.keras.applications.mobilenet.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.mobilenet.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.mobilenet.decode_predictions", "type": "function", "code": "tf.keras.applications.mobilenet.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.mobilenet.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.inception_v3.decode_predictions", "type": "function", "code": "tf.keras.applications.inception_v3.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.inception_v3.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.densenet.decode_predictions", "type": "function", "code": "tf.keras.applications.densenet.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.densenet.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.inception_resnet_v2.decode_predictions", "type": "function", "code": "tf.keras.applications.inception_resnet_v2.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.inception_resnet_v2.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.imagenet_utils.preprocess_input", "type": "function", "code": "tf.keras.applications.imagenet_utils.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.imagenet_utils.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.imagenet_utils.decode_predictions", "type": "function", "code": "tf.keras.applications.imagenet_utils.decode_predictions(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.imagenet_utils.decode_predictions", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.densenet.preprocess_input", "type": "function", "code": "tf.keras.applications.densenet.preprocess_input(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.densenet.preprocess_input", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.VGG16", "type": "function", "code": "tf.keras.applications.VGG16(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.VGG16", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.VGG19", "type": "function", "code": "tf.keras.applications.VGG19(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.VGG19", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet152V2", "type": "function", "code": "tf.keras.applications.ResNet152V2(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet152V2", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet101V2", "type": "function", "code": "tf.keras.applications.ResNet101V2(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet101V2", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.Xception", "type": "function", "code": "tf.keras.applications.Xception(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.Xception", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet50V2", "type": "function", "code": "tf.keras.applications.ResNet50V2(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet50V2", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet152", "type": "function", "code": "tf.keras.applications.ResNet152(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet152", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.NASNetMobile", "type": "function", "code": "tf.keras.applications.NASNetMobile(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.NASNetMobile", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet101", "type": "function", "code": "tf.keras.applications.ResNet101(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet101", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.ResNet50", "type": "function", "code": "tf.keras.applications.ResNet50(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.ResNet50", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.NASNetLarge", "type": "function", "code": "tf.keras.applications.NASNetLarge(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.NASNetLarge", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.InceptionResNetV2", "type": "function", "code": "tf.keras.applications.InceptionResNetV2(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.InceptionResNetV2", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.MobileNetV2", "type": "function", "code": "tf.keras.applications.MobileNetV2(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.MobileNetV2", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.MobileNet", "type": "function", "code": "tf.keras.applications.MobileNet(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.MobileNet", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.InceptionV3", "type": "function", "code": "tf.keras.applications.InceptionV3(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.InceptionV3", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.activations.softsign", "type": "function", "code": "tf.keras.activations.softsign(x)", "summary": "Softsign activation function.", "description": "", "code-info": {"name": "tf.keras.activations.softsign", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.activations.softplus", "type": "function", "code": "tf.keras.activations.softplus(x)", "summary": "Softplus activation function.", "description": "", "code-info": {"name": "tf.keras.activations.softplus", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.applications.DenseNet201", "type": "function", "code": "tf.keras.applications.DenseNet201(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.DenseNet201", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.applications.DenseNet169", "type": "function", "code": "tf.keras.applications.DenseNet169(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.DenseNet169", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.activations.softmax", "type": "function", "code": "tf.keras.activations.softmax(x,axis=-1)", "summary": "Softmax converts a real vector to a vector of categorical probabilities.", "description": "", "code-info": {"name": "tf.keras.activations.softmax", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "-1", "description": "Integer, axis along which the softmax normalization is applied."}]}},
{"id": "tf.keras.applications.DenseNet121", "type": "function", "code": "tf.keras.applications.DenseNet121(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.keras.applications.DenseNet121", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.keras.activations.tanh", "type": "function", "code": "tf.keras.activations.tanh(x)", "summary": "Hyperbolic tangent activation function.", "description": "", "code-info": {"name": "tf.keras.activations.tanh", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.activations.selu", "type": "function", "code": "tf.keras.activations.selu(x)", "summary": "Scaled Exponential Linear Unit (SELU).", "description": "", "code-info": {"name": "tf.keras.activations.selu", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor or variable to compute the activation function for."}]}},
{"id": "tf.keras.activations.hard_sigmoid", "type": "function", "code": "tf.keras.activations.hard_sigmoid(x)", "summary": "Hard sigmoid activation function.", "description": "", "code-info": {"name": "tf.keras.activations.hard_sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.activations.linear", "type": "function", "code": "tf.keras.activations.linear(x)", "summary": "Linear activation function.", "description": "", "code-info": {"name": "tf.keras.activations.linear", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.activations.get", "type": "function", "code": "tf.keras.activations.get(identifier)", "summary": "Returns function.", "description": "", "code-info": {"name": "tf.keras.activations.get", "parameters": [{"name": "identifier", "is_optional": false, "type": "string", "description": "Function or string"}]}},
{"id": "tf.keras.activations.serialize", "type": "function", "code": "tf.keras.activations.serialize(activation)", "summary": "Returns name attribute (__name__) of function.", "description": "", "code-info": {"name": "tf.keras.activations.serialize", "parameters": [{"name": "activation", "is_optional": false, "type": "others", "description": "Function"}]}},
{"id": "tf.keras.activations.elu", "type": "function", "code": "tf.keras.activations.elu(x,alpha=1.0)", "summary": "Exponential linear unit.", "description": "", "code-info": {"name": "tf.keras.activations.elu", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "alpha", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A scalar, slope of negative section."}]}},
{"id": "tf.keras.activations.relu", "type": "function", "code": "tf.keras.activations.relu(x,alpha=0.0,max_value=None,threshold=0)", "summary": "Applies the rectified linear unit activation function.", "description": "", "code-info": {"name": "tf.keras.activations.relu", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor or variable."}, {"name": "alpha", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float that governs the slope for values lower than the\nthreshold."}, {"name": "max_value", "is_optional": true, "type": "float", "default_value": "None", "description": "A float that sets the saturation threshold (the largest value\nthe function will return)."}, {"name": "threshold", "is_optional": true, "type": "int", "default_value": "0", "description": "A float giving the threshold value of the activation function\nbelow which values will be damped or set to zero."}]}},
{"id": "tf.keras.activations.deserialize", "type": "function", "code": "tf.keras.activations.deserialize(name,custom_objects=None)", "summary": "Returns activation function denoted by input string.", "description": "", "code-info": {"name": "tf.keras.activations.deserialize", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The name of the actiuvation function."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "A {name:value} dictionary for activations not build into\nkeras."}]}},
{"id": "tf.keras.activations.sigmoid", "type": "function", "code": "tf.keras.activations.sigmoid(x)", "summary": "Sigmoid activation function.", "description": "", "code-info": {"name": "tf.keras.activations.sigmoid", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.keras.activations.exponential", "type": "function", "code": "tf.keras.activations.exponential(x)", "summary": "Exponential activation function.", "description": "", "code-info": {"name": "tf.keras.activations.exponential", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input tensor."}]}},
{"id": "tf.io.gfile.walk", "type": "function", "code": "tf.io.gfile.walk(top,topdown=True,onerror=None)", "summary": "Recursive directory tree generator for directories.", "description": "", "code-info": {"name": "tf.io.gfile.walk", "parameters": [{"name": "top", "is_optional": false, "type": "string", "description": "string, a Directory name"}, {"name": "topdown", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, Traverse pre order if True, post order if False."}, {"name": "onerror", "is_optional": true, "type": "others", "default_value": "None", "description": "optional handler for errors. Should be a function, it will be\ncalled with the error as argument. Rethrowing the error aborts the walk.\nErrors that happen while listing directories are ignored."}]}},
{"id": "tf.keras.Input", "type": "function", "code": "tf.keras.Input(shape=None,batch_size=None,name=None,dtype=None,sparse=False,tensor=None,ragged=False,**kwargs)", "summary": "Input() is used to instantiate a Keras tensor.", "description": "", "code-info": {"name": "tf.keras.Input", "parameters": [{"name": "shape", "is_optional": true, "type": "int", "default_value": "None", "description": "A shape tuple (integers), not including the batch size.\nFor instance, shape=(32,) indicates that the expected input\nwill be batches of 32-dimensional vectors. Elements of this tuple\ncan be None; 'None' elements represent dimensions where the shape is\nnot known."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "None", "description": "optional static batch size (integer)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional name string for the layer.\nShould be unique in a model (do not reuse the same name twice).\nIt will be autogenerated if it isn't provided."}, {"name": "dtype", "is_optional": true, "type": "string", "default_value": "None", "description": "The data type expected by the input, as a string\n(float32, float64, int32...)"}, {"name": "sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean specifying whether the placeholder to be created is\nsparse. Only one of 'ragged' and 'sparse' can be True."}, {"name": "tensor", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional existing tensor to wrap into the Input layer.\nIf set, the layer will not create a placeholder tensor."}, {"name": "ragged", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean specifying whether the placeholder to be created is\nragged. Only one of 'ragged' and 'sparse' can be True. In this case,\nvalues of 'None' in the 'shape' argument represent ragged dimensions.\nFor more information about RaggedTensors, see\nhttps://www.tensorflow.org/guide/ragged_tensors."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "deprecated arguments support. Supports batch_shape and\nbatch_input_shape."}]}},
{"id": "tf.keras.Sequential", "type": "function", "code": "tf.keras.Sequential(layers=None,name=None)", "summary": "Linear stack of layers.\n\nInherits From: Model", "description": "", "code-info": {"name": "tf.keras.Sequential", "parameters": [{"name": "layers", "is_optional": true, "type": "others", "default_value": "None", "description": "list of layers to add to the model.\n\n\nExample:\n# Optionally, the first layer can receive an `input_shape` argument:\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(500,)))\n# Afterwards, we do automatic shape inference:\nmodel.add(Dense(32))\n\n# This is identical to the following:\nmodel = Sequential()\nmodel.add(Dense(32, input_dim=500))\n\n# And to the following:\nmodel = Sequential()\nmodel.add(Dense(32, batch_input_shape=(None, 500)))\n\n# Note that you can also omit the `input_shape` argument:\n# In that case the model gets built the first time you call `fit` (or other\n# training and evaluation methods).\nmodel = Sequential()\nmodel.add(Dense(32))\nmodel.add(Dense(32))\nmodel.compile(optimizer=optimizer, loss=loss)\n# This builds the model for the first time:\nmodel.fit(x, y, batch_size=32, epochs=10)\n\n# Note that when using this delayed-build pattern (no input shape specified),\n# the model doesn't have any weights until the first call\n# to a training/evaluation method (since it isn't yet built):\nmodel = Sequential()\nmodel.add(Dense(32))\nmodel.add(Dense(32))\nmodel.weights  # returns []\n\n# Whereas if you specify the input shape, the model gets built continuously\n# as you are adding layers:\nmodel = Sequential()\nmodel.add(Dense(32, input_shape=(500,)))\nmodel.add(Dense(32))\nmodel.weights  # returns list of length 4\n\n# When using the delayed-build pattern (no input shape specified), you can\n# choose to manually build your model by calling `build(batch_input_shape)`:\nmodel = Sequential()\nmodel.add(Dense(32))\nmodel.add(Dense(32))\nmodel.build((None, 500))\nmodel.weights  # returns list of length 4\n\nAttributes:\n\n\nlayers\nmetrics_names:   Returns the model's display labels for all outputs.\nrun_eagerly:   Settable attribute indicating whether the model should run eagerly.\n\nRunning eagerly means that your model will be run step by step,\nlike Python code. Your model might run slower, but it should become easier\nfor you to debug it by stepping into individual layer calls.\n\nBy default, we will attempt to compile your model to a static graph to\ndeliver the best execution performance.\nsample_weights\nstate_updates:   Returns the updates from all layers that are stateful.\n\nThis is useful for separating training updates and\nstate updates, e.g. when we need to update a layer's internal state\nduring prediction.\n\n\nMethods\n\nadd\n\nView source\nadd(\n    layer\n)\n\nAdds a layer instance on top of the layer stack.\n\nArguments:\n\n\nlayer: layer instance.\n\n\nRaises:\n\n\nTypeError: If layer is not a layer instance.\nValueError: In case the layer argument does not\nknow its input shape.\nValueError: In case the layer argument has\nmultiple output tensors, or is already connected\nsomewhere else (forbidden in Sequential models).\n\n\ncompile\n\nView source\ncompile(\n    optimizer='rmsprop', loss=None, metrics=None, loss_weights=None,\n    sample_weight_mode=None, weighted_metrics=None, target_tensors=None,\n    distribute=None, **kwargs\n)\n\nConfigures the model for training.\n\nArguments:\n\n\noptimizer: String (name of optimizer) or optimizer instance.\nSee tf.keras.optimizers.\nloss: String (name of objective function), objective function or\ntf.keras.losses.Loss instance. See tf.keras.losses. An objective\nfunction is any callable with the signature\nscalar_loss = fn(y_true, y_pred). If the model has multiple\noutputs, you can use a different loss on each output by passing a\ndictionary or a list of losses. The loss value that will be\nminimized by the model will then be the sum of all individual\nlosses.\nmetrics: List of metrics to be evaluated by the model during training\nand testing. Typically you will use metrics=['accuracy'].\nTo specify different metrics for different outputs of a\nmulti-output model, you could also pass a dictionary, such as\nmetrics={'output_a': 'accuracy', 'output_b': ['accuracy', 'mse']}.\nYou can also pass a list (len = len(outputs)) of lists of metrics\nsuch as metrics=[['accuracy'], ['accuracy', 'mse']] or\nmetrics=['accuracy', ['accuracy', 'mse']].\nloss_weights: Optional list or dictionary specifying scalar\ncoefficients (Python floats) to weight the loss contributions\nof different model outputs.\nThe loss value that will be minimized by the model\nwill then be the weighted sum of all individual losses,\nweighted by the loss_weights coefficients.\nIf a list, it is expected to have a 1:1 mapping\nto the model's outputs. If a tensor, it is expected to map\noutput names (strings) to scalar coefficients.\nsample_weight_mode: If you need to do timestep-wise\nsample weighting (2D weights), set this to \"temporal\".\nNone defaults to sample-wise weights (1D).\nIf the model has multiple outputs, you can use a different\nsample_weight_mode on each output by passing a\ndictionary or a list of modes.\nweighted_metrics: List of metrics to be evaluated and weighted\nby sample_weight or class_weight during training and testing.\ntarget_tensors: By default, Keras will create placeholders for the\nmodel's target, which will be fed with the target data during\ntraining. If instead you would like to use your own\ntarget tensors (in turn, Keras will not expect external\nNumpy data for these targets at training time), you\ncan specify them via the target_tensors argument. It can be\na single tensor (for a single-output model), a list of tensors,\nor a dict mapping output names to target tensors.\ndistribute: NOT SUPPORTED IN TF 2.0, please create and compile the\nmodel under distribution strategy scope instead of passing it to\ncompile.\n**kwargs: Any additional arguments.\n\n\nRaises:\n\n\nValueError: In case of invalid arguments for\noptimizer, loss, metrics or sample_weight_mode.\n\n\nevaluate\n\nView source\nevaluate(\n    x=None, y=None, batch_size=None, verbose=1, sample_weight=None, steps=None,\n    callbacks=None, max_queue_size=10, workers=1, use_multiprocessing=False\n)\n\nReturns the loss value &amp; metrics values for the model in test mode.\n\nComputation is done in batches.\n\nArguments:\n\n\nx: Input data. It could be:\n\nA Numpy array (or array-like), or a list of arrays\n(in case the model has multiple inputs).\nA TensorFlow tensor, or a list of tensors\n(in case the model has multiple inputs).\nA dict mapping input names to the corresponding array/tensors,\nif the model has named inputs.\nA tf.data dataset.\nA generator or keras.utils.Sequence instance.\nA more detailed description of unpacking behavior for iterator types\n(Dataset, generator, Sequence) is given in the Unpacking behavior\nfor iterator-like inputs section of Model.fit.\n\ny: Target data. Like the input data x,\nit could be either Numpy array(s) or TensorFlow tensor(s).\nIt should be consistent with x (you cannot have Numpy inputs and\ntensor targets, or inversely).\nIf x is a dataset, generator or\nkeras.utils.Sequence instance, y should not be specified (since\ntargets will be obtained from the iterator/dataset).\nbatch_size: Integer or None.\nNumber of samples per gradient update.\nIf unspecified, batch_size will default to 32.\nDo not specify the batch_size if your data is in the\nform of symbolic tensors, dataset,\ngenerators, or keras.utils.Sequence instances (since they generate\nbatches).\nverbose: 0 or 1. Verbosity mode.\n0 = silent, 1 = progress bar.\nsample_weight: Optional Numpy array of weights for\nthe test samples, used for weighting the loss function.\nYou can either pass a flat (1D)\nNumpy array with the same length as the input samples\n(1:1 mapping between weights and samples),\nor in the case of temporal data,\nyou can pass a 2D array with shape\n(samples, sequence_length),\nto apply a different weight to every timestep of every sample.\nIn this case you should make sure to specify\nsample_weight_mode=\"temporal\" in compile(). This argument is not\nsupported when x is a dataset, instead pass\nsample weights as the third element of x.\nsteps: Integer or None.\nTotal number of steps (batches of samples)\nbefore declaring the evaluation round finished.\nIgnored with the default value of None.\nIf x is a tf.data dataset and steps is\nNone, 'evaluate' will run until the dataset is exhausted.\nThis argument is not supported with array inputs.\ncallbacks: List of keras.callbacks.Callback instances.\nList of callbacks to apply during evaluation.\nSee callbacks.\nmax_queue_size: Integer. Used for generator or keras.utils.Sequence\ninput only. Maximum size for the generator queue.\nIf unspecified, max_queue_size will default to 10.\nworkers: Integer. Used for generator or keras.utils.Sequence input\nonly. Maximum number of processes to spin up when using\nprocess-based threading. If unspecified, workers will default\nto 1. If 0, will execute the generator on the main thread.\nuse_multiprocessing: Boolean. Used for generator or\nkeras.utils.Sequence input only. If True, use process-based\nthreading. If unspecified, use_multiprocessing will default to\nFalse. Note that because this implementation relies on\nmultiprocessing, you should not pass non-picklable arguments to\nthe generator as they can't be passed easily to children processes.\n\n\nSee the discussion of Unpacking behavior for iterator-like inputs for\nModel.fit.\n\nReturns:\n\nScalar test loss (if the model has a single output and no metrics)\nor list of scalars (if the model has multiple outputs\nand/or metrics). The attribute model.metrics_names will give you\nthe display labels for the scalar outputs.\n\nRaises:\n\n\nValueError: in case of invalid arguments.\n\n\nevaluate_generator\n\nView source\nevaluate_generator(\n    generator, steps=None, callbacks=None, max_queue_size=10, workers=1,\n    use_multiprocessing=False, verbose=0\n)\n\nEvaluates the model on a data generator. (deprecated)\nWarning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.\nInstructions for updating:\nPlease use Model.evaluate, which supports generators.\nDEPRECATED:\n\nModel.evaluate now supports generators, so there is no longer any need\nto use this endpoint.\n\nfit\n\nView source\nfit(\n    x=None, y=None, batch_size=None, epochs=1, verbose=1, callbacks=None,\n    validation_split=0.0, validation_data=None, shuffle=True, class_weight=None,\n    sample_weight=None, initial_epoch=0, steps_per_epoch=None,\n    validation_steps=None, validation_freq=1, max_queue_size=10, workers=1,\n    use_multiprocessing=False, **kwargs\n)\n\nTrains the model for a fixed number of epochs (iterations on a dataset).\n\nArguments:\n\n\nx: Input data. It could be:\n\nA Numpy array (or array-like), or a list of arrays\n(in case the model has multiple inputs).\nA TensorFlow tensor, or a list of tensors\n(in case the model has multiple inputs).\nA dict mapping input names to the corresponding array/tensors,\nif the model has named inputs.\nA tf.data dataset. Should return a tuple\nof either (inputs, targets) or\n(inputs, targets, sample_weights).\nA generator or keras.utils.Sequence returning (inputs, targets)\nor (inputs, targets, sample weights).\nA more detailed description of unpacking behavior for iterator types\n(Dataset, generator, Sequence) is given below.\n\ny: Target data. Like the input data x,\nit could be either Numpy array(s) or TensorFlow tensor(s).\nIt should be consistent with x (you cannot have Numpy inputs and\ntensor targets, or inversely). If x is a dataset, generator,\nor keras.utils.Sequence instance, y should\nnot be specified (since targets will be obtained from x).\nbatch_size: Integer or None.\nNumber of samples per gradient update.\nIf unspecified, batch_size will default to 32.\nDo not specify the batch_size if your data is in the\nform of symbolic tensors, datasets,\ngenerators, or keras.utils.Sequence instances (since they generate\nbatches).\nepochs: Integer. Number of epochs to train the model.\nAn epoch is an iteration over the entire x and y\ndata provided.\nNote that in conjunction with initial_epoch,\nepochs is to be understood as \"final epoch\".\nThe model is not trained for a number of iterations\ngiven by epochs, but merely until the epoch\nof index epochs is reached.\nverbose: 0, 1, or 2. Verbosity mode.\n0 = silent, 1 = progress bar, 2 = one line per epoch.\nNote that the progress bar is not particularly useful when\nlogged to a file, so verbose=2 is recommended when not running\ninteractively (eg, in a production environment).\ncallbacks: List of keras.callbacks.Callback instances.\nList of callbacks to apply during training.\nSee tf.keras.callbacks.\nvalidation_split: Float between 0 and 1.\nFraction of the training data to be used as validation data.\nThe model will set apart this fraction of the training data,\nwill not train on it, and will evaluate\nthe loss and any model metrics\non this data at the end of each epoch.\nThe validation data is selected from the last samples\nin the x and y data provided, before shuffling. This argument is\nnot supported when x is a dataset, generator or\nkeras.utils.Sequence instance.\nvalidation_data: Data on which to evaluate\nthe loss and any model metrics at the end of each epoch.\nThe model will not be trained on this data.\nvalidation_data will override validation_split.\nvalidation_data could be:\n\ntuple (x_val, y_val) of Numpy arrays or tensors\ntuple (x_val, y_val, val_sample_weights) of Numpy arrays\ndataset\nFor the first two cases, batch_size must be provided.\nFor the last case, validation_steps could be provided.\n\nshuffle: Boolean (whether to shuffle the training data\nbefore each epoch) or str (for 'batch').\n'batch' is a special option for dealing with the\nlimitations of HDF5 data; it shuffles in batch-sized chunks.\nHas no effect when steps_per_epoch is not None.\nclass_weight: Optional dictionary mapping class indices (integers)\nto a weight (float) value, used for weighting the loss function\n(during training only).\nThis can be useful to tell the model to\n\"pay more attention\" to samples from\nan under-represented class.\nsample_weight: Optional Numpy array of weights for\nthe training samples, used for weighting the loss function\n(during training only). You can either pass a flat (1D)\nNumpy array with the same length as the input samples\n(1:1 mapping between weights and samples),\nor in the case of temporal data,\nyou can pass a 2D array with shape\n(samples, sequence_length),\nto apply a different weight to every timestep of every sample.\nIn this case you should make sure to specify\nsample_weight_mode=\"temporal\" in compile(). This argument is not\nsupported when x is a dataset, generator, or\nkeras.utils.Sequence instance, instead provide the sample_weights\nas the third element of x.\ninitial_epoch: Integer.\nEpoch at which to start training\n(useful for resuming a previous training run).\nsteps_per_epoch: Integer or None.\nTotal number of steps (batches of samples)\nbefore declaring one epoch finished and starting the\nnext epoch. When training with input tensors such as\nTensorFlow data tensors, the default None is equal to\nthe number of samples in your dataset divided by\nthe batch size, or 1 if that cannot be determined. If x is a\ntf.data dataset, and 'steps_per_epoch'\nis None, the epoch will run until the input dataset is exhausted.\nThis argument is not supported with array inputs.\nvalidation_steps: Only relevant if validation_data is provided and\nis a tf.data dataset. Total number of steps (batches of\nsamples) to draw before stopping when performing validation\nat the end of every epoch. If 'validation_steps' is None, validation\nwill run until the validation_data dataset is exhausted. In the\ncase of a infinite dataset, it will run into a infinite loop.\nIf 'validation_steps' is specified and only part of the dataset\nwill be consumed, the evaluation will start from the beginning of\nthe dataset at each epoch. This ensures that the same validation\nsamples are used every time.\nvalidation_freq: Only relevant if validation data is provided. Integer\nor collections_abc.Container instance (e.g. list, tuple, etc.).\nIf an integer, specifies how many training epochs to run before a\nnew validation run is performed, e.g. validation_freq=2 runs\nvalidation every 2 epochs. If a Container, specifies the epochs on\nwhich to run validation, e.g. validation_freq=[1, 2, 10] runs\nvalidation at the end of the 1st, 2nd, and 10th epochs.\nmax_queue_size: Integer. Used for generator or keras.utils.Sequence\ninput only. Maximum size for the generator queue.\nIf unspecified, max_queue_size will default to 10.\nworkers: Integer. Used for generator or keras.utils.Sequence input\nonly. Maximum number of processes to spin up\nwhen using process-based threading. If unspecified, workers\nwill default to 1. If 0, will execute the generator on the main\nthread.\nuse_multiprocessing: Boolean. Used for generator or\nkeras.utils.Sequence input only. If True, use process-based\nthreading. If unspecified, use_multiprocessing will default to\nFalse. Note that because this implementation relies on\nmultiprocessing, you should not pass non-picklable arguments to\nthe generator as they can't be passed easily to children processes.\n**kwargs: Used for backwards compatibility.\n\n\nUnpacking behavior for iterator-like inputs:\n    A common pattern is to pass a tf.data.Dataset, generator, or\n  tf.keras.utils.Sequence to the x argument of fit, which will in fact\n  yield not only features (x) but optionally targets (y) and sample weights.\n  Keras requires that the output of such iterator-likes be unambiguous. The\n  iterator should return a tuple of length 1, 2, or 3, where the optional\n  second and third elements will be used for y and sample_weight\n  respectively. Any other type provided will be wrapped in a length one\n  tuple, effectively treating everything as 'x'. When yielding dicts, they\n  should still adhere to the top-level tuple structure.\n  e.g. ({\"x0\": x0, \"x1\": x1}, y). Keras will not attempt to separate\n  features, targets, and weights from the keys of a single dict.\n    A notable unsupported data type is the namedtuple. The reason is that\n  it behaves like both an ordered datatype (tuple) and a mapping\n  datatype (dict). So given a namedtuple of the form:\n      namedtuple(\"example_tuple\", [\"y\", \"x\"])\n  it is ambiguous whether to reverse the order of the elements when\n  interpreting the value. Even worse is a tuple of the form:\n      namedtuple(\"other_tuple\", [\"x\", \"y\", \"z\"])\n  where it is unclear if the tuple was intended to be unpacked into x, y,\n  and sample_weight or passed through as a single element to x. As a\n  result the data processing code will simply raise a ValueError if it\n  encounters a namedtuple. (Along with instructions to remedy the issue.)\n\nReturns:\n\nA History object. Its History.history attribute is\na record of training loss values and metrics values\nat successive epochs, as well as validation loss values\nand validation metrics values (if applicable).\n\nRaises:\n\n\nRuntimeError: If the model was never compiled.\nValueError: In case of mismatch between the provided input data\nand what the model expects.\n\n\nfit_generator\n\nView source\nfit_generator(\n    generator, steps_per_epoch=None, epochs=1, verbose=1, callbacks=None,\n    validation_data=None, validation_steps=None, validation_freq=1,\n    class_weight=None, max_queue_size=10, workers=1, use_multiprocessing=False,\n    shuffle=True, initial_epoch=0\n)\n\nFits the model on data yielded batch-by-batch by a Python generator. (deprecated)\nWarning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.\nInstructions for updating:\nPlease use Model.fit, which supports generators.\nDEPRECATED:\n\nModel.fit now supports generators, so there is no longer any need to use\nthis endpoint.\n\nget_layer\n\nView source\nget_layer(\n    name=None, index=None\n)\n\nRetrieves a layer based on either its name (unique) or index.\n\nIf name and index are both provided, index will take precedence.\nIndices are based on order of horizontal graph traversal (bottom-up).\n\nArguments:\n\n"}, {"name": "name", "is_optional": true, "type": "int", "default_value": "None", "description": "String, name of layer.\nindex: Integer, index of layer."}]}},
{"id": "tf.io.gfile.stat", "type": "function", "code": "tf.io.gfile.stat(path)", "summary": "Returns file statistics for a given path.", "description": "", "code-info": {"name": "tf.io.gfile.stat", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, path to a file"}]}},
{"id": "tf.io.gfile.rmtree", "type": "function", "code": "tf.io.gfile.rmtree(path)", "summary": "Deletes everything under path recursively.", "description": "", "code-info": {"name": "tf.io.gfile.rmtree", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, a path"}]}},
{"id": "tf.keras.Model", "type": "function", "code": "tf.keras.Model(*args,**kwargs)", "summary": "Model groups layers into an object with training and inference features.", "description": "", "code-info": {"name": "tf.keras.Model", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Any additional arguments."}]}},
{"id": "tf.io.gfile.rename", "type": "function", "code": "tf.io.gfile.rename(src,dst,overwrite=False)", "summary": "Rename or move a file / directory.", "description": "", "code-info": {"name": "tf.io.gfile.rename", "parameters": [{"name": "src", "is_optional": false, "type": "string", "description": "string, pathname for a file"}, {"name": "dst", "is_optional": false, "type": "string", "description": "string, pathname to which the file needs to be moved"}, {"name": "overwrite", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean, if false it's an error for dst to be occupied by an\nexisting file."}]}},
{"id": "tf.io.gfile.remove", "type": "function", "code": "tf.io.gfile.remove(path)", "summary": "Deletes the path located at 'path'.", "description": "", "code-info": {"name": "tf.io.gfile.remove", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, a path"}]}},
{"id": "tf.io.gfile.mkdir", "type": "function", "code": "tf.io.gfile.mkdir(path)", "summary": "Creates a directory with the name given by path.", "description": "", "code-info": {"name": "tf.io.gfile.mkdir", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, name of the directory to be created"}]}},
{"id": "tf.io.gfile.exists", "type": "function", "code": "tf.io.gfile.exists(path)", "summary": "Determines whether a path exists or not.", "description": "", "code-info": {"name": "tf.io.gfile.exists", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, a path"}]}},
{"id": "tf.io.gfile.makedirs", "type": "function", "code": "tf.io.gfile.makedirs(path)", "summary": "Creates a directory and all parent/intermediate directories.", "description": "", "code-info": {"name": "tf.io.gfile.makedirs", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, name of the directory to be created"}]}},
{"id": "tf.io.gfile.copy", "type": "function", "code": "tf.io.gfile.copy(src,dst,overwrite=False)", "summary": "Copies data from src to dst.", "description": "", "code-info": {"name": "tf.io.gfile.copy", "parameters": [{"name": "src", "is_optional": false, "type": "string", "description": "string, name of the file whose contents need to be copied"}, {"name": "dst", "is_optional": false, "type": "string", "description": "string, name of the file to which to copy to"}, {"name": "overwrite", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean, if false it's an error for dst to be occupied by an\nexisting file."}]}},
{"id": "tf.io.gfile.listdir", "type": "function", "code": "tf.io.gfile.listdir(path)", "summary": "Returns a list of entries contained within a directory.", "description": "", "code-info": {"name": "tf.io.gfile.listdir", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, path to a directory"}]}},
{"id": "tf.io.gfile.isdir", "type": "function", "code": "tf.io.gfile.isdir(path)", "summary": "Returns whether the path is a directory or not.", "description": "", "code-info": {"name": "tf.io.gfile.isdir", "parameters": [{"name": "path", "is_optional": false, "type": "string", "description": "string, path to a potential directory"}]}},
{"id": "tf.io.gfile.glob", "type": "function", "code": "tf.io.gfile.glob(pattern)", "summary": "Returns a list of files that match the given pattern(s).", "description": "", "code-info": {"name": "tf.io.gfile.glob", "parameters": [{"name": "pattern", "is_optional": false, "type": "string", "description": "string or iterable of strings. The glob pattern(s)."}]}},
{"id": "tf.io.gfile.GFile", "type": "function", "code": "tf.io.gfile.GFile(name,mode='r')", "summary": "File I/O wrappers without thread locking.", "description": "", "code-info": {"name": "tf.io.gfile.GFile", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "  Returns the file name.\n\n\nMethods\n\n__enter__\n\nView source\n__enter__()\n\nMake usable with \"with\" statement.\n\n__exit__\n\nView source\n__exit__(\n    unused_type, unused_value, unused_traceback\n)\n\nMake usable with \"with\" statement.\n\n__iter__\n\nView source\n__iter__()\n\nclose\n\nView source\nclose()\n\nCloses FileIO. Should be called for the WritableFile to be flushed.\n\nflush\n\nView source\nflush()\n\nFlushes the Writable file.\n\nThis only ensures that the data has made its way out of the process without\nany guarantees on whether it's written to disk. This means that the\ndata would survive an application crash but not necessarily an OS crash.\n\nnext\n\nView source\nnext()\n\nread\n\nView source\nread(\n    n=-1\n)\n\nReturns the contents of a file as a string.\n\nStarts reading from current position in file.\n\nArgs:\n\n\nn: Read n bytes if n != -1. If n = -1, reads to end of file.\n\n\nReturns:\n\nn bytes of the file (or whole file) in bytes mode or n bytes of the\nstring if in string (regular) mode.\n\nreadline\n\nView source\nreadline()\n\nReads the next line from the file. Leaves the '\\n' at the end.\n\nreadlines\n\nView source\nreadlines()\n\nReturns all lines from the file in a list.\n\nseek\n\nView source\nseek(\n    offset=None, whence=0, position=None\n)\n\nSeeks to the offset in the file. (deprecated arguments)\nWarning: SOME ARGUMENTS ARE DEPRECATED: (position). They will be removed in a future version.\nInstructions for updating:\nposition is deprecated in favor of the offset argument.\nArgs:\n\n\noffset: The byte count relative to the whence argument.\nwhence: Valid values for whence are:\n0: start of the file (default)\n1: relative to the current position of the file\n2: relative to the end of file. offset is usually negative.\n\n\nseekable\n\nView source\nseekable()\n\nReturns True as FileIO supports random access ops of seek()/tell()\n\nsize\n\nView source\nsize()\n\nReturns the size of the file.\n\ntell\n\nView source\ntell()\n\nReturns the current position in the file.\n\nwrite\n\nView source\nwrite(\n    file_content\n)\n\nWrites file_content to the file. Appends to the end of the file.\n\n          "}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'r'", "description": "  Returns the mode in which the file was opened.\nname:   Returns the file name."}]}},
{"id": "tf.io.TFRecordOptions", "type": "function", "code": "tf.io.TFRecordOptions(compression_type=None,flush_mode=None,input_buffer_size=None,output_buffer_size=None,window_bits=None,compression_level=None,compression_method=None,mem_level=None,compression_strategy=None)", "summary": "Options used for manipulating TFRecord files.", "description": "", "code-info": {"name": "tf.io.TFRecordOptions", "parameters": [{"name": "compression_type", "is_optional": true, "type": "others", "default_value": "None", "description": "\"GZIP\", \"ZLIB\", or \"\" (no compression)."}, {"name": "flush_mode", "is_optional": true, "type": "others", "default_value": "None", "description": "flush mode or None, Default: Z_NO_FLUSH."}, {"name": "input_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "int or None."}, {"name": "output_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "int or None."}, {"name": "window_bits", "is_optional": true, "type": "others", "default_value": "None", "description": "int or None."}, {"name": "compression_level", "is_optional": true, "type": "others", "default_value": "None", "description": "0 to 9, or None."}, {"name": "compression_method", "is_optional": true, "type": "others", "default_value": "None", "description": "compression method or None."}, {"name": "mem_level", "is_optional": true, "type": "others", "default_value": "None", "description": "1 to 9, or None."}, {"name": "compression_strategy", "is_optional": true, "type": "string", "default_value": "None", "description": "strategy or None. Default: Z_DEFAULT_STRATEGY."}]}},
{"id": "tf.io.TFRecordWriter", "type": "function", "code": "tf.io.TFRecordWriter(path,options=None)", "summary": "A class to write records to a TFRecords file.", "description": "", "code-info": {"name": "tf.io.TFRecordWriter", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "The path to the TFRecords file."}, {"name": "options", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional) String specifying compression type,\nTFRecordCompressionType, or TFRecordOptions object."}]}},
{"id": "tf.io.write_graph", "type": "function", "code": "tf.io.write_graph(graph_or_graph_def,logdir,name,as_text=True)", "summary": "Writes a graph proto to a file.", "description": "", "code-info": {"name": "tf.io.write_graph", "parameters": [{"name": "graph_or_graph_def", "is_optional": false, "type": "others", "description": "A Graph or a GraphDef protocol buffer."}, {"name": "logdir", "is_optional": false, "type": "others", "description": "Directory where to write the graph. This can refer to remote\nfilesystems, such as Google Cloud Storage (GCS)."}, {"name": "name", "is_optional": false, "type": "string", "description": "Filename for the graph."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, writes the graph as an ASCII proto."}]}},
{"id": "tf.io.write_file", "type": "function", "code": "tf.io.write_file(filename,contents,name=None)", "summary": "Writes contents to the file at input filename. Creates file and recursively", "description": "", "code-info": {"name": "tf.io.write_file", "parameters": [{"name": "filename", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nscalar. The name of the file to which we write the contents."}, {"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nscalar. The content to be written to the output file."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.serialize_tensor", "type": "function", "code": "tf.io.serialize_tensor(tensor,name=None)", "summary": "Transforms a Tensor into a serialized TensorProto proto.", "description": "", "code-info": {"name": "tf.io.serialize_tensor", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. A Tensor of type T."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.read_file", "type": "function", "code": "tf.io.read_file(filename,name=None)", "summary": "Reads and outputs the entire contents of the input filename.", "description": "", "code-info": {"name": "tf.io.read_file", "parameters": [{"name": "filename", "is_optional": false, "type": "tensor", "description": "A Tensor of type string."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.serialize_sparse", "type": "function", "code": "tf.io.serialize_sparse(sp_input,out_type=tf.dtypes.string,name=None)", "summary": "Serialize a SparseTensor into a 3-vector (1-D Tensor) object.", "description": "", "code-info": {"name": "tf.io.serialize_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.string", "description": "The dtype to use for serialization."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}]}},
{"id": "tf.io.serialize_many_sparse", "type": "function", "code": "tf.io.serialize_many_sparse(sp_input,out_type=tf.dtypes.string,name=None)", "summary": "Serialize N-minibatch SparseTensor into an [N, 3] Tensor.", "description": "", "code-info": {"name": "tf.io.serialize_many_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input rank R SparseTensor."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.string", "description": "The dtype to use for serialization."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}]}},
{"id": "tf.io.parse_single_sequence_example", "type": "function", "code": "tf.io.parse_single_sequence_example(serialized,context_features=None,sequence_features=None,example_name=None,name=None)", "summary": "Parses a single SequenceExample proto.", "description": "", "code-info": {"name": "tf.io.parse_single_sequence_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A scalar (0-D Tensor) of type string, a single binary\nserialized SequenceExample proto."}, {"name": "context_features", "is_optional": true, "type": "others", "default_value": "None", "description": "A dict mapping feature keys to FixedLenFeature or\nVarLenFeature or RaggedFeature values. These features are associated\nwith a SequenceExample as a whole."}, {"name": "sequence_features", "is_optional": true, "type": "others", "default_value": "None", "description": "A dict mapping feature keys to\nFixedLenSequenceFeature or VarLenFeature or RaggedFeature values.\nThese features are associated with data within the FeatureList section\nof the SequenceExample proto."}, {"name": "example_name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A scalar (0-D Tensor) of strings (optional), the name of\nthe serialized proto."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.io.parse_tensor", "type": "function", "code": "tf.io.parse_tensor(serialized,out_type,name=None)", "summary": "Transforms a serialized tensorflow.TensorProto proto into a Tensor.", "description": "", "code-info": {"name": "tf.io.parse_tensor", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nA scalar string containing a serialized TensorProto proto."}, {"name": "out_type", "is_optional": false, "type": "tensor", "description": "A tf.DType.\nThe type of the serialized tensor.  The provided type must match the\ntype of the serialized tensor and no implicit conversion will take place."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.parse_single_example", "type": "function", "code": "tf.io.parse_single_example(serialized,features,example_names=None,name=None)", "summary": "Parses a single Example proto.", "description": "", "code-info": {"name": "tf.io.parse_single_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A scalar string Tensor, a single serialized Example."}, {"name": "features", "is_optional": false, "type": "others", "description": "A dict mapping feature keys to FixedLenFeature or\nVarLenFeature values."}, {"name": "example_names", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional) A scalar string Tensor, the associated name."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.io.parse_sequence_example", "type": "function", "code": "tf.io.parse_sequence_example(serialized,context_features=None,sequence_features=None,example_names=None,name=None)", "summary": "Parses a batch of SequenceExample protos.", "description": "", "code-info": {"name": "tf.io.parse_sequence_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A vector (1-D Tensor) of type string containing binary\nserialized SequenceExample protos."}, {"name": "context_features", "is_optional": true, "type": "others", "default_value": "None", "description": "A dict mapping feature keys to FixedLenFeature or\nVarLenFeature or RaggedFeature values. These features are associated\nwith a SequenceExample as a whole."}, {"name": "sequence_features", "is_optional": true, "type": "others", "default_value": "None", "description": "A dict mapping feature keys to\nFixedLenSequenceFeature or VarLenFeature or RaggedFeature values.\nThese features are associated with data within the FeatureList section\nof the SequenceExample proto."}, {"name": "example_names", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A vector (1-D Tensor) of strings (optional), the name of the\nserialized protos."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.io.parse_example", "type": "function", "code": "tf.io.parse_example(serialized,features,example_names=None,name=None)", "summary": "Parses Example protos into a dict of tensors.", "description": "", "code-info": {"name": "tf.io.parse_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A vector (1-D Tensor) of strings, a batch of binary\nserialized Example protos."}, {"name": "features", "is_optional": false, "type": "string", "description": "{\n    \"kw\": VarLenFeature(tf.string),\n    \"dank\": VarLenFeature(tf.int64),\n    \"gps\": VarLenFeature(tf.float32),\n}\n\nThen the output is a dictionary:\n{\n  \"kw\": SparseTensor(\n      indices=[[0, 0], [0, 1], [1, 0]],\n      values=[\"knit\", \"big\", \"emmy\"]\n      dense_shape=[2, 2]),\n  \"dank\": SparseTensor(\n      indices=[[1, 0]],\n      values=[42],\n      dense_shape=[2, 1]),\n  \"gps\": SparseTensor(\n      indices=[],\n      values=[],\n      dense_shape=[2, 0]),\n}\n\nFor dense results in two serialized Examples:\n[\n  features {\n    feature { key: \"age\" value { int64_list { value: [ 0 ] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n   },\n   features {\n    feature { key: \"age\" value { int64_list { value: [] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n  }\n]\n\nWe can use arguments:"}, {"name": "example_names", "is_optional": true, "type": "others", "default_value": "None", "description": "[\"input0\", \"input1\"],\nfeatures: {\n    \"kw\": VarLenFeature(tf.string),\n    \"dank\": VarLenFeature(tf.int64),\n    \"gps\": VarLenFeature(tf.float32),\n}\n\nThen the output is a dictionary:\n{\n  \"kw\": SparseTensor(\n      indices=[[0, 0], [0, 1], [1, 0]],\n      values=[\"knit\", \"big\", \"emmy\"]\n      dense_shape=[2, 2]),\n  \"dank\": SparseTensor(\n      indices=[[1, 0]],\n      values=[42],\n      dense_shape=[2, 1]),\n  \"gps\": SparseTensor(\n      indices=[],\n      values=[],\n      dense_shape=[2, 0]),\n}\n\nFor dense results in two serialized Examples:\n[\n  features {\n    feature { key: \"age\" value { int64_list { value: [ 0 ] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n   },\n   features {\n    feature { key: \"age\" value { int64_list { value: [] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n  }\n]\n\nWe can use arguments:"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.io.matching_files", "type": "function", "code": "tf.io.matching_files(pattern,name=None)", "summary": "Returns the set of files matching one or more glob patterns.", "description": "", "code-info": {"name": "tf.io.matching_files", "parameters": [{"name": "pattern", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nShell wildcard pattern(s). Scalar or vector of type string."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.extract_jpeg_shape", "type": "function", "code": "tf.io.extract_jpeg_shape(contents,output_type=tf.dtypes.int32,name=None)", "summary": "Extract the shape information of a JPEG-encoded image.", "description": "", "code-info": {"name": "tf.io.extract_jpeg_shape", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D. The JPEG-encoded image."}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int32.\n(Optional) The output type of the operation (int32 or int64).\nDefaults to int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.is_jpeg", "type": "function", "code": "tf.io.is_jpeg(contents,name=None)", "summary": "Convenience function to check if the 'contents' encodes a JPEG image.", "description": "", "code-info": {"name": "tf.io.is_jpeg", "parameters": [{"name": "contents", "is_optional": false, "type": "string", "description": "0-D string. The encoded image bytes."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)"}]}},
{"id": "tf.io.match_filenames_once", "type": "function", "code": "tf.io.match_filenames_once(pattern,name=None)", "summary": "Save the list of files matching pattern, so it is only computed once.", "description": "", "code-info": {"name": "tf.io.match_filenames_once", "parameters": [{"name": "pattern", "is_optional": false, "type": "tensor", "description": "A file pattern (glob), or 1D tensor of file patterns."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operations (optional)."}]}},
{"id": "tf.io.decode_proto", "type": "function", "code": "tf.io.decode_proto(bytes,message_type,field_names,output_types,descriptor_source='local://',message_format='binary',sanitize=False,name=None)", "summary": "The op extracts fields from a serialized protocol buffers message into tensors.", "description": "", "code-info": {"name": "tf.io.decode_proto", "parameters": [{"name": "bytes", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nTensor of serialized protos with shape batch_shape."}, {"name": "message_type", "is_optional": false, "type": "string", "description": "A string. Name of the proto message type to decode."}, {"name": "field_names", "is_optional": false, "type": "string", "description": "A list of strings.\nList of strings containing proto field names. An extension field can be decoded\nby using its full name, e.g. EXT_PACKAGE.EXT_FIELD_NAME."}, {"name": "output_types", "is_optional": false, "type": "others", "description": "A list of tf.DTypes.\nList of TF types to use for the respective field in field_names."}, {"name": "descriptor_source", "is_optional": true, "type": "string", "default_value": "'local://'", "description": "An optional string. Defaults to \"local://\".\nEither the special value local:// or a path to a file containing\na serialized FileDescriptorSet."}, {"name": "message_format", "is_optional": true, "type": "string", "default_value": "'binary'", "description": "An optional string. Defaults to \"binary\".\nEither binary or text."}, {"name": "sanitize", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nWhether to sanitize the result or not."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.encode_proto", "type": "function", "code": "tf.io.encode_proto(sizes,values,field_names,message_type,descriptor_source='local://',name=None)", "summary": "The op serializes protobuf messages provided in the input tensors.", "description": "", "code-info": {"name": "tf.io.encode_proto", "parameters": [{"name": "sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nTensor of int32 with shape [batch_shape, len(field_names)]."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects.\nList of tensors containing values for the corresponding field."}, {"name": "field_names", "is_optional": false, "type": "string", "description": "A list of strings.\nList of strings containing proto field names."}, {"name": "message_type", "is_optional": false, "type": "string", "description": "A string. Name of the proto message type to decode."}, {"name": "descriptor_source", "is_optional": true, "type": "string", "default_value": "'local://'", "description": "An optional string. Defaults to \"local://\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.encode_jpeg", "type": "function", "code": "tf.io.encode_jpeg(image,format='',quality=95,progressive=False,optimize_size=False,chroma_downsampling=True,density_unit='in',x_density=300,y_density=300,xmp_metadata='',name=None)", "summary": "JPEG-encode an image.", "description": "", "code-info": {"name": "tf.io.encode_jpeg", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "A Tensor of type uint8.\n3-D with shape [height, width, channels]."}, {"name": "format", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string from: \"\", \"grayscale\", \"rgb\". Defaults to \"\".\nPer pixel image format."}, {"name": "quality", "is_optional": true, "type": "int", "default_value": "95", "description": "An optional int. Defaults to 95.\nQuality of the compression from 0 to 100 (higher is better and slower)."}, {"name": "progressive", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf True, create a JPEG that loads progressively (coarse to fine)."}, {"name": "optimize_size", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf True, spend CPU/RAM to reduce size with no quality change."}, {"name": "chroma_downsampling", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nSee http://en.wikipedia.org/wiki/Chroma_subsampling."}, {"name": "density_unit", "is_optional": true, "type": "string", "default_value": "'in'", "description": "An optional string from: \"in\", \"cm\". Defaults to \"in\".\nUnit used to specify x_density and y_density:\npixels per inch ('in') or centimeter ('cm')."}, {"name": "x_density", "is_optional": true, "type": "int", "default_value": "300", "description": "An optional int. Defaults to 300.\nHorizontal pixels per density unit."}, {"name": "y_density", "is_optional": true, "type": "int", "default_value": "300", "description": "An optional int. Defaults to 300.\nVertical pixels per density unit."}, {"name": "xmp_metadata", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nIf not empty, embed this XMP metadata in the image header."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_json_example", "type": "function", "code": "tf.io.decode_json_example(json_examples,name=None)", "summary": "Convert JSON-encoded Example records to binary protocol buffer strings.", "description": "", "code-info": {"name": "tf.io.decode_json_example", "parameters": [{"name": "json_examples", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nEach string is a JSON object serialized according to the JSON\nmapping of the Example proto."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.encode_base64", "type": "function", "code": "tf.io.encode_base64(input,pad=False,name=None)", "summary": "Encode strings into web-safe base64 format.", "description": "", "code-info": {"name": "tf.io.encode_base64", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. Strings to be encoded."}, {"name": "pad", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nBool whether padding is applied at the ends."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.deserialize_many_sparse", "type": "function", "code": "tf.io.deserialize_many_sparse(serialized_sparse,dtype,rank=None,name=None)", "summary": "Deserialize and concatenate SparseTensors from a serialized minibatch.", "description": "", "code-info": {"name": "tf.io.deserialize_many_sparse", "parameters": [{"name": "serialized_sparse", "is_optional": false, "type": "tensor", "description": "2-D Tensor of type string of shape [N, 3].\nThe serialized and packed SparseTensor objects."}, {"name": "dtype", "is_optional": false, "type": "tensor", "description": "The dtype of the serialized SparseTensor objects."}, {"name": "rank", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Python int, the rank of the SparseTensor objects."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}]}},
{"id": "tf.io.decode_raw", "type": "function", "code": "tf.io.decode_raw(input_bytes,out_type,little_endian=True,fixed_length=None,name=None)", "summary": "Convert raw byte strings into tensors.", "description": "", "code-info": {"name": "tf.io.decode_raw", "parameters": [{"name": "input_bytes", "is_optional": false, "type": "tensor", "description": "  Each element of the input Tensor is converted to an array of bytes."}, {"name": "out_type", "is_optional": false, "type": "others", "description": "  DType of the output. Acceptable types are half, float, double,\nint32, uint16, uint8, int16, int8, int64."}, {"name": "little_endian", "is_optional": true, "type": "bool", "default_value": "True", "description": "  Whether the input_bytes data is in little-endian format. Data will be\nconverted into host byte order if necessary."}, {"name": "fixed_length", "is_optional": true, "type": "others", "default_value": "None", "description": "  If set, the first fixed_length bytes of each element will be converted.\nData will be zero-padded or truncated to the specified length.\n\nfixed_length must be a multiple of the size of out_type.\nfixed_length must be specified if the elements of input_bytes are of\nvariable length."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_png", "type": "function", "code": "tf.io.decode_png(contents,channels=0,dtype=tf.dtypes.uint8,name=None)", "summary": "Decode a PNG-encoded image to a uint8 or uint16 tensor.", "description": "", "code-info": {"name": "tf.io.decode_png", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D.  The PNG-encoded image."}, {"name": "channels", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int. Defaults to 0.\nNumber of color channels for the decoded image."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.uint8", "description": "An optional tf.DType from: tf.uint8, tf.uint16. Defaults to tf.uint8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_jpeg", "type": "function", "code": "tf.io.decode_jpeg(contents,channels=0,ratio=1,fancy_upscaling=True,try_recover_truncated=False,acceptable_fraction=1,dct_method='',name=None)", "summary": "Decode a JPEG-encoded image to a uint8 tensor.", "description": "", "code-info": {"name": "tf.io.decode_jpeg", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D.  The JPEG-encoded image."}, {"name": "channels", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int. Defaults to 0.\nNumber of color channels for the decoded image."}, {"name": "ratio", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional int. Defaults to 1. Downscaling ratio."}, {"name": "fancy_upscaling", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nIf true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only)."}, {"name": "try_recover_truncated", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf true try to recover an image from truncated input."}, {"name": "acceptable_fraction", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional float. Defaults to 1.\nThe minimum required fraction of lines before a truncated\ninput is accepted."}, {"name": "dct_method", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nstring specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_image", "type": "function", "code": "tf.io.decode_image(contents,channels=None,dtype=tf.dtypes.uint8,name=None,expand_animations=True)", "summary": "Function for decode_bmp, decode_gif, decode_jpeg, and decode_png.", "description": "", "code-info": {"name": "tf.io.decode_image", "parameters": [{"name": "contents", "is_optional": false, "type": "string", "description": "0-D string. The encoded image bytes."}, {"name": "channels", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0. Number of color channels for\nthe decoded image."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.uint8", "description": "The desired DType of the returned Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)"}, {"name": "expand_animations", "is_optional": true, "type": "bool", "default_value": "True", "description": "Controls the shape of the returned op's output. If\nTrue, the returned op will produce a 3-D tensor for PNG, JPEG, and BMP\nfiles; and a 4-D tensor for all GIFs, whether animated or not. If,\nFalse, the returned op will produce a 3-D tensor for all file types and\nwill truncate animated GIFs to the first frame."}]}},
{"id": "tf.io.decode_gif", "type": "function", "code": "tf.io.decode_gif(contents,name=None)", "summary": "Decode the frame(s) of a GIF-encoded image to a uint8 tensor.", "description": "", "code-info": {"name": "tf.io.decode_gif", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D.  The GIF-encoded image."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_csv", "type": "function", "code": "tf.io.decode_csv(records,record_defaults,field_delim=',',use_quote_delim=True,na_value='',select_cols=None,name=None)", "summary": "Convert CSV records to tensors. Each column maps to one tensor.", "description": "", "code-info": {"name": "tf.io.decode_csv", "parameters": [{"name": "records", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nEach string is a record/row in the csv and all records should have\nthe same format."}, {"name": "record_defaults", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with specific types.\nAcceptable types are float32, float64, int32, int64, string.\nOne tensor per column of the input record, with either a\nscalar default value for that column or an empty vector if the column is\nrequired."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nIf false, treats double quotation marks as regular\ncharacters inside of the string fields (ignoring RFC 4180, Section 2,\nBullet 5)."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "Additional string to recognize as NA/NaN."}, {"name": "select_cols", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional sorted list of column indices to select. If specified,\nonly this subset of columns will be parsed and returned."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_compressed", "type": "function", "code": "tf.io.decode_compressed(bytes,compression_type='',name=None)", "summary": "Decompress strings.", "description": "", "code-info": {"name": "tf.io.decode_compressed", "parameters": [{"name": "bytes", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nA Tensor of string which is compressed."}, {"name": "compression_type", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nA scalar containing either (i) the empty string (no\ncompression), (ii) \"ZLIB\", or (iii) \"GZIP\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_bmp", "type": "function", "code": "tf.io.decode_bmp(contents,channels=0,name=None)", "summary": "Decode the first frame of a BMP-encoded image to a uint8 tensor.", "description": "", "code-info": {"name": "tf.io.decode_bmp", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D.  The BMP-encoded image."}, {"name": "channels", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int. Defaults to 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.total_variation", "type": "function", "code": "tf.image.total_variation(images,name=None)", "summary": "Calculate and return the total variation for one or more images.", "description": "", "code-info": {"name": "tf.image.total_variation", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.io.decode_base64", "type": "function", "code": "tf.io.decode_base64(input,name=None)", "summary": "Decode web-safe base64-encoded strings.", "description": "", "code-info": {"name": "tf.io.decode_base64", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. Base64 strings to decode."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.yiq_to_rgb", "type": "function", "code": "tf.image.yiq_to_rgb(images)", "summary": "Converts one or more images from YIQ to RGB.", "description": "", "code-info": {"name": "tf.image.yiq_to_rgb", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": "2-D or higher rank. Image data to convert. Last dimension must be\nsize 3."}]}},
{"id": "tf.image.transpose", "type": "function", "code": "tf.image.transpose(image,name=None)", "summary": "Transpose image(s) by swapping the height and width dimension.", "description": "", "code-info": {"name": "tf.image.transpose", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.ssim_multiscale", "type": "function", "code": "tf.image.ssim_multiscale(img1,img2,max_val,power_factors=_MSSSIM_WEIGHTS,filter_size=11,filter_sigma=1.5,k1=0.01,k2=0.03)", "summary": "Computes the MS-SSIM between img1 and img2.", "description": "", "code-info": {"name": "tf.image.ssim_multiscale", "parameters": [{"name": "img1", "is_optional": false, "type": "others", "description": "First image batch."}, {"name": "img2", "is_optional": false, "type": "others", "description": "Second image batch. Must have the same rank as img1."}, {"name": "max_val", "is_optional": false, "type": "others", "description": "The dynamic range of the images (i.e., the difference between the\nmaximum the and minimum allowed values)."}, {"name": "power_factors", "is_optional": true, "type": "others", "default_value": "_MSSSIM_WEIGHTS", "description": "Iterable of weights for each of the scales. The number of\nscales used is the length of the list. Index 0 is the unscaled\nresolution's weight and each increasing scale corresponds to the image\nbeing downsampled by 2.  Defaults to (0.0448, 0.2856, 0.3001, 0.2363,\n0.1333), which are the values obtained in the original paper."}, {"name": "filter_size", "is_optional": true, "type": "int", "default_value": "11", "description": "Default value 11 (size of gaussian filter)."}, {"name": "filter_sigma", "is_optional": true, "type": "others", "default_value": "1.5", "description": "Default value 1.5 (width of gaussian filter)."}, {"name": "k1", "is_optional": true, "type": "others", "default_value": "0.01", "description": "Default value 0.01"}, {"name": "k2", "is_optional": true, "type": "others", "default_value": "0.03", "description": "Default value 0.03 (SSIM is less sensitivity to K2 for lower values, so\nit would be better if we taken the values in range of 0&lt; K2 &lt;0.4)."}]}},
{"id": "tf.image.sample_distorted_bounding_box", "type": "function", "code": "tf.image.sample_distorted_bounding_box(image_size,bounding_boxes,seed=0,min_object_covered=0.1,aspect_ratio_range=None,area_range=None,max_attempts=None,use_image_if_no_bounding_boxes=None,name=None)", "summary": "Generate a single randomly distorted bounding box for an image.", "description": "", "code-info": {"name": "tf.image.sample_distorted_bounding_box", "parameters": [{"name": "image_size", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: uint8, int8,\nint16, int32, int64. 1-D, containing [height, width, channels]."}, {"name": "bounding_boxes", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 3-D with shape [batch, N, 4]\ndescribing the N bounding boxes associated with the image."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int. Defaults to 0. If seed is set to non-zero, the\nrandom number generator is seeded by the given seed.  Otherwise, it is\nseeded by a random seed."}, {"name": "min_object_covered", "is_optional": true, "type": "tensor", "default_value": "0.1", "description": "A Tensor of type float32. Defaults to 0.1. The\ncropped area of the image must contain at least this fraction of any\nbounding box supplied. The value of this parameter should be non-negative.\nIn the case of 0, the cropped area does not need to overlap any of the\nbounding boxes supplied."}, {"name": "aspect_ratio_range", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional list of floats. Defaults to [0.75,\n1.33]. The cropped area of the image must have an aspect ratio = width /\nheight within this range."}, {"name": "area_range", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional list of floats. Defaults to [0.05, 1]. The\ncropped area of the image must contain a fraction of the supplied image\nwithin this range."}, {"name": "max_attempts", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 100. Number of attempts at\ngenerating a cropped region of the image of the specified constraints.\nAfter max_attempts failures, return the entire image."}, {"name": "use_image_if_no_bounding_boxes", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to False.\nControls behavior if no bounding boxes supplied. If true, assume an\nimplicit bounding box covering the whole input. If false, raise an error."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.yuv_to_rgb", "type": "function", "code": "tf.image.yuv_to_rgb(images)", "summary": "Converts one or more images from YUV to RGB.", "description": "", "code-info": {"name": "tf.image.yuv_to_rgb", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": "2-D or higher rank. Image data to convert. Last dimension must be\nsize 3."}]}},
{"id": "tf.image.ssim", "type": "function", "code": "tf.image.ssim(img1,img2,max_val,filter_size=11,filter_sigma=1.5,k1=0.01,k2=0.03)", "summary": "Computes SSIM index between img1 and img2.", "description": "", "code-info": {"name": "tf.image.ssim", "parameters": [{"name": "img1", "is_optional": false, "type": "others", "description": "First image batch."}, {"name": "img2", "is_optional": false, "type": "others", "description": "Second image batch."}, {"name": "max_val", "is_optional": false, "type": "others", "description": "The dynamic range of the images (i.e., the difference between the\nmaximum the and minimum allowed values)."}, {"name": "filter_size", "is_optional": true, "type": "int", "default_value": "11", "description": "Default value 11 (size of gaussian filter)."}, {"name": "filter_sigma", "is_optional": true, "type": "others", "default_value": "1.5", "description": "Default value 1.5 (width of gaussian filter)."}, {"name": "k1", "is_optional": true, "type": "others", "default_value": "0.01", "description": "Default value 0.01"}, {"name": "k2", "is_optional": true, "type": "others", "default_value": "0.03", "description": "Default value 0.03 (SSIM is less sensitivity to K2 for lower values, so\nit would be better if we taken the values in range of 0&lt; K2 &lt;0.4)."}]}},
{"id": "tf.io.decode_and_crop_jpeg", "type": "function", "code": "tf.io.decode_and_crop_jpeg(contents,crop_window,channels=0,ratio=1,fancy_upscaling=True,try_recover_truncated=False,acceptable_fraction=1,dct_method='',name=None)", "summary": "Decode and Crop a JPEG-encoded image to a uint8 tensor.", "description": "", "code-info": {"name": "tf.io.decode_and_crop_jpeg", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. 0-D.  The JPEG-encoded image."}, {"name": "crop_window", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\n1-D.  The crop window: [crop_y, crop_x, crop_height, crop_width]."}, {"name": "channels", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int. Defaults to 0.\nNumber of color channels for the decoded image."}, {"name": "ratio", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional int. Defaults to 1. Downscaling ratio."}, {"name": "fancy_upscaling", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nIf true use a slower but nicer upscaling of the\nchroma planes (yuv420/422 only)."}, {"name": "try_recover_truncated", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf true try to recover an image from truncated input."}, {"name": "acceptable_fraction", "is_optional": true, "type": "int", "default_value": "1", "description": "An optional float. Defaults to 1.\nThe minimum required fraction of lines before a truncated\ninput is accepted."}, {"name": "dct_method", "is_optional": true, "type": "string", "default_value": "''", "description": "An optional string. Defaults to \"\".\nstring specifying a hint about the algorithm used for\ndecompression.  Defaults to \"\" which maps to a system-specific\ndefault.  Currently valid values are [\"INTEGER_FAST\",\n\"INTEGER_ACCURATE\"].  The hint may be ignored (e.g., the internal\njpeg library changes to a version that does not have that specific\noption.)"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.rgb_to_grayscale", "type": "function", "code": "tf.image.rgb_to_grayscale(images,name=None)", "summary": "Converts one or more images from RGB to Grayscale.", "description": "", "code-info": {"name": "tf.image.rgb_to_grayscale", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "The RGB tensor to convert. Last dimension must have size 3 and\nshould contain RGB values."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.rot90", "type": "function", "code": "tf.image.rot90(image,k=1,name=None)", "summary": "Rotate image(s) counter-clockwise by 90 degrees.", "description": "", "code-info": {"name": "tf.image.rot90", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": ""}, {"name": "k", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.image.rgb_to_yuv", "type": "function", "code": "tf.image.rgb_to_yuv(images)", "summary": "Converts one or more images from RGB to YUV.", "description": "", "code-info": {"name": "tf.image.rgb_to_yuv", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": "2-D or higher rank. Image data to convert. Last dimension must be\nsize 3."}]}},
{"id": "tf.image.resize_with_pad", "type": "function", "code": "tf.image.resize_with_pad(image,target_height,target_width,method=ResizeMethod.BILINEAR,antialias=False)", "summary": "Resizes and pads an image to a target width and height.", "description": "", "code-info": {"name": "tf.image.resize_with_pad", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "target_height", "is_optional": false, "type": "others", "description": "Target height."}, {"name": "target_width", "is_optional": false, "type": "others", "description": "Target width."}, {"name": "method", "is_optional": true, "type": "others", "default_value": "ResizeMethod.BILINEAR", "description": "Method to use for resizing image. See image.resize()"}, {"name": "antialias", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use anti-aliasing when resizing. See 'image.resize()'."}]}},
{"id": "tf.image.rgb_to_yiq", "type": "function", "code": "tf.image.rgb_to_yiq(images)", "summary": "Converts one or more images from RGB to YIQ.", "description": "", "code-info": {"name": "tf.image.rgb_to_yiq", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": "2-D or higher rank. Image data to convert. Last dimension must be\nsize 3."}]}},
{"id": "tf.image.sobel_edges", "type": "function", "code": "tf.image.sobel_edges(image)", "summary": "Returns a tensor holding Sobel edge maps.", "description": "", "code-info": {"name": "tf.image.sobel_edges", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "Image tensor with shape [batch_size, h, w, d] and type float32 or\nfloat64.  The image(s) must be 2x2 or larger."}]}},
{"id": "tf.image.rgb_to_hsv", "type": "function", "code": "tf.image.rgb_to_hsv(images,name=None)", "summary": "Converts one or more images from RGB to HSV.", "description": "", "code-info": {"name": "tf.image.rgb_to_hsv", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\n1-D or higher rank. RGB data to convert. Last dimension must be size 3."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.resize", "type": "function", "code": "tf.image.resize(images,size,method=ResizeMethod.BILINEAR,preserve_aspect_ratio=False,antialias=False,name=None)", "summary": "Resize images to size using the specified method.", "description": "", "code-info": {"name": "tf.image.resize", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "A 1-D int32 Tensor of 2 elements: new_height, new_width.  The new\nsize for the images."}, {"name": "method", "is_optional": true, "type": "others", "default_value": "ResizeMethod.BILINEAR", "description": "ResizeMethod.  Defaults to bilinear."}, {"name": "preserve_aspect_ratio", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to preserve the aspect ratio. If this is set,\nthen images will be resized to a size that fits in size while\npreserving the aspect ratio of the original image. Scales up the image if\nsize is bigger than the current size of the image. Defaults to False."}, {"name": "antialias", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use an anti-aliasing filter when downsampling an\nimage."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.resize_with_crop_or_pad", "type": "function", "code": "tf.image.resize_with_crop_or_pad(image,target_height,target_width)", "summary": "Crops and/or pads an image to a target width and height.", "description": "", "code-info": {"name": "tf.image.resize_with_crop_or_pad", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "target_height", "is_optional": false, "type": "others", "description": "Target height."}, {"name": "target_width", "is_optional": false, "type": "others", "description": "Target width."}]}},
{"id": "tf.image.random_saturation", "type": "function", "code": "tf.image.random_saturation(image,lower,upper,seed=None)", "summary": "Adjust the saturation of RGB images by a random factor.", "description": "", "code-info": {"name": "tf.image.random_saturation", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images. Size of the last dimension must be 3."}, {"name": "lower", "is_optional": false, "type": "float", "description": "float.  Lower bound for the random saturation factor."}, {"name": "upper", "is_optional": false, "type": "float", "description": "float.  Upper bound for the random saturation factor."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An operation-specific seed. It will be used in conjunction with the\ngraph-level seed to determine the real seeds that will be used in this\noperation. Please see the documentation of set_random_seed for its\ninteraction with the graph-level random seed."}]}},
{"id": "tf.image.random_jpeg_quality", "type": "function", "code": "tf.image.random_jpeg_quality(image,min_jpeg_quality,max_jpeg_quality,seed=None)", "summary": "Randomly changes jpeg encoding quality for inducing jpeg noise.", "description": "", "code-info": {"name": "tf.image.random_jpeg_quality", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "3D image. Size of the last dimension must be 1 or 3."}, {"name": "min_jpeg_quality", "is_optional": false, "type": "others", "description": "Minimum jpeg encoding quality to use."}, {"name": "max_jpeg_quality", "is_optional": false, "type": "others", "description": "Maximum jpeg encoding quality to use."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An operation-specific seed. It will be used in conjunction with the\ngraph-level seed to determine the real seeds that will be used in this\noperation. Please see the documentation of set_random_seed for its\ninteraction with the graph-level random seed."}]}},
{"id": "tf.image.random_flip_left_right", "type": "function", "code": "tf.image.random_flip_left_right(image,seed=None)", "summary": "Randomly flip an image horizontally (left to right).", "description": "", "code-info": {"name": "tf.image.random_flip_left_right", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.image.random_crop", "type": "function", "code": "tf.image.random_crop(value,size,seed=None,name=None)", "summary": "Randomly crops a tensor to a given size.", "description": "", "code-info": {"name": "tf.image.random_crop", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "Input tensor to crop."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "1-D tensor with size the rank of value."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.per_image_standardization", "type": "function", "code": "tf.image.per_image_standardization(image)", "summary": "Linearly scales each image in image to have mean 0 and variance 1.", "description": "", "code-info": {"name": "tf.image.per_image_standardization", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "An n-D Tensor with at least 3 dimensions, the last 3 of which are the\ndimensions of each image."}]}},
{"id": "tf.image.random_brightness", "type": "function", "code": "tf.image.random_brightness(image,max_delta,seed=None)", "summary": "Adjust the brightness of images by a random factor.", "description": "", "code-info": {"name": "tf.image.random_brightness", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "An image or images to adjust."}, {"name": "max_delta", "is_optional": false, "type": "float", "description": "float, must be non-negative."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.image.psnr", "type": "function", "code": "tf.image.psnr(a,b,max_val,name=None)", "summary": "Returns the Peak Signal-to-Noise Ratio between a and b.", "description": "", "code-info": {"name": "tf.image.psnr", "parameters": [{"name": "a", "is_optional": false, "type": "others", "description": "First set of images."}, {"name": "b", "is_optional": false, "type": "others", "description": "Second set of images."}, {"name": "max_val", "is_optional": false, "type": "others", "description": "The dynamic range of the images (i.e., the difference between the\nmaximum the and minimum allowed values)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Namespace to embed the computation in."}]}},
{"id": "tf.image.random_hue", "type": "function", "code": "tf.image.random_hue(image,max_delta,seed=None)", "summary": "Adjust the hue of RGB images by a random factor.", "description": "", "code-info": {"name": "tf.image.random_hue", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images. Size of the last dimension must be 3."}, {"name": "max_delta", "is_optional": false, "type": "float", "description": "float.  Maximum value for the random delta."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An operation-specific seed. It will be used in conjunction with the\ngraph-level seed to determine the real seeds that will be used in this\noperation. Please see the documentation of set_random_seed for its\ninteraction with the graph-level random seed."}]}},
{"id": "tf.image.random_flip_up_down", "type": "function", "code": "tf.image.random_flip_up_down(image,seed=None)", "summary": "Randomly flips an image vertically (upside down).", "description": "", "code-info": {"name": "tf.image.random_flip_up_down", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.image.random_contrast", "type": "function", "code": "tf.image.random_contrast(image,lower,upper,seed=None)", "summary": "Adjust the contrast of an image or images by a random factor.", "description": "", "code-info": {"name": "tf.image.random_contrast", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "An image tensor with 3 or more dimensions."}, {"name": "lower", "is_optional": false, "type": "float", "description": "float.  Lower bound for the random contrast factor."}, {"name": "upper", "is_optional": false, "type": "float", "description": "float.  Upper bound for the random contrast factor."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.image.pad_to_bounding_box", "type": "function", "code": "tf.image.pad_to_bounding_box(image,offset_height,offset_width,target_height,target_width)", "summary": "Pad image with zeros to the specified height and width.", "description": "", "code-info": {"name": "tf.image.pad_to_bounding_box", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "offset_height", "is_optional": false, "type": "others", "description": "Number of rows of zeros to add on top."}, {"name": "offset_width", "is_optional": false, "type": "others", "description": "Number of columns of zeros to add on the left."}, {"name": "target_height", "is_optional": false, "type": "others", "description": "Height of output image."}, {"name": "target_width", "is_optional": false, "type": "others", "description": "Width of output image."}]}},
{"id": "tf.image.non_max_suppression_with_scores", "type": "function", "code": "tf.image.non_max_suppression_with_scores(boxes,scores,max_output_size,iou_threshold=0.5,score_threshold=float('-inf'),soft_nms_sigma=0.0,name=None)", "summary": "Greedily selects a subset of bounding boxes in descending order of score.", "description": "", "code-info": {"name": "tf.image.non_max_suppression_with_scores", "parameters": [{"name": "boxes", "is_optional": false, "type": "tensor", "description": "A 2-D float Tensor of shape [num_boxes, 4]."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "A 1-D float Tensor of shape [num_boxes] representing a single\nscore corresponding to each box (each row of boxes)."}, {"name": "max_output_size", "is_optional": false, "type": "tensor", "description": "A scalar integer Tensor representing the maximum number\nof boxes to be selected by non max suppression."}, {"name": "iou_threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU."}, {"name": "score_threshold", "is_optional": true, "type": "float", "default_value": "floa", "description": "A float representing the threshold for deciding when to\nremove boxes based on score.\nsoft_nms_sigma: A scalar float representing the Soft NMS sigma parameter;\nSee Bodla et al, https://arxiv.org/abs/1704.04503).  When\nsoft_nms_sigma=0.0 (which is default), we fall back to standard (hard)\nNMS.\nname: A name for the operation (optional)."}]}},
{"id": "tf.image.grayscale_to_rgb", "type": "function", "code": "tf.image.grayscale_to_rgb(images,name=None)", "summary": "Converts one or more images from Grayscale to RGB.", "description": "", "code-info": {"name": "tf.image.grayscale_to_rgb", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "The Grayscale tensor to convert. Last dimension must be size 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.non_max_suppression", "type": "function", "code": "tf.image.non_max_suppression(boxes,scores,max_output_size,iou_threshold=0.5,score_threshold=float('-inf'),name=None)", "summary": "Greedily selects a subset of bounding boxes in descending order of score.", "description": "", "code-info": {"name": "tf.image.non_max_suppression", "parameters": [{"name": "boxes", "is_optional": false, "type": "tensor", "description": "A 2-D float Tensor of shape [num_boxes, 4]."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "A 1-D float Tensor of shape [num_boxes] representing a single\nscore corresponding to each box (each row of boxes)."}, {"name": "max_output_size", "is_optional": false, "type": "tensor", "description": "A scalar integer Tensor representing the maximum number\nof boxes to be selected by non max suppression."}, {"name": "iou_threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU."}, {"name": "score_threshold", "is_optional": true, "type": "float", "default_value": "floa", "description": "A float representing the threshold for deciding when to\nremove boxes based on score.\nname: A name for the operation (optional)."}]}},
{"id": "tf.image.non_max_suppression_padded", "type": "function", "code": "tf.image.non_max_suppression_padded(boxes,scores,max_output_size,iou_threshold=0.5,score_threshold=float('-inf'),pad_to_max_output_size=False,name=None)", "summary": "Greedily selects a subset of bounding boxes in descending order of score.", "description": "", "code-info": {"name": "tf.image.non_max_suppression_padded", "parameters": [{"name": "boxes", "is_optional": false, "type": "tensor", "description": "A 2-D float Tensor of shape [num_boxes, 4]."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "A 1-D float Tensor of shape [num_boxes] representing a single\nscore corresponding to each box (each row of boxes)."}, {"name": "max_output_size", "is_optional": false, "type": "tensor", "description": "A scalar integer Tensor representing the maximum number\nof boxes to be selected by non max suppression."}, {"name": "iou_threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU."}, {"name": "score_threshold", "is_optional": true, "type": "float", "default_value": "floa", "description": "A float representing the threshold for deciding when to\nremove boxes based on score.\npad_to_max_output_size: bool.  If True, size of selected_indices output is\npadded to max_output_size.\nname: A name for the operation (optional)."}]}},
{"id": "tf.image.image_gradients", "type": "function", "code": "tf.image.image_gradients(image)", "summary": "Returns image gradients (dy, dx) for each color channel.", "description": "", "code-info": {"name": "tf.image.image_gradients", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "Tensor with shape [batch_size, h, w, d]."}]}},
{"id": "tf.image.hsv_to_rgb", "type": "function", "code": "tf.image.hsv_to_rgb(images,name=None)", "summary": "Convert one or more images from HSV to RGB.", "description": "", "code-info": {"name": "tf.image.hsv_to_rgb", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\n1-D or higher rank. HSV data to convert. Last dimension must be size 3."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.non_max_suppression_overlaps", "type": "function", "code": "tf.image.non_max_suppression_overlaps(overlaps,scores,max_output_size,overlap_threshold=0.5,score_threshold=float('-inf'),name=None)", "summary": "Greedily selects a subset of bounding boxes in descending order of score.", "description": "", "code-info": {"name": "tf.image.non_max_suppression_overlaps", "parameters": [{"name": "overlaps", "is_optional": false, "type": "tensor", "description": "A 2-D float Tensor of shape [num_boxes, num_boxes]."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "A 1-D float Tensor of shape [num_boxes] representing a single\nscore corresponding to each box (each row of boxes)."}, {"name": "max_output_size", "is_optional": false, "type": "tensor", "description": "A scalar integer Tensor representing the maximum number\nof boxes to be selected by non max suppression."}, {"name": "overlap_threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "A float representing the threshold for deciding whether\nboxes overlap too much with respect to the provided overlap values."}, {"name": "score_threshold", "is_optional": true, "type": "float", "default_value": "floa", "description": "A float representing the threshold for deciding when to\nremove boxes based on score.\nname: A name for the operation (optional)."}]}},
{"id": "tf.image.generate_bounding_box_proposals", "type": "function", "code": "tf.image.generate_bounding_box_proposals(scores,bbox_deltas,image_info,anchors,nms_threshold=0.7,pre_nms_topn=6000,min_size=16,post_nms_topn=300,name=None)", "summary": "Generate bounding box proposals from encoded bounding boxes.", "description": "", "code-info": {"name": "tf.image.generate_bounding_box_proposals", "parameters": [{"name": "scores", "is_optional": false, "type": "others", "description": ""}, {"name": "bbox_deltas", "is_optional": false, "type": "others", "description": ""}, {"name": "image_info", "is_optional": false, "type": "others", "description": ""}, {"name": "anchors", "is_optional": false, "type": "others", "description": ""}, {"name": "nms_threshold", "is_optional": true, "type": "others", "default_value": "0.7", "description": ""}, {"name": "pre_nms_topn", "is_optional": true, "type": "int", "default_value": "6000", "description": ""}, {"name": "min_size", "is_optional": true, "type": "int", "default_value": "16", "description": ""}, {"name": "post_nms_topn", "is_optional": true, "type": "int", "default_value": "300", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.image.flip_up_down", "type": "function", "code": "tf.image.flip_up_down(image)", "summary": "Flip an image vertically (upside down).", "description": "", "code-info": {"name": "tf.image.flip_up_down", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}]}},
{"id": "tf.image.flip_left_right", "type": "function", "code": "tf.image.flip_left_right(image)", "summary": "Flip an image horizontally (left to right).", "description": "", "code-info": {"name": "tf.image.flip_left_right", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}]}},
{"id": "tf.image.extract_patches", "type": "function", "code": "tf.image.extract_patches(images,sizes,strides,rates,padding,name=None)", "summary": "Extract patches from images.", "description": "", "code-info": {"name": "tf.image.extract_patches", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor with shape `[batch, in_rows, in_cols, depth]"}, {"name": "sizes", "is_optional": false, "type": "others", "description": "The size of the extracted patches. Must be [1, size_rows, size_cols,\n1]."}, {"name": "strides", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor of length 4. How far the centers of two consecutive\npatches are in the images. Must be: [1, stride_rows, stride_cols, 1]."}, {"name": "rates", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor of length 4. Must be: [1, rate_rows, rate_cols, 1].\nThis is the input stride, specifying how far two consecutive patch samples\nare in the input. Equivalent to extracting patches with patch_sizes_eff =\npatch_sizes + (patch_sizes - 1) * (rates - 1), followed by subsampling\nthem spatially by a factor of rates. This is equivalent to rate in\ndilated (a.k.a. Atrous) convolutions."}, {"name": "padding", "is_optional": false, "type": "others", "description": "The type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.crop_and_resize", "type": "function", "code": "tf.image.crop_and_resize(image,boxes,box_indices,crop_size,method='bilinear',extrapolation_value=0,name=None)", "summary": "Extracts crops from the input image tensor and resizes them.", "description": "", "code-info": {"name": "tf.image.crop_and_resize", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "A 4-D tensor of shape [batch, image_height, image_width, depth].\nBoth image_height and image_width need to be positive."}, {"name": "boxes", "is_optional": false, "type": "tensor", "description": "A 2-D tensor of shape [num_boxes, 4]. The i-th row of the tensor\nspecifies the coordinates of a box in the box_ind[i] image and is\nspecified in normalized coordinates [y1, x1, y2, x2]. A normalized\ncoordinate value of y is mapped to the image coordinate at y *\n(image_height - 1), so as the [0, 1] interval of normalized image\nheight is mapped to [0, image_height - 1] in image height coordinates.\nWe do allow y1 &gt; y2, in which case the sampled crop is an up-down\nflipped version of the original image. The width dimension is treated\nsimilarly. Normalized coordinates outside the [0, 1] range are allowed,\nin which case we use extrapolation_value to extrapolate the input image\nvalues."}, {"name": "box_indices", "is_optional": false, "type": "tensor", "description": "A 1-D tensor of shape [num_boxes] with int32 values in [0,\nbatch). The value of box_ind[i] specifies the image that the i-th box\nrefers to."}, {"name": "crop_size", "is_optional": false, "type": "tensor", "description": "A 1-D tensor of 2 elements, size = [crop_height, crop_width].\nAll cropped image patches are resized to this size. The aspect ratio of\nthe image content is not preserved. Both crop_height and crop_width\nneed to be positive."}, {"name": "method", "is_optional": true, "type": "string", "default_value": "'bilinear'", "description": "An optional string specifying the sampling method for resizing. It\ncan be either \"bilinear\" or \"nearest\" and default to \"bilinear\".\nCurrently two sampling methods are supported: Bilinear and Nearest\nNeighbor."}, {"name": "extrapolation_value", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional float. Defaults to 0. Value used for\nextrapolation, when applicable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.convert_image_dtype", "type": "function", "code": "tf.image.convert_image_dtype(image,dtype,saturate=False,name=None)", "summary": "Convert image to dtype, scaling its values if needed.", "description": "", "code-info": {"name": "tf.image.convert_image_dtype", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "An image."}, {"name": "dtype", "is_optional": false, "type": "others", "description": "A DType to convert image to."}, {"name": "saturate", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, clip the input before casting (if necessary)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.central_crop", "type": "function", "code": "tf.image.central_crop(image,central_fraction)", "summary": "Crop the central region of the image(s).", "description": "", "code-info": {"name": "tf.image.central_crop", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "Either a 3-D float Tensor of shape [height, width, depth], or a 4-D\nTensor of shape [batch_size, height, width, depth]."}, {"name": "central_fraction", "is_optional": false, "type": "float", "description": "float (0, 1], fraction of size to crop\nUsage Example: python &gt;&gt; import tensorflow as tf &gt;&gt; x =\ntf.random.normal(shape=(256, 256, 3)) &gt;&gt; tf.image.central_crop(x, 0.5)"}]}},
{"id": "tf.image.encode_png", "type": "function", "code": "tf.image.encode_png(image,compression=-1,name=None)", "summary": "PNG-encode an image.", "description": "", "code-info": {"name": "tf.image.encode_png", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: uint8, uint16.\n3-D with shape [height, width, channels]."}, {"name": "compression", "is_optional": true, "type": "others", "default_value": "-1", "description": "An optional int. Defaults to -1. Compression level."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.crop_to_bounding_box", "type": "function", "code": "tf.image.crop_to_bounding_box(image,offset_height,offset_width,target_height,target_width)", "summary": "Crops an image to a specified bounding box.", "description": "", "code-info": {"name": "tf.image.crop_to_bounding_box", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "offset_height", "is_optional": false, "type": "others", "description": "Vertical coordinate of the top-left corner of the result in\nthe input."}, {"name": "offset_width", "is_optional": false, "type": "others", "description": "Horizontal coordinate of the top-left corner of the result in\nthe input."}, {"name": "target_height", "is_optional": false, "type": "others", "description": "Height of the result."}, {"name": "target_width", "is_optional": false, "type": "others", "description": "Width of the result."}]}},
{"id": "tf.image.combined_non_max_suppression", "type": "function", "code": "tf.image.combined_non_max_suppression(boxes,scores,max_output_size_per_class,max_total_size,iou_threshold=0.5,score_threshold=float('-inf'),pad_per_class=False,clip_boxes=True,name=None)", "summary": "Greedily selects a subset of bounding boxes in descending order of score.", "description": "", "code-info": {"name": "tf.image.combined_non_max_suppression", "parameters": [{"name": "boxes", "is_optional": false, "type": "tensor", "description": "A 4-D float Tensor of shape [batch_size, num_boxes, q, 4]. If q\nis 1 then same boxes are used for all classes otherwise, if q is equal\nto number of classes, class-specific boxes are used."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "A 3-D float Tensor of shape [batch_size, num_boxes, num_classes]\nrepresenting a single score corresponding to each box (each row of boxes)."}, {"name": "max_output_size_per_class", "is_optional": false, "type": "tensor", "description": "A scalar integer Tensor representing the\nmaximum number of boxes to be selected by non max suppression per class"}, {"name": "max_total_size", "is_optional": false, "type": "float", "description": "A scalar representing maximum number of boxes retained over\nall classes."}, {"name": "iou_threshold", "is_optional": true, "type": "float", "default_value": "0.5", "description": "A float representing the threshold for deciding whether boxes\noverlap too much with respect to IOU."}, {"name": "score_threshold", "is_optional": true, "type": "float", "default_value": "floa", "description": "A float representing the threshold for deciding when to\nremove boxes based on score.\npad_per_class: If false, the output nmsed boxes, scores and classes are\npadded/clipped to max_total_size. If true, the output nmsed boxes,\nscores and classes are padded to be of length\nmax_size_per_class*num_classes, unless it exceeds max_total_size in\nwhich case it is clipped to max_total_size. Defaults to false.\nclip_boxes: If true, the coordinates of output nmsed boxes will be clipped\nto [0, 1]. If false, output the box coordinates as it is. Defaults to\ntrue.\nname: A name for the operation (optional)."}]}},
{"id": "tf.image.extract_glimpse", "type": "function", "code": "tf.image.extract_glimpse(input,size,offsets,centered=True,normalized=True,noise='uniform',name=None)", "summary": "Extracts a glimpse from the input tensor.", "description": "", "code-info": {"name": "tf.image.extract_glimpse", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. A 4-D float tensor of shape\n[batch_size, height, width, channels]."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32. A 1-D tensor of 2 elements containing the\nsize of the glimpses to extract.  The glimpse height must be specified\nfirst, following by the glimpse width."}, {"name": "offsets", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. A 2-D integer tensor of shape\n[batch_size, 2] containing the y, x locations of the center of each\nwindow."}, {"name": "centered", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. indicates if the offset\ncoordinates are centered relative to the image, in which case the (0, 0)\noffset is relative to the center of the input images. If false, the (0,0)\noffset corresponds to the upper left corner of the input images."}, {"name": "normalized", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. indicates if the offset\ncoordinates are normalized."}, {"name": "noise", "is_optional": true, "type": "string", "default_value": "'uniform'", "description": "An optional string. Defaults to uniform. indicates if the noise\nshould be uniform (uniform distribution), gaussian (gaussian\ndistribution), or zero (zero padding)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.draw_bounding_boxes", "type": "function", "code": "tf.image.draw_bounding_boxes(images,boxes,colors,name=None)", "summary": "Draw bounding boxes on a batch of images.", "description": "", "code-info": {"name": "tf.image.draw_bounding_boxes", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, half.\n4-D with shape [batch, height, width, depth]. A batch of images."}, {"name": "boxes", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 3-D with shape [batch,\nnum_bounding_boxes, 4] containing bounding boxes."}, {"name": "colors", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 2-D. A list of RGBA colors to cycle\nthrough for the boxes."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.image.adjust_saturation", "type": "function", "code": "tf.image.adjust_saturation(image,saturation_factor,name=None)", "summary": "Adjust saturation of RGB images.", "description": "", "code-info": {"name": "tf.image.adjust_saturation", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images. Size of the last dimension must be 3."}, {"name": "saturation_factor", "is_optional": false, "type": "float", "description": "float. Factor to multiply the saturation by."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.adjust_jpeg_quality", "type": "function", "code": "tf.image.adjust_jpeg_quality(image,jpeg_quality,name=None)", "summary": "Adjust jpeg encoding quality of an image.", "description": "", "code-info": {"name": "tf.image.adjust_jpeg_quality", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "3D image. Size of the last dimension must be None, 1 or 3."}, {"name": "jpeg_quality", "is_optional": false, "type": "tensor", "description": "Python int or Tensor of type int32. jpeg encoding quality."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.adjust_brightness", "type": "function", "code": "tf.image.adjust_brightness(image,delta)", "summary": "Adjust the brightness of RGB or Grayscale images.", "description": "", "code-info": {"name": "tf.image.adjust_brightness", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images to adjust."}, {"name": "delta", "is_optional": false, "type": "float", "description": "A scalar. Amount to add to the pixel values."}]}},
{"id": "tf.image.adjust_hue", "type": "function", "code": "tf.image.adjust_hue(image,delta,name=None)", "summary": "Adjust hue of RGB images.", "description": "", "code-info": {"name": "tf.image.adjust_hue", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images. Size of the last dimension must be 3."}, {"name": "delta", "is_optional": false, "type": "float", "description": "float.  How much to add to the hue channel."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.image.adjust_gamma", "type": "function", "code": "tf.image.adjust_gamma(image,gamma=1,gain=1)", "summary": "Performs Gamma Correction on the input image.", "description": "", "code-info": {"name": "tf.image.adjust_gamma", "parameters": [{"name": "image", "is_optional": false, "type": "others", "description": "RGB image or images to adjust."}, {"name": "gamma", "is_optional": true, "type": "int", "default_value": "1", "description": "A scalar or tensor. Non negative real number."}, {"name": "gain", "is_optional": true, "type": "int", "default_value": "1", "description": "A scalar or tensor. The constant multiplier."}]}},
{"id": "tf.graph_util.import_graph_def", "type": "function", "code": "tf.graph_util.import_graph_def(graph_def,input_map=None,return_elements=None,name=None,op_dict=None,producer_op_list=None)", "summary": "Imports the graph from graph_def into the current default Graph. (deprecated arguments)", "description": "", "code-info": {"name": "tf.graph_util.import_graph_def", "parameters": [{"name": "graph_def", "is_optional": false, "type": "others", "description": "A GraphDef proto containing operations to be imported into\nthe default graph."}, {"name": "input_map", "is_optional": true, "type": "string", "default_value": "None", "description": "A dictionary mapping input names (as strings) in graph_def\nto Tensor objects. The values of the named input tensors in the\nimported graph will be re-mapped to the respective Tensor values."}, {"name": "return_elements", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings containing operation names in\ngraph_def that will be returned as Operation objects; and/or\ntensor names in graph_def that will be returned as Tensor objects."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) A prefix that will be prepended to the names in\ngraph_def. Note that this does not apply to imported function names.\nDefaults to \"import\"."}, {"name": "op_dict", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Deprecated, do not use."}, {"name": "producer_op_list", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) An OpList proto with the (possibly stripped)\nlist of OpDefs used by the producer of the graph. If provided,\nunrecognized attrs for ops in graph_def that have their default value\naccording to producer_op_list will be removed. This will allow some more\nGraphDefs produced by later binaries to be accepted by earlier binaries."}]}},
{"id": "tf.image.adjust_contrast", "type": "function", "code": "tf.image.adjust_contrast(images,contrast_factor)", "summary": "Adjust contrast of RGB or grayscale images.", "description": "", "code-info": {"name": "tf.image.adjust_contrast", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": "Images to adjust.  At least 3-D."}, {"name": "contrast_factor", "is_optional": false, "type": "float", "description": "A float multiplier for adjusting contrast."}]}},
{"id": "tf.feature_column.weighted_categorical_column", "type": "function", "code": "tf.feature_column.weighted_categorical_column(categorical_column,weight_feature_key,dtype=tf.dtypes.float32)", "summary": "Applies weight values to a CategoricalColumn.", "description": "", "code-info": {"name": "tf.feature_column.weighted_categorical_column", "parameters": [{"name": "categorical_column", "is_optional": false, "type": "others", "description": "A CategoricalColumn created by\ncategorical_column_with_* functions."}, {"name": "weight_feature_key", "is_optional": false, "type": "string", "description": "String key for weight values."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "Type of weights, such as tf.float32. Only float and integer weights\nare supported."}]}},
{"id": "tf.feature_column.shared_embeddings", "type": "function", "code": "tf.feature_column.shared_embeddings(categorical_columns,dimension,combiner='mean',initializer=None,shared_embedding_collection_name=None,ckpt_to_load_from=None,tensor_name_in_ckpt=None,max_norm=None,trainable=True)", "summary": "List of dense columns that convert from sparse, categorical input.", "description": "", "code-info": {"name": "tf.feature_column.shared_embeddings", "parameters": [{"name": "categorical_columns", "is_optional": false, "type": "others", "description": "List of categorical columns created by a\ncategorical_column_with_* function. These columns produce the sparse IDs\nthat are inputs to the embedding lookup. All columns must be of the same\ntype and have the same arguments except key. E.g. they can be\ncategorical_column_with_vocabulary_file with the same vocabulary_file.\nSome or all columns could also be weighted_categorical_column."}, {"name": "dimension", "is_optional": false, "type": "int", "description": "An integer specifying dimension of the embedding, must be &gt; 0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to reduce if there are multiple entries\nin a single row. Currently 'mean', 'sqrtn' and 'sum' are supported, with\n'mean' the default. 'sqrtn' often achieves good accuracy, in particular\nwith bag-of-words columns. Each of this can be thought as example level\nnormalizations on the column. For more information, see\ntf.embedding_lookup_sparse."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "A variable initializer function to be used in embedding\nvariable initialization. If not specified, defaults to\ntruncated_normal_initializer with mean 0.0 and standard\ndeviation 1/sqrt(dimension)."}, {"name": "shared_embedding_collection_name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional collective name of these columns.\nIf not given, a reasonable name will be chosen based on the names of\ncategorical_columns."}, {"name": "ckpt_to_load_from", "is_optional": true, "type": "string", "default_value": "None", "description": "String representing checkpoint name/pattern from which to\nrestore column weights. Required if tensor_name_in_ckpt is not None."}, {"name": "tensor_name_in_ckpt", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Name of the Tensor in ckpt_to_load_from from\nwhich to restore the column weights. Required if ckpt_to_load_from is\nnot None."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is\nlarger than this value, before combining."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether or not the embedding is trainable. Default is True."}]}},
{"id": "tf.feature_column.sequence_numeric_column", "type": "function", "code": "tf.feature_column.sequence_numeric_column(key,shape=(1,),default_value=0.0,dtype=tf.dtypes.float32,normalizer_fn=None)", "summary": "Returns a feature column that represents sequences of numeric data.", "description": "", "code-info": {"name": "tf.feature_column.sequence_numeric_column", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input features."}, {"name": "shape", "is_optional": false, "type": "others", "description": "The shape of the input data per sequence id. E.g. if shape=(2,),\neach example must contain 2 * sequence_length values.\ndefault_value: A single value compatible with dtype that is used for\npadding the sparse data into a dense Tensor.\ndtype: The type of values.\nnormalizer_fn: If not None, a function that can be used to normalize the\nvalue of the tensor after default_value is applied for parsing.\nNormalizer function takes the input Tensor as its argument, and returns\nthe output Tensor. (e.g. lambda x: (x - 3.0) / 4.2). Please note that\neven though the most common use case of this function is normalization, it\ncan be used for any kind of Tensorflow transformations."}]}},
{"id": "tf.feature_column.sequence_categorical_column_with_vocabulary_list", "type": "function", "code": "tf.feature_column.sequence_categorical_column_with_vocabulary_list(key,vocabulary_list,dtype=None,default_value=-1,num_oov_buckets=0)", "summary": "A sequence of categorical terms where ids use an in-memory list.", "description": "", "code-info": {"name": "tf.feature_column.sequence_categorical_column_with_vocabulary_list", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature."}, {"name": "vocabulary_list", "is_optional": false, "type": "others", "description": "An ordered iterable defining the vocabulary. Each feature\nis mapped to the index of its value (if present) in vocabulary_list.\nMust be castable to dtype."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "None", "description": "The type of features. Only string and integer types are supported.\nIf None, it will be inferred from vocabulary_list."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "-1", "description": "The integer ID value to return for out-of-vocabulary feature\nvalues, defaults to -1. This can not be specified with a positive\nnum_oov_buckets."}, {"name": "num_oov_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "Non-negative integer, the number of out-of-vocabulary\nbuckets. All out-of-vocabulary inputs will be assigned IDs in the range\n[len(vocabulary_list), len(vocabulary_list)+num_oov_buckets) based on a\nhash of the input value. A positive num_oov_buckets can not be specified\nwith default_value."}]}},
{"id": "tf.feature_column.make_parse_example_spec", "type": "function", "code": "tf.feature_column.make_parse_example_spec(feature_columns)", "summary": "Creates parsing spec dictionary from input feature_columns.", "description": "", "code-info": {"name": "tf.feature_column.make_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from FeatureColumn."}]}},
{"id": "tf.feature_column.crossed_column", "type": "function", "code": "tf.feature_column.crossed_column(keys,hash_bucket_size,hash_key=None)", "summary": "Returns a column for performing crosses of categorical features.", "description": "", "code-info": {"name": "tf.feature_column.crossed_column", "parameters": [{"name": "keys", "is_optional": false, "type": "others", "description": "An iterable identifying the features to be crossed. Each element can\nbe either:\n\nstring: Will use the corresponding feature which must be of string type.\nCategoricalColumn: Will use the transformed tensor produced by this\ncolumn. Does not support hashed categorical column.\n"}, {"name": "hash_bucket_size", "is_optional": false, "type": "others", "description": "An int &gt; 1. The number of buckets."}, {"name": "hash_key", "is_optional": true, "type": "others", "default_value": "None", "description": "Specify the hash_key that will be used by the FingerprintCat64\nfunction to combine the crosses fingerprints on SparseCrossOp (optional)."}]}},
{"id": "tf.feature_column.numeric_column", "type": "function", "code": "tf.feature_column.numeric_column(key,shape=(1,),default_value=None,dtype=tf.dtypes.float32,normalizer_fn=None)", "summary": "Represents real valued or numerical features.", "description": "", "code-info": {"name": "tf.feature_column.numeric_column", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the\ncolumn name and the dictionary key for feature parsing configs, feature\nTensor objects, and feature columns."}, {"name": "shape", "is_optional": false, "type": "int", "description": "An iterable of integers specifies the shape of the Tensor. An\ninteger can be given which means a single dimension Tensor with given\nwidth. The Tensor representing the column will have the shape of\n[batch_size] + shape.\ndefault_value: A single value compatible with dtype or an iterable of\nvalues compatible with dtype which the column takes on during\ntf.Example parsing if data is missing. A default value of None will\ncause tf.io.parse_example to fail if an example does not contain this\ncolumn. If a single value is provided, the same value will be applied as\nthe default value for every item. If an iterable of values is provided,\nthe shape of the default_value should be equal to the given shape.\ndtype: defines the type of values. Default value is tf.float32. Must be a\nnon-quantized, real integer or floating point type.\nnormalizer_fn: If not None, a function that can be used to normalize the\nvalue of the tensor after default_value is applied for parsing.\nNormalizer function takes the input Tensor as its argument, and returns\nthe output Tensor. (e.g. lambda x: (x - 3.0) / 4.2). Please note that\neven though the most common use case of this function is normalization, it\ncan be used for any kind of Tensorflow transformations."}]}},
{"id": "tf.feature_column.indicator_column", "type": "function", "code": "tf.feature_column.indicator_column(categorical_column)", "summary": "Represents multi-hot representation of given categorical column.", "description": "", "code-info": {"name": "tf.feature_column.indicator_column", "parameters": [{"name": "categorical_column", "is_optional": false, "type": "others", "description": "A CategoricalColumn which is created by\ncategorical_column_with_* or crossed_column functions."}]}},
{"id": "tf.feature_column.sequence_categorical_column_with_identity", "type": "function", "code": "tf.feature_column.sequence_categorical_column_with_identity(key,num_buckets,default_value=None)", "summary": "Returns a feature column that represents sequences of integers.", "description": "", "code-info": {"name": "tf.feature_column.sequence_categorical_column_with_identity", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature."}, {"name": "num_buckets", "is_optional": false, "type": "string", "description": "Range of inputs. Namely, inputs are expected to be in the\nrange [0, num_buckets)."}, {"name": "default_value", "is_optional": true, "type": "others", "default_value": "None", "description": "If None, this column's graph operations will fail for\nout-of-range inputs. Otherwise, this value must be in the range\n[0, num_buckets), and will replace out-of-range inputs."}]}},
{"id": "tf.feature_column.embedding_column", "type": "function", "code": "tf.feature_column.embedding_column(categorical_column,dimension,combiner='mean',initializer=None,ckpt_to_load_from=None,tensor_name_in_ckpt=None,max_norm=None,trainable=True)", "summary": "DenseColumn that converts from sparse, categorical input.", "description": "", "code-info": {"name": "tf.feature_column.embedding_column", "parameters": [{"name": "categorical_column", "is_optional": false, "type": "others", "description": "A CategoricalColumn created by a\ncategorical_column_with_* function. This column produces the sparse IDs\nthat are inputs to the embedding lookup."}, {"name": "dimension", "is_optional": false, "type": "int", "description": "An integer specifying dimension of the embedding, must be &gt; 0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to reduce if there are multiple entries in\na single row. Currently 'mean', 'sqrtn' and 'sum' are supported, with\n'mean' the default. 'sqrtn' often achieves good accuracy, in particular\nwith bag-of-words columns. Each of this can be thought as example level\nnormalizations on the column. For more information, see\ntf.embedding_lookup_sparse."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "A variable initializer function to be used in embedding\nvariable initialization. If not specified, defaults to\ntruncated_normal_initializer with mean 0.0 and\nstandard deviation 1/sqrt(dimension)."}, {"name": "ckpt_to_load_from", "is_optional": true, "type": "string", "default_value": "None", "description": "String representing checkpoint name/pattern from which to\nrestore column weights. Required if tensor_name_in_ckpt is not None."}, {"name": "tensor_name_in_ckpt", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Name of the Tensor in ckpt_to_load_from from which\nto restore the column weights. Required if ckpt_to_load_from is not\nNone."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, embedding values are l2-normalized to this value."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether or not the embedding is trainable. Default is True."}]}},
{"id": "tf.feature_column.sequence_categorical_column_with_vocabulary_file", "type": "function", "code": "tf.feature_column.sequence_categorical_column_with_vocabulary_file(key,vocabulary_file,vocabulary_size=None,num_oov_buckets=0,default_value=None,dtype=tf.dtypes.string)", "summary": "A sequence of categorical terms where ids use a vocabulary file.", "description": "", "code-info": {"name": "tf.feature_column.sequence_categorical_column_with_vocabulary_file", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature."}, {"name": "vocabulary_file", "is_optional": false, "type": "string", "description": "The vocabulary file name."}, {"name": "vocabulary_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of the elements in the vocabulary. This must be no\ngreater than length of vocabulary_file, if less than length, later\nvalues are ignored. If None, it is set to the length of vocabulary_file."}, {"name": "num_oov_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "Non-negative integer, the number of out-of-vocabulary\nbuckets. All out-of-vocabulary inputs will be assigned IDs in the range\n[vocabulary_size, vocabulary_size+num_oov_buckets) based on a hash of\nthe input value. A positive num_oov_buckets can not be specified with\ndefault_value."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "None", "description": "The integer ID value to return for out-of-vocabulary feature\nvalues, defaults to -1. This can not be specified with a positive\nnum_oov_buckets."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.string", "description": "The type of features. Only string and integer types are supported."}]}},
{"id": "tf.feature_column.sequence_categorical_column_with_hash_bucket", "type": "function", "code": "tf.feature_column.sequence_categorical_column_with_hash_bucket(key,hash_bucket_size,dtype=tf.dtypes.string)", "summary": "A sequence of categorical terms where ids are set by hashing.", "description": "", "code-info": {"name": "tf.feature_column.sequence_categorical_column_with_hash_bucket", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature."}, {"name": "hash_bucket_size", "is_optional": false, "type": "others", "description": "An int &gt; 1. The number of buckets."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.string", "description": "The type of features. Only string and integer types are supported."}]}},
{"id": "tf.feature_column.categorical_column_with_identity", "type": "function", "code": "tf.feature_column.categorical_column_with_identity(key,num_buckets,default_value=None)", "summary": "A CategoricalColumn that returns identity values.", "description": "", "code-info": {"name": "tf.feature_column.categorical_column_with_identity", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the\ncolumn name and the dictionary key for feature parsing configs, feature\nTensor objects, and feature columns."}, {"name": "num_buckets", "is_optional": false, "type": "others", "description": "Range of inputs and outputs is [0, num_buckets)."}, {"name": "default_value", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, values outside of range [0, num_buckets) will\nbe replaced with this value. If not set, values &gt;= num_buckets will\ncause a failure while values &lt; 0 will be dropped."}]}},
{"id": "tf.feature_column.categorical_column_with_vocabulary_list", "type": "function", "code": "tf.feature_column.categorical_column_with_vocabulary_list(key,vocabulary_list,dtype=None,default_value=-1,num_oov_buckets=0)", "summary": "A CategoricalColumn with in-memory vocabulary.", "description": "", "code-info": {"name": "tf.feature_column.categorical_column_with_vocabulary_list", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the column\nname and the dictionary key for feature parsing configs, feature Tensor\nobjects, and feature columns."}, {"name": "vocabulary_list", "is_optional": false, "type": "others", "description": "An ordered iterable defining the vocabulary. Each feature\nis mapped to the index of its value (if present) in vocabulary_list.\nMust be castable to dtype."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "None", "description": "The type of features. Only string and integer types are supported. If\nNone, it will be inferred from vocabulary_list."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "-1", "description": "The integer ID value to return for out-of-vocabulary feature\nvalues, defaults to -1. This can not be specified with a positive\nnum_oov_buckets."}, {"name": "num_oov_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "Non-negative integer, the number of out-of-vocabulary\nbuckets. All out-of-vocabulary inputs will be assigned IDs in the range\n[len(vocabulary_list), len(vocabulary_list)+num_oov_buckets) based on a\nhash of the input value. A positive num_oov_buckets can not be specified\nwith default_value."}]}},
{"id": "tf.feature_column.categorical_column_with_vocabulary_file", "type": "function", "code": "tf.feature_column.categorical_column_with_vocabulary_file(key,vocabulary_file,vocabulary_size=None,dtype=tf.dtypes.string,default_value=None,num_oov_buckets=0)", "summary": "A CategoricalColumn with a vocabulary file.", "description": "", "code-info": {"name": "tf.feature_column.categorical_column_with_vocabulary_file", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the\ncolumn name and the dictionary key for feature parsing configs, feature\nTensor objects, and feature columns."}, {"name": "vocabulary_file", "is_optional": false, "type": "string", "description": "The vocabulary file name."}, {"name": "vocabulary_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of the elements in the vocabulary. This must be no\ngreater than length of vocabulary_file, if less than length, later\nvalues are ignored. If None, it is set to the length of vocabulary_file."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.string", "description": "The type of features. Only string and integer types are supported."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "None", "description": "The integer ID value to return for out-of-vocabulary feature\nvalues, defaults to -1. This can not be specified with a positive\nnum_oov_buckets."}, {"name": "num_oov_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "Non-negative integer, the number of out-of-vocabulary\nbuckets. All out-of-vocabulary inputs will be assigned IDs in the range\n[vocabulary_size, vocabulary_size+num_oov_buckets) based on a hash of\nthe input value. A positive num_oov_buckets can not be specified with\ndefault_value."}]}},
{"id": "tf.feature_column.categorical_column_with_hash_bucket", "type": "function", "code": "tf.feature_column.categorical_column_with_hash_bucket(key,hash_bucket_size,dtype=tf.dtypes.string)", "summary": "Represents sparse feature where ids are set by hashing.", "description": "", "code-info": {"name": "tf.feature_column.categorical_column_with_hash_bucket", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the\ncolumn name and the dictionary key for feature parsing configs, feature\nTensor objects, and feature columns."}, {"name": "hash_bucket_size", "is_optional": false, "type": "others", "description": "An int &gt; 1. The number of buckets."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.string", "description": "The type of features. Only string and integer types are supported."}]}},
{"id": "tf.experimental.tensorrt.Converter", "type": "function", "code": "tf.experimental.tensorrt.Converter(input_saved_model_dir=None,input_saved_model_tags=None,input_saved_model_signature_key=None,conversion_params=DEFAULT_TRT_CONVERSION_PARAMS)", "summary": "An offline converter for TF-TRT transformation for TF 2.0 SavedModels.", "description": "", "code-info": {"name": "tf.experimental.tensorrt.Converter", "parameters": [{"name": "input_saved_model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "the directory to load the SavedModel which contains\nthe input graph to transforms. Used only when input_graph_def is None."}, {"name": "input_saved_model_tags", "is_optional": true, "type": "others", "default_value": "None", "description": "list of tags to load the SavedModel."}, {"name": "input_saved_model_signature_key", "is_optional": true, "type": "others", "default_value": "None", "description": "the key of the signature to optimize the\ngraph for."}, {"name": "conversion_params", "is_optional": true, "type": "others", "default_value": "DEFAULT_TRT_CONVERSION_PARAMS", "description": "a TrtConversionParams instance."}]}},
{"id": "tf.feature_column.bucketized_column", "type": "function", "code": "tf.feature_column.bucketized_column(source_column,boundaries)", "summary": "Represents discretized dense input bucketed by boundaries.", "description": "", "code-info": {"name": "tf.feature_column.bucketized_column", "parameters": [{"name": "source_column", "is_optional": false, "type": "others", "description": "A one-dimensional dense column which is generated with\nnumeric_column."}, {"name": "boundaries", "is_optional": false, "type": "float", "description": "A sorted list or tuple of floats specifying the boundaries."}]}},
{"id": "tf.estimator.export.RegressionOutput", "type": "class", "code": "tf.estimator.export.RegressionOutput(value)", "summary": "Represents the output of a regression head.\n\nInherits From: ExportOutput", "description": "", "code-info": {"name": "tf.estimator.export.RegressionOutput", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "a float Tensor giving the predicted values.  Required."}]}},
{"id": "tf.estimator.export.build_raw_serving_input_receiver_fn", "type": "function", "code": "tf.estimator.export.build_raw_serving_input_receiver_fn(features,default_batch_size=None)", "summary": "Build a serving_input_receiver_fn expecting feature Tensors.", "description": "", "code-info": {"name": "tf.estimator.export.build_raw_serving_input_receiver_fn", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "a dict of string to Tensor."}, {"name": "default_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "the number of query examples expected per batch.\nLeave unset for variable batch size (recommended)."}]}},
{"id": "as_signature_def", "type": "function", "code": "as_signature_def(receiver_tensors)", "summary": "Represents an output of a model that can be served.", "description": "", "code-info": {"name": "as_signature_def", "parameters": [{"name": "receiver_tensors", "is_optional": false, "type": "tensor", "description": "a Tensor, or a dict of string to Tensor, specifying\ninput nodes that will be fed."}]}},
{"id": "tf.estimator.export.PredictOutput", "type": "class", "code": "tf.estimator.export.PredictOutput(outputs)", "summary": "Represents the output of a generic prediction head.\n\nInherits From: ExportOutput", "description": "", "code-info": {"name": "tf.estimator.export.PredictOutput", "parameters": [{"name": "outputs", "is_optional": false, "type": "tensor", "description": "A Tensor or a dict of string to Tensor representing the\npredictions."}]}},
{"id": "tf.estimator.experimental.stop_if_no_increase_hook", "type": "function", "code": "tf.estimator.experimental.stop_if_no_increase_hook(estimator,metric_name,max_steps_without_increase,eval_dir=None,min_steps=0,run_every_secs=60,run_every_steps=None)", "summary": "Creates hook to stop if metric does not increase within given max steps.", "description": "", "code-info": {"name": "tf.estimator.experimental.stop_if_no_increase_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance."}, {"name": "metric_name", "is_optional": false, "type": "string", "description": "str, metric to track. \"loss\", \"accuracy\", etc."}, {"name": "max_steps_without_increase", "is_optional": false, "type": "others", "description": "int, maximum number of training steps with no\nincrease in the given metric."}, {"name": "eval_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, directory containing summary files with eval metrics. By\ndefault, estimator.eval_dir() will be used."}, {"name": "min_steps", "is_optional": true, "type": "int", "default_value": "0", "description": "int, stop is never requested if global step is less than this\nvalue. Defaults to 0."}, {"name": "run_every_secs", "is_optional": true, "type": "int", "default_value": "60", "description": "If specified, calls should_stop_fn at an interval of\nrun_every_secs seconds. Defaults to 60 seconds. Either this or\nrun_every_steps must be set."}, {"name": "run_every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "If specified, calls should_stop_fn every\nrun_every_steps steps. Either this or run_every_secs must be set."}]}},
{"id": "tf.estimator.export.ClassificationOutput", "type": "class", "code": "tf.estimator.export.ClassificationOutput(scores=None,classes=None)", "summary": "Represents the output of a classification head.\n\nInherits From: ExportOutput", "description": "", "code-info": {"name": "tf.estimator.export.ClassificationOutput", "parameters": [{"name": "scores", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A float Tensor giving scores (sometimes but not always\ninterpretable as probabilities) for each class.  May be None, but\nonly if classes is set.  Interpretation varies-- see class doc."}, {"name": "classes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A string Tensor giving predicted class labels.  May be None,\nbut only if scores is set.  Interpretation varies-- see class doc."}]}},
{"id": "tf.estimator.export.build_parsing_serving_input_receiver_fn", "type": "function", "code": "tf.estimator.export.build_parsing_serving_input_receiver_fn(feature_spec,default_batch_size=None)", "summary": "Build a serving_input_receiver_fn expecting fed tf.Examples.", "description": "", "code-info": {"name": "tf.estimator.export.build_parsing_serving_input_receiver_fn", "parameters": [{"name": "feature_spec", "is_optional": false, "type": "string", "description": "a dict of string to VarLenFeature/FixedLenFeature."}, {"name": "default_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "the number of query examples expected per batch.\nLeave unset for variable batch size (recommended)."}]}},
{"id": "tf.estimator.experimental.stop_if_no_decrease_hook", "type": "function", "code": "tf.estimator.experimental.stop_if_no_decrease_hook(estimator,metric_name,max_steps_without_decrease,eval_dir=None,min_steps=0,run_every_secs=60,run_every_steps=None)", "summary": "Creates hook to stop if metric does not decrease within given max steps.", "description": "", "code-info": {"name": "tf.estimator.experimental.stop_if_no_decrease_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance."}, {"name": "metric_name", "is_optional": false, "type": "string", "description": "str, metric to track. \"loss\", \"accuracy\", etc."}, {"name": "max_steps_without_decrease", "is_optional": false, "type": "others", "description": "int, maximum number of training steps with no\ndecrease in the given metric."}, {"name": "eval_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, directory containing summary files with eval metrics. By\ndefault, estimator.eval_dir() will be used."}, {"name": "min_steps", "is_optional": true, "type": "int", "default_value": "0", "description": "int, stop is never requested if global step is less than this\nvalue. Defaults to 0."}, {"name": "run_every_secs", "is_optional": true, "type": "int", "default_value": "60", "description": "If specified, calls should_stop_fn at an interval of\nrun_every_secs seconds. Defaults to 60 seconds. Either this or\nrun_every_steps must be set."}, {"name": "run_every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "If specified, calls should_stop_fn every\nrun_every_steps steps. Either this or run_every_secs must be set."}]}},
{"id": "tf.estimator.experimental.LinearSDCA", "type": "function", "code": "tf.estimator.experimental.LinearSDCA(example_id_column,num_loss_partitions=1,num_table_shards=None,symmetric_l1_regularization=0.0,symmetric_l2_regularization=1.0,adaptive=False)", "summary": "Stochastic Dual Coordinate Ascent helper for linear estimators.", "description": "", "code-info": {"name": "tf.estimator.experimental.LinearSDCA", "parameters": [{"name": "example_id_column", "is_optional": false, "type": "string", "description": "The column name containing the example ids."}, {"name": "num_loss_partitions", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of workers."}, {"name": "num_table_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of shards of the internal state table, typically\nset to match the number of parameter servers."}, {"name": "symmetric_l1_regularization", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "symmetric_l2_regularization", "is_optional": true, "type": "float", "default_value": "1.0", "description": "A float value, must be greater than zero and\nshould typically be greater than 1."}, {"name": "adaptive", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean indicating whether to use adaptive sampling."}]}},
{"id": "tf.estimator.experimental.RNNClassifier", "type": "class", "code": "tf.estimator.experimental.RNNClassifier(sequence_feature_columns,context_feature_columns=None,units=None,cell_type=USE_DEFAULT,rnn_cell_fn=None,return_sequences=False,model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Adagrad',loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,sequence_mask='sequence_mask',config=None)", "summary": "A classifier for TensorFlow RNN models.\n\nInherits From: RNNEstimator", "description": "", "code-info": {"name": "tf.estimator.experimental.RNNClassifier", "parameters": [{"name": "sequence_feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns\nthat represent sequential input. All items in the set should either be\nsequence columns (e.g. sequence_numeric_column) or constructed from\none (e.g. embedding_column with sequence_categorical_column_* as\ninput)."}, {"name": "context_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing the FeatureColumns\nfor contextual input. The data represented by these columns will be\nreplicated and given to the RNN at each timestep. These columns must be\ninstances of classes derived from DenseColumn such as\nnumeric_column, not the sequential variants."}, {"name": "units", "is_optional": true, "type": "int", "default_value": "None", "description": "Iterable of integer number of hidden units per RNN layer. If\nset, cell_type must also be specified and rnn_cell_fn must be\nNone."}, {"name": "cell_type", "is_optional": true, "type": "string", "default_value": "USE_DEFAULT", "description": "A class producing a RNN cell or a string specifying the cell\ntype. Supported strings are: 'simple_rnn', 'lstm', and 'gru'. If\nset, units must also be specified and rnn_cell_fn must be None."}, {"name": "rnn_cell_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A function that returns a RNN cell instance that will be used\nto construct the RNN. If set, units and cell_type cannot be set.\nThis is for advanced users who need additional customization beyond\nunits and cell_type. Note that tf.keras.layers.StackedRNNCells is\nneeded for stacked RNNs."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean indicating whether to return the last output\nin the output sequence, or the full sequence. Note that if True,\nweight_column must be None or a string."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": "Number of label classes. Defaults to 2, namely binary\nclassification. Must be &gt; 1."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key, then\nweight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If\ngiven, labels must be string type and have any value in\nlabel_vocabulary. If it is not given, that means labels are\nalready encoded as integer or float within [0, 1] for n_classes=2 and\nencoded as integer values in {0, 1,..., n_classes-1} for n_classes&gt;2 .\nAlso there will be errors if vocabulary is not provided and labels are\nstring."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.Optimizer or string specifying optimizer\ntype. Defaults to Adagrad optimizer."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "sequence_mask", "is_optional": true, "type": "string", "default_value": "'sequence_mask'", "description": "A string with the name of the sequence mask tensor. If\nsequence_mask is in the features dictionary, the provided tensor is\nused, otherwise the sequence mask is computed from the length of\nsequential features. The sequence mask is used in evaluation and\ntraining mode to aggregate loss and metrics computation while excluding\npadding steps. It is also added to the predictions dictionary in\nprediction mode to indicate which steps are padding."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}]}},
{"id": "tf.estimator.experimental.RNNEstimator", "type": "class", "code": "tf.estimator.experimental.RNNEstimator(head,sequence_feature_columns,context_feature_columns=None,units=None,cell_type=USE_DEFAULT,rnn_cell_fn=None,return_sequences=False,model_dir=None,optimizer='Adagrad',config=None)", "summary": "An Estimator for TensorFlow RNN models with user-specified head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.experimental.RNNEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "others", "description": "A Head instance. This specifies the model's output and loss\nfunction to be optimized."}, {"name": "sequence_feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns\nthat represent sequential input. All items in the set should either be\nsequence columns (e.g. sequence_numeric_column) or constructed from\none (e.g. embedding_column with sequence_categorical_column_* as\ninput)."}, {"name": "context_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing the FeatureColumns\nfor contextual input. The data represented by these columns will be\nreplicated and given to the RNN at each timestep. These columns must be\ninstances of classes derived from DenseColumn such as\nnumeric_column, not the sequential variants."}, {"name": "units", "is_optional": true, "type": "int", "default_value": "None", "description": "Iterable of integer number of hidden units per RNN layer. If\nset, cell_type must also be specified and rnn_cell_fn must be\nNone."}, {"name": "cell_type", "is_optional": true, "type": "string", "default_value": "USE_DEFAULT", "description": "A class producing a RNN cell or a string specifying the cell\ntype. Supported strings are: 'simple_rnn', 'lstm', and 'gru'. If\nset, units must also be specified and rnn_cell_fn must be None."}, {"name": "rnn_cell_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A function that returns a RNN cell instance that will be used\nto construct the RNN. If set, units and cell_type cannot be set.\nThis is for advanced users who need additional customization beyond\nunits and cell_type. Note that tf.keras.layers.StackedRNNCells is\nneeded for stacked RNNs."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean indicating whether to return the last output\nin the output sequence, or the full sequence."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.Optimizer or string specifying optimizer\ntype. Defaults to Adagrad optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}]}},
{"id": "tf.estimator.experimental.stop_if_higher_hook", "type": "function", "code": "tf.estimator.experimental.stop_if_higher_hook(estimator,metric_name,threshold,eval_dir=None,min_steps=0,run_every_secs=60,run_every_steps=None)", "summary": "Creates hook to stop if the given metric is higher than the threshold.", "description": "", "code-info": {"name": "tf.estimator.experimental.stop_if_higher_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance."}, {"name": "metric_name", "is_optional": false, "type": "string", "description": "str, metric to track. \"loss\", \"accuracy\", etc."}, {"name": "threshold", "is_optional": false, "type": "others", "description": "Numeric threshold for the given metric."}, {"name": "eval_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, directory containing summary files with eval metrics. By\ndefault, estimator.eval_dir() will be used."}, {"name": "min_steps", "is_optional": true, "type": "int", "default_value": "0", "description": "int, stop is never requested if global step is less than this\nvalue. Defaults to 0."}, {"name": "run_every_secs", "is_optional": true, "type": "int", "default_value": "60", "description": "If specified, calls should_stop_fn at an interval of\nrun_every_secs seconds. Defaults to 60 seconds. Either this or\nrun_every_steps must be set."}, {"name": "run_every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "If specified, calls should_stop_fn every\nrun_every_steps steps. Either this or run_every_secs must be set."}]}},
{"id": "tf.estimator.experimental.make_stop_at_checkpoint_step_hook", "type": "function", "code": "tf.estimator.experimental.make_stop_at_checkpoint_step_hook(estimator,last_step,wait_after_file_check_secs=30)", "summary": "Creates a proper StopAtCheckpointStepHook based on chief status.", "description": "", "code-info": {"name": "tf.estimator.experimental.make_stop_at_checkpoint_step_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": ""}, {"name": "last_step", "is_optional": false, "type": "others", "description": ""}, {"name": "wait_after_file_check_secs", "is_optional": true, "type": "int", "default_value": "30", "description": ""}]}},
{"id": "tf.estimator.experimental.stop_if_lower_hook", "type": "function", "code": "tf.estimator.experimental.stop_if_lower_hook(estimator,metric_name,threshold,eval_dir=None,min_steps=0,run_every_secs=60,run_every_steps=None)", "summary": "Creates hook to stop if the given metric is lower than the threshold.", "description": "", "code-info": {"name": "tf.estimator.experimental.stop_if_lower_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance."}, {"name": "metric_name", "is_optional": false, "type": "string", "description": "str, metric to track. \"loss\", \"accuracy\", etc."}, {"name": "threshold", "is_optional": false, "type": "others", "description": "Numeric threshold for the given metric."}, {"name": "eval_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, directory containing summary files with eval metrics. By\ndefault, estimator.eval_dir() will be used."}, {"name": "min_steps", "is_optional": true, "type": "int", "default_value": "0", "description": "int, stop is never requested if global step is less than this\nvalue. Defaults to 0."}, {"name": "run_every_secs", "is_optional": true, "type": "int", "default_value": "60", "description": "If specified, calls should_stop_fn at an interval of\nrun_every_secs seconds. Defaults to 60 seconds. Either this or\nrun_every_steps must be set."}, {"name": "run_every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "If specified, calls should_stop_fn every\nrun_every_steps steps. Either this or run_every_secs must be set."}]}},
{"id": "tf.estimator.experimental.make_early_stopping_hook", "type": "function", "code": "tf.estimator.experimental.make_early_stopping_hook(estimator,should_stop_fn,run_every_secs=60,run_every_steps=None)", "summary": "Creates early-stopping hook.", "description": "", "code-info": {"name": "tf.estimator.experimental.make_early_stopping_hook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance."}, {"name": "should_stop_fn", "is_optional": false, "type": "others", "description": "callable, function that takes no arguments and returns a\nbool. If the function returns True, stopping will be initiated by the\nchief."}, {"name": "run_every_secs", "is_optional": true, "type": "int", "default_value": "60", "description": "If specified, calls should_stop_fn at an interval of\nrun_every_secs seconds. Defaults to 60 seconds. Either this or\nrun_every_steps must be set."}, {"name": "run_every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "If specified, calls should_stop_fn every\nrun_every_steps steps. Either this or run_every_secs must be set."}]}},
{"id": "tf.estimator.experimental.InMemoryEvaluatorHook", "type": "function", "code": "tf.estimator.experimental.InMemoryEvaluatorHook(estimator,input_fn,steps=None,hooks=None,name=None,every_n_iter=100)", "summary": "Hook to run evaluation in training without a checkpoint.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.experimental.InMemoryEvaluatorHook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator instance to call evaluate."}, {"name": "input_fn", "is_optional": false, "type": "others", "description": " Equivalent to the input_fn arg to estimator.evaluate. A\nfunction that constructs the input data for evaluation.\nSee Creating input functions\nfor more information. The function should construct and return one of\nthe following:\n\n\nA 'tf.data.Dataset' object: Outputs of Dataset object must be a\ntuple (features, labels) with same constraints as below.\nA tuple (features, labels): Where features is a Tensor or a\ndictionary of string feature name to Tensor and labels is a\nTensor or a dictionary of string label name to Tensor. Both\nfeatures and labels are consumed by model_fn. They should\nsatisfy the expectation of model_fn from inputs.\n"}, {"name": "steps", "is_optional": true, "type": "others", "default_value": "None", "description": "Equivalent to the steps arg to estimator.evaluate.  Number of\nsteps for which to evaluate model. If None, evaluates until input_fn\nraises an end-of-input exception."}, {"name": "hooks", "is_optional": true, "type": "others", "default_value": "None", "description": "Equivalent to the hooks arg to estimator.evaluate. List of\nSessionRunHook subclass instances. Used for callbacks inside the\nevaluation call."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " Equivalent to the name arg to estimator.evaluate. Name of the\nevaluation if user needs to run multiple evaluations on different data\nsets, such as on training data vs test data. Metrics for different\nevaluations are saved in separate folders, and appear separately in\ntensorboard."}, {"name": "every_n_iter", "is_optional": true, "type": "int", "default_value": "100", "description": "int, runs the evaluator once every N training iteration."}]}},
{"id": "tf.estimator.experimental.call_logit_fn", "type": "function", "code": "tf.estimator.experimental.call_logit_fn(logit_fn,features,mode,params,config)", "summary": "Calls logit_fn (experimental).", "description": "", "code-info": {"name": "tf.estimator.experimental.call_logit_fn", "parameters": [{"name": "logit_fn", "is_optional": false, "type": "others", "description": "A logit_fn as defined above."}, {"name": "features", "is_optional": false, "type": "others", "description": "The features dict."}, {"name": "mode", "is_optional": false, "type": "others", "description": "TRAIN / EVAL / PREDICT ModeKeys."}, {"name": "params", "is_optional": false, "type": "others", "description": "The hyperparameter dict."}, {"name": "config", "is_optional": false, "type": "others", "description": "The configuration object."}]}},
{"id": "tf.estimator.experimental.build_raw_supervised_input_receiver_fn", "type": "function", "code": "tf.estimator.experimental.build_raw_supervised_input_receiver_fn(features,labels,default_batch_size=None)", "summary": "Build a supervised_input_receiver_fn for raw features and labels.", "description": "", "code-info": {"name": "tf.estimator.experimental.build_raw_supervised_input_receiver_fn", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "a dict of string to Tensor or Tensor."}, {"name": "labels", "is_optional": false, "type": "tensor", "description": "a dict of string to Tensor or Tensor."}, {"name": "default_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "the number of query examples expected per batch.\nLeave unset for variable batch size (recommended)."}]}},
{"id": "tf.estimator.train_and_evaluate", "type": "function", "code": "tf.estimator.train_and_evaluate(estimator,train_spec,eval_spec)", "summary": "Train and evaluate the estimator.", "description": "", "code-info": {"name": "tf.estimator.train_and_evaluate", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "An Estimator instance to train and evaluate."}, {"name": "train_spec", "is_optional": false, "type": "others", "description": "A TrainSpec instance to specify the training specification."}, {"name": "eval_spec", "is_optional": false, "type": "others", "description": "A EvalSpec instance to specify the evaluation and export\nspecification."}]}},
{"id": "tf.estimator.SummarySaverHook", "type": "function", "code": "tf.estimator.SummarySaverHook(save_steps=None,save_secs=None,output_dir=None,summary_writer=None,scaffold=None,summary_op=None)", "summary": "Saves summaries every N steps.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.SummarySaverHook", "parameters": [{"name": "save_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "int, save summaries every N steps. Exactly one of\nsave_secs and save_steps should be set."}, {"name": "save_secs", "is_optional": true, "type": "others", "default_value": "None", "description": "int, save summaries every N seconds."}, {"name": "output_dir", "is_optional": true, "type": "string", "default_value": "None", "description": "string, the directory to save the summaries to. Only used if\nno summary_writer is supplied."}, {"name": "summary_writer", "is_optional": true, "type": "others", "default_value": "None", "description": "SummaryWriter. If None and an output_dir was passed,\none will be created accordingly."}, {"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "Scaffold to get summary_op if it's not provided."}, {"name": "summary_op", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor of type string containing the serialized Summary\nprotocol buffer or a list of Tensor. They are most likely an output by\nTF summary methods like tf.compat.v1.summary.scalar or\ntf.compat.v1.summary.merge_all. It can be passed in as one tensor; if\nmore than one, they must be passed in as a list."}]}},
{"id": "tf.estimator.StepCounterHook", "type": "function", "code": "tf.estimator.StepCounterHook(every_n_steps=100,every_n_secs=None,output_dir=None,summary_writer=None)", "summary": "Hook that counts steps per second.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.StepCounterHook", "parameters": [{"name": "every_n_steps", "is_optional": true, "type": "int", "default_value": "100", "description": ""}, {"name": "every_n_secs", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "output_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "summary_writer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "after_create_session", "type": "function", "code": "after_create_session(session,coord)", "summary": "Hook to extend calls to MonitoredSession.run().", "description": "", "code-info": {"name": "after_create_session", "parameters": [{"name": "session", "is_optional": false, "type": "tensor", "description": "A TensorFlow Session that has been created."}, {"name": "coord", "is_optional": false, "type": "others", "description": "A Coordinator object which keeps track of all threads."}]}},
{"id": "tf.estimator.RunConfig", "type": "class", "code": "tf.estimator.RunConfig(model_dir=None,tf_random_seed=None,save_summary_steps=100,save_checkpoints_steps=_USE_DEFAULT,save_checkpoints_secs=_USE_DEFAULT,session_config=None,keep_checkpoint_max=5,keep_checkpoint_every_n_hours=10000,log_step_count_steps=100,train_distribute=None,device_fn=None,protocol=None,eval_distribute=None,experimental_distribute=None,experimental_max_worker_delay_secs=None,session_creation_timeout_secs=7200)", "summary": "This class specifies the configurations for an Estimator run.", "description": "", "code-info": {"name": "tf.estimator.RunConfig", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "directory where model parameters, graph, etc are saved. If\nPathLike object, the path will be resolved. If None, will use a\ndefault value set by the Estimator."}, {"name": "tf_random_seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Random seed for TensorFlow initializers.\nSetting this value allows consistency between reruns."}, {"name": "save_summary_steps", "is_optional": true, "type": "int", "default_value": "100", "description": "Save summaries every this many steps."}, {"name": "save_checkpoints_steps", "is_optional": true, "type": "others", "default_value": "_USE_DEFAULT", "description": "Save checkpoints every this many steps. Can not be\nspecified with save_checkpoints_secs."}, {"name": "save_checkpoints_secs", "is_optional": true, "type": "others", "default_value": "_USE_DEFAULT", "description": "Save checkpoints every this many seconds. Can not\nbe specified with save_checkpoints_steps. Defaults to 600 seconds if\nboth save_checkpoints_steps and save_checkpoints_secs are not set\nin constructor.  If both save_checkpoints_steps and\nsave_checkpoints_secs are None, then checkpoints are disabled."}, {"name": "session_config", "is_optional": true, "type": "others", "default_value": "None", "description": "a ConfigProto used to set session parameters, or None."}, {"name": "keep_checkpoint_max", "is_optional": true, "type": "int", "default_value": "5", "description": "The maximum number of recent checkpoint files to\nkeep. As new files are created, older files are deleted. If None or 0,\nall checkpoint files are kept. Defaults to 5 (that is, the 5 most recent\ncheckpoint files are kept.)"}, {"name": "keep_checkpoint_every_n_hours", "is_optional": true, "type": "int", "default_value": "10000", "description": "Number of hours between each checkpoint\nto be saved. The default value of 10,000 hours effectively disables\nthe feature."}, {"name": "log_step_count_steps", "is_optional": true, "type": "int", "default_value": "100", "description": "The frequency, in number of global steps, that the\nglobal step and the loss will be logged during training.  Also controls\nthe frequency that the global steps / s will be logged (and written to\nsummary) during training."}, {"name": "train_distribute", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional instance of tf.distribute.Strategy.\nIf specified, then Estimator will distribute the user's model during\ntraining, according to the policy specified by that strategy. Setting\nexperimental_distribute.train_distribute is preferred."}, {"name": "device_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A callable invoked for every Operation that takes the\nOperation and returns the device string. If None, defaults to\nthe device function returned by tf.train.replica_device_setter\nwith round-robin strategy."}, {"name": "protocol", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional argument which specifies the protocol used when\nstarting server. None means default to grpc."}, {"name": "eval_distribute", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional instance of tf.distribute.Strategy.\nIf specified, then Estimator will distribute the user's model during\nevaluation, according to the policy specified by that strategy.\nSetting experimental_distribute.eval_distribute is preferred."}, {"name": "experimental_distribute", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional\ntf.contrib.distribute.DistributeConfig object specifying\nDistributionStrategy-related configuration. The train_distribute and\neval_distribute can be passed as parameters to RunConfig or set in\nexperimental_distribute but not both."}, {"name": "experimental_max_worker_delay_secs", "is_optional": true, "type": "int", "default_value": "None", "description": "An optional integer\nspecifying the maximum time a worker should wait before starting.\nBy default, workers are started at staggered times, with each worker\nbeing delayed by up to 60 seconds. This is intended to reduce the risk\nof divergence, which can occur when many workers simultaneously update\nthe weights of a randomly initialized model. Users who warm-start their\nmodels and train them for short durations (a few minutes or less) should\nconsider reducing this default to improve training times."}, {"name": "session_creation_timeout_secs", "is_optional": true, "type": "int", "default_value": "7200", "description": "Max time workers should wait for a session\nto become available (on initialization or when recovering a session)\nwith MonitoredTrainingSession. Defaults to 7200 seconds, but users may\nwant to set a lower value to detect problems with variable / session\n(re)-initialization more quickly."}]}},
{"id": "tf.estimator.SessionRunContext", "type": "function", "code": "tf.estimator.SessionRunContext(original_args,session)", "summary": "Provides information about the session.run() call being made.", "description": "", "code-info": {"name": "tf.estimator.SessionRunContext", "parameters": [{"name": "original_args", "is_optional": false, "type": "others", "description": "  A SessionRunArgs object holding the original arguments of run().\n\nIf user called MonitoredSession.run(fetches=a, feed_dict=b), then this\nfield is equal to SessionRunArgs(a, b)."}, {"name": "session", "is_optional": false, "type": "tensor", "description": "  A TensorFlow session object which will execute the run.\nstop_requested:   Returns whether a stop is requested or not."}]}},
{"id": "tf.estimator.StopAtStepHook", "type": "function", "code": "tf.estimator.StopAtStepHook(num_steps=None,last_step=None)", "summary": "Hook that requests stop at a specified step.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.StopAtStepHook", "parameters": [{"name": "num_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of steps to execute."}, {"name": "last_step", "is_optional": true, "type": "others", "default_value": "None", "description": "Step after which to stop."}]}},
{"id": "tf.estimator.regressor_parse_example_spec", "type": "function", "code": "tf.estimator.regressor_parse_example_spec(feature_columns,label_key,label_dtype=tf.dtypes.float32,label_default=None,label_dimension=1,weight_column=None)", "summary": "Generates parsing spec for tf.parse_example to be used with regressors.", "description": "", "code-info": {"name": "tf.estimator.regressor_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from _FeatureColumn."}, {"name": "label_key", "is_optional": false, "type": "string", "description": "A string identifying the label. It means tf.Example stores labels\nwith this key."}, {"name": "label_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "A tf.dtype identifies the type of labels. By default it is\ntf.float32."}, {"name": "label_default", "is_optional": true, "type": "others", "default_value": "None", "description": "used as label if label_key does not exist in given\ntf.Example. By default default_value is none, which means\ntf.parse_example will error out if there is any missing label."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}]}},
{"id": "tf.estimator.SecondOrStepTimer", "type": "function", "code": "tf.estimator.SecondOrStepTimer(every_secs=None,every_steps=None)", "summary": "Timer that triggers at most once every N seconds or once every N steps.", "description": "", "code-info": {"name": "tf.estimator.SecondOrStepTimer", "parameters": [{"name": "every_secs", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "every_steps", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.estimator.ProfilerHook", "type": "function", "code": "tf.estimator.ProfilerHook(save_steps=None,save_secs=None,output_dir='',show_dataflow=True,show_memory=False)", "summary": "Captures CPU/GPU profiling information every N steps or seconds.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.ProfilerHook", "parameters": [{"name": "save_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "int, save profile traces every N steps. Exactly one of\nsave_secs and save_steps should be set."}, {"name": "save_secs", "is_optional": true, "type": "float", "default_value": "None", "description": "int or float, save profile traces every N seconds."}, {"name": "output_dir", "is_optional": true, "type": "string", "default_value": "''", "description": "string, the directory to save the profile traces to.\nDefaults to the current directory."}, {"name": "show_dataflow", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, if True, add flow events to the trace connecting\nproducers and consumers of tensors."}, {"name": "show_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, if True, add object snapshot events to the trace\nshowing the sizes and lifetimes of tensors."}]}},
{"id": "tf.estimator.RegressionHead", "type": "class", "code": "tf.estimator.RegressionHead(label_dimension=1,weight_column=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,loss_fn=None,inverse_link_fn=None,name=None)", "summary": "Creates a Head for regression using the mean_squared_error loss.\n\nInherits From: Head", "description": "", "code-info": {"name": "tf.estimator.RegressionHead", "parameters": [{"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression labels per example. This is the size\nof the last dimension of the labels Tensor (typically, this has shape\n[batch_size, label_dimension]).\nloss_reduction: One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch and label dimension. Defaults to\nSUM_OVER_BATCH_SIZE, namely weighted sum of losses divided by\nbatch size * label_dimension.\nloss_fn: Optional loss function. Defaults to mean_squared_error.\ninverse_link_fn: Optional inverse link function, also known as 'mean\nfunction'. Defaults to identity.\nname: name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops.\n\n\nAttributes:\n\n\nlogits_dimension:   See base_head.Head for details.\nloss_reduction:   See base_head.Head for details.\nname:   See base_head.Head for details.\n\n\nMethods\n\ncreate_estimator_spec\n\nView source\ncreate_estimator_spec(\n    features, mode, logits, labels=None, optimizer=None, trainable_variables=None,\n    train_op_fn=None, update_ops=None, regularization_losses=None\n)\n\nReturns EstimatorSpec that a model_fn can return.\n\nIt is recommended to pass all args via name.\n\nArgs:\n\n\nfeatures: Input dict mapping string feature names to Tensor or\nSparseTensor objects containing the values for that feature in a\nminibatch. Often to be used to fetch example-weight tensor.\nmode: Estimator's ModeKeys.\nlogits: Logits Tensor to be used by the head.\nlabels: Labels Tensor, or dict mapping string label names to Tensor\nobjects of the label values.\noptimizer: An tf.keras.optimizers.Optimizer instance to optimize the\nloss in TRAIN mode. Namely, sets train_op = optimizer.get_updates(loss,\ntrainable_variables), which updates variables to minimize loss.\ntrainable_variables: A list or tuple of Variable objects to update to\nminimize loss. In Tensorflow 1.x, by default these are the list of\nvariables collected in the graph under the key\nGraphKeys.TRAINABLE_VARIABLES. As Tensorflow 2.x doesn't have\ncollections and GraphKeys, trainable_variables need to be passed\nexplicitly here.\ntrain_op_fn: Function that takes a scalar loss Tensor and returns an op\nto optimize the model with the loss in TRAIN mode. Used if optimizer\nis None. Exactly one of train_op_fn and optimizer must be set in\nTRAIN mode. By default, it is None in other modes. If you want to\noptimize loss yourself, you can pass lambda _: tf.no_op() and then use\nEstimatorSpec.loss to compute and apply gradients.\nupdate_ops: A list or tuple of update ops to be run at training time. For\nexample, layers such as BatchNormalization create mean and variance\nupdate ops that need to be run at training time. In Tensorflow 1.x,\nthese are thrown into an UPDATE_OPS collection. As Tensorflow 2.x\ndoesn't have collections, update_ops need to be passed explicitly here.\nregularization_losses: A list of additional scalar losses to be added to\nthe training loss, such as regularization losses.\n\n\nReturns:\n\nEstimatorSpec.\n\nloss\n\nView source\nloss(\n    labels, logits, features=None, mode=None, regularization_losses=None\n)\n\nReturn predictions based on keys. See base_head.Head for details.\n\nmetrics\n\nView source\nmetrics(\n    regularization_losses=None\n)\n\nCreates metrics. See base_head.Head for details.\n\npredictions\n\nView source\npredictions(\n    logits\n)\n\nReturn predictions based on keys.  See base_head.Head for details.\n\nArgs:\n\n\nlogits: logits Tensor with shape [D0, D1, ... DN, logits_dimension].\nFor many applications, the shape is [batch_size, logits_dimension].\n\n\nReturns:\n\nA dict of predictions.\n\nupdate_metrics\n\nView source\nupdate_metrics(\n    eval_metrics, features, logits, labels, regularization_losses=None\n)\n\nUpdates eval metrics. See base_head.Head for details.\n\n          "}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example.\nlabel_dimension: Number of regression labels per example. This is the size\nof the last dimension of the labels Tensor (typically, this has shape\n[batch_size, label_dimension])."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch and label dimension. Defaults to\nSUM_OVER_BATCH_SIZE, namely weighted sum of losses divided by\nbatch size * label_dimension."}, {"name": "loss_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional loss function. Defaults to mean_squared_error."}, {"name": "inverse_link_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional inverse link function, also known as 'mean\nfunction'. Defaults to identity."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.NanTensorHook", "type": "function", "code": "tf.estimator.NanTensorHook(loss_tensor,fail_on_nan_loss=True)", "summary": "Monitors the loss tensor and stops training if loss is NaN.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.NanTensorHook", "parameters": [{"name": "loss_tensor", "is_optional": false, "type": "tensor", "description": "Tensor, the loss tensor."}, {"name": "fail_on_nan_loss", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, whether to raise exception when loss is NaN."}]}},
{"id": "tf.estimator.NanLossDuringTrainingError", "type": "function", "code": "tf.estimator.NanLossDuringTrainingError(*args,**kwargs)", "summary": "Unspecified run-time error.", "description": "", "code-info": {"name": "tf.estimator.NanLossDuringTrainingError", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.estimator.MultiLabelHead", "type": "class", "code": "tf.estimator.MultiLabelHead(n_classes,weight_column=None,thresholds=None,label_vocabulary=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,loss_fn=None,classes_for_class_based_metrics=None,name=None)", "summary": "Creates a Head for multi-label classification.\n\nInherits From: Head", "description": "", "code-info": {"name": "tf.estimator.MultiLabelHead", "parameters": [{"name": "n_classes", "is_optional": false, "type": "others", "description": "Number of classes, must be greater than 1 (for 1 class, use\nBinaryClassHead)."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example.  Per-class weighting is\nnot supported."}, {"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "Iterable of floats in the range (0, 1). Accuracy, precision\nand recall metrics are evaluated for each threshold value. The threshold\nis applied to the predicted probabilities, i.e. above the threshold is\ntrue, below is false."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If it\nis not given, that means labels are already encoded as integer within\n[0, n_classes) or multi-hot Tensor. If given, labels must be SparseTensor\nstring type and have any value in label_vocabulary. Also there will be\nerrors if vocabulary is not provided and labels are string."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE, namely\nweighted sum of losses divided by batch size."}, {"name": "loss_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional loss function."}, {"name": "classes_for_class_based_metrics", "is_optional": true, "type": "int", "default_value": "None", "description": "List of integer class IDs or string class\nnames for which per-class metrics are evaluated. If integers, all must be\nin the range [0, n_classes - 1]. If strings, all must be in\nlabel_vocabulary."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.LogisticRegressionHead", "type": "class", "code": "tf.estimator.LogisticRegressionHead(weight_column=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,name=None)", "summary": "Creates a Head for logistic regression.\n\nInherits From: RegressionHead", "description": "", "code-info": {"name": "tf.estimator.LogisticRegressionHead", "parameters": [{"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch and label dimension. Defaults to\nSUM_OVER_BATCH_SIZE, namely weighted sum of losses divided by\nbatch size * label_dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.PoissonRegressionHead", "type": "class", "code": "tf.estimator.PoissonRegressionHead(label_dimension=1,weight_column=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,compute_full_loss=True,name=None)", "summary": "Creates a Head for poisson regression using tf.nn.log_poisson_loss.\n\nInherits From: RegressionHead", "description": "", "code-info": {"name": "tf.estimator.PoissonRegressionHead", "parameters": [{"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression labels per example. This is the size\nof the last dimension of the labels Tensor (typically, this has shape\n[batch_size, label_dimension]).\nloss_reduction: One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch and label dimension. Defaults to\nSUM_OVER_BATCH_SIZE, namely weighted sum of losses divided by\nbatch size * label_dimension.\ncompute_full_loss: Whether to include the constant log(z!) term in\ncomputing the poisson loss. See tf.nn.log_poisson_loss for the full\ndocumentation.\nname: name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops.\n\n\nAttributes:\n\n\nlogits_dimension:   See base_head.Head for details.\nloss_reduction:   See base_head.Head for details.\nname:   See base_head.Head for details.\n\n\nMethods\n\ncreate_estimator_spec\n\nView source\ncreate_estimator_spec(\n    features, mode, logits, labels=None, optimizer=None, trainable_variables=None,\n    train_op_fn=None, update_ops=None, regularization_losses=None\n)\n\nReturns EstimatorSpec that a model_fn can return.\n\nIt is recommended to pass all args via name.\n\nArgs:\n\n\nfeatures: Input dict mapping string feature names to Tensor or\nSparseTensor objects containing the values for that feature in a\nminibatch. Often to be used to fetch example-weight tensor.\nmode: Estimator's ModeKeys.\nlogits: Logits Tensor to be used by the head.\nlabels: Labels Tensor, or dict mapping string label names to Tensor\nobjects of the label values.\noptimizer: An tf.keras.optimizers.Optimizer instance to optimize the\nloss in TRAIN mode. Namely, sets train_op = optimizer.get_updates(loss,\ntrainable_variables), which updates variables to minimize loss.\ntrainable_variables: A list or tuple of Variable objects to update to\nminimize loss. In Tensorflow 1.x, by default these are the list of\nvariables collected in the graph under the key\nGraphKeys.TRAINABLE_VARIABLES. As Tensorflow 2.x doesn't have\ncollections and GraphKeys, trainable_variables need to be passed\nexplicitly here.\ntrain_op_fn: Function that takes a scalar loss Tensor and returns an op\nto optimize the model with the loss in TRAIN mode. Used if optimizer\nis None. Exactly one of train_op_fn and optimizer must be set in\nTRAIN mode. By default, it is None in other modes. If you want to\noptimize loss yourself, you can pass lambda _: tf.no_op() and then use\nEstimatorSpec.loss to compute and apply gradients.\nupdate_ops: A list or tuple of update ops to be run at training time. For\nexample, layers such as BatchNormalization create mean and variance\nupdate ops that need to be run at training time. In Tensorflow 1.x,\nthese are thrown into an UPDATE_OPS collection. As Tensorflow 2.x\ndoesn't have collections, update_ops need to be passed explicitly here.\nregularization_losses: A list of additional scalar losses to be added to\nthe training loss, such as regularization losses.\n\n\nReturns:\n\nEstimatorSpec.\n\nloss\n\nView source\nloss(\n    labels, logits, features=None, mode=None, regularization_losses=None\n)\n\nReturn predictions based on keys. See base_head.Head for details.\n\nmetrics\n\nView source\nmetrics(\n    regularization_losses=None\n)\n\nCreates metrics. See base_head.Head for details.\n\npredictions\n\nView source\npredictions(\n    logits\n)\n\nReturn predictions based on keys.  See base_head.Head for details.\n\nArgs:\n\n\nlogits: logits Tensor with shape [D0, D1, ... DN, logits_dimension].\nFor many applications, the shape is [batch_size, logits_dimension].\n\n\nReturns:\n\nA dict of predictions.\n\nupdate_metrics\n\nView source\nupdate_metrics(\n    eval_metrics, features, logits, labels, regularization_losses=None\n)\n\nUpdates eval metrics. See base_head.Head for details.\n\n          "}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example.\nlabel_dimension: Number of regression labels per example. This is the size\nof the last dimension of the labels Tensor (typically, this has shape\n[batch_size, label_dimension])."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch and label dimension. Defaults to\nSUM_OVER_BATCH_SIZE, namely weighted sum of losses divided by\nbatch size * label_dimension."}, {"name": "compute_full_loss", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to include the constant log(z!) term in\ncomputing the poisson loss. See tf.nn.log_poisson_loss for the full\ndocumentation."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.MultiHead", "type": "class", "code": "tf.estimator.MultiHead(heads,head_weights=None)", "summary": "Creates a Head for multi-objective learning.\n\nInherits From: Head", "description": "", "code-info": {"name": "tf.estimator.MultiHead", "parameters": [{"name": "heads", "is_optional": false, "type": "others", "description": "List or tuple of Head instances. All heads must have name\nspecified. The first head in the list is the default used at serving time."}, {"name": "head_weights", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of weights, same length as heads. Used when\nmerging losses to calculate the weighted sum of losses from each head. If\nNone, all losses are weighted equally."}]}},
{"id": "tf.estimator.MultiClassHead", "type": "class", "code": "tf.estimator.MultiClassHead(n_classes,weight_column=None,label_vocabulary=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,loss_fn=None,name=None)", "summary": "Creates a Head for multi class classification.\n\nInherits From: Head", "description": "", "code-info": {"name": "tf.estimator.MultiClassHead", "parameters": [{"name": "n_classes", "is_optional": false, "type": "others", "description": "Number of classes, must be greater than 2 (for 2 classes, use\nBinaryClassHead)."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list or tuple of strings representing possible label\nvalues. If it is not given, that means labels are already encoded as an\ninteger within [0, n_classes). If given, labels must be of string type and\nhave any value in label_vocabulary. Note that errors will be raised if\nlabel_vocabulary is not provided but labels are strings. If both\nn_classes and label_vocabulary are provided, label_vocabulary should\ncontain exactly n_classes items."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE, namely\nweighted sum of losses divided by batch size * label_dimension."}, {"name": "loss_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional loss function."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.LoggingTensorHook", "type": "function", "code": "tf.estimator.LoggingTensorHook(tensors,every_n_iter=None,every_n_secs=None,at_end=False,formatter=None)", "summary": "Prints the given tensors every N local steps, every N seconds, or at end.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.LoggingTensorHook", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "dict that maps string-valued tags to tensors/tensor names, or\niterable of tensors/tensor names."}, {"name": "every_n_iter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "int, print the values of tensors once every N local\nsteps taken on the current worker."}, {"name": "every_n_secs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "int or float, print the values of tensors once every N\nseconds. Exactly one of every_n_iter and every_n_secs should be\nprovided."}, {"name": "at_end", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool specifying whether to print the values of tensors at the\nend of the run."}, {"name": "formatter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "function, takes dict of tag-&gt;Tensor and returns a string.\nIf None uses default printing all tensors."}]}},
{"id": "tf.estimator.LinearRegressor", "type": "class", "code": "tf.estimator.LinearRegressor(feature_columns,model_dir=None,label_dimension=1,weight_column=None,optimizer='Ftrl',config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear regression problems.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.LinearRegressor", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key, then\nweight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* or\ntf.estimator.experimental.LinearSDCA used to train the model. Can also\nbe a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or\ncallable. Defaults to FTRL optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights and biases are warm-started, and it is assumed that vocabularies\nand Tensor names are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent.  One of \"mean\", \"sqrtn\", and \"sum\" -- these are\neffectively different ways to do example-level normalization, which can\nbe useful for bag-of-words features. for more details, see\ntf.feature_column.linear_model."}]}},
{"id": "tf.estimator.FinalExporter", "type": "class", "code": "tf.estimator.FinalExporter(name,serving_input_receiver_fn,assets_extra=None,as_text=False)", "summary": "This class exports the serving graph and checkpoints at the end.\n\nInherits From: Exporter", "description": "", "code-info": {"name": "tf.estimator.FinalExporter", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "unique name of this Exporter that is going to be used in the\nexport path."}, {"name": "serving_input_receiver_fn", "is_optional": false, "type": "others", "description": "a function that takes no arguments and returns\na ServingInputReceiver."}, {"name": "assets_extra", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional dict specifying how to populate the assets.extra\ndirectory within the exported SavedModel.  Each key should give the\ndestination path (including the filename) relative to the assets.extra\ndirectory.  The corresponding value gives the full path of the source\nfile to be copied.  For example, the simple case of copying a single\nfile without renaming it is specified as\n{'my_asset_file.txt': '/path/to/my_asset_file.txt'}."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to write the SavedModel proto in text format. Defaults to\nFalse."}]}},
{"id": "tf.estimator.LinearEstimator", "type": "class", "code": "tf.estimator.LinearEstimator(head,feature_columns,model_dir=None,optimizer='Ftrl',config=None,sparse_combiner='sum')", "summary": "An estimator for TensorFlow linear models with user-specified head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.LinearEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "string", "description": "A Head instance constructed with a method such as\ntf.estimator.MultiLabelHead."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator\nto continue training a previously saved model."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* used to train the model.\nCan also be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp',\n'SGD'), or callable. Defaults to FTRL optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent.  One of \"mean\", \"sqrtn\", and \"sum\" -- these are\neffectively different ways to do example-level normalization, which can\nbe useful for bag-of-words features. for more details, see\ntf.feature_column.linear_model."}]}},
{"id": "tf.estimator.LatestExporter", "type": "class", "code": "tf.estimator.LatestExporter(name,serving_input_receiver_fn,assets_extra=None,as_text=False,exports_to_keep=5)", "summary": "This class regularly exports the serving graph and checkpoints.\n\nInherits From: Exporter", "description": "", "code-info": {"name": "tf.estimator.LatestExporter", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "unique name of this Exporter that is going to be used in the\nexport path."}, {"name": "serving_input_receiver_fn", "is_optional": false, "type": "others", "description": "a function that takes no arguments and returns\na ServingInputReceiver."}, {"name": "assets_extra", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional dict specifying how to populate the assets.extra\ndirectory within the exported SavedModel.  Each key should give the\ndestination path (including the filename) relative to the assets.extra\ndirectory.  The corresponding value gives the full path of the source\nfile to be copied.  For example, the simple case of copying a single\nfile without renaming it is specified as\n{'my_asset_file.txt': '/path/to/my_asset_file.txt'}."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to write the SavedModel proto in text format. Defaults to\nFalse."}, {"name": "exports_to_keep", "is_optional": true, "type": "int", "default_value": "5", "description": "Number of exports to keep.  Older exports will be\ngarbage-collected.  Defaults to 5.  Set to None to disable garbage\ncollection."}]}},
{"id": "create_estimator_spec", "type": "class", "code": "create_estimator_spec(features,mode,logits,labels=None,optimizer=None,trainable_variables=None,train_op_fn=None,update_ops=None,regularization_losses=None)", "summary": "Interface for the head/top of a model.", "description": "", "code-info": {"name": "create_estimator_spec", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "Input dict mapping string feature names to Tensor or\nSparseTensor objects containing the values for that feature in a\nminibatch. Often to be used to fetch example-weight tensor."}, {"name": "mode", "is_optional": false, "type": "others", "description": "Estimator's ModeKeys."}, {"name": "logits", "is_optional": false, "type": "tensor", "description": "Logits Tensor to be used by the head."}, {"name": "labels", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Labels Tensor, or dict mapping string label names to Tensor\nobjects of the label values."}, {"name": "optimizer", "is_optional": true, "type": "others", "default_value": "None", "description": "An tf.keras.optimizers.Optimizer instance to optimize the\nloss in TRAIN mode. Namely, sets train_op = optimizer.get_updates(loss,\ntrainable_variables), which updates variables to minimize loss."}, {"name": "trainable_variables", "is_optional": true, "type": "others", "default_value": "None", "description": "A list or tuple of Variable objects to update to\nminimize loss. In Tensorflow 1.x, by default these are the list of\nvariables collected in the graph under the key\nGraphKeys.TRAINABLE_VARIABLES. As Tensorflow 2.x doesn't have\ncollections and GraphKeys, trainable_variables need to be passed\nexplicitly here."}, {"name": "train_op_fn", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Function that takes a scalar loss Tensor and returns an op\nto optimize the model with the loss in TRAIN mode. Used if optimizer\nis None. Exactly one of train_op_fn and optimizer must be set in\nTRAIN mode. By default, it is None in other modes. If you want to\noptimize loss yourself, you can pass lambda _: tf.no_op() and then use\nEstimatorSpec.loss to compute and apply gradients."}, {"name": "update_ops", "is_optional": true, "type": "others", "default_value": "None", "description": "A list or tuple of update ops to be run at training time. For\nexample, layers such as BatchNormalization create mean and variance\nupdate ops that need to be run at training time. In Tensorflow 1.x,\nthese are thrown into an UPDATE_OPS collection. As Tensorflow 2.x\ndoesn't have collections, update_ops need to be passed explicitly here."}, {"name": "regularization_losses", "is_optional": true, "type": "float", "default_value": "None", "description": "A list of additional scalar losses to be added to\nthe training loss, such as regularization losses."}]}},
{"id": "tf.estimator.GlobalStepWaiterHook", "type": "function", "code": "tf.estimator.GlobalStepWaiterHook(wait_until_step)", "summary": "Delays execution until global step reaches wait_until_step.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.GlobalStepWaiterHook", "parameters": [{"name": "wait_until_step", "is_optional": false, "type": "others", "description": "an int shows until which global step should we wait."}]}},
{"id": "export", "type": "class", "code": "export(estimator,export_path,checkpoint_path,eval_result,is_the_final_export)", "summary": "A class representing a type of model export.", "description": "", "code-info": {"name": "export", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "the Estimator to export."}, {"name": "export_path", "is_optional": false, "type": "string", "description": "A string containing a directory where to write the export."}, {"name": "checkpoint_path", "is_optional": false, "type": "others", "description": "The checkpoint path to export."}, {"name": "eval_result", "is_optional": false, "type": "others", "description": "The output of Estimator.evaluate on this checkpoint."}, {"name": "is_the_final_export", "is_optional": false, "type": "bool", "description": "This boolean is True when this is an export in the\nend of training.  It is False for the intermediate exports during\nthe training.\nWhen passing Exporter to tf.estimator.train_and_evaluate\nis_the_final_export is always False if TrainSpec.max_steps is\nNone."}]}},
{"id": "tf.estimator.FeedFnHook", "type": "function", "code": "tf.estimator.FeedFnHook(feed_fn)", "summary": "Runs feed_fn and sets the feed_dict accordingly.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.FeedFnHook", "parameters": [{"name": "feed_fn", "is_optional": false, "type": "others", "description": "function that takes no arguments and returns dict of Tensor\nto feed."}]}},
{"id": "tf.estimator.LinearClassifier", "type": "class", "code": "tf.estimator.LinearClassifier(feature_columns,model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Ftrl',config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,sparse_combiner='sum')", "summary": "Linear classifier model.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.LinearClassifier", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator\nto continue training a previously saved model."}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": "number of label classes. Default is binary classification.\nNote that class labels are integers representing the class index (i.e.\nvalues from 0 to n_classes-1). For arbitrary label values (e.g. string\nlabels), convert to class indices first."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a _NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\n_NumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If\ngiven, labels must be string type and have any value in\nlabel_vocabulary. If it is not given, that means labels are\nalready encoded as integer or float within [0, 1] for n_classes=2 and\nencoded as integer values in {0, 1,..., n_classes-1} for n_classes&gt;2 .\nAlso there will be errors if vocabulary is not provided and labels are\nstring."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* or\ntf.estimator.experimental.LinearSDCA used to train the model. Can\nalso be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'),\nor callable. Defaults to FTRL optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights and biases are warm-started, and it is assumed that vocabularies\nand Tensor names are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent.  One of \"mean\", \"sqrtn\", and \"sum\" -- these are\neffectively different ways to do example-level normalization, which can\nbe useful for bag-of-words features. for more details, see\ntf.feature_column.linear_model."}]}},
{"id": "tf.estimator.FinalOpsHook", "type": "class", "code": "tf.estimator.FinalOpsHook(final_ops,final_ops_feed_dict=None)", "summary": "A hook which evaluates Tensors at the end of a session.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.FinalOpsHook", "parameters": [{"name": "final_ops", "is_optional": false, "type": "tensor", "description": "A single Tensor, a list of Tensors or a dictionary of names\nto Tensors."}, {"name": "final_ops_feed_dict", "is_optional": true, "type": "others", "default_value": "None", "description": "A feed dictionary to use when running\nfinal_ops_dict."}]}},
{"id": "tf.estimator.DNNEstimator", "type": "class", "code": "tf.estimator.DNNEstimator(head,hidden_units,feature_columns,model_dir=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,config=None,warm_start_from=None,batch_norm=False)", "summary": "An estimator for TensorFlow DNN models with user-specified head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "string", "description": "A _Head instance constructed with a method such as\ntf.contrib.estimator.multi_label_head."}, {"name": "hidden_units", "is_optional": false, "type": "others", "description": "Iterable of number hidden units per layer. All layers are\nfully connected. Ex. [64, 32] means first layer has 64 nodes and\nsecond one has 32."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom _FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to train the model.\nCan also be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp',\nSGD'), or callable. Defaults to Adagrad optimizer."}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None, will\nuse tf.nn.relu."}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out a given\ncoordinate."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights are warm-started, and it is assumed that vocabularies and Tensor\nnames are unchanged."}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use batch normalization after each hidden layer."}]}},
{"id": "tf.estimator.DNNLinearCombinedEstimator", "type": "class", "code": "tf.estimator.DNNLinearCombinedEstimator(head,model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,config=None,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined models with custom head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNLinearCombinedEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "string", "description": "A Head instance constructed with a method such as\ntf.estimator.MultiLabelHead."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator\nto continue training a previously saved model."}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns\nused by linear part of the model. All items in the set must be\ninstances of classes derived from FeatureColumn."}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the linear part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to FTRL optimizer."}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns used\nby deep part of the model. All items in the set must be instances of\nclasses derived from FeatureColumn."}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the deep part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to Adagrad optimizer."}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": "List of hidden units per layer. All layers are fully\nconnected."}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None,\nwill use tf.nn.relu."}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out\na given coordinate."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce the linear model\nif a categorical column is multivalent.  One of \"mean\", \"sqrtn\", and\n\"sum\" -- these are effectively different ways to do example-level\nnormalization, which can be useful for bag-of-words features.  For more\ndetails, see tf.feature_column.linear_model."}]}},
{"id": "tf.estimator.DNNLinearCombinedClassifier", "type": "class", "code": "tf.estimator.DNNLinearCombinedClassifier(model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,n_classes=2,weight_column=None,label_vocabulary=None,config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,batch_norm=False,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined classification models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNLinearCombinedClassifier", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator\nto continue training a previously saved model."}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns\nused by linear part of the model. All items in the set must be\ninstances of classes derived from FeatureColumn."}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the linear part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to FTRL optimizer."}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns used\nby deep part of the model. All items in the set must be instances of\nclasses derived from FeatureColumn."}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the deep part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to Adagrad optimizer."}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": "List of hidden units per layer. All layers are fully\nconnected."}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None,\nwill use tf.nn.relu."}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out\na given coordinate."}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": "Number of label classes. Defaults to 2, namely binary\nclassification. Must be &gt; 1."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a _NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\n_NumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If\ngiven, labels must be string type and have any value in\nlabel_vocabulary. If it is not given, that means labels are\nalready encoded as integer or float within [0, 1] for n_classes=2 and\nencoded as integer values in {0, 1,..., n_classes-1} for n_classes&gt;2 .\nAlso there will be errors if vocabulary is not provided and labels are\nstring."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights are warm-started, and it is assumed that vocabularies and Tensor\nnames are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use batch normalization after each hidden layer."}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce the linear model\nif a categorical column is multivalent.  One of \"mean\", \"sqrtn\", and\n\"sum\" -- these are effectively different ways to do example-level\nnormalization, which can be useful for bag-of-words features.  For more\ndetails, see tf.feature_column.linear_model."}]}},
{"id": "tf.estimator.DNNClassifier", "type": "class", "code": "tf.estimator.DNNClassifier(hidden_units,feature_columns,model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,batch_norm=False)", "summary": "A classifier for TensorFlow DNN models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNClassifier", "parameters": [{"name": "hidden_units", "is_optional": false, "type": "others", "description": "Iterable of number hidden units per layer. All layers are\nfully connected. Ex. [64, 32] means first layer has 64 nodes and\nsecond one has 32."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom _FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": "Number of label classes. Defaults to 2, namely binary\nclassification. Must be &gt; 1."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\n_NumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If\ngiven, labels must be string type and have any value in\nlabel_vocabulary. If it is not given, that means labels are\nalready encoded as integer or float within [0, 1] for n_classes=2 and\nencoded as integer values in {0, 1,..., n_classes-1} for n_classes&gt;2 .\nAlso there will be errors if vocabulary is not provided and labels are\nstring."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to train the model.\nCan also be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp',\nSGD'), or callable. Defaults to Adagrad optimizer."}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None, will\nuse tf.nn.relu."}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out a given\ncoordinate."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights are warm-started, and it is assumed that vocabularies and Tensor\nnames are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use batch normalization after each hidden layer."}]}},
{"id": "tf.estimator.Estimator", "type": "class", "code": "tf.estimator.Estimator(model_fn,model_dir=None,config=None,params=None,warm_start_from=None)", "summary": "Estimator class to train and evaluate TensorFlow models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.Estimator", "parameters": [{"name": "model_fn", "is_optional": false, "type": "others", "description": "Model function. Follows the signature:\n\n\nArgs:\nfeatures: This is the first item returned from the input_fn\n   passed to train, evaluate, and predict. This should be a\n   single tf.Tensor or dict of same.\nlabels: This is the second item returned from the input_fn\n   passed to train, evaluate, and predict. This should be a\n   single tf.Tensor or dict of same (for multi-head models).\n   If mode is tf.estimator.ModeKeys.PREDICT, labels=None will\n   be passed. If the model_fn's signature does not accept\n   mode, the model_fn must still be able to handle\n   labels=None.\nmode: Optional. Specifies if this is training, evaluation or\n   prediction. See tf.estimator.ModeKeys.\nparams: Optional dict of hyperparameters.  Will receive what\n   is passed to Estimator in params parameter. This allows\n   to configure Estimators from hyper parameter tuning.\nconfig: Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n"}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "params", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional dict of hyperparameters.  Will receive what\n   is passed to Estimator in params parameter. This allows\n   to configure Estimators from hyper parameter tuning.\nconfig: Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used.\nconfig: estimator.RunConfig configuration object."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string filepath to a checkpoint or SavedModel to\n             warm-start from, or a tf.estimator.WarmStartSettings\n             object to fully configure warm-starting.\n         If None, only TRAINABLE variables are warm-started."}]}},
{"id": "tf.estimator.DNNRegressor", "type": "class", "code": "tf.estimator.DNNRegressor(hidden_units,feature_columns,model_dir=None,label_dimension=1,weight_column=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,batch_norm=False)", "summary": "A regressor for TensorFlow DNN models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNRegressor", "parameters": [{"name": "hidden_units", "is_optional": false, "type": "others", "description": "Iterable of number hidden units per layer. All layers are\nfully connected. Ex. [64, 32] means first layer has 64 nodes and\nsecond one has 32."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to train the model.\nCan also be a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp',\nSGD'), or callable. Defaults to Adagrad optimizer."}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None, will\nuse tf.nn.relu."}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out a given\ncoordinate."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights are warm-started, and it is assumed that vocabularies and Tensor\nnames are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use batch normalization after each hidden layer."}]}},
{"id": "tf.estimator.DNNLinearCombinedRegressor", "type": "class", "code": "tf.estimator.DNNLinearCombinedRegressor(model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,label_dimension=1,weight_column=None,config=None,warm_start_from=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,batch_norm=False,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined models for regression.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.DNNLinearCombinedRegressor", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator\nto continue training a previously saved model."}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns\nused by linear part of the model. All items in the set must be\ninstances of classes derived from FeatureColumn."}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the linear part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to FTRL optimizer."}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable containing all the feature columns used\nby deep part of the model. All items in the set must be instances of\nclasses derived from FeatureColumn."}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "An instance of tf.keras.optimizers.* used to apply\ngradients to the deep part of the model. Can also be a string\n(one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or callable.\nDefaults to Adagrad optimizer."}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": "List of hidden units per layer. All layers are fully\nconnected."}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": "Activation function applied to each layer. If None,\nwill use tf.nn.relu."}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": "When not None, the probability we will drop out\na given coordinate."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\n_NumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "A string filepath to a checkpoint to warm-start from, or\na WarmStartSettings object to fully configure warm-starting.  If the\nstring filepath is provided instead of a WarmStartSettings, then all\nweights are warm-started, and it is assumed that vocabularies and Tensor\nnames are unchanged."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use batch normalization after each hidden layer."}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce the linear model\nif a categorical column is multivalent.  One of \"mean\", \"sqrtn\", and\n\"sum\" -- these are effectively different ways to do example-level\nnormalization, which can be useful for bag-of-words features.  For more\ndetails, see tf.feature_column.linear_model."}]}},
{"id": "tf.estimator.BestExporter", "type": "class", "code": "tf.estimator.BestExporter(name='best_exporter',serving_input_receiver_fn=None,event_file_pattern='eval/*.tfevents.*',compare_fn=_loss_smaller,assets_extra=None,as_text=False,exports_to_keep=5)", "summary": "This class exports the serving graph and checkpoints of the best models.\n\nInherits From: Exporter", "description": "", "code-info": {"name": "tf.estimator.BestExporter", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'best_exporter'", "description": "unique name of this Exporter that is going to be used in the\nexport path."}, {"name": "serving_input_receiver_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "a function that takes no arguments and returns\na ServingInputReceiver."}, {"name": "event_file_pattern", "is_optional": true, "type": "string", "default_value": "'eval/*.tfevents.*'", "description": "event file name pattern relative to model_dir. If\nNone, however, the exporter would not be preemption-safe. To be\npreemption-safe, event_file_pattern must be specified."}, {"name": "compare_fn", "is_optional": true, "type": "others", "default_value": "_loss_smaller", "description": "a function that compares two evaluation results and returns\ntrue if current evaluation result is better. Follows the signature:\n\nArgs:\nbest_eval_result: This is the evaluation result of the best model.\ncurrent_eval_result: This is the evaluation result of current\n   candidate model.\nReturns:\nTrue if current evaluation result is better; otherwise, False.\n"}, {"name": "assets_extra", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional dict specifying how to populate the assets.extra\ndirectory within the exported SavedModel.  Each key should give the\ndestination path (including the filename) relative to the assets.extra\ndirectory.  The corresponding value gives the full path of the source\nfile to be copied.  For example, the simple case of copying a single\nfile without renaming it is specified as {'my_asset_file.txt':\n'/path/to/my_asset_file.txt'}."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to write the SavedModel proto in text format. Defaults to\nFalse."}, {"name": "exports_to_keep", "is_optional": true, "type": "int", "default_value": "5", "description": "Number of exports to keep.  Older exports will be\ngarbage-collected.  Defaults to 5.  Set to None to disable garbage\ncollection."}]}},
{"id": "tf.estimator.CheckpointSaverHook", "type": "function", "code": "tf.estimator.CheckpointSaverHook(checkpoint_dir,save_secs=None,save_steps=None,saver=None,checkpoint_basename='model.ckpt',scaffold=None,listeners=None,save_graph_def=True)", "summary": "Saves checkpoints every N steps or seconds.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.estimator.CheckpointSaverHook", "parameters": [{"name": "checkpoint_dir", "is_optional": false, "type": "string", "description": "str, base directory for the checkpoint files."}, {"name": "save_secs", "is_optional": true, "type": "others", "default_value": "None", "description": "int, save every N secs."}, {"name": "save_steps", "is_optional": true, "type": "others", "default_value": "None", "description": "int, save every N steps."}, {"name": "saver", "is_optional": true, "type": "others", "default_value": "None", "description": "Saver object, used for saving."}, {"name": "checkpoint_basename", "is_optional": true, "type": "string", "default_value": "'model.ckpt'", "description": "str, base name for the checkpoint files."}, {"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "Scaffold, use to get saver object."}, {"name": "listeners", "is_optional": true, "type": "others", "default_value": "None", "description": "List of CheckpointSaverListener subclass instances. Used for\ncallbacks that run immediately before or after this hook saves the\ncheckpoint."}, {"name": "save_graph_def", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to save the GraphDef and MetaGraphDef to\ncheckpoint_dir. The GraphDef is saved after the session is created as\ngraph.pbtxt. MetaGraphDefs are saved out for every checkpoint as\nmodel.ckpt-*.meta."}]}},
{"id": "tf.estimator.BoostedTreesRegressor", "type": "class", "code": "tf.estimator.BoostedTreesRegressor(feature_columns,n_batches_per_layer,model_dir=None,label_dimension=_HOLD_FOR_MULTI_DIM_SUPPORT,weight_column=None,n_trees=100,max_depth=6,learning_rate=0.1,l1_regularization=0.0,l2_regularization=0.0,tree_complexity=0.0,min_node_weight=0.0,config=None,center_bias=False,pruning_mode='none',quantile_sketch_epsilon=0.01,train_in_memory=False)", "summary": "A Regressor for Tensorflow Boosted Trees models.", "description": "", "code-info": {"name": "tf.estimator.BoostedTreesRegressor", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "n_batches_per_layer", "is_optional": false, "type": "others", "description": "the number of batches to collect statistics per\nlayer. The total number of batches is total number of data divided by\nbatch size."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "label_dimension", "is_optional": true, "type": "others", "default_value": "_HOLD_FOR_MULTI_DIM_SUPPORT", "description": "Number of regression targets per example.\nMulti-dimensional support is not yet implemented."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.fc_old.numeric_column defining feature column representing weights.\nIt is used to downweight or boost examples during training. It will be\nmultiplied by the loss of the example. If it is a string, it is used as\na key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key, then\nweight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "n_trees", "is_optional": true, "type": "int", "default_value": "100", "description": "number trees to be created."}, {"name": "max_depth", "is_optional": true, "type": "int", "default_value": "6", "description": "maximum depth of the tree to grow."}, {"name": "learning_rate", "is_optional": true, "type": "others", "default_value": "0.1", "description": "shrinkage parameter to be used when a tree added to the\nmodel."}, {"name": "l1_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the absolute\nweights of the tree leafs."}, {"name": "l2_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the square weights\nof the tree leafs."}, {"name": "tree_complexity", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization factor to penalize trees with more leaves."}, {"name": "min_node_weight", "is_optional": true, "type": "others", "default_value": "0.0", "description": "min_node_weight: minimum hessian a node must have for a\nsplit to be considered. The value will be compared with\nsum(leaf_hessian)/(batch_size * n_batches_per_layer)."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "center_bias", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether bias centering needs to occur. Bias centering refers\nto the first node in the very first tree returning the prediction that\nis aligned with the original labels distribution. For example, for\nregression problems, the first node will return the mean of the labels.\nFor binary classification problems, it will return a logit for a prior\nprobability of label 1."}, {"name": "pruning_mode", "is_optional": true, "type": "string", "default_value": "'none'", "description": "one of 'none', 'pre', 'post' to indicate no pruning, pre-\npruning (do not split a node if not enough gain is observed) and post\npruning (build the tree up to a max depth and then prune branches with\nnegative gain). For pre and post pruning, you MUST provide\ntree_complexity &gt;0."}, {"name": "quantile_sketch_epsilon", "is_optional": true, "type": "float", "default_value": "0.01", "description": "float between 0 and 1. Error bound for quantile\ncomputation. This is only used for float feature columns, and the number\nof buckets generated per float feature is 1/quantile_sketch_epsilon."}, {"name": "train_in_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, when true, it assumes the dataset is in memory,\ni.e., input_fn should return the entire dataset as a single batch,\nn_batches_per_layer should be set as 1, num_worker_replicas should be 1,\nand num_ps_replicas should be 0 in tf.Estimator.RunConfig."}]}},
{"id": "tf.estimator.BoostedTreesEstimator", "type": "class", "code": "tf.estimator.BoostedTreesEstimator(feature_columns,n_batches_per_layer,head,model_dir=None,weight_column=None,n_trees=100,max_depth=6,learning_rate=0.1,l1_regularization=0.0,l2_regularization=0.0,tree_complexity=0.0,min_node_weight=0.0,config=None,center_bias=False,pruning_mode='none',quantile_sketch_epsilon=0.01)", "summary": "An Estimator for Tensorflow Boosted Trees models.", "description": "", "code-info": {"name": "tf.estimator.BoostedTreesEstimator", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "n_batches_per_layer", "is_optional": false, "type": "others", "description": "the number of batches to collect statistics per\nlayer."}, {"name": "head", "is_optional": false, "type": "others", "description": "the Head instance defined for Estimator."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a _NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to downweight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\n_NumericColumn, raw tensor is fetched by key weight_column.key, then\nweight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "n_trees", "is_optional": true, "type": "int", "default_value": "100", "description": "number trees to be created."}, {"name": "max_depth", "is_optional": true, "type": "int", "default_value": "6", "description": "maximum depth of the tree to grow."}, {"name": "learning_rate", "is_optional": true, "type": "others", "default_value": "0.1", "description": "shrinkage parameter to be used when a tree added to the\nmodel."}, {"name": "l1_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the absolute\nweights of the tree leafs."}, {"name": "l2_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the square weights\nof the tree leafs."}, {"name": "tree_complexity", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization factor to penalize trees with more leaves."}, {"name": "min_node_weight", "is_optional": true, "type": "others", "default_value": "0.0", "description": "minimum hessian a node must have for a split to be\nconsidered. The value will be compared with sum(leaf_hessian)/\n(batch_size * n_batches_per_layer)."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "center_bias", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether bias centering needs to occur. Bias centering refers\nto the first node in the very first tree returning the prediction that\nis aligned with the original labels distribution. For example, for\nregression problems, the first node will return the mean of the labels.\nFor binary classification problems, it will return a logit for a prior\nprobability of label 1."}, {"name": "pruning_mode", "is_optional": true, "type": "string", "default_value": "'none'", "description": "one of 'none', 'pre', 'post' to indicate no pruning, pre-\npruning (do not split a node if not enough gain is observed) and post\npruning (build the tree up to a max depth and then prune branches with\nnegative gain). For pre and post pruning, you MUST provide\ntree_complexity &gt;0."}, {"name": "quantile_sketch_epsilon", "is_optional": true, "type": "float", "default_value": "0.01", "description": "float between 0 and 1. Error bound for quantile\ncomputation. This is only used for float feature columns, and the number\nof buckets generated per float feature is 1/quantile_sketch_epsilon."}]}},
{"id": "tf.estimator.BoostedTreesClassifier", "type": "class", "code": "tf.estimator.BoostedTreesClassifier(feature_columns,n_batches_per_layer,model_dir=None,n_classes=_HOLD_FOR_MULTI_CLASS_SUPPORT,weight_column=None,label_vocabulary=None,n_trees=100,max_depth=6,learning_rate=0.1,l1_regularization=0.0,l2_regularization=0.0,tree_complexity=0.0,min_node_weight=0.0,config=None,center_bias=False,pruning_mode='none',quantile_sketch_epsilon=0.01,train_in_memory=False)", "summary": "A Classifier for Tensorflow Boosted Trees models.", "description": "", "code-info": {"name": "tf.estimator.BoostedTreesClassifier", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "n_batches_per_layer", "is_optional": false, "type": "others", "description": "the number of batches to collect statistics per\nlayer. The total number of batches is total number of data divided by\nbatch size."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "n_classes", "is_optional": true, "type": "others", "default_value": "_HOLD_FOR_MULTI_CLASS_SUPPORT", "description": "number of label classes. Default is binary classification.\nMulticlass support is not yet implemented."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.fc_old.numeric_column defining feature column representing weights.\nIt is used to downweight or boost examples during training. It will be\nmultiplied by the loss of the example. If it is a string, it is used as\na key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key, then\nweight_column.normalizer_fn is applied on it to get weight tensor."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of strings represents possible label values. If\ngiven, labels must be string type and have any value in\nlabel_vocabulary. If it is not given, that means labels are already\nencoded as integer or float within [0, 1] for n_classes=2 and encoded\nas integer values in {0, 1,..., n_classes-1} for n_classes&gt;2 . Also\nthere will be errors if vocabulary is not provided and labels are\nstring."}, {"name": "n_trees", "is_optional": true, "type": "int", "default_value": "100", "description": "number trees to be created."}, {"name": "max_depth", "is_optional": true, "type": "int", "default_value": "6", "description": "maximum depth of the tree to grow."}, {"name": "learning_rate", "is_optional": true, "type": "others", "default_value": "0.1", "description": "shrinkage parameter to be used when a tree added to the\nmodel."}, {"name": "l1_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the absolute\nweights of the tree leafs."}, {"name": "l2_regularization", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization multiplier applied to the square weights\nof the tree leafs."}, {"name": "tree_complexity", "is_optional": true, "type": "others", "default_value": "0.0", "description": "regularization factor to penalize trees with more leaves."}, {"name": "min_node_weight", "is_optional": true, "type": "others", "default_value": "0.0", "description": "min_node_weight: minimum hessian a node must have for a\nsplit to be considered. The value will be compared with\nsum(leaf_hessian)/(batch_size * n_batches_per_layer)."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "center_bias", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether bias centering needs to occur. Bias centering refers\nto the first node in the very first tree returning the prediction that\nis aligned with the original labels distribution. For example, for\nregression problems, the first node will return the mean of the labels.\nFor binary classification problems, it will return a logit for a prior\nprobability of label 1."}, {"name": "pruning_mode", "is_optional": true, "type": "string", "default_value": "'none'", "description": "one of 'none', 'pre', 'post' to indicate no pruning, pre-\npruning (do not split a node if not enough gain is observed) and post\npruning (build the tree up to a max depth and then prune branches with\nnegative gain). For pre and post pruning, you MUST provide\ntree_complexity &gt;0."}, {"name": "quantile_sketch_epsilon", "is_optional": true, "type": "float", "default_value": "0.01", "description": "float between 0 and 1. Error bound for quantile\ncomputation. This is only used for float feature columns, and the number\nof buckets generated per float feature is 1/quantile_sketch_epsilon."}, {"name": "train_in_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, when true, it assumes the dataset is in memory,\ni.e., input_fn should return the entire dataset as a single batch,\nn_batches_per_layer should be set as 1, num_worker_replicas should be 1,\nand num_ps_replicas should be 0 in tf.Estimator.RunConfig."}]}},
{"id": "tf.estimator.BinaryClassHead", "type": "class", "code": "tf.estimator.BinaryClassHead(weight_column=None,thresholds=None,label_vocabulary=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE,loss_fn=None,name=None)", "summary": "Creates a Head for single label binary classification.\n\nInherits From: Head", "description": "", "code-info": {"name": "tf.estimator.BinaryClassHead", "parameters": [{"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example."}, {"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "Iterable of floats in the range (0, 1). For binary\nclassification metrics such as precision and recall, an eval metric is\ngenerated for each threshold value. This threshold is applied to the\nlogistic values to determine the binary classification (i.e., above the\nthreshold is true, below is false."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "A list or tuple of strings representing possible label\nvalues. If it is not given, that means labels are already encoded within\n[0, 1]. If given, labels must be string type and have any value in\nlabel_vocabulary. Note that errors will be raised if label_vocabulary\nis not provided but labels are strings."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Decides how to\nreduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE, namely\nweighted sum of losses divided by batch size * label_dimension."}, {"name": "loss_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional loss function."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the head. If provided, summary and metrics keys will be\nsuffixed by \"/\" + name. Also used as name_scope when creating ops."}]}},
{"id": "tf.estimator.classifier_parse_example_spec", "type": "function", "code": "tf.estimator.classifier_parse_example_spec(feature_columns,label_key,label_dtype=tf.dtypes.int64,label_default=None,weight_column=None)", "summary": "Generates parsing spec for tf.parse_example to be used with classifiers.", "description": "", "code-info": {"name": "tf.estimator.classifier_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from FeatureColumn."}, {"name": "label_key", "is_optional": false, "type": "string", "description": "A string identifying the label. It means tf.Example stores labels\nwith this key."}, {"name": "label_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "A tf.dtype identifies the type of labels. By default it is\ntf.int64. If user defines a label_vocabulary, this should be set as\ntf.string. tf.float32 labels are only supported for binary\nclassification."}, {"name": "label_default", "is_optional": true, "type": "others", "default_value": "None", "description": "used as label if label_key does not exist in given\ntf.Example. An example usage: let's say label_key is 'clicked' and\ntf.Example contains clicked data only for positive examples in following\nformat key:clicked, value:1. This means that if there is no data with\nkey 'clicked' it should count as negative example by setting\nlabel_deafault=0. Type of this value should be compatible with\nlabel_dtype."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}]}},
{"id": "tf.estimator.BaselineRegressor", "type": "class", "code": "tf.estimator.BaselineRegressor(model_dir=None,label_dimension=1,weight_column=None,optimizer='Ftrl',config=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE)", "summary": "A regressor that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.BaselineRegressor", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a _NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It will be multiplied by the loss of the example."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "String, tf.keras.optimizers.* object, or callable that\ncreates the optimizer to use for training. If not specified, will use\nFtrl as the default optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}]}},
{"id": "tf.errors.UnimplementedError", "type": "function", "code": "tf.errors.UnimplementedError(node_def,op,message)", "summary": "Raised when an operation has not been implemented.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.UnimplementedError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.UnknownError", "type": "function", "code": "tf.errors.UnknownError(node_def,op,message,error_code=UNKNOWN)", "summary": "Unknown error.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.UnknownError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "error_code", "is_optional": true, "type": "int", "default_value": "UNKNOWN", "description": "  The integer error code that describes the error.\nmessage:   The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.UnauthenticatedError", "type": "function", "code": "tf.errors.UnauthenticatedError(node_def,op,message)", "summary": "The request does not have valid authentication credentials.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.UnauthenticatedError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.UnavailableError", "type": "function", "code": "tf.errors.UnavailableError(node_def,op,message)", "summary": "Raised when the runtime is currently unavailable.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.UnavailableError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.ResourceExhaustedError", "type": "function", "code": "tf.errors.ResourceExhaustedError(node_def,op,message)", "summary": "Some resource has been exhausted.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.ResourceExhaustedError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.estimator.BaselineClassifier", "type": "class", "code": "tf.estimator.BaselineClassifier(model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Ftrl',config=None,loss_reduction=losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE)", "summary": "A classifier that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.BaselineClassifier", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": "number of label classes. Default is binary classification.\nIt must be greater than 1. Note: Class labels are integers representing\nthe class index (i.e. values from 0 to n_classes-1). For arbitrary\nlabel values (e.g. string labels), convert to class indices first."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It will be multiplied by the loss of the example."}, {"name": "label_vocabulary", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional list of strings with size [n_classes]\ndefining the label vocabulary. Only supported for n_classes &gt; 2."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "String, tf.keras.optimizers.* object, or callable that\ncreates the optimizer to use for training. If not specified, will use\nFtrl as the default optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses_utils.ReductionV2.SUM_OVER_BATCH_SIZE", "description": "One of tf.losses.Reduction except NONE. Describes how\nto reduce training loss over batch. Defaults to SUM_OVER_BATCH_SIZE."}]}},
{"id": "tf.estimator.add_metrics", "type": "function", "code": "tf.estimator.add_metrics(estimator,metric_fn)", "summary": "Creates a new tf.estimator.Estimator which has given metrics.", "description": "", "code-info": {"name": "tf.estimator.add_metrics", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "A tf.estimator.Estimator object."}, {"name": "metric_fn", "is_optional": false, "type": "others", "description": "A function which should obey the following signature:"}]}},
{"id": "tf.errors.PermissionDeniedError", "type": "function", "code": "tf.errors.PermissionDeniedError(node_def,op,message)", "summary": "Raised when the caller does not have permission to run an operation.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.PermissionDeniedError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.OutOfRangeError", "type": "function", "code": "tf.errors.OutOfRangeError(node_def,op,message)", "summary": "Raised when an operation iterates past the valid input range.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.OutOfRangeError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.estimator.BaselineEstimator", "type": "class", "code": "tf.estimator.BaselineEstimator(head,model_dir=None,optimizer='Ftrl',config=None)", "summary": "An estimator that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.estimator.BaselineEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "string", "description": "A Head instance constructed with a method such as\ntf.estimator.MultiLabelHead."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "String, tf.keras.optimizers.* object, or callable that\ncreates the optimizer to use for training. If not specified, will use\nFtrl as the default optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}]}},
{"id": "tf.errors.OpError", "type": "class", "code": "tf.errors.OpError(node_def,op,message,error_code)", "summary": "A generic error that is raised when TensorFlow execution fails.", "description": "", "code-info": {"name": "tf.errors.OpError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "The node_def_pb2.NodeDef proto representing the op that\nfailed, if known; otherwise None."}, {"name": "op", "is_optional": false, "type": "others", "description": "The ops.Operation that failed, if known; otherwise None."}, {"name": "message", "is_optional": false, "type": "string", "description": "The message string describing the failure."}, {"name": "error_code", "is_optional": false, "type": "others", "description": "The error_codes_pb2.Code describing the error."}]}},
{"id": "tf.errors.DataLossError", "type": "function", "code": "tf.errors.DataLossError(node_def,op,message)", "summary": "Raised when unrecoverable data loss or corruption is encountered.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.DataLossError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.CancelledError", "type": "function", "code": "tf.errors.CancelledError(node_def,op,message)", "summary": "Raised when an operation or step is cancelled.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.CancelledError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.InvalidArgumentError", "type": "function", "code": "tf.errors.InvalidArgumentError(node_def,op,message)", "summary": "Raised when an operation receives an invalid argument.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.InvalidArgumentError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.InternalError", "type": "function", "code": "tf.errors.InternalError(node_def,op,message)", "summary": "Raised when the system experiences an internal error.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.InternalError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.DeadlineExceededError", "type": "function", "code": "tf.errors.DeadlineExceededError(node_def,op,message)", "summary": "Raised when a deadline expires before an operation could complete.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.DeadlineExceededError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.FailedPreconditionError", "type": "function", "code": "tf.errors.FailedPreconditionError(node_def,op,message)", "summary": "Operation was rejected because the system is not in a state to execute it.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.FailedPreconditionError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.NotFoundError", "type": "function", "code": "tf.errors.NotFoundError(node_def,op,message)", "summary": "Raised when a requested entity (e.g., a file or directory) was not found.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.NotFoundError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.AlreadyExistsError", "type": "function", "code": "tf.errors.AlreadyExistsError(node_def,op,message)", "summary": "Raised when an entity that we attempted to create already exists.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.AlreadyExistsError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.errors.AbortedError", "type": "function", "code": "tf.errors.AbortedError(node_def,op,message)", "summary": "The operation was aborted, typically due to a concurrent action.\n\nInherits From: OpError", "description": "", "code-info": {"name": "tf.errors.AbortedError", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "  The NodeDef proto representing the op that failed."}, {"name": "op", "is_optional": false, "type": "others", "description": "  The operation that failed, if known.\n\nN.B. If the failed op was synthesized at runtime, e.g. a Send\nor Recv op, there will be no corresponding\ntf.Operation\nobject.  In that case, this will return None, and you should\ninstead use the tf.errors.OpError.node_def to\ndiscover information about the op.\n\n\n          "}, {"name": "message", "is_optional": false, "type": "others", "description": "  The error message that describes the error.\nnode_def:   The NodeDef proto representing the op that failed.\nop:   The operation that failed, if known."}]}},
{"id": "tf.dtypes.saturate_cast", "type": "function", "code": "tf.dtypes.saturate_cast(value,dtype,name=None)", "summary": "Performs a safe saturating cast of value to dtype.", "description": "", "code-info": {"name": "tf.dtypes.saturate_cast", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "dtype", "is_optional": false, "type": "others", "description": "The desired output DType."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.dtypes.DType", "type": "class", "code": "tf.dtypes.DType(type_enum)", "summary": "Represents the type of the elements in a Tensor.", "description": "", "code-info": {"name": "tf.dtypes.DType", "parameters": [{"name": "type_enum", "is_optional": false, "type": "others", "description": "A types_pb2.DataType enum value."}]}},
{"id": "tf.distribute.experimental.CentralStorageStrategy", "type": "function", "code": "tf.distribute.experimental.CentralStorageStrategy(compute_devices=None,parameter_device=None)", "summary": "A one-machine strategy that puts all variables on a single device.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.experimental.CentralStorageStrategy", "parameters": [{"name": "compute_devices", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "parameter_device", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.dtypes.complex", "type": "function", "code": "tf.dtypes.complex(real,imag,name=None)", "summary": "Converts two real numbers to a complex number.", "description": "", "code-info": {"name": "tf.dtypes.complex", "parameters": [{"name": "real", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64."}, {"name": "imag", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as real."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.distribute.experimental.TPUStrategy", "type": "class", "code": "tf.distribute.experimental.TPUStrategy(tpu_cluster_resolver=None,device_assignment=None)", "summary": "TPU distribution strategy implementation.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.experimental.TPUStrategy", "parameters": [{"name": "tpu_cluster_resolver", "is_optional": true, "type": "string", "default_value": "None", "description": "A tf.distribute.cluster_resolver.TPUClusterResolver,\nwhich provides information about the TPU cluster."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tf.tpu.experimental.DeviceAssignment to\nspecify the placement of replicas on the TPU cluster. Currently only\nsupports the usecase of using a single core within a TPU cluster."}]}},
{"id": "tf.distribute.experimental.ParameterServerStrategy", "type": "function", "code": "tf.distribute.experimental.ParameterServerStrategy(cluster_resolver=None)", "summary": "An asynchronous multi-worker parameter server tf.distribute strategy.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.experimental.ParameterServerStrategy", "parameters": [{"name": "cluster_resolver", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.distribute.experimental.MultiWorkerMirroredStrategy", "type": "class", "code": "tf.distribute.experimental.MultiWorkerMirroredStrategy(communication=tf.distribute.experimental.CollectiveCommunication.AUTO,cluster_resolver=None)", "summary": "A distribution strategy for synchronous training on multiple workers.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.experimental.MultiWorkerMirroredStrategy", "parameters": [{"name": "communication", "is_optional": true, "type": "string", "default_value": "tf.distribute.experimental.CollectiveCommunication.AUTO", "description": "optional Enum of type\ndistribute.experimental.CollectiveCommunication.  This provides a way\nfor the user to override the choice of collective op communication.\nPossible values include AUTO, RING, and NCCL."}, {"name": "cluster_resolver", "is_optional": true, "type": "string", "default_value": "None", "description": "optional distribute.cluster_resolver.ClusterResolver\nobject. The default ClusterResolver that is used is the\nTFConfigClusterResolver which is instantiated from the TF_CONFIG env\nvar."}]}},
{"id": "tf.distribute.cluster_resolver.UnionResolver", "type": "class", "code": "tf.distribute.cluster_resolver.UnionResolver(*args,**kwargs)", "summary": "Performs a union on underlying ClusterResolvers.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.UnionResolver", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": "ClusterResolver objects to be unionized."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "  rpc_layer - (Optional) Override value for the RPC layer used by\nTensorFlow.\ntask_type - (Optional) Override value for the current task type.\ntask_id - (Optional) Override value for the current task index."}]}},
{"id": "tf.dtypes.as_dtype", "type": "function", "code": "tf.dtypes.as_dtype(type_value)", "summary": "Converts the given type_value to a DType.", "description": "", "code-info": {"name": "tf.dtypes.as_dtype", "parameters": [{"name": "type_value", "is_optional": false, "type": "others", "description": "A value that can be converted to a tf.DType object. This may\ncurrently be a tf.DType object, a DataType\nenum,\na string type name, or a numpy.dtype."}]}},
{"id": "tf.distribute.cluster_resolver.SlurmClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.SlurmClusterResolver(jobs,port_base=8888,gpus_per_node=1,gpus_per_task=1,tasks_per_node=None,auto_set_gpu=True,rpc_layer='grpc')", "summary": "ClusterResolver for system with Slurm workload manager.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.SlurmClusterResolver", "parameters": [{"name": "jobs", "is_optional": false, "type": "string", "description": "Dictionary with job names as key and number of tasks in the job as\nvalue."}, {"name": "port_base", "is_optional": true, "type": "int", "default_value": "8888", "description": "The first port number to start with for processes on a node."}, {"name": "gpus_per_node", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of GPUs available on each node."}, {"name": "gpus_per_task", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of GPUs to be used for each task."}, {"name": "tasks_per_node", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of tasks to run on each node, if not set defaults\nto Slurm's output environment variable SLURM_NTASKS_PER_NODE."}, {"name": "auto_set_gpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "Set the visible CUDA devices automatically while resolving\nthe cluster by setting CUDA_VISIBLE_DEVICES environment variable.\nDefaults to True."}, {"name": "rpc_layer", "is_optional": true, "type": "string", "default_value": "'grpc'", "description": "(Optional) The protocol TensorFlow uses to communicate between\nnodes. Defaults to 'grpc'."}]}},
{"id": "tf.distribute.cluster_resolver.SimpleClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.SimpleClusterResolver(cluster_spec,master='',task_type=None,task_id=None,environment='',num_accelerators=None,rpc_layer=None)", "summary": "Simple implementation of ClusterResolver that accepts a ClusterSpec.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.SimpleClusterResolver", "parameters": [{"name": "cluster_spec", "is_optional": false, "type": "others", "description": ""}, {"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": ""}, {"name": "task_type", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional) The type of the TensorFlow task of the master."}, {"name": "task_id", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional) The index of the TensorFlow task of the master.\nrpc_layer: (Optional) The RPC used by distributed TensorFlow.\n\n\nReturns:\n\nThe name or URL of the session master.\n\nIf a task_type and task_id is given, this will override the master\nstring passed into the initialization function.\n\nnum_accelerators\n\nView source\nnum_accelerators(\n    task_type=None, task_id=None, config_proto=None\n)\n\nReturns the number of accelerator cores per worker.\n\nThe SimpleClusterResolver does not do automatic detection of accelerators,\nso a TensorFlow session will never be created, and thus all arguments are\nunused and we simply assume that the type of accelerator is a GPU and return\nthe value in provided to us in the constructor.\n\nArgs:\n\n\ntask_type: Unused."}, {"name": "environment", "is_optional": true, "type": "string", "default_value": "''", "description": ""}, {"name": "num_accelerators", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "rpc_layer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional) The RPC used by distributed TensorFlow."}]}},
{"id": "tf.distribute.cluster_resolver.KubernetesClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.KubernetesClusterResolver(job_to_label_mapping=None,tf_server_port=8470,rpc_layer='grpc',override_client=None)", "summary": "ClusterResolver for Kubernetes.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.KubernetesClusterResolver", "parameters": [{"name": "job_to_label_mapping", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A mapping of TensorFlow jobs to label selectors.\nThis allows users to specify many TensorFlow jobs in one Cluster\nResolver, and each job can have pods belong with different label\nselectors. For example, a sample mapping might be\n\n\n\n{'worker': ['job-name=worker-cluster-a', 'job-name=worker-cluster-b'],\n 'ps': ['job-name=ps-1', 'job-name=ps-2']}\n\n\n"}, {"name": "tf_server_port", "is_optional": true, "type": "int", "default_value": "8470", "description": "The port the TensorFlow server is listening on."}, {"name": "rpc_layer", "is_optional": true, "type": "string", "default_value": "'grpc'", "description": "(Optional) The RPC layer TensorFlow should use to communicate\nbetween tasks in Kubernetes. Defaults to 'grpc'."}, {"name": "override_client", "is_optional": true, "type": "others", "default_value": "None", "description": "The Kubernetes client (usually automatically retrieved\nusing from kubernetes import client as k8sclient). If you pass this\nin, you are responsible for setting Kubernetes credentials manually."}]}},
{"id": "cluster_spec", "type": "class", "code": "cluster_spec()", "summary": "Abstract class for all implementations of ClusterResolvers.", "description": "", "code-info": {"name": "cluster_spec", "parameters": []}},
{"id": "tf.distribute.cluster_resolver.TPUClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.TPUClusterResolver(tpu=None,zone=None,project=None,job_name='worker',coordinator_name=None,coordinator_address=None,credentials='default',service=None,discovery_url=None)", "summary": "Cluster Resolver for Google Cloud TPUs.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.TPUClusterResolver", "parameters": [{"name": "tpu", "is_optional": true, "type": "string", "default_value": "None", "description": "A string corresponding to the TPU to use. If the string is an empty\nstring, the string 'local', or a string that begins with 'grpc://',\nthen it is assumed to not correspond with a Cloud TPU and will\ninstead be passed as the session master and no ClusterSpec propagation\nwill be done. In the future, this may also support a list of strings\nwhen multiple Cloud TPUs are used."}, {"name": "zone", "is_optional": true, "type": "others", "default_value": "None", "description": "Zone where the TPUs are located. If omitted or empty, we will assume\nthat the zone of the TPU is the same as the zone of the GCE VM, which we\nwill try to discover from the GCE metadata service."}, {"name": "project", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the GCP project containing Cloud TPUs. If omitted or\nempty, we will try to discover the project name of the GCE VM from the\nGCE metadata service."}, {"name": "job_name", "is_optional": true, "type": "string", "default_value": "'worker'", "description": "Name of the TensorFlow job the TPUs belong to."}, {"name": "coordinator_name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name to use for the coordinator. Set to None if the\ncoordinator should not be included in the computed ClusterSpec."}, {"name": "coordinator_address", "is_optional": true, "type": "others", "default_value": "None", "description": "The address of the coordinator (typically an ip:port\npair). If set to None, a TF server will be started. If coordinator_name\nis None, a TF server will not be started even if coordinator_address is\nNone."}, {"name": "credentials", "is_optional": true, "type": "string", "default_value": "'default'", "description": "GCE Credentials. If None, then we use default credentials\nfrom the oauth2client"}, {"name": "service", "is_optional": true, "type": "others", "default_value": "None", "description": "The GCE API object returned by the googleapiclient.discovery\nfunction. If you specify a custom service object, then the credentials\nparameter will be ignored."}, {"name": "discovery_url", "is_optional": true, "type": "others", "default_value": "None", "description": "A URL template that points to the location of the discovery\nservice. It should have two parameters {api} and {apiVersion} that when\nfilled in produce an absolute URL to the discovery document for that\nservice. The environment variable 'TPU_API_DISCOVERY_URL' will override\nthis."}]}},
{"id": "tf.distribute.cluster_resolver.TFConfigClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.TFConfigClusterResolver(task_type=None,task_id=None,rpc_layer=None,environment=None)", "summary": "Implementation of a ClusterResolver which reads the TF_CONFIG EnvVar.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.TFConfigClusterResolver", "parameters": [{"name": "task_type", "is_optional": true, "type": "string", "default_value": "None", "description": "(String, optional) Overrides the task type specified in the\nTF_CONFIG environment variable."}, {"name": "task_id", "is_optional": true, "type": "int", "default_value": "None", "description": "(Integer, optional) Overrides the task index specified in the\nTF_CONFIG environment variable."}, {"name": "rpc_layer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(String, optional) Overrides the rpc layer TensorFlow uses."}, {"name": "environment", "is_optional": true, "type": "string", "default_value": "None", "description": "(String, optional) Overrides the environment TensorFlow\noperates in."}]}},
{"id": "tf.distribute.Strategy", "type": "function", "code": "tf.distribute.Strategy(extended)", "summary": "A state &amp; compute distribution policy on a list of devices.", "description": "", "code-info": {"name": "tf.distribute.Strategy", "parameters": [{"name": "extended", "is_optional": false, "type": "string", "description": "  tf.distribute.StrategyExtended with additional methods.\nnum_replicas_in_sync:   Returns number of replicas over which gradients are aggregated."}]}},
{"id": "tf.distribute.cluster_resolver.GCEClusterResolver", "type": "class", "code": "tf.distribute.cluster_resolver.GCEClusterResolver(project,zone,instance_group,port,task_type='worker',task_id=0,rpc_layer='grpc',credentials='default',service=None)", "summary": "ClusterResolver for Google Compute Engine.\n\nInherits From: ClusterResolver", "description": "", "code-info": {"name": "tf.distribute.cluster_resolver.GCEClusterResolver", "parameters": [{"name": "project", "is_optional": false, "type": "string", "description": "Name of the GCE project."}, {"name": "zone", "is_optional": false, "type": "others", "description": "Zone of the GCE instance group."}, {"name": "instance_group", "is_optional": false, "type": "string", "description": "Name of the GCE instance group."}, {"name": "port", "is_optional": false, "type": "tensor", "description": "Port of the listening TensorFlow server (default: 8470)"}, {"name": "task_type", "is_optional": true, "type": "string", "default_value": "'worker'", "description": "Name of the TensorFlow job this GCE instance group of VM\ninstances belong to."}, {"name": "task_id", "is_optional": true, "type": "int", "default_value": "0", "description": "The task index for this particular VM, within the GCE\ninstance group. In particular, every single instance should be assigned\na unique ordinal index within an instance group manually so that they\ncan be distinguished from each other."}, {"name": "rpc_layer", "is_optional": true, "type": "string", "default_value": "'grpc'", "description": "The RPC layer TensorFlow should use to communicate across\ninstances."}, {"name": "credentials", "is_optional": true, "type": "string", "default_value": "'default'", "description": "GCE Credentials. If nothing is specified, this defaults to\nGoogleCredentials.get_application_default()."}, {"name": "service", "is_optional": true, "type": "others", "default_value": "None", "description": "The GCE API object returned by the googleapiclient.discovery\nfunction. (Default: discovery.build('compute', 'v1')). If you specify a\ncustom service object, then the credentials parameter will be ignored."}]}},
{"id": "tf.distribute.Server", "type": "class", "code": "tf.distribute.Server(server_or_cluster_def,job_name=None,task_index=None,protocol=None,config=None,start=True)", "summary": "An in-process TensorFlow server, for use in distributed training.", "description": "", "code-info": {"name": "tf.distribute.Server", "parameters": [{"name": "server_or_cluster_def", "is_optional": false, "type": "others", "description": "A tf.train.ServerDef or tf.train.ClusterDef\nprotocol buffer, or a tf.train.ClusterSpec object, describing the\nserver to be created and/or the cluster of which it is a member."}, {"name": "job_name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) Specifies the name of the job of which the server is\na member. Defaults to the value in server_or_cluster_def, if\nspecified."}, {"name": "task_index", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Specifies the task index of the server in its job.\nDefaults to the value in server_or_cluster_def, if specified.\nOtherwise defaults to 0 if the server's job has only one task."}, {"name": "protocol", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Specifies the protocol to be used by the server.\nAcceptable values include \"grpc\", \"grpc+verbs\". Defaults to the value\nin server_or_cluster_def, if specified. Otherwise defaults to\n\"grpc\"."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "(Options.) A tf.compat.v1.ConfigProto that specifies default\nconfiguration options for all sessions that run on this server."}, {"name": "start", "is_optional": true, "type": "bool", "default_value": "True", "description": "(Optional.) Boolean, indicating whether to start the server after\ncreating it. Defaults to True."}]}},
{"id": "tf.distribute.NcclAllReduce", "type": "function", "code": "tf.distribute.NcclAllReduce(num_packs=1)", "summary": "Reduction using NCCL all-reduce.", "description": "", "code-info": {"name": "tf.distribute.NcclAllReduce", "parameters": [{"name": "num_packs", "is_optional": true, "type": "int", "default_value": "1", "description": "values will be packed in this many splits.  num_packs should\nbe greater than or equals 0. When it is zero, no packing will be done."}]}},
{"id": "tf.distribute.StrategyExtended", "type": "function", "code": "tf.distribute.StrategyExtended(container_strategy)", "summary": "Additional APIs for algorithms that need to be distribution-aware.", "description": "", "code-info": {"name": "tf.distribute.StrategyExtended", "parameters": [{"name": "container_strategy", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.distribute.MirroredStrategy", "type": "class", "code": "tf.distribute.MirroredStrategy(devices=None,cross_device_ops=None)", "summary": "Mirrors vars to distribute across multiple devices and machines.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.MirroredStrategy", "parameters": [{"name": "devices", "is_optional": true, "type": "string", "default_value": "None", "description": "a list of device strings.  If None, all available GPUs are used.\nIf no GPUs are found, CPU is used."}, {"name": "cross_device_ops", "is_optional": true, "type": "others", "default_value": "None", "description": "optional, a descedant of CrossDeviceOps. If this is not\nset, nccl will be used by default."}]}},
{"id": "tf.distribute.ReductionToOneDevice", "type": "function", "code": "tf.distribute.ReductionToOneDevice(reduce_to_device=None,accumulation_fn=None)", "summary": "Always do reduction to one device first and then do broadcasting.\n\nInherits From: CrossDeviceOps", "description": "", "code-info": {"name": "tf.distribute.ReductionToOneDevice", "parameters": [{"name": "reduce_to_device", "is_optional": true, "type": "others", "default_value": "None", "description": "the intermediate device to reduce to. If None, reduce\nto the first device in destinations of the reduce() method."}, {"name": "accumulation_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "a function that does accumulation.  If None, then\ntf.math.add_n is used."}]}},
{"id": "tf.distribute.InputContext", "type": "class", "code": "tf.distribute.InputContext(num_input_pipelines=1,input_pipeline_id=0,num_replicas_in_sync=1)", "summary": "A class wrapping information needed by an input function.", "description": "", "code-info": {"name": "tf.distribute.InputContext", "parameters": [{"name": "num_input_pipelines", "is_optional": true, "type": "int", "default_value": "1", "description": "the number of input pipelines in a cluster."}, {"name": "input_pipeline_id", "is_optional": true, "type": "int", "default_value": "0", "description": "the current input pipeline id, should be an int in\n[0,num_input_pipelines)."}, {"name": "num_replicas_in_sync", "is_optional": true, "type": "int", "default_value": "1", "description": "the number of replicas that are in sync."}]}},
{"id": "tf.distribute.OneDeviceStrategy", "type": "class", "code": "tf.distribute.OneDeviceStrategy(device)", "summary": "A distribution strategy for running on a single device.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.distribute.OneDeviceStrategy", "parameters": [{"name": "device", "is_optional": false, "type": "string", "description": "Device string identifier for the device on which the variables\nshould be placed. See class docs for more details on how the device is\nused. Examples: \"/cpu:0\", \"/gpu:0\", \"/device:CPU:0\", \"/device:GPU:0\""}]}},
{"id": "tf.distribute.in_cross_replica_context", "type": "function", "code": "tf.distribute.in_cross_replica_context()", "summary": "Returns True if in a cross-replica context.", "description": "", "code-info": {"name": "tf.distribute.in_cross_replica_context", "parameters": []}},
{"id": "tf.distribute.ReplicaContext", "type": "function", "code": "tf.distribute.ReplicaContext(strategy,replica_id_in_sync_group)", "summary": "tf.distribute.Strategy API when in a replica context.", "description": "", "code-info": {"name": "tf.distribute.ReplicaContext", "parameters": [{"name": "strategy", "is_optional": false, "type": "string", "description": "  The current tf.distribute.Strategy object.\n\n\nMethods\n\n__enter__\n\nView source\n__enter__()\n\n__exit__\n\nView source\n__exit__(\n    exception_type, exception_value, traceback\n)\n\nall_reduce\n\nView source\nall_reduce(\n    reduce_op, value\n)\n\nAll-reduces the given value Tensor nest across replicas.\n\nIf all_reduce is called in any replica, it must be called in all replicas.\nThe nested structure and Tensor shapes must be identical in all replicas.\n\nIMPORTANT: The ordering of communications must be identical in all replicas.\n\nExample with two replicas:\n  Replica 0 value: {'a': 1, 'b': [40, 1]}\n  Replica 1 value: {'a': 3, 'b': [ 2, 98]}\n\nIf reduce_op == SUM:\n    Result (on all replicas): {'a': 4, 'b': [42, 99]}\n\nIf reduce_op == MEAN:\n    Result (on all replicas): {'a': 2, 'b': [21, 49.5]}\n\nArgs:\n\n\nreduce_op: Reduction type, an instance of tf.distribute.ReduceOp enum.\nvalue: The nested structure of Tensors to all-reduce. The structure must\nbe compatible with tf.nest.\n\n\nReturns:\n\nA Tensor nest with the reduced values from each replica.\n\nmerge_call\n\nView source\nmerge_call(\n    merge_fn, args=(), kwargs=None\n)\n\nMerge args across replicas and run merge_fn in a cross-replica context.\n\nThis allows communication and coordination when there are multiple calls\nto the step_fn triggered by a call to\nstrategy.experimental_run_v2(step_fn, ...).\n\nSee tf.distribute.Strategy.experimental_run_v2 for an\nexplanation.\n\nIf not inside a distributed scope, this is equivalent to:\nstrategy = tf.distribute.get_strategy()\nwith cross-replica-context(strategy):\n  return merge_fn(strategy, *args, **kwargs)\n\nArgs:\n\n\nmerge_fn: Function that joins arguments from threads that are given as\nPerReplica. It accepts tf.distribute.Strategy object as\nthe first argument.\nargs: List or tuple with positional per-thread arguments for merge_fn.\nkwargs: Dict with keyword per-thread arguments for merge_fn.\n\n\nReturns:\n\nThe return value of merge_fn, except for PerReplica values which are\nunpacked.\n\n          "}, {"name": "replica_id_in_sync_group", "is_optional": false, "type": "others", "description": "  Returns the id of the replica being defined."}]}},
{"id": "tf.distribute.has_strategy", "type": "function", "code": "tf.distribute.has_strategy()", "summary": "Return if there is a current non-default tf.distribute.Strategy.", "description": "", "code-info": {"name": "tf.distribute.has_strategy", "parameters": []}},
{"id": "tf.distribute.HierarchicalCopyAllReduce", "type": "function", "code": "tf.distribute.HierarchicalCopyAllReduce(num_packs=1)", "summary": "Reduction using hierarchical copy all-reduce.", "description": "", "code-info": {"name": "tf.distribute.HierarchicalCopyAllReduce", "parameters": [{"name": "num_packs", "is_optional": true, "type": "int", "default_value": "1", "description": "values will be packed in this many splits.  num_packs should\nbe greater than or equals 0. When it is zero, no packing will be done."}]}},
{"id": "tf.distribute.get_strategy", "type": "function", "code": "tf.distribute.get_strategy()", "summary": "Returns the current tf.distribute.Strategy object.", "description": "", "code-info": {"name": "tf.distribute.get_strategy", "parameters": []}},
{"id": "tf.distribute.get_replica_context", "type": "function", "code": "tf.distribute.get_replica_context()", "summary": "Returns the current tf.distribute.ReplicaContext or None.", "description": "", "code-info": {"name": "tf.distribute.get_replica_context", "parameters": []}},
{"id": "tf.distribute.experimental_set_strategy", "type": "function", "code": "tf.distribute.experimental_set_strategy(strategy)", "summary": "Set a tf.distribute.Strategy as current without with strategy.scope().", "description": "", "code-info": {"name": "tf.distribute.experimental_set_strategy", "parameters": [{"name": "strategy", "is_optional": false, "type": "string", "description": "A tf.distribute.Strategy object or None."}]}},
{"id": "tf.distribute.CrossDeviceOps", "type": "function", "code": "tf.distribute.CrossDeviceOps()", "summary": "Base class for cross-device reduction and broadcasting algorithms.", "description": "", "code-info": {"name": "tf.distribute.CrossDeviceOps", "parameters": []}},
{"id": "tf.debugging.experimental.enable_dump_debug_info", "type": "function", "code": "tf.debugging.experimental.enable_dump_debug_info(dump_root,tensor_debug_mode=DEFAULT_TENSOR_DEBUG_MODE,circular_buffer_size=1000,op_regex=None,tensor_dtypes=None)", "summary": "Enable dumping debugging information from a TensorFlow program.", "description": "", "code-info": {"name": "tf.debugging.experimental.enable_dump_debug_info", "parameters": [{"name": "dump_root", "is_optional": false, "type": "others", "description": "The directory path where the dumping information will be written."}, {"name": "tensor_debug_mode", "is_optional": true, "type": "tensor", "default_value": "DEFAULT_TENSOR_DEBUG_MODE", "description": "Debug mode for tensor values, as a string.\nThe currently supported options are:\n\n\"NO_TENSOR\": (Default) Only traces the execution of ops' output\ntensors, while not dumping the value of the ops' output tensors\nor any form of concise summary of them.\n"}, {"name": "circular_buffer_size", "is_optional": true, "type": "int", "default_value": "1000", "description": "Size of the circular buffers for execution events.\nThese circular buffers are designed to reduce the overhead of debugging\ndumping. They hold the most recent debug events concerning eager execution\nof ops and tf.functions and traces of tensor values computed inside\ntf.functions. They are written to the file system only when the proper\nflushing method is called (see description of return values below).\nExpected to be an integer. If &lt;= 0, the circular-buffer behavior will be\ndisabled, i.e., the execution debug events will be written to the file\nwriters in the same way as non-execution events such as op creations and\nsource-file snapshots."}, {"name": "op_regex", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Dump data from only the tensors from op types that matches to the\nregular expression (through Python's re.match()).\n\"Op type\" refers to the names of the TensorFlow operations (e.g.,\n\"MatMul\", \"LogSoftmax\"), which may repeat in a TensorFlow\nfunction. It does not refer to the names of nodes (e.g.,\n\"dense/MatMul\", \"dense_1/MatMul_1\") which are unique within a function.\n\nExample 1: Dump tensor data from only MatMul and Relu ops\nop_regex=\"^(MatMul|Relu)$\".\nExample 2: Dump tensors from all ops except Relu:\nop_regex=\"(?!^Relu$)\".\nThis filter operates in a logical AND relation with tensor_dtypes.\n"}, {"name": "tensor_dtypes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Dump data from only the tensors of which the specified\ndtypes. This optional argument can be in any of the following format:"}]}},
{"id": "tf.debugging.enable_check_numerics", "type": "function", "code": "tf.debugging.enable_check_numerics(stack_height_limit=30,path_length_limit=50)", "summary": "Enable tensor numerics checking in an eager/graph unified fashion.", "description": "", "code-info": {"name": "tf.debugging.enable_check_numerics", "parameters": [{"name": "stack_height_limit", "is_optional": true, "type": "int", "default_value": "30", "description": "Limit to the height of the printed stack trace.\nApplicable only to ops in tf.functions (graphs)."}, {"name": "path_length_limit", "is_optional": true, "type": "int", "default_value": "50", "description": "Limit to the file path included in the printed stack\ntrace. Applicable only to ops in tf.functions (graphs)."}]}},
{"id": "tf.debugging.is_numeric_tensor", "type": "function", "code": "tf.debugging.is_numeric_tensor(tensor)", "summary": "Returns True if the elements of tensor are numbers.", "description": "", "code-info": {"name": "tf.debugging.is_numeric_tensor", "parameters": [{"name": "tensor", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.debugging.experimental.disable_dump_debug_info", "type": "function", "code": "tf.debugging.experimental.disable_dump_debug_info()", "summary": "Disable the currently-enabled debugging dumping.", "description": "", "code-info": {"name": "tf.debugging.experimental.disable_dump_debug_info", "parameters": []}},
{"id": "tf.debugging.get_log_device_placement", "type": "function", "code": "tf.debugging.get_log_device_placement()", "summary": "Get if device placements are logged.", "description": "", "code-info": {"name": "tf.debugging.get_log_device_placement", "parameters": []}},
{"id": "tf.debugging.set_log_device_placement", "type": "function", "code": "tf.debugging.set_log_device_placement(enabled)", "summary": "Set if device placements should be logged.", "description": "", "code-info": {"name": "tf.debugging.set_log_device_placement", "parameters": [{"name": "enabled", "is_optional": false, "type": "others", "description": "Whether to enabled device placement logging."}]}},
{"id": "tf.debugging.assert_shapes", "type": "function", "code": "tf.debugging.assert_shapes(shapes,data=None,summarize=None,message=None,name=None)", "summary": "Assert tensor shapes and dimension size relationships between tensors.", "description": "", "code-info": {"name": "tf.debugging.assert_shapes", "parameters": [{"name": "shapes", "is_optional": false, "type": "tensor", "description": "dictionary with (Tensor to shape) items. A shape must be an\niterable."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The tensors to print out if the condition is False.  Defaults to error\nmessage and first few entries of the violating tensor."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of the tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_shapes\"."}]}},
{"id": "tf.debugging.assert_same_float_dtype", "type": "function", "code": "tf.debugging.assert_same_float_dtype(tensors=None,dtype=None)", "summary": "Validate and return float type based on tensors and dtype.", "description": "", "code-info": {"name": "tf.debugging.assert_same_float_dtype", "parameters": [{"name": "tensors", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensors of input values. Can include None elements, which will be\nignored."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Expected type."}]}},
{"id": "tf.debugging.assert_scalar", "type": "function", "code": "tf.debugging.assert_scalar(tensor,message=None,name=None)", "summary": "Asserts that the given tensor is a scalar.", "description": "", "code-info": {"name": "tf.debugging.assert_scalar", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this operation. Defaults to \"assert_scalar\""}]}},
{"id": "tf.debugging.assert_type", "type": "function", "code": "tf.debugging.assert_type(tensor,tf_type,message=None,name=None)", "summary": "Asserts that the given Tensor is of the specified type.", "description": "", "code-info": {"name": "tf.debugging.assert_type", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "tf_type", "is_optional": false, "type": "tensor", "description": "A tensorflow type (dtypes.float32, tf.int64, dtypes.bool,\netc)."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this operation. Defaults to \"assert_type\""}]}},
{"id": "tf.debugging.disable_check_numerics", "type": "function", "code": "tf.debugging.disable_check_numerics()", "summary": "Disable the eager/graph unified numerics checking mechanism.", "description": "", "code-info": {"name": "tf.debugging.disable_check_numerics", "parameters": []}},
{"id": "tf.debugging.assert_rank", "type": "function", "code": "tf.debugging.assert_rank(x,rank,message=None,name=None)", "summary": "Assert that x has rank equal to rank.", "description": "", "code-info": {"name": "tf.debugging.assert_rank", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor."}, {"name": "rank", "is_optional": false, "type": "tensor", "description": "Scalar integer Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to\n\"assert_rank\"."}]}},
{"id": "tf.debugging.assert_rank_in", "type": "function", "code": "tf.debugging.assert_rank_in(x,ranks,message=None,name=None)", "summary": "Assert that x has a rank in ranks.", "description": "", "code-info": {"name": "tf.debugging.assert_rank_in", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor."}, {"name": "ranks", "is_optional": false, "type": "tensor", "description": "Iterable of scalar Tensor objects."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to \"assert_rank_in\"."}]}},
{"id": "tf.debugging.check_numerics", "type": "function", "code": "tf.debugging.check_numerics(tensor,message,name=None)", "summary": "Checks a tensor for NaN and Inf values.", "description": "", "code-info": {"name": "tf.debugging.check_numerics", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64."}, {"name": "message", "is_optional": false, "type": "string", "description": "A string. Prefix of the error message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.debugging.assert_rank_at_least", "type": "function", "code": "tf.debugging.assert_rank_at_least(x,rank,message=None,name=None)", "summary": "Assert that x has rank of at least rank.", "description": "", "code-info": {"name": "tf.debugging.assert_rank_at_least", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor."}, {"name": "rank", "is_optional": false, "type": "tensor", "description": "Scalar integer Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to\n\"assert_rank_at_least\"."}]}},
{"id": "tf.debugging.assert_proper_iterable", "type": "function", "code": "tf.debugging.assert_proper_iterable(values)", "summary": "Static assert that values is a \"proper\" iterable.", "description": "", "code-info": {"name": "tf.debugging.assert_proper_iterable", "parameters": [{"name": "values", "is_optional": false, "type": "others", "description": " Object to be checked."}]}},
{"id": "tf.debugging.assert_none_equal", "type": "function", "code": "tf.debugging.assert_none_equal(x,y,summarize=None,message=None,name=None)", "summary": "Assert the condition x != y holds for all elements.", "description": "", "code-info": {"name": "tf.debugging.assert_none_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to\n\"assert_none_equal\"."}]}},
{"id": "tf.debugging.assert_less", "type": "function", "code": "tf.debugging.assert_less(x,y,message=None,summarize=None,name=None)", "summary": "Assert the condition x &lt; y holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_less", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_less\"."}]}},
{"id": "tf.debugging.assert_less_equal", "type": "function", "code": "tf.debugging.assert_less_equal(x,y,message=None,summarize=None,name=None)", "summary": "Assert the condition x &lt;= y holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_less_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to \"assert_less_equal\"."}]}},
{"id": "tf.debugging.assert_positive", "type": "function", "code": "tf.debugging.assert_positive(x,message=None,summarize=None,name=None)", "summary": "Assert the condition x &gt; 0 holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_positive", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to \"assert_positive\"."}]}},
{"id": "tf.debugging.assert_negative", "type": "function", "code": "tf.debugging.assert_negative(x,message=None,summarize=None,name=None)", "summary": "Assert the condition x &lt; 0 holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_negative", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_negative\"."}]}},
{"id": "tf.debugging.assert_non_positive", "type": "function", "code": "tf.debugging.assert_non_positive(x,message=None,summarize=None,name=None)", "summary": "Assert the condition x &lt;= 0 holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_non_positive", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to\n\"assert_non_positive\"."}]}},
{"id": "tf.debugging.assert_non_negative", "type": "function", "code": "tf.debugging.assert_non_negative(x,message=None,summarize=None,name=None)", "summary": "Assert the condition x &gt;= 0 holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_non_negative", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to\n\"assert_non_negative\"."}]}},
{"id": "tf.debugging.assert_integer", "type": "function", "code": "tf.debugging.assert_integer(x,message=None,name=None)", "summary": "Assert that x is of integer dtype.", "description": "", "code-info": {"name": "tf.debugging.assert_integer", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional). Defaults to \"assert_integer\"."}]}},
{"id": "tf.debugging.assert_near", "type": "function", "code": "tf.debugging.assert_near(x,y,rtol=None,atol=None,message=None,summarize=None,name=None)", "summary": "Assert the condition x and y are close element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_near", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Float or complex Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "Float or complex Tensor, same dtype as and broadcastable to x."}, {"name": "rtol", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Tensor.  Same dtype as, and broadcastable to, x.\nThe relative tolerance.  Default is 10 * eps."}, {"name": "atol", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Tensor.  Same dtype as, and broadcastable to, x.\nThe absolute tolerance.  Default is 10 * eps."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_near\"."}]}},
{"id": "tf.debugging.assert_greater_equal", "type": "function", "code": "tf.debugging.assert_greater_equal(x,y,message=None,summarize=None,name=None)", "summary": "Assert the condition x &gt;= y holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_greater_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to\n\"assert_greater_equal\"."}]}},
{"id": "tf.debugging.assert_greater", "type": "function", "code": "tf.debugging.assert_greater(x,y,message=None,summarize=None,name=None)", "summary": "Assert the condition x &gt; y holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_greater", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_greater\"."}]}},
{"id": "tf.debugging.assert_equal", "type": "function", "code": "tf.debugging.assert_equal(x,y,message=None,summarize=None,name=None)", "summary": "Assert the condition x == y holds element-wise.", "description": "", "code-info": {"name": "tf.debugging.assert_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_equal\"."}]}},
{"id": "tf.debugging.assert_all_finite", "type": "function", "code": "tf.debugging.assert_all_finite(x,message,name=None)", "summary": "Assert that the tensor does not contain any NaN's or Inf's.", "description": "", "code-info": {"name": "tf.debugging.assert_all_finite", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor to check."}, {"name": "message", "is_optional": false, "type": "others", "description": "Message to log on failure."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.data.experimental.unique", "type": "function", "code": "tf.data.experimental.unique()", "summary": "Creates a Dataset from another Dataset, discarding duplicates.", "description": "", "code-info": {"name": "tf.data.experimental.unique", "parameters": []}},
{"id": "tf.debugging.Assert", "type": "function", "code": "tf.debugging.Assert(condition,data,summarize=None,name=None)", "summary": "Asserts that the given condition is true.", "description": "", "code-info": {"name": "tf.debugging.Assert", "parameters": [{"name": "condition", "is_optional": false, "type": "others", "description": "The condition to evaluate."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "The tensors to print out when condition is false."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.data.experimental.unbatch", "type": "function", "code": "tf.data.experimental.unbatch()", "summary": "Splits elements of a dataset into multiple elements on the batch dimension. (deprecated)", "description": "", "code-info": {"name": "tf.data.experimental.unbatch", "parameters": []}},
{"id": "tf.data.experimental.TFRecordWriter", "type": "function", "code": "tf.data.experimental.TFRecordWriter(filename,compression_type=None)", "summary": "Writes a dataset to a TFRecord file.", "description": "", "code-info": {"name": "tf.data.experimental.TFRecordWriter", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "a string path indicating where to write the TFRecord data."}, {"name": "compression_type", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) a string indicating what type of compression\nto use when writing the file. See tf.io.TFRecordCompressionType for\nwhat types of compression are available. Defaults to None."}]}},
{"id": "tf.data.experimental.take_while", "type": "function", "code": "tf.data.experimental.take_while(predicate)", "summary": "A transformation that stops dataset iteration based on a predicate.", "description": "", "code-info": {"name": "tf.data.experimental.take_while", "parameters": [{"name": "predicate", "is_optional": false, "type": "tensor", "description": "A function that maps a nested structure of tensors (having shapes\nand types defined by self.output_shapes and self.output_types) to a\nscalar tf.bool tensor."}]}},
{"id": "tf.data.experimental.StatsOptions", "type": "function", "code": "tf.data.experimental.StatsOptions()", "summary": "Represents options for collecting dataset stats using StatsAggregator.", "description": "", "code-info": {"name": "tf.data.experimental.StatsOptions", "parameters": []}},
{"id": "tf.data.experimental.to_variant", "type": "function", "code": "tf.data.experimental.to_variant(dataset)", "summary": "Returns a variant representing the given dataset.", "description": "", "code-info": {"name": "tf.data.experimental.to_variant", "parameters": [{"name": "dataset", "is_optional": false, "type": "others", "description": "A tf.data.Dataset."}]}},
{"id": "tf.data.experimental.ThreadingOptions", "type": "function", "code": "tf.data.experimental.ThreadingOptions()", "summary": "Represents options for dataset threading.", "description": "", "code-info": {"name": "tf.data.experimental.ThreadingOptions", "parameters": []}},
{"id": "tf.data.experimental.StatsAggregator", "type": "function", "code": "tf.data.experimental.StatsAggregator()", "summary": "A stateful resource that aggregates statistics from one or more iterators.", "description": "", "code-info": {"name": "tf.data.experimental.StatsAggregator", "parameters": []}},
{"id": "tf.data.experimental.prefetch_to_device", "type": "function", "code": "tf.data.experimental.prefetch_to_device(device,buffer_size=None)", "summary": "A transformation that prefetches dataset values to the given device.", "description": "", "code-info": {"name": "tf.data.experimental.prefetch_to_device", "parameters": [{"name": "device", "is_optional": false, "type": "string", "description": "A string. The name of a device to which elements will be prefetched."}, {"name": "buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) The number of elements to buffer on device.\nDefaults to an automatically chosen value."}]}},
{"id": "tf.data.experimental.shuffle_and_repeat", "type": "function", "code": "tf.data.experimental.shuffle_and_repeat(buffer_size,count=None,seed=None)", "summary": "Shuffles and repeats a Dataset, reshuffling with each repetition. (deprecated)", "description": "", "code-info": {"name": "tf.data.experimental.shuffle_and_repeat", "parameters": [{"name": "buffer_size", "is_optional": false, "type": "tensor", "description": "A tf.int64 scalar tf.Tensor, representing the maximum\nnumber elements that will be buffered when prefetching."}, {"name": "count", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the number\nof times the dataset should be repeated. The default behavior (if count\nis None or -1) is for the dataset be repeated indefinitely."}, {"name": "seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the random\nseed that will be used to create the distribution. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.data.experimental.scan", "type": "function", "code": "tf.data.experimental.scan(initial_state,scan_func)", "summary": "A transformation that scans a function across an input dataset.", "description": "", "code-info": {"name": "tf.data.experimental.scan", "parameters": [{"name": "initial_state", "is_optional": false, "type": "tensor", "description": "A nested structure of tensors, representing the initial state\nof the accumulator."}, {"name": "scan_func", "is_optional": false, "type": "others", "description": "A function that maps (old_state, input_element) to\n(new_state, output_element). It must take two arguments and return a\npair of nested structures of tensors. Thenew_statemust match the\nstructure ofinitial_state`."}]}},
{"id": "tf.data.experimental.rejection_resample", "type": "function", "code": "tf.data.experimental.rejection_resample(class_func,target_dist,initial_dist=None,seed=None)", "summary": "A transformation that resamples a dataset to achieve a target distribution.", "description": "", "code-info": {"name": "tf.data.experimental.rejection_resample", "parameters": [{"name": "class_func", "is_optional": false, "type": "others", "description": "A function mapping an element of the input dataset to a scalar\ntf.int32 tensor. Values should be in [0, num_classes)."}, {"name": "target_dist", "is_optional": false, "type": "tensor", "description": "A floating point type tensor, shaped [num_classes]."}, {"name": "initial_dist", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.)  A floating point type tensor, shaped\n[num_classes].  If not provided, the true class distribution is\nestimated live in a streaming fashion."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "(Optional.) Python integer seed for the resampler."}]}},
{"id": "tf.data.experimental.RandomDataset", "type": "class", "code": "tf.data.experimental.RandomDataset(seed=None)", "summary": "A Dataset of pseudorandom values.", "description": "", "code-info": {"name": "tf.data.experimental.RandomDataset", "parameters": [{"name": "seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the random\nseed that will be used to create the distribution. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.data.experimental.sample_from_datasets", "type": "function", "code": "tf.data.experimental.sample_from_datasets(datasets,weights=None,seed=None)", "summary": "Samples elements at random from the datasets in datasets.", "description": "", "code-info": {"name": "tf.data.experimental.sample_from_datasets", "parameters": [{"name": "datasets", "is_optional": false, "type": "others", "description": "A list of tf.data.Dataset objects with compatible structure."}, {"name": "weights", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A list of len(datasets) floating-point values where\nweights[i] represents the probability with which an element should be\nsampled from datasets[i], or a tf.data.Dataset object where each\nelement is such a list. Defaults to a uniform distribution across\ndatasets."}, {"name": "seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the\nrandom seed that will be used to create the distribution. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.data.experimental.SqlDataset", "type": "class", "code": "tf.data.experimental.SqlDataset(driver_name,data_source_name,query,output_types)", "summary": "A Dataset consisting of the results from a SQL query.", "description": "", "code-info": {"name": "tf.data.experimental.SqlDataset", "parameters": [{"name": "driver_name", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing the database type.\nCurrently, the only supported value is 'sqlite'."}, {"name": "data_source_name", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing a connection string\nto connect to the database."}, {"name": "query", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing the SQL query to execute."}, {"name": "output_types", "is_optional": false, "type": "others", "description": "A tuple of tf.DType objects representing the types of the\ncolumns returned by query."}]}},
{"id": "tf.data.experimental.parse_example_dataset", "type": "function", "code": "tf.data.experimental.parse_example_dataset(features,num_parallel_calls=1)", "summary": "A transformation that parses Example protos into a dict of tensors.", "description": "", "code-info": {"name": "tf.data.experimental.parse_example_dataset", "parameters": [{"name": "features", "is_optional": false, "type": "others", "description": "A dict mapping feature keys to FixedLenFeature,\nVarLenFeature, RaggedFeature, and SparseFeature values."}, {"name": "num_parallel_calls", "is_optional": true, "type": "int", "default_value": "1", "description": "(Optional.) A tf.int32 scalar tf.Tensor,\nrepresenting the number of parsing processes to call in parallel."}]}},
{"id": "tf.data.experimental.parallel_interleave", "type": "function", "code": "tf.data.experimental.parallel_interleave(map_func,cycle_length,block_length=1,sloppy=False,buffer_output_elements=None,prefetch_input_elements=None)", "summary": "A parallel version of the Dataset.interleave() transformation. (deprecated)", "description": "", "code-info": {"name": "tf.data.experimental.parallel_interleave", "parameters": [{"name": "map_func", "is_optional": false, "type": "tensor", "description": "A function mapping a nested structure of tensors to a Dataset."}, {"name": "cycle_length", "is_optional": false, "type": "others", "description": "The number of input Datasets to interleave from in parallel."}, {"name": "block_length", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of consecutive elements to pull from an input\nDataset before advancing to the next input Dataset."}, {"name": "sloppy", "is_optional": true, "type": "bool", "default_value": "False", "description": "If false, elements are produced in deterministic order. Otherwise,\nthe implementation is allowed, for the sake of expediency, to produce\nelements in a non-deterministic order."}, {"name": "buffer_output_elements", "is_optional": true, "type": "others", "default_value": "None", "description": "The number of elements each iterator being\ninterleaved should buffer (similar to the .prefetch() transformation for\neach interleaved iterator)."}, {"name": "prefetch_input_elements", "is_optional": true, "type": "others", "default_value": "None", "description": "The number of input elements to transform to\niterators before they are needed for interleaving."}]}},
{"id": "tf.data.experimental.make_csv_dataset", "type": "function", "code": "tf.data.experimental.make_csv_dataset(file_pattern,batch_size,column_names=None,column_defaults=None,label_name=None,select_columns=None,field_delim=',',use_quote_delim=True,na_value='',header=True,num_epochs=None,shuffle=True,shuffle_buffer_size=10000,shuffle_seed=None,prefetch_buffer_size=None,num_parallel_reads=None,sloppy=False,num_rows_for_inference=100,compression_type=None,ignore_errors=False)", "summary": "Reads CSV files into a dataset.", "description": "", "code-info": {"name": "tf.data.experimental.make_csv_dataset", "parameters": [{"name": "file_pattern", "is_optional": false, "type": "others", "description": "List of files or patterns of file paths containing CSV\nrecords. See tf.io.gfile.glob for pattern rules."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "An int representing the number of records to combine\nin a single batch."}, {"name": "column_names", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional list of strings that corresponds to the CSV\ncolumns, in order. One per column of the input record. If this is not\nprovided, infers the column names from the first row of the records.\nThese names will be the keys of the features dict of each dataset element."}, {"name": "column_defaults", "is_optional": true, "type": "others", "default_value": "None", "description": "A optional list of default values for the CSV fields. One\nitem per selected column of the input record. Each item in the list is\neither a valid CSV dtype (float32, float64, int32, int64, or string), or a\nTensor with one of the aforementioned types. The tensor can either be\na scalar default value (if the column is optional), or an empty tensor (if\nthe column is required). If a dtype is provided instead of a tensor, the\ncolumn is also treated as required. If this list is not provided, tries\nto infer types based on reading the first num_rows_for_inference rows of\nfiles specified, and assumes all columns are optional, defaulting to 0\nfor numeric values and \"\" for string values. If both this and\nselect_columns are specified, these must have the same lengths, and\ncolumn_defaults is assumed to be sorted in order of increasing column\nindex."}, {"name": "label_name", "is_optional": true, "type": "string", "default_value": "None", "description": "A optional string corresponding to the label column. If\nprovided, the data for this column is returned as a separate Tensor from\nthe features dictionary, so that the dataset complies with the format\nexpected by a tf.Estimator.train or tf.Estimator.evaluate input\nfunction."}, {"name": "select_columns", "is_optional": true, "type": "int", "default_value": "None", "description": "An optional list of integer indices or string column\nnames, that specifies a subset of columns of CSV data to select. If\ncolumn names are provided, these must correspond to names provided in\ncolumn_names or inferred from the file header lines. When this argument\nis specified, only a subset of CSV columns will be parsed and returned,\ncorresponding to the columns specified. Using this results in faster\nparsing and lower memory usage. If both this and column_defaults are\nspecified, these must have the same lengths, and column_defaults is\nassumed to be sorted in order of increasing column index."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. If false, treats\ndouble quotation marks as regular characters inside of the string fields."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "Additional string to recognize as NA/NaN."}, {"name": "header", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool that indicates whether the first rows of provided CSV files\ncorrespond to header lines with column names, and should not be included\nin the data."}, {"name": "num_epochs", "is_optional": true, "type": "others", "default_value": "None", "description": "An int specifying the number of times this dataset is repeated.\nIf None, cycles through the dataset forever."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool that indicates whether the input should be shuffled."}, {"name": "shuffle_buffer_size", "is_optional": true, "type": "int", "default_value": "10000", "description": "Buffer size to use for shuffling. A large buffer size\nensures better shuffling, but increases memory usage and startup time."}, {"name": "shuffle_seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Randomization seed to use for shuffling."}, {"name": "prefetch_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int specifying the number of feature\nbatches to prefetch for performance improvement. Recommended value is the\nnumber of batches consumed per training step. Defaults to auto-tune."}, {"name": "num_parallel_reads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads used to read CSV records from files.\nIf &gt;1, the results will be interleaved. Defaults to 1."}, {"name": "sloppy", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, reading performance will be improved at\nthe cost of non-deterministic ordering. If False, the order of elements\nproduced is deterministic prior to shuffling (elements are still\nrandomized if shuffle=True. Note that if the seed is set, then order\nof elements after shuffling is deterministic). Defaults to False."}, {"name": "num_rows_for_inference", "is_optional": true, "type": "int", "default_value": "100", "description": "Number of rows of a file to use for type inference\nif record_defaults is not provided. If None, reads all the rows of all\nthe files. Defaults to 100."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\". Defaults to no compression."}, {"name": "ignore_errors", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) If True, ignores errors with CSV file parsing,\nsuch as malformed data or empty lines, and moves on to the next valid\nCSV record. Otherwise, the dataset raises an error and stops processing\nwhen encountering any invalid records. Defaults to False."}]}},
{"id": "tf.data.experimental.OptimizationOptions", "type": "function", "code": "tf.data.experimental.OptimizationOptions()", "summary": "Represents options for dataset optimizations.", "description": "", "code-info": {"name": "tf.data.experimental.OptimizationOptions", "parameters": []}},
{"id": "tf.data.experimental.make_saveable_from_iterator", "type": "function", "code": "tf.data.experimental.make_saveable_from_iterator(iterator)", "summary": "Returns a SaveableObject for saving/restoring iterator state using Saver.", "description": "", "code-info": {"name": "tf.data.experimental.make_saveable_from_iterator", "parameters": [{"name": "iterator", "is_optional": false, "type": "others", "description": "Iterator."}]}},
{"id": "tf.data.experimental.make_batched_features_dataset", "type": "function", "code": "tf.data.experimental.make_batched_features_dataset(file_pattern,batch_size,features,reader=None,label_key=None,reader_args=None,num_epochs=None,shuffle=True,shuffle_buffer_size=10000,shuffle_seed=None,prefetch_buffer_size=None,reader_num_threads=None,parser_num_threads=None,sloppy_ordering=False,drop_final_batch=False)", "summary": "Returns a Dataset of feature dictionaries from Example protos.", "description": "", "code-info": {"name": "tf.data.experimental.make_batched_features_dataset", "parameters": [{"name": "file_pattern", "is_optional": false, "type": "others", "description": "List of files or patterns of file paths containing\nExample records. See tf.io.gfile.glob for pattern rules."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "An int representing the number of records to combine\nin a single batch."}, {"name": "features", "is_optional": false, "type": "others", "description": "{\n  \"age\": FixedLenFeature([], dtype=tf.int64, default_value=-1),\n  \"gender\": FixedLenFeature([], dtype=tf.string),\n  \"kws\": VarLenFeature(dtype=tf.string),\n}\n\nAnd the expected output is:\n{\n  \"age\": [[0], [-1]],\n  \"gender\": [[\"f\"], [\"f\"]],\n  \"kws\": SparseTensor(\n    indices=[[0, 0], [0, 1], [1, 0]],\n    values=[\"code\", \"art\", \"sports\"]\n    dense_shape=[2, 2]),\n}\n\nArgs:\n\n\nfile_pattern: List of files or patterns of file paths containing\nExample records. See tf.io.gfile.glob for pattern rules.\nbatch_size: An int representing the number of records to combine\nin a single batch."}, {"name": "reader", "is_optional": true, "type": "others", "default_value": "None", "description": "A function or class that can be\ncalled with a filenames tensor and (optional) reader_args and returns\na Dataset of Example tensors. Defaults to tf.data.TFRecordDataset."}, {"name": "label_key", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A string corresponding to the key labels are stored in\ntf.Examples. If provided, it must be one of the features key,\notherwise results in ValueError."}, {"name": "reader_args", "is_optional": true, "type": "others", "default_value": "None", "description": "Additional arguments to pass to the reader class."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer specifying the number of times to read through the\ndataset. If None, cycles through the dataset forever. Defaults to None."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean, indicates whether the input should be shuffled. Defaults\nto True."}, {"name": "shuffle_buffer_size", "is_optional": true, "type": "int", "default_value": "10000", "description": "Buffer size of the ShuffleDataset. A large capacity\nensures better shuffling but would increase memory usage and startup time."}, {"name": "shuffle_seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Randomization seed to use for shuffling."}, {"name": "prefetch_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of feature batches to prefetch in order to\nimprove performance. Recommended value is the number of batches consumed\nper training step. Defaults to auto-tune."}, {"name": "reader_num_threads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads used to read Example records. If &gt;1,\nthe results will be interleaved. Defaults to 1."}, {"name": "parser_num_threads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads to use for parsing Example tensors\ninto a dictionary of Feature tensors. Defaults to 2."}, {"name": "sloppy_ordering", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, reading performance will be improved at\nthe cost of non-deterministic ordering. If False, the order of elements\nproduced is deterministic prior to shuffling (elements are still\nrandomized if shuffle=True. Note that if the seed is set, then order\nof elements after shuffling is deterministic). Defaults to False."}, {"name": "drop_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, and the batch size does not evenly divide the\ninput dataset size, the final smaller batch will be dropped. Defaults to\nFalse."}]}},
{"id": "tf.data.experimental.Reducer", "type": "function", "code": "tf.data.experimental.Reducer(init_func,reduce_func,finalize_func)", "summary": "A reducer is used for reducing a set of elements.", "description": "", "code-info": {"name": "tf.data.experimental.Reducer", "parameters": [{"name": "init_func", "is_optional": false, "type": "others", "description": ""}, {"name": "reduce_func", "is_optional": false, "type": "others", "description": ""}, {"name": "finalize_func", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.data.experimental.map_and_batch", "type": "function", "code": "tf.data.experimental.map_and_batch(map_func,batch_size,num_parallel_batches=None,drop_remainder=False,num_parallel_calls=None)", "summary": "Fused implementation of map and batch. (deprecated)", "description": "", "code-info": {"name": "tf.data.experimental.map_and_batch", "parameters": [{"name": "map_func", "is_optional": false, "type": "tensor", "description": "A function mapping a nested structure of tensors to another\nnested structure of tensors."}, {"name": "batch_size", "is_optional": false, "type": "tensor", "description": "A tf.int64 scalar tf.Tensor, representing the number of\nconsecutive elements of this dataset to combine in a single batch."}, {"name": "num_parallel_batches", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor,\nrepresenting the number of batches to create in parallel. On one hand,\nhigher values can help mitigate the effect of stragglers. On the other\nhand, higher values can increase contention if CPU is scarce."}, {"name": "drop_remainder", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar tf.Tensor, representing\nwhether the last batch should be dropped in case its size is smaller than\ndesired; the default behavior is not to drop the smaller batch."}, {"name": "num_parallel_calls", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int32 scalar tf.Tensor,\nrepresenting the number of elements to process in parallel. If not\nspecified, batch_size * num_parallel_batches elements will be processed\nin parallel. If the value tf.data.experimental.AUTOTUNE is used, then\nthe number of parallel calls is set dynamically based on available CPU."}]}},
{"id": "tf.data.experimental.MapVectorizationOptions", "type": "class", "code": "tf.data.experimental.MapVectorizationOptions()", "summary": "Represents options for the MapVectorization optimization.", "description": "", "code-info": {"name": "tf.data.experimental.MapVectorizationOptions", "parameters": []}},
{"id": "tf.data.experimental.latency_stats", "type": "function", "code": "tf.data.experimental.latency_stats(tag)", "summary": "Records the latency of producing each element of the input dataset.", "description": "", "code-info": {"name": "tf.data.experimental.latency_stats", "parameters": [{"name": "tag", "is_optional": false, "type": "string", "description": "String. All statistics recorded by the returned transformation will\nbe associated with the given tag."}]}},
{"id": "tf.data.experimental.ignore_errors", "type": "function", "code": "tf.data.experimental.ignore_errors()", "summary": "Creates a Dataset from another Dataset and silently ignores any errors.", "description": "", "code-info": {"name": "tf.data.experimental.ignore_errors", "parameters": []}},
{"id": "tf.data.experimental.group_by_window", "type": "function", "code": "tf.data.experimental.group_by_window(key_func,reduce_func,window_size=None,window_size_func=None)", "summary": "A transformation that groups windows of elements by key and reduces them.", "description": "", "code-info": {"name": "tf.data.experimental.group_by_window", "parameters": [{"name": "key_func", "is_optional": false, "type": "tensor", "description": "A function mapping a nested structure of tensors\n(having shapes and types defined by self.output_shapes and\nself.output_types) to a scalar tf.int64 tensor."}, {"name": "reduce_func", "is_optional": false, "type": "others", "description": "A function mapping a key and a dataset of up to window_size\nconsecutive elements matching that key to another dataset."}, {"name": "window_size", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A tf.int64 scalar tf.Tensor, representing the number of\nconsecutive elements matching the same key to combine in a single\nbatch, which will be passed to reduce_func. Mutually exclusive with\nwindow_size_func."}, {"name": "window_size_func", "is_optional": true, "type": "float", "default_value": "None", "description": "A function mapping a key to a tf.int64 scalar\ntf.Tensor, representing the number of consecutive elements matching\nthe same key to combine in a single batch, which will be passed to\nreduce_func. Mutually exclusive with window_size."}]}},
{"id": "tf.data.experimental.group_by_reducer", "type": "function", "code": "tf.data.experimental.group_by_reducer(key_func,reducer)", "summary": "A transformation that groups elements and performs a reduction.", "description": "", "code-info": {"name": "tf.data.experimental.group_by_reducer", "parameters": [{"name": "key_func", "is_optional": false, "type": "tensor", "description": "A function mapping a nested structure of tensors\n(having shapes and types defined by self.output_shapes and\nself.output_types) to a scalar tf.int64 tensor."}, {"name": "reducer", "is_optional": false, "type": "others", "description": "An instance of Reducer, which captures the reduction logic using\nthe init_func, reduce_func, and finalize_func functions."}]}},
{"id": "tf.data.experimental.get_structure", "type": "function", "code": "tf.data.experimental.get_structure(dataset_or_iterator)", "summary": "Returns the type specification of an element of a Dataset or Iterator.", "description": "", "code-info": {"name": "tf.data.experimental.get_structure", "parameters": [{"name": "dataset_or_iterator", "is_optional": false, "type": "others", "description": "A tf.data.Dataset or tf.data.Iterator."}]}},
{"id": "tf.data.experimental.get_single_element", "type": "function", "code": "tf.data.experimental.get_single_element(dataset)", "summary": "Returns the single element in dataset as a nested structure of tensors.", "description": "", "code-info": {"name": "tf.data.experimental.get_single_element", "parameters": [{"name": "dataset", "is_optional": false, "type": "others", "description": "A tf.data.Dataset object containing a single element."}]}},
{"id": "tf.data.experimental.get_next_as_optional", "type": "function", "code": "tf.data.experimental.get_next_as_optional(iterator)", "summary": "Returns an Optional that contains the next value from the iterator.", "description": "", "code-info": {"name": "tf.data.experimental.get_next_as_optional", "parameters": [{"name": "iterator", "is_optional": false, "type": "others", "description": "A tf.compat.v1.data.Iterator object."}]}},
{"id": "tf.data.experimental.from_variant", "type": "function", "code": "tf.data.experimental.from_variant(variant,structure)", "summary": "Constructs a dataset from the given variant and structure.", "description": "", "code-info": {"name": "tf.data.experimental.from_variant", "parameters": [{"name": "variant", "is_optional": false, "type": "tensor", "description": "A scalar tf.variant tensor representing a dataset."}, {"name": "structure", "is_optional": false, "type": "string", "description": "A tf.data.experimental.Structure object representing the\nstructure of each element in the dataset."}]}},
{"id": "tf.data.experimental.copy_to_device", "type": "function", "code": "tf.data.experimental.copy_to_device(target_device,source_device='/cpu:0')", "summary": "A transformation that copies dataset elements to the given target_device.", "description": "", "code-info": {"name": "tf.data.experimental.copy_to_device", "parameters": [{"name": "target_device", "is_optional": false, "type": "string", "description": "The name of a device to which elements will be copied."}, {"name": "source_device", "is_optional": true, "type": "string", "default_value": "'/cpu:0'", "description": "The original device on which input_dataset will be placed."}]}},
{"id": "tf.data.experimental.enumerate_dataset", "type": "function", "code": "tf.data.experimental.enumerate_dataset(start=0)", "summary": "A transformation that enumerates the elements of a dataset. (deprecated)", "description": "", "code-info": {"name": "tf.data.experimental.enumerate_dataset", "parameters": [{"name": "start", "is_optional": true, "type": "int", "default_value": "0", "description": "A tf.int64 scalar tf.Tensor, representing the start value for\nenumeration."}]}},
{"id": "tf.data.experimental.choose_from_datasets", "type": "function", "code": "tf.data.experimental.choose_from_datasets(datasets,choice_dataset)", "summary": "Creates a dataset that deterministically chooses elements from datasets.", "description": "", "code-info": {"name": "tf.data.experimental.choose_from_datasets", "parameters": [{"name": "datasets", "is_optional": false, "type": "others", "description": "A list of tf.data.Dataset objects with compatible structure."}, {"name": "choice_dataset", "is_optional": false, "type": "tensor", "description": "A tf.data.Dataset of scalar tf.int64 tensors between\n0 and len(datasets) - 1."}]}},
{"id": "tf.data.experimental.dense_to_sparse_batch", "type": "function", "code": "tf.data.experimental.dense_to_sparse_batch(batch_size,row_shape)", "summary": "A transformation that batches ragged elements into tf.SparseTensors.", "description": "", "code-info": {"name": "tf.data.experimental.dense_to_sparse_batch", "parameters": [{"name": "batch_size", "is_optional": false, "type": "tensor", "description": "A tf.int64 scalar tf.Tensor, representing the number of\nconsecutive elements of this dataset to combine in a single batch."}, {"name": "row_shape", "is_optional": false, "type": "tensor", "description": "A tf.TensorShape or tf.int64 vector tensor-like object\nrepresenting the equivalent dense shape of a row in the resulting\ntf.SparseTensor. Each element of this dataset must have the same rank as\nrow_shape, and must have size less than or equal to row_shape in each\ndimension."}]}},
{"id": "tf.data.experimental.Counter", "type": "function", "code": "tf.data.experimental.Counter(start=0,step=1,dtype=tf.dtypes.int64)", "summary": "Creates a Dataset that counts from start in steps of size step.", "description": "", "code-info": {"name": "tf.data.experimental.Counter", "parameters": [{"name": "start", "is_optional": true, "type": "int", "default_value": "0", "description": "(Optional.) The starting value for the counter. Defaults to 0."}, {"name": "step", "is_optional": true, "type": "int", "default_value": "1", "description": "(Optional.) The step size for the counter. Defaults to 1."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "(Optional.) The data type for counter elements. Defaults to\ntf.int64."}]}},
{"id": "tf.data.experimental.cardinality", "type": "function", "code": "tf.data.experimental.cardinality(dataset)", "summary": "Returns the cardinality of dataset, if known.", "description": "", "code-info": {"name": "tf.data.experimental.cardinality", "parameters": [{"name": "dataset", "is_optional": false, "type": "others", "description": "A tf.data.Dataset for which to determine cardinality."}]}},
{"id": "tf.data.experimental.CsvDataset", "type": "class", "code": "tf.data.experimental.CsvDataset(filenames,record_defaults,compression_type=None,buffer_size=None,header=False,field_delim=',',use_quote_delim=True,na_value='',select_cols=None)", "summary": "A Dataset comprising lines from one or more CSV files.", "description": "", "code-info": {"name": "tf.data.experimental.CsvDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor containing one or more filenames."}, {"name": "record_defaults", "is_optional": false, "type": "others", "description": "A list of default values for the CSV fields. Each item in\nthe list is either a valid CSV DType (float32, float64, int32, int64,\nstring), or a Tensor object with one of the above types. One per\ncolumn of CSV data, with either a scalar Tensor default value for the\ncolumn if it is optional, or DType or empty Tensor if required. If\nboth this and select_columns are specified, these must have the same\nlengths, and column_defaults is assumed to be sorted in order of\nincreasing column index."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\". Defaults to no\ncompression."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar denoting the number of bytes\nto buffer while reading files. Defaults to 4MB."}, {"name": "header", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar indicating whether the CSV file(s)\nhave header line(s) that should be skipped when parsing. Defaults to\nFalse."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "(Optional.) A tf.bool scalar. If False, treats\ndouble quotation marks as regular characters inside of string fields\n(ignoring RFC 4180, Section 2, Bullet 5). Defaults to True."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "(Optional.) A tf.string scalar indicating a value that will\nbe treated as NA/NaN."}, {"name": "select_cols", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) A sorted list of column indices to select from\nthe input data. If specified, only this subset of columns will be\nparsed. Defaults to parsing all columns."}]}},
{"id": "tf.data.experimental.CheckpointInputPipelineHook", "type": "function", "code": "tf.data.experimental.CheckpointInputPipelineHook(estimator)", "summary": "Checkpoints input pipeline state every N steps or seconds.\n\nInherits From: SessionRunHook", "description": "", "code-info": {"name": "tf.data.experimental.CheckpointInputPipelineHook", "parameters": [{"name": "estimator", "is_optional": false, "type": "others", "description": "Estimator."}]}},
{"id": "tf.data.experimental.bytes_produced_stats", "type": "function", "code": "tf.data.experimental.bytes_produced_stats(tag)", "summary": "Records the number of bytes produced by each element of the input dataset.", "description": "", "code-info": {"name": "tf.data.experimental.bytes_produced_stats", "parameters": [{"name": "tag", "is_optional": false, "type": "string", "description": "String. All statistics recorded by the returned transformation will\nbe associated with the given tag."}]}},
{"id": "tf.data.experimental.DistributeOptions", "type": "function", "code": "tf.data.experimental.DistributeOptions()", "summary": "Represents options for distributed data processing.", "description": "", "code-info": {"name": "tf.data.experimental.DistributeOptions", "parameters": []}},
{"id": "tf.data.experimental.bucket_by_sequence_length", "type": "function", "code": "tf.data.experimental.bucket_by_sequence_length(element_length_func,bucket_boundaries,bucket_batch_sizes,padded_shapes=None,padding_values=None,pad_to_bucket_boundary=False,no_padding=False,drop_remainder=False)", "summary": "A transformation that buckets elements in a Dataset by length.", "description": "", "code-info": {"name": "tf.data.experimental.bucket_by_sequence_length", "parameters": [{"name": "element_length_func", "is_optional": false, "type": "others", "description": "function from element in Dataset to tf.int32,\ndetermines the length of the element, which will determine the bucket it\ngoes into."}, {"name": "bucket_boundaries", "is_optional": false, "type": "others", "description": "list&lt;int&gt;, upper length boundaries of the buckets."}, {"name": "bucket_batch_sizes", "is_optional": false, "type": "others", "description": "list&lt;int&gt;, batch size per bucket. Length should be\nlen(bucket_boundaries) + 1."}, {"name": "padded_shapes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Nested structure of tf.TensorShape to pass to\ntf.data.Dataset.padded_batch. If not provided, will use\ndataset.output_shapes, which will result in variable length dimensions\nbeing padded out to the maximum length in each batch."}, {"name": "padding_values", "is_optional": true, "type": "others", "default_value": "None", "description": "Values to pad with, passed to\ntf.data.Dataset.padded_batch. Defaults to padding with 0."}, {"name": "pad_to_bucket_boundary", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, if False, will pad dimensions with unknown\nsize to maximum length in batch. If True, will pad dimensions with\nunknown size to bucket boundary minus 1 (i.e., the maximum length in each\nbucket), and caller must ensure that the source Dataset does not contain\nany elements with length longer than max(bucket_boundaries)."}, {"name": "no_padding", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, indicates whether to pad the batch features (features\nneed to be either of type tf.SparseTensor or of same shape)."}, {"name": "drop_remainder", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar tf.Tensor, representing\nwhether the last batch should be dropped in the case it has fewer than\nbatch_size elements; the default behavior is not to drop the smaller\nbatch."}]}},
{"id": "tf.data.experimental.dense_to_ragged_batch", "type": "function", "code": "tf.data.experimental.dense_to_ragged_batch(batch_size,drop_remainder=False,row_splits_dtype=tf.dtypes.int64)", "summary": "A transformation that batches ragged elements into tf.RaggedTensors.", "description": "", "code-info": {"name": "tf.data.experimental.dense_to_ragged_batch", "parameters": [{"name": "batch_size", "is_optional": false, "type": "tensor", "description": "A tf.int64 scalar tf.Tensor, representing the number of\nconsecutive elements of this dataset to combine in a single batch."}, {"name": "drop_remainder", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar tf.Tensor, representing\nwhether the last batch should be dropped in the case it has fewer than\nbatch_size elements; the default behavior is not to drop the smaller\nbatch."}, {"name": "row_splits_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "The dtype that should be used for the row_splits of any\nnew ragged tensors.  Existing tf.RaggedTensor elements do not have their\nrow_splits dtype changed."}]}},
{"id": "tf.data.FixedLengthRecordDataset", "type": "class", "code": "tf.data.FixedLengthRecordDataset(filenames,record_bytes,header_bytes=None,footer_bytes=None,buffer_size=None,compression_type=None,num_parallel_reads=None)", "summary": "A Dataset of fixed-length records from one or more binary files.", "description": "", "code-info": {"name": "tf.data.FixedLengthRecordDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "record_bytes", "is_optional": false, "type": "float", "description": "A tf.int64 scalar representing the number of bytes in each\nrecord."}, {"name": "header_bytes", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to skip at the start of a file."}, {"name": "footer_bytes", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to ignore at the end of a file."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to buffer when reading."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.data.TFRecordDataset", "type": "class", "code": "tf.data.TFRecordDataset(filenames,compression_type=None,buffer_size=None,num_parallel_reads=None)", "summary": "A Dataset comprising records from one or more TFRecord files.\n\nInherits From: Dataset", "description": "", "code-info": {"name": "tf.data.TFRecordDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes in the read buffer. If your input pipeline is I/O bottlenecked,\nconsider setting this parameter to a value 1-100 MBs. If None, a\nsensible default for both local and remote file systems is used."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.data.TextLineDataset", "type": "class", "code": "tf.data.TextLineDataset(filenames,compression_type=None,buffer_size=None,num_parallel_reads=None)", "summary": "A Dataset comprising lines from one or more text files.", "description": "", "code-info": {"name": "tf.data.TextLineDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar denoting the number of bytes\nto buffer. A value of 0 results in the default buffering values chosen\nbased on the compression type."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.data.Options", "type": "class", "code": "tf.data.Options()", "summary": "Represents options for tf.data.Dataset.", "description": "", "code-info": {"name": "tf.data.Options", "parameters": []}},
{"id": "tf.data.Dataset", "type": "class", "code": "tf.data.Dataset(variant_tensor)", "summary": "Represents a potentially large set of elements.", "description": "", "code-info": {"name": "tf.data.Dataset", "parameters": [{"name": "variant_tensor", "is_optional": false, "type": "tensor", "description": "A DT_VARIANT tensor that represents the dataset."}]}},
{"id": "tf.data.DatasetSpec", "type": "class", "code": "tf.data.DatasetSpec(element_spec,dataset_shape=())", "summary": "Type specification for tf.data.Dataset.", "description": "", "code-info": {"name": "tf.data.DatasetSpec", "parameters": [{"name": "element_spec", "is_optional": false, "type": "others", "description": ""}, {"name": "dataset_shape", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.config.threading.get_intra_op_parallelism_threads", "type": "function", "code": "tf.config.threading.get_intra_op_parallelism_threads()", "summary": "Get number of threads used within an individual op for parallelism.", "description": "", "code-info": {"name": "tf.config.threading.get_intra_op_parallelism_threads", "parameters": []}},
{"id": "tf.config.threading.set_intra_op_parallelism_threads", "type": "function", "code": "tf.config.threading.set_intra_op_parallelism_threads(num_threads)", "summary": "Set number of threads used within an individual op for parallelism.", "description": "", "code-info": {"name": "tf.config.threading.set_intra_op_parallelism_threads", "parameters": [{"name": "num_threads", "is_optional": false, "type": "others", "description": "Number of parallel threads"}]}},
{"id": "tf.config.threading.set_inter_op_parallelism_threads", "type": "function", "code": "tf.config.threading.set_inter_op_parallelism_threads(num_threads)", "summary": "Set number of threads used for parallelism between independent operations.", "description": "", "code-info": {"name": "tf.config.threading.set_inter_op_parallelism_threads", "parameters": [{"name": "num_threads", "is_optional": false, "type": "others", "description": "Number of parallel threads"}]}},
{"id": "tf.config.threading.get_inter_op_parallelism_threads", "type": "function", "code": "tf.config.threading.get_inter_op_parallelism_threads()", "summary": "Get number of threads used for parallelism between independent operations.", "description": "", "code-info": {"name": "tf.config.threading.get_inter_op_parallelism_threads", "parameters": []}},
{"id": "tf.config.experimental.set_synchronous_execution", "type": "function", "code": "tf.config.experimental.set_synchronous_execution(enable)", "summary": "Specifies whether operations are executed synchronously or asynchronously.", "description": "", "code-info": {"name": "tf.config.experimental.set_synchronous_execution", "parameters": [{"name": "enable", "is_optional": false, "type": "others", "description": "Whether operations should be dispatched synchronously.\nValid values:"}]}},
{"id": "tf.config.optimizer.get_experimental_options", "type": "function", "code": "tf.config.optimizer.get_experimental_options()", "summary": "Get experimental optimizer options.", "description": "", "code-info": {"name": "tf.config.optimizer.get_experimental_options", "parameters": []}},
{"id": "tf.config.experimental.set_memory_growth", "type": "function", "code": "tf.config.experimental.set_memory_growth(device,enable)", "summary": "Set if memory growth should be enabled for a PhysicalDevice.", "description": "", "code-info": {"name": "tf.config.experimental.set_memory_growth", "parameters": [{"name": "device", "is_optional": false, "type": "others", "description": "PhysicalDevice to configure"}, {"name": "enable", "is_optional": false, "type": "bool", "description": "(Boolean) Whether to enable or disable memory growth"}]}},
{"id": "tf.config.optimizer.get_jit", "type": "function", "code": "tf.config.optimizer.get_jit()", "summary": "Get if JIT compilation is enabled.", "description": "", "code-info": {"name": "tf.config.optimizer.get_jit", "parameters": []}},
{"id": "tf.config.optimizer.set_experimental_options", "type": "function", "code": "tf.config.optimizer.set_experimental_options(options)", "summary": "Set experimental optimizer options.", "description": "", "code-info": {"name": "tf.config.optimizer.set_experimental_options", "parameters": [{"name": "options", "is_optional": false, "type": "others", "description": "Dictionary of experimental optimizer options to configure.\nValid keys:"}]}},
{"id": "tf.config.optimizer.set_jit", "type": "function", "code": "tf.config.optimizer.set_jit(enabled)", "summary": "Set if JIT compilation is enabled.", "description": "", "code-info": {"name": "tf.config.optimizer.set_jit", "parameters": [{"name": "enabled", "is_optional": false, "type": "others", "description": "Whether to enable JIT compilation."}]}},
{"id": "tf.config.experimental.get_device_policy", "type": "function", "code": "tf.config.experimental.get_device_policy()", "summary": "Gets the current device policy.", "description": "", "code-info": {"name": "tf.config.experimental.get_device_policy", "parameters": []}},
{"id": "tf.config.set_visible_devices", "type": "function", "code": "tf.config.set_visible_devices(devices,device_type=None)", "summary": "Set the list of visible devices.", "description": "", "code-info": {"name": "tf.config.set_visible_devices", "parameters": [{"name": "devices", "is_optional": false, "type": "others", "description": "List of PhysicalDevices to make visible"}, {"name": "device_type", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Only configure devices matching this device type.\nFor example \"CPU\" or \"GPU\". Other devices will be left unaltered."}]}},
{"id": "tf.config.experimental.set_device_policy", "type": "function", "code": "tf.config.experimental.set_device_policy(device_policy)", "summary": "Sets the current thread device policy.", "description": "", "code-info": {"name": "tf.config.experimental.set_device_policy", "parameters": [{"name": "device_policy", "is_optional": false, "type": "others", "description": "A device policy.\nValid values:"}]}},
{"id": "tf.config.experimental.get_memory_growth", "type": "function", "code": "tf.config.experimental.get_memory_growth(device)", "summary": "Get if memory growth is enabled for a PhysicalDevice.", "description": "", "code-info": {"name": "tf.config.experimental.get_memory_growth", "parameters": [{"name": "device", "is_optional": false, "type": "others", "description": "PhysicalDevice to query"}]}},
{"id": "tf.config.experimental.get_synchronous_execution", "type": "function", "code": "tf.config.experimental.get_synchronous_execution()", "summary": "Gets whether operations are executed synchronously or asynchronously.", "description": "", "code-info": {"name": "tf.config.experimental.get_synchronous_execution", "parameters": []}},
{"id": "tf.config.experimental.disable_mlir_bridge", "type": "function", "code": "tf.config.experimental.disable_mlir_bridge()", "summary": "Disables experimental MLIR-Based TensorFlow Compiler Bridge.", "description": "", "code-info": {"name": "tf.config.experimental.disable_mlir_bridge", "parameters": []}},
{"id": "tf.config.experimental.enable_mlir_bridge", "type": "function", "code": "tf.config.experimental.enable_mlir_bridge()", "summary": "Enables experimental MLIR-Based TensorFlow Compiler Bridge.", "description": "", "code-info": {"name": "tf.config.experimental.enable_mlir_bridge", "parameters": []}},
{"id": "tf.config.set_soft_device_placement", "type": "function", "code": "tf.config.set_soft_device_placement(enabled)", "summary": "Set if soft device placement is enabled.", "description": "", "code-info": {"name": "tf.config.set_soft_device_placement", "parameters": [{"name": "enabled", "is_optional": false, "type": "others", "description": "Whether to enable soft placement."}]}},
{"id": "tf.config.set_logical_device_configuration", "type": "function", "code": "tf.config.set_logical_device_configuration(device,logical_devices)", "summary": "Set the logical device configuration for a tf.config.PhysicalDevice.", "description": "", "code-info": {"name": "tf.config.set_logical_device_configuration", "parameters": [{"name": "device", "is_optional": false, "type": "others", "description": "The PhysicalDevice to configure."}, {"name": "logical_devices", "is_optional": false, "type": "others", "description": "(optional) List of tf.config.LogicalDeviceConfiguration\nobjects to allocate for the specified PhysicalDevice. If None, the\ndefault configuration will be used."}]}},
{"id": "tf.config.experimental_functions_run_eagerly", "type": "function", "code": "tf.config.experimental_functions_run_eagerly()", "summary": "Returns the value of the experimental_run_functions_eagerly setting.", "description": "", "code-info": {"name": "tf.config.experimental_functions_run_eagerly", "parameters": []}},
{"id": "tf.config.get_visible_devices", "type": "function", "code": "tf.config.get_visible_devices(device_type=None)", "summary": "Get the list of visible physical devices.", "description": "", "code-info": {"name": "tf.config.get_visible_devices", "parameters": [{"name": "device_type", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional string) Only include devices matching this device\ntype. For example \"CPU\" or \"GPU\"."}]}},
{"id": "tf.config.get_logical_device_configuration", "type": "function", "code": "tf.config.get_logical_device_configuration(device)", "summary": "Get the virtual device configuration for a tf.config.PhysicalDevice.", "description": "", "code-info": {"name": "tf.config.get_logical_device_configuration", "parameters": [{"name": "device", "is_optional": false, "type": "others", "description": "PhysicalDevice to query"}]}},
{"id": "tf.config.experimental_connect_to_host", "type": "function", "code": "tf.config.experimental_connect_to_host(remote_host=None,job_name='worker')", "summary": "Connects to a single machine to enable remote execution on it.", "description": "", "code-info": {"name": "tf.config.experimental_connect_to_host", "parameters": [{"name": "remote_host", "is_optional": true, "type": "others", "default_value": "None", "description": "a single or a list the remote server addr in host-port format."}, {"name": "job_name", "is_optional": true, "type": "string", "default_value": "'worker'", "description": "The job name under which the new server will be accessible."}]}},
{"id": "tf.config.list_physical_devices", "type": "function", "code": "tf.config.list_physical_devices(device_type=None)", "summary": "Return a list of physical devices visible to the host runtime.", "description": "", "code-info": {"name": "tf.config.list_physical_devices", "parameters": [{"name": "device_type", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional string) Only include devices matching this device\ntype. For example \"CPU\" or \"GPU\"."}]}},
{"id": "tf.config.list_logical_devices", "type": "function", "code": "tf.config.list_logical_devices(device_type=None)", "summary": "Return a list of logical devices created by runtime.", "description": "", "code-info": {"name": "tf.config.list_logical_devices", "parameters": [{"name": "device_type", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional string) Only include devices matching this device\ntype. For example \"CPU\" or \"GPU\"."}]}},
{"id": "tf.config.experimental_run_functions_eagerly", "type": "function", "code": "tf.config.experimental_run_functions_eagerly(run_eagerly)", "summary": "Enables / disables eager execution of tf.functions.", "description": "", "code-info": {"name": "tf.config.experimental_run_functions_eagerly", "parameters": [{"name": "run_eagerly", "is_optional": false, "type": "bool", "description": "Boolean. Whether to run functions eagerly."}]}},
{"id": "tf.config.get_soft_device_placement", "type": "function", "code": "tf.config.get_soft_device_placement()", "summary": "Get if soft device placement is enabled.", "description": "", "code-info": {"name": "tf.config.get_soft_device_placement", "parameters": []}},
{"id": "tf.config.experimental_connect_to_cluster", "type": "function", "code": "tf.config.experimental_connect_to_cluster(cluster_spec_or_resolver,job_name='localhost',task_index=0,protocol=None,make_master_device_default=True)", "summary": "Connects to the given cluster.", "description": "", "code-info": {"name": "tf.config.experimental_connect_to_cluster", "parameters": [{"name": "cluster_spec_or_resolver", "is_optional": false, "type": "others", "description": "A ClusterSpec or ClusterResolver describing\nthe cluster."}, {"name": "job_name", "is_optional": true, "type": "string", "default_value": "'localhost'", "description": "The name of the local job."}, {"name": "task_index", "is_optional": true, "type": "int", "default_value": "0", "description": "The local task index."}, {"name": "protocol", "is_optional": true, "type": "others", "default_value": "None", "description": "The communication protocol, such as \"grpc\". If unspecified, will\nuse the default from python/platform/remote_utils.py."}, {"name": "make_master_device_default", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True and a cluster resolver is passed, will\nautomatically enter the master task device scope, which indicates the\nmaster becomes the default device to run ops. It won't do anything if\na cluster spec is passed. Will throw an error if the caller is currently\nalready in some device scope."}]}},
{"id": "tf.compat.v1.user_ops.my_fact", "type": "function", "code": "tf.compat.v1.user_ops.my_fact()", "summary": "Example of overriding the generated code for an Op.", "description": "", "code-info": {"name": "tf.compat.v1.user_ops.my_fact", "parameters": []}},
{"id": "tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite", "type": "function", "code": "tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite(opt,loss_scale='dynamic')", "summary": "Enable mixed precision via a graph rewrite.", "description": "", "code-info": {"name": "tf.compat.v1.train.experimental.enable_mixed_precision_graph_rewrite", "parameters": [{"name": "opt", "is_optional": false, "type": "others", "description": "An instance of a tf.keras.optimizers.Optimizer or a\ntf.train.Optimizer."}, {"name": "loss_scale", "is_optional": true, "type": "string", "default_value": "'dynamic'", "description": "Either an int/float, the string \"dynamic\", or an instance of\na tf.mixed_precision.experimental.LossScale. The loss scale to use. It\nis recommended to keep this as its default value of \"dynamic\", which\nwill adjust the scaling automatically to prevent Inf or NaN values."}]}},
{"id": "tf.compat.v1.train.experimental.MixedPrecisionLossScaleOptimizer", "type": "function", "code": "tf.compat.v1.train.experimental.MixedPrecisionLossScaleOptimizer(opt,loss_scale)", "summary": "An optimizer that applies loss scaling.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.experimental.MixedPrecisionLossScaleOptimizer", "parameters": [{"name": "opt", "is_optional": false, "type": "others", "description": ""}, {"name": "loss_scale", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.train.experimental.disable_mixed_precision_graph_rewrite", "type": "function", "code": "tf.compat.v1.train.experimental.disable_mixed_precision_graph_rewrite()", "summary": "Disables the mixed precision graph rewrite.", "description": "", "code-info": {"name": "tf.compat.v1.train.experimental.disable_mixed_precision_graph_rewrite", "parameters": []}},
{"id": "tf.compat.v1.train.WorkerSessionCreator", "type": "function", "code": "tf.compat.v1.train.WorkerSessionCreator(scaffold=None,master='',config=None,max_wait_secs=(30*60))", "summary": "Creates a tf.compat.v1.Session for a worker.\n\nInherits From: SessionCreator", "description": "", "code-info": {"name": "tf.compat.v1.train.WorkerSessionCreator", "parameters": [{"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "A Scaffold used for gathering or building supportive ops. If\nnot specified a default one is created. It's used to finalize the graph."}, {"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": "String representation of the TensorFlow master to use."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "ConfigProto proto used to configure the session."}, {"name": "max_wait_secs", "is_optional": false, "type": "others", "description": "Maximum time to wait for the session to become available."}]}},
{"id": "tf.compat.v1.train.warm_start", "type": "function", "code": "tf.compat.v1.train.warm_start(ckpt_to_initialize_from,vars_to_warm_start='.*',var_name_to_vocab_info=None,var_name_to_prev_var_name=None)", "summary": "Warm-starts a model using the given settings.", "description": "", "code-info": {"name": "tf.compat.v1.train.warm_start", "parameters": [{"name": "ckpt_to_initialize_from", "is_optional": false, "type": "string", "description": "[Required] A string specifying the directory with\ncheckpoint file(s) or path to checkpoint from which to warm-start the\nmodel parameters."}, {"name": "vars_to_warm_start", "is_optional": true, "type": "string", "default_value": "'.*'", "description": "[Optional] One of the following:\n\n\nA regular expression (string) that captures which variables to\nwarm-start (see tf.compat.v1.get_collection).  This expression will only\nconsider variables in the TRAINABLE_VARIABLES collection -- if you need\nto warm-start non_TRAINABLE vars (such as optimizer accumulators or\nbatch norm statistics), please use the below option.\nA list of strings, each a regex scope provided to\ntf.compat.v1.get_collection with GLOBAL_VARIABLES (please see\ntf.compat.v1.get_collection).  For backwards compatibility reasons,\nthis is separate from the single-string argument type.\nA list of Variables to warm-start.  If you do not have access to the\nVariable objects at the call site, please use the above option.\nNone, in which case only TRAINABLE variables specified in\nvar_name_to_vocab_info will be warm-started.\n\n\nDefaults to '.*', which warm-starts all variables in the\nTRAINABLE_VARIABLES collection.  Note that this excludes variables such\nas accumulators and moving statistics from batch norm."}, {"name": "var_name_to_vocab_info", "is_optional": true, "type": "string", "default_value": "None", "description": "[Optional] Dict of variable names (strings) to\ntf.estimator.VocabInfo. The variable names should be \"full\" variables,\nnot the names of the partitions.  If not explicitly provided, the variable\nis assumed to have no (changes to) vocabulary."}, {"name": "var_name_to_prev_var_name", "is_optional": true, "type": "string", "default_value": "None", "description": "[Optional] Dict of variable names (strings) to\nname of the previously-trained variable in ckpt_to_initialize_from. If\nnot explicitly provided, the name of the variable is assumed to be same\nbetween previous checkpoint and current model.  Note that this has no\neffect on the set of variables that is warm-started, and only controls\nname mapping (use vars_to_warm_start for controlling what variables to\nwarm-start)."}]}},
{"id": "tf.compat.v1.train.update_checkpoint_state", "type": "function", "code": "tf.compat.v1.train.update_checkpoint_state(save_dir,model_checkpoint_path,all_model_checkpoint_paths=None,latest_filename=None,all_model_checkpoint_timestamps=None,last_preserved_timestamp=None)", "summary": "Updates the content of the 'checkpoint' file. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.update_checkpoint_state", "parameters": [{"name": "save_dir", "is_optional": false, "type": "others", "description": "Directory where the model was saved."}, {"name": "model_checkpoint_path", "is_optional": false, "type": "others", "description": "The checkpoint file."}, {"name": "all_model_checkpoint_paths", "is_optional": true, "type": "string", "default_value": "None", "description": "List of strings.  Paths to all not-yet-deleted\ncheckpoints, sorted from oldest to newest.  If this is a non-empty list,\nthe last element must be equal to model_checkpoint_path.  These paths\nare also saved in the CheckpointState proto."}, {"name": "latest_filename", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name of the checkpoint file.  Default to\n'checkpoint'."}, {"name": "all_model_checkpoint_timestamps", "is_optional": true, "type": "float", "default_value": "None", "description": "Optional list of timestamps (floats,\nseconds since the Epoch) indicating when the checkpoints in\nall_model_checkpoint_paths were created."}, {"name": "last_preserved_timestamp", "is_optional": true, "type": "float", "default_value": "None", "description": "A float, indicating the number of seconds since\nthe Epoch when the last preserved checkpoint was written, e.g. due to a\nkeep_checkpoint_every_n_hours parameter (see\ntf.train.CheckpointManager for an implementation)."}]}},
{"id": "tf.compat.v1.train.SyncReplicasOptimizer", "type": "function", "code": "tf.compat.v1.train.SyncReplicasOptimizer(opt,replicas_to_aggregate,total_num_replicas=None,variable_averages=None,variables_to_average=None,use_locking=False,name='sync_replicas')", "summary": "Class to synchronize, aggregate gradients and pass them to the optimizer.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.SyncReplicasOptimizer", "parameters": [{"name": "opt", "is_optional": false, "type": "others", "description": "The actual optimizer that will be used to compute and apply the\ngradients. Must be one of the Optimizer classes."}, {"name": "replicas_to_aggregate", "is_optional": false, "type": "others", "description": "number of replicas to aggregate for each variable\nupdate."}, {"name": "total_num_replicas", "is_optional": true, "type": "others", "default_value": "None", "description": "Total number of tasks/workers/replicas, could be\ndifferent from replicas_to_aggregate.\nIf total_num_replicas &gt; replicas_to_aggregate: it is backup_replicas +\nreplicas_to_aggregate.\nIf total_num_replicas &lt; replicas_to_aggregate: Replicas compute\nmultiple batches per update to variables."}, {"name": "variable_averages", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional ExponentialMovingAverage object, used to\nmaintain moving averages for the variables passed in\nvariables_to_average."}, {"name": "variables_to_average", "is_optional": true, "type": "others", "default_value": "None", "description": "a list of variables that need to be averaged. Only\nneeded if variable_averages is passed in."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operation."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sync_replicas'", "description": "string. Optional name of the returned operation."}]}},
{"id": "tf.compat.v1.train.Supervisor", "type": "class", "code": "tf.compat.v1.train.Supervisor(graph=None,ready_op=USE_DEFAULT,ready_for_local_init_op=USE_DEFAULT,is_chief=True,init_op=USE_DEFAULT,init_feed_dict=None,local_init_op=USE_DEFAULT,logdir=None,summary_op=USE_DEFAULT,saver=USE_DEFAULT,global_step=USE_DEFAULT,save_summaries_secs=120,save_model_secs=600,recovery_wait_secs=30,stop_grace_secs=120,checkpoint_basename='model.ckpt',session_manager=None,summary_writer=USE_DEFAULT,init_fn=None,local_init_run_options=None)", "summary": "A training helper that checkpoints models and computes summaries.", "description": "", "code-info": {"name": "tf.compat.v1.train.Supervisor", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "A Graph.  The graph that the model will use.  Defaults to the\ndefault Graph.  The supervisor may add operations to the graph before\ncreating a session, but the graph should not be modified by the caller\nafter passing it to the supervisor."}, {"name": "ready_op", "is_optional": true, "type": "tensor", "default_value": "USE_DEFAULT", "description": "1-D string Tensor.  This tensor is evaluated by supervisors in\nprepare_or_wait_for_session() to check if the model is ready to use.\nThe model is considered ready if it returns an empty array.  Defaults to\nthe tensor returned from tf.compat.v1.report_uninitialized_variables()\nIf None, the model is not checked for readiness."}, {"name": "ready_for_local_init_op", "is_optional": true, "type": "tensor", "default_value": "USE_DEFAULT", "description": "1-D string Tensor.  This tensor is evaluated by\nsupervisors in prepare_or_wait_for_session() to check if the model is\nready to run the local_init_op. The model is considered ready if it\nreturns an empty array. Defaults to None. If None, the model is not\nchecked for readiness before running local_init_op."}, {"name": "is_chief", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, create a chief supervisor in charge of initializing and\nrestoring the model.  If False, create a supervisor that relies on a\nchief supervisor for inits and restore."}, {"name": "init_op", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "Operation.  Used by chief supervisors to initialize the model\nwhen it can not be recovered.  Defaults to an Operation that\ninitializes all global variables.  If None, no initialization is done\nautomatically unless you pass a value for init_fn, see below."}, {"name": "init_feed_dict", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A dictionary that maps Tensor objects to feed values.\nThis feed dictionary will be used when init_op is evaluated."}, {"name": "local_init_op", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "Operation. Used by all supervisors to run initializations\nthat should run for every new supervisor instance. By default these are\ntable initializers and initializers for local variables. If None, no\nfurther per supervisor-instance initialization is done automatically."}, {"name": "logdir", "is_optional": true, "type": "string", "default_value": "None", "description": "A string.  Optional path to a directory where to checkpoint the\nmodel and log events for the visualizer.  Used by chief supervisors. The\ndirectory will be created if it does not exist."}, {"name": "summary_op", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "An Operation that returns a Summary for the event logs. Used\nby chief supervisors if a logdir was specified.  Defaults to the\noperation returned from summary.merge_all().  If None, summaries are\nnot computed automatically."}, {"name": "saver", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "A Saver object.  Used by chief supervisors if a logdir was\nspecified.  Defaults to the saved returned by Saver(). If None, the\nmodel is not saved automatically."}, {"name": "global_step", "is_optional": true, "type": "tensor", "default_value": "USE_DEFAULT", "description": "An integer Tensor of size 1 that counts steps.  The value\nfrom 'global_step' is used in summaries and checkpoint filenames.\nDefault to the op named 'global_step' in the graph if it exists, is of\nrank 1, size 1, and of type tf.int32 or tf.int64.  If None the global\nstep is not recorded in summaries and checkpoint files.  Used by chief\nsupervisors if a logdir was specified."}, {"name": "save_summaries_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Number of seconds between the computation of\nsummaries for the event log.  Defaults to 120 seconds.  Pass 0 to\ndisable summaries."}, {"name": "save_model_secs", "is_optional": true, "type": "int", "default_value": "600", "description": "Number of seconds between the creation of model\ncheckpoints.  Defaults to 600 seconds.  Pass 0 to disable checkpoints."}, {"name": "recovery_wait_secs", "is_optional": true, "type": "int", "default_value": "30", "description": "Number of seconds between checks that the model is\nready.  Used by supervisors when waiting for a chief supervisor to\ninitialize or restore the model.  Defaults to 30 seconds."}, {"name": "stop_grace_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Grace period, in seconds, given to running threads to\nstop when stop() is called.  Defaults to 120 seconds."}, {"name": "checkpoint_basename", "is_optional": true, "type": "string", "default_value": "'model.ckpt'", "description": "The basename for checkpoint saving."}, {"name": "session_manager", "is_optional": true, "type": "others", "default_value": "None", "description": "SessionManager, which manages Session creation and\nrecovery. If it is None, a default SessionManager will be created\nwith the set of arguments passed in for backwards compatibility."}, {"name": "summary_writer", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "SummaryWriter to use or USE_DEFAULT.  Can be None to\nindicate that no summaries should be written."}, {"name": "init_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional callable used to initialize the model. Called after the\noptional init_op is called.  The callable must accept one argument,\nthe session being initialized."}, {"name": "local_init_run_options", "is_optional": true, "type": "others", "default_value": "None", "description": "RunOptions to be passed as the SessionManager\nlocal_init_run_options parameter."}]}},
{"id": "tf.compat.v1.train.string_input_producer", "type": "function", "code": "tf.compat.v1.train.string_input_producer(string_tensor,num_epochs=None,shuffle=True,seed=None,capacity=32,shared_name=None,name=None,cancel_op=None)", "summary": "Output strings (e.g. filenames) to a queue for an input pipeline. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.string_input_producer", "parameters": [{"name": "string_tensor", "is_optional": false, "type": "tensor", "description": "A 1-D string tensor with the strings to produce."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). If specified, string_input_producer\nproduces each string from string_tensor num_epochs times before\ngenerating an OutOfRange error. If not specified,\nstring_input_producer can cycle through the strings in string_tensor\nan unlimited number of times."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean. If true, the strings are randomly shuffled within each\nepoch."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). Seed used if shuffle == True."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. Sets the queue capacity."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional). If set, this queue will be shared under the given\nname across multiple sessions. All sessions open to the device which has\nthis queue will be able to access it via the shared_name. Using this in\na distributed setting means each name will only be seen by one of the\nsessions which has access to this operation."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operations (optional)."}, {"name": "cancel_op", "is_optional": true, "type": "others", "default_value": "None", "description": "Cancel op for the queue (optional)."}]}},
{"id": "tf.compat.v1.train.SessionManager", "type": "function", "code": "tf.compat.v1.train.SessionManager(local_init_op=None,ready_op=None,ready_for_local_init_op=None,graph=None,recovery_wait_secs=30,local_init_run_options=None,local_init_feed_dict=None)", "summary": "Training helper that restores from checkpoint and creates session.", "description": "", "code-info": {"name": "tf.compat.v1.train.SessionManager", "parameters": [{"name": "local_init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An Operation run immediately after session creation.\nUsually used to initialize tables and local variables."}, {"name": "ready_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An Operation to check if the model is initialized."}, {"name": "ready_for_local_init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An Operation to check if the model is ready\nto run local_init_op."}, {"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "The Graph that the model will use."}, {"name": "recovery_wait_secs", "is_optional": true, "type": "int", "default_value": "30", "description": "Seconds between checks for the model to be ready."}, {"name": "local_init_run_options", "is_optional": true, "type": "others", "default_value": "None", "description": "RunOptions to be passed to session.run when\nexecuting the local_init_op."}, {"name": "local_init_feed_dict", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional session feed dictionary to use when running\nthe local_init_op."}]}},
{"id": "tf.compat.v1.train.shuffle_batch_join", "type": "function", "code": "tf.compat.v1.train.shuffle_batch_join(tensors_list,batch_size,capacity,min_after_dequeue,seed=None,enqueue_many=False,shapes=None,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Create batches by randomly shuffling tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.shuffle_batch_join", "parameters": [{"name": "tensors_list", "is_optional": false, "type": "tensor", "description": "A list of tuples or dictionaries of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "int", "description": "An integer. The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The maximum number of elements in the queue."}, {"name": "min_after_dequeue", "is_optional": false, "type": "others", "description": "Minimum number elements in the queue after a\ndequeue, used to ensure a level of mixing of elements."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Seed for the random shuffling within the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list_list is a single\nexample."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensors_list[i]."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.slice_input_producer", "type": "function", "code": "tf.compat.v1.train.slice_input_producer(tensor_list,num_epochs=None,shuffle=True,seed=None,capacity=32,shared_name=None,name=None)", "summary": "Produces a slice of each Tensor in tensor_list. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.slice_input_producer", "parameters": [{"name": "tensor_list", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects. Every Tensor in\ntensor_list must have the same size in the first dimension."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). If specified, slice_input_producer\nproduces each slice num_epochs times before generating\nan OutOfRange error. If not specified, slice_input_producer can cycle\nthrough the slices an unlimited number of times."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean. If true, the integers are randomly shuffled within each\nepoch."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). Seed used if shuffle == True."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. Sets the queue capacity."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operations (optional)."}]}},
{"id": "tf.compat.v1.train.start_queue_runners", "type": "function", "code": "tf.compat.v1.train.start_queue_runners(sess=None,coord=None,daemon=True,start=True,collection=tf.GraphKeys.QUEUE_RUNNERS)", "summary": "Starts all queue runners collected in the graph. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.start_queue_runners", "parameters": [{"name": "sess", "is_optional": true, "type": "others", "default_value": "None", "description": "Session used to run the queue ops.  Defaults to the\ndefault session."}, {"name": "coord", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional Coordinator for coordinating the started threads."}, {"name": "daemon", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether the threads should be marked as daemons, meaning\nthey don't block program exit."}, {"name": "start", "is_optional": true, "type": "bool", "default_value": "True", "description": "Set to False to only create the threads, not start them."}, {"name": "collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.QUEUE_RUNNERS", "description": "A GraphKey specifying the graph collection to\nget the queue runners from.  Defaults to GraphKeys.QUEUE_RUNNERS."}]}},
{"id": "tf.compat.v1.train.SingularMonitoredSession", "type": "class", "code": "tf.compat.v1.train.SingularMonitoredSession(hooks=None,scaffold=None,master='',config=None,checkpoint_dir=None,stop_grace_period_secs=120,checkpoint_filename_with_path=None)", "summary": "Session-like object that handles initialization, restoring, and hooks.", "description": "", "code-info": {"name": "tf.compat.v1.train.SingularMonitoredSession", "parameters": [{"name": "hooks", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable of `SessionRunHook' objects."}, {"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "A Scaffold used for gathering or building supportive ops. If\nnot specified a default one is created. It's used to finalize the graph."}, {"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": "String representation of the TensorFlow master to use."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "ConfigProto proto used to configure the session."}, {"name": "checkpoint_dir", "is_optional": true, "type": "string", "default_value": "None", "description": "A string.  Optional path to a directory where to restore\nvariables."}, {"name": "stop_grace_period_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Number of seconds given to threads to stop after\nclose() has been called."}, {"name": "checkpoint_filename_with_path", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Optional path to a checkpoint\nfile from which to restore variables."}]}},
{"id": "tf.compat.v1.train.shuffle_batch", "type": "function", "code": "tf.compat.v1.train.shuffle_batch(tensors,batch_size,capacity,min_after_dequeue,num_threads=1,seed=None,enqueue_many=False,shapes=None,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Creates batches by randomly shuffling tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.shuffle_batch", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "The list or dictionary of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The maximum number of elements in the queue."}, {"name": "min_after_dequeue", "is_optional": false, "type": "others", "description": "Minimum number elements in the queue after a\ndequeue, used to ensure a level of mixing of elements."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of threads enqueuing tensor_list."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Seed for the random shuffling within the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list is a single example."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensor_list."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.Scaffold", "type": "class", "code": "tf.compat.v1.train.Scaffold(init_op=None,init_feed_dict=None,init_fn=None,ready_op=None,ready_for_local_init_op=None,local_init_op=None,summary_op=None,saver=None,copy_from_scaffold=None,local_init_feed_dict=None)", "summary": "Structure to create or gather pieces commonly needed to train a model.", "description": "", "code-info": {"name": "tf.compat.v1.train.Scaffold", "parameters": [{"name": "init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An op to run to initialize the variables.  Picked from and\nstored into the INIT_OP collection in the graph by default.\nready_op: An op to verify that the variables are initialized.  Picked\nfrom and stored into the READY_OP collection in the graph by default.\nready_for_local_init_op: An op to verify that global state has been\ninitialized and it is alright to run local_init_op.  Picked from and\nstored into the READY_FOR_LOCAL_INIT_OP collection in the graph by\ndefault. This is needed when the initialization of local variables depends\non the values of global variables.\nlocal_init_op: An op to initialize the local variables.  Picked\nfrom and stored into the LOCAL_INIT_OP collection in the graph by default.\nsummary_op: An op to run and merge the summaries in the graph.  Picked\nfrom and stored into the SUMMARY_OP collection in the graph by default.\n\n\nYou can also pass the following additional pieces to the constructor:\n\n"}, {"name": "init_feed_dict", "is_optional": true, "type": "others", "default_value": "None", "description": "A session feed dictionary that should be used when\nrunning the init op."}, {"name": "init_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A callable to run after the init op to perform additional\ninitializations.  The callable will be called as\ninit_fn(scaffold, session).\n\n\nArgs:\n\n\ninit_op: Optional op for initializing variables.\ninit_feed_dict: Optional session feed dictionary to use when running the\ninit_op."}, {"name": "ready_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An op to verify that the variables are initialized.  Picked\nfrom and stored into the READY_OP collection in the graph by default."}, {"name": "ready_for_local_init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An op to verify that global state has been\ninitialized and it is alright to run local_init_op.  Picked from and\nstored into the READY_FOR_LOCAL_INIT_OP collection in the graph by\ndefault. This is needed when the initialization of local variables depends\non the values of global variables."}, {"name": "local_init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An op to initialize the local variables.  Picked\nfrom and stored into the LOCAL_INIT_OP collection in the graph by default."}, {"name": "summary_op", "is_optional": true, "type": "others", "default_value": "None", "description": "An op to run and merge the summaries in the graph.  Picked\nfrom and stored into the SUMMARY_OP collection in the graph by default.\n\n\nYou can also pass the following additional pieces to the constructor:\n\n\ninit_feed_dict: A session feed dictionary that should be used when\nrunning the init op.\ninit_fn: A callable to run after the init op to perform additional\ninitializations.  The callable will be called as\ninit_fn(scaffold, session).\n\n\nArgs:\n\n\ninit_op: Optional op for initializing variables.\ninit_feed_dict: Optional session feed dictionary to use when running the\ninit_op.\ninit_fn: Optional function to use to initialize the model after running\nthe init_op.  Will be called as init_fn(scaffold, session).\nready_op: Optional op to verify that the variables are initialized.  Must\nreturn an empty 1D string tensor when the variables are initialized, or\na non-empty 1D string tensor listing the names of the non-initialized\nvariables.\nready_for_local_init_op: Optional op to verify that the global variables\nare initialized and local_init_op can be run. Must return an empty 1D\nstring tensor when the global variables are initialized, or a non-empty\n1D string tensor listing the names of the non-initialized global\nvariables.\nlocal_init_op: Optional op to initialize local variables."}, {"name": "saver", "is_optional": true, "type": "others", "default_value": "None", "description": "A tf.compat.v1.train.Saver object taking care of saving the\nvariables.\nPicked from and stored into the SAVERS collection in the graph by default.\ninit_op: An op to run to initialize the variables.  Picked from and\nstored into the INIT_OP collection in the graph by default.\nready_op: An op to verify that the variables are initialized.  Picked\nfrom and stored into the READY_OP collection in the graph by default.\nready_for_local_init_op: An op to verify that global state has been\ninitialized and it is alright to run local_init_op.  Picked from and\nstored into the READY_FOR_LOCAL_INIT_OP collection in the graph by\ndefault. This is needed when the initialization of local variables depends\non the values of global variables.\nlocal_init_op: An op to initialize the local variables.  Picked\nfrom and stored into the LOCAL_INIT_OP collection in the graph by default.\nsummary_op: An op to run and merge the summaries in the graph.  Picked\nfrom and stored into the SUMMARY_OP collection in the graph by default.\n\n\nYou can also pass the following additional pieces to the constructor:\n\n\ninit_feed_dict: A session feed dictionary that should be used when\nrunning the init op.\ninit_fn: A callable to run after the init op to perform additional\ninitializations.  The callable will be called as\ninit_fn(scaffold, session).\n\n\nArgs:\n\n\ninit_op: Optional op for initializing variables.\ninit_feed_dict: Optional session feed dictionary to use when running the\ninit_op.\ninit_fn: Optional function to use to initialize the model after running\nthe init_op.  Will be called as init_fn(scaffold, session).\nready_op: Optional op to verify that the variables are initialized.  Must\nreturn an empty 1D string tensor when the variables are initialized, or\na non-empty 1D string tensor listing the names of the non-initialized\nvariables.\nready_for_local_init_op: Optional op to verify that the global variables\nare initialized and local_init_op can be run. Must return an empty 1D\nstring tensor when the global variables are initialized, or a non-empty\n1D string tensor listing the names of the non-initialized global\nvariables.\nlocal_init_op: Optional op to initialize local variables.\nsummary_op: Optional op to gather all summaries.  Must return a scalar\nstring tensor containing a serialized Summary proto."}, {"name": "copy_from_scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional scaffold object to copy fields from. Its\nfields will be overwritten by the provided fields in this function."}, {"name": "local_init_feed_dict", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional session feed dictionary to use when running\nthe local_init_op."}]}},
{"id": "tf.compat.v1.train.sdca_optimizer", "type": "function", "code": "tf.compat.v1.train.sdca_optimizer(sparse_example_indices,sparse_feature_indices,sparse_feature_values,dense_features,example_weights,example_labels,sparse_indices,sparse_weights,dense_weights,example_state_data,loss_type,l1,l2,num_loss_partitions,num_inner_iterations,adaptative=True,name=None)", "summary": "Distributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for", "description": "", "code-info": {"name": "tf.compat.v1.train.sdca_optimizer", "parameters": [{"name": "sparse_example_indices", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with type int64.\na list of vectors which contain example indices."}, {"name": "sparse_feature_indices", "is_optional": false, "type": "others", "description": "A list with the same length as sparse_example_indices of Tensor objects with type int64.\na list of vectors which contain feature indices."}, {"name": "sparse_feature_values", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with type float32.\na list of vectors which contains feature value\nassociated with each feature group."}, {"name": "dense_features", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with type float32.\na list of matrices which contains the dense feature values."}, {"name": "example_weights", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\na vector which contains the weight associated with each\nexample."}, {"name": "example_labels", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\na vector which contains the label/target associated with each\nexample."}, {"name": "sparse_indices", "is_optional": false, "type": "others", "description": "A list with the same length as sparse_example_indices of Tensor objects with type int64.\na list of vectors where each value is the indices which has\ncorresponding weights in sparse_weights. This field maybe omitted for the\ndense approach."}, {"name": "sparse_weights", "is_optional": false, "type": "others", "description": "A list with the same length as sparse_example_indices of Tensor objects with type float32.\na list of vectors where each value is the weight associated with\na sparse feature group."}, {"name": "dense_weights", "is_optional": false, "type": "others", "description": "A list with the same length as dense_features of Tensor objects with type float32.\na list of vectors where the values are the weights associated\nwith a dense feature group."}, {"name": "example_state_data", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\na list of vectors containing the example state data."}, {"name": "loss_type", "is_optional": false, "type": "string", "description": "A string from: \"logistic_loss\", \"squared_loss\", \"hinge_loss\", \"smooth_hinge_loss\", \"poisson_loss\".\nType of the primal loss. Currently SdcaSolver supports logistic,\nsquared and hinge losses."}, {"name": "l1", "is_optional": false, "type": "float", "description": "A float. Symmetric l1 regularization strength."}, {"name": "l2", "is_optional": false, "type": "float", "description": "A float. Symmetric l2 regularization strength."}, {"name": "num_loss_partitions", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1.\nNumber of partitions of the global loss function."}, {"name": "num_inner_iterations", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1.\nNumber of iterations per mini-batch."}, {"name": "adaptative", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nWhether to use Adaptive SDCA for the inner loop."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.train.summary_iterator", "type": "function", "code": "tf.compat.v1.train.summary_iterator(path)", "summary": "An iterator for reading Event protocol buffers from an event file.", "description": "", "code-info": {"name": "tf.compat.v1.train.summary_iterator", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "The path to an event file created by a SummaryWriter."}]}},
{"id": "tf.compat.v1.train.sdca_fprint", "type": "function", "code": "tf.compat.v1.train.sdca_fprint(input,name=None)", "summary": "Computes fingerprints of the input strings.", "description": "", "code-info": {"name": "tf.compat.v1.train.sdca_fprint", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nvector of strings to compute fingerprints on."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.train.Saver", "type": "class", "code": "tf.compat.v1.train.Saver(var_list=None,reshape=False,sharded=False,max_to_keep=5,keep_checkpoint_every_n_hours=10000.0,name=None,restore_sequentially=False,saver_def=None,builder=None,defer_build=False,allow_empty=False,write_version=tf.train.SaverDef.V2,pad_step_number=False,save_relative_paths=False,filename=None)", "summary": "Saves and restores variables.", "description": "", "code-info": {"name": "tf.compat.v1.train.Saver", "parameters": [{"name": "var_list", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of Variable/SaveableObject, or a dictionary mapping\nnames to SaveableObjects. If None, defaults to the list of all\nsaveable objects."}, {"name": "reshape", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, allows restoring parameters from a checkpoint where\nthe variables have a different shape."}, {"name": "sharded", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, shard the checkpoints, one per device."}, {"name": "max_to_keep", "is_optional": true, "type": "int", "default_value": "5", "description": "Maximum number of recent checkpoints to keep. Defaults to 5."}, {"name": "keep_checkpoint_every_n_hours", "is_optional": true, "type": "others", "default_value": "10000.0", "description": "In addition to keeping the most recent\nmax_to_keep checkpoint files, you might want to keep one checkpoint file\nfor every N hours of training.  This can be useful if you want to later\nanalyze how a model progressed during a long training session.  For\nexample, passing keep_checkpoint_every_n_hours=2 ensures that you keep\none checkpoint file for every 2 hours of training.  The default value of\n10,000 hours effectively disables the feature.\n\n\nNote that you still have to call the save() method to save the model.\nPassing these arguments to the constructor will not save variables\nautomatically for you.\n\nA training program that saves regularly looks like:\n...\n# Create a saver.\nsaver = tf.compat.v1.train.Saver(...variables...)\n# Launch the graph and train, saving the model every 1,000 steps.\nsess = tf.compat.v1.Session()\nfor step in xrange(1000000):\n    sess.run(..training_op..)\n    if step % 1000 == 0:\n        # Append the step number to the checkpoint name:\n        saver.save(sess, 'my-model', global_step=step)\n\nIn addition to checkpoint files, savers keep a protocol buffer on disk with\nthe list of recent checkpoints. This is used to manage numbered checkpoint\nfiles and by latest_checkpoint(), which makes it easy to discover the path\nto the most recent checkpoint. That protocol buffer is stored in a file named\n'checkpoint' next to the checkpoint files.\n\nIf you create several savers, you can specify a different filename for the\nprotocol buffer file in the call to save().\n\nArgs:\n\n\nvar_list: A list of Variable/SaveableObject, or a dictionary mapping\nnames to SaveableObjects. If None, defaults to the list of all\nsaveable objects.\nreshape: If True, allows restoring parameters from a checkpoint where\nthe variables have a different shape.\nsharded: If True, shard the checkpoints, one per device.\nmax_to_keep: Maximum number of recent checkpoints to keep. Defaults to 5."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name to use as a prefix when adding operations."}, {"name": "restore_sequentially", "is_optional": true, "type": "bool", "default_value": "False", "description": "A Bool, which if true, causes restore of different\nvariables to happen sequentially within each device.  This can lower\nmemory usage when restoring very large models."}, {"name": "saver_def", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional SaverDef proto to use instead of running the\nbuilder. This is only useful for specialty code that wants to recreate a\nSaver object for a previously built Graph that had a Saver. The\nsaver_def proto should be the one returned by the as_saver_def()\ncall of the Saver that was created for that Graph."}, {"name": "builder", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional SaverBuilder to use if a saver_def was not provided.\nDefaults to BulkSaverBuilder()."}, {"name": "defer_build", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, defer adding the save and restore ops to the\nbuild() call. In that case build() should be called before\nfinalizing the graph or using the saver."}, {"name": "allow_empty", "is_optional": true, "type": "bool", "default_value": "False", "description": "If False (default) raise an error if there are no variables\nin the graph. Otherwise, construct the saver anyway and make it a no-op."}, {"name": "write_version", "is_optional": true, "type": "others", "default_value": "tf.train.SaverDef.V2", "description": "controls what format to use when saving checkpoints.  It\nalso affects certain filepath matching logic.  The V2 format is the\nrecommended choice: it is much more optimized than V1 in terms of memory\nrequired and latency incurred during restore.  Regardless of this\nflag, the Saver is able to restore from both V2 and V1 checkpoints."}, {"name": "pad_step_number", "is_optional": true, "type": "bool", "default_value": "False", "description": "if True, pads the global step number in the checkpoint\nfilepaths to some fixed width (8 by default).  This is turned off by\ndefault."}, {"name": "save_relative_paths", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, will write relative paths to the\ncheckpoint state file. This is needed if the user wants to copy the\ncheckpoint directory and reload from the copied directory."}, {"name": "filename", "is_optional": true, "type": "string", "default_value": "None", "description": "If known at graph construction time, filename used for variable\nloading/saving."}]}},
{"id": "create_session", "type": "function", "code": "create_session()", "summary": "A factory for tf.Session.\n\n\n\nMethods\n\ncreate_session\n\nView source\ncreate_session()", "description": "", "code-info": {"name": "create_session", "parameters": []}},
{"id": "tf.compat.v1.train.sdca_shrink_l1", "type": "function", "code": "tf.compat.v1.train.sdca_shrink_l1(weights,l1,l2,name=None)", "summary": "Applies L1 regularization shrink step on the parameters.", "description": "", "code-info": {"name": "tf.compat.v1.train.sdca_shrink_l1", "parameters": [{"name": "weights", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with type mutable float32.\na list of vectors where each value is the weight associated with a\nfeature group."}, {"name": "l1", "is_optional": false, "type": "float", "description": "A float. Symmetric l1 regularization strength."}, {"name": "l2", "is_optional": false, "type": "float", "description": "A float.\nSymmetric l2 regularization strength. Should be a positive float."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.train.RMSPropOptimizer", "type": "function", "code": "tf.compat.v1.train.RMSPropOptimizer(learning_rate,decay=0.9,momentum=0.0,epsilon=1e-10,use_locking=False,centered=False,name='RMSProp')", "summary": "Optimizer that implements the RMSProp algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.RMSPropOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "decay", "is_optional": true, "type": "others", "default_value": "0.9", "description": "Discounting factor for the history/coming gradient"}, {"name": "momentum", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar tensor."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-10", "description": "Small value to avoid zero denominator."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operation."}, {"name": "centered", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, gradients are normalized by the estimated variance of\nthe gradient; if False, by the uncentered second moment. Setting this to\nTrue may help with training, but is slightly more expensive in terms of\ncomputation and memory. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'RMSProp'", "description": "Optional name prefix for the operations created when applying\ngradients. Defaults to \"RMSProp\"."}]}},
{"id": "tf.compat.v1.train.replica_device_setter", "type": "function", "code": "tf.compat.v1.train.replica_device_setter(ps_tasks=0,ps_device='/job:ps',worker_device='/job:worker',merge_devices=True,cluster=None,ps_ops=None,ps_strategy=None)", "summary": "Return a device function to use when building a Graph for replicas.", "description": "", "code-info": {"name": "tf.compat.v1.train.replica_device_setter", "parameters": [{"name": "ps_tasks", "is_optional": true, "type": "int", "default_value": "0", "description": "Number of tasks in the ps job.  Ignored if cluster is\nprovided."}, {"name": "ps_device", "is_optional": true, "type": "string", "default_value": "'/job:ps'", "description": "String.  Device of the ps job.  If empty no ps job is used.\nDefaults to ps."}, {"name": "worker_device", "is_optional": true, "type": "string", "default_value": "'/job:worker'", "description": "String.  Device of the worker job.  If empty no worker\njob is used."}, {"name": "merge_devices", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean. If True, merges or only sets a device if the\ndevice constraint is completely unset. merges device specification rather\nthan overriding them."}, {"name": "cluster", "is_optional": true, "type": "others", "default_value": "None", "description": "ClusterDef proto or ClusterSpec."}, {"name": "ps_ops", "is_optional": true, "type": "string", "default_value": "None", "description": "List of strings representing Operation types that need to be\nplaced on ps devices.  If None, defaults to STANDARD_PS_OPS."}, {"name": "ps_strategy", "is_optional": true, "type": "others", "default_value": "None", "description": "A callable invoked for every ps Operation (i.e. matched by\nps_ops), that takes the Operation and returns the ps task index to\nuse.  If None, defaults to a round-robin strategy across all ps\ndevices."}]}},
{"id": "tf.compat.v1.train.remove_checkpoint", "type": "function", "code": "tf.compat.v1.train.remove_checkpoint(checkpoint_prefix,checkpoint_format_version=tf.train.SaverDef.V2,meta_graph_suffix='meta')", "summary": "Removes a checkpoint given by checkpoint_prefix. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.remove_checkpoint", "parameters": [{"name": "checkpoint_prefix", "is_optional": false, "type": "others", "description": "The prefix of a V1 or V2 checkpoint. Typically the result\nof Saver.save() or that of tf.train.latest_checkpoint(), regardless of\nsharded/non-sharded or V1/V2."}, {"name": "checkpoint_format_version", "is_optional": true, "type": "others", "default_value": "tf.train.SaverDef.V2", "description": "SaverDef.CheckpointFormatVersion, defaults to\nSaverDef.V2."}, {"name": "meta_graph_suffix", "is_optional": true, "type": "string", "default_value": "'meta'", "description": "Suffix for MetaGraphDef file. Defaults to 'meta'."}]}},
{"id": "tf.compat.v1.train.QueueRunner", "type": "class", "code": "tf.compat.v1.train.QueueRunner(queue=None,enqueue_ops=None,close_op=None,cancel_op=None,queue_closed_exception_types=None,queue_runner_def=None,import_scope=None)", "summary": "Holds a list of enqueue operations for a queue, each to be run in a thread.", "description": "", "code-info": {"name": "tf.compat.v1.train.QueueRunner", "parameters": [{"name": "queue", "is_optional": true, "type": "others", "default_value": "None", "description": "A Queue."}, {"name": "enqueue_ops", "is_optional": true, "type": "others", "default_value": "None", "description": "List of enqueue ops to run in threads later."}, {"name": "close_op", "is_optional": true, "type": "others", "default_value": "None", "description": "Op to close the queue. Pending enqueue ops are preserved."}, {"name": "cancel_op", "is_optional": true, "type": "others", "default_value": "None", "description": "Op to close the queue and cancel pending enqueue ops."}, {"name": "queue_closed_exception_types", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tuple of Exception types that\nindicate that the queue has been closed when raised during an enqueue\noperation.  Defaults to (tf.errors.OutOfRangeError,).  Another common\ncase includes (tf.errors.OutOfRangeError, tf.errors.CancelledError),\nwhen some of the enqueue ops may dequeue from other Queues."}, {"name": "queue_runner_def", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional QueueRunnerDef protocol buffer. If specified,\nrecreates the QueueRunner from its contents. queue_runner_def and the\nother arguments are mutually exclusive."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope to add. Only used when\ninitializing from protocol buffer."}]}},
{"id": "tf.compat.v1.train.ProximalGradientDescentOptimizer", "type": "function", "code": "tf.compat.v1.train.ProximalGradientDescentOptimizer(learning_rate,l1_regularization_strength=0.0,l2_regularization_strength=0.0,use_locking=False,name='ProximalGradientDescent')", "summary": "Optimizer that implements the proximal gradient descent algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.ProximalGradientDescentOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning\nrate to use."}, {"name": "l1_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "l2_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ProximalGradientDescent'", "description": "Optional name prefix for the operations created when applying\ngradients. Defaults to \"GradientDescent\"."}]}},
{"id": "tf.compat.v1.train.ProximalAdagradOptimizer", "type": "function", "code": "tf.compat.v1.train.ProximalAdagradOptimizer(learning_rate,initial_accumulator_value=0.1,l1_regularization_strength=0.0,l2_regularization_strength=0.0,use_locking=False,name='ProximalAdagrad')", "summary": "Optimizer that implements the Proximal Adagrad algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.ProximalAdagradOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "initial_accumulator_value", "is_optional": true, "type": "float", "default_value": "0.1", "description": "A floating point value.\nStarting value for the accumulators, must be positive."}, {"name": "l1_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "l2_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ProximalAdagrad'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Adagrad\"."}]}},
{"id": "tf.compat.v1.train.polynomial_decay", "type": "function", "code": "tf.compat.v1.train.polynomial_decay(learning_rate,global_step,decay_steps,end_learning_rate=0.0001,power=1.0,cycle=False,name=None)", "summary": "Applies a polynomial decay to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.polynomial_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation.  Must not be negative."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Must\nbe positive.  See the decay computation above."}, {"name": "end_learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.0001", "description": "A scalar float32 or float64 Tensor or a Python\nnumber.  The minimal end learning rate."}, {"name": "power", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A scalar float32 or float64 Tensor or a Python number.  The\npower of the polynomial. Defaults to linear, 1.0."}, {"name": "cycle", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean, whether or not it should cycle beyond decay_steps."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation. Defaults to\n'PolynomialDecay'."}]}},
{"id": "tf.compat.v1.train.range_input_producer", "type": "function", "code": "tf.compat.v1.train.range_input_producer(limit,num_epochs=None,shuffle=True,seed=None,capacity=32,shared_name=None,name=None)", "summary": "Produces the integers from 0 to limit-1 in a queue. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.range_input_producer", "parameters": [{"name": "limit", "is_optional": false, "type": "tensor", "description": "An int32 scalar tensor."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). If specified, range_input_producer\nproduces each integer num_epochs times before generating an\nOutOfRange error. If not specified, range_input_producer can cycle\nthrough the integers an unlimited number of times."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean. If true, the integers are randomly shuffled within each\nepoch."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer (optional). Seed used if shuffle == True."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. Sets the queue capacity."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operations (optional)."}]}},
{"id": "tf.compat.v1.train.MonitoredSession.StepContext", "type": "class", "code": "tf.compat.v1.train.MonitoredSession.StepContext(session,run_with_hooks_fn)", "summary": "Control flow instrument for the step_fn from run_step_fn().", "description": "", "code-info": {"name": "tf.compat.v1.train.MonitoredSession.StepContext", "parameters": [{"name": "session", "is_optional": false, "type": "others", "description": "An instance of tf.compat.v1.Session."}, {"name": "run_with_hooks_fn", "is_optional": false, "type": "others", "description": "A function for running fetches and hooks."}]}},
{"id": "tf.compat.v1.train.Optimizer", "type": "function", "code": "tf.compat.v1.train.Optimizer(use_locking,name)", "summary": "Base class for optimizers.", "description": "", "code-info": {"name": "tf.compat.v1.train.Optimizer", "parameters": [{"name": "use_locking", "is_optional": false, "type": "bool", "description": "Bool. If True apply use locks to prevent concurrent updates\nto variables."}, {"name": "name", "is_optional": false, "type": "string", "description": "A non-empty string.  The name to use for accumulators created\nfor the optimizer."}]}},
{"id": "tf.compat.v1.train.NewCheckpointReader", "type": "function", "code": "tf.compat.v1.train.NewCheckpointReader(filepattern)", "summary": "A function that returns a CheckPointReader.", "description": "", "code-info": {"name": "tf.compat.v1.train.NewCheckpointReader", "parameters": [{"name": "filepattern", "is_optional": false, "type": "string", "description": "The filename."}]}},
{"id": "tf.compat.v1.train.MonitoredSession", "type": "class", "code": "tf.compat.v1.train.MonitoredSession(session_creator=None,hooks=None,stop_grace_period_secs=120)", "summary": "Session-like object that handles initialization, recovery and hooks.", "description": "", "code-info": {"name": "tf.compat.v1.train.MonitoredSession", "parameters": [{"name": "session_creator", "is_optional": true, "type": "others", "default_value": "None", "description": "A factory object to create session. Typically a\nChiefSessionCreator which is the default one."}, {"name": "hooks", "is_optional": true, "type": "others", "default_value": "None", "description": "An iterable of `SessionRunHook' objects.\n\n\nReturns:\n\nA MonitoredSession object.\n\nArgs:\n\n\nsession_creator: A factory object to create session. Typically a\nChiefSessionCreator or a WorkerSessionCreator."}, {"name": "stop_grace_period_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Number of seconds given to threads to stop after\nclose() has been called."}]}},
{"id": "tf.compat.v1.train.piecewise_constant", "type": "function", "code": "tf.compat.v1.train.piecewise_constant(x,boundaries,values,name=None)", "summary": "Piecewise constant from boundaries and interval values.", "description": "", "code-info": {"name": "tf.compat.v1.train.piecewise_constant", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A 0-D scalar Tensor. Must be one of the following types: float32,\nfloat64, uint8, int8, int16, int32, int64."}, {"name": "boundaries", "is_optional": false, "type": "tensor", "description": "A list of Tensors or ints or floats with strictly\nincreasing entries, and with all elements having the same type as x."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensors or floats or ints that specifies the values\nfor the intervals defined by boundaries. It should have one more element\nthan boundaries, and all elements should have the same type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Optional name of the operation. Defaults to\n'PiecewiseConstant'."}]}},
{"id": "tf.compat.v1.train.natural_exp_decay", "type": "function", "code": "tf.compat.v1.train.natural_exp_decay(learning_rate,global_step,decay_steps,decay_rate,staircase=False,name=None)", "summary": "Applies natural exponential decay to the initial learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.natural_exp_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "others", "description": "A Python number. Global step to use for the decay computation.\nMust not be negative."}, {"name": "decay_steps", "is_optional": false, "type": "others", "description": "How often to apply decay."}, {"name": "decay_rate", "is_optional": false, "type": "others", "description": "A Python number.  The decay rate."}, {"name": "staircase", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to apply decay in a discrete staircase, as opposed to\ncontinuous, fashion."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'ExponentialTimeDecay'."}]}},
{"id": "tf.compat.v1.train.maybe_shuffle_batch", "type": "function", "code": "tf.compat.v1.train.maybe_shuffle_batch(tensors,batch_size,capacity,min_after_dequeue,keep_input,num_threads=1,seed=None,enqueue_many=False,shapes=None,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Creates batches by randomly shuffling conditionally-enqueued tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.maybe_shuffle_batch", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "The list or dictionary of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The maximum number of elements in the queue."}, {"name": "min_after_dequeue", "is_optional": false, "type": "others", "description": "Minimum number elements in the queue after a\ndequeue, used to ensure a level of mixing of elements."}, {"name": "keep_input", "is_optional": false, "type": "tensor", "description": "A bool Tensor.  This tensor controls whether the input is\nadded to the queue or not.  If it is a scalar and evaluates True, then\ntensors are all added to the queue. If it is a vector and enqueue_many\nis True, then each example is added to the queue only if the\ncorresponding value in keep_input is True. This tensor essentially\nacts as a filtering mechanism."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of threads enqueuing tensor_list."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Seed for the random shuffling within the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list is a single example."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensor_list."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.MonitoredTrainingSession", "type": "function", "code": "tf.compat.v1.train.MonitoredTrainingSession(master='',is_chief=True,checkpoint_dir=None,scaffold=None,hooks=None,chief_only_hooks=None,save_checkpoint_secs=USE_DEFAULT,save_summaries_steps=USE_DEFAULT,save_summaries_secs=USE_DEFAULT,config=None,stop_grace_period_secs=120,log_step_count_steps=100,max_wait_secs=7200,save_checkpoint_steps=USE_DEFAULT,summary_dir=None,save_graph_def=True)", "summary": "Creates a MonitoredSession for training.", "description": "", "code-info": {"name": "tf.compat.v1.train.MonitoredTrainingSession", "parameters": [{"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": "String the TensorFlow master to use."}, {"name": "is_chief", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, it will take care of initialization and recovery the\nunderlying TensorFlow session. If False, it will wait on a chief to\ninitialize or recover the TensorFlow session."}, {"name": "checkpoint_dir", "is_optional": true, "type": "string", "default_value": "None", "description": "A string.  Optional path to a directory where to restore\nvariables."}, {"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "A Scaffold used for gathering or building supportive ops. If not\nspecified, a default one is created. It's used to finalize the graph."}, {"name": "hooks", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of SessionRunHook objects."}, {"name": "chief_only_hooks", "is_optional": true, "type": "others", "default_value": "None", "description": "list of SessionRunHook objects. Activate these hooks if\nis_chief==True, ignore otherwise."}, {"name": "save_checkpoint_secs", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "The frequency, in seconds, that a checkpoint is saved\nusing a default checkpoint saver. If both save_checkpoint_steps and\nsave_checkpoint_secs are set to None, then the default checkpoint\nsaver isn't used. If both are provided, then only save_checkpoint_secs\nis used. Default 600."}, {"name": "save_summaries_steps", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "The frequency, in number of global steps, that the\nsummaries are written to disk using a default summary saver. If both\nsave_summaries_steps and save_summaries_secs are set to None, then\nthe default summary saver isn't used. Default 100."}, {"name": "save_summaries_secs", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "The frequency, in secs, that the summaries are written\nto disk using a default summary saver.  If both save_summaries_steps and\nsave_summaries_secs are set to None, then the default summary saver\nisn't used. Default not enabled."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "an instance of tf.compat.v1.ConfigProto proto used to configure\nthe session. It's the config argument of constructor of\ntf.compat.v1.Session."}, {"name": "stop_grace_period_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Number of seconds given to threads to stop after\nclose() has been called."}, {"name": "log_step_count_steps", "is_optional": true, "type": "int", "default_value": "100", "description": "The frequency, in number of global steps, that the\nglobal step/sec is logged."}, {"name": "max_wait_secs", "is_optional": true, "type": "int", "default_value": "7200", "description": "Maximum time workers should wait for the session to become\navailable. This should be kept relatively short to help detect incorrect\ncode, but sometimes may need to be increased if the chief takes a while to\nstart up."}, {"name": "save_checkpoint_steps", "is_optional": true, "type": "others", "default_value": "USE_DEFAULT", "description": "The frequency, in number of global steps, that a\ncheckpoint is saved using a default checkpoint saver. If both\nsave_checkpoint_steps and save_checkpoint_secs are set to None, then\nthe default checkpoint saver isn't used. If both are provided, then only\nsave_checkpoint_secs is used. Default not enabled."}, {"name": "summary_dir", "is_optional": true, "type": "string", "default_value": "None", "description": "A string.  Optional path to a directory where to save\nsummaries. If None, checkpoint_dir is used instead."}, {"name": "save_graph_def", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to save the GraphDef and MetaGraphDef to\ncheckpoint_dir. The GraphDef is saved after the session is created as\ngraph.pbtxt. MetaGraphDefs are saved out for every checkpoint as\nmodel.ckpt-*.meta."}]}},
{"id": "tf.compat.v1.train.maybe_batch_join", "type": "function", "code": "tf.compat.v1.train.maybe_batch_join(tensors_list,keep_input,batch_size,capacity=32,enqueue_many=False,shapes=None,dynamic_pad=False,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Runs a list of tensors to conditionally fill a queue to create batches. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.maybe_batch_join", "parameters": [{"name": "tensors_list", "is_optional": false, "type": "tensor", "description": "A list of tuples or dictionaries of tensors to enqueue."}, {"name": "keep_input", "is_optional": false, "type": "tensor", "description": "A bool Tensor.  This tensor controls whether the input is\nadded to the queue or not.  If it is a scalar and evaluates True, then\ntensors are all added to the queue. If it is a vector and enqueue_many\nis True, then each example is added to the queue only if the\ncorresponding value in keep_input is True. This tensor essentially\nacts as a filtering mechanism."}, {"name": "batch_size", "is_optional": false, "type": "int", "description": "An integer. The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. The maximum number of elements in the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list_list is a single\nexample."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensor_list_list[i]."}, {"name": "dynamic_pad", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  Allow variable dimensions in input shapes.\nThe given dimensions are padded upon dequeue so that tensors within a\nbatch have the same shapes."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.maybe_batch", "type": "function", "code": "tf.compat.v1.train.maybe_batch(tensors,keep_input,batch_size,num_threads=1,capacity=32,enqueue_many=False,shapes=None,dynamic_pad=False,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Conditionally creates batches of tensors based on keep_input. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.maybe_batch", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "The list or dictionary of tensors to enqueue."}, {"name": "keep_input", "is_optional": false, "type": "tensor", "description": "A bool Tensor.  This tensor controls whether the input is\nadded to the queue or not.  If it is a scalar and evaluates True, then\ntensors are all added to the queue. If it is a vector and enqueue_many\nis True, then each example is added to the queue only if the\ncorresponding value in keep_input is True. This tensor essentially\nacts as a filtering mechanism."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "The new batch size pulled from the queue."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of threads enqueuing tensors.  The batching will\nbe nondeterministic if num_threads &gt; 1."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. The maximum number of elements in the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensors is a single example."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensors."}, {"name": "dynamic_pad", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  Allow variable dimensions in input shapes.\nThe given dimensions are padded upon dequeue so that tensors within a\nbatch have the same shapes."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.noisy_linear_cosine_decay", "type": "function", "code": "tf.compat.v1.train.noisy_linear_cosine_decay(learning_rate,global_step,decay_steps,initial_variance=1.0,variance_decay=0.55,num_periods=0.5,alpha=0.0,beta=0.001,name=None)", "summary": "Applies noisy linear cosine decay to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.noisy_linear_cosine_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Number\nof steps to decay over."}, {"name": "initial_variance", "is_optional": true, "type": "others", "default_value": "1.0", "description": "initial variance for the noise. See computation above."}, {"name": "variance_decay", "is_optional": true, "type": "others", "default_value": "0.55", "description": "decay for the noise's variance. See computation above."}, {"name": "num_periods", "is_optional": true, "type": "others", "default_value": "0.5", "description": "Number of periods in the cosine part of the decay. See\ncomputation above."}, {"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.0", "description": "See computation above."}, {"name": "beta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "See computation above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'NoisyLinearCosineDecay'."}]}},
{"id": "tf.compat.v1.train.maybe_shuffle_batch_join", "type": "function", "code": "tf.compat.v1.train.maybe_shuffle_batch_join(tensors_list,batch_size,capacity,min_after_dequeue,keep_input,seed=None,enqueue_many=False,shapes=None,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Create batches by randomly shuffling conditionally-enqueued tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.maybe_shuffle_batch_join", "parameters": [{"name": "tensors_list", "is_optional": false, "type": "tensor", "description": "A list of tuples or dictionaries of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "int", "description": "An integer. The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": false, "type": "int", "description": "An integer. The maximum number of elements in the queue."}, {"name": "min_after_dequeue", "is_optional": false, "type": "others", "description": "Minimum number elements in the queue after a\ndequeue, used to ensure a level of mixing of elements."}, {"name": "keep_input", "is_optional": false, "type": "tensor", "description": "A bool Tensor.  This tensor controls whether the input is\nadded to the queue or not.  If it is a scalar and evaluates True, then\ntensors are all added to the queue. If it is a vector and enqueue_many\nis True, then each example is added to the queue only if the\ncorresponding value in keep_input is True. This tensor essentially\nacts as a filtering mechanism."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Seed for the random shuffling within the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list_list is a single\nexample."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensors_list[i]."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional). If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.MomentumOptimizer", "type": "function", "code": "tf.compat.v1.train.MomentumOptimizer(learning_rate,momentum,use_locking=False,name='Momentum',use_nesterov=False)", "summary": "Optimizer that implements the Momentum algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.MomentumOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "momentum", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The momentum."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Momentum'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Momentum\"."}, {"name": "use_nesterov", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use Nesterov Momentum.\nSee Sutskever et al., 2013.\nThis implementation always computes gradients at the value of the\nvariable(s) passed to the optimizer. Using Nesterov Momentum makes the\nvariable(s) track the values called theta_t + mu*v_t in the paper.\nThis implementation is an approximation of the original formula, valid \nfor high values of momentum. It will compute the \"adjusted gradient\" \nin NAG by assuming that the new gradient will be estimated by the \ncurrent average gradient plus the product of momentum and the change \nin the average gradient."}]}},
{"id": "tf.compat.v1.train.inverse_time_decay", "type": "function", "code": "tf.compat.v1.train.inverse_time_decay(learning_rate,global_step,decay_steps,decay_rate,staircase=False,name=None)", "summary": "Applies inverse time decay to the initial learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.inverse_time_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "others", "description": "A Python number. Global step to use for the decay computation.\nMust not be negative."}, {"name": "decay_steps", "is_optional": false, "type": "others", "description": "How often to apply decay."}, {"name": "decay_rate", "is_optional": false, "type": "others", "description": "A Python number.  The decay rate."}, {"name": "staircase", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to apply decay in a discrete staircase, as opposed to\ncontinuous, fashion."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'InverseTimeDecay'."}]}},
{"id": "tf.compat.v1.train.input_producer", "type": "function", "code": "tf.compat.v1.train.input_producer(input_tensor,element_shape=None,num_epochs=None,shuffle=True,seed=None,capacity=32,shared_name=None,summary_name=None,name=None,cancel_op=None)", "summary": "Output the rows of input_tensor to a queue for an input pipeline. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.input_producer", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "A tensor with the rows to produce. Must be at least\none-dimensional. Must either have a fully-defined shape, or\nelement_shape must be defined."}, {"name": "element_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A TensorShape representing the shape of a\nrow of input_tensor, if it cannot be inferred."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "(Optional.) An integer. If specified input_producer produces\neach row of input_tensor num_epochs times before generating an\nOutOfRange error. If not specified, input_producer can cycle through\nthe rows of input_tensor an unlimited number of times."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "(Optional.) A boolean. If true, the rows are randomly shuffled\nwithin each epoch."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "(Optional.) An integer. The seed to use if shuffle is true."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "(Optional.) The capacity of the queue to be used for buffering\nthe input."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "summary_name", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) If set, a scalar summary for the current queue\nsize will be generated, using this name as part of the tag."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A name for queue."}, {"name": "cancel_op", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Cancel op for the queue"}]}},
{"id": "tf.compat.v1.train.linear_cosine_decay", "type": "function", "code": "tf.compat.v1.train.linear_cosine_decay(learning_rate,global_step,decay_steps,num_periods=0.5,alpha=0.0,beta=0.001,name=None)", "summary": "Applies linear cosine decay to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.linear_cosine_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Number\nof steps to decay over."}, {"name": "num_periods", "is_optional": true, "type": "others", "default_value": "0.5", "description": "Number of periods in the cosine part of the decay. See\ncomputation above."}, {"name": "alpha", "is_optional": true, "type": "others", "default_value": "0.0", "description": "See computation above."}, {"name": "beta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "See computation above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'LinearCosineDecay'."}]}},
{"id": "tf.compat.v1.train.LooperThread", "type": "class", "code": "tf.compat.v1.train.LooperThread(coord,timer_interval_secs,target=None,args=None,kwargs=None)", "summary": "A thread that runs code repeatedly, optionally on a timer.", "description": "", "code-info": {"name": "tf.compat.v1.train.LooperThread", "parameters": [{"name": "coord", "is_optional": false, "type": "others", "description": "A Coordinator."}, {"name": "timer_interval_secs", "is_optional": false, "type": "others", "description": "Time boundaries at which to call Run(), or None\nif it should be called back to back."}, {"name": "target", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional callable object that will be executed in the thread."}, {"name": "args", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional arguments to pass to target when calling it."}, {"name": "kwargs", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional keyword arguments to pass to target when calling it."}]}},
{"id": "tf.compat.v1.train.limit_epochs", "type": "function", "code": "tf.compat.v1.train.limit_epochs(tensor,num_epochs=None,name=None)", "summary": "Returns tensor num_epochs times and then raises an OutOfRange error. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.limit_epochs", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Any Tensor."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "A positive integer (optional).  If specified, limits the number\nof steps the output tensor may be evaluated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operations (optional)."}]}},
{"id": "tf.compat.v1.train.import_meta_graph", "type": "function", "code": "tf.compat.v1.train.import_meta_graph(meta_graph_or_file,clear_devices=False,import_scope=None,**kwargs)", "summary": "Recreates a Graph saved in a MetaGraphDef proto.", "description": "", "code-info": {"name": "tf.compat.v1.train.import_meta_graph", "parameters": [{"name": "meta_graph_or_file", "is_optional": false, "type": "string", "description": "MetaGraphDef protocol buffer or filename (including\nthe path) containing a MetaGraphDef."}, {"name": "clear_devices", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether or not to clear the device field for an Operation\nor Tensor during import."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope to add. Only used when\ninitializing from protocol buffer."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Optional keyed arguments."}]}},
{"id": "tf.compat.v1.train.init_from_checkpoint", "type": "function", "code": "tf.compat.v1.train.init_from_checkpoint(ckpt_dir_or_file,assignment_map)", "summary": "Replaces tf.Variable initializers so they load from a checkpoint file.", "description": "", "code-info": {"name": "tf.compat.v1.train.init_from_checkpoint", "parameters": [{"name": "ckpt_dir_or_file", "is_optional": false, "type": "others", "description": "Directory with checkpoints file or path to checkpoint."}, {"name": "assignment_map", "is_optional": false, "type": "string", "description": "Dict, where keys are names of the variables in the\ncheckpoint and values are current variables or names of current variables\n(in default graph)."}]}},
{"id": "tf.compat.v1.train.GradientDescentOptimizer", "type": "function", "code": "tf.compat.v1.train.GradientDescentOptimizer(learning_rate,use_locking=False,name='GradientDescent')", "summary": "Optimizer that implements the gradient descent algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.GradientDescentOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning\nrate to use."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'GradientDescent'", "description": "Optional name prefix for the operations created when applying\ngradients. Defaults to \"GradientDescent\"."}]}},
{"id": "tf.compat.v1.train.global_step", "type": "function", "code": "tf.compat.v1.train.global_step(sess,global_step_tensor)", "summary": "Small helper to get the global step.", "description": "", "code-info": {"name": "tf.compat.v1.train.global_step", "parameters": [{"name": "sess", "is_optional": false, "type": "tensor", "description": "A TensorFlow Session object."}, {"name": "global_step_tensor", "is_optional": false, "type": "tensor", "description": " Tensor or the name of the operation that contains\nthe global step."}]}},
{"id": "tf.compat.v1.train.exponential_decay", "type": "function", "code": "tf.compat.v1.train.exponential_decay(learning_rate,global_step,decay_steps,decay_rate,staircase=False,name=None)", "summary": "Applies exponential decay to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.exponential_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation.  Must not be negative."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Must\nbe positive.  See the decay computation above."}, {"name": "decay_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe decay rate."}, {"name": "staircase", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  If True decay the learning rate at discrete intervals"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String.  Optional name of the operation.  Defaults to\n'ExponentialDecay'."}]}},
{"id": "tf.compat.v1.train.get_or_create_global_step", "type": "function", "code": "tf.compat.v1.train.get_or_create_global_step(graph=None)", "summary": "Returns and create (if necessary) the global step tensor.", "description": "", "code-info": {"name": "tf.compat.v1.train.get_or_create_global_step", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "The graph in which to create the global step tensor. If missing, use\ndefault graph."}]}},
{"id": "tf.compat.v1.train.get_global_step", "type": "function", "code": "tf.compat.v1.train.get_global_step(graph=None)", "summary": "Get the global step tensor.", "description": "", "code-info": {"name": "tf.compat.v1.train.get_global_step", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "The graph to find the global step in. If missing, use default graph."}]}},
{"id": "tf.compat.v1.train.do_quantize_training_on_graphdef", "type": "function", "code": "tf.compat.v1.train.do_quantize_training_on_graphdef(input_graph,num_bits)", "summary": "A general quantization scheme is being developed in tf.contrib.quantize. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.do_quantize_training_on_graphdef", "parameters": [{"name": "input_graph", "is_optional": false, "type": "others", "description": "A GraphDef."}, {"name": "num_bits", "is_optional": false, "type": "others", "description": "The number of bits for quantize training."}]}},
{"id": "tf.compat.v1.train.get_checkpoint_mtimes", "type": "function", "code": "tf.compat.v1.train.get_checkpoint_mtimes(checkpoint_prefixes)", "summary": "Returns the mtimes (modification timestamps) of the checkpoints. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.get_checkpoint_mtimes", "parameters": [{"name": "checkpoint_prefixes", "is_optional": false, "type": "others", "description": "a list of checkpoint paths, typically the results of\nSaver.save() or those of tf.train.latest_checkpoint(), regardless of\nsharded/non-sharded or V1/V2."}]}},
{"id": "tf.compat.v1.train.generate_checkpoint_state_proto", "type": "function", "code": "tf.compat.v1.train.generate_checkpoint_state_proto(save_dir,model_checkpoint_path,all_model_checkpoint_paths=None,all_model_checkpoint_timestamps=None,last_preserved_timestamp=None)", "summary": "Generates a checkpoint state proto.", "description": "", "code-info": {"name": "tf.compat.v1.train.generate_checkpoint_state_proto", "parameters": [{"name": "save_dir", "is_optional": false, "type": "others", "description": "Directory where the model was saved."}, {"name": "model_checkpoint_path", "is_optional": false, "type": "others", "description": "The checkpoint file."}, {"name": "all_model_checkpoint_paths", "is_optional": true, "type": "string", "default_value": "None", "description": "List of strings.  Paths to all not-yet-deleted\ncheckpoints, sorted from oldest to newest.  If this is a non-empty list,\nthe last element must be equal to model_checkpoint_path.  These paths\nare also saved in the CheckpointState proto."}, {"name": "all_model_checkpoint_timestamps", "is_optional": true, "type": "float", "default_value": "None", "description": "A list of floats, indicating the number of\nseconds since the Epoch when each checkpoint was generated."}, {"name": "last_preserved_timestamp", "is_optional": true, "type": "float", "default_value": "None", "description": "A float, indicating the number of seconds since\nthe Epoch when the last preserved checkpoint was written, e.g. due to a\nkeep_checkpoint_every_n_hours parameter (see\ntf.train.CheckpointManager for an implementation)."}]}},
{"id": "tf.compat.v1.train.export_meta_graph", "type": "function", "code": "tf.compat.v1.train.export_meta_graph(filename=None,meta_info_def=None,graph_def=None,saver_def=None,collection_list=None,as_text=False,graph=None,export_scope=None,clear_devices=False,clear_extraneous_savers=False,strip_default_attrs=False,save_debug_info=False,**kwargs)", "summary": "Returns MetaGraphDef proto.", "description": "", "code-info": {"name": "tf.compat.v1.train.export_meta_graph", "parameters": [{"name": "filename", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional filename including the path for writing the generated\nMetaGraphDef protocol buffer."}, {"name": "meta_info_def", "is_optional": true, "type": "others", "default_value": "None", "description": "MetaInfoDef protocol buffer."}, {"name": "graph_def", "is_optional": true, "type": "others", "default_value": "None", "description": "GraphDef protocol buffer."}, {"name": "saver_def", "is_optional": true, "type": "others", "default_value": "None", "description": "SaverDef protocol buffer."}, {"name": "collection_list", "is_optional": true, "type": "string", "default_value": "None", "description": "List of string keys to collect."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, writes the MetaGraphDef as an ASCII proto."}, {"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "The Graph to export. If None, use the default graph."}, {"name": "export_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope under which to extract the\nsubgraph. The scope name will be striped from the node definitions for\neasy import later into new name scopes. If None, the whole graph is\nexported. graph_def and export_scope cannot both be specified."}, {"name": "clear_devices", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether or not to clear the device field for an Operation\nor Tensor during export."}, {"name": "clear_extraneous_savers", "is_optional": true, "type": "bool", "default_value": "False", "description": "Remove any Saver-related information from the graph\n(both Save/Restore ops and SaverDefs) that are not associated with the\nprovided SaverDef."}, {"name": "strip_default_attrs", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. If True, default-valued attributes will be\nremoved from the NodeDefs. For a detailed guide, see\nStripping Default-Valued Attributes."}, {"name": "save_debug_info", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, save the GraphDebugInfo to a separate file,\nwhich in the same directory of filename and with _debug added before the\nfile extend."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Optional keyed arguments."}]}},
{"id": "tf.compat.v1.train.FtrlOptimizer", "type": "function", "code": "tf.compat.v1.train.FtrlOptimizer(learning_rate,learning_rate_power=-0.5,initial_accumulator_value=0.1,l1_regularization_strength=0.0,l2_regularization_strength=0.0,use_locking=False,name='Ftrl',accum_name=None,linear_name=None,l2_shrinkage_regularization_strength=0.0)", "summary": "Optimizer that implements the FTRL algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.FtrlOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A float value or a constant float Tensor."}, {"name": "learning_rate_power", "is_optional": true, "type": "float", "default_value": "-0.5", "description": "A float value, must be less or equal to zero.\nControls how the learning rate decreases during training. Use zero for\na fixed learning rate. See section 3.1 in the\npaper."}, {"name": "initial_accumulator_value", "is_optional": true, "type": "others", "default_value": "0.1", "description": "The starting value for accumulators.\nOnly zero or positive values are allowed."}, {"name": "l1_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "l2_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Ftrl\"."}, {"name": "accum_name", "is_optional": true, "type": "others", "default_value": "None", "description": "The suffix for the variable that keeps the gradient squared\naccumulator.  If not present, defaults to name."}, {"name": "linear_name", "is_optional": true, "type": "others", "default_value": "None", "description": "The suffix for the variable that keeps the linear gradient\naccumulator.  If not present, defaults to name + \"_1\"."}, {"name": "l2_shrinkage_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than\nor equal to zero. This differs from L2 above in that the L2 above is a\nstabilization penalty, whereas this L2 shrinkage is a magnitude penalty.\nThe FTRL formulation can be written as:\nw_{t+1} = argminw(\\hat{g}{1:t}w + L1||w||_1 + L2||w||_2^2), where\n\\hat{g} = g + (2L2_shrinkagew), and g is the gradient of the loss\nfunction w.r.t. the weights w.\nSpecifically, in the absence of L1 regularization, it is equivalent to\nthe following update rule:\nw_{t+1} = w_t - lr_t / (1 + 2L2lr_t) * g_t -\n        2L2_shrinkagelr_t / (1 + 2L2lr_t) * w_t\nwhere lr_t is the learning rate at t.\nWhen input is sparse shrinkage will only happen on the active weights."}]}},
{"id": "tf.compat.v1.train.create_global_step", "type": "function", "code": "tf.compat.v1.train.create_global_step(graph=None)", "summary": "Create global step tensor in graph.", "description": "", "code-info": {"name": "tf.compat.v1.train.create_global_step", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "The graph in which to create the global step tensor. If missing, use\ndefault graph."}]}},
{"id": "tf.compat.v1.train.ChiefSessionCreator", "type": "function", "code": "tf.compat.v1.train.ChiefSessionCreator(scaffold=None,master='',config=None,checkpoint_dir=None,checkpoint_filename_with_path=None)", "summary": "Creates a tf.compat.v1.Session for a chief.\n\nInherits From: SessionCreator", "description": "", "code-info": {"name": "tf.compat.v1.train.ChiefSessionCreator", "parameters": [{"name": "scaffold", "is_optional": true, "type": "others", "default_value": "None", "description": "A Scaffold used for gathering or building supportive ops. If\nnot specified a default one is created. It's used to finalize the graph."}, {"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": "String representation of the TensorFlow master to use."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "ConfigProto proto used to configure the session."}, {"name": "checkpoint_dir", "is_optional": true, "type": "string", "default_value": "None", "description": "A string.  Optional path to a directory where to restore\nvariables."}, {"name": "checkpoint_filename_with_path", "is_optional": true, "type": "string", "default_value": "None", "description": "Full file name path to the checkpoint file."}]}},
{"id": "tf.compat.v1.train.cosine_decay_restarts", "type": "function", "code": "tf.compat.v1.train.cosine_decay_restarts(learning_rate,global_step,first_decay_steps,t_mul=2.0,m_mul=1.0,alpha=0.0,name=None)", "summary": "Applies cosine decay with restarts to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.cosine_decay_restarts", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation."}, {"name": "first_decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number.\nNumber of steps to decay over."}, {"name": "t_mul", "is_optional": true, "type": "tensor", "default_value": "2.0", "description": "A scalar float32 or float64 Tensor or a Python number. Used to\nderive the number of iterations in the i-th period"}, {"name": "m_mul", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "A scalar float32 or float64 Tensor or a Python number.\nUsed to derive the initial learning rate of the i-th period:"}, {"name": "alpha", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar float32 or float64 Tensor or a Python number. Minimum\nlearning rate value as a fraction of the learning_rate."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String. Optional name of the operation.  Defaults to 'SGDRDecay'."}]}},
{"id": "tf.compat.v1.train.basic_train_loop", "type": "function", "code": "tf.compat.v1.train.basic_train_loop(supervisor,train_step_fn,args=None,kwargs=None,master='')", "summary": "Basic loop to train a model.", "description": "", "code-info": {"name": "tf.compat.v1.train.basic_train_loop", "parameters": [{"name": "supervisor", "is_optional": false, "type": "others", "description": "tf.compat.v1.train.Supervisor to run the training services."}, {"name": "train_step_fn", "is_optional": false, "type": "others", "description": "Callable to execute one training step.  Called repeatedly as\ntrain_step_fn(session, *args **kwargs)."}, {"name": "args", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional positional arguments passed to train_step_fn."}, {"name": "kwargs", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional keyword arguments passed to train_step_fn."}, {"name": "master", "is_optional": true, "type": "string", "default_value": "''", "description": "Master to use to create the training session.  Defaults to \"\"\nwhich causes the session to be created in the local process."}]}},
{"id": "tf.compat.v1.train.cosine_decay", "type": "function", "code": "tf.compat.v1.train.cosine_decay(learning_rate,global_step,decay_steps,alpha=0.0,name=None)", "summary": "Applies cosine decay to the learning rate.", "description": "", "code-info": {"name": "tf.compat.v1.train.cosine_decay", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A scalar float32 or float64 Tensor or a Python number.\nThe initial learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Global\nstep to use for the decay computation."}, {"name": "decay_steps", "is_optional": false, "type": "tensor", "description": "A scalar int32 or int64 Tensor or a Python number. Number\nof steps to decay over."}, {"name": "alpha", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "A scalar float32 or float64 Tensor or a Python number. Minimum\nlearning rate value as a fraction of learning_rate."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String. Optional name of the operation.  Defaults to 'CosineDecay'."}]}},
{"id": "tf.compat.v1.train.checkpoint_exists", "type": "function", "code": "tf.compat.v1.train.checkpoint_exists(checkpoint_prefix)", "summary": "Checks whether a V1 or V2 checkpoint exists with the specified prefix. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.checkpoint_exists", "parameters": [{"name": "checkpoint_prefix", "is_optional": false, "type": "others", "description": "the prefix of a V1 or V2 checkpoint, with V2 taking\npriority.  Typically the result of Saver.save() or that of\ntf.train.latest_checkpoint(), regardless of sharded/non-sharded or\nV1/V2."}]}},
{"id": "tf.compat.v1.train.Checkpoint", "type": "class", "code": "tf.compat.v1.train.Checkpoint(**kwargs)", "summary": "Groups trackable objects, saving and restoring them.", "description": "", "code-info": {"name": "tf.compat.v1.train.Checkpoint", "parameters": [{"name": "**kwargs", "is_optional": false, "type": "others", "description": "Keyword arguments are set as attributes of this object, and are\nsaved with the checkpoint. Values must be trackable objects."}]}},
{"id": "tf.compat.v1.train.batch_join", "type": "function", "code": "tf.compat.v1.train.batch_join(tensors_list,batch_size,capacity=32,enqueue_many=False,shapes=None,dynamic_pad=False,allow_smaller_final_batch=False,shared_name=None,name=None)", "summary": "Runs a list of tensors to fill a queue to create batches of examples. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.batch_join", "parameters": [{"name": "tensors_list", "is_optional": false, "type": "tensor", "description": "A list of tuples or dictionaries of tensors to enqueue."}, {"name": "batch_size", "is_optional": false, "type": "int", "description": "An integer. The new batch size pulled from the queue."}, {"name": "capacity", "is_optional": true, "type": "int", "default_value": "32", "description": "An integer. The maximum number of elements in the queue."}, {"name": "enqueue_many", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether each tensor in tensor_list_list is a single\nexample."}, {"name": "shapes", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) The shapes for each example.  Defaults to the\ninferred shapes for tensor_list_list[i]."}, {"name": "dynamic_pad", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  Allow variable dimensions in input shapes.\nThe given dimensions are padded upon dequeue so that tensors within a\nbatch have the same shapes."}, {"name": "allow_smaller_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional) Boolean. If True, allow the final\nbatch to be smaller if there are insufficient items left in the queue."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) If set, this queue will be shared under the given\nname across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operations."}]}},
{"id": "tf.compat.v1.train.assert_global_step", "type": "function", "code": "tf.compat.v1.train.assert_global_step(global_step_tensor)", "summary": "Asserts global_step_tensor is a scalar int Variable or Tensor.", "description": "", "code-info": {"name": "tf.compat.v1.train.assert_global_step", "parameters": [{"name": "global_step_tensor", "is_optional": false, "type": "tensor", "description": "Tensor to test."}]}},
{"id": "tf.compat.v1.train.add_queue_runner", "type": "function", "code": "tf.compat.v1.train.add_queue_runner(qr,collection=tf.GraphKeys.QUEUE_RUNNERS)", "summary": "Adds a QueueRunner to a collection in the graph. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.train.add_queue_runner", "parameters": [{"name": "qr", "is_optional": false, "type": "others", "description": "A QueueRunner."}, {"name": "collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.QUEUE_RUNNERS", "description": "A GraphKey specifying the graph collection to add\nthe queue runner to.  Defaults to GraphKeys.QUEUE_RUNNERS."}]}},
{"id": "tf.compat.v1.train.AdamOptimizer", "type": "function", "code": "tf.compat.v1.train.AdamOptimizer(learning_rate=0.001,beta1=0.9,beta2=0.999,epsilon=1e-08,use_locking=False,name='Adam')", "summary": "Optimizer that implements the Adam algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.AdamOptimizer", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "beta1", "is_optional": true, "type": "tensor", "default_value": "0.9", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 1st moment estimates."}, {"name": "beta2", "is_optional": true, "type": "tensor", "default_value": "0.999", "description": "A float value or a constant float tensor. The exponential decay\nrate for the 2nd moment estimates."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-08", "description": "A small constant for numerical stability. This epsilon is\n\"epsilon hat\" in the Kingma and Ba paper (in the formula just before\nSection 2.1), not the epsilon in Algorithm 1 of the paper."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adam'", "description": "Optional name for the operations created when applying gradients.\nDefaults to \"Adam\".  @compatibility(eager) When eager execution is\nenabled, learning_rate, beta1, beta2, and epsilon can each be a\ncallable that takes no arguments and returns the actual value to use.\nThis can be useful for changing these values across different\ninvocations of optimizer functions. @end_compatibility"}]}},
{"id": "tf.compat.v1.train.AdagradOptimizer", "type": "function", "code": "tf.compat.v1.train.AdagradOptimizer(learning_rate,initial_accumulator_value=0.1,use_locking=False,name='Adagrad')", "summary": "Optimizer that implements the Adagrad algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.AdagradOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "initial_accumulator_value", "is_optional": true, "type": "float", "default_value": "0.1", "description": "A floating point value.\nStarting value for the accumulators, must be positive."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Adagrad\"."}]}},
{"id": "tf.compat.v1.train.AdagradDAOptimizer", "type": "function", "code": "tf.compat.v1.train.AdagradDAOptimizer(learning_rate,global_step,initial_gradient_squared_accumulator_value=0.1,l1_regularization_strength=0.0,l2_regularization_strength=0.0,use_locking=False,name='AdagradDA')", "summary": "Adagrad Dual Averaging algorithm for sparse linear models.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.AdagradDAOptimizer", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "tensor", "description": "A Tensor or a floating point value.  The learning rate."}, {"name": "global_step", "is_optional": false, "type": "tensor", "description": "A Tensor containing the current training step number."}, {"name": "initial_gradient_squared_accumulator_value", "is_optional": true, "type": "float", "default_value": "0.1", "description": "A floating point value.\nStarting value for the accumulators, must be positive."}, {"name": "l1_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "l2_regularization_strength", "is_optional": true, "type": "float", "default_value": "0.0", "description": "A float value, must be greater than or\nequal to zero."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'AdagradDA'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"AdagradDA\"."}]}},
{"id": "tf.compat.v1.train.AdadeltaOptimizer", "type": "function", "code": "tf.compat.v1.train.AdadeltaOptimizer(learning_rate=0.001,rho=0.95,epsilon=1e-08,use_locking=False,name='Adadelta')", "summary": "Optimizer that implements the Adadelta algorithm.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.train.AdadeltaOptimizer", "parameters": [{"name": "learning_rate", "is_optional": true, "type": "tensor", "default_value": "0.001", "description": "A Tensor or a floating point value. The learning rate.\nTo match the exact form in the original paper use 1.0."}, {"name": "rho", "is_optional": true, "type": "tensor", "default_value": "0.95", "description": "A Tensor or a floating point value. The decay rate."}, {"name": "epsilon", "is_optional": true, "type": "tensor", "default_value": "1e-08", "description": "A Tensor or a floating point value.  A constant epsilon used\n     to better conditioning the grad update."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True use locks for update operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Adadelta'", "description": "Optional name prefix for the operations created when applying\ngradients.  Defaults to \"Adadelta\"."}]}},
{"id": "tf.compat.v1.tpu.experimental.embedding_column", "type": "function", "code": "tf.compat.v1.tpu.experimental.embedding_column(categorical_column,dimension,combiner='mean',initializer=None,max_sequence_length=0,learning_rate_fn=None,embedding_lookup_device=None,tensor_core_shape=None)", "summary": "TPU version of tf.compat.v1.feature_column.embedding_column.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.experimental.embedding_column", "parameters": [{"name": "categorical_column", "is_optional": false, "type": "others", "description": "A categorical column returned from\ncategorical_column_with_identity, weighted_categorical_column,\ncategorical_column_with_vocabulary_file,\ncategorical_column_with_vocabulary_list,\nsequence_categorical_column_with_identity,\nsequence_categorical_column_with_vocabulary_file,\nsequence_categorical_column_with_vocabulary_list"}, {"name": "dimension", "is_optional": false, "type": "int", "description": "An integer specifying dimension of the embedding, must be &gt; 0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to reduce if there are multiple entries\nin a single row for a non-sequence column. For more information, see\ntf.feature_column.embedding_column."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "A variable initializer function to be used in embedding\nvariable initialization. If not specified, defaults to\ntf.compat.v1.truncated_normal_initializer with mean 0.0 and\nstandard deviation 1/sqrt(dimension)."}, {"name": "max_sequence_length", "is_optional": true, "type": "int", "default_value": "0", "description": "An non-negative integer specifying the max sequence\nlength. Any sequence shorter then this will be padded with 0 embeddings\nand any sequence longer will be truncated. This must be positive for\nsequence features and 0 for non-sequence features."}, {"name": "learning_rate_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A function that takes global step and returns learning\nrate for the embedding table."}, {"name": "embedding_lookup_device", "is_optional": true, "type": "others", "default_value": "None", "description": "The device on which to run the embedding lookup.\nValid options are \"cpu\", \"tpu_tensor_core\", and \"tpu_embedding_core\".\nIf specifying \"tpu_tensor_core\", a tensor_core_shape must be supplied.\nIf not specified, the default behavior is embedding lookup on\n\"tpu_embedding_core\" for training and \"cpu\" for inference.\nValid options for training : [\"tpu_embedding_core\", \"tpu_tensor_core\"]\nValid options for serving :  [\"cpu\", \"tpu_tensor_core\"]\nFor training, tpu_embedding_core is good for large embedding vocab (&gt;1M),\notherwise, tpu_tensor_core is often sufficient.\nFor serving, doing embedding lookup on tpu_tensor_core during serving is\na way to reduce host cpu usage in cases where that is a bottleneck."}, {"name": "tensor_core_shape", "is_optional": true, "type": "int", "default_value": "None", "description": "If supplied, a list of integers which specifies\nthe intended dense shape to run embedding lookup for this feature on\nTensorCore. The batch dimension can be left None or -1 to indicate\na dynamic shape. Only rank 2 shapes currently supported."}]}},
{"id": "tf.compat.v1.tpu.experimental.AdamParameters", "type": "function", "code": "tf.compat.v1.tpu.experimental.AdamParameters(learning_rate,beta1=0.9,beta2=0.999,epsilon=1e-08,lazy_adam=True,sum_inside_sqrt=True,use_gradient_accumulation=True,clip_weight_min=None,clip_weight_max=None)", "summary": "Optimization parameters for Adam with TPU embeddings.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.experimental.AdamParameters", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "float", "description": "a floating point value. The learning rate."}, {"name": "beta1", "is_optional": true, "type": "float", "default_value": "0.9", "description": "A float value.\nThe exponential decay rate for the 1st moment estimates."}, {"name": "beta2", "is_optional": true, "type": "float", "default_value": "0.999", "description": "A float value.\nThe exponential decay rate for the 2nd moment estimates."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-08", "description": "A small constant for numerical stability."}, {"name": "lazy_adam", "is_optional": true, "type": "bool", "default_value": "True", "description": "Use lazy Adam instead of Adam. Lazy Adam trains faster.\nPlease see optimization_parameters.proto for details."}, {"name": "sum_inside_sqrt", "is_optional": true, "type": "bool", "default_value": "True", "description": "This improves training speed. Please see\noptimization_parameters.proto for details."}, {"name": "use_gradient_accumulation", "is_optional": true, "type": "bool", "default_value": "True", "description": "setting this to False makes embedding\ngradients calculation less accurate but faster. Please see\noptimization_parameters.proto for details.\nfor details."}, {"name": "clip_weight_min", "is_optional": true, "type": "others", "default_value": "None", "description": "the minimum value to clip by; None means -infinity."}, {"name": "clip_weight_max", "is_optional": true, "type": "others", "default_value": "None", "description": "the maximum value to clip by; None means +infinity."}]}},
{"id": "tf.compat.v1.tpu.experimental.StochasticGradientDescentParameters", "type": "function", "code": "tf.compat.v1.tpu.experimental.StochasticGradientDescentParameters(learning_rate,clip_weight_min=None,clip_weight_max=None)", "summary": "Optimization parameters for stochastic gradient descent for TPU embeddings.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.experimental.StochasticGradientDescentParameters", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "float", "description": "a floating point value. The learning rate."}, {"name": "clip_weight_min", "is_optional": true, "type": "others", "default_value": "None", "description": "the minimum value to clip by; None means -infinity."}, {"name": "clip_weight_max", "is_optional": true, "type": "others", "default_value": "None", "description": "the maximum value to clip by; None means +infinity."}]}},
{"id": "tf.compat.v1.tpu.experimental.AdagradParameters", "type": "function", "code": "tf.compat.v1.tpu.experimental.AdagradParameters(learning_rate,initial_accumulator=0.1,use_gradient_accumulation=True,clip_weight_min=None,clip_weight_max=None)", "summary": "Optimization parameters for Adagrad with TPU embeddings.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.experimental.AdagradParameters", "parameters": [{"name": "learning_rate", "is_optional": false, "type": "others", "description": "used for updating embedding table."}, {"name": "initial_accumulator", "is_optional": true, "type": "others", "default_value": "0.1", "description": "initial accumulator for Adagrad."}, {"name": "use_gradient_accumulation", "is_optional": true, "type": "bool", "default_value": "True", "description": "setting this to False makes embedding\ngradients calculation less accurate but faster. Please see\noptimization_parameters.proto for details.\nfor details."}, {"name": "clip_weight_min", "is_optional": true, "type": "others", "default_value": "None", "description": "the minimum value to clip by; None means -infinity."}, {"name": "clip_weight_max", "is_optional": true, "type": "others", "default_value": "None", "description": "the maximum value to clip by; None means +infinity."}]}},
{"id": "tf.compat.v1.tpu.shutdown_system", "type": "function", "code": "tf.compat.v1.tpu.shutdown_system(job=None)", "summary": "Shuts down a running a distributed TPU system.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.shutdown_system", "parameters": [{"name": "job", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The job (the XXX in TensorFlow device specification /job:XXX) that\ncontains the TPU devices that will be shutdown. If job=None it is\nassumed there is only one job in the TensorFlow flock, and an error will\nbe returned if this assumption does not hold."}]}},
{"id": "tf.compat.v1.tpu.experimental.shared_embedding_columns", "type": "function", "code": "tf.compat.v1.tpu.experimental.shared_embedding_columns(categorical_columns,dimension,combiner='mean',initializer=None,shared_embedding_collection_name=None,max_sequence_lengths=None,learning_rate_fn=None,embedding_lookup_device=None,tensor_core_shape=None)", "summary": "TPU version of tf.compat.v1.feature_column.shared_embedding_columns.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.experimental.shared_embedding_columns", "parameters": [{"name": "categorical_columns", "is_optional": false, "type": "others", "description": "A list of categorical columns returned from\ncategorical_column_with_identity, weighted_categorical_column,\ncategorical_column_with_vocabulary_file,\ncategorical_column_with_vocabulary_list,\nsequence_categorical_column_with_identity,\nsequence_categorical_column_with_vocabulary_file,\nsequence_categorical_column_with_vocabulary_list"}, {"name": "dimension", "is_optional": false, "type": "int", "description": "An integer specifying dimension of the embedding, must be &gt; 0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to reduce if there are multiple entries in\na single row for a non-sequence column. For more information, see\ntf.feature_column.embedding_column."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "A variable initializer function to be used in embedding\nvariable initialization. If not specified, defaults to\ntf.truncated_normal_initializer with mean 0.0 and standard deviation\n1/sqrt(dimension)."}, {"name": "shared_embedding_collection_name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name of the collection where\nshared embedding weights are added. If not given, a reasonable name will\nbe chosen based on the names of categorical_columns. This is also used\nin variable_scope when creating shared embedding weights."}, {"name": "max_sequence_lengths", "is_optional": true, "type": "int", "default_value": "None", "description": "An list of non-negative integers, either None or empty\nor the same length as the argument categorical_columns. Entries\ncorresponding to non-sequence columns must be 0 and entries corresponding\nto sequence columns specify the max sequence length for the column. Any\nsequence shorter then this will be padded with 0 embeddings and any\nsequence longer will be truncated."}, {"name": "learning_rate_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "A function that takes global step and returns learning\nrate for the embedding table."}, {"name": "embedding_lookup_device", "is_optional": true, "type": "others", "default_value": "None", "description": "The device on which to run the embedding lookup.\nValid options are \"cpu\", \"tpu_tensor_core\", and \"tpu_embedding_core\". If\nspecifying \"tpu_tensor_core\", a tensor_core_shape must be supplied.\nDefaults to \"cpu\". If not specified, the default behavior is embedding\nlookup on \"tpu_embedding_core\" for training and \"cpu\" for inference.\nValid options for training : [\"tpu_embedding_core\", \"tpu_tensor_core\"]\nValid options for serving :  [\"cpu\", \"tpu_tensor_core\"]\nFor training, tpu_embedding_core is good for large embedding vocab (&gt;1M),\notherwise, tpu_tensor_core is often sufficient.\nFor serving, doing embedding lookup on tpu_tensor_core during serving is\na way to reduce host cpu usage in cases where that is a bottleneck."}, {"name": "tensor_core_shape", "is_optional": true, "type": "int", "default_value": "None", "description": "If supplied, a list of integers which specifies the\nintended dense shape to run embedding lookup for this feature on\nTensorCore. The batch dimension can be left None or -1 to indicate a\ndynamic shape. Only rank 2 shapes currently supported."}]}},
{"id": "tf.compat.v1.tpu.shard", "type": "function", "code": "tf.compat.v1.tpu.shard(computation,inputs=None,num_shards=1,input_shard_axes=None,outputs_from_all_shards=True,output_shard_axes=None,infeed_queue=None,device_assignment=None,name=None)", "summary": "Shards computation for parallel execution.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.shard", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds a computation to apply to each\nshard of the input."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A list of input tensors or None (equivalent to an empty list). Each\ninput tensor has a corresponding shard axes, given by input_shard_axes,\nwhich must have size divisible by num_shards."}, {"name": "num_shards", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of shards."}, {"name": "input_shard_axes", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of dimensions along which to shard inputs, or\nNone. None means \"shard all inputs along dimension 0\". If not None,\nthere must be one dimension per input."}, {"name": "outputs_from_all_shards", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean or list of boolean. For each output, if\nTrue, outputs from all shards are concatenated along the corresponding\noutput_shard_axes entry. Otherwise, each output is taken\nfrom an arbitrary shard. If the argument is a boolean, the argument's\nvalue is used for each output."}, {"name": "output_shard_axes", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of dimensions along which to concatenate the\noutputs of computation, or None. None means \"concatenate all outputs\nalong dimension 0\". If not None, there must be one dimension per output.\nIgnored if outputs_from_all_shards is False."}, {"name": "infeed_queue", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, the InfeedQueue to use to augment the inputs\nof computation."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, a DeviceAssignment describing the\nmapping between logical cores in the computation with physical cores in\nthe TPU topology. Uses a default device assignment if None. The\nDeviceAssignment may be omitted if each shard of the computation uses\nonly one core, and there is either only one shard, or the number of shards\nis equal to the number of cores in the TPU system."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Deprecated) Does nothing."}]}},
{"id": "tf.compat.v1.tpu.replicate", "type": "function", "code": "tf.compat.v1.tpu.replicate(computation,inputs=None,infeed_queue=None,device_assignment=None,name=None,maximum_shapes=None)", "summary": "Builds a graph operator that runs a replicated TPU computation.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.replicate", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds the computation to replicate."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A list of lists of input tensors or None (equivalent to\n[[]]), indexed by [replica_num][input_num]. All replicas must\nhave the same number of inputs. Each input can be a nested structure\ncontaining values that are convertible to tensors. Note that passing an\nN-dimension list of compatible values will result in a N-dimension list of\nscalar tensors rather than a single Rank-N tensors. If you need different\nbehavior, convert part of inputs to tensors with tf.convert_to_tensor."}, {"name": "infeed_queue", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, the InfeedQueue from which to append a tuple\nof arguments as inputs to computation."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, a DeviceAssignment describing the\nmapping between logical cores in the computation with physical cores in\nthe TPU topology. Uses a default device assignment if None. The\nDeviceAssignment may be omitted if each replica of the computation uses\nonly one core, and there is either only one replica, or the number of\nreplicas is equal to the number of cores in the TPU system."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Deprecated) Does nothing."}, {"name": "maximum_shapes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A nested structure of tf.TensorShape representing the shape\nto which the respective component of each input element in each replica\nshould be padded. Any unknown dimensions (e.g.\ntf.compat.v1.Dimension(None) in a tf.TensorShape or -1 in a tensor-like\nobject) will be padded to the maximum size of that dimension over all\nreplicas. The structure of maximum_shapes needs to be the same as\ninputs[0]."}]}},
{"id": "tf.compat.v1.tpu.rewrite", "type": "function", "code": "tf.compat.v1.tpu.rewrite(computation,inputs=None,infeed_queue=None,device_assignment=None,name=None)", "summary": "Rewrites computation for execution on a TPU system.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.rewrite", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds a computation to apply to the\ninput. If the function takes n inputs, 'inputs' should be a list of n\ntensors.\n\ncomputation may return a list of operations and tensors. Tensors must\ncome before operations in the returned list.  The return value of\nrewrite is a list of tensors corresponding to the tensors from the\noutput of computation.\n\nAll Operations constructed during computation will be executed when\nevaluating any of the returned output tensors, not just the ones returned."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A list of input tensors or None (equivalent to an empty list).\nEach input can be a nested structure containing values that are\nconvertible to tensors. Note that passing an N-dimension list of\ncompatible values will result in a N-dimention list of scalar tensors\nrather than a single Rank-N tensors. If you need different behavior,\nconvert part of inputs to tensors with tf.convert_to_tensor."}, {"name": "infeed_queue", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, the InfeedQueue from which to append a tuple\nof arguments as inputs to computation."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "if not None, a DeviceAssignment describing the\nmapping between logical cores in the computation with physical cores in\nthe TPU topology. May be omitted for a single-core computation, in which\ncase the core attached to task 0, TPU device 0 is used."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Deprecated) Does nothing."}]}},
{"id": "tf.compat.v1.tpu.outside_compilation", "type": "function", "code": "tf.compat.v1.tpu.outside_compilation(computation,*args,**kwargs)", "summary": "Builds part of a computation outside any current TPU replicate scope.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.outside_compilation", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds the computation to\nplace on the host."}, {"name": "*args", "is_optional": false, "type": "others", "description": "the positional arguments for the computation."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "the keyword arguments for the computation."}]}},
{"id": "tf.compat.v1.tpu.core", "type": "function", "code": "tf.compat.v1.tpu.core(num)", "summary": "Returns the device name for a core in a replicated TPU computation.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.core", "parameters": [{"name": "num", "is_optional": false, "type": "others", "description": "the virtual core number within each replica to which operators should\nbe assigned."}]}},
{"id": "tf.compat.v1.tpu.initialize_system", "type": "function", "code": "tf.compat.v1.tpu.initialize_system(embedding_config=None,job=None,compilation_failure_closes_chips=True)", "summary": "Initializes a distributed TPU system for use with TensorFlow.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.initialize_system", "parameters": [{"name": "embedding_config", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, a TPUEmbeddingConfiguration proto\ndescribing the desired configuration of the hardware embedding lookup\ntables. If embedding_config is None, no hardware embeddings can be used."}, {"name": "job", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The job (the XXX in TensorFlow device specification /job:XXX) that\ncontains the TPU devices that will be initialized. If job=None it is\nassumed there is only one job in the TensorFlow flock, and an error will\nbe returned if this assumption does not hold."}, {"name": "compilation_failure_closes_chips", "is_optional": true, "type": "bool", "default_value": "True", "description": "Set the configuration whether\nwe want to close TPU chips when there is a compilation failure."}]}},
{"id": "tf.compat.v1.tpu.cross_replica_sum", "type": "function", "code": "tf.compat.v1.tpu.cross_replica_sum(x,group_assignment=None,name=None)", "summary": "Sum the input tensor across replicas according to group_assignment.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.cross_replica_sum", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "The local tensor to the sum."}, {"name": "group_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional 2d int32 lists with shape [num_groups,\nnum_replicas_per_group]. group_assignment[i] represents the replica\nids in the ith subgroup."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional op name."}]}},
{"id": "tf.compat.v1.tpu.CrossShardOptimizer", "type": "function", "code": "tf.compat.v1.tpu.CrossShardOptimizer(opt,reduction=losses.Reduction.MEAN,name='CrossShardOptimizer',group_assignment=None)", "summary": "An optimizer that averages gradients across TPU shards.\n\nInherits From: Optimizer", "description": "", "code-info": {"name": "tf.compat.v1.tpu.CrossShardOptimizer", "parameters": [{"name": "opt", "is_optional": false, "type": "others", "description": "An existing Optimizer to encapsulate."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.MEAN", "description": "The reduction to apply to the shard losses."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'CrossShardOptimizer'", "description": "Optional name prefix for the operations created when applying\ngradients. Defaults to \"CrossShardOptimizer\"."}, {"name": "group_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional 2d int32 lists with shape\n[num_groups, num_replicas_per_group] which describles how to apply\noptimizer to subgroups."}]}},
{"id": "tf.compat.v1.tpu.batch_parallel", "type": "function", "code": "tf.compat.v1.tpu.batch_parallel(computation,inputs=None,num_shards=1,infeed_queue=None,device_assignment=None,name=None)", "summary": "Shards computation along the batch dimension for parallel execution.", "description": "", "code-info": {"name": "tf.compat.v1.tpu.batch_parallel", "parameters": [{"name": "computation", "is_optional": false, "type": "others", "description": "A Python function that builds a computation to apply to each\nshard of the input."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A list of input tensors or None (equivalent to an empty list). The\n0-th dimension of each Tensor must have size divisible by num_shards."}, {"name": "num_shards", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of shards."}, {"name": "infeed_queue", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, the InfeedQueue from which to append a tuple\nof arguments as inputs to computation."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, a DeviceAssignment describing the\nmapping between logical cores in the computation with physical cores in\nthe TPU topology. Uses a default device assignment if None. The\nDeviceAssignment may be omitted if each shard of the computation uses\nonly one core, and there is either only one shard, or the number of shards\nis equal to the number of cores in the TPU system."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Deprecated) Does nothing."}]}},
{"id": "tf.compat.v1.test.test_src_dir_path", "type": "function", "code": "tf.compat.v1.test.test_src_dir_path(relative_path)", "summary": "Creates an absolute test srcdir path given a relative path.", "description": "", "code-info": {"name": "tf.compat.v1.test.test_src_dir_path", "parameters": [{"name": "relative_path", "is_optional": false, "type": "tensor", "description": "a path relative to tensorflow root.\ne.g. \"core/platform\"."}]}},
{"id": "tf.compat.v1.test.StubOutForTesting", "type": "function", "code": "tf.compat.v1.test.StubOutForTesting()", "summary": "Support class for stubbing methods out for unit testing.", "description": "", "code-info": {"name": "tf.compat.v1.test.StubOutForTesting", "parameters": []}},
{"id": "tf.compat.v1.test.get_temp_dir", "type": "function", "code": "tf.compat.v1.test.get_temp_dir()", "summary": "Returns a temporary directory for use during tests.", "description": "", "code-info": {"name": "tf.compat.v1.test.get_temp_dir", "parameters": []}},
{"id": "tf.compat.v1.test.compute_gradient_error", "type": "function", "code": "tf.compat.v1.test.compute_gradient_error(x,x_shape,y,y_shape,x_init_value=None,delta=0.001,init_targets=None,extra_feed_dict=None)", "summary": "Computes the gradient error. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.test.compute_gradient_error", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "a tensor or list of tensors"}, {"name": "x_shape", "is_optional": false, "type": "others", "description": "the dimensions of x as a tuple or an array of ints. If x is a list,\nthen this is the list of shapes."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "a tensor"}, {"name": "y_shape", "is_optional": false, "type": "others", "description": "the dimensions of y as a tuple or an array of ints."}, {"name": "x_init_value", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) a numpy array of the same shape as \"x\"\nrepresenting the initial value of x. If x is a list, this should be a list\nof numpy arrays.  If this is none, the function will pick a random tensor\nas the initial value."}, {"name": "delta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "(optional) the amount of perturbation."}, {"name": "init_targets", "is_optional": true, "type": "others", "default_value": "None", "description": "list of targets to run to initialize model params."}, {"name": "extra_feed_dict", "is_optional": true, "type": "tensor", "default_value": "None", "description": "dict that allows fixing specified tensor values\nduring the Jacobian calculation."}]}},
{"id": "tf.compat.v1.summary.tensor_summary", "type": "function", "code": "tf.compat.v1.summary.tensor_summary(name,tensor,summary_description=None,collections=None,summary_metadata=None,family=None,display_name=None)", "summary": "Outputs a Summary protocol buffer with a serialized tensor.proto.", "description": "", "code-info": {"name": "tf.compat.v1.summary.tensor_summary", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. If display_name is not set, it will\nalso serve as the tag name in TensorBoard. (In that case, the tag\nname will inherit tf name scopes.)"}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "A tensor of any type and shape to serialize."}, {"name": "summary_description", "is_optional": true, "type": "others", "default_value": "None", "description": "A long description of the summary sequence. Markdown\nis supported."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of graph collections keys. The new summary op is\nadded to these collections. Defaults to [GraphKeys.SUMMARIES]."}, {"name": "summary_metadata", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional SummaryMetadata proto (which describes which\nplugins may use the summary value)."}, {"name": "family", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional; if provided, used as the prefix of the summary tag,\nwhich controls the name used for display on TensorBoard when\ndisplay_name is not set."}, {"name": "display_name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A string used to name this data in TensorBoard. If this is\nnot set, then the node name will be used instead."}]}},
{"id": "tf.compat.v1.test.compute_gradient", "type": "function", "code": "tf.compat.v1.test.compute_gradient(x,x_shape,y,y_shape,x_init_value=None,delta=0.001,init_targets=None,extra_feed_dict=None)", "summary": "Computes and returns the theoretical and numerical Jacobian. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.test.compute_gradient", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "a tensor or list of tensors"}, {"name": "x_shape", "is_optional": false, "type": "others", "description": "the dimensions of x as a tuple or an array of ints. If x is a list,\nthen this is the list of shapes."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "a tensor"}, {"name": "y_shape", "is_optional": false, "type": "others", "description": "the dimensions of y as a tuple or an array of ints."}, {"name": "x_init_value", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) a numpy array of the same shape as \"x\"\nrepresenting the initial value of x. If x is a list, this should be a list\nof numpy arrays.  If this is none, the function will pick a random tensor\nas the initial value."}, {"name": "delta", "is_optional": true, "type": "others", "default_value": "0.001", "description": "(optional) the amount of perturbation."}, {"name": "init_targets", "is_optional": true, "type": "others", "default_value": "None", "description": "list of targets to run to initialize model params."}, {"name": "extra_feed_dict", "is_optional": true, "type": "tensor", "default_value": "None", "description": "dict that allows fixing specified tensor values\nduring the Jacobian calculation."}]}},
{"id": "tf.compat.v1.summary.text", "type": "function", "code": "tf.compat.v1.summary.text(name,tensor,collections=None)", "summary": "Summarizes textual data.", "description": "", "code-info": {"name": "tf.compat.v1.summary.text", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. Will also serve as a series name in\nTensorBoard."}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "a string-type Tensor to summarize."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of ops.GraphKeys.  The collections to add the\nsummary to.  Defaults to [_ops.GraphKeys.SUMMARIES]"}]}},
{"id": "tf.compat.v1.test.assert_equal_graph_def", "type": "function", "code": "tf.compat.v1.test.assert_equal_graph_def(actual,expected,checkpoint_v2=False,hash_table_shared_name=False)", "summary": "Asserts that two GraphDefs are (mostly) the same.", "description": "", "code-info": {"name": "tf.compat.v1.test.assert_equal_graph_def", "parameters": [{"name": "actual", "is_optional": false, "type": "others", "description": "The GraphDef we have."}, {"name": "expected", "is_optional": false, "type": "others", "description": "The GraphDef we expected."}, {"name": "checkpoint_v2", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean determining whether to ignore randomized attribute\nvalues that appear in V2 checkpoints."}, {"name": "hash_table_shared_name", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean determining whether to ignore randomized\nshared_names that appear in HashTableV2 op defs."}]}},
{"id": "tf.compat.v1.summary.scalar", "type": "function", "code": "tf.compat.v1.summary.scalar(name,tensor,collections=None,family=None)", "summary": "Outputs a Summary protocol buffer containing a single scalar value.", "description": "", "code-info": {"name": "tf.compat.v1.summary.scalar", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. Will also serve as the series name in\nTensorBoard."}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "A real numeric Tensor containing a single value."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of graph collections keys. The new summary op is\nadded to these collections. Defaults to [GraphKeys.SUMMARIES]."}, {"name": "family", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional; if provided, used as the prefix of the summary tag name,\nwhich controls the tab name used for display on Tensorboard."}]}},
{"id": "tf.compat.v1.summary.image", "type": "function", "code": "tf.compat.v1.summary.image(name,tensor,max_outputs=3,collections=None,family=None)", "summary": "Outputs a Summary protocol buffer with images.", "description": "", "code-info": {"name": "tf.compat.v1.summary.image", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. Will also serve as a series name in\nTensorBoard."}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "A 4-D uint8 or float32 Tensor of shape [batch_size, height,\nwidth, channels] where channels is 1, 3, or 4."}, {"name": "max_outputs", "is_optional": true, "type": "int", "default_value": "3", "description": "Max number of batch elements to generate images for."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of ops.GraphKeys.  The collections to add the\nsummary to.  Defaults to [_ops.GraphKeys.SUMMARIES]"}, {"name": "family", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional; if provided, used as the prefix of the summary tag name,\nwhich controls the tab name used for display on Tensorboard."}]}},
{"id": "tf.compat.v1.summary.merge", "type": "function", "code": "tf.compat.v1.summary.merge(inputs,collections=None,name=None)", "summary": "Merges summaries.", "description": "", "code-info": {"name": "tf.compat.v1.summary.merge", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A list of string Tensor objects containing serialized Summary\nprotocol buffers."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of graph collections keys. The new summary op is\nadded to these collections. Defaults to []."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.summary.merge_all", "type": "function", "code": "tf.compat.v1.summary.merge_all(key=tf.GraphKeys.SUMMARIES,scope=None,name=None)", "summary": "Merges all summaries collected in the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.summary.merge_all", "parameters": [{"name": "key", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.SUMMARIES", "description": "GraphKey used to collect the summaries.  Defaults to\nGraphKeys.SUMMARIES."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.summary.get_summary_description", "type": "function", "code": "tf.compat.v1.summary.get_summary_description(node_def)", "summary": "Given a TensorSummary node_def, retrieve its SummaryDescription.", "description": "", "code-info": {"name": "tf.compat.v1.summary.get_summary_description", "parameters": [{"name": "node_def", "is_optional": false, "type": "tensor", "description": "the node_def_pb2.NodeDef of a TensorSummary op"}]}},
{"id": "tf.compat.v1.summary.initialize", "type": "function", "code": "tf.compat.v1.summary.initialize(graph=None,session=None)", "summary": "Initializes summary writing for graph execution mode.", "description": "", "code-info": {"name": "tf.compat.v1.summary.initialize", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "A tf.Graph or tf.compat.v1.GraphDef to output to the writer.\nThis function will not write the default graph by default. When\nwriting to an event log file, the associated step will be zero."}, {"name": "session", "is_optional": true, "type": "others", "default_value": "None", "description": "So this method can call tf.Session.run. This defaults\nto tf.compat.v1.get_default_session."}]}},
{"id": "tf.compat.v1.summary.histogram", "type": "function", "code": "tf.compat.v1.summary.histogram(name,values,collections=None,family=None)", "summary": "Outputs a Summary protocol buffer with a histogram.", "description": "", "code-info": {"name": "tf.compat.v1.summary.histogram", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. Will also serve as a series name in\nTensorBoard."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "A real numeric Tensor. Any shape. Values to use to\nbuild the histogram."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of graph collections keys. The new summary op is\nadded to these collections. Defaults to [GraphKeys.SUMMARIES]."}, {"name": "family", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional; if provided, used as the prefix of the summary tag name,\nwhich controls the tab name used for display on Tensorboard."}]}},
{"id": "tf.compat.v1.strings.split", "type": "function", "code": "tf.compat.v1.strings.split(input=None,sep=None,maxsplit=-1,result_type='SparseTensor',source=None,name=None)", "summary": "Split elements of input based on sep.", "description": "", "code-info": {"name": "tf.compat.v1.strings.split", "parameters": [{"name": "input", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A string Tensor of rank N, the strings to split.  If\nrank(input) is not known statically, then it is assumed to be 1."}, {"name": "sep", "is_optional": true, "type": "tensor", "default_value": "None", "description": "0-D string Tensor, the delimiter character."}, {"name": "maxsplit", "is_optional": true, "type": "others", "default_value": "-1", "description": "An int. If maxsplit &gt; 0, limit of the split of the result."}, {"name": "result_type", "is_optional": true, "type": "string", "default_value": "'SparseTensor'", "description": "The tensor type for the result: one of \"RaggedTensor\" or\n\"SparseTensor\"."}, {"name": "source", "is_optional": true, "type": "others", "default_value": "None", "description": "alias for \"input\" argument."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.summary.FileWriter", "type": "function", "code": "tf.compat.v1.summary.FileWriter(logdir,graph=None,max_queue=10,flush_secs=120,graph_def=None,filename_suffix=None,session=None)", "summary": "Writes Summary protocol buffers to event files.", "description": "", "code-info": {"name": "tf.compat.v1.summary.FileWriter", "parameters": [{"name": "logdir", "is_optional": false, "type": "string", "description": "A string. Directory where event file will be written."}, {"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "A Graph object, such as sess.graph."}, {"name": "max_queue", "is_optional": true, "type": "int", "default_value": "10", "description": "Integer. Size of the queue for pending events and summaries."}, {"name": "flush_secs", "is_optional": true, "type": "int", "default_value": "120", "description": "Number. How often, in seconds, to flush the\npending events and summaries to disk."}, {"name": "graph_def", "is_optional": true, "type": "others", "default_value": "None", "description": "DEPRECATED: Use the graph argument instead."}, {"name": "filename_suffix", "is_optional": true, "type": "string", "default_value": "None", "description": "A string. Every event file's name is suffixed with\nsuffix."}, {"name": "session", "is_optional": true, "type": "others", "default_value": "None", "description": "A tf.compat.v1.Session object. See details above."}]}},
{"id": "tf.compat.v1.summary.audio", "type": "function", "code": "tf.compat.v1.summary.audio(name,tensor,sample_rate,max_outputs=3,collections=None,family=None)", "summary": "Outputs a Summary protocol buffer with audio.", "description": "", "code-info": {"name": "tf.compat.v1.summary.audio", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "A name for the generated node. Will also serve as a series name in\nTensorBoard."}, {"name": "tensor", "is_optional": false, "type": "tensor", "description": "A 3-D float32 Tensor of shape [batch_size, frames, channels]\nor a 2-D float32 Tensor of shape [batch_size, frames]."}, {"name": "sample_rate", "is_optional": false, "type": "tensor", "description": "A Scalar float32 Tensor indicating the sample rate of the\nsignal in hertz."}, {"name": "max_outputs", "is_optional": true, "type": "int", "default_value": "3", "description": "Max number of batch elements to generate audio for."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of ops.GraphKeys.  The collections to add the\nsummary to.  Defaults to [_ops.GraphKeys.SUMMARIES]"}, {"name": "family", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional; if provided, used as the prefix of the summary tag name,\nwhich controls the tab name used for display on Tensorboard."}]}},
{"id": "tf.compat.v1.summary.all_v2_summary_ops", "type": "function", "code": "tf.compat.v1.summary.all_v2_summary_ops()", "summary": "Returns all V2-style summary ops defined in the current default graph.", "description": "", "code-info": {"name": "tf.compat.v1.summary.all_v2_summary_ops", "parameters": []}},
{"id": "tf.compat.v1.strings.length", "type": "function", "code": "tf.compat.v1.strings.length(input,name=None,unit='BYTE')", "summary": "String lengths of input.", "description": "", "code-info": {"name": "tf.compat.v1.strings.length", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nThe string for which to compute the length.\nunit: An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is counted to compute string length.  One of: \"BYTE\" (for\nthe number of bytes in each string) or \"UTF8_CHAR\" (for the number of UTF-8\nencoded Unicode code points in each string).  Results are undefined\nif unit=UTF8_CHAR and the input strings do not contain structurally\nvalid UTF-8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type int32.\n\n          "}, {"name": "unit", "is_optional": true, "type": "string", "default_value": "'BYTE'", "description": "An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is counted to compute string length.  One of: \"BYTE\" (for\nthe number of bytes in each string) or \"UTF8_CHAR\" (for the number of UTF-8\nencoded Unicode code points in each string).  Results are undefined\nif unit=UTF8_CHAR and the input strings do not contain structurally\nvalid UTF-8.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.strings.substr", "type": "function", "code": "tf.compat.v1.strings.substr(input,pos,len,name=None,unit='BYTE')", "summary": "Return substrings from Tensor of strings.", "description": "", "code-info": {"name": "tf.compat.v1.strings.substr", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. Tensor of strings"}, {"name": "pos", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nScalar defining the position of first character in each substring"}, {"name": "len", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as pos.\nScalar defining the number of characters to include in each substring\nunit: An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is used to create the substring.  One of: \"BYTE\" (for\ndefining position and length by bytes) or \"UTF8_CHAR\" (for the UTF-8\nencoded Unicode code points).  The default is \"BYTE\". Results are undefined if\nunit=UTF8_CHAR and the input strings do not contain structurally valid\nUTF-8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type string.\n\n          "}, {"name": "unit", "is_optional": true, "type": "string", "default_value": "'BYTE'", "description": "An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is used to create the substring.  One of: \"BYTE\" (for\ndefining position and length by bytes) or \"UTF8_CHAR\" (for the UTF-8\nencoded Unicode code points).  The default is \"BYTE\". Results are undefined if\nunit=UTF8_CHAR and the input strings do not contain structurally valid\nUTF-8.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.saved_model.main_op.main_op", "type": "function", "code": "tf.compat.v1.saved_model.main_op.main_op()", "summary": "Returns a main op to init variables and tables. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.main_op.main_op", "parameters": []}},
{"id": "tf.compat.v1.saved_model.simple_save", "type": "function", "code": "tf.compat.v1.saved_model.simple_save(session,export_dir,inputs,outputs,legacy_init_op=None)", "summary": "Convenience function to build a SavedModel suitable for serving. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.simple_save", "parameters": [{"name": "session", "is_optional": false, "type": "tensor", "description": "The TensorFlow session from which to save the meta graph and\nvariables."}, {"name": "export_dir", "is_optional": false, "type": "others", "description": "The path to which the SavedModel will be stored."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "dict mapping string input names to tensors. These are added\nto the SignatureDef as the inputs."}, {"name": "outputs", "is_optional": false, "type": "tensor", "description": " dict mapping string output names to tensors. These are added\nto the SignatureDef as the outputs."}, {"name": "legacy_init_op", "is_optional": true, "type": "others", "default_value": "None", "description": "Legacy support for op or group of ops to execute after the\nrestore op upon a load."}]}},
{"id": "tf.compat.v1.saved_model.regression_signature_def", "type": "function", "code": "tf.compat.v1.saved_model.regression_signature_def(examples,predictions)", "summary": "Creates regression signature from given examples and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.regression_signature_def", "parameters": [{"name": "examples", "is_optional": false, "type": "tensor", "description": "A string Tensor, expected to accept serialized tf.Examples."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A float Tensor."}]}},
{"id": "tf.compat.v1.saved_model.predict_signature_def", "type": "function", "code": "tf.compat.v1.saved_model.predict_signature_def(inputs,outputs)", "summary": "Creates prediction signature from given inputs and outputs.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.predict_signature_def", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "dict of string to Tensor."}, {"name": "outputs", "is_optional": false, "type": "tensor", "description": "dict of string to Tensor."}]}},
{"id": "tf.compat.v1.saved_model.main_op_with_restore", "type": "function", "code": "tf.compat.v1.saved_model.main_op_with_restore(restore_op_name)", "summary": "Returns a main op to init variables, tables and restore the graph. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.main_op_with_restore", "parameters": [{"name": "restore_op_name", "is_optional": false, "type": "string", "description": "Name of the op to use to restore the graph."}]}},
{"id": "tf.compat.v1.saved_model.load", "type": "function", "code": "tf.compat.v1.saved_model.load(sess,tags,export_dir,import_scope=None,**saver_kwargs)", "summary": "Loads the model from a SavedModel as specified by tags. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.load", "parameters": [{"name": "sess", "is_optional": false, "type": "tensor", "description": "The TensorFlow session to restore the variables."}, {"name": "tags", "is_optional": false, "type": "string", "description": "Set of string tags to identify the required MetaGraphDef. These should\ncorrespond to the tags used when saving the variables using the\nSavedModel save() API."}, {"name": "export_dir", "is_optional": false, "type": "others", "description": "Directory in which the SavedModel protocol buffer and variables\nto be loaded are located."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string -- if specified, prepend this string\nfollowed by '/' to all loaded tensor names. This scope is applied to\ntensor instances loaded into the passed session, but it is not written\nthrough to the static MetaGraphDef protocol buffer that is returned."}, {"name": "**saver_kwargs", "is_optional": false, "type": "others", "description": "Optional keyword arguments passed through to Saver."}]}},
{"id": "tf.compat.v1.saved_model.is_valid_signature", "type": "function", "code": "tf.compat.v1.saved_model.is_valid_signature(signature_def)", "summary": "Determine whether a SignatureDef can be served by TensorFlow Serving.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.is_valid_signature", "parameters": [{"name": "signature_def", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.saved_model.get_tensor_from_tensor_info", "type": "function", "code": "tf.compat.v1.saved_model.get_tensor_from_tensor_info(tensor_info,graph=None,import_scope=None)", "summary": "Returns the Tensor or CompositeTensor described by a TensorInfo proto. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.get_tensor_from_tensor_info", "parameters": [{"name": "tensor_info", "is_optional": false, "type": "tensor", "description": "A TensorInfo proto describing a Tensor or SparseTensor or\nCompositeTensor."}, {"name": "graph", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The tf.Graph in which tensors are looked up. If None, the\ncurrent default graph is used."}, {"name": "import_scope", "is_optional": true, "type": "tensor", "default_value": "None", "description": "If not None, names in tensor_info are prefixed with this\nstring before lookup."}]}},
{"id": "tf.compat.v1.saved_model.contains_saved_model", "type": "function", "code": "tf.compat.v1.saved_model.contains_saved_model(export_dir)", "summary": "Checks whether the provided export directory could contain a SavedModel.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.contains_saved_model", "parameters": [{"name": "export_dir", "is_optional": false, "type": "string", "description": "Absolute string path to possible export location. For example,\n        '/my/foo/model'."}]}},
{"id": "tf.compat.v1.saved_model.classification_signature_def", "type": "function", "code": "tf.compat.v1.saved_model.classification_signature_def(examples,classes,scores)", "summary": "Creates classification signature from given examples and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.classification_signature_def", "parameters": [{"name": "examples", "is_optional": false, "type": "tensor", "description": "A string Tensor, expected to accept serialized tf.Examples."}, {"name": "classes", "is_optional": false, "type": "tensor", "description": "A string Tensor.  Note that the ClassificationResponse message\nrequires that class labels are strings, not integers or anything else."}, {"name": "scores", "is_optional": false, "type": "tensor", "description": "a float Tensor."}]}},
{"id": "tf.compat.v1.saved_model.build_tensor_info", "type": "function", "code": "tf.compat.v1.saved_model.build_tensor_info(tensor)", "summary": "Utility function to build TensorInfo proto from a Tensor. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.build_tensor_info", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor or SparseTensor whose name, dtype and shape are used to\nbuild the TensorInfo. For SparseTensors, the names of the three\nconstituent Tensors are used."}]}},
{"id": "tf.compat.v1.saved_model.build_signature_def", "type": "function", "code": "tf.compat.v1.saved_model.build_signature_def(inputs=None,outputs=None,method_name=None)", "summary": "Utility function to build a SignatureDef protocol buffer.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.build_signature_def", "parameters": [{"name": "inputs", "is_optional": true, "type": "others", "default_value": "None", "description": "Inputs of the SignatureDef defined as a proto map of string to\ntensor info."}, {"name": "outputs", "is_optional": true, "type": "others", "default_value": "None", "description": "Outputs of the SignatureDef defined as a proto map of string to\ntensor info."}, {"name": "method_name", "is_optional": true, "type": "string", "default_value": "None", "description": "Method name of the SignatureDef as a string."}]}},
{"id": "tf.compat.v1.saved_model.Builder", "type": "function", "code": "tf.compat.v1.saved_model.Builder(export_dir)", "summary": "Builds the SavedModel protocol buffer and saves variables and assets.", "description": "", "code-info": {"name": "tf.compat.v1.saved_model.Builder", "parameters": [{"name": "export_dir", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.resource_loader.readahead_file_path", "type": "function", "code": "tf.compat.v1.resource_loader.readahead_file_path(path,readahead='128M')", "summary": "Readahead files not implemented; simply returns given path.", "description": "", "code-info": {"name": "tf.compat.v1.resource_loader.readahead_file_path", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": ""}, {"name": "readahead", "is_optional": true, "type": "string", "default_value": "'128M'", "description": ""}]}},
{"id": "tf.compat.v1.resource_loader.load_resource", "type": "function", "code": "tf.compat.v1.resource_loader.load_resource(path)", "summary": "Load the resource at given path, where path is relative to tensorflow/.", "description": "", "code-info": {"name": "tf.compat.v1.resource_loader.load_resource", "parameters": [{"name": "path", "is_optional": false, "type": "tensor", "description": "a string resource path relative to tensorflow/."}]}},
{"id": "tf.compat.v1.random.stateless_multinomial", "type": "function", "code": "tf.compat.v1.random.stateless_multinomial(logits,num_samples,seed,output_dtype=tf.dtypes.int64,name=None)", "summary": "Draws deterministic pseudorandom samples from a multinomial distribution. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.random.stateless_multinomial", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "2-D Tensor with shape [batch_size, num_classes].  Each slice\n[i, :] represents the unnormalized log-probabilities for all classes."}, {"name": "num_samples", "is_optional": false, "type": "others", "description": "0-D.  Number of independent samples to draw for each row slice."}, {"name": "seed", "is_optional": false, "type": "tensor", "description": "A shape [2] integer Tensor of seeds to the random number generator."}, {"name": "output_dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.int64", "description": "integer type to use for the output. Defaults to int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.compat.v1.resource_loader.get_root_dir_with_all_resources", "type": "function", "code": "tf.compat.v1.resource_loader.get_root_dir_with_all_resources()", "summary": "Get a root directory containing all the data attributes in the build rule.", "description": "", "code-info": {"name": "tf.compat.v1.resource_loader.get_root_dir_with_all_resources", "parameters": []}},
{"id": "tf.compat.v1.resource_loader.get_path_to_datafile", "type": "function", "code": "tf.compat.v1.resource_loader.get_path_to_datafile(path)", "summary": "Get the path to the specified file in the data dependencies.", "description": "", "code-info": {"name": "tf.compat.v1.resource_loader.get_path_to_datafile", "parameters": [{"name": "path", "is_optional": false, "type": "tensor", "description": "a string resource path relative to tensorflow/"}]}},
{"id": "tf.compat.v1.resource_loader.get_data_files_path", "type": "function", "code": "tf.compat.v1.resource_loader.get_data_files_path()", "summary": "Get a direct path to the data files colocated with the script.", "description": "", "code-info": {"name": "tf.compat.v1.resource_loader.get_data_files_path", "parameters": []}},
{"id": "tf.compat.v1.ragged.constant_value", "type": "function", "code": "tf.compat.v1.ragged.constant_value(pylist,dtype=None,ragged_rank=None,inner_shape=None,row_splits_dtype='int64')", "summary": "Constructs a RaggedTensorValue from a nested Python list.", "description": "", "code-info": {"name": "tf.compat.v1.ragged.constant_value", "parameters": [{"name": "pylist", "is_optional": false, "type": "others", "description": "A nested list, tuple or np.ndarray.  Any nested element that\nis not a list or tuple must be a scalar value compatible with dtype."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "numpy.dtype.  The type of elements for the returned RaggedTensor.\nIf not specified, then a default is chosen based on the scalar values in\npylist."}, {"name": "ragged_rank", "is_optional": true, "type": "int", "default_value": "None", "description": "An integer specifying the ragged rank of the returned\nRaggedTensorValue.  Must be nonnegative and less than K. Defaults to\nmax(0, K - 1) if inner_shape is not specified.  Defaults to `max(0, K\n\n1 - len(inner_shape))ifinner_shape` is specified.\n"}, {"name": "inner_shape", "is_optional": true, "type": "int", "default_value": "None", "description": "A tuple of integers specifying the shape for individual inner\nvalues in the returned RaggedTensorValue.  Defaults to () if\nragged_rank is not specified.  If ragged_rank is specified, then a\ndefault is chosen based on the contents of pylist."}, {"name": "row_splits_dtype", "is_optional": true, "type": "string", "default_value": "'int64'", "description": "data type for the constructed RaggedTensorValue's\nrow_splits.  One of numpy.int32 or numpy.int64."}]}},
{"id": "tf.compat.v1.ragged.RaggedTensorValue", "type": "class", "code": "tf.compat.v1.ragged.RaggedTensorValue(values,row_splits)", "summary": "Represents the value of a RaggedTensor.", "description": "", "code-info": {"name": "tf.compat.v1.ragged.RaggedTensorValue", "parameters": [{"name": "values", "is_optional": false, "type": "others", "description": "A numpy array of any type and shape; or a RaggedTensorValue."}, {"name": "row_splits", "is_optional": false, "type": "others", "description": "A 1-D int32 or int64 numpy array."}]}},
{"id": "tf.compat.v1.ragged.placeholder", "type": "function", "code": "tf.compat.v1.ragged.placeholder(dtype,ragged_rank,value_shape=None,name=None)", "summary": "Creates a placeholder for a tf.RaggedTensor that will always be fed.", "description": "", "code-info": {"name": "tf.compat.v1.ragged.placeholder", "parameters": [{"name": "dtype", "is_optional": false, "type": "tensor", "description": "The data type for the RaggedTensor."}, {"name": "ragged_rank", "is_optional": false, "type": "tensor", "description": "The ragged rank for the RaggedTensor"}, {"name": "value_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "The shape for individual flat values in the RaggedTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.profiler.write_op_log", "type": "function", "code": "tf.compat.v1.profiler.write_op_log(graph,log_dir,op_log=None,run_meta=None,add_trace=True)", "summary": "Log provided 'op_log', and add additional model information below.", "description": "", "code-info": {"name": "tf.compat.v1.profiler.write_op_log", "parameters": [{"name": "graph", "is_optional": false, "type": "others", "description": "tf.Graph. If None and eager execution is not enabled, use\ndefault graph."}, {"name": "log_dir", "is_optional": false, "type": "others", "description": "directory to write the log file."}, {"name": "op_log", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) OpLogProto proto to be written. If not provided, an new\none is created."}, {"name": "run_meta", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) RunMetadata proto that helps flops computation using\nrun time shape information."}, {"name": "add_trace", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to add python code trace information.\nUsed to support \"code\" view."}]}},
{"id": "tf.compat.v1.profiler.profile", "type": "function", "code": "tf.compat.v1.profiler.profile(graph=None,run_meta=None,op_log=None,cmd='scope',options=_DEFAULT_PROFILE_OPTIONS)", "summary": "Profile model.", "description": "", "code-info": {"name": "tf.compat.v1.profiler.profile", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "tf.Graph. If None and eager execution is not enabled, use\ndefault graph."}, {"name": "run_meta", "is_optional": true, "type": "tensor", "default_value": "None", "description": "optional tensorflow.RunMetadata proto. It is necessary to\nto support run time information profiling, such as time and memory."}, {"name": "op_log", "is_optional": true, "type": "tensor", "default_value": "None", "description": "tensorflow.tfprof.OpLogProto proto. User can assign \"types\" to\ngraph nodes with op_log. \"types\" allow user to flexibly group and\naccount profiles using options['accounted_type_regexes']."}, {"name": "cmd", "is_optional": true, "type": "string", "default_value": "'scope'", "description": "string. Either 'op', 'scope', 'graph' or 'code'.\n'op' view organizes profile using operation type. (e.g. MatMul)\n'scope' view organizes profile using graph node name scope.\n'graph' view organizes profile using graph node inputs/outputs.\n'code' view organizes profile using Python call stack."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "_DEFAULT_PROFILE_OPTIONS", "description": "A dict of options. See core/profiler/g3doc/options.md."}]}},
{"id": "tf.compat.v1.profiler.Profiler", "type": "function", "code": "tf.compat.v1.profiler.Profiler(graph=None,op_log=None)", "summary": "TensorFlow multi-step profiler.", "description": "", "code-info": {"name": "tf.compat.v1.profiler.Profiler", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "tf.Graph. If None and eager execution is not enabled, use\ndefault graph."}, {"name": "op_log", "is_optional": true, "type": "tensor", "default_value": "None", "description": "optional. tensorflow::tfprof::OpLogProto proto. Used to define\nextra op types."}]}},
{"id": "tf.compat.v1.profiler.ProfileOptionBuilder", "type": "function", "code": "tf.compat.v1.profiler.ProfileOptionBuilder(options=None)", "summary": "Option Builder for Profiling API.", "description": "", "code-info": {"name": "tf.compat.v1.profiler.ProfileOptionBuilder", "parameters": [{"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional initial option dict to start with."}]}},
{"id": "tf.compat.v1.profiler.advise", "type": "function", "code": "tf.compat.v1.profiler.advise(graph=None,run_meta=None,options=_DEFAULT_ADVISE_OPTIONS)", "summary": "Auto profile and advise.", "description": "", "code-info": {"name": "tf.compat.v1.profiler.advise", "parameters": [{"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "tf.Graph. If None and eager execution is not enabled, use\ndefault graph."}, {"name": "run_meta", "is_optional": true, "type": "tensor", "default_value": "None", "description": "optional tensorflow.RunMetadata proto. It is necessary to\nto support run time information profiling, such as time and memory."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "_DEFAULT_ADVISE_OPTIONS", "description": "see ALL_ADVICE example above. Default checks everything."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.GRUCell", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.GRUCell(num_units,activation=None,reuse=None,kernel_initializer=None,bias_initializer=None,name=None,dtype=None,**kwargs)", "summary": "Gated Recurrent Unit cell (cf.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.GRUCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the GRU cell."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Nonlinearity to use.  Default: tanh."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in an\nexisting scope.  If not True, and the existing scope already has the\ngiven variables, an error is raised."}, {"name": "kernel_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The initializer to use for the weight and\nprojection matrices."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The initializer to use for the bias."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Dict, keyword named properties for common layer attributes, like\ntrainable etc when constructing the cell from configs of get_config()."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.ResidualWrapper", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.ResidualWrapper(*args,**kwargs)", "summary": "RNNCell wrapper that ensures cell inputs are added to the outputs.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.ResidualWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.LSTMCell", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.LSTMCell(num_units,use_peepholes=False,cell_clip=None,initializer=None,num_proj=None,proj_clip=None,num_unit_shards=None,num_proj_shards=None,forget_bias=1.0,state_is_tuple=True,activation=None,reuse=None,name=None,dtype=None,**kwargs)", "summary": "Long short-term memory unit (LSTM) recurrent network cell.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.LSTMCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the LSTM cell."}, {"name": "use_peepholes", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, set True to enable diagonal/peephole connections."}, {"name": "cell_clip", "is_optional": true, "type": "float", "default_value": "None", "description": "(optional) A float value, if provided the cell state is clipped\nby this value prior to the cell output activation."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The initializer to use for the weight and\nprojection matrices."}, {"name": "num_proj", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) int, The output dimensionality for the projection\nmatrices.  If None, no projection is performed."}, {"name": "proj_clip", "is_optional": true, "type": "float", "default_value": "None", "description": "(optional) A float value.  If num_proj &gt; 0 and proj_clip is\nprovided, then the projected values are clipped elementwise to within\n[-proj_clip, proj_clip]."}, {"name": "num_unit_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated, will be removed by Jan. 2017. Use a\nvariable_scope partitioner instead."}, {"name": "num_proj_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated, will be removed by Jan. 2017. Use a\nvariable_scope partitioner instead."}, {"name": "forget_bias", "is_optional": true, "type": "others", "default_value": "1.0", "description": "Biases of the forget gate are initialized by default to 1 in\norder to reduce the scale of forgetting at the beginning of the\ntraining. Must set it manually to 0.0 when restoring from CudnnLSTM\ntrained checkpoints."}, {"name": "state_is_tuple", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, accepted and returned states are 2-tuples of the\nc_state and m_state.  If False, they are concatenated along the\ncolumn axis.  This latter behavior will soon be deprecated."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function of the inner states.  Default: tanh. It\ncould also be string that is within Keras activation function names."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in\nan existing scope.  If not True, and the existing scope already has\nthe given variables, an error is raised."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Dict, keyword named properties for common layer attributes, like\ntrainable etc when constructing the cell from configs of get_config().\nWhen restoring from CudnnLSTM-trained checkpoints, use\nCudnnCompatibleLSTMCell instead."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.MultiRNNCell", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.MultiRNNCell(cells,state_is_tuple=True)", "summary": "RNN cell composed sequentially of multiple simple cells.\n\nInherits From: RNNCell", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.MultiRNNCell", "parameters": [{"name": "cells", "is_optional": false, "type": "others", "description": "list of RNNCells that will be composed in this order."}, {"name": "state_is_tuple", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, accepted and returned states are n-tuples, where\nn = len(cells).  If False, the states are all concatenated along the\ncolumn axis.  This latter behavior will soon be deprecated."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.RNNCell", "type": "function", "code": "tf.compat.v1.nn.rnn_cell.RNNCell(trainable=True,name=None,dtype=None,**kwargs)", "summary": "Abstract object representing an RNN cell.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.RNNCell", "parameters": [{"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.nn.xw_plus_b", "type": "function", "code": "tf.compat.v1.nn.xw_plus_b(x,weights,biases,name=None)", "summary": "Computes matmul(x, weights) + biases.", "description": "", "code-info": {"name": "tf.compat.v1.nn.xw_plus_b", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "a 2D tensor.  Dimensions typically: batch, in_units"}, {"name": "weights", "is_optional": false, "type": "tensor", "description": "a 2D tensor.  Dimensions typically: in_units, out_units"}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "a 1D tensor.  Dimensions: out_units"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).  If not specified\n\"xw_plus_b\" is used."}]}},
{"id": "tf.compat.v1.nn.weighted_moments", "type": "function", "code": "tf.compat.v1.nn.weighted_moments(x,axes,frequency_weights,name=None,keep_dims=None,keepdims=None)", "summary": "Returns the frequency-weighted mean and variance of x.", "description": "", "code-info": {"name": "tf.compat.v1.nn.weighted_moments", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A tensor."}, {"name": "axes", "is_optional": false, "type": "tensor", "description": "1-d tensor of int32 values; these are the axes along which\nto compute mean and variance."}, {"name": "frequency_weights", "is_optional": false, "type": "tensor", "description": "A tensor of positive weights which can be\nbroadcast with x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operation."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Produce moments with the same dimensionality as the input."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of keep_dims."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.DropoutWrapper", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.DropoutWrapper(*args,**kwargs)", "summary": "Operator adding dropout to inputs and outputs of the given cell.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.DropoutWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.DeviceWrapper", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.DeviceWrapper(*args,**kwargs)", "summary": "Operator that ensures an RNNCell runs on a particular device.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.DeviceWrapper", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "dict of keyword arguments for base layer."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.BasicRNNCell", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.BasicRNNCell(num_units,activation=None,reuse=None,name=None,dtype=None,**kwargs)", "summary": "The most basic RNN cell.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.BasicRNNCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the RNN cell."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Nonlinearity to use.  Default: tanh. It could also be string\nthat is within Keras activation function names."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in an\nexisting scope.  If not True, and the existing scope already has the\ngiven variables, an error is raised."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Dict, keyword named properties for common layer attributes, like\ntrainable etc when constructing the cell from configs of get_config()."}]}},
{"id": "tf.compat.v1.nn.rnn_cell.BasicLSTMCell", "type": "class", "code": "tf.compat.v1.nn.rnn_cell.BasicLSTMCell(num_units,forget_bias=1.0,state_is_tuple=True,activation=None,reuse=None,name=None,dtype=None,**kwargs)", "summary": "DEPRECATED: Please use tf.compat.v1.nn.rnn_cell.LSTMCell instead.", "description": "", "code-info": {"name": "tf.compat.v1.nn.rnn_cell.BasicLSTMCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the LSTM cell."}, {"name": "forget_bias", "is_optional": true, "type": "float", "default_value": "1.0", "description": "float, The bias added to forget gates (see above). Must set\nto 0.0 manually when restoring from CudnnLSTM-trained checkpoints."}, {"name": "state_is_tuple", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, accepted and returned states are 2-tuples of the\nc_state and m_state.  If False, they are concatenated along the\ncolumn axis.  The latter behavior will soon be deprecated."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function of the inner states.  Default: tanh. It\ncould also be string that is within Keras activation function names."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in\nan existing scope.  If not True, and the existing scope already has\nthe given variables, an error is raised."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Dict, keyword named properties for common layer attributes, like\ntrainable etc when constructing the cell from configs of get_config().\nWhen restoring from CudnnLSTM-trained checkpoints, must use\nCudnnCompatibleLSTMCell instead."}]}},
{"id": "tf.compat.v1.nn.sufficient_statistics", "type": "function", "code": "tf.compat.v1.nn.sufficient_statistics(x,axes,shift=None,keep_dims=None,name=None,keepdims=None)", "summary": "Calculate the sufficient statistics for the mean and variance of x.", "description": "", "code-info": {"name": "tf.compat.v1.nn.sufficient_statistics", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axes", "is_optional": false, "type": "others", "description": "Array of ints. Axes along which to compute mean and variance."}, {"name": "shift", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor containing the value by which to shift the data for\nnumerical stability, or None if no shift is to be performed. A shift\nclose to the true mean provides the most numerically stable results."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "produce statistics with the same dimensionality as the input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operations that compute the sufficient stats."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for keep_dims."}]}},
{"id": "tf.compat.v1.nn.static_rnn", "type": "function", "code": "tf.compat.v1.nn.static_rnn(cell,inputs,initial_state=None,dtype=None,sequence_length=None,scope=None)", "summary": "Creates a recurrent neural network specified by RNNCell cell. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.static_rnn", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "An instance of RNNCell."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A length T list of inputs, each a Tensor of shape [batch_size,\ninput_size], or a nested tuple of such elements."}, {"name": "initial_state", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An initial state for the RNN. If cell.state_size\nis an integer, this must be a Tensor of appropriate type and shape\n[batch_size, cell.state_size]. If cell.state_size is a tuple, this\nshould be a tuple of tensors having shapes [batch_size, s] for s in\ncell.state_size."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The data type for the initial state and expected output.\nRequired if initial_state is not provided or RNN state has a heterogeneous\ndtype."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "Specifies the length of each sequence in inputs. An int32\nor int64 vector (tensor) size [batch_size], values in [0, T)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to \"rnn\"."}]}},
{"id": "tf.compat.v1.nn.softmax_cross_entropy_with_logits_v2", "type": "function", "code": "tf.compat.v1.nn.softmax_cross_entropy_with_logits_v2(labels,logits,axis=None,name=None,dim=None)", "summary": "Computes softmax cross entropy between logits and labels. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.nn.softmax_cross_entropy_with_logits_v2", "parameters": [{"name": "labels", "is_optional": false, "type": "others", "description": "Each vector along the class dimension should hold a valid\nprobability distribution e.g. for the case in which labels are of shape\n[batch_size, num_classes], each row of labels[i] must be a valid\nprobability distribution."}, {"name": "logits", "is_optional": false, "type": "others", "description": "Unscaled log probabilities."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The class dimension. Defaulted to -1 which is the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "dim", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for axis."}]}},
{"id": "tf.compat.v1.nn.sparse_softmax_cross_entropy_with_logits", "type": "function", "code": "tf.compat.v1.nn.sparse_softmax_cross_entropy_with_logits(_sentinel=None,labels=None,logits=None,name=None)", "summary": "Computes sparse softmax cross entropy between logits and labels.", "description": "", "code-info": {"name": "tf.compat.v1.nn.sparse_softmax_cross_entropy_with_logits", "parameters": [{"name": "_sentinel", "is_optional": true, "type": "others", "default_value": "None", "description": "Used to prevent positional parameters. Internal, do not use."}, {"name": "labels", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor of shape [d_0, d_1, ..., d_{r-1}] (where r is rank of\nlabels and result) and dtype int32 or int64. Each entry in labels\nmust be an index in [0, num_classes). Other values will raise an\nexception when this op is run on CPU, and return NaN for corresponding\nloss and gradient rows on GPU."}, {"name": "logits", "is_optional": true, "type": "others", "default_value": "None", "description": "Per-label activations (typically a linear output) of shape\n[d_0, d_1, ..., d_{r-1}, num_classes] and dtype float16, float32, or\nfloat64. These activation energies are interpreted as unnormalized log\nprobabilities."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.static_state_saving_rnn", "type": "function", "code": "tf.compat.v1.nn.static_state_saving_rnn(cell,inputs,state_saver,state_name,sequence_length=None,scope=None)", "summary": "RNN that accepts a state saver for time-truncated RNN calculation. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.static_state_saving_rnn", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "An instance of RNNCell."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A length T list of inputs, each a Tensor of shape [batch_size,\ninput_size]."}, {"name": "state_saver", "is_optional": false, "type": "others", "description": "A state saver object with methods state and save_state."}, {"name": "state_name", "is_optional": false, "type": "string", "description": "Python string or tuple of strings.  The name to use with the\nstate_saver. If the cell returns tuples of states (i.e., cell.state_size\nis a tuple) then state_name should be a tuple of strings having the same\nlength as cell.state_size.  Otherwise it should be a single string."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An int32/int64 vector size [batch_size]. See the\ndocumentation for rnn() for more details about sequence_length."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to \"rnn\"."}]}},
{"id": "tf.compat.v1.nn.static_bidirectional_rnn", "type": "function", "code": "tf.compat.v1.nn.static_bidirectional_rnn(cell_fw,cell_bw,inputs,initial_state_fw=None,initial_state_bw=None,dtype=None,sequence_length=None,scope=None)", "summary": "Creates a bidirectional recurrent neural network. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.static_bidirectional_rnn", "parameters": [{"name": "cell_fw", "is_optional": false, "type": "others", "description": "An instance of RNNCell, to be used for forward direction."}, {"name": "cell_bw", "is_optional": false, "type": "others", "description": "An instance of RNNCell, to be used for backward direction."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A length T list of inputs, each a tensor of shape [batch_size,\ninput_size], or a nested tuple of such elements."}, {"name": "initial_state_fw", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An initial state for the forward RNN. This must\nbe a tensor of appropriate type and shape [batch_size,\ncell_fw.state_size]. If cell_fw.state_size is a tuple, this should be a\ntuple of tensors having shapes [batch_size, s] for s in\ncell_fw.state_size."}, {"name": "initial_state_bw", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Same as for initial_state_fw, but using the\ncorresponding properties of cell_bw."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The data type for the initial state.  Required if either\nof the initial states are not provided."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An int32/int64 vector, size [batch_size],\ncontaining the actual lengths for each of the sequences."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to\n\"bidirectional_rnn\""}]}},
{"id": "tf.compat.v1.nn.weighted_cross_entropy_with_logits", "type": "function", "code": "tf.compat.v1.nn.weighted_cross_entropy_with_logits(labels=None,logits=None,pos_weight=None,name=None,targets=None)", "summary": "Computes a weighted cross entropy. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.nn.weighted_cross_entropy_with_logits", "parameters": [{"name": "labels", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of the same type and shape as logits."}, {"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type float32 or float64."}, {"name": "pos_weight", "is_optional": true, "type": "others", "default_value": "None", "description": "A coefficient to use on the positive examples."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "targets", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for labels."}]}},
{"id": "tf.compat.v1.nn.softmax_cross_entropy_with_logits", "type": "function", "code": "tf.compat.v1.nn.softmax_cross_entropy_with_logits(_sentinel=None,labels=None,logits=None,dim=-1,name=None,axis=None)", "summary": "Computes softmax cross entropy between logits and labels. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.softmax_cross_entropy_with_logits", "parameters": [{"name": "_sentinel", "is_optional": true, "type": "others", "default_value": "None", "description": "Used to prevent positional parameters. Internal, do not use."}, {"name": "labels", "is_optional": true, "type": "others", "default_value": "None", "description": "Each vector along the class dimension should hold a valid\nprobability distribution e.g. for the case in which labels are of shape\n[batch_size, num_classes], each row of labels[i] must be a valid\nprobability distribution."}, {"name": "logits", "is_optional": true, "type": "others", "default_value": "None", "description": "Per-label activations, typically a linear output. These activation\nenergies are interpreted as unnormalized log probabilities."}, {"name": "dim", "is_optional": true, "type": "others", "default_value": "-1", "description": "The class dimension. Defaulted to -1 which is the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for dim."}]}},
{"id": "tf.compat.v1.nn.sigmoid_cross_entropy_with_logits", "type": "function", "code": "tf.compat.v1.nn.sigmoid_cross_entropy_with_logits(_sentinel=None,labels=None,logits=None,name=None)", "summary": "Computes sigmoid cross entropy given logits.", "description": "", "code-info": {"name": "tf.compat.v1.nn.sigmoid_cross_entropy_with_logits", "parameters": [{"name": "_sentinel", "is_optional": true, "type": "others", "default_value": "None", "description": "Used to prevent positional parameters. Internal, do not use."}, {"name": "labels", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of the same type and shape as logits."}, {"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type float32 or float64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.separable_conv2d", "type": "function", "code": "tf.compat.v1.nn.separable_conv2d(input,depthwise_filter,pointwise_filter,strides,padding,rate=None,name=None,data_format=None,dilations=None)", "summary": "2-D convolution with separable filters.", "description": "", "code-info": {"name": "tf.compat.v1.nn.separable_conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape according to data_format."}, {"name": "depthwise_filter", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape\n[filter_height, filter_width, in_channels, channel_multiplier].\nContains in_channels convolutional filters of depth 1."}, {"name": "pointwise_filter", "is_optional": false, "type": "tensor", "description": "4-D Tensor with shape\n[1, 1, channel_multiplier * in_channels, out_channels].  Pointwise\nfilter to mix channels after depthwise_filter has convolved spatially."}, {"name": "strides", "is_optional": false, "type": "string", "description": "1-D of size 4.  The strides for the depthwise convolution for\neach dimension of input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'.  The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "rate", "is_optional": true, "type": "others", "default_value": "None", "description": "1-D of size 2. The dilation rate in which we sample input values\nacross the height and width dimensions in atrous convolution. If it is\ngreater than 1, then all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "The data format for input. Either \"NHWC\" (default) or \"NCHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of rate."}]}},
{"id": "tf.compat.v1.nn.relu_layer", "type": "function", "code": "tf.compat.v1.nn.relu_layer(x,weights,biases,name=None)", "summary": "Computes Relu(x * weight + biases).", "description": "", "code-info": {"name": "tf.compat.v1.nn.relu_layer", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "a 2D tensor.  Dimensions typically: batch, in_units"}, {"name": "weights", "is_optional": false, "type": "tensor", "description": "a 2D tensor.  Dimensions typically: in_units, out_units"}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "a 1D tensor.  Dimensions: out_units"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).  If not specified\n\"nn_relu_layer\" is used."}]}},
{"id": "tf.compat.v1.nn.sampled_softmax_loss", "type": "function", "code": "tf.compat.v1.nn.sampled_softmax_loss(weights,biases,labels,inputs,num_sampled,num_classes,num_true=1,sampled_values=None,remove_accidental_hits=True,partition_strategy='mod',name='sampled_softmax_loss',seed=None)", "summary": "Computes and returns the sampled softmax training loss.", "description": "", "code-info": {"name": "tf.compat.v1.nn.sampled_softmax_loss", "parameters": [{"name": "weights", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes, dim], or a list of Tensor\nobjects whose concatenation along dimension 0 has shape\n[num_classes, dim].  The (possibly-sharded) class embeddings."}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes].  The class biases."}, {"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes.  Note that this format differs from\nthe labels argument of nn.softmax_cross_entropy_with_logits."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [batch_size, dim].  The forward\nactivations of the input network."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of classes to randomly sample per batch."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "num_true", "is_optional": true, "type": "int", "default_value": "1", "description": "An int.  The number of target classes per training example."}, {"name": "sampled_values", "is_optional": true, "type": "others", "default_value": "None", "description": "a tuple of (sampled_candidates, true_expected_count,\nsampled_expected_count) returned by a *_candidate_sampler function.\n(if None, we default to log_uniform_candidate_sampler)"}, {"name": "remove_accidental_hits", "is_optional": true, "type": "bool", "default_value": "True", "description": " A bool.  whether to remove \"accidental hits\"\nwhere a sampled class equals one of the target classes.  Default is\nTrue."}, {"name": "partition_strategy", "is_optional": true, "type": "string", "default_value": "'mod'", "description": "A string specifying the partitioning strategy, relevant\nif len(weights) &gt; 1. Currently \"div\" and \"mod\" are supported.\nDefault is \"mod\". See tf.nn.embedding_lookup for more details."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sampled_softmax_loss'", "description": "A name for the operation (optional)."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "random seed for candidate sampling. Default to None, which doesn't set\nthe op-level random seed for candidate sampling."}]}},
{"id": "tf.compat.v1.nn.quantized_relu_x", "type": "function", "code": "tf.compat.v1.nn.quantized_relu_x(features,max_value,min_features,max_features,out_type=tf.dtypes.quint8,name=None)", "summary": "Computes Quantized Rectified Linear X: min(max(features, 0), max_value)", "description": "", "code-info": {"name": "tf.compat.v1.nn.quantized_relu_x", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16."}, {"name": "max_value", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32."}, {"name": "min_features", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the lowest quantized value represents."}, {"name": "max_features", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the highest quantized value represents."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.quint8", "description": "An optional tf.DType from: tf.qint8, tf.quint8, tf.qint32, tf.qint16, tf.quint16. Defaults to tf.quint8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.safe_embedding_lookup_sparse", "type": "function", "code": "tf.compat.v1.nn.safe_embedding_lookup_sparse(embedding_weights,sparse_ids,sparse_weights=None,combiner='mean',default_id=None,name=None,partition_strategy='div',max_norm=None)", "summary": "Lookup embedding results, accounting for invalid IDs and empty features.", "description": "", "code-info": {"name": "tf.compat.v1.nn.safe_embedding_lookup_sparse", "parameters": [{"name": "embedding_weights", "is_optional": false, "type": "tensor", "description": " A list of P float Tensors or values representing\npartitioned embedding Tensors.  Alternatively, a PartitionedVariable\ncreated by partitioning along dimension 0.  The total unpartitioned shape\nshould be [e_0, e_1, ..., e_m], where e_0 represents the vocab size\nand e_1, ..., e_m are the embedding dimensions."}, {"name": "sparse_ids", "is_optional": false, "type": "tensor", "description": "SparseTensor of shape [d_0, d_1, ..., d_n] containing the\nids. d_0 is typically batch size."}, {"name": "sparse_weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "SparseTensor of same shape as sparse_ids, containing\nfloat weights corresponding to sparse_ids, or None if all weights are\nbe assumed to be 1.0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to combine embedding results for each\nentry. Currently \"mean\", \"sqrtn\" and \"sum\" are supported, with \"mean\" the\ndefault."}, {"name": "default_id", "is_optional": true, "type": "others", "default_value": "None", "description": "The id to use for an entry with no features."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "partition_strategy", "is_optional": true, "type": "string", "default_value": "'div'", "description": "A string specifying the partitioning strategy. Currently\n\"div\" and \"mod\" are supported. Default is \"div\"."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, all embeddings are l2-normalized to max_norm before\ncombining."}]}},
{"id": "tf.compat.v1.nn.quantized_max_pool", "type": "function", "code": "tf.compat.v1.nn.quantized_max_pool(input,min_input,max_input,ksize,strides,padding,name=None)", "summary": "Produces the max pool of the input tensor for quantized types.", "description": "", "code-info": {"name": "tf.compat.v1.nn.quantized_max_pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16.\nThe 4D (batch x rows x cols x depth) Tensor to MaxReduce over."}, {"name": "min_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the lowest quantized input value represents."}, {"name": "max_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the highest quantized input value represents."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "A list of ints.\nThe size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\ntensor. The length must be 4 to match the number of dimensions of the input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.quantized_conv2d", "type": "function", "code": "tf.compat.v1.nn.quantized_conv2d(input,filter,min_input,max_input,min_filter,max_filter,strides,padding,out_type=tf.dtypes.qint32,dilations=[1,1,1,1],name=None)", "summary": "Computes a 2D convolution given quantized 4D input and filter tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.quantized_conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16."}, {"name": "filter", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16.\nfilter's input_depth dimension must match input's depth dimensions."}, {"name": "min_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the lowest quantized input value represents."}, {"name": "max_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the highest quantized input value represents."}, {"name": "min_filter", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the lowest quantized filter value represents."}, {"name": "max_filter", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the highest quantized filter value represents."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\ntensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.qint32", "description": "An optional tf.DType from: tf.qint8, tf.quint8, tf.qint32, tf.qint16, tf.quint16. Defaults to tf.qint32."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.pool", "type": "function", "code": "tf.compat.v1.nn.pool(input,window_shape,pooling_type,padding,dilation_rate=None,strides=None,name=None,data_format=None,dilations=None)", "summary": "Performs an N-D pooling operation.", "description": "", "code-info": {"name": "tf.compat.v1.nn.pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "Tensor of rank N+2, of shape\n[batch_size] + input_spatial_shape + [num_channels] if data_format does\nnot start with \"NC\" (default), or\n[batch_size, num_channels] + input_spatial_shape if data_format starts\nwith \"NC\".  Pooling happens over the spatial dimensions only."}, {"name": "window_shape", "is_optional": false, "type": "others", "description": "Sequence of N ints &gt;= 1."}, {"name": "pooling_type", "is_optional": false, "type": "others", "description": "Specifies pooling operation, must be \"AVG\" or \"MAX\"."}, {"name": "padding", "is_optional": false, "type": "others", "description": "The padding algorithm, must be \"SAME\" or \"VALID\".\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "dilation_rate", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Dilation rate.  List of N ints &gt;= 1.\nDefaults to [1]*N.  If any value of dilation_rate is &gt; 1, then all values\nof strides must be 1."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Sequence of N ints &gt;= 1.  Defaults to [1]*N.\nIf any value of strides is &gt; 1, then all values of dilation_rate must be\n1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional. Name of the op."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for dilation_rate"}]}},
{"id": "tf.compat.v1.nn.quantized_avg_pool", "type": "function", "code": "tf.compat.v1.nn.quantized_avg_pool(input,min_input,max_input,ksize,strides,padding,name=None)", "summary": "Produces the average pool of the input tensor for quantized types.", "description": "", "code-info": {"name": "tf.compat.v1.nn.quantized_avg_pool", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: qint8, quint8, qint32, qint16, quint16.\n4-D with shape [batch, height, width, channels]."}, {"name": "min_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the lowest quantized input value represents."}, {"name": "max_input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nThe float value that the highest quantized input value represents."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "A list of ints.\nThe size of the window for each dimension of the input tensor.\nThe length must be 4 to match the number of dimensions of the input."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\ntensor.  The length must be 4 to match the number of dimensions of the input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.raw_rnn", "type": "function", "code": "tf.compat.v1.nn.raw_rnn(cell,loop_fn,parallel_iterations=None,swap_memory=False,scope=None)", "summary": "Creates an RNN specified by RNNCell cell and loop function loop_fn.", "description": "", "code-info": {"name": "tf.compat.v1.nn.raw_rnn", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "An instance of RNNCell."}, {"name": "loop_fn", "is_optional": false, "type": "others", "description": "A callable that takes inputs (time, cell_output, cell_state,\nloop_state) and returns the tuple (finished, next_input,\nnext_cell_state, emit_output, next_loop_state). Here time is an int32\nscalar Tensor, cell_output is a Tensor or (possibly nested) tuple of\ntensors as determined by cell.output_size, and cell_state is a\nTensor or (possibly nested) tuple of tensors, as determined by the\nloop_fn on its first call (and should match cell.state_size).\nThe outputs are: finished, a boolean Tensor of\nshape [batch_size], next_input: the next input to feed to cell,\nnext_cell_state: the next state to feed to cell,\nand emit_output: the output to store for this iteration.  Note that\nemit_output should be a Tensor or (possibly nested) tuple of tensors\nwhich is aggregated in the emit_ta inside the while_loop. For the\nfirst call to loop_fn, the emit_output corresponds to the\nemit_structure which is then used to determine the size of the\nzero_tensor for the emit_ta (defaults to cell.output_size). For\nthe subsequent calls to the loop_fn, the emit_output corresponds to\nthe actual output tensor that is to be aggregated in the emit_ta. The\nparameter cell_state and output next_cell_state may be either a\nsingle or (possibly nested) tuple of tensors.  The parameter\nloop_state and output next_loop_state may be either a single or\n(possibly nested) tuple of Tensor and TensorArray objects.  This\nlast parameter may be ignored by loop_fn and the return value may be\nNone.  If it is not None, then the loop_state will be propagated\nthrough the RNN loop, for use purely by loop_fn to keep track of its\nown state. The next_loop_state parameter returned may be None.  The\nfirst call to loop_fn will be time = 0, cell_output = None,\ncell_state = None, and loop_state = None.  For this call: The\nnext_cell_state value should be the value with which to initialize the\ncell's state.  It may be a final state from a previous RNN or it may be\nthe output of cell.zero_state().  It should be a (possibly nested)\ntuple structure of tensors. If cell.state_size is an integer, this\nmust be a Tensor of appropriate type and shape [batch_size,\ncell.state_size]. If cell.state_size is a TensorShape, this must be\na Tensor of appropriate type and shape [batch_size] +\ncell.state_size. If cell.state_size is a (possibly nested) tuple of\nints or TensorShape, this will be a tuple having the corresponding\nshapes. The emit_output value may be either None or a (possibly\nnested) tuple structure of tensors, e.g., (tf.zeros(shape_0,\ndtype=dtype_0), tf.zeros(shape_1, dtype=dtype_1)). If this first\nemit_output return value is None, then the emit_ta result of\nraw_rnn will have the same structure and dtypes as cell.output_size.\nOtherwise emit_ta will have the same structure, shapes (prepended with\na batch_size dimension), and dtypes as emit_output.  The actual\nvalues returned for emit_output at this initializing call are ignored.\nNote, this emit structure must be consistent across all time steps."}, {"name": "parallel_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "(Default: 32).  The number of iterations to run in\nparallel.  Those operations which do not have any temporal dependency and\ncan be run in parallel, will be.  This parameter trades off time for\nspace.  Values &gt;&gt; 1 use more memory but take less time, while smaller\nvalues use less memory but computations take longer."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Transparently swap the tensors produced in forward inference\nbut needed for back prop from GPU to CPU.  This allows training RNNs which\nwould typically not fit on a single GPU, with very minimal (or no)\nperformance penalty."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to \"rnn\"."}]}},
{"id": "tf.compat.v1.nn.nce_loss", "type": "function", "code": "tf.compat.v1.nn.nce_loss(weights,biases,labels,inputs,num_sampled,num_classes,num_true=1,sampled_values=None,remove_accidental_hits=False,partition_strategy='mod',name='nce_loss')", "summary": "Computes and returns the noise-contrastive estimation training loss.", "description": "", "code-info": {"name": "tf.compat.v1.nn.nce_loss", "parameters": [{"name": "weights", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes, dim], or a list of Tensor\nobjects whose concatenation along dimension 0 has shape\n[num_classes, dim].  The (possibly-partitioned) class embeddings."}, {"name": "biases", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [num_classes].  The class biases."}, {"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of type int64 and shape [batch_size,\nnum_true]. The target classes."}, {"name": "inputs", "is_optional": false, "type": "tensor", "description": "A Tensor of shape [batch_size, dim].  The forward\nactivations of the input network."}, {"name": "num_sampled", "is_optional": false, "type": "others", "description": "An int.  The number of negative classes to randomly sample\nper batch. This single sample of negative classes is evaluated for each\nelement in the batch."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "An int. The number of possible classes."}, {"name": "num_true", "is_optional": true, "type": "int", "default_value": "1", "description": "An int.  The number of target classes per training example."}, {"name": "sampled_values", "is_optional": true, "type": "others", "default_value": "None", "description": "a tuple of (sampled_candidates, true_expected_count,\nsampled_expected_count) returned by a *_candidate_sampler function.\n(if None, we default to log_uniform_candidate_sampler)"}, {"name": "remove_accidental_hits", "is_optional": true, "type": "bool", "default_value": "False", "description": " A bool.  Whether to remove \"accidental hits\"\nwhere a sampled class equals one of the target classes.  If set to\nTrue, this is a \"Sampled Logistic\" loss instead of NCE, and we are\nlearning to generate log-odds instead of log probabilities.  See\nour Candidate Sampling Algorithms Reference.\nDefault is False."}, {"name": "partition_strategy", "is_optional": true, "type": "string", "default_value": "'mod'", "description": "A string specifying the partitioning strategy, relevant\nif len(weights) &gt; 1. Currently \"div\" and \"mod\" are supported.\nDefault is \"mod\". See tf.nn.embedding_lookup for more details."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'nce_loss'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.moments", "type": "function", "code": "tf.compat.v1.nn.moments(x,axes,shift=None,name=None,keep_dims=None,keepdims=None)", "summary": "Calculate the mean and variance of x.", "description": "", "code-info": {"name": "tf.compat.v1.nn.moments", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axes", "is_optional": false, "type": "others", "description": "Array of ints.  Axes along which to compute mean and\nvariance."}, {"name": "shift", "is_optional": true, "type": "others", "default_value": "None", "description": "Not used in the current implementation"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name used to scope the operations that compute the moments."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "produce moments with the same dimensionality as the input."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias to keep_dims."}]}},
{"id": "tf.compat.v1.nn.max_pool_with_argmax", "type": "function", "code": "tf.compat.v1.nn.max_pool_with_argmax(input,ksize,strides,padding,data_format='NHWC',Targmax=None,name=None,output_dtype=None,include_batch_in_index=False)", "summary": "Performs max pooling on the input and outputs both max values and indices.", "description": "", "code-info": {"name": "tf.compat.v1.nn.max_pool_with_argmax", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64.\n4-D with shape [batch, height, width, channels].  Input to pool over."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\nThe size of the window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints that has length &gt;= 4.\nThe stride of the sliding window for each dimension of the\ninput tensor."}, {"name": "padding", "is_optional": false, "type": "others", "description": ""}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": ""}, {"name": "Targmax", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64.\ninclude_batch_in_index: An optional bool. Defaults to False.\nWhether to include batch dimension in flattened index of argmax."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "output_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "include_batch_in_index", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nWhether to include batch dimension in flattened index of argmax.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.embedding_lookup_sparse", "type": "function", "code": "tf.compat.v1.nn.embedding_lookup_sparse(params,sp_ids,sp_weights,partition_strategy='mod',name=None,combiner=None,max_norm=None)", "summary": "Computes embeddings for the given ids and weights.", "description": "", "code-info": {"name": "tf.compat.v1.nn.embedding_lookup_sparse", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A single tensor representing the complete embedding tensor, or a\nlist of P tensors all of same shape except for the first dimension,\nrepresenting sharded embedding tensors.  Alternatively, a\nPartitionedVariable, created by partitioning along dimension 0. Each\nelement must be appropriately sized for the given partition_strategy."}, {"name": "sp_ids", "is_optional": false, "type": "tensor", "description": "N x M SparseTensor of int64 ids where N is typically batch size\nand M is arbitrary."}, {"name": "sp_weights", "is_optional": false, "type": "tensor", "description": "either a SparseTensor of float / double weights, or None to\nindicate all weights should be taken to be 1. If specified, sp_weights\nmust have exactly the same shape and indices as sp_ids."}, {"name": "partition_strategy", "is_optional": true, "type": "string", "default_value": "'mod'", "description": "A string specifying the partitioning strategy, relevant\nif len(params) &gt; 1. Currently \"div\" and \"mod\" are supported. Default\nis \"mod\". See tf.nn.embedding_lookup for more details."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the op."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "None", "description": "A string specifying the reduction op. Currently \"mean\", \"sqrtn\"\nand \"sum\" are supported. \"sum\" computes the weighted sum of the embedding\nresults for each row. \"mean\" is the weighted sum divided by the total\nweight. \"sqrtn\" is the weighted sum divided by the square root of the sum\nof the squares of the weights."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is larger\nthan this value, before combining."}]}},
{"id": "tf.compat.v1.nn.max_pool", "type": "function", "code": "tf.compat.v1.nn.max_pool(value,ksize,strides,padding,data_format='NHWC',name=None,input=None)", "summary": "Performs the max pooling on the input.", "description": "", "code-info": {"name": "tf.compat.v1.nn.max_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of the format specified by data_format."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.\nThe size of the window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4.\nThe stride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC', 'NCHW' and 'NCHW_VECT_C' are supported."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for value."}]}},
{"id": "tf.compat.v1.nn.fused_batch_norm", "type": "function", "code": "tf.compat.v1.nn.fused_batch_norm(x,scale,offset,mean=None,variance=None,epsilon=0.001,data_format='NHWC',is_training=True,name=None)", "summary": "Batch normalization.", "description": "", "code-info": {"name": "tf.compat.v1.nn.fused_batch_norm", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Input Tensor of 4 dimensions."}, {"name": "scale", "is_optional": false, "type": "tensor", "description": "A Tensor of 1 dimension for scaling."}, {"name": "offset", "is_optional": false, "type": "tensor", "description": "A Tensor of 1 dimension for bias."}, {"name": "mean", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of 1 dimension for population mean used for inference."}, {"name": "variance", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of 1 dimension for population variance\n      used for inference."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "A small float number added to the variance of x."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "The data format for x. Either \"NHWC\" (default) or \"NCHW\"."}, {"name": "is_training", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool value to specify if the operation is used for\n         training or inference."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.compat.v1.nn.fractional_max_pool", "type": "function", "code": "tf.compat.v1.nn.fractional_max_pool(value,pooling_ratio,pseudo_random=False,overlapping=False,deterministic=False,seed=0,seed2=0,name=None)", "summary": "Performs fractional max pooling on the input. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.fractional_max_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, height, width, channels]."}, {"name": "pooling_ratio", "is_optional": false, "type": "float", "description": "A list of floats that has length &gt;= 4.  Pooling ratio for\neach dimension of value, currently only supports row and col dimension\nand should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0,\n1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't\nallow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling\nratio on height and width dimensions respectively."}, {"name": "pseudo_random", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False. When set to True,\ngenerates the pooling sequence in a pseudorandom fashion, otherwise, in a\nrandom fashion. Check paper Benjamin Graham, Fractional\nMax-Pooling for difference between\npseudorandom and random."}, {"name": "overlapping", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False.  When set to True,\nit means when pooling, the values at the boundary of adjacent pooling\ncells are used by both cells. For example:\nindex  0  1  2  3  4\nvalue  20 5  16 3  7\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used\ntwice.  The result would be [20, 16] for fractional max pooling."}, {"name": "deterministic", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Deprecated; use fractional_max_pool_v2\ninstead."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Defaults to 0.  If set to be non-zero, the\nrandom number generator is seeded by the given seed.  Otherwise it is\nseeded by a random seed."}, {"name": "seed2", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Deprecated; use fractional_max_pool_v2 instead."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.fractional_avg_pool", "type": "function", "code": "tf.compat.v1.nn.fractional_avg_pool(value,pooling_ratio,pseudo_random=False,overlapping=False,deterministic=False,seed=0,seed2=0,name=None)", "summary": "Performs fractional average pooling on the input. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.fractional_avg_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, height, width, channels]."}, {"name": "pooling_ratio", "is_optional": false, "type": "float", "description": "A list of floats that has length &gt;= 4.  Pooling ratio for\neach dimension of value, currently only supports row and col dimension\nand should be &gt;= 1.0. For example, a valid pooling ratio looks like [1.0,\n1.44, 1.73, 1.0]. The first and last elements must be 1.0 because we don't\nallow pooling on batch and channels dimensions.  1.44 and 1.73 are pooling\nratio on height and width dimensions respectively."}, {"name": "pseudo_random", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False. When set to True,\ngenerates the pooling sequence in a pseudorandom fashion, otherwise, in a\nrandom fashion. Check paper Benjamin Graham, Fractional\nMax-Pooling for difference between\npseudorandom and random."}, {"name": "overlapping", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Defaults to False.  When set to True,\nit means when pooling, the values at the boundary of adjacent pooling\ncells are used by both cells. For example:\nindex  0  1  2  3  4\nvalue  20 5  16 3  7\nIf the pooling sequence is [0, 2, 4], then 16, at index 2 will be used\ntwice.  The result would be [20, 16] for fractional avg pooling."}, {"name": "deterministic", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool.  Deprecated; use fractional_avg_pool_v2\ninstead."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Defaults to 0.  If set to be non-zero, the\nrandom number generator is seeded by the given seed.  Otherwise it is\nseeded by a random seed."}, {"name": "seed2", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional int.  Deprecated; use fractional_avg_pool_v2 instead."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.erosion2d", "type": "function", "code": "tf.compat.v1.nn.erosion2d(value,kernel,strides,rates,padding,name=None)", "summary": "Computes the grayscale erosion of 4-D value and 3-D kernel tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.erosion2d", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, in_height, in_width, depth]."}, {"name": "kernel", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as value.\n3-D with shape [kernel_height, kernel_width, depth]."}, {"name": "strides", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\n1-D of length 4. The stride of the sliding window for each dimension of\nthe input tensor. Must be: [1, stride_height, stride_width, 1]."}, {"name": "rates", "is_optional": false, "type": "others", "description": "A list of ints that has length &gt;= 4.\n1-D of length 4. The input stride for atrous morphological dilation.\nMust be: [1, rate_height, rate_width, 1]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional). If not specified \"erosion2d\"\nis used."}]}},
{"id": "tf.compat.v1.nn.dynamic_rnn", "type": "function", "code": "tf.compat.v1.nn.dynamic_rnn(cell,inputs,sequence_length=None,initial_state=None,dtype=None,parallel_iterations=None,swap_memory=False,time_major=False,scope=None)", "summary": "Creates a recurrent neural network specified by RNNCell cell. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.dynamic_rnn", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "An instance of RNNCell."}, {"name": "inputs", "is_optional": false, "type": "others", "description": "The RNN inputs.\nIf time_major == False (default), this must be a Tensor of shape:\n[batch_size, max_time, ...], or a nested tuple of such elements.\nIf time_major == True, this must be a Tensor of shape: [max_time,\nbatch_size, ...], or a nested tuple of such elements. This may also be\na (possibly nested) tuple of Tensors satisfying this property.  The\nfirst two dimensions must match across all the inputs, but otherwise the\nranks and other shape components may differ. In this case, input to\ncell at each time-step will replicate the structure of these tuples,\nexcept for the time dimension (from which the time is taken). The input\nto cell at each time step will be a Tensor or (possibly nested)\ntuple of Tensors each with dimensions [batch_size, ...]."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An int32/int64 vector sized [batch_size]. Used\nto copy-through state and zero-out outputs when past a batch element's\nsequence length.  This parameter enables users to extract the last valid\nstate and properly padded outputs, so it is provided for correctness."}, {"name": "initial_state", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An initial state for the RNN. If cell.state_size\nis an integer, this must be a Tensor of appropriate type and shape\n[batch_size, cell.state_size]. If cell.state_size is a tuple, this\nshould be a tuple of tensors having shapes [batch_size, s] for s in\ncell.state_size."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The data type for the initial state and expected output.\nRequired if initial_state is not provided or RNN state has a heterogeneous\ndtype."}, {"name": "parallel_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "(Default: 32).  The number of iterations to run in\nparallel.  Those operations which do not have any temporal dependency and\ncan be run in parallel, will be.  This parameter trades off time for\nspace.  Values &gt;&gt; 1 use more memory but take less time, while smaller\nvalues use less memory but computations take longer."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Transparently swap the tensors produced in forward inference\nbut needed for back prop from GPU to CPU.  This allows training RNNs which\nwould typically not fit on a single GPU, with very minimal (or no)\nperformance penalty."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": "The shape format of the inputs and outputs Tensors. If true,\nthese Tensors must be shaped [max_time, batch_size, depth]. If false,\nthese Tensors must be shaped [batch_size, max_time, depth]. Using\ntime_major = True is a bit more efficient because it avoids transposes\nat the beginning and end of the RNN calculation.  However, most TensorFlow\ndata is batch-major, so by default this function accepts input and emits\noutput in batch-major form."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to \"rnn\"."}]}},
{"id": "tf.compat.v1.nn.embedding_lookup", "type": "function", "code": "tf.compat.v1.nn.embedding_lookup(params,ids,partition_strategy='mod',name=None,validate_indices=True,max_norm=None)", "summary": "Looks up ids in a list of embedding tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.embedding_lookup", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A single tensor representing the complete embedding tensor, or a\nlist of P tensors all of same shape except for the first dimension,\nrepresenting sharded embedding tensors.  Alternatively, a\nPartitionedVariable, created by partitioning along dimension 0. Each\nelement must be appropriately sized for the given partition_strategy."}, {"name": "ids", "is_optional": false, "type": "tensor", "description": "A Tensor or a 'RaggedTensor' with type int32 or int64 containing\nthe ids to be looked up in params."}, {"name": "partition_strategy", "is_optional": true, "type": "string", "default_value": "'mod'", "description": "A string specifying the partitioning strategy, relevant\nif len(params) &gt; 1. Currently \"div\" and \"mod\" are supported. Default\nis \"mod\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "DEPRECATED. If this operation is assigned to CPU, values\nin indices are always validated to be within range.  If assigned to GPU,\nout-of-bound indices result in safe but unspecified behavior, which may\ninclude raising an error."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is larger\nthan this value."}]}},
{"id": "tf.compat.v1.nn.ctc_loss", "type": "function", "code": "tf.compat.v1.nn.ctc_loss(labels,inputs=None,sequence_length=None,preprocess_collapse_repeated=False,ctc_merge_repeated=True,ignore_longer_outputs_than_inputs=False,time_major=True,logits=None)", "summary": "Computes the CTC (Connectionist Temporal Classification) Loss.", "description": "", "code-info": {"name": "tf.compat.v1.nn.ctc_loss", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "An int32 SparseTensor.\nlabels.indices[i, :] == [b, t] means labels.values[i] stores the id\nfor (batch b, time t). labels.values[i] must take on values in [0,\nnum_labels). See core/ops/ctc_ops.cc for more details."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "3-D float Tensor.\nIf time_major == False, this will be a Tensor shaped: [batch_size,\nmax_time, num_classes].\nIf time_major == True (default), this will be a Tensor shaped:\n[max_time, batch_size, num_classes]. The logits."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "1-D int32 vector, size [batch_size]. The sequence\nlengths."}, {"name": "preprocess_collapse_repeated", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean.  Default: False. If True, repeated\nlabels are collapsed prior to the CTC calculation."}, {"name": "ctc_merge_repeated", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean.  Default: True."}, {"name": "ignore_longer_outputs_than_inputs", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Default: False. If True,\nsequences with longer outputs than inputs will be ignored."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "True", "description": "The shape format of the inputs Tensors. If True, these\nTensors must be shaped [max_time, batch_size, num_classes]. If False,\nthese Tensors must be shaped [batch_size, max_time, num_classes].\nUsing time_major = True (default) is a bit more efficient because it\navoids transposes at the beginning of the ctc_loss calculation.  However,\nmost TensorFlow data is batch-major, so by this function also accepts\ninputs in batch-major form."}, {"name": "logits", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for inputs."}]}},
{"id": "tf.compat.v1.nn.dropout", "type": "function", "code": "tf.compat.v1.nn.dropout(x,keep_prob=None,noise_shape=None,seed=None,name=None,rate=None)", "summary": "Computes dropout. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.nn.dropout", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A floating point tensor."}, {"name": "keep_prob", "is_optional": true, "type": "others", "default_value": "None", "description": "(deprecated) A deprecated alias for (1-rate)."}, {"name": "noise_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D Tensor of type int32, representing the\nshape for randomly generated keep/drop flags."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.random.set_seed for behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "rate", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A scalar Tensor with the same type as x. The probability that each\nelement of x is discarded."}]}},
{"id": "tf.compat.v1.nn.depthwise_conv2d_native", "type": "function", "code": "tf.compat.v1.nn.depthwise_conv2d_native(input,filter,strides,padding,data_format='NHWC',dilations=[1,1,1,1],name=None)", "summary": "Computes a 2-D depthwise convolution given 4-D input and filter tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.depthwise_conv2d_native", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64."}, {"name": "filter", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\n1-D of length 4.  The stride of the sliding window for each dimension\nof input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\". Defaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, channels, height, width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.depthwise_conv2d", "type": "function", "code": "tf.compat.v1.nn.depthwise_conv2d(input,filter,strides,padding,rate=None,name=None,data_format=None,dilations=None)", "summary": "Depthwise 2-D convolution.", "description": "", "code-info": {"name": "tf.compat.v1.nn.depthwise_conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "others", "description": "4-D with shape according to data_format."}, {"name": "filter", "is_optional": false, "type": "others", "description": "4-D with shape\n[filter_height, filter_width, in_channels, channel_multiplier]."}, {"name": "strides", "is_optional": false, "type": "string", "description": "1-D of size 4.  The stride of the sliding window for each\ndimension of input."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "rate", "is_optional": true, "type": "others", "default_value": "None", "description": "1-D of size 2. The dilation rate in which we sample input values\nacross the height and width dimensions in atrous convolution. If it is\ngreater than 1, then all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": "The data format for input. Either \"NHWC\" (default) or \"NCHW\"."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of rate."}]}},
{"id": "tf.compat.v1.nn.ctc_beam_search_decoder", "type": "function", "code": "tf.compat.v1.nn.ctc_beam_search_decoder(inputs,sequence_length,beam_width=100,top_paths=1,merge_repeated=True)", "summary": "Performs beam search decoding on the logits given in input.", "description": "", "code-info": {"name": "tf.compat.v1.nn.ctc_beam_search_decoder", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "3-D float Tensor, size [max_time x batch_size x num_classes].\nThe logits."}, {"name": "sequence_length", "is_optional": false, "type": "others", "description": "1-D int32 vector containing sequence lengths, having size\n[batch_size]."}, {"name": "beam_width", "is_optional": true, "type": "int", "default_value": "100", "description": "An int scalar &gt;= 0 (beam search beam width)."}, {"name": "top_paths", "is_optional": true, "type": "int", "default_value": "1", "description": "An int scalar &gt;= 0, &lt;= beam_width (controls output size)."}, {"name": "merge_repeated", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean.  Default: True."}]}},
{"id": "tf.compat.v1.nn.convolution", "type": "function", "code": "tf.compat.v1.nn.convolution(input,filter,padding,strides=None,dilation_rate=None,name=None,data_format=None,filters=None,dilations=None)", "summary": "Computes sums of N-D convolutions (actually cross-correlation).", "description": "", "code-info": {"name": "tf.compat.v1.nn.convolution", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An (N+2)-D Tensor of type T, of shape\n[batch_size] + input_spatial_shape + [in_channels] if data_format does\nnot start with \"NC\" (default), or\n[batch_size, in_channels] + input_spatial_shape if data_format starts\nwith \"NC\"."}, {"name": "filter", "is_optional": false, "type": "tensor", "description": "An (N+2)-D Tensor with the same type as input and shape\nspatial_filter_shape + [in_channels, out_channels]."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either \"VALID\" or \"SAME\". The padding algorithm."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Sequence of N ints &gt;= 1.  Specifies the output stride.\nDefaults to [1]*N.  If any value of strides is &gt; 1, then all values of\ndilation_rate must be 1."}, {"name": "dilation_rate", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional.  Sequence of N ints &gt;= 1.  Specifies the filter\nupsampling/input downsampling rate.  In the literature, the same parameter\nis sometimes called input stride or dilation.  The effective filter\nsize used for the convolution will be spatial_filter_shape +\n(spatial_filter_shape - 1) * (rate - 1), obtained by inserting\n(dilation_rate[i]-1) zeros between consecutive elements of the original\nfilter in each spatial dimension i.  If any value of dilation_rate is &gt; 1,\nthen all values of strides must be 1."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or None.  Specifies whether the channel dimension of\nthe input and output is the last dimension (default, or if data_format\ndoes not start with \"NC\"), or the second dimension (if data_format\nstarts with \"NC\").  For N=1, the valid values are \"NWC\" (default) and\n\"NCW\".  For N=2, the valid values are \"NHWC\" (default) and \"NCHW\".\nFor N=3, the valid values are \"NDHWC\" (default) and \"NCDHW\"."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of filter."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of dilation_rate."}]}},
{"id": "tf.compat.v1.nn.crelu", "type": "function", "code": "tf.compat.v1.nn.crelu(features,name=None,axis=-1)", "summary": "Computes Concatenated ReLU.", "description": "", "code-info": {"name": "tf.compat.v1.nn.crelu", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A Tensor with type float, double, int32, int64, uint8,\nint16, or int8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The axis that the output values are concatenated along. Default is -1."}]}},
{"id": "tf.compat.v1.nn.conv3d_backprop_filter", "type": "function", "code": "tf.compat.v1.nn.conv3d_backprop_filter(input,filter_sizes,out_backprop,strides,padding,data_format='NDHWC',dilations=[1,1,1,1,1],name=None)", "summary": "Computes the gradients of 3-D convolution with respect to the filter.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv3d_backprop_filter", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\nShape [batch, depth, rows, cols, in_channels]."}, {"name": "filter_sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAn integer vector representing the tensor shape of filter,\nwhere filter is a 5-D\n[filter_depth, filter_height, filter_width, in_channels, out_channels]\ntensor."}, {"name": "out_backprop", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\nBackprop signal of shape [batch, out_depth, out_rows, out_cols,\nout_channels]."}, {"name": "strides", "is_optional": false, "type": "tensor", "description": "A list of ints that has length &gt;= 5.\n1-D tensor of length 5. The stride of the sliding window for each\ndimension of input. Must have strides[0] = strides[4] = 1."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to \"NDHWC\".\nThe data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n  [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n  [batch, in_channels, in_depth, in_height, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.dilation2d", "type": "function", "code": "tf.compat.v1.nn.dilation2d(input,filter=None,strides=None,rates=None,padding=None,name=None,filters=None,dilations=None)", "summary": "Computes the grayscale dilation of 4-D input and 3-D filter tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.dilation2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64.\n4-D with shape [batch, in_height, in_width, depth]."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must have the same type as input.\n3-D with shape [filter_height, filter_width, depth]."}, {"name": "strides", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of ints that has length &gt;= 4.\nThe stride of the sliding window for each dimension of the input\ntensor. Must be: [1, stride_height, stride_width, 1]."}, {"name": "rates", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of ints that has length &gt;= 4.\nThe input stride for atrous morphological dilation. Must be:\n[1, rate_height, rate_width, 1]."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "None", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.nn.conv3d_transpose", "type": "function", "code": "tf.compat.v1.nn.conv3d_transpose(value,filter=None,output_shape=None,strides=None,padding='SAME',data_format='NDHWC',name=None,input=None,filters=None,dilations=None)", "summary": "The transpose of conv3d.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv3d_transpose", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A 5-D Tensor of type float and shape\n[batch, depth, height, width, in_channels]."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 5-D Tensor with the same type as value and shape\n[depth, height, width, output_channels, in_channels].  filter's\nin_channels dimension must match that of value."}, {"name": "output_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D Tensor representing the output shape of the\ndeconvolution op."}, {"name": "strides", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of ints. The stride of the sliding window for each\ndimension of the input tensor."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "A string, either 'NDHWC' or 'NCDHW' specifying the layout\nof the input and output tensors. Defaults to 'NDHWC'."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of value."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias of filter."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 3 or 5,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the D, H and W dimension.\nBy default the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details. Dilations in the batch and depth dimensions if a 5-d tensor\nmust be 1."}]}},
{"id": "tf.compat.v1.nn.conv2d_backprop_filter", "type": "function", "code": "tf.compat.v1.nn.conv2d_backprop_filter(input,filter_sizes,out_backprop,strides,padding,use_cudnn_on_gpu=True,data_format='NHWC',dilations=[1,1,1,1],name=None)", "summary": "Computes the gradients of convolution with respect to the filter.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv2d_backprop_filter", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types:\nhalf, bfloat16, float32, float64.\n4-D with shape [batch, in_height, in_width, in_channels]."}, {"name": "filter_sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAn integer vector representing the tensor shape of filter,\nwhere filter is a 4-D\n[filter_height, filter_width, in_channels, out_channels] tensor."}, {"name": "out_backprop", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as input.\n4-D with shape [batch, out_height, out_width, out_channels].\nGradients w.r.t. the output of the convolution."}, {"name": "strides", "is_optional": false, "type": "string", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified\nwith format."}, {"name": "padding", "is_optional": false, "type": "string", "description": "Either the string\"SAME\"or\"VALID\"indicating the type of\npadding algorithm to use, or a list indicating the explicit paddings at\nthe start and end of each dimension. When explicit padding is used and\ndata_format is\"NHWC\", this should be in the form[[0, 0], [pad_top,\npad_bottom], [pad_left, pad_right], [0, 0]]. When explicit padding used\nand data_format is\"NCHW\", this should be in the form[[0, 0], [0, 0],\n[pad_top, pad_bottom], [pad_left, pad_right]]`."}, {"name": "use_cudnn_on_gpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\".\nDefaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, in_channels, in_height, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.nn.conv3d", "type": "function", "code": "tf.compat.v1.nn.conv3d(input,filter=None,strides=None,padding=None,data_format='NDHWC',dilations=[1,1,1,1,1],name=None,filters=None)", "summary": "Computes a 3-D convolution given 5-D input and filter tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv3d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: half, bfloat16, float32, float64.\nShape [batch, in_depth, in_height, in_width, in_channels]."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must have the same type as input.\nShape [filter_depth, filter_height, filter_width, in_channels,\nout_channels]. in_channels must match between input and filter."}, {"name": "strides", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A list of ints that has length &gt;= 5.\n1-D tensor of length 5. The stride of the sliding window for each\ndimension of input. Must have strides[0] = strides[4] = 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "None", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NDHWC'", "description": "An optional string from: \"NDHWC\", \"NCDHW\". Defaults to \"NDHWC\".\nThe data format of the input and output data. With the\ndefault format \"NDHWC\", the data is stored in the order of:\n  [batch, in_depth, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCDHW\", the data storage order is:\n  [batch, in_channels, in_depth, in_height, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.nn.conv2d_transpose", "type": "function", "code": "tf.compat.v1.nn.conv2d_transpose(value=None,filter=None,output_shape=None,strides=None,padding='SAME',data_format='NHWC',name=None,input=None,filters=None,dilations=None)", "summary": "The transpose of conv2d.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv2d_transpose", "parameters": [{"name": "value", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 4-D Tensor of type float and shape\n[batch, height, width, in_channels] for NHWC data format or\n[batch, in_channels, height, width] for NCHW data format."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 4-D Tensor with the same type as value and shape\n[height, width, output_channels, in_channels].  filter's\nin_channels dimension must match that of value."}, {"name": "output_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D Tensor representing the output shape of the\ndeconvolution op."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 2 or 4.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the H and W dimension. By default\nthe N and C dimensions are set to 0. The dimension order is determined\nby the value of data_format, see below for details."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'SAME'", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC' and 'NCHW' are supported."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the returned tensor."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for value."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for filter."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 2 or 4,\ndefaults to 1. The dilation factor for each dimension ofinput. If a\nsingle value is given it is replicated in the H and W dimension. By\ndefault the N and C dimensions are set to 1. If set to k &gt; 1, there\nwill be k-1 skipped cells between each filter element on that dimension.\nThe dimension order is determined by the value of data_format, see above\nfor details. Dilations in the batch and depth dimensions if a 4-d tensor\nmust be 1."}]}},
{"id": "tf.compat.v1.nn.conv2d_backprop_input", "type": "function", "code": "tf.compat.v1.nn.conv2d_backprop_input(input_sizes,filter=None,out_backprop=None,strides=None,padding=None,use_cudnn_on_gpu=True,data_format='NHWC',dilations=[1,1,1,1],name=None,filters=None)", "summary": "Computes the gradients of convolution with respect to the input.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv2d_backprop_input", "parameters": [{"name": "input_sizes", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAn integer vector representing the shape of input,\nwhere input is a 4-D [batch, height, width, channels] tensor."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types:\nhalf, bfloat16, float32, float64.\n4-D with shape\n[filter_height, filter_width, in_channels, out_channels]."}, {"name": "out_backprop", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must have the same type as filter.\n4-D with shape [batch, out_height, out_width, out_channels].\nGradients w.r.t. the output of the convolution."}, {"name": "strides", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of ints.\nThe stride of the sliding window for each dimension of the input\nof the convolution. Must be in the same order as the dimension specified\nwith format."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "None", "description": "Either the string\"SAME\"or\"VALID\"indicating the type of\npadding algorithm to use, or a list indicating the explicit paddings at\nthe start and end of each dimension. When explicit padding is used and\ndata_format is\"NHWC\", this should be in the form[[0, 0], [pad_top,\npad_bottom], [pad_left, pad_right], [0, 0]]. When explicit padding used\nand data_format is\"NCHW\", this should be in the form[[0, 0], [0, 0],\n[pad_top, pad_bottom], [pad_left, pad_right]]`."}, {"name": "use_cudnn_on_gpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\".\nDefaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, in_height, in_width, in_channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, in_channels, in_height, in_width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for filter."}]}},
{"id": "tf.compat.v1.nn.avg_pool", "type": "function", "code": "tf.compat.v1.nn.avg_pool(value,ksize,strides,padding,data_format='NHWC',name=None,input=None)", "summary": "Performs the average pooling on the input.", "description": "", "code-info": {"name": "tf.compat.v1.nn.avg_pool", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A 4-D Tensor of shape [batch, height, width, channels] and type\nfloat32, float64, qint8, quint8, or qint32."}, {"name": "ksize", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The size of\nthe window for each dimension of the input tensor."}, {"name": "strides", "is_optional": false, "type": "others", "description": "An int or list of ints that has length 1, 2 or 4. The\nstride of the sliding window for each dimension of the input tensor."}, {"name": "padding", "is_optional": false, "type": "string", "description": "A string, either 'VALID' or 'SAME'. The padding algorithm.\nSee the \"returns\" section of tf.nn.convolution for details."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "A string. 'NHWC' and 'NCHW' are supported."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for value."}]}},
{"id": "tf.compat.v1.nn.conv1d", "type": "function", "code": "tf.compat.v1.nn.conv1d(value=None,filters=None,stride=None,padding=None,use_cudnn_on_gpu=None,data_format=None,name=None,input=None,dilations=None)", "summary": "Computes a 1-D convolution given 3-D input and filter tensors. (deprecated argument values) (deprecated argument values)", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv1d", "parameters": [{"name": "value", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 3D Tensor.  Must be of type float16, float32, or float64."}, {"name": "filters", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 3D Tensor.  Must have the same type as value."}, {"name": "stride", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1 or 3.  The number of\nentries by which the filter is moved right at each step."}, {"name": "padding", "is_optional": true, "type": "others", "default_value": "None", "description": "'SAME' or 'VALID'"}, {"name": "use_cudnn_on_gpu", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool.  Defaults to True."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional string from \"NWC\", \"NCW\".  Defaults to \"NWC\",\nthe data is stored in the order of [batch, in_width, in_channels].  The\n\"NCW\" format stores data as [batch, in_channels, in_width]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for value."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1 or 3 which\ndefaults to 1. The dilation factor for each dimension of input. If set to\nk &gt; 1, there will be k-1 skipped cells between each filter element on that\ndimension. Dilations in the batch and depth dimensions must be 1."}]}},
{"id": "tf.compat.v1.nn.bidirectional_dynamic_rnn", "type": "function", "code": "tf.compat.v1.nn.bidirectional_dynamic_rnn(cell_fw,cell_bw,inputs,sequence_length=None,initial_state_fw=None,initial_state_bw=None,dtype=None,parallel_iterations=None,swap_memory=False,time_major=False,scope=None)", "summary": "Creates a dynamic version of bidirectional recurrent neural network. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.nn.bidirectional_dynamic_rnn", "parameters": [{"name": "cell_fw", "is_optional": false, "type": "others", "description": "An instance of RNNCell, to be used for forward direction."}, {"name": "cell_bw", "is_optional": false, "type": "others", "description": "An instance of RNNCell, to be used for backward direction."}, {"name": "inputs", "is_optional": false, "type": "others", "description": "The RNN inputs.\nIf time_major == False (default), this must be a tensor of shape:\n[batch_size, max_time, ...], or a nested tuple of such elements.\nIf time_major == True, this must be a tensor of shape: [max_time,\nbatch_size, ...], or a nested tuple of such elements."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An int32/int64 vector, size [batch_size],\ncontaining the actual lengths for each of the sequences in the batch. If\nnot provided, all batch entries are assumed to be full sequences; and time\nreversal is applied from time 0 to max_time for each sequence."}, {"name": "initial_state_fw", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An initial state for the forward RNN. This must\nbe a tensor of appropriate type and shape [batch_size,\ncell_fw.state_size]. If cell_fw.state_size is a tuple, this should be a\ntuple of tensors having shapes [batch_size, s] for s in\ncell_fw.state_size."}, {"name": "initial_state_bw", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) Same as for initial_state_fw, but using the\ncorresponding properties of cell_bw."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The data type for the initial states and expected output.\nRequired if initial_states are not provided or RNN states have a\nheterogeneous dtype."}, {"name": "parallel_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "(Default: 32).  The number of iterations to run in\nparallel.  Those operations which do not have any temporal dependency and\ncan be run in parallel, will be.  This parameter trades off time for\nspace.  Values &gt;&gt; 1 use more memory but take less time, while smaller\nvalues use less memory but computations take longer."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Transparently swap the tensors produced in forward inference\nbut needed for back prop from GPU to CPU.  This allows training RNNs which\nwould typically not fit on a single GPU, with very minimal (or no)\nperformance penalty."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "False", "description": "The shape format of the inputs and outputs Tensors. If true,\nthese Tensors must be shaped [max_time, batch_size, depth]. If false,\nthese Tensors must be shaped [batch_size, max_time, depth]. Using\ntime_major = True is a bit more efficient because it avoids transposes\nat the beginning and end of the RNN calculation.  However, most TensorFlow\ndata is batch-major, so by default this function accepts input and emits\noutput in batch-major form."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to\n\"bidirectional_rnn\""}]}},
{"id": "tf.compat.v1.nn.batch_norm_with_global_normalization", "type": "function", "code": "tf.compat.v1.nn.batch_norm_with_global_normalization(t=None,m=None,v=None,beta=None,gamma=None,variance_epsilon=None,scale_after_normalization=None,name=None,input=None,mean=None,variance=None)", "summary": "Batch normalization.", "description": "", "code-info": {"name": "tf.compat.v1.nn.batch_norm_with_global_normalization", "parameters": [{"name": "t", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 4D input Tensor."}, {"name": "m", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1D mean Tensor with size matching the last dimension of t.\nThis is the first output from tf.nn.moments,\nor a saved moving average thereof."}, {"name": "v", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1D variance Tensor with size matching the last dimension of t.\nThis is the second output from tf.nn.moments,\nor a saved moving average thereof."}, {"name": "beta", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1D beta Tensor with size matching the last dimension of t.\nAn offset to be added to the normalized tensor."}, {"name": "gamma", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1D gamma Tensor with size matching the last dimension of t.\nIf \"scale_after_normalization\" is true, this tensor will be multiplied\nwith the normalized tensor."}, {"name": "variance_epsilon", "is_optional": true, "type": "float", "default_value": "None", "description": "A small float number to avoid dividing by 0."}, {"name": "scale_after_normalization", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A bool indicating whether the resulted tensor\nneeds to be multiplied with gamma."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for t."}, {"name": "mean", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for m."}, {"name": "variance", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for v."}]}},
{"id": "tf.compat.v1.nn.conv2d", "type": "function", "code": "tf.compat.v1.nn.conv2d(input,filter=None,strides=None,padding=None,use_cudnn_on_gpu=True,data_format='NHWC',dilations=[1,1,1,1],name=None,filters=None)", "summary": "Computes a 2-D convolution given 4-D input and filter tensors.", "description": "", "code-info": {"name": "tf.compat.v1.nn.conv2d", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types:\nhalf, bfloat16, float32, float64.\nA 4-D tensor. The dimension order is interpreted according to the value\nof data_format, see below for details."}, {"name": "filter", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must have the same type as input.\nA 4-D tensor of shape\n[filter_height, filter_width, in_channels, out_channels]"}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "An int or list of ints that has length 1, 2 or 4.  The\nstride of the sliding window for each dimension of input. If a single\nvalue is given it is replicated in the H and W dimension. By default\nthe N and C dimensions are set to 1. The dimension order is determined\nby the value of data_format, see below for details."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "None", "description": "Either the string \"SAME\" or \"VALID\" indicating the type of\npadding algorithm to use, or a list indicating the explicit paddings at\nthe start and end of each dimension. When explicit padding is used and\ndata_format is \"NHWC\", this should be in the form [[0, 0], [pad_top,\npad_bottom], [pad_left, pad_right], [0, 0]]. When explicit padding used\nand data_format is \"NCHW\", this should be in the form [[0, 0], [0, 0],\n[pad_top, pad_bottom], [pad_left, pad_right]]."}, {"name": "use_cudnn_on_gpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\".\nDefaults to \"NHWC\".\nSpecify the data format of the input and output data. With the\ndefault format \"NHWC\", the data is stored in the order of:\n  [batch, height, width, channels].\nAlternatively, the format could be \"NCHW\", the data storage order of:\n  [batch, channels, height, width]."}, {"name": "dilations", "is_optional": true, "type": "others", "default_value": "[1", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1", "is_optional": false, "type": "others", "description": ""}, {"name": "1]", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "filters", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for filter."}]}},
{"id": "tf.compat.v1.metrics.true_negatives", "type": "function", "code": "tf.compat.v1.metrics.true_negatives(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Sum the weights of true_negatives.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.true_negatives", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.true_negatives_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.true_negatives_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes true negatives at provided threshold values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.true_negatives_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor whose shape matches predictions. Will be cast to\nbool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that true_negatives\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.true_positives_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.true_positives_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes true positives at provided threshold values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.true_positives_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor whose shape matches predictions. Will be cast to\nbool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that true_positives\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.specificity_at_sensitivity", "type": "function", "code": "tf.compat.v1.metrics.specificity_at_sensitivity(labels,predictions,sensitivity,weights=None,num_thresholds=200,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the specificity at a given sensitivity.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.specificity_at_sensitivity", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "sensitivity", "is_optional": false, "type": "float", "description": "A scalar value in range [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "The number of thresholds to use for matching the given\nsensitivity."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that specificity\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.true_positives", "type": "function", "code": "tf.compat.v1.metrics.true_positives(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Sum the weights of true_positives.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.true_positives", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.sparse_precision_at_k", "type": "function", "code": "tf.compat.v1.metrics.sparse_precision_at_k(labels,predictions,k,class_id=None,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Renamed to precision_at_k, please use that method instead. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.metrics.sparse_precision_at_k", "parameters": [{"name": "labels", "is_optional": false, "type": "others", "description": ""}, {"name": "predictions", "is_optional": false, "type": "others", "description": ""}, {"name": "k", "is_optional": false, "type": "others", "description": ""}, {"name": "class_id", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "weights", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.metrics.sparse_average_precision_at_k", "type": "function", "code": "tf.compat.v1.metrics.sparse_average_precision_at_k(labels,predictions,k,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Renamed to average_precision_at_k, please use that method instead. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.metrics.sparse_average_precision_at_k", "parameters": [{"name": "labels", "is_optional": false, "type": "others", "description": ""}, {"name": "predictions", "is_optional": false, "type": "others", "description": ""}, {"name": "k", "is_optional": false, "type": "others", "description": ""}, {"name": "weights", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.metrics.recall_at_top_k", "type": "function", "code": "tf.compat.v1.metrics.recall_at_top_k(labels,predictions_idx,k=None,class_id=None,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes recall@k of top-k predictions with respect to sparse labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.recall_at_top_k", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "int64 Tensor or SparseTensor with shape\n[D1, ... DN, num_labels] or [D1, ... DN], where the latter implies\nnum_labels=1. N &gt;= 1 and num_labels is the number of target classes for\nthe associated prediction. Commonly, N=1 and labels has shape\n[batch_size, num_labels]. [D1, ... DN] must match predictions. Values\nshould be in range [0, num_classes), where num_classes is the last\ndimension of predictions. Values outside this range always count\ntowards false_negative_at_&lt;k&gt;."}, {"name": "predictions_idx", "is_optional": false, "type": "tensor", "description": "Integer Tensor with shape [D1, ... DN, k] where N &gt;= 1.\nCommonly, N=1 and predictions has shape [batch size, k]. The final\ndimension contains the top k predicted class indices. [D1, ... DN] must\nmatch labels."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, k for @k metric. Only used for the default op name."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer class ID for which we want binary metrics. This should be\nin range [0, num_classes), where num_classes is the last dimension of\npredictions. If class_id is outside this range, the method returns NAN."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor whose rank is either 0, or n-1, where n is the rank of\nlabels. If the latter, it must be broadcastable to labels (i.e., all\ndimensions must be either 1, or the same as the corresponding labels\ndimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that values should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that updates should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of new update operation, and namespace for other dependent ops."}]}},
{"id": "tf.compat.v1.metrics.recall_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.recall_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes various recall values for different thresholds on predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.recall_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that recall should be\nadded to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.sensitivity_at_specificity", "type": "function", "code": "tf.compat.v1.metrics.sensitivity_at_specificity(labels,predictions,specificity,weights=None,num_thresholds=200,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the specificity at a given sensitivity.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.sensitivity_at_specificity", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "specificity", "is_optional": false, "type": "float", "description": "A scalar value in range [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "The number of thresholds to use for matching the given\nspecificity."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that sensitivity\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.root_mean_squared_error", "type": "function", "code": "tf.compat.v1.metrics.root_mean_squared_error(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the root mean squared error between the labels and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.root_mean_squared_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as predictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary shape."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that\nroot_mean_squared_error should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.precision_at_top_k", "type": "function", "code": "tf.compat.v1.metrics.precision_at_top_k(labels,predictions_idx,k=None,class_id=None,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes precision@k of the predictions with respect to sparse labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.precision_at_top_k", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "int64 Tensor or SparseTensor with shape\n[D1, ... DN, num_labels] or [D1, ... DN], where the latter implies\nnum_labels=1. N &gt;= 1 and num_labels is the number of target classes for\nthe associated prediction. Commonly, N=1 and labels has shape\n[batch_size, num_labels]. [D1, ... DN] must match predictions. Values\nshould be in range [0, num_classes), where num_classes is the last\ndimension of predictions. Values outside this range are ignored."}, {"name": "predictions_idx", "is_optional": false, "type": "tensor", "description": "Integer Tensor with shape [D1, ... DN, k] where\nN &gt;= 1. Commonly, N=1 and predictions has shape [batch size, k].\nThe final dimension contains the top k predicted class indices.\n[D1, ... DN] must match labels."}, {"name": "k", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer, k for @k metric. Only used for the default op name."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer class ID for which we want binary metrics. This should be\nin range [0, num_classes], where num_classes is the last dimension of\npredictions. If class_id is outside this range, the method returns\nNAN."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor whose rank is either 0, or n-1, where n is the rank of\nlabels. If the latter, it must be broadcastable to labels (i.e., all\ndimensions must be either 1, or the same as the corresponding labels\ndimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that values should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that updates should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of new update operation, and namespace for other dependent ops."}]}},
{"id": "tf.compat.v1.metrics.precision_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.precision_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes precision values for different thresholds on predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.precision_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that auc should be\nadded to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.recall_at_k", "type": "function", "code": "tf.compat.v1.metrics.recall_at_k(labels,predictions,k,class_id=None,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes recall@k of the predictions with respect to sparse labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.recall_at_k", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "int64 Tensor or SparseTensor with shape\n[D1, ... DN, num_labels] or [D1, ... DN], where the latter implies\nnum_labels=1. N &gt;= 1 and num_labels is the number of target classes for\nthe associated prediction. Commonly, N=1 and labels has shape\n[batch_size, num_labels]. [D1, ... DN] must match predictions. Values\nshould be in range [0, num_classes), where num_classes is the last\ndimension of predictions. Values outside this range always count\ntowards false_negative_at_&lt;k&gt;."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "Float Tensor with shape [D1, ... DN, num_classes] where\nN &gt;= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].\nThe final dimension contains the logit values for each class. [D1, ... DN]\nmust match labels."}, {"name": "k", "is_optional": false, "type": "int", "description": "Integer, k for @k metric."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer class ID for which we want binary metrics. This should be\nin range [0, num_classes), where num_classes is the last dimension of\npredictions. If class_id is outside this range, the method returns NAN."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor whose rank is either 0, or n-1, where n is the rank of\nlabels. If the latter, it must be broadcastable to labels (i.e., all\ndimensions must be either 1, or the same as the corresponding labels\ndimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that values should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that updates should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of new update operation, and namespace for other dependent ops."}]}},
{"id": "tf.compat.v1.metrics.precision_at_k", "type": "function", "code": "tf.compat.v1.metrics.precision_at_k(labels,predictions,k,class_id=None,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes precision@k of the predictions with respect to sparse labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.precision_at_k", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "int64 Tensor or SparseTensor with shape\n[D1, ... DN, num_labels] or [D1, ... DN], where the latter implies\nnum_labels=1. N &gt;= 1 and num_labels is the number of target classes for\nthe associated prediction. Commonly, N=1 and labels has shape\n[batch_size, num_labels]. [D1, ... DN] must match predictions. Values\nshould be in range [0, num_classes), where num_classes is the last\ndimension of predictions. Values outside this range are ignored."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "Float Tensor with shape [D1, ... DN, num_classes] where\nN &gt;= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].\nThe final dimension contains the logit values for each class. [D1, ... DN]\nmust match labels."}, {"name": "k", "is_optional": false, "type": "int", "description": "Integer, k for @k metric."}, {"name": "class_id", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer class ID for which we want binary metrics. This should be\nin range [0, num_classes], where num_classes is the last dimension of\npredictions. If class_id is outside this range, the method returns\nNAN."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor whose rank is either 0, or n-1, where n is the rank of\nlabels. If the latter, it must be broadcastable to labels (i.e., all\ndimensions must be either 1, or the same as the corresponding labels\ndimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that values should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that updates should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of new update operation, and namespace for other dependent ops."}]}},
{"id": "tf.compat.v1.metrics.precision", "type": "function", "code": "tf.compat.v1.metrics.precision(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the precision of the predictions with respect to the labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.precision", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that precision should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.recall", "type": "function", "code": "tf.compat.v1.metrics.recall(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the recall of the predictions with respect to the labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.recall", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that recall should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.percentage_below", "type": "function", "code": "tf.compat.v1.metrics.percentage_below(values,threshold,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the percentage of values less than the given threshold.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.percentage_below", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A numeric Tensor of arbitrary size."}, {"name": "threshold", "is_optional": false, "type": "float", "description": "A scalar threshold."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nvalues, and must be broadcastable to values (i.e., all dimensions must\nbe either 1, or the same as the corresponding values dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_tensor", "type": "function", "code": "tf.compat.v1.metrics.mean_tensor(values,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the element-wise (weighted) mean of the given tensors.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_tensor", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary dimensions."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nvalues, and must be broadcastable to values (i.e., all dimensions must\nbe either 1, or the same as the corresponding values dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that mean\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op\nshould be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_iou", "type": "function", "code": "tf.compat.v1.metrics.mean_iou(labels,predictions,num_classes,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Calculate per-step mean Intersection-Over-Union (mIOU).", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_iou", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of ground truth labels with shape [batch size] and of\ntype int32 or int64. The tensor will be flattened if its rank &gt; 1."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of prediction results for semantic labels, whose\nshape is [batch size] and type int32 or int64. The tensor will be\nflattened if its rank &gt; 1."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "The possible number of labels the prediction task can\nhave. This value must be provided, since a confusion matrix of\ndimension = [num_classes, num_classes] will be allocated."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that mean_iou\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections update_op should be\nadded to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_per_class_accuracy", "type": "function", "code": "tf.compat.v1.metrics.mean_per_class_accuracy(labels,predictions,num_classes,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Calculates the mean of the per-class accuracies.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_per_class_accuracy", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of ground truth labels with shape [batch size] and of\ntype int32 or int64. The tensor will be flattened if its rank &gt; 1."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of prediction results for semantic labels, whose\nshape is [batch size] and type int32 or int64. The tensor will be\nflattened if its rank &gt; 1."}, {"name": "num_classes", "is_optional": false, "type": "others", "description": "The possible number of labels the prediction task can\nhave. This value must be provided, since two variables with shape =\n[num_classes] will be allocated."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that\n`mean_per_class_accuracy'\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections update_op should be\nadded to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_absolute_error", "type": "function", "code": "tf.compat.v1.metrics.mean_absolute_error(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the mean absolute error between the labels and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_absolute_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as predictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary shape."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that\nmean_absolute_error should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean", "type": "function", "code": "tf.compat.v1.metrics.mean(values,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the (weighted) mean of the given values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary dimensions."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nvalues, and must be broadcastable to values (i.e., all dimensions must\nbe either 1, or the same as the corresponding values dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that mean\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op\nshould be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_relative_error", "type": "function", "code": "tf.compat.v1.metrics.mean_relative_error(labels,predictions,normalizer,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the mean relative error by normalizing with the given values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_relative_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as predictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary shape."}, {"name": "normalizer", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as predictions."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that\nmean_relative_error should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_squared_error", "type": "function", "code": "tf.compat.v1.metrics.mean_squared_error(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the mean squared error between the labels and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_squared_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as predictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary shape."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that\nmean_squared_error should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.false_negatives_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.false_negatives_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes false negatives at provided threshold values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.false_negatives_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor whose shape matches predictions. Will be cast to\nbool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that false_negatives\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.false_positives", "type": "function", "code": "tf.compat.v1.metrics.false_positives(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Sum the weights of false positives.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.false_positives", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.mean_cosine_distance", "type": "function", "code": "tf.compat.v1.metrics.mean_cosine_distance(labels,predictions,dim,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the cosine distance between the labels and predictions.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.mean_cosine_distance", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor of arbitrary shape."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of the same shape as labels."}, {"name": "dim", "is_optional": false, "type": "others", "description": "The dimension along which the cosine distance is computed."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension). Also,\ndimension dim must be 1."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.false_positives_at_thresholds", "type": "function", "code": "tf.compat.v1.metrics.false_positives_at_thresholds(labels,predictions,thresholds,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes false positives at provided threshold values.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.false_positives_at_thresholds", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor whose shape matches predictions. Will be cast to\nbool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "thresholds", "is_optional": false, "type": "float", "description": "A python list or tuple of float thresholds in [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that false_positives\nshould be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.auc", "type": "function", "code": "tf.compat.v1.metrics.auc(labels,predictions,weights=None,num_thresholds=200,metrics_collections=None,updates_collections=None,curve='ROC',name=None,summation_method='trapezoidal',thresholds=None)", "summary": "Computes the approximate AUC via a Riemann sum. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.metrics.auc", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "A Tensor whose shape matches predictions. Will be cast to\nbool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "A floating point Tensor of arbitrary shape and whose values\nare in the range [0, 1]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "num_thresholds", "is_optional": true, "type": "int", "default_value": "200", "description": "The number of thresholds to use when discretizing the roc\ncurve."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that auc should be\nadded to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "curve", "is_optional": true, "type": "string", "default_value": "'ROC'", "description": "Specifies the name of the curve to be computed, 'ROC' [default] or\n'PR' for the Precision-Recall-curve."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}, {"name": "summation_method", "is_optional": true, "type": "string", "default_value": "'trapezoidal'", "description": "Specifies the Riemann summation method used\n(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that\napplies the trapezoidal rule; 'careful_interpolation', a variant of it\ndiffering only by a more correct interpolation scheme for PR-AUC -\ninterpolating (true/false) positives but not the ratio that is precision;\n'minoring' that applies left summation for increasing intervals and right\nsummation for decreasing intervals; 'majoring' that does the opposite.\nNote that 'careful_interpolation' is strictly preferred to 'trapezoidal'\n(to be deprecated soon) as it applies the same method for ROC, and a\nbetter one (see Davis &amp; Goadrich 2006 for details) for the PR curve."}, {"name": "thresholds", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional list of floating point values to use as the\nthresholds for discretizing the curve. If set, the num_thresholds\nparameter is ignored. Values should be in [0, 1]. Endpoint thresholds\nequal to {-epsilon, 1+epsilon} for a small positive epsilon value will be\nautomatically included with these to correctly handle predictions equal to\nexactly 0 or 1."}]}},
{"id": "tf.compat.v1.metrics.false_negatives", "type": "function", "code": "tf.compat.v1.metrics.false_negatives(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes the total number of false negatives.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.false_negatives", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose dimensions must match\npredictions. Will be cast to bool."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of arbitrary dimensions. Will\nbe cast to bool."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric\nvalue variable should be added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that the metric update\nops should be added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.metrics.average_precision_at_k", "type": "function", "code": "tf.compat.v1.metrics.average_precision_at_k(labels,predictions,k,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Computes average precision@k of predictions with respect to sparse labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.average_precision_at_k", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "int64 Tensor or SparseTensor with shape\n[D1, ... DN, num_labels] or [D1, ... DN], where the latter implies\nnum_labels=1. N &gt;= 1 and num_labels is the number of target classes for\nthe associated prediction. Commonly, N=1 and labels has shape\n[batch_size, num_labels]. [D1, ... DN] must match predictions. Values\nshould be in range [0, num_classes), where num_classes is the last\ndimension of predictions. Values outside this range are ignored."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "Float Tensor with shape [D1, ... DN, num_classes] where\nN &gt;= 1. Commonly, N=1 and predictions has shape\n[batch size, num_classes]. The final dimension contains the logit values\nfor each class. [D1, ... DN] must match labels."}, {"name": "k", "is_optional": false, "type": "int", "description": "Integer, k for @k metric. This will calculate an average precision for\nrange [1,k], as documented above."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor whose rank is either 0, or n-1, where n is the rank of\nlabels. If the latter, it must be broadcastable to labels (i.e., all\ndimensions must be either 1, or the same as the corresponding labels\ndimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that values should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that updates should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of new update operation, and namespace for other dependent ops."}]}},
{"id": "tf.compat.v1.metrics.accuracy", "type": "function", "code": "tf.compat.v1.metrics.accuracy(labels,predictions,weights=None,metrics_collections=None,updates_collections=None,name=None)", "summary": "Calculates how often predictions matches labels.", "description": "", "code-info": {"name": "tf.compat.v1.metrics.accuracy", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth values, a Tensor whose shape matches\npredictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted values, a Tensor of any shape."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding labels dimension)."}, {"name": "metrics_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that accuracy should\nbe added to."}, {"name": "updates_collections", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of collections that update_op should\nbe added to."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional variable_scope name."}]}},
{"id": "tf.compat.v1.math.log_softmax", "type": "function", "code": "tf.compat.v1.math.log_softmax(logits,axis=None,name=None,dim=None)", "summary": "Computes log softmax activations. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.math.log_softmax", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "A non-empty Tensor. Must be one of the following types: half,\nfloat32, float64."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimension softmax would be performed on. The default is -1 which\nindicates the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "dim", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for axis."}]}},
{"id": "tf.compat.v1.math.softmax", "type": "function", "code": "tf.compat.v1.math.softmax(logits,axis=None,name=None,dim=None)", "summary": "Computes softmax activations. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.math.softmax", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "A non-empty Tensor, or an object whose type has a registered\nTensor conversion function. Must be one of the following types:\nhalf,float32, float64. See also convert_to_tensor"}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimension softmax would be performed on. The default is -1 which\nindicates the last dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "dim", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for axis."}]}},
{"id": "tf.compat.v1.losses.sparse_softmax_cross_entropy", "type": "function", "code": "tf.compat.v1.losses.sparse_softmax_cross_entropy(labels,logits,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Cross-entropy loss using tf.nn.sparse_softmax_cross_entropy_with_logits.", "description": "", "code-info": {"name": "tf.compat.v1.losses.sparse_softmax_cross_entropy", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "Tensor of shape [d_0, d_1, ..., d_{r-1}] (where r is rank of\nlabels and result) and dtype int32 or int64. Each entry in labels\nmust be an index in [0, num_classes). Other values will raise an\nexception when this op is run on CPU, and return NaN for corresponding\nloss and gradient rows on GPU."}, {"name": "logits", "is_optional": false, "type": "others", "description": "Unscaled log probabilities of shape\n[d_0, d_1, ..., d_{r-1}, num_classes] and dtype float16, float32 or\nfloat64."}, {"name": "weights", "is_optional": true, "type": "float", "default_value": "1.0", "description": "Coefficients for the loss. This must be scalar or broadcastable to\nlabels (i.e. same rank and each dimension is either 1 or the same)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "the scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.math.in_top_k", "type": "function", "code": "tf.compat.v1.math.in_top_k(predictions,targets,k,name=None)", "summary": "Says whether the targets are in the top K predictions.", "description": "", "code-info": {"name": "tf.compat.v1.math.in_top_k", "parameters": [{"name": "predictions", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nA batch_size x classes tensor."}, {"name": "targets", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA batch_size vector of class ids."}, {"name": "k", "is_optional": false, "type": "others", "description": "An int. Number of top elements to look at for computing precision."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.losses.hinge_loss", "type": "function", "code": "tf.compat.v1.losses.hinge_loss(labels,logits,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Adds a hinge loss to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.hinge_loss", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor. Its shape should match the shape of\nlogits. The values of the tensor are expected to be 0.0 or 1.0. Internally\nthe {0,1} labels are converted to {-1,1} when calculating the hinge loss."}, {"name": "logits", "is_optional": false, "type": "tensor", "description": "The logits, a float tensor. Note that logits are assumed to be\nunbounded and 0-centered. A value &gt; 0 (resp. &lt; 0) is considered a positive\n(resp. negative) binary prediction."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.softmax_cross_entropy", "type": "function", "code": "tf.compat.v1.losses.softmax_cross_entropy(onehot_labels,logits,weights=1.0,label_smoothing=0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Creates a cross-entropy loss using tf.nn.softmax_cross_entropy_with_logits_v2.", "description": "", "code-info": {"name": "tf.compat.v1.losses.softmax_cross_entropy", "parameters": [{"name": "onehot_labels", "is_optional": false, "type": "others", "description": "One-hot-encoded labels."}, {"name": "logits", "is_optional": false, "type": "others", "description": "Logits outputs of the network."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor that is broadcastable to loss."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "If greater than 0 then smooth the labels."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "the scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.mean_pairwise_squared_error", "type": "function", "code": "tf.compat.v1.losses.mean_pairwise_squared_error(labels,predictions,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES)", "summary": "Adds a pairwise-errors-squared loss to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.mean_pairwise_squared_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor, whose shape must match the shape of\npredictions."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "The predicted outputs, a tensor of size\n[batch_size, d0, .. dN] where N+1 is the total number of dimensions in\npredictions."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Coefficients for the loss a scalar, a tensor of shape\n[batch_size] or a tensor whose shape matches predictions."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}]}},
{"id": "tf.compat.v1.losses.mean_squared_error", "type": "function", "code": "tf.compat.v1.losses.mean_squared_error(labels,predictions,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Adds a Sum-of-Squares loss to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.mean_squared_error", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor, same dimensions as 'predictions'."}, {"name": "predictions", "is_optional": false, "type": "others", "description": "The predicted outputs."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.sigmoid_cross_entropy", "type": "function", "code": "tf.compat.v1.losses.sigmoid_cross_entropy(multi_class_labels,logits,weights=1.0,label_smoothing=0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Creates a cross-entropy loss using tf.nn.sigmoid_cross_entropy_with_logits.", "description": "", "code-info": {"name": "tf.compat.v1.losses.sigmoid_cross_entropy", "parameters": [{"name": "multi_class_labels", "is_optional": false, "type": "int", "description": "[batch_size, num_classes] target integer labels in\n{0, 1}."}, {"name": "logits", "is_optional": false, "type": "float", "description": "Float [batch_size, num_classes] logits outputs of the network."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "label_smoothing", "is_optional": true, "type": "int", "default_value": "0", "description": "If greater than 0 then smooth the labels."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.log_loss", "type": "function", "code": "tf.compat.v1.losses.log_loss(labels,predictions,weights=1.0,epsilon=1e-07,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Adds a Log Loss term to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.log_loss", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor, same dimensions as 'predictions'."}, {"name": "predictions", "is_optional": false, "type": "others", "description": "The predicted outputs."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-07", "description": "A small increment to add to avoid taking a log of zero."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.huber_loss", "type": "function", "code": "tf.compat.v1.losses.huber_loss(labels,predictions,weights=1.0,delta=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Adds a Huber Loss term to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.huber_loss", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor, same dimensions as 'predictions'."}, {"name": "predictions", "is_optional": false, "type": "others", "description": "The predicted outputs."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "delta", "is_optional": true, "type": "float", "default_value": "1.0", "description": "float, the point where the huber loss function\nchanges from a quadratic to linear."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which the loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.get_regularization_losses", "type": "function", "code": "tf.compat.v1.losses.get_regularization_losses(scope=None)", "summary": "Gets the list of regularization losses.", "description": "", "code-info": {"name": "tf.compat.v1.losses.get_regularization_losses", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional scope name for filtering the losses to return."}]}},
{"id": "tf.compat.v1.losses.get_regularization_loss", "type": "function", "code": "tf.compat.v1.losses.get_regularization_loss(scope=None,name='total_regularization_loss')", "summary": "Gets the total regularization loss.", "description": "", "code-info": {"name": "tf.compat.v1.losses.get_regularization_loss", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional scope name for filtering the losses to return."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'total_regularization_loss'", "description": "The name of the returned tensor."}]}},
{"id": "tf.compat.v1.losses.get_total_loss", "type": "function", "code": "tf.compat.v1.losses.get_total_loss(add_regularization_losses=True,name='total_loss',scope=None)", "summary": "Returns a tensor whose value represents the total loss.", "description": "", "code-info": {"name": "tf.compat.v1.losses.get_total_loss", "parameters": [{"name": "add_regularization_losses", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean indicating whether or not to use the\nregularization losses in the sum."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'total_loss'", "description": "The name of the returned tensor."}, {"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional scope name for filtering the losses to return. Note that\nthis filters the losses added with tf.add_loss() as well as the\nregularization losses to that scope."}]}},
{"id": "tf.compat.v1.losses.add_loss", "type": "function", "code": "tf.compat.v1.losses.add_loss(loss,loss_collection=tf.GraphKeys.LOSSES)", "summary": "Adds a externally defined loss to the collection of losses.", "description": "", "code-info": {"name": "tf.compat.v1.losses.add_loss", "parameters": [{"name": "loss", "is_optional": false, "type": "tensor", "description": "A loss Tensor."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "Optional collection to add the loss to."}]}},
{"id": "tf.compat.v1.losses.get_losses", "type": "function", "code": "tf.compat.v1.losses.get_losses(scope=None,loss_collection=tf.GraphKeys.LOSSES)", "summary": "Gets the list of losses from the loss_collection.", "description": "", "code-info": {"name": "tf.compat.v1.losses.get_losses", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional scope name for filtering the losses to return."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "Optional losses collection."}]}},
{"id": "tf.compat.v1.losses.compute_weighted_loss", "type": "function", "code": "tf.compat.v1.losses.compute_weighted_loss(losses,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Computes the weighted loss.", "description": "", "code-info": {"name": "tf.compat.v1.losses.compute_weighted_loss", "parameters": [{"name": "losses", "is_optional": false, "type": "tensor", "description": "Tensor of shape [batch_size, d1, ... dN]."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlosses, and must be broadcastable to losses (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "the scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "the loss will be added to these collections."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.absolute_difference", "type": "function", "code": "tf.compat.v1.losses.absolute_difference(labels,predictions,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS)", "summary": "Adds an Absolute Difference loss to the training procedure.", "description": "", "code-info": {"name": "tf.compat.v1.losses.absolute_difference", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "The ground truth output tensor, same dimensions as 'predictions'."}, {"name": "predictions", "is_optional": false, "type": "others", "description": "The predicted outputs."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which this loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}]}},
{"id": "tf.compat.v1.losses.cosine_distance", "type": "function", "code": "tf.compat.v1.losses.cosine_distance(labels,predictions,axis=None,weights=1.0,scope=None,loss_collection=tf.GraphKeys.LOSSES,reduction=Reduction.SUM_BY_NONZERO_WEIGHTS,dim=None)", "summary": "Adds a cosine-distance loss to the training procedure. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.losses.cosine_distance", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "Tensor whose shape matches 'predictions'"}, {"name": "predictions", "is_optional": false, "type": "others", "description": "An arbitrary matrix."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimension along which the cosine distance is computed."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Optional Tensor whose rank is either 0, or the same rank as\nlabels, and must be broadcastable to labels (i.e., all dimensions must\nbe either 1, or the same as the corresponding losses dimension)."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "The scope for the operations performed in computing the loss."}, {"name": "loss_collection", "is_optional": true, "type": "others", "default_value": "tf.GraphKeys.LOSSES", "description": "collection to which this loss will be added."}, {"name": "reduction", "is_optional": true, "type": "others", "default_value": "Reduction.SUM_BY_NONZERO_WEIGHTS", "description": "Type of reduction to apply to loss."}, {"name": "dim", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}]}},
{"id": "tf.compat.v1.lookup.StaticVocabularyTable", "type": "class", "code": "tf.compat.v1.lookup.StaticVocabularyTable(initializer,num_oov_buckets,lookup_key_dtype=None,name=None)", "summary": "String to Id table wrapper that assigns out-of-vocabulary keys to buckets.\n\nInherits From: StaticVocabularyTable", "description": "", "code-info": {"name": "tf.compat.v1.lookup.StaticVocabularyTable", "parameters": [{"name": "initializer", "is_optional": false, "type": "others", "description": "A TableInitializerBase object that contains the data used to\ninitialize the table. If None, then we only use out-of-vocab buckets."}, {"name": "num_oov_buckets", "is_optional": false, "type": "others", "description": "Number of buckets to use for out-of-vocabulary keys. Must\nbe greater than zero."}, {"name": "lookup_key_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Data type of keys passed to lookup. Defaults to\ninitializer.key_dtype if initializer is specified, otherwise\ntf.string. Must be string or integer, and must be castable to\ninitializer.key_dtype."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.lookup.StaticHashTable", "type": "class", "code": "tf.compat.v1.lookup.StaticHashTable(initializer,default_value,name=None)", "summary": "A generic hash table that is immutable once initialized.\n\nInherits From: StaticHashTable", "description": "", "code-info": {"name": "tf.compat.v1.lookup.StaticHashTable", "parameters": [{"name": "initializer", "is_optional": false, "type": "others", "description": "The table initializer to use. See HashTable kernel for\nsupported key and value types."}, {"name": "default_value", "is_optional": false, "type": "others", "description": "The value to use if a key is missing in the table."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.logging.warning", "type": "function", "code": "tf.compat.v1.logging.warning(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.warning", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.vlog", "type": "function", "code": "tf.compat.v1.logging.vlog(level,msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.vlog", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": ""}, {"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.TaskLevelStatusMessage", "type": "function", "code": "tf.compat.v1.logging.TaskLevelStatusMessage(msg)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.TaskLevelStatusMessage", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.set_verbosity", "type": "function", "code": "tf.compat.v1.logging.set_verbosity(v)", "summary": "Sets the threshold for what messages will be logged.", "description": "", "code-info": {"name": "tf.compat.v1.logging.set_verbosity", "parameters": [{"name": "v", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.log", "type": "function", "code": "tf.compat.v1.logging.log(level,msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.log", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": ""}, {"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.log_every_n", "type": "function", "code": "tf.compat.v1.logging.log_every_n(level,msg,n,*args)", "summary": "Log 'msg % args' at level 'level' once per 'n' times.", "description": "", "code-info": {"name": "tf.compat.v1.logging.log_every_n", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": "The level at which to log."}, {"name": "msg", "is_optional": false, "type": "others", "description": "The message to be logged."}, {"name": "n", "is_optional": false, "type": "others", "description": "The number of times this should be called before it is logged."}, {"name": "*args", "is_optional": false, "type": "others", "description": "The args to be substituted into the msg."}]}},
{"id": "tf.compat.v1.logging.log_if", "type": "function", "code": "tf.compat.v1.logging.log_if(level,msg,condition,*args)", "summary": "Log 'msg % args' at level 'level' only if condition is fulfilled.", "description": "", "code-info": {"name": "tf.compat.v1.logging.log_if", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": ""}, {"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "condition", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.log_first_n", "type": "function", "code": "tf.compat.v1.logging.log_first_n(level,msg,n,*args)", "summary": "Log 'msg % args' at level 'level' only first 'n' times.", "description": "", "code-info": {"name": "tf.compat.v1.logging.log_first_n", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": "The level at which to log."}, {"name": "msg", "is_optional": false, "type": "others", "description": "The message to be logged."}, {"name": "n", "is_optional": false, "type": "others", "description": "The number of times this should be called before it is logged."}, {"name": "*args", "is_optional": false, "type": "others", "description": "The args to be substituted into the msg."}]}},
{"id": "tf.compat.v1.logging.get_verbosity", "type": "function", "code": "tf.compat.v1.logging.get_verbosity()", "summary": "Return how much logging output will be produced.", "description": "", "code-info": {"name": "tf.compat.v1.logging.get_verbosity", "parameters": []}},
{"id": "tf.compat.v1.logging.warn", "type": "function", "code": "tf.compat.v1.logging.warn(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.warn", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.fatal", "type": "function", "code": "tf.compat.v1.logging.fatal(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.fatal", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.info", "type": "function", "code": "tf.compat.v1.logging.info(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.info", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.logging.flush", "type": "function", "code": "tf.compat.v1.logging.flush()", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.flush", "parameters": []}},
{"id": "tf.compat.v1.logging.error", "type": "function", "code": "tf.compat.v1.logging.error(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.error", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.lite.experimental.nn.TfLiteRNNCell", "type": "class", "code": "tf.compat.v1.lite.experimental.nn.TfLiteRNNCell(num_units,activation=None,reuse=None,name=None,dtype=None,**kwargs)", "summary": "The most basic RNN cell.", "description": "", "code-info": {"name": "tf.compat.v1.lite.experimental.nn.TfLiteRNNCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the RNN cell."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Nonlinearity to use.  Default: tanh. It could also be string\nthat is within Keras activation function names."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in\nan existing scope. Raises an error if not True and the existing scope\nalready has the given variables."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Dict, keyword named properties for common layer attributes, like\ntrainable etc when constructing the cell from configs of get_config()."}]}},
{"id": "tf.compat.v1.logging.debug", "type": "function", "code": "tf.compat.v1.logging.debug(msg,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.logging.debug", "parameters": [{"name": "msg", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell", "type": "class", "code": "tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell(num_units,use_peepholes=False,cell_clip=None,initializer=None,num_proj=None,proj_clip=None,num_unit_shards=None,num_proj_shards=None,forget_bias=1.0,state_is_tuple=True,activation=None,reuse=None,name=None,dtype=None)", "summary": "Long short-term memory unit (LSTM) recurrent network cell.", "description": "", "code-info": {"name": "tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell", "parameters": [{"name": "num_units", "is_optional": false, "type": "others", "description": "int, The number of units in the LSTM cell."}, {"name": "use_peepholes", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, set True to enable diagonal/peephole connections."}, {"name": "cell_clip", "is_optional": true, "type": "float", "default_value": "None", "description": "(optional) A float value, if provided the cell state is clipped\nby this value prior to the cell output activation."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The initializer to use for the weight and\nprojection matrices."}, {"name": "num_proj", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) int, The output dimensionality for the projection\nmatrices.  If None, no projection is performed."}, {"name": "proj_clip", "is_optional": true, "type": "float", "default_value": "None", "description": "(optional) A float value.  If num_proj &gt; 0 and proj_clip is\nprovided, then the projected values are clipped elementwise to within\n[-proj_clip, proj_clip]."}, {"name": "num_unit_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated, will be removed by Jan. 2017. Use a\nvariable_scope partitioner instead."}, {"name": "num_proj_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated, will be removed by Jan. 2017. Use a\nvariable_scope partitioner instead."}, {"name": "forget_bias", "is_optional": true, "type": "others", "default_value": "1.0", "description": "Biases of the forget gate are initialized by default to 1 in\norder to reduce the scale of forgetting at the beginning of the\ntraining. Must set it manually to 0.0 when restoring from CudnnLSTM\ntrained checkpoints."}, {"name": "state_is_tuple", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, accepted and returned states are 2-tuples of the\nc_state and m_state.  If False, they are concatenated along the\ncolumn axis.  This latter behavior will soon be deprecated."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function of the inner states.  Default: tanh."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python boolean describing whether to reuse variables in\nan existing scope.  If not True, and the existing scope already has\nthe given variables, an error is raised."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String, the name of the layer. Layers with the same name will share\nweights, but to avoid mistakes we require reuse=True in such cases."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Default dtype of the layer (default of None means use the type of\nthe first input). Required when build is called before call.  When\nrestoring from CudnnLSTM-trained checkpoints, use\nCudnnCompatibleLSTMCell instead."}]}},
{"id": "tf.compat.v1.lite.experimental.nn.dynamic_rnn", "type": "function", "code": "tf.compat.v1.lite.experimental.nn.dynamic_rnn(cell,inputs,sequence_length=None,initial_state=None,dtype=None,parallel_iterations=None,swap_memory=False,time_major=True,scope=None)", "summary": "Creates a recurrent neural network specified by RNNCell cell.", "description": "", "code-info": {"name": "tf.compat.v1.lite.experimental.nn.dynamic_rnn", "parameters": [{"name": "cell", "is_optional": false, "type": "others", "description": "An instance of RNNCell."}, {"name": "inputs", "is_optional": false, "type": "others", "description": "The RNN inputs.\nIf time_major == False (default), this must be a Tensor of shape:\n[batch_size, max_time, ...], or a nested tuple of such elements.\nIf time_major == True, this must be a Tensor of shape: [max_time,\nbatch_size, ...], or a nested tuple of such elements. This may also be\na (possibly nested) tuple of Tensors satisfying this property.  The\nfirst two dimensions must match across all the inputs, but otherwise the\nranks and other shape components may differ. In this case, input to\ncell at each time-step will replicate the structure of these tuples,\nexcept for the time dimension (from which the time is taken). The input\nto cell at each time step will be a Tensor or (possibly nested)\ntuple of Tensors each with dimensions [batch_size, ...]."}, {"name": "sequence_length", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An int32/int64 vector sized [batch_size]. Used\nto copy-through state and zero-out outputs when past a batch element's\nsequence length.  So it's more for performance than correctness."}, {"name": "initial_state", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) An initial state for the RNN. If cell.state_size\nis an integer, this must be a Tensor of appropriate type and shape\n[batch_size, cell.state_size]. If cell.state_size is a tuple, this\nshould be a tuple of tensors having shapes [batch_size, s] for s in\ncell.state_size."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The data type for the initial state and expected output.\nRequired if initial_state is not provided or RNN state has a heterogeneous\ndtype."}, {"name": "parallel_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "(Default: 32).  The number of iterations to run in\nparallel.  Those operations which do not have any temporal dependency and\ncan be run in parallel, will be.  This parameter trades off time for\nspace.  Values &gt;&gt; 1 use more memory but take less time, while smaller\nvalues use less memory but computations take longer."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Transparently swap the tensors produced in forward inference\nbut needed for back prop from GPU to CPU.  This allows training RNNs which\nwould typically not fit on a single GPU, with very minimal (or no)\nperformance penalty."}, {"name": "time_major", "is_optional": true, "type": "bool", "default_value": "True", "description": "The shape format of the inputs and outputs Tensors. If true,\nthese Tensors must be shaped [max_time, batch_size, depth]. If false,\nthese Tensors must be shaped [batch_size, max_time, depth]. Using\ntime_major = True is a bit more efficient because it avoids transposes\nat the beginning and end of the RNN calculation.  However, most TensorFlow\ndata is batch-major, so by default this function accepts input and emits\noutput in batch-major form."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableScope for the created subgraph; defaults to \"rnn\"."}]}},
{"id": "tf.compat.v1.lite.experimental.get_potentially_supported_ops", "type": "function", "code": "tf.compat.v1.lite.experimental.get_potentially_supported_ops()", "summary": "Returns operations potentially supported by TensorFlow Lite.", "description": "", "code-info": {"name": "tf.compat.v1.lite.experimental.get_potentially_supported_ops", "parameters": []}},
{"id": "tf.compat.v1.lite.experimental.convert_op_hints_to_stubs", "type": "function", "code": "tf.compat.v1.lite.experimental.convert_op_hints_to_stubs(session=None,graph_def=None,write_callback=(lambdagraph_def,comments:None))", "summary": "Converts a graphdef with LiteOp hints into stub operations.", "description": "", "code-info": {"name": "tf.compat.v1.lite.experimental.convert_op_hints_to_stubs", "parameters": [{"name": "session", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A TensorFlow session that contains the graph to convert."}, {"name": "graph_def", "is_optional": true, "type": "others", "default_value": "None", "description": "A graph def that we should convert."}, {"name": "write_callback", "is_optional": false, "type": "others", "description": "A function pointer that can be used to write intermediate\nsteps of graph transformation (optional)."}]}},
{"id": "tf.compat.v1.lite.toco_convert", "type": "function", "code": "tf.compat.v1.lite.toco_convert(input_data,input_tensors,output_tensors,*args,**kwargs)", "summary": "Convert a model using TOCO. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.lite.toco_convert", "parameters": [{"name": "input_data", "is_optional": false, "type": "others", "description": "Input data (i.e. often sess.graph_def),"}, {"name": "input_tensors", "is_optional": false, "type": "tensor", "description": "List of input tensors. Type and shape are computed using\nfoo.shape and foo.dtype."}, {"name": "output_tensors", "is_optional": false, "type": "tensor", "description": "List of output tensors (only .name is used from this)."}, {"name": "*args", "is_optional": false, "type": "others", "description": "See build_toco_convert_protos,"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "See build_toco_convert_protos."}]}},
{"id": "tf.compat.v1.lite.TFLiteConverter", "type": "class", "code": "tf.compat.v1.lite.TFLiteConverter(graph_def,input_tensors,output_tensors,input_arrays_with_shape=None,output_arrays=None,experimental_debug_info_func=None)", "summary": "Convert a TensorFlow model into output_format.", "description": "", "code-info": {"name": "tf.compat.v1.lite.TFLiteConverter", "parameters": [{"name": "graph_def", "is_optional": false, "type": "tensor", "description": "Frozen TensorFlow GraphDef."}, {"name": "input_tensors", "is_optional": false, "type": "tensor", "description": "List of input tensors. Type and shape are computed using\nfoo.shape and foo.dtype."}, {"name": "output_tensors", "is_optional": false, "type": "tensor", "description": "List of output tensors (only .name is used from this)."}, {"name": "input_arrays_with_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tuple of strings representing input tensor names\nand list of integers representing input shapes\n(e.g., [(\"foo\" : [1, 16, 16, 3])]). Use only when graph cannot be loaded\ninto TensorFlow and when input_tensors and output_tensors are\nNone. (default None)"}, {"name": "output_arrays", "is_optional": true, "type": "tensor", "default_value": "None", "description": "List of output tensors to freeze graph with. Use only when\ngraph cannot be loaded into TensorFlow and when input_tensors and\noutput_tensors are None. (default None)"}, {"name": "experimental_debug_info_func", "is_optional": true, "type": "others", "default_value": "None", "description": "An experimental function to retrieve the\ngraph debug info for a set of nodes from the graph_def."}]}},
{"id": "tf.compat.v1.lite.OpHint.OpHintArgumentTracker", "type": "function", "code": "tf.compat.v1.lite.OpHint.OpHintArgumentTracker(function_name,unique_function_id,node_name_prefix,attr_name,level=1,children_inputs_mappings=None)", "summary": "Conceptually tracks indices of arguments of \"OpHint functions\".", "description": "", "code-info": {"name": "tf.compat.v1.lite.OpHint.OpHintArgumentTracker", "parameters": [{"name": "function_name", "is_optional": false, "type": "string", "description": "Name of the function that this tracks arguments for."}, {"name": "unique_function_id", "is_optional": false, "type": "others", "description": "UUID of function that this tracks arguments for."}, {"name": "node_name_prefix", "is_optional": false, "type": "string", "description": "How identities that are created are named."}, {"name": "attr_name", "is_optional": false, "type": "string", "description": "Name of attribute to use to store the index for this hint.\ni.e. FUNCTION_INPUT_INDEX or FUNCTION_OUTPUT_INDEX"}, {"name": "level", "is_optional": true, "type": "int", "default_value": "1", "description": "Hierarchical level of the Ophint node, a number."}, {"name": "children_inputs_mappings", "is_optional": true, "type": "others", "default_value": "None", "description": "Inputs/Outputs mapping for children hints."}]}},
{"id": "tf.compat.v1.linalg.l2_normalize", "type": "function", "code": "tf.compat.v1.linalg.l2_normalize(x,axis=None,epsilon=1e-12,name=None,dim=None)", "summary": "Normalizes along dimension axis using an L2 norm. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.linalg.l2_normalize", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "Dimension along which to normalize.  A scalar or a vector of\nintegers."}, {"name": "epsilon", "is_optional": true, "type": "others", "default_value": "1e-12", "description": "A lower bound value for the norm. Will use sqrt(epsilon) as the\ndivisor if norm &lt; sqrt(epsilon)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "dim", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for axis."}]}},
{"id": "tf.compat.v1.layers.experimental.set_keras_style", "type": "function", "code": "tf.compat.v1.layers.experimental.set_keras_style()", "summary": "Use Keras-style variable management.", "description": "", "code-info": {"name": "tf.compat.v1.layers.experimental.set_keras_style", "parameters": []}},
{"id": "tf.compat.v1.lite.OpHint", "type": "function", "code": "tf.compat.v1.lite.OpHint(function_name,level=1,children_inputs_mappings=None,**kwargs)", "summary": "A class that helps build tflite function invocations.", "description": "", "code-info": {"name": "tf.compat.v1.lite.OpHint", "parameters": [{"name": "function_name", "is_optional": false, "type": "string", "description": "Name of the function (the custom op name in tflite)"}, {"name": "level", "is_optional": true, "type": "int", "default_value": "1", "description": "OpHint level."}, {"name": "children_inputs_mappings", "is_optional": true, "type": "others", "default_value": "None", "description": "Children OpHint inputs/outputs mapping.\nchildren_inputs_mappings should like below:\n\"parent_first_child_input\":\n  [{\"parent_input_index\": num, \"child_input_index\": num}, ...]\n\"parent_last_child_output\":\n  [{\"parent_output_index\": num, \"child_output_index\": num}, ...]\n\"internal_children_input_output\":\n  [{\"child_input_index\": num, \"child_output_index\": num}, ...]"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Keyword arguments of any constant attributes for the function."}]}},
{"id": "tf.compat.v1.layers.separable_conv2d", "type": "function", "code": "tf.compat.v1.layers.separable_conv2d(inputs,filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1),depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer=None,pointwise_initializer=None,bias_initializer=tf.zeros_initializer(),depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for the depthwise separable 2D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.separable_conv2d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A tuple or list of 2 integers specifying the spatial\ndimensions of the filters. Can be a single integer to specify the same\nvalue for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the strides\nof the convolution. Can be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\ndilation_rate: An integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\ndepth_multiplier: The number of depthwise convolution output channels for\neach input channel. The total number of depthwise convolution output\nchannels will be equal to num_filters_in * depth_multiplier.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\ndepthwise_initializer: An initializer for the depthwise convolution kernel.\npointwise_initializer: An initializer for the pointwise convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\ndepthwise_regularizer: Optional regularizer for the depthwise\nconvolution kernel.\npointwise_regularizer: Optional regularizer for the pointwise\nconvolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\ndepthwise_constraint: Optional projection function to be applied to the\ndepthwise kernel after being updated by an Optimizer (e.g. used for\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\npointwise_constraint: Optional projection function to be applied to the\npointwise kernel after being updated by an Optimizer.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.separable_conv1d", "type": "function", "code": "tf.compat.v1.layers.separable_conv1d(inputs,filters,kernel_size,strides=1,padding='valid',data_format='channels_last',dilation_rate=1,depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer=None,pointwise_initializer=None,bias_initializer=tf.zeros_initializer(),depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for the depthwise separable 1D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.separable_conv1d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A single integer specifying the spatial\ndimensions of the filters."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer specifying the strides\nof the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1."}, {"name": "depth_multiplier", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of depthwise convolution output channels for\neach input channel. The total number of depthwise convolution output\nchannels will be equal to num_filters_in * depth_multiplier."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "depthwise_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the depthwise convolution kernel."}, {"name": "pointwise_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the pointwise convolution kernel."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "An initializer for the bias vector. If None, the default\ninitializer will be used.\ndepthwise_regularizer: Optional regularizer for the depthwise\nconvolution kernel.\npointwise_regularizer: Optional regularizer for the pointwise\nconvolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\ndepthwise_constraint: Optional projection function to be applied to the\ndepthwise kernel after being updated by an Optimizer (e.g. used for\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\npointwise_constraint: Optional projection function to be applied to the\npointwise kernel after being updated by an Optimizer.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.SeparableConv2D", "type": "class", "code": "tf.compat.v1.layers.SeparableConv2D(filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1),depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer=None,pointwise_initializer=None,bias_initializer=tf.zeros_initializer(),depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Depthwise separable 2D convolution.\n\nInherits From: SeparableConv2D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.SeparableConv2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A tuple or list of 2 integers specifying the spatial\ndimensions of the filters. Can be a single integer to specify the same\nvalue for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the strides\nof the convolution. Can be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\ndilation_rate: An integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\ndepth_multiplier: The number of depthwise convolution output channels for\neach input channel. The total number of depthwise convolution output\nchannels will be equal to num_filters_in * depth_multiplier.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\ndepthwise_initializer: An initializer for the depthwise convolution kernel.\npointwise_initializer: An initializer for the pointwise convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\ndepthwise_regularizer: Optional regularizer for the depthwise\nconvolution kernel.\npointwise_regularizer: Optional regularizer for the pointwise\nconvolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\ndepthwise_constraint: Optional projection function to be applied to the\ndepthwise kernel after being updated by an Optimizer (e.g. used for\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\npointwise_constraint: Optional projection function to be applied to the\npointwise kernel after being updated by an Optimizer.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.max_pooling1d", "type": "function", "code": "tf.compat.v1.layers.max_pooling1d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Max Pooling layer for 1D inputs. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.max_pooling1d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 3."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nrepresenting the size of the pooling window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nstrides of the pooling operation."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.SeparableConv1D", "type": "class", "code": "tf.compat.v1.layers.SeparableConv1D(filters,kernel_size,strides=1,padding='valid',data_format='channels_last',dilation_rate=1,depth_multiplier=1,activation=None,use_bias=True,depthwise_initializer=None,pointwise_initializer=None,bias_initializer=tf.zeros_initializer(),depthwise_regularizer=None,pointwise_regularizer=None,bias_regularizer=None,activity_regularizer=None,depthwise_constraint=None,pointwise_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Depthwise separable 1D convolution.\n\nInherits From: SeparableConv1D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.SeparableConv1D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A single integer specifying the spatial\ndimensions of the filters."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer specifying the strides\nof the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "A single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1."}, {"name": "depth_multiplier", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of depthwise convolution output channels for\neach input channel. The total number of depthwise convolution output\nchannels will be equal to num_filters_in * depth_multiplier."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "depthwise_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the depthwise convolution kernel."}, {"name": "pointwise_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the pointwise convolution kernel."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "An initializer for the bias vector. If None, the default\ninitializer will be used.\ndepthwise_regularizer: Optional regularizer for the depthwise\nconvolution kernel.\npointwise_regularizer: Optional regularizer for the pointwise\nconvolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\ndepthwise_constraint: Optional projection function to be applied to the\ndepthwise kernel after being updated by an Optimizer (e.g. used for\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\npointwise_constraint: Optional projection function to be applied to the\npointwise kernel after being updated by an Optimizer.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.max_pooling3d", "type": "function", "code": "tf.compat.v1.layers.max_pooling3d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Max pooling layer for 3D inputs (e.g. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.max_pooling3d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 5."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers: (pool_depth, pool_height,\npool_width) specifying the size of the pooling window. Can be a single\ninteger to specify the same value for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the strides of\nthe pooling operation. Can be a single integer to specify the same value\nfor all spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape (batch, depth, height,\nwidth, channels) while channels_first corresponds to inputs with shape\n(batch, channels, depth, height, width)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.max_pooling2d", "type": "function", "code": "tf.compat.v1.layers.max_pooling2d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Max pooling layer for 2D inputs (e.g. images). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.max_pooling2d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 4."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers: (pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.MaxPooling3D", "type": "class", "code": "tf.compat.v1.layers.MaxPooling3D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Max pooling layer for 3D inputs (e.g. volumes).\n\nInherits From: MaxPool3D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.MaxPooling3D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers:\n(pool_depth, pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.MaxPooling2D", "type": "class", "code": "tf.compat.v1.layers.MaxPooling2D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Max pooling layer for 2D inputs (e.g. images).\n\nInherits From: MaxPool2D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.MaxPooling2D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers: (pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.Flatten", "type": "function", "code": "tf.compat.v1.layers.Flatten(data_format=None,**kwargs)", "summary": "Flattens an input tensor while preserving the batch axis (axis 0).\n\nInherits From: Flatten, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Flatten", "parameters": [{"name": "data_format", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.MaxPooling1D", "type": "class", "code": "tf.compat.v1.layers.MaxPooling1D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Max Pooling layer for 1D inputs.\n\nInherits From: MaxPool1D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.MaxPooling1D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nrepresenting the size of the pooling window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nstrides of the pooling operation."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.Layer", "type": "class", "code": "tf.compat.v1.layers.Layer(trainable=True,name=None,dtype=None,**kwargs)", "summary": "Base layer class.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Layer", "parameters": [{"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer's variables should be trainable."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "String name of the layer."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.flatten", "type": "function", "code": "tf.compat.v1.layers.flatten(inputs,name=None,data_format='channels_last')", "summary": "Flattens an input tensor while preserving the batch axis (axis 0). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.flatten", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the layer (string)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width)."}]}},
{"id": "tf.compat.v1.layers.dropout", "type": "function", "code": "tf.compat.v1.layers.dropout(inputs,rate=0.5,noise_shape=None,seed=None,training=False,name=None)", "summary": "Applies Dropout to the input. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.dropout", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "rate", "is_optional": true, "type": "others", "default_value": "0.5", "description": "The dropout rate, between 0 and 1. E.g. \"rate=0.1\" would drop out\n10% of input units."}, {"name": "noise_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "1D tensor of type int32 representing the shape of the\nbinary dropout mask that will be multiplied with the input.\nFor instance, if your inputs have shape\n(batch_size, timesteps, features), and you want the dropout mask\nto be the same for all timesteps, you can use\nnoise_shape=[batch_size, 1, features]."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "training", "is_optional": true, "type": "bool", "default_value": "False", "description": "Either a Python boolean, or a TensorFlow boolean scalar tensor\n(e.g. a placeholder). Whether to return the output in training mode\n(apply dropout) or in inference mode (return the input untouched)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the layer (string)."}]}},
{"id": "tf.compat.v1.layers.Conv3DTranspose", "type": "class", "code": "tf.compat.v1.layers.Conv3DTranspose(filters,kernel_size,strides=(1,1,1),padding='valid',data_format='channels_last',activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Transposed 3D convolution layer (sometimes called 3D Deconvolution).\n\nInherits From: Conv3DTranspose, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Conv3DTranspose", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the\ndepth, height and width of the 3D convolution window.\nCan be a single integer to specify the same value for all spatial\ndimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the strides\nof the convolution along the depth, height and width.\nCan be a single integer to specify the same value for all spatial\ndimensions.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width).\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.conv3d", "type": "function", "code": "tf.compat.v1.layers.conv3d(inputs,filters,kernel_size,strides=(1,1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1,1),activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for the 3D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.conv3d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the\ndepth, height and width of the 3D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the convolution along the depth,\nheight and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width).\ndilation_rate: An integer or tuple/list of 3 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.Conv3D", "type": "class", "code": "tf.compat.v1.layers.Conv3D(filters,kernel_size,strides=(1,1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1,1),activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "3D convolution layer (e.g. spatial convolution over volumes).\n\nInherits From: Conv3D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Conv3D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers, specifying the\ndepth, height and width of the 3D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the convolution along the depth,\nheight and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width).\ndilation_rate: An integer or tuple/list of 3 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.conv3d_transpose", "type": "function", "code": "tf.compat.v1.layers.conv3d_transpose(inputs,filters,kernel_size,strides=(1,1,1),padding='valid',data_format='channels_last',activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for transposed 3D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.conv3d_transpose", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A tuple or list of 3 positive integers specifying the spatial\ndimensions of the filters. Can be a single integer to specify the same\nvalue for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "A tuple or list of 3 positive integers specifying the strides\nof the convolution. Can be a single integer to specify the same value for\nall spatial dimensions.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width).\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.conv2d_transpose", "type": "function", "code": "tf.compat.v1.layers.conv2d_transpose(inputs,filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for transposed 2D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.conv2d_transpose", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Input tensor."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the spatial\ndimensions of the filters. Can be a single integer to specify the same\nvalue for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the strides\nof the convolution. Can be a single integer to specify the same value for\nall spatial dimensions.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.dense", "type": "function", "code": "tf.compat.v1.layers.dense(inputs,units,activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for the densely-connected layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.dense", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "units", "is_optional": false, "type": "int", "description": "Integer or Long, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function (callable). Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "kernel_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "Initializer function for the weight matrix.\nIf None (default), weights are initialized using the default\ninitializer used by tf.compat.v1.get_variable."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "Initializer function for the bias.\nkernel_regularizer: Regularizer function for the weight matrix.\nbias_regularizer: Regularizer function for the bias.\nactivity_regularizer: Regularizer function for the output.\nkernel_constraint: An optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: An optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: String, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.Dropout", "type": "class", "code": "tf.compat.v1.layers.Dropout(rate=0.5,noise_shape=None,seed=None,name=None,**kwargs)", "summary": "Applies Dropout to the input.\n\nInherits From: Dropout, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Dropout", "parameters": [{"name": "rate", "is_optional": true, "type": "others", "default_value": "0.5", "description": "The dropout rate, between 0 and 1. E.g. rate=0.1 would drop out\n10% of input units."}, {"name": "noise_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "1D tensor of type int32 representing the shape of the\nbinary dropout mask that will be multiplied with the input.\nFor instance, if your inputs have shape\n(batch_size, timesteps, features), and you want the dropout mask\nto be the same for all timesteps, you can use\nnoise_shape=[batch_size, 1, features]."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed.\nfor behavior."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.Dense", "type": "class", "code": "tf.compat.v1.layers.Dense(units,activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Densely-connected layer class.\n\nInherits From: Dense, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Dense", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Integer or Long, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function (callable). Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "kernel_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "Initializer function for the weight matrix.\nIf None (default), weights are initialized using the default\ninitializer used by tf.compat.v1.get_variable."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "Initializer function for the bias.\nkernel_regularizer: Regularizer function for the weight matrix.\nbias_regularizer: Regularizer function for the bias.\nactivity_regularizer: Regularizer function for the output.\nkernel_constraint: An optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: An optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: String, the name of the layer. Layers with the same name will\nshare weights, but to avoid mistakes we require reuse=True in such cases.\n_reuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.Conv2DTranspose", "type": "class", "code": "tf.compat.v1.layers.Conv2DTranspose(filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "Transposed 2D convolution layer (sometimes called 2D Deconvolution).\n\nInherits From: Conv2DTranspose, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Conv2DTranspose", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the spatial\ndimensions of the filters. Can be a single integer to specify the same\nvalue for all spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "A tuple or list of 2 positive integers specifying the strides\nof the convolution. Can be a single integer to specify the same value for\nall spatial dimensions.\npadding: one of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.conv2d", "type": "function", "code": "tf.compat.v1.layers.conv2d(inputs,filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1),activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for the 2D convolution layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.conv2d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\ndilation_rate: An integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.Conv2D", "type": "class", "code": "tf.compat.v1.layers.Conv2D(filters,kernel_size,strides=(1,1),padding='valid',data_format='channels_last',dilation_rate=(1,1),activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "2D convolution layer (e.g. spatial convolution over images).\n\nInherits From: Conv2D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Conv2D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers, specifying the\nheight and width of the 2D convolution window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the convolution along the height and width.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1.\npadding: One of \"valid\" or \"same\" (case-insensitive).\ndata_format: A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width).\ndilation_rate: An integer or tuple/list of 2 integers, specifying\nthe dilation rate to use for dilated convolution.\nCan be a single integer to specify the same value for\nall spatial dimensions.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any stride value != 1.\nactivation: Activation function. Set it to None to maintain a\nlinear activation.\nuse_bias: Boolean, whether the layer uses a bias.\nkernel_initializer: An initializer for the convolution kernel.\nbias_initializer: An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.conv1d", "type": "function", "code": "tf.compat.v1.layers.conv1d(inputs,filters,kernel_size,strides=1,padding='valid',data_format='channels_last',dilation_rate=1,activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None)", "summary": "Functional interface for 1D convolution layer (e.g. temporal convolution). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.conv1d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nlength of the 1D convolution window."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer,\nspecifying the stride length of the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any strides value != 1."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "kernel_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the convolution kernel."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name."}]}},
{"id": "tf.compat.v1.layers.Conv1D", "type": "class", "code": "tf.compat.v1.layers.Conv1D(filters,kernel_size,strides=1,padding='valid',data_format='channels_last',dilation_rate=1,activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,**kwargs)", "summary": "1D convolution layer (e.g. temporal convolution).\n\nInherits From: Conv1D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.Conv1D", "parameters": [{"name": "filters", "is_optional": false, "type": "int", "description": "Integer, the dimensionality of the output space (i.e. the number\nof filters in the convolution)."}, {"name": "kernel_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nlength of the 1D convolution window."}, {"name": "strides", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer,\nspecifying the stride length of the convolution.\nSpecifying any stride value != 1 is incompatible with specifying\nany dilation_rate value != 1."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "One of \"valid\" or \"same\" (case-insensitive)."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "dilation_rate", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer or tuple/list of a single integer, specifying\nthe dilation rate to use for dilated convolution.\nCurrently, specifying any dilation_rate value != 1 is\nincompatible with specifying any strides value != 1."}, {"name": "activation", "is_optional": true, "type": "others", "default_value": "None", "description": "Activation function. Set it to None to maintain a\nlinear activation."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias."}, {"name": "kernel_initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "An initializer for the convolution kernel."}, {"name": "bias_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "An initializer for the bias vector. If None, the default\ninitializer will be used.\nkernel_regularizer: Optional regularizer for the convolution kernel.\nbias_regularizer: Optional regularizer for the bias vector.\nactivity_regularizer: Optional regularizer function for the output.\nkernel_constraint: Optional projection function to be applied to the\nkernel after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\nbias_constraint: Optional projection function to be applied to the\nbias after being updated by an Optimizer.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.batch_normalization", "type": "function", "code": "tf.compat.v1.layers.batch_normalization(inputs,axis=-1,momentum=0.99,epsilon=0.001,center=True,scale=True,beta_initializer=tf.zeros_initializer(),gamma_initializer=tf.ones_initializer(),moving_mean_initializer=tf.zeros_initializer(),moving_variance_initializer=tf.ones_initializer(),beta_regularizer=None,gamma_regularizer=None,beta_constraint=None,gamma_constraint=None,training=False,trainable=True,name=None,reuse=None,renorm=False,renorm_clipping=None,renorm_momentum=0.99,fused=None,virtual_batch_size=None,adjustment=None)", "summary": "Functional interface for the batch normalization layer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.batch_normalization", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "Tensor input."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "An int, the axis that should be normalized (typically the features\naxis). For instance, after a Convolution2D layer with\ndata_format=\"channels_first\", set axis=1 in BatchNormalization."}, {"name": "momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum for the moving average."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "Small float added to variance to avoid dividing by zero."}, {"name": "center", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, add offset of beta to normalized tensor. If False, beta\nis ignored."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, multiply by gamma. If False, gamma is\nnot used. When the next layer is linear (also e.g. nn.relu), this can be\ndisabled since the scaling can be done by the next layer."}, {"name": "beta_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "Initializer for the beta weight.\ngamma_initializer: Initializer for the gamma weight.\nmoving_mean_initializer: Initializer for the moving mean.\nmoving_variance_initializer: Initializer for the moving variance.\nbeta_regularizer: Optional regularizer for the beta weight.\ngamma_regularizer: Optional regularizer for the gamma weight.\nbeta_constraint: An optional projection function to be applied to the beta\nweight after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\ngamma_constraint: An optional projection function to be applied to the\ngamma weight after being updated by an Optimizer.\ntraining: Either a Python boolean, or a TensorFlow boolean scalar tensor\n(e.g. a placeholder). Whether to return the output in training mode\n(normalized with statistics of the current batch) or in inference mode\n(normalized with moving statistics). NOTE: make sure to set this\nparameter correctly, or else your training/inference will not work\nproperly.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nname: String, the name of the layer.\nreuse: Boolean, whether to reuse the weights of a previous layer\nby the same name.\nrenorm: Whether to use Batch Renormalization\n(https://arxiv.org/abs/1702.03275). This adds extra variables during\ntraining. The inference is the same for either value of this parameter.\nrenorm_clipping: A dictionary that may map keys 'rmax', 'rmin', 'dmax' to\nscalar Tensors used to clip the renorm correction. The correction\n(r, d) is used as corrected_value = normalized_value * r + d, with\nr clipped to [rmin, rmax], and d to [-dmax, dmax]. Missing rmax, rmin,\ndmax are set to inf, 0, inf, respectively.\nrenorm_momentum: Momentum used to update the moving means and standard\ndeviations with renorm. Unlike momentum, this affects training\nand should be neither too small (which would add noise) nor too large\n(which would give stale estimates). Note that momentum is still applied\nto get the means and variances for inference.\nfused: if None or True, use a faster, fused implementation if possible.\nIf False, use the system recommended implementation.\nvirtual_batch_size: An int. By default, virtual_batch_size is None,\nwhich means batch normalization is performed across the whole batch. When\nvirtual_batch_size is not None, instead perform \"Ghost Batch\nNormalization\", which creates virtual sub-batches which are each\nnormalized separately (with shared gamma, beta, and moving statistics).\nMust divide the actual batch size during execution.\nadjustment: A function taking the Tensor containing the (dynamic) shape of\nthe input tensor and returning a pair (scale, bias) to apply to the\nnormalized values (before gamma and beta), only during training. For\nexample, if axis==-1,\nadjustment = lambda shape: (\n  tf.random.uniform(shape[-1:], 0.93, 1.07),\n  tf.random.uniform(shape[-1:], -0.1, 0.1))\nwill scale the normalized value by up to 7% up or down, then shift the\nresult by up to 0.1 (with independent scaling and bias for each feature\nbut shared across all examples), and finally apply gamma and/or beta. If\nNone, no adjustment is applied. Cannot be specified if\nvirtual_batch_size is specified."}]}},
{"id": "tf.compat.v1.layers.BatchNormalization", "type": "class", "code": "tf.compat.v1.layers.BatchNormalization(axis=-1,momentum=0.99,epsilon=0.001,center=True,scale=True,beta_initializer=tf.zeros_initializer(),gamma_initializer=tf.ones_initializer(),moving_mean_initializer=tf.zeros_initializer(),moving_variance_initializer=tf.ones_initializer(),beta_regularizer=None,gamma_regularizer=None,beta_constraint=None,gamma_constraint=None,renorm=False,renorm_clipping=None,renorm_momentum=0.99,fused=None,trainable=True,virtual_batch_size=None,adjustment=None,name=None,**kwargs)", "summary": "Batch Normalization layer from http://arxiv.org/abs/1502.03167.\n\nInherits From: BatchNormalization, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.BatchNormalization", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "An int or list of int, the axis or axes that should be\nnormalized, typically the features axis/axes. For instance, after a\nConv2D layer with data_format=\"channels_first\", set axis=1. If a\nlist of axes is provided, each axis in axis will be normalized\nsimultaneously. Default is -1 which uses the last axis. Note: when\nusing multi-axis batch norm, the beta, gamma, moving_mean, and\nmoving_variance variables are the same rank as the input Tensor, with\ndimension size 1 in all reduced (non-axis) dimensions)."}, {"name": "momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum for the moving average."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "Small float added to variance to avoid dividing by zero."}, {"name": "center", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, add offset of beta to normalized tensor. If False, beta\nis ignored."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, multiply by gamma. If False, gamma is\nnot used. When the next layer is linear (also e.g. nn.relu), this can be\ndisabled since the scaling can be done by the next layer."}, {"name": "beta_initializer", "is_optional": true, "type": "others", "default_value": "tf.zeros_initialize", "description": "Initializer for the beta weight.\ngamma_initializer: Initializer for the gamma weight.\nmoving_mean_initializer: Initializer for the moving mean.\nmoving_variance_initializer: Initializer for the moving variance.\nbeta_regularizer: Optional regularizer for the beta weight.\ngamma_regularizer: Optional regularizer for the gamma weight.\nbeta_constraint: An optional projection function to be applied to the beta\nweight after being updated by an Optimizer (e.g. used to implement\nnorm constraints or value constraints for layer weights). The function\nmust take as input the unprojected variable and must return the\nprojected variable (which must have the same shape). Constraints are\nnot safe to use when doing asynchronous distributed training.\ngamma_constraint: An optional projection function to be applied to the\ngamma weight after being updated by an Optimizer.\nrenorm: Whether to use Batch Renormalization\n(https://arxiv.org/abs/1702.03275). This adds extra variables during\ntraining. The inference is the same for either value of this parameter.\nrenorm_clipping: A dictionary that may map keys 'rmax', 'rmin', 'dmax' to\nscalar Tensors used to clip the renorm correction. The correction\n(r, d) is used as corrected_value = normalized_value * r + d, with\nr clipped to [rmin, rmax], and d to [-dmax, dmax]. Missing rmax, rmin,\ndmax are set to inf, 0, inf, respectively.\nrenorm_momentum: Momentum used to update the moving means and standard\ndeviations with renorm. Unlike momentum, this affects training\nand should be neither too small (which would add noise) nor too large\n(which would give stale estimates). Note that momentum is still applied\nto get the means and variances for inference.\nfused: if None or True, use a faster, fused implementation if possible.\nIf False, use the system recommended implementation.\ntrainable: Boolean, if True also add variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable).\nvirtual_batch_size: An int. By default, virtual_batch_size is None,\nwhich means batch normalization is performed across the whole batch. When\nvirtual_batch_size is not None, instead perform \"Ghost Batch\nNormalization\", which creates virtual sub-batches which are each\nnormalized separately (with shared gamma, beta, and moving statistics).\nMust divide the actual batch size during execution.\nadjustment: A function taking the Tensor containing the (dynamic) shape of\nthe input tensor and returning a pair (scale, bias) to apply to the\nnormalized values (before gamma and beta), only during training. For\nexample, if axis==-1,\nadjustment = lambda shape: (\n  tf.random.uniform(shape[-1:], 0.93, 1.07),\n  tf.random.uniform(shape[-1:], -0.1, 0.1))\nwill scale the normalized value by up to 7% up or down, then shift the\nresult by up to 0.1 (with independent scaling and bias for each feature\nbut shared across all examples), and finally apply gamma and/or beta. If\nNone, no adjustment is applied. Cannot be specified if\nvirtual_batch_size is specified.\nname: A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.average_pooling3d", "type": "function", "code": "tf.compat.v1.layers.average_pooling3d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Average pooling layer for 3D inputs (e.g. volumes). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.average_pooling3d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 5."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers:\n(pool_depth, pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.average_pooling2d", "type": "function", "code": "tf.compat.v1.layers.average_pooling2d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Average pooling layer for 2D inputs (e.g. images). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.average_pooling2d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 4."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers: (pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.average_pooling1d", "type": "function", "code": "tf.compat.v1.layers.average_pooling1d(inputs,pool_size,strides,padding='valid',data_format='channels_last',name=None)", "summary": "Average Pooling layer for 1D inputs. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.layers.average_pooling1d", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "The tensor over which to pool. Must have rank 3."}, {"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nrepresenting the size of the pooling window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nstrides of the pooling operation."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the layer."}]}},
{"id": "tf.compat.v1.layers.AveragePooling3D", "type": "class", "code": "tf.compat.v1.layers.AveragePooling3D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Average pooling layer for 3D inputs (e.g. volumes).\n\nInherits From: AveragePooling3D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.AveragePooling3D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers:\n(pool_depth, pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 3 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, depth, height, width, channels) while channels_first\ncorresponds to inputs with shape\n(batch, channels, depth, height, width)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.AveragePooling2D", "type": "class", "code": "tf.compat.v1.layers.AveragePooling2D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Average pooling layer for 2D inputs (e.g. images).\n\nInherits From: AveragePooling2D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.AveragePooling2D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers: (pool_height, pool_width)\nspecifying the size of the pooling window.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of 2 integers,\nspecifying the strides of the pooling operation.\nCan be a single integer to specify the same value for\nall spatial dimensions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string. The ordering of the dimensions in the inputs.\nchannels_last (default) and channels_first are supported.\nchannels_last corresponds to inputs with shape\n(batch, height, width, channels) while channels_first corresponds to\ninputs with shape (batch, channels, height, width)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.layers.AveragePooling1D", "type": "class", "code": "tf.compat.v1.layers.AveragePooling1D(pool_size,strides,padding='valid',data_format='channels_last',name=None,**kwargs)", "summary": "Average Pooling layer for 1D inputs.\n\nInherits From: AveragePooling1D, Layer", "description": "", "code-info": {"name": "tf.compat.v1.layers.AveragePooling1D", "parameters": [{"name": "pool_size", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer,\nrepresenting the size of the pooling window."}, {"name": "strides", "is_optional": false, "type": "int", "description": "An integer or tuple/list of a single integer, specifying the\nstrides of the pooling operation."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "'valid'", "description": "A string. The padding method, either 'valid' or 'same'.\nCase-insensitive."}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'channels_last'", "description": "A string, one of channels_last (default) or channels_first.\nThe ordering of the dimensions in the inputs.\nchannels_last corresponds to inputs with shape\n(batch, length, channels) while channels_first corresponds to\ninputs with shape (batch, channels, length)."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.experimental.preprocessing.TextVectorization", "type": "function", "code": "tf.compat.v1.keras.layers.experimental.preprocessing.TextVectorization(max_tokens=None,standardize=LOWER_AND_STRIP_PUNCTUATION,split=SPLIT_ON_WHITESPACE,ngrams=None,output_mode=INT,output_sequence_length=None,pad_to_max_tokens=True,**kwargs)", "summary": "Text vectorization layer.\n\nInherits From: TextVectorization", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.TextVectorization", "parameters": [{"name": "max_tokens", "is_optional": true, "type": "others", "default_value": "None", "description": "The maximum size of the vocabulary for this layer. If None,\nthere is no cap on the size of the vocabulary."}, {"name": "standardize", "is_optional": true, "type": "others", "default_value": "LOWER_AND_STRIP_PUNCTUATION", "description": "Optional specification for standardization to apply to the\ninput text. Values can be None (no standardization),\nLOWER_AND_STRIP_PUNCTUATION (lowercase and remove punctuation) or a\nCallable."}, {"name": "split", "is_optional": true, "type": "others", "default_value": "SPLIT_ON_WHITESPACE", "description": "Optional specification for splitting the input text. Values can be\nNone (no splitting), SPLIT_ON_WHITESPACE (split on ASCII whitespace), or a\nCallable."}, {"name": "ngrams", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional specification for ngrams to create from the possibly-split\ninput text. Values can be None, an integer or tuple of integers; passing\nan integer will create ngrams up to that integer, and passing a tuple of\nintegers will create ngrams for the specified values in the tuple. Passing\nNone means that no ngrams will be created."}, {"name": "output_mode", "is_optional": true, "type": "others", "default_value": "INT", "description": "Optional specification for the output of the layer. Values can\nbe INT, BINARY, COUNT or TFIDF, which control the outputs as follows:\nINT: Outputs integer indices, one integer index per split string token.\nBINARY: Outputs a single int array per batch, of either vocab_size or\n  max_tokens size, containing 1s in all elements where the token mapped\n  to that index exists at least once in the batch item.\nCOUNT: As BINARY, but the int array contains a count of the number of\n  times the token at that index appeared in the batch item.\nTFIDF: As BINARY, but the TF-IDF algorithm is applied to find the value\n  in each token slot."}, {"name": "output_sequence_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional length for the output tensor. If set,\nthe output will be padded or truncated to this value in INT mode."}, {"name": "pad_to_max_tokens", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.experimental.preprocessing.Normalization", "type": "function", "code": "tf.compat.v1.keras.layers.experimental.preprocessing.Normalization(axis=-1,dtype=None,**kwargs)", "summary": "Feature-wise normalization of the data.\n\nInherits From: Normalization", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.Normalization", "parameters": [{"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": ""}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.LSTMCell", "type": "function", "code": "tf.compat.v1.keras.layers.LSTMCell(units,activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=1,**kwargs)", "summary": "Cell class for the LSTM layer.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.LSTMCell", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'hard_sigmoid'", "description": "Activation function to use\nfor the recurrent step.\nDefault: hard sigmoid (hard_sigmoid).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix,\nused for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean.\nIf True, add 1 to the bias of the forget gate at initialization.\nSetting it to true will also force bias_initializer=\"zeros\".\nThis is recommended in Jozefowicz et\nal."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe kernel weights matrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the inputs."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the recurrent state."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.CuDNNLSTM", "type": "class", "code": "tf.compat.v1.keras.layers.CuDNNLSTM(units,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,return_sequences=False,return_state=False,go_backwards=False,stateful=False,**kwargs)", "summary": "Fast LSTM implementation backed by cuDNN.", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.CuDNNLSTM", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix, used for\nthe linear transformation of the inputs.\nunit_forget_bias: Boolean. If True, add 1 to the bias of the forget gate\nat initialization. Setting it to true will also force\nbias_initializer=\"zeros\". This is recommended in Jozefowicz et\nal."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel weights\nmatrix, used for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector.\nkernel_regularizer: Regularizer function applied to the kernel weights\nmatrix.\nrecurrent_regularizer: Regularizer function applied to the\nrecurrent_kernel weights matrix.\nbias_regularizer: Regularizer function applied to the bias vector.\nactivity_regularizer: Regularizer function applied to the output of the\nlayer (its \"activation\").\nkernel_constraint: Constraint function applied to the kernel weights\nmatrix.\nrecurrent_constraint: Constraint function applied to the\nrecurrent_kernel weights matrix.\nbias_constraint: Constraint function applied to the bias vector.\nreturn_sequences: Boolean. Whether to return the last output. in the\noutput sequence, or the full sequence.\nreturn_state: Boolean. Whether to return the last state in addition to the\noutput.\ngo_backwards: Boolean (default False). If True, process the input sequence\nbackwards and return the reversed sequence.\nstateful: Boolean (default False). If True, the last state for each sample\nat index i in a batch will be used as initial state for the sample of\nindex i in the following batch.\n\n\nAttributes:\n\n\ncell\nstates\n\n\nMethods\n\nreset_states\n\nView source\nreset_states(\n    states=None\n)\n\nReset the recorded states for the stateful RNN layer.\n\nCan only be used when RNN layer is constructed with stateful = True.\nArgs:\n  states: Numpy arrays that contains the value for the initial state, which\n    will be feed to cell at the first time step. When the value is None,\n    zero filled numpy array will be created based on the cell state size.\n\nRaises:\n\n\nAttributeError: When the RNN layer is not stateful.\nValueError: When the batch size of the RNN layer is unknown.\nValueError: When the input numpy array is not compatible with the RNN\nlayer state, either size wise or dtype wise.\n\n\n          "}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean. If True, add 1 to the bias of the forget gate\nat initialization. Setting it to true will also force\nbias_initializer=\"zeros\". This is recommended in Jozefowicz et\nal.\nrecurrent_initializer: Initializer for the recurrent_kernel weights\nmatrix, used for the linear transformation of the recurrent state.\nbias_initializer: Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the output of the\nlayer (its \"activation\")."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the\nrecurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output. in the\noutput sequence, or the full sequence."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state in addition to the\noutput."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, process the input sequence\nbackwards and return the reversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.CuDNNGRU", "type": "class", "code": "tf.compat.v1.keras.layers.CuDNNGRU(units,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,return_sequences=False,return_state=False,go_backwards=False,stateful=False,**kwargs)", "summary": "Fast GRU implementation backed by cuDNN.", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.CuDNNGRU", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix, used for\nthe linear transformation of the inputs."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel weights\nmatrix, used for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the kernel weights\nmatrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the\nrecurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the output of the\nlayer (its \"activation\")."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the kernel weights\nmatrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the\nrecurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output in the output\nsequence, or the full sequence."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state in addition to the\noutput."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, process the input sequence\nbackwards and return the reversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.BatchNormalization", "type": "function", "code": "tf.compat.v1.keras.layers.BatchNormalization(axis=-1,momentum=0.99,epsilon=0.001,center=True,scale=True,beta_initializer='zeros',gamma_initializer='ones',moving_mean_initializer='zeros',moving_variance_initializer='ones',beta_regularizer=None,gamma_regularizer=None,beta_constraint=None,gamma_constraint=None,renorm=False,renorm_clipping=None,renorm_momentum=0.99,fused=None,trainable=True,virtual_batch_size=None,adjustment=None,name=None,**kwargs)", "summary": "Normalize and scale inputs or activations. (Ioffe and Szegedy, 2014).", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.BatchNormalization", "parameters": [{"name": "axis", "is_optional": true, "type": "int", "default_value": "-1", "description": "Integer, the axis that should be normalized\n(typically the features axis).\nFor instance, after a Conv2D layer with\ndata_format=\"channels_first\",\nset axis=1 in BatchNormalization."}, {"name": "momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum for the moving average."}, {"name": "epsilon", "is_optional": true, "type": "float", "default_value": "0.001", "description": "Small float added to variance to avoid dividing by zero."}, {"name": "center", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, add offset of beta to normalized tensor.\nIf False, beta is ignored."}, {"name": "scale", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, multiply by gamma.\nIf False, gamma is not used.\nWhen the next layer is linear (also e.g. nn.relu),\nthis can be disabled since the scaling\nwill be done by the next layer."}, {"name": "beta_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the beta weight."}, {"name": "gamma_initializer", "is_optional": true, "type": "string", "default_value": "'ones'", "description": "Initializer for the gamma weight."}, {"name": "moving_mean_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the moving mean."}, {"name": "moving_variance_initializer", "is_optional": true, "type": "string", "default_value": "'ones'", "description": "Initializer for the moving variance."}, {"name": "beta_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the beta weight."}, {"name": "gamma_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional regularizer for the gamma weight."}, {"name": "beta_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the beta weight."}, {"name": "gamma_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional constraint for the gamma weight."}, {"name": "renorm", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to use Batch Renormalization\n(https://arxiv.org/abs/1702.03275). This adds extra variables during\ntraining. The inference is the same for either value of this parameter."}, {"name": "renorm_clipping", "is_optional": true, "type": "others", "default_value": "None", "description": "A dictionary that may map keys 'rmax', 'rmin', 'dmax' to\nscalar Tensors used to clip the renorm correction. The correction\n(r, d) is used as corrected_value = normalized_value * r + d, with\nr clipped to [rmin, rmax], and d to [-dmax, dmax]. Missing rmax, rmin,\ndmax are set to inf, 0, inf, respectively."}, {"name": "renorm_momentum", "is_optional": true, "type": "others", "default_value": "0.99", "description": "Momentum used to update the moving means and standard\ndeviations with renorm. Unlike momentum, this affects training\nand should be neither too small (which would add noise) nor too large\n(which would give stale estimates). Note that momentum is still applied\nto get the means and variances for inference."}, {"name": "fused", "is_optional": true, "type": "others", "default_value": "None", "description": "if None or True, use a faster, fused implementation if possible.\nIf False, use the system recommended implementation."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, if True the variables will be marked as trainable."}, {"name": "virtual_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. By default, virtual_batch_size is None,\nwhich means batch normalization is performed across the whole batch. When\nvirtual_batch_size is not None, instead perform \"Ghost Batch\nNormalization\", which creates virtual sub-batches which are each\nnormalized separately (with shared gamma, beta, and moving statistics).\nMust divide the actual batch size during execution."}, {"name": "adjustment", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.LSTM", "type": "class", "code": "tf.compat.v1.keras.layers.LSTM(units,activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',unit_forget_bias=True,kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=1,return_sequences=False,return_state=False,go_backwards=False,stateful=False,unroll=False,**kwargs)", "summary": "Long Short-Term Memory layer - Hochreiter 1997.\n\nInherits From: RNN", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.LSTM", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'hard_sigmoid'", "description": "Activation function to use\nfor the recurrent step.\nDefault: hard sigmoid (hard_sigmoid).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs.."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix,\nused for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "unit_forget_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean.\nIf True, add 1 to the bias of the forget gate at initialization.\nSetting it to true will also force bias_initializer=\"zeros\".\nThis is recommended in Jozefowicz et\nal.."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe output of the layer (its \"activation\").."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe kernel weights matrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the inputs."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the recurrent state."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": "Implementation mode, either 1 or 2.\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions, whereas mode 2 will\nbatch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output.\nin the output sequence, or the full sequence."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state\nin addition to the output."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, process the input sequence backwards and return the\nreversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.GRUCell", "type": "function", "code": "tf.compat.v1.keras.layers.GRUCell(units,activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=1,reset_after=False,**kwargs)", "summary": "Cell class for the GRU layer.\n\nInherits From: Layer", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.GRUCell", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'hard_sigmoid'", "description": "Activation function to use\nfor the recurrent step.\nDefault: hard sigmoid (hard_sigmoid).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix,\nused for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe kernel weights matrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for the linear transformation of the inputs."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the recurrent state."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": "Implementation mode, either 1 or 2.\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions, whereas mode 2 will\nbatch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications."}, {"name": "reset_after", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.GRU", "type": "class", "code": "tf.compat.v1.keras.layers.GRU(units,activation='tanh',recurrent_activation='hard_sigmoid',use_bias=True,kernel_initializer='glorot_uniform',recurrent_initializer='orthogonal',bias_initializer='zeros',kernel_regularizer=None,recurrent_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,recurrent_constraint=None,bias_constraint=None,dropout=0.0,recurrent_dropout=0.0,implementation=1,return_sequences=False,return_state=False,go_backwards=False,stateful=False,unroll=False,reset_after=False,**kwargs)", "summary": "Gated Recurrent Unit - Cho et al. 2014.\n\nInherits From: RNN", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.GRU", "parameters": [{"name": "units", "is_optional": false, "type": "int", "description": "Positive integer, dimensionality of the output space."}, {"name": "activation", "is_optional": true, "type": "string", "default_value": "'tanh'", "description": "Activation function to use.\nDefault: hyperbolic tangent (tanh).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "recurrent_activation", "is_optional": true, "type": "string", "default_value": "'hard_sigmoid'", "description": "Activation function to use\nfor the recurrent step.\nDefault: hard sigmoid (hard_sigmoid).\nIf you pass None, no activation is applied\n(ie. \"linear\" activation: a(x) = x)."}, {"name": "use_bias", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean, whether the layer uses a bias vector."}, {"name": "kernel_initializer", "is_optional": true, "type": "string", "default_value": "'glorot_uniform'", "description": "Initializer for the kernel weights matrix,\nused for the linear transformation of the inputs."}, {"name": "recurrent_initializer", "is_optional": true, "type": "string", "default_value": "'orthogonal'", "description": "Initializer for the recurrent_kernel\nweights matrix, used for the linear transformation of the recurrent state."}, {"name": "bias_initializer", "is_optional": true, "type": "string", "default_value": "'zeros'", "description": "Initializer for the bias vector."}, {"name": "kernel_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe kernel weights matrix."}, {"name": "recurrent_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to the bias vector."}, {"name": "activity_regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "Regularizer function applied to\nthe output of the layer (its \"activation\").."}, {"name": "kernel_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe kernel weights matrix."}, {"name": "recurrent_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to\nthe recurrent_kernel weights matrix."}, {"name": "bias_constraint", "is_optional": true, "type": "string", "default_value": "None", "description": "Constraint function applied to the bias vector."}, {"name": "dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the inputs."}, {"name": "recurrent_dropout", "is_optional": true, "type": "float", "default_value": "0.0", "description": "Float between 0 and 1.\nFraction of the units to drop for\nthe linear transformation of the recurrent state."}, {"name": "implementation", "is_optional": true, "type": "int", "default_value": "1", "description": "Implementation mode, either 1 or 2.\nMode 1 will structure its operations as a larger number of\nsmaller dot products and additions, whereas mode 2 will\nbatch them into fewer, larger operations. These modes will\nhave different performance profiles on different hardware and\nfor different applications."}, {"name": "return_sequences", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last output\nin the output sequence, or the full sequence."}, {"name": "return_state", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean. Whether to return the last state\nin addition to the output."}, {"name": "go_backwards", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, process the input sequence backwards and return the\nreversed sequence."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False). If True, the last state\nfor each sample at index i in a batch will be used as initial\nstate for the sample of index i in the following batch."}, {"name": "unroll", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean (default False).\nIf True, the network will be unrolled,\nelse a symbolic loop will be used.\nUnrolling can speed-up a RNN,\nalthough it tends to be more memory-intensive.\nUnrolling is only suitable for short sequences.\ntime_major: The shape format of the inputs and outputs tensors.\nIf True, the inputs and outputs will be in shape\n(timesteps, batch, ...), whereas in the False case, it will be\n(batch, timesteps, ...). Using time_major = True is a bit more\nefficient because it avoids transposes at the beginning and end of the\nRNN calculation. However, most TensorFlow data is batch-major, so by\ndefault this function accepts input and emits output in batch-major\nform."}, {"name": "reset_after", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.keras.layers.DenseFeatures", "type": "function", "code": "tf.compat.v1.keras.layers.DenseFeatures(feature_columns,trainable=True,name=None,**kwargs)", "summary": "A layer that produces a dense Tensor based on given feature_columns.", "description": "", "code-info": {"name": "tf.compat.v1.keras.layers.DenseFeatures", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns to use as\ninputs to your model. All items should be instances of classes derived\nfrom DenseColumn such as numeric_column, embedding_column,\nbucketized_column, indicator_column. If you have categorical\nfeatures, you can wrap them with an embedding_column or\nindicator_column."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": " Boolean, whether the layer's variables will be updated via\ngradient descent during training."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name to give to the DenseFeatures."}, {"name": "**kwargs", "is_optional": false, "type": "string", "description": "Keyword arguments to construct a layer."}]}},
{"id": "tf.compat.v1.keras.initializers.Zeros", "type": "function", "code": "tf.compat.v1.keras.initializers.Zeros(dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors initialized to 0.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.Zeros", "parameters": [{"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "Optional dtype of the tensor. If not provided use the initializer\ndtype.\npartition_info: Optional information about the possible partitioning of a\ntensor."}]}},
{"id": "tf.compat.v1.keras.initializers.VarianceScaling", "type": "function", "code": "tf.compat.v1.keras.initializers.VarianceScaling(scale=1.0,mode='fan_in',distribution='truncated_normal',seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer capable of adapting its scale to the shape of weights tensors.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.VarianceScaling", "parameters": [{"name": "scale", "is_optional": true, "type": "float", "default_value": "1.0", "description": "Scaling factor (positive float)."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'fan_in'", "description": "One of \"fan_in\", \"fan_out\", \"fan_avg\"."}, {"name": "distribution", "is_optional": true, "type": "string", "default_value": "'truncated_normal'", "description": "Random distribution to use. One of \"normal\", \"uniform\"."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.initializers.RandomUniform", "type": "function", "code": "tf.compat.v1.keras.initializers.RandomUniform(minval=-0.05,maxval=0.05,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors with a uniform distribution.\n\nInherits From: random_uniform_initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.RandomUniform", "parameters": [{"name": "minval", "is_optional": true, "type": "tensor", "default_value": "-0.05", "description": "A python scalar or a scalar tensor. Lower bound of the range of\nrandom values to generate. Defaults to -0.05."}, {"name": "maxval", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "A python scalar or a scalar tensor. Upper bound of the range of\nrandom values to generate. Defaults to 0.05."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "The data type."}]}},
{"id": "tf.compat.v1.keras.initializers.RandomNormal", "type": "function", "code": "tf.compat.v1.keras.initializers.RandomNormal(mean=0.0,stddev=0.05,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors with a normal distribution.\n\nInherits From: random_normal_initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.RandomNormal", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values to\ngenerate. Defaults to 0."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "a python scalar or a scalar tensor. Standard deviation of the random\nvalues to generate. Defaults to 0.05."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The data type. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.initializers.Ones", "type": "function", "code": "tf.compat.v1.keras.initializers.Ones(dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors initialized to 1.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.Ones", "parameters": [{"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "Optional dtype of the tensor. If not provided use the initializer\ndtype.\npartition_info: Optional information about the possible partitioning of a\ntensor."}]}},
{"id": "tf.compat.v1.keras.initializers.lecun_uniform", "type": "function", "code": "tf.compat.v1.keras.initializers.lecun_uniform(seed=None)", "summary": "LeCun uniform initializer.", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.lecun_uniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.compat.v1.keras.initializers.lecun_normal", "type": "function", "code": "tf.compat.v1.keras.initializers.lecun_normal(seed=None)", "summary": "LeCun normal initializer.", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.lecun_normal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.compat.v1.keras.initializers.TruncatedNormal", "type": "function", "code": "tf.compat.v1.keras.initializers.TruncatedNormal(mean=0.0,stddev=0.05,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates a truncated normal distribution.\n\nInherits From: truncated_normal_initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.TruncatedNormal", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values to\ngenerate. Defaults to 0."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "a python scalar or a scalar tensor. Standard deviation of the random\nvalues to generate. Defaults to 0.05."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The data type. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.initializers.Orthogonal", "type": "function", "code": "tf.compat.v1.keras.initializers.Orthogonal(gain=1.0,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates an orthogonal matrix.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.Orthogonal", "parameters": [{"name": "gain", "is_optional": true, "type": "others", "default_value": "1.0", "description": "multiplicative factor to apply to the orthogonal matrix"}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.initializers.Identity", "type": "function", "code": "tf.compat.v1.keras.initializers.Identity(gain=1.0,dtype=tf.dtypes.float32)", "summary": "Initializer that generates the identity matrix.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.Identity", "parameters": [{"name": "gain", "is_optional": true, "type": "others", "default_value": "1.0", "description": "Multiplicative factor to apply to the identity matrix."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.initializers.he_uniform", "type": "function", "code": "tf.compat.v1.keras.initializers.he_uniform(seed=None)", "summary": "He uniform variance scaling initializer.", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.he_uniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.compat.v1.keras.initializers.he_normal", "type": "function", "code": "tf.compat.v1.keras.initializers.he_normal(seed=None)", "summary": "He normal initializer.", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.he_normal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to seed the random generator."}]}},
{"id": "tf.compat.v1.keras.initializers.glorot_uniform", "type": "function", "code": "tf.compat.v1.keras.initializers.glorot_uniform(seed=None,dtype=tf.dtypes.float32)", "summary": "The Glorot uniform initializer, also called Xavier uniform initializer.\n\nInherits From: VarianceScaling", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.glorot_uniform", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "__call__", "type": "function", "code": "__call__(shape,dtype=None,partition_info=None)", "summary": "Initializer base class: all initializers inherit from this class.\n\n\n\nMethods\n\n__call__\n\nView source\n__call__(\n    shape, dtype=None, partition_info=None\n)\n\nReturns a tensor object initialized as specified by the initializer.\n\nArgs:\n\n\nshape: Shape of the tensor.\ndtype: Optional dtype of the tensor. If not provided use the initializer\ndtype.\npartition_info: Optional information about the possible partitioning of a\ntensor.\n\n\nfrom_config\n\nView source\n@classmethod\nfrom_config(\n    cls, config\n)\n\nInstantiates an initializer from a configuration dictionary.\n\nExample:\ninitializer = RandomUniform(-1, 1)\nconfig = initializer.get_config()\ninitializer = RandomUniform.from_config(config)\n\nArgs:\n\n\nconfig: A Python dictionary. It will typically be the output of\nget_config.\n\n\nReturns:\n\nAn Initializer instance.\n\nget_config\n\nView source\nget_config()\n\nReturns the configuration of the initializer as a JSON-serializable dict.\n\nReturns:\n\nA JSON-serializable Python dict.", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "Shape of the tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional dtype of the tensor. If not provided use the initializer\ndtype."}, {"name": "partition_info", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional information about the possible partitioning of a\ntensor."}]}},
{"id": "tf.compat.v1.keras.experimental.load_from_saved_model", "type": "function", "code": "tf.compat.v1.keras.experimental.load_from_saved_model(saved_model_path,custom_objects=None)", "summary": "Loads a keras Model from a SavedModel created by export_saved_model(). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.keras.experimental.load_from_saved_model", "parameters": [{"name": "saved_model_path", "is_optional": false, "type": "string", "description": "a string specifying the path to an existing SavedModel."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping names\n(strings) to custom classes or functions to be\nconsidered during deserialization."}]}},
{"id": "tf.compat.v1.keras.estimator.model_to_estimator", "type": "function", "code": "tf.compat.v1.keras.estimator.model_to_estimator(keras_model=None,keras_model_path=None,custom_objects=None,model_dir=None,config=None,checkpoint_format='saver')", "summary": "Constructs an Estimator instance from given keras model.", "description": "", "code-info": {"name": "tf.compat.v1.keras.estimator.model_to_estimator", "parameters": [{"name": "keras_model", "is_optional": true, "type": "others", "default_value": "None", "description": "A compiled Keras model object. This argument is mutually\nexclusive with keras_model_path."}, {"name": "keras_model_path", "is_optional": true, "type": "others", "default_value": "None", "description": "Path to a compiled Keras model saved on disk, in HDF5\nformat, which can be generated with the save() method of a Keras model.\nThis argument is mutually exclusive with keras_model."}, {"name": "custom_objects", "is_optional": true, "type": "others", "default_value": "None", "description": "Dictionary for custom objects."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save Estimator model parameters, graph, summary\nfiles for TensorBoard, etc."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig to config Estimator."}, {"name": "checkpoint_format", "is_optional": true, "type": "string", "default_value": "'saver'", "description": "Sets the format of the checkpoint saved by the estimator\nwhen training. May be saver or checkpoint, depending on whether to\nsave checkpoints from tf.train.Saver or tf.train.Checkpoint. This\nargument currently defaults to saver. When 2.0 is released, the default\nwill be checkpoint. Estimators use name-based tf.train.Saver\ncheckpoints, while Keras models use object-based checkpoints from\ntf.train.Checkpoint. Currently, saving object-based checkpoints from\nmodel_to_estimator is only supported by Functional and Sequential\nmodels."}]}},
{"id": "tf.compat.v1.keras.initializers.Constant", "type": "function", "code": "tf.compat.v1.keras.initializers.Constant(value=0,dtype=tf.dtypes.float32,verify_shape=False)", "summary": "Initializer that generates tensors with constant values.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.Constant", "parameters": [{"name": "value", "is_optional": true, "type": "int", "default_value": "0", "description": "A Python scalar, list or tuple of values, or a N-dimensional numpy\narray. All elements of the initialized variable will be set to the\ncorresponding value in the value argument."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer."}, {"name": "verify_shape", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean that enables verification of the shape of value. If\nTrue, the initializer will throw an error if the shape of value is not\ncompatible with the shape of the initialized tensor."}]}},
{"id": "tf.compat.v1.keras.initializers.glorot_normal", "type": "function", "code": "tf.compat.v1.keras.initializers.glorot_normal(seed=None,dtype=tf.dtypes.float32)", "summary": "The Glorot normal initializer, also called Xavier normal initializer.\n\nInherits From: VarianceScaling", "description": "", "code-info": {"name": "tf.compat.v1.keras.initializers.glorot_normal", "parameters": [{"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.keras.experimental.export_saved_model", "type": "function", "code": "tf.compat.v1.keras.experimental.export_saved_model(model,saved_model_path,custom_objects=None,as_text=False,input_signature=None,serving_only=False)", "summary": "Exports a tf.keras.Model as a Tensorflow SavedModel. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.keras.experimental.export_saved_model", "parameters": [{"name": "model", "is_optional": false, "type": "others", "description": "A tf.keras.Model to be saved. If the model is subclassed, the flag\nserving_only must be set to True."}, {"name": "saved_model_path", "is_optional": false, "type": "string", "description": "a string specifying the path to the SavedModel directory."}, {"name": "custom_objects", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional dictionary mapping string names to custom classes\nor functions (e.g. custom loss functions)."}, {"name": "as_text", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, False by default. Whether to write the SavedModel proto\nin text format. Currently unavailable in serving-only mode."}, {"name": "input_signature", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A possibly nested sequence of tf.TensorSpec objects, used\nto specify the expected model inputs. See tf.function for more details."}, {"name": "serving_only", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, False by default. When this is true, only the\nprediction graph is saved."}]}},
{"id": "tf.compat.v1.keras.callbacks.TensorBoard", "type": "function", "code": "tf.compat.v1.keras.callbacks.TensorBoard(log_dir='./logs',histogram_freq=0,batch_size=32,write_graph=True,write_grads=False,write_images=False,embeddings_freq=0,embeddings_layer_names=None,embeddings_metadata=None,embeddings_data=None,update_freq='epoch',profile_batch=2)", "summary": "Enable visualizations for TensorBoard.\n\nInherits From: Callback", "description": "", "code-info": {"name": "tf.compat.v1.keras.callbacks.TensorBoard", "parameters": [{"name": "log_dir", "is_optional": true, "type": "string", "default_value": "'./logs'", "description": "the path of the directory where to save the log files to be\nparsed by TensorBoard."}, {"name": "histogram_freq", "is_optional": true, "type": "int", "default_value": "0", "description": "frequency (in epochs) at which to compute activation and\nweight histograms for the layers of the model. If set to 0, histograms\nwon't be computed. Validation data (or split) must be specified for\nhistogram visualizations.\nwrite_graph: whether to visualize the graph in TensorBoard. The log file\ncan become quite large when write_graph is set to True.\nwrite_grads: whether to visualize gradient histograms in TensorBoard.\nhistogram_freq must be greater than 0."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "32", "description": "size of batch of inputs to feed to the network for histograms\ncomputation.\nwrite_images: whether to write model weights to visualize as image in\nTensorBoard.\nembeddings_freq: frequency (in epochs) at which selected embedding layers\nwill be saved. If set to 0, embeddings won't be computed. Data to be\nvisualized in TensorBoard's Embedding tab must be passed as\nembeddings_data.\nembeddings_layer_names: a list of names of layers to keep eye on. If None\nor empty list all the embedding layer will be watched.\nembeddings_metadata: a dictionary which maps layer name to a file name in\nwhich metadata for this embedding layer is saved. See the\ndetails\n  about metadata files format. In case if the same metadata file is\n  used for all embedding layers, string can be passed.\nembeddings_data: data to be embedded at layers specified in\nembeddings_layer_names. Numpy array (if the model has a single input)\nor list of Numpy arrays (if the model has multiple inputs). Learn more\nabout\n  embeddings\nupdate_freq: 'batch' or 'epoch' or integer. When using 'batch',\nwrites the losses and metrics to TensorBoard after each batch. The same\napplies for 'epoch'. If using an integer, let's say 1000, the\ncallback will write the metrics and losses to TensorBoard every 1000\nsamples. Note that writing too frequently to TensorBoard can slow down\nyour training.\nprofile_batch: Profile the batch to sample compute characteristics. By\ndefault, it will profile the second batch. Set profile_batch=0 to\ndisable profiling.\n\n\nRaises:\n\n\nValueError: If histogram_freq is set and no validation data is provided.\n\n\nEager Compatibility\n\nUsing the TensorBoard callback will work when eager execution is enabled,\nwith the restriction that outputting histogram summaries of weights and\ngradients is not supported. Consequently, histogram_freq will be ignored.\n\nMethods\n\nset_model\n\nView source\nset_model(\n    model\n)\n\nSets Keras model and creates summary ops.\n\nset_params\n\nView source\nset_params(\n    params\n)\n\n\n          "}, {"name": "write_graph", "is_optional": true, "type": "bool", "default_value": "True", "description": "whether to visualize the graph in TensorBoard. The log file\ncan become quite large when write_graph is set to True."}, {"name": "write_grads", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to visualize gradient histograms in TensorBoard.\nhistogram_freq must be greater than 0.\nbatch_size: size of batch of inputs to feed to the network for histograms\ncomputation."}, {"name": "write_images", "is_optional": true, "type": "bool", "default_value": "False", "description": "whether to write model weights to visualize as image in\nTensorBoard."}, {"name": "embeddings_freq", "is_optional": true, "type": "int", "default_value": "0", "description": "frequency (in epochs) at which selected embedding layers\nwill be saved. If set to 0, embeddings won't be computed. Data to be\nvisualized in TensorBoard's Embedding tab must be passed as\nembeddings_data."}, {"name": "embeddings_layer_names", "is_optional": true, "type": "string", "default_value": "None", "description": "a list of names of layers to keep eye on. If None\nor empty list all the embedding layer will be watched."}, {"name": "embeddings_metadata", "is_optional": true, "type": "string", "default_value": "None", "description": "a dictionary which maps layer name to a file name in\nwhich metadata for this embedding layer is saved. See the\ndetails\n  about metadata files format. In case if the same metadata file is\n  used for all embedding layers, string can be passed."}, {"name": "embeddings_data", "is_optional": true, "type": "others", "default_value": "None", "description": "data to be embedded at layers specified in\nembeddings_layer_names. Numpy array (if the model has a single input)\nor list of Numpy arrays (if the model has multiple inputs). Learn more\nabout\n  embeddings"}, {"name": "update_freq", "is_optional": true, "type": "string", "default_value": "'epoch'", "description": "'batch' or 'epoch' or integer. When using 'batch',\nwrites the losses and metrics to TensorBoard after each batch. The same\napplies for 'epoch'. If using an integer, let's say 1000, the\ncallback will write the metrics and losses to TensorBoard every 1000\nsamples. Note that writing too frequently to TensorBoard can slow down\nyour training."}, {"name": "profile_batch", "is_optional": true, "type": "int", "default_value": "2", "description": "Profile the batch to sample compute characteristics. By\ndefault, it will profile the second batch. Set profile_batch=0 to\ndisable profiling."}]}},
{"id": "tf.compat.v1.keras.backend.set_session", "type": "function", "code": "tf.compat.v1.keras.backend.set_session(session)", "summary": "Sets the global TensorFlow session.", "description": "", "code-info": {"name": "tf.compat.v1.keras.backend.set_session", "parameters": [{"name": "session", "is_optional": false, "type": "others", "description": "A TF Session."}]}},
{"id": "tf.compat.v1.keras.backend.name_scope", "type": "class", "code": "tf.compat.v1.keras.backend.name_scope(name,default_name=None,values=None)", "summary": "A context manager for use when defining a Python op.", "description": "", "code-info": {"name": "tf.compat.v1.keras.backend.name_scope", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The name argument that is passed to the op function."}, {"name": "default_name", "is_optional": true, "type": "string", "default_value": "None", "description": "The default name to use if the name argument is None."}, {"name": "values", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The list of Tensor arguments that are passed to the op function."}]}},
{"id": "tf.compat.v1.keras.backend.get_session", "type": "function", "code": "tf.compat.v1.keras.backend.get_session(op_input_list=())", "summary": "Returns the TF session to be used by the backend.", "description": "", "code-info": {"name": "tf.compat.v1.keras.backend.get_session", "parameters": [{"name": "op_input_list", "is_optional": false, "type": "tensor", "description": "An option sequence of tensors or ops, which will be used\nto determine the current graph. Otherwise the default graph will be\nused."}]}},
{"id": "tf.compat.v1.io.tf_record_iterator", "type": "function", "code": "tf.compat.v1.io.tf_record_iterator(path,options=None)", "summary": "An iterator that read the records from a TFRecords file. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.io.tf_record_iterator", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "The path to the TFRecords file."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) A TFRecordOptions object."}]}},
{"id": "tf.compat.v1.image.sample_distorted_bounding_box", "type": "function", "code": "tf.compat.v1.image.sample_distorted_bounding_box(image_size,bounding_boxes,seed=None,seed2=None,min_object_covered=0.1,aspect_ratio_range=None,area_range=None,max_attempts=None,use_image_if_no_bounding_boxes=None,name=None)", "summary": "Generate a single randomly distorted bounding box for an image. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.image.sample_distorted_bounding_box", "parameters": [{"name": "image_size", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: uint8, int8,\nint16, int32, int64. 1-D, containing [height, width, channels]."}, {"name": "bounding_boxes", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 3-D with shape [batch, N, 4]\ndescribing the N bounding boxes associated with the image."}, {"name": "seed", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0. If either seed or seed2 are\nset to non-zero, the random number generator is seeded by the given\nseed.  Otherwise, it is seeded by a random seed."}, {"name": "seed2", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0. A second seed to avoid seed\ncollision."}, {"name": "min_object_covered", "is_optional": true, "type": "tensor", "default_value": "0.1", "description": "A Tensor of type float32. Defaults to 0.1. The\ncropped area of the image must contain at least this fraction of any\nbounding box supplied. The value of this parameter should be non-negative.\nIn the case of 0, the cropped area does not need to overlap any of the\nbounding boxes supplied."}, {"name": "aspect_ratio_range", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional list of floats. Defaults to [0.75,\n1.33]. The cropped area of the image must have an aspect ratio = width /\nheight within this range."}, {"name": "area_range", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional list of floats. Defaults to [0.05, 1]. The\ncropped area of the image must contain a fraction of the supplied image\nwithin this range."}, {"name": "max_attempts", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 100. Number of attempts at\ngenerating a cropped region of the image of the specified constraints.\nAfter max_attempts failures, return the entire image."}, {"name": "use_image_if_no_bounding_boxes", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to False.\nControls behavior if no bounding boxes supplied. If true, assume an\nimplicit bounding box covering the whole input. If false, raise an error."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.image.resize_nearest_neighbor", "type": "function", "code": "tf.compat.v1.image.resize_nearest_neighbor(images,size,align_corners=False,name=None,half_pixel_centers=False)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.image.resize_nearest_neighbor", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": ""}, {"name": "size", "is_optional": false, "type": "others", "description": ""}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "half_pixel_centers", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.image.resize_image_with_pad", "type": "function", "code": "tf.compat.v1.image.resize_image_with_pad(image,target_height,target_width,method=ResizeMethodV1.BILINEAR,align_corners=False)", "summary": "Resizes and pads an image to a target width and height.", "description": "", "code-info": {"name": "tf.compat.v1.image.resize_image_with_pad", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "target_height", "is_optional": false, "type": "others", "description": "Target height."}, {"name": "target_width", "is_optional": false, "type": "others", "description": "Target width."}, {"name": "method", "is_optional": true, "type": "others", "default_value": "ResizeMethodV1.BILINEAR", "description": "Method to use for resizing image. See resize_images()"}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool.  If True, the centers of the 4 corner pixels of the\ninput and output tensors are aligned, preserving the values at the corner\npixels. Defaults to False."}]}},
{"id": "tf.compat.v1.image.resize_bilinear", "type": "function", "code": "tf.compat.v1.image.resize_bilinear(images,size,align_corners=False,name=None,half_pixel_centers=False)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.image.resize_bilinear", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": ""}, {"name": "size", "is_optional": false, "type": "others", "description": ""}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "half_pixel_centers", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.image.resize_bicubic", "type": "function", "code": "tf.compat.v1.image.resize_bicubic(images,size,align_corners=False,name=None,half_pixel_centers=False)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.image.resize_bicubic", "parameters": [{"name": "images", "is_optional": false, "type": "others", "description": ""}, {"name": "size", "is_optional": false, "type": "others", "description": ""}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "half_pixel_centers", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.image.resize_area", "type": "function", "code": "tf.compat.v1.image.resize_area(images,size,align_corners=False,name=None)", "summary": "Resize images to size using area interpolation.", "description": "", "code-info": {"name": "tf.compat.v1.image.resize_area", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, uint8, int16, uint16, int32, int64, half, float32, float64.\n4-D with shape [batch, height, width, channels]."}, {"name": "size", "is_optional": false, "type": "tensor", "description": " A 1-D int32 Tensor of 2 elements: new_height, new_width.  The\nnew size for the images."}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf true, the centers of the 4 corner pixels of the input and output tensors are\naligned, preserving the values at the corner pixels. Defaults to false."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.image.resize", "type": "function", "code": "tf.compat.v1.image.resize(images,size,method=ResizeMethodV1.BILINEAR,align_corners=False,preserve_aspect_ratio=False,name=None)", "summary": "Resize images to size using the specified method.", "description": "", "code-info": {"name": "tf.compat.v1.image.resize", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "4-D Tensor of shape [batch, height, width, channels] or 3-D Tensor\nof shape [height, width, channels]."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "A 1-D int32 Tensor of 2 elements: new_height, new_width.  The new\nsize for the images."}, {"name": "method", "is_optional": true, "type": "others", "default_value": "ResizeMethodV1.BILINEAR", "description": "ResizeMethod.  Defaults to ResizeMethod.BILINEAR."}, {"name": "align_corners", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool.  If True, the centers of the 4 corner pixels of the\ninput and output tensors are aligned, preserving the values at the corner\npixels. Defaults to False."}, {"name": "preserve_aspect_ratio", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to preserve the aspect ratio. If this is set,\nthen images will be resized to a size that fits in size while\npreserving the aspect ratio of the original image. Scales up the image if\nsize is bigger than the current size of the image. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}]}},
{"id": "tf.compat.v1.graph_util.remove_training_nodes", "type": "function", "code": "tf.compat.v1.graph_util.remove_training_nodes(input_graph,protected_nodes=None)", "summary": "Prunes out nodes that aren't needed for inference. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.graph_util.remove_training_nodes", "parameters": [{"name": "input_graph", "is_optional": false, "type": "others", "description": "Model to analyze and prune."}, {"name": "protected_nodes", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional list of names of nodes to be kept\nunconditionally. This is for example useful to preserve Identity output\nnodes."}]}},
{"id": "tf.compat.v1.image.crop_and_resize", "type": "function", "code": "tf.compat.v1.image.crop_and_resize(image,boxes,box_ind=None,crop_size=None,method='bilinear',extrapolation_value=0,name=None,box_indices=None)", "summary": "Extracts crops from the input image tensor and resizes them.", "description": "", "code-info": {"name": "tf.compat.v1.image.crop_and_resize", "parameters": [{"name": "image", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: uint8, uint16, int8, int16, int32, int64, half, float32, float64.\nA 4-D tensor of shape [batch, image_height, image_width, depth].\nBoth image_height and image_width need to be positive."}, {"name": "boxes", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32.\nA 2-D tensor of shape [num_boxes, 4]. The i-th row of the tensor\nspecifies the coordinates of a box in the box_ind[i] image and is specified\nin normalized coordinates [y1, x1, y2, x2]. A normalized coordinate value of\ny is mapped to the image coordinate at y * (image_height - 1), so as the\n[0, 1] interval of normalized image height is mapped to\n[0, image_height - 1] in image height coordinates. We do allow y1 &gt; y2, in\nwhich case the sampled crop is an up-down flipped version of the original\nimage. The width dimension is treated similarly. Normalized coordinates\noutside the [0, 1] range are allowed, in which case we use\nextrapolation_value to extrapolate the input image values."}, {"name": "box_ind", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nA 1-D tensor of shape [num_boxes] with int32 values in [0, batch).\nThe value of box_ind[i] specifies the image that the i-th box refers to."}, {"name": "crop_size", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type int32.\nA 1-D tensor of 2 elements, size = [crop_height, crop_width]. All\ncropped image patches are resized to this size. The aspect ratio of the image\ncontent is not preserved. Both crop_height and crop_width need to be\npositive."}, {"name": "method", "is_optional": true, "type": "string", "default_value": "'bilinear'", "description": "An optional string from: \"bilinear\", \"nearest\". Defaults to \"bilinear\".\nA string specifying the sampling method for resizing. It can be either\n\"bilinear\" or \"nearest\" and default to \"bilinear\". Currently two sampling\nmethods are supported: Bilinear and Nearest Neighbor."}, {"name": "extrapolation_value", "is_optional": true, "type": "int", "default_value": "0", "description": "An optional float. Defaults to 0.\nValue used for extrapolation, when applicable."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "box_indices", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.image.extract_glimpse", "type": "function", "code": "tf.compat.v1.image.extract_glimpse(input,size,offsets,centered=True,normalized=True,uniform_noise=True,name=None)", "summary": "Extracts a glimpse from the input tensor.", "description": "", "code-info": {"name": "tf.compat.v1.image.extract_glimpse", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. A 4-D float tensor of shape\n[batch_size, height, width, channels]."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32. A 1-D tensor of 2 elements containing the\nsize of the glimpses to extract.  The glimpse height must be specified\nfirst, following by the glimpse width."}, {"name": "offsets", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. A 2-D integer tensor of shape\n[batch_size, 2] containing the y, x locations of the center of each\nwindow."}, {"name": "centered", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. indicates if the offset\ncoordinates are centered relative to the image, in which case the (0, 0)\noffset is relative to the center of the input images. If false, the (0,0)\noffset corresponds to the upper left corner of the input images."}, {"name": "normalized", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. indicates if the offset\ncoordinates are normalized."}, {"name": "uniform_noise", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. indicates if the\nnoise should be generated using a uniform distribution or a Gaussian\ndistribution."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.image.draw_bounding_boxes", "type": "function", "code": "tf.compat.v1.image.draw_bounding_boxes(images,boxes,name=None,colors=None)", "summary": "Draw bounding boxes on a batch of images.", "description": "", "code-info": {"name": "tf.compat.v1.image.draw_bounding_boxes", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, half.\n4-D with shape [batch, height, width, depth]. A batch of images."}, {"name": "boxes", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 3-D with shape [batch,\nnum_bounding_boxes, 4] containing bounding boxes."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "colors", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.graph_util.convert_variables_to_constants", "type": "function", "code": "tf.compat.v1.graph_util.convert_variables_to_constants(sess,input_graph_def,output_node_names,variable_names_whitelist=None,variable_names_blacklist=None)", "summary": "Replaces all the variables in a graph with constants of the same values. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.graph_util.convert_variables_to_constants", "parameters": [{"name": "sess", "is_optional": false, "type": "tensor", "description": "Active TensorFlow session containing the variables."}, {"name": "input_graph_def", "is_optional": false, "type": "others", "description": "GraphDef object holding the network."}, {"name": "output_node_names", "is_optional": false, "type": "string", "description": "List of name strings for the result nodes of the graph."}, {"name": "variable_names_whitelist", "is_optional": true, "type": "string", "default_value": "None", "description": "The set of variable names to convert (by default,\n                      all variables are converted)."}, {"name": "variable_names_blacklist", "is_optional": true, "type": "string", "default_value": "None", "description": "The set of variable names to omit converting\n                      to constants."}]}},
{"id": "tf.compat.v1.graph_util.tensor_shape_from_node_def_name", "type": "function", "code": "tf.compat.v1.graph_util.tensor_shape_from_node_def_name(graph,input_name)", "summary": "Convenience function to get a shape from a NodeDef's input string. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.graph_util.tensor_shape_from_node_def_name", "parameters": [{"name": "graph", "is_optional": false, "type": "others", "description": ""}, {"name": "input_name", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.graph_util.extract_sub_graph", "type": "function", "code": "tf.compat.v1.graph_util.extract_sub_graph(graph_def,dest_nodes)", "summary": "Extract the subgraph that can reach any of the nodes in 'dest_nodes'. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.graph_util.extract_sub_graph", "parameters": [{"name": "graph_def", "is_optional": false, "type": "others", "description": "A graph_pb2.GraphDef proto."}, {"name": "dest_nodes", "is_optional": false, "type": "string", "description": "A list of strings specifying the destination node names."}]}},
{"id": "tf.compat.v1.graph_util.must_run_on_cpu", "type": "function", "code": "tf.compat.v1.graph_util.must_run_on_cpu(node,pin_variables_on_cpu=False)", "summary": "Returns True if the given node_def must run on CPU, otherwise False. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.graph_util.must_run_on_cpu", "parameters": [{"name": "node", "is_optional": false, "type": "others", "description": "The node to be assigned to a device. Could be either an ops.Operation\nor NodeDef."}, {"name": "pin_variables_on_cpu", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, this function will return False if node_def\nrepresents a variable-related op."}]}},
{"id": "tf.compat.v1.gfile.Stat", "type": "function", "code": "tf.compat.v1.gfile.Stat(filename)", "summary": "Returns file statistics for a given path.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Stat", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "string, path to a file"}]}},
{"id": "tf.compat.v1.gfile.Rename", "type": "function", "code": "tf.compat.v1.gfile.Rename(oldname,newname,overwrite=False)", "summary": "Rename or move a file / directory.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Rename", "parameters": [{"name": "oldname", "is_optional": false, "type": "string", "description": "string, pathname for a file"}, {"name": "newname", "is_optional": false, "type": "string", "description": "string, pathname to which the file needs to be moved"}, {"name": "overwrite", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean, if false it's an error for newname to be occupied by\nan existing file."}]}},
{"id": "tf.compat.v1.gfile.IsDirectory", "type": "function", "code": "tf.compat.v1.gfile.IsDirectory(dirname)", "summary": "Returns whether the path is a directory or not.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.IsDirectory", "parameters": [{"name": "dirname", "is_optional": false, "type": "string", "description": "string, path to a potential directory"}]}},
{"id": "tf.compat.v1.gfile.Walk", "type": "function", "code": "tf.compat.v1.gfile.Walk(top,in_order=True)", "summary": "Recursive directory tree generator for directories.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Walk", "parameters": [{"name": "top", "is_optional": false, "type": "string", "description": "string, a Directory name"}, {"name": "in_order", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, Traverse in order if True, post order if False.  Errors that\nhappen while listing directories are ignored."}]}},
{"id": "tf.compat.v1.gfile.Remove", "type": "function", "code": "tf.compat.v1.gfile.Remove(filename)", "summary": "Deletes the file located at 'filename'.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Remove", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "string, a filename"}]}},
{"id": "tf.compat.v1.gfile.MkDir", "type": "function", "code": "tf.compat.v1.gfile.MkDir(dirname)", "summary": "Creates a directory with the name dirname.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.MkDir", "parameters": [{"name": "dirname", "is_optional": false, "type": "string", "description": "string, name of the directory to be created"}]}},
{"id": "tf.compat.v1.gfile.MakeDirs", "type": "function", "code": "tf.compat.v1.gfile.MakeDirs(dirname)", "summary": "Creates a directory and all parent/intermediate directories.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.MakeDirs", "parameters": [{"name": "dirname", "is_optional": false, "type": "string", "description": "string, name of the directory to be created"}]}},
{"id": "tf.compat.v1.gfile.ListDirectory", "type": "function", "code": "tf.compat.v1.gfile.ListDirectory(dirname)", "summary": "Returns a list of entries contained within a directory.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.ListDirectory", "parameters": [{"name": "dirname", "is_optional": false, "type": "string", "description": "string, path to a directory"}]}},
{"id": "__enter__", "type": "function", "code": "__enter__()", "summary": "Allows remapping traceback information to different source code.\n\nInherits From: StackTraceTransform", "description": "", "code-info": {"name": "__enter__", "parameters": []}},
{"id": "tf.compat.v1.gfile.Exists", "type": "function", "code": "tf.compat.v1.gfile.Exists(filename)", "summary": "Determines whether a path exists or not.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Exists", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "string, a path"}]}},
{"id": "tf.compat.v1.gfile.DeleteRecursively", "type": "function", "code": "tf.compat.v1.gfile.DeleteRecursively(dirname)", "summary": "Deletes everything under dirname recursively.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.DeleteRecursively", "parameters": [{"name": "dirname", "is_optional": false, "type": "string", "description": "string, a path to a directory"}]}},
{"id": "__enter__", "type": "function", "code": "__enter__()", "summary": "Base class for stack trace transformation functions.", "description": "", "code-info": {"name": "__enter__", "parameters": []}},
{"id": "tf.compat.v1.gfile.Copy", "type": "function", "code": "tf.compat.v1.gfile.Copy(oldpath,newpath,overwrite=False)", "summary": "Copies data from oldpath to newpath.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Copy", "parameters": [{"name": "oldpath", "is_optional": false, "type": "string", "description": "string, name of the file who's contents need to be copied"}, {"name": "newpath", "is_optional": false, "type": "string", "description": "string, name of the file to which to copy to"}, {"name": "overwrite", "is_optional": true, "type": "bool", "default_value": "False", "description": "boolean, if false it's an error for newpath to be occupied by\nan existing file."}]}},
{"id": "tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack(limit=-1)", "summary": "A lightweight, extensible re-implementation of traceback.extract_stack.", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack", "parameters": [{"name": "limit", "is_optional": true, "type": "others", "default_value": "-1", "description": "A limit on the number of frames to return."}]}},
{"id": "tf.compat.v1.gfile.Glob", "type": "function", "code": "tf.compat.v1.gfile.Glob(filename)", "summary": "Returns a list of files that match the given pattern(s).", "description": "", "code-info": {"name": "tf.compat.v1.gfile.Glob", "parameters": [{"name": "filename", "is_optional": false, "type": "string", "description": "string or iterable of strings. The glob pattern(s)."}]}},
{"id": "tf.compat.v1.gfile.FastGFile", "type": "function", "code": "tf.compat.v1.gfile.FastGFile(name,mode='r')", "summary": "File I/O wrappers without thread locking.", "description": "", "code-info": {"name": "tf.compat.v1.gfile.FastGFile", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "  Returns the file name.\n\n\nMethods\n\n__enter__\n\nView source\n__enter__()\n\nMake usable with \"with\" statement.\n\n__exit__\n\nView source\n__exit__(\n    unused_type, unused_value, unused_traceback\n)\n\nMake usable with \"with\" statement.\n\n__iter__\n\nView source\n__iter__()\n\nclose\n\nView source\nclose()\n\nCloses FileIO. Should be called for the WritableFile to be flushed.\n\nflush\n\nView source\nflush()\n\nFlushes the Writable file.\n\nThis only ensures that the data has made its way out of the process without\nany guarantees on whether it's written to disk. This means that the\ndata would survive an application crash but not necessarily an OS crash.\n\nnext\n\nView source\nnext()\n\nread\n\nView source\nread(\n    n=-1\n)\n\nReturns the contents of a file as a string.\n\nStarts reading from current position in file.\n\nArgs:\n\n\nn: Read n bytes if n != -1. If n = -1, reads to end of file.\n\n\nReturns:\n\nn bytes of the file (or whole file) in bytes mode or n bytes of the\nstring if in string (regular) mode.\n\nreadline\n\nView source\nreadline()\n\nReads the next line from the file. Leaves the '\\n' at the end.\n\nreadlines\n\nView source\nreadlines()\n\nReturns all lines from the file in a list.\n\nseek\n\nView source\nseek(\n    offset=None, whence=0, position=None\n)\n\nSeeks to the offset in the file. (deprecated arguments)\nWarning: SOME ARGUMENTS ARE DEPRECATED: (position). They will be removed in a future version.\nInstructions for updating:\nposition is deprecated in favor of the offset argument.\nArgs:\n\n\noffset: The byte count relative to the whence argument.\nwhence: Valid values for whence are:\n0: start of the file (default)\n1: relative to the current position of the file\n2: relative to the end of file. offset is usually negative.\n\n\nseekable\n\nView source\nseekable()\n\nReturns True as FileIO supports random access ops of seek()/tell()\n\nsize\n\nView source\nsize()\n\nReturns the size of the file.\n\ntell\n\nView source\ntell()\n\nReturns the current position in the file.\n\nwrite\n\nView source\nwrite(\n    file_content\n)\n\nWrites file_content to the file. Appends to the end of the file.\n\n          "}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'r'", "description": "  Returns the mode in which the file was opened.\nname:   Returns the file name."}]}},
{"id": "tf.compat.v1.flags.tf_decorator.tf_stack.StackSummary", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.tf_stack.StackSummary(type,*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.StackSummary", "parameters": [{"name": "type", "is_optional": false, "type": "others", "description": ""}, {"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "__enter__", "type": "function", "code": "__enter__()", "summary": "Allows filtering traceback information by removing superfluous frames.\n\nInherits From: StackTraceTransform", "description": "", "code-info": {"name": "__enter__", "parameters": []}},
{"id": "tf.compat.v1.flags.tf_decorator.tf_stack.FrameSummary", "type": "class", "code": "tf.compat.v1.flags.tf_decorator.tf_stack.FrameSummary(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.FrameSummary", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.tf_decorator.tf_stack.CurrentModuleFilter", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.tf_stack.CurrentModuleFilter()", "summary": "Filters stack frames from the module where this is used (best effort).\n\nInherits From: StackTraceFilter", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.CurrentModuleFilter", "parameters": []}},
{"id": "tf.compat.v1.flags.tf_decorator.unwrap", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.unwrap(maybe_tf_decorator)", "summary": "Unwraps an object into a list of TFDecorators and a final target.", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.unwrap", "parameters": [{"name": "maybe_tf_decorator", "is_optional": false, "type": "others", "description": "Any callable object."}]}},
{"id": "tf.compat.v1.flags.tf_decorator.rewrap", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.rewrap(decorator_func,previous_target,new_target)", "summary": "Injects a new target into a function built by make_decorator.", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.rewrap", "parameters": [{"name": "decorator_func", "is_optional": false, "type": "others", "description": "Callable returned by wrap."}, {"name": "previous_target", "is_optional": false, "type": "others", "description": "Callable that needs to be replaced."}, {"name": "new_target", "is_optional": false, "type": "others", "description": "Callable to replace previous_target with."}]}},
{"id": "tf.compat.v1.flags.tf_decorator.make_decorator", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.make_decorator(target,decorator_func,decorator_name=None,decorator_doc='',decorator_argspec=None)", "summary": "Make a decorator from a wrapper and a target.", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.make_decorator", "parameters": [{"name": "target", "is_optional": false, "type": "others", "description": "The final callable to be wrapped."}, {"name": "decorator_func", "is_optional": false, "type": "others", "description": "The wrapper function."}, {"name": "decorator_name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the decorator. If None, the name of the\nfunction calling make_decorator."}, {"name": "decorator_doc", "is_optional": true, "type": "string", "default_value": "''", "description": "Documentation specific to this application of\ndecorator_func to target."}, {"name": "decorator_argspec", "is_optional": true, "type": "others", "default_value": "None", "description": "The new callable signature of this decorator."}]}},
{"id": "tf.compat.v1.flags.WhitespaceSeparatedListParser", "type": "function", "code": "tf.compat.v1.flags.WhitespaceSeparatedListParser(comma_compat=False)", "summary": "Parser for a whitespace-separated list of strings.\n\nInherits From: BaseListParser", "description": "", "code-info": {"name": "tf.compat.v1.flags.WhitespaceSeparatedListParser", "parameters": [{"name": "comma_compat", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, whether to support comma as an additional separator.\nIf False then only whitespace is supported.  This is intended only for\nbackwards compatibility with flags that used to be comma-separated."}]}},
{"id": "tf.compat.v1.flags.validator", "type": "function", "code": "tf.compat.v1.flags.validator(flag_name,message='Flagvalidationfailed',flag_values=_flagvalues.FLAGS)", "summary": "A function decorator for defining a flag validator.", "description": "", "code-info": {"name": "tf.compat.v1.flags.validator", "parameters": [{"name": "flag_name", "is_optional": false, "type": "string", "description": "str, name of the flag to be checked."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "'Flagvalidationfailed'", "description": "str, error text to be shown to the user if checker returns False.\nIf checker raises flags.ValidationError, message from the raised\nerror will be shown."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance to validate\nagainst."}]}},
{"id": "tf.compat.v1.flags.tf_decorator.TFDecorator", "type": "function", "code": "tf.compat.v1.flags.tf_decorator.TFDecorator(decorator_name,target,decorator_doc='',decorator_argspec=None)", "summary": "Base class for all TensorFlow decorators.", "description": "", "code-info": {"name": "tf.compat.v1.flags.tf_decorator.TFDecorator", "parameters": [{"name": "decorator_name", "is_optional": false, "type": "others", "description": ""}, {"name": "target", "is_optional": false, "type": "others", "description": ""}, {"name": "decorator_doc", "is_optional": true, "type": "string", "default_value": "''", "description": ""}, {"name": "decorator_argspec", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.flags.multi_flags_validator", "type": "function", "code": "tf.compat.v1.flags.multi_flags_validator(flag_names,message='Flagvalidationfailed',flag_values=_flagvalues.FLAGS)", "summary": "A function decorator for defining a multi-flag validator.", "description": "", "code-info": {"name": "tf.compat.v1.flags.multi_flags_validator", "parameters": [{"name": "flag_names", "is_optional": false, "type": "string", "description": "[str], a list of the flag names to be checked."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "'Flagvalidationfailed'", "description": "str, error text to be shown to the user if checker returns False.\nIf checker raises flags.ValidationError, message from the raised\nerror will be shown."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance to validate\nagainst."}]}},
{"id": "tf.compat.v1.flags.register_validator", "type": "function", "code": "tf.compat.v1.flags.register_validator(flag_name,checker,message='Flagvalidationfailed',flag_values=_flagvalues.FLAGS)", "summary": "Adds a constraint, which will be enforced during program execution.", "description": "", "code-info": {"name": "tf.compat.v1.flags.register_validator", "parameters": [{"name": "flag_name", "is_optional": false, "type": "others", "description": ""}, {"name": "checker", "is_optional": false, "type": "others", "description": ""}, {"name": "message", "is_optional": true, "type": "string", "default_value": "'Flagvalidationfailed'", "description": ""}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": ""}]}},
{"id": "tf.compat.v1.flags.MultiEnumClassFlag", "type": "function", "code": "tf.compat.v1.flags.MultiEnumClassFlag(name,default,help_string,enum_class,**args)", "summary": "A multi_enum_class flag.\n\nInherits From: MultiFlag", "description": "", "code-info": {"name": "tf.compat.v1.flags.MultiEnumClassFlag", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help_string", "is_optional": false, "type": "others", "description": ""}, {"name": "enum_class", "is_optional": false, "type": "others", "description": ""}, {"name": "**args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.UnrecognizedFlagError", "type": "class", "code": "tf.compat.v1.flags.UnrecognizedFlagError(flagname,flagvalue='',suggestions=None)", "summary": "Raised when a flag is unrecognized.\n\nInherits From: Error", "description": "", "code-info": {"name": "tf.compat.v1.flags.UnrecognizedFlagError", "parameters": [{"name": "flagname", "is_optional": false, "type": "string", "description": "str, the name of the unrecognized flag."}, {"name": "flagvalue", "is_optional": true, "type": "string", "default_value": "''", "description": ""}, {"name": "suggestions", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.flags.text_wrap", "type": "function", "code": "tf.compat.v1.flags.text_wrap(text,length=None,indent='',firstline_indent=None)", "summary": "Wraps a given text to a maximum line length and returns it.", "description": "", "code-info": {"name": "tf.compat.v1.flags.text_wrap", "parameters": [{"name": "text", "is_optional": false, "type": "string", "description": "str, text to wrap."}, {"name": "length", "is_optional": true, "type": "others", "default_value": "None", "description": "int, maximum length of a line, includes indentation.\nIf this is None then use get_help_width()"}, {"name": "indent", "is_optional": true, "type": "string", "default_value": "''", "description": "str, indent for all but first line."}, {"name": "firstline_indent", "is_optional": true, "type": "string", "default_value": "None", "description": "str, indent for first line; if None, fall back to indent."}]}},
{"id": "tf.compat.v1.flags.register_multi_flags_validator", "type": "function", "code": "tf.compat.v1.flags.register_multi_flags_validator(flag_names,multi_flags_checker,message='Flagsvalidationfailed',flag_values=_flagvalues.FLAGS)", "summary": "Adds a constraint to multiple flags.", "description": "", "code-info": {"name": "tf.compat.v1.flags.register_multi_flags_validator", "parameters": [{"name": "flag_names", "is_optional": false, "type": "string", "description": "[str], a list of the flag names to be checked."}, {"name": "multi_flags_checker", "is_optional": false, "type": "others", "description": "callable, a function to validate the flag.\ninput - dict, with keys() being flag_names, and value for each key\n    being the value of the corresponding flag (string, boolean, etc).\noutput - bool, True if validator constraint is satisfied.\n    If constraint is not satisfied, it should either return False or\n    raise flags.ValidationError."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "'Flagsvalidationfailed'", "description": "str, error text to be shown to the user if checker returns False.\nIf checker raises flags.ValidationError, message from the raised\nerror will be shown."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance to validate\nagainst."}]}},
{"id": "tf.compat.v1.flags.MultiFlag", "type": "class", "code": "tf.compat.v1.flags.MultiFlag(*args,**kwargs)", "summary": "A flag that can appear multiple time on the command-line.\n\nInherits From: Flag", "description": "", "code-info": {"name": "tf.compat.v1.flags.MultiFlag", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.mark_flags_as_required", "type": "function", "code": "tf.compat.v1.flags.mark_flags_as_required(flag_names,flag_values=_flagvalues.FLAGS)", "summary": "Ensures that flags are not None during program execution.", "description": "", "code-info": {"name": "tf.compat.v1.flags.mark_flags_as_required", "parameters": [{"name": "flag_names", "is_optional": false, "type": "string", "description": "Sequence[str], names of the flags."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance where the flags\nare defined."}]}},
{"id": "tf.compat.v1.flags.mark_flags_as_mutual_exclusive", "type": "function", "code": "tf.compat.v1.flags.mark_flags_as_mutual_exclusive(flag_names,required=False,flag_values=_flagvalues.FLAGS)", "summary": "Ensures that only one flag among flag_names is not None.", "description": "", "code-info": {"name": "tf.compat.v1.flags.mark_flags_as_mutual_exclusive", "parameters": [{"name": "flag_names", "is_optional": false, "type": "string", "description": "[str], names of the flags."}, {"name": "required", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool. If true, exactly one of the flags must have a value other\nthan None. Otherwise, at most one of the flags can have a value other\nthan None, and it is valid for all of the flags to be None."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance where the flags\nare defined."}]}},
{"id": "tf.compat.v1.flags.mark_bool_flags_as_mutual_exclusive", "type": "function", "code": "tf.compat.v1.flags.mark_bool_flags_as_mutual_exclusive(flag_names,required=False,flag_values=_flagvalues.FLAGS)", "summary": "Ensures that only one flag among flag_names is True.", "description": "", "code-info": {"name": "tf.compat.v1.flags.mark_bool_flags_as_mutual_exclusive", "parameters": [{"name": "flag_names", "is_optional": false, "type": "string", "description": "[str], names of the flags."}, {"name": "required", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool. If true, exactly one flag must be True. Otherwise, at most\none flag can be True, and it is valid for all flags to be False."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance where the flags\nare defined."}]}},
{"id": "tf.compat.v1.flags.ListSerializer", "type": "function", "code": "tf.compat.v1.flags.ListSerializer(list_sep)", "summary": "Base class for generating string representations of a flag value.\n\nInherits From: ArgumentSerializer", "description": "", "code-info": {"name": "tf.compat.v1.flags.ListSerializer", "parameters": [{"name": "list_sep", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.ListParser", "type": "function", "code": "tf.compat.v1.flags.ListParser()", "summary": "Parser for a comma-separated list of strings.\n\nInherits From: BaseListParser", "description": "", "code-info": {"name": "tf.compat.v1.flags.ListParser", "parameters": []}},
{"id": "tf.compat.v1.flags.get_help_width", "type": "function", "code": "tf.compat.v1.flags.get_help_width()", "summary": "Returns the integer width of help lines that is used in TextWrap.", "description": "", "code-info": {"name": "tf.compat.v1.flags.get_help_width", "parameters": []}},
{"id": "tf.compat.v1.flags.mark_flag_as_required", "type": "function", "code": "tf.compat.v1.flags.mark_flag_as_required(flag_name,flag_values=_flagvalues.FLAGS)", "summary": "Ensures that flag is not None during program execution.", "description": "", "code-info": {"name": "tf.compat.v1.flags.mark_flag_as_required", "parameters": [{"name": "flag_name", "is_optional": false, "type": "string", "description": "str, name of the flag"}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "flags.FlagValues, optional FlagValues instance where the flag\nis defined."}]}},
{"id": "tf.compat.v1.flags.IntegerParser", "type": "function", "code": "tf.compat.v1.flags.IntegerParser(lower_bound=None,upper_bound=None)", "summary": "Parser of an integer value.", "description": "", "code-info": {"name": "tf.compat.v1.flags.IntegerParser", "parameters": [{"name": "lower_bound", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "upper_bound", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.flags.FloatParser", "type": "function", "code": "tf.compat.v1.flags.FloatParser(lower_bound=None,upper_bound=None)", "summary": "Parser of floating point values.", "description": "", "code-info": {"name": "tf.compat.v1.flags.FloatParser", "parameters": [{"name": "lower_bound", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "upper_bound", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.flags.flag_dict_to_args", "type": "function", "code": "tf.compat.v1.flags.flag_dict_to_args(flag_map)", "summary": "Convert a dict of values into process call parameters.", "description": "", "code-info": {"name": "tf.compat.v1.flags.flag_dict_to_args", "parameters": [{"name": "flag_map", "is_optional": false, "type": "string", "description": "dict, a mapping where the keys are flag names (strings).\nvalues are treated according to their type:"}]}},
{"id": "tf.compat.v1.flags.FlagValues", "type": "function", "code": "tf.compat.v1.flags.FlagValues()", "summary": "Registry of 'Flag' objects.", "description": "", "code-info": {"name": "tf.compat.v1.flags.FlagValues", "parameters": []}},
{"id": "tf.compat.v1.flags.FLAGS", "type": "function", "code": "tf.compat.v1.flags.FLAGS(*args,**kwargs)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.flags.FLAGS", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.Flag", "type": "function", "code": "tf.compat.v1.flags.Flag(parser,serializer,name,default,help_string,short_name=None,boolean=False,allow_override=False,allow_override_cpp=False,allow_hide_cpp=False,allow_overwrite=True,allow_using_method_names=False)", "summary": "Information about a command-line flag.", "description": "", "code-info": {"name": "tf.compat.v1.flags.Flag", "parameters": [{"name": "parser", "is_optional": false, "type": "others", "description": ""}, {"name": "serializer", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help_string", "is_optional": false, "type": "others", "description": ""}, {"name": "short_name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "boolean", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "allow_override", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "allow_override_cpp", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "allow_hide_cpp", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "allow_overwrite", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "allow_using_method_names", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.flags.EnumFlag", "type": "class", "code": "tf.compat.v1.flags.EnumFlag(name,default,help,enum_values,short_name=None,case_sensitive=True,**args)", "summary": "Basic enum flag; its value can be any string from list of enum_values.\n\nInherits From: Flag", "description": "", "code-info": {"name": "tf.compat.v1.flags.EnumFlag", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help", "is_optional": false, "type": "others", "description": ""}, {"name": "enum_values", "is_optional": false, "type": "others", "description": ""}, {"name": "short_name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "case_sensitive", "is_optional": true, "type": "bool", "default_value": "True", "description": ""}, {"name": "**args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.EnumClassParser", "type": "function", "code": "tf.compat.v1.flags.EnumClassParser(enum_class)", "summary": "Parser of an Enum class member.\n\nInherits From: ArgumentParser", "description": "", "code-info": {"name": "tf.compat.v1.flags.EnumClassParser", "parameters": [{"name": "enum_class", "is_optional": false, "type": "others", "description": "class, the Enum class with all possible flag values."}]}},
{"id": "tf.compat.v1.flags.EnumClassFlag", "type": "class", "code": "tf.compat.v1.flags.EnumClassFlag(name,default,help,enum_class,short_name=None,**args)", "summary": "Basic enum flag; its value is an enum class's member.\n\nInherits From: Flag", "description": "", "code-info": {"name": "tf.compat.v1.flags.EnumClassFlag", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help", "is_optional": false, "type": "others", "description": ""}, {"name": "enum_class", "is_optional": false, "type": "others", "description": ""}, {"name": "short_name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.doc_to_help", "type": "function", "code": "tf.compat.v1.flags.doc_to_help(doc)", "summary": "Takes a doc string and reformats it as help.", "description": "", "code-info": {"name": "tf.compat.v1.flags.doc_to_help", "parameters": [{"name": "doc", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.disclaim_key_flags", "type": "function", "code": "tf.compat.v1.flags.disclaim_key_flags()", "summary": "Declares that the current module will not define any more key flags.", "description": "", "code-info": {"name": "tf.compat.v1.flags.disclaim_key_flags", "parameters": []}},
{"id": "tf.compat.v1.flags.EnumParser", "type": "function", "code": "tf.compat.v1.flags.EnumParser(enum_values,case_sensitive=True)", "summary": "Parser of a string enum value (a string value from a given set).\n\nInherits From: ArgumentParser", "description": "", "code-info": {"name": "tf.compat.v1.flags.EnumParser", "parameters": [{"name": "enum_values", "is_optional": false, "type": "string", "description": "[str], a non-empty list of string values in the enum."}, {"name": "case_sensitive", "is_optional": true, "type": "bool", "default_value": "True", "description": "bool, whether or not the enum is to be case-sensitive."}]}},
{"id": "tf.compat.v1.flags.DEFINE_string", "type": "function", "code": "tf.compat.v1.flags.DEFINE_string(name,default,help,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value can be any string.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_string", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help", "is_optional": false, "type": "others", "description": ""}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": ""}, {"name": "**args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.DEFINE_spaceseplist", "type": "function", "code": "tf.compat.v1.flags.DEFINE_spaceseplist(name,default,help,comma_compat=False,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value is a whitespace-separated list of strings.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_spaceseplist", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "string", "description": "list|str|None, the default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "comma_compat", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool - Whether to support comma as an additional separator.\nIf false then only whitespace is supported.  This is intended only for\nbackwards compatibility with flags that used to be comma-separated."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi_string", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi_string(name,default,help,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value can be a list of any strings.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi_string", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "Union[Iterable[Text], Text, None], the default value of the flag;\nsee DEFINE_multi."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi_integer", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi_integer(name,default,help,lower_bound=None,upper_bound=None,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value can be a list of arbitrary integers.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi_integer", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "Union[Iterable[int], Text, None], the default value of the flag;\nsee DEFINE_multi."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "lower_bound", "is_optional": true, "type": "others", "default_value": "None", "description": "int, min values of the flag."}, {"name": "upper_bound", "is_optional": true, "type": "others", "default_value": "None", "description": "int, max values of the flag."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi_float", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi_float(name,default,help,lower_bound=None,upper_bound=None,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value can be a list of arbitrary floats.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi_float", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "float", "description": "Union[Iterable[float], Text, None], the default value of the flag;\nsee DEFINE_multi."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "lower_bound", "is_optional": true, "type": "float", "default_value": "None", "description": "float, min values of the flag."}, {"name": "upper_bound", "is_optional": true, "type": "float", "default_value": "None", "description": "float, max values of the flag."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi_enum_class", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi_enum_class(name,default,enum_class,help,flag_values=_flagvalues.FLAGS,module_name=None,**args)", "summary": "Registers a flag whose value can be a list of enum members.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi_enum_class", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "Union[Iterable[Enum], Iterable[Text], Enum, Text, None], the\ndefault value of the flag; see\nDEFINE_multi; only differences are documented here. If the value is\na single Enum, it is treated as a single-item list of that Enum value.\nIf it is an iterable, text values within the iterable will be converted\nto the equivalent Enum objects."}, {"name": "enum_class", "is_optional": false, "type": "others", "description": "class, the Enum class with all the possible values for the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will be\nregistered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the Python module declaring this flag. If\nnot provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the Flag\ninit."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi_enum", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi_enum(name,default,enum_values,help,flag_values=_flagvalues.FLAGS,case_sensitive=True,**args)", "summary": "Registers a flag whose value can be a list strings from enum_values.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi_enum", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "Union[Iterable[Text], Text, None], the default value of the flag;\nsee DEFINE_multi."}, {"name": "enum_values", "is_optional": false, "type": "string", "description": "[str], a non-empty list of strings with the possible values for\nthe flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "case_sensitive", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether or not the enum is to be case-sensitive."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_multi", "type": "function", "code": "tf.compat.v1.flags.DEFINE_multi(parser,serializer,name,default,help,flag_values=_flagvalues.FLAGS,module_name=None,**args)", "summary": "Registers a generic MultiFlag that parses its args with a given parser.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_multi", "parameters": [{"name": "parser", "is_optional": false, "type": "others", "description": "ArgumentParser, used to parse the flag arguments."}, {"name": "serializer", "is_optional": false, "type": "others", "description": "ArgumentSerializer, the flag serializer instance."}, {"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "Union[Iterable[T], Text, None], the default value of the flag.\nIf the value is text, it will be parsed as if it was provided from\nthe command line. If the value is a non-string iterable, it will be\niterated over to create a shallow copy of the values. If it is None,\nit is left as-is."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_list", "type": "function", "code": "tf.compat.v1.flags.DEFINE_list(name,default,help,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value is a comma-separated list of strings.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_list", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "string", "description": "list|str|None, the default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "Dictionary with extra keyword args that are passed to the\nFlag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_float", "type": "function", "code": "tf.compat.v1.flags.DEFINE_float(name,default,help,lower_bound=None,upper_bound=None,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value must be a float.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_float", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "float", "description": "float|str|None, the default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "lower_bound", "is_optional": true, "type": "float", "default_value": "None", "description": "float, min value of the flag."}, {"name": "upper_bound", "is_optional": true, "type": "float", "default_value": "None", "description": "float, max value of the flag."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to DEFINE."}]}},
{"id": "tf.compat.v1.flags.DEFINE_enum", "type": "function", "code": "tf.compat.v1.flags.DEFINE_enum(name,default,enum_values,help,flag_values=_flagvalues.FLAGS,module_name=None,**args)", "summary": "Registers a flag whose value can be any string from enum_values.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_enum", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "string", "description": "str|None, the default value of the flag."}, {"name": "enum_values", "is_optional": false, "type": "string", "description": "[str], a non-empty list of strings with the possible values for\nthe flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "str, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to Flag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_bool", "type": "function", "code": "tf.compat.v1.flags.DEFINE_bool(name,default,help,flag_values=_flagvalues.FLAGS,module_name=None,**args)", "summary": "Registers a boolean flag.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_bool", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "bool", "description": "bool|str|None, the default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "str, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to Flag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_integer", "type": "function", "code": "tf.compat.v1.flags.DEFINE_integer(name,default,help,lower_bound=None,upper_bound=None,flag_values=_flagvalues.FLAGS,**args)", "summary": "Registers a flag whose value must be an integer.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_integer", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "string", "description": "int|str|None, the default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "lower_bound", "is_optional": true, "type": "others", "default_value": "None", "description": "int, min value of the flag."}, {"name": "upper_bound", "is_optional": true, "type": "others", "default_value": "None", "description": "int, max value of the flag."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to DEFINE."}]}},
{"id": "tf.compat.v1.flags.DEFINE_alias", "type": "function", "code": "tf.compat.v1.flags.DEFINE_alias(name,original_name,flag_values=_flagvalues.FLAGS,module_name=None)", "summary": "Defines an alias flag for an existing one.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_alias", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "original_name", "is_optional": false, "type": "string", "description": "str, the original flag name."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, the name of the module that defines this flag."}]}},
{"id": "tf.compat.v1.flags.DEFINE_enum_class", "type": "function", "code": "tf.compat.v1.flags.DEFINE_enum_class(name,default,enum_class,help,flag_values=_flagvalues.FLAGS,module_name=None,**args)", "summary": "Registers a flag whose value can be the name of enum members.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_enum_class", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "string", "description": "Enum|str|None, the default value of the flag."}, {"name": "enum_class", "is_optional": false, "type": "others", "description": "class, the Enum class with all the possible values for the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "str, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to Flag init."}]}},
{"id": "tf.compat.v1.flags.DEFINE_flag", "type": "function", "code": "tf.compat.v1.flags.DEFINE_flag(flag,flag_values=_flagvalues.FLAGS,module_name=None)", "summary": "Registers a 'Flag' object with a 'FlagValues' object.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE_flag", "parameters": [{"name": "flag", "is_optional": false, "type": "others", "description": "Flag, a flag that is key to the module."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "str, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}]}},
{"id": "tf.compat.v1.flags.CsvListSerializer", "type": "function", "code": "tf.compat.v1.flags.CsvListSerializer(list_sep)", "summary": "Base class for generating string representations of a flag value.\n\nInherits From: ArgumentSerializer", "description": "", "code-info": {"name": "tf.compat.v1.flags.CsvListSerializer", "parameters": [{"name": "list_sep", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.DEFINE", "type": "function", "code": "tf.compat.v1.flags.DEFINE(parser,name,default,help,flag_values=_flagvalues.FLAGS,serializer=None,module_name=None,**args)", "summary": "Registers a generic Flag object.", "description": "", "code-info": {"name": "tf.compat.v1.flags.DEFINE", "parameters": [{"name": "parser", "is_optional": false, "type": "others", "description": "ArgumentParser, used to parse the flag arguments."}, {"name": "name", "is_optional": false, "type": "string", "description": "str, the flag name."}, {"name": "default", "is_optional": false, "type": "others", "description": "The default value of the flag."}, {"name": "help", "is_optional": false, "type": "string", "description": "str, the help message."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance with which the flag will\nbe registered. This should almost never need to be overridden."}, {"name": "serializer", "is_optional": true, "type": "others", "default_value": "None", "description": "ArgumentSerializer, the flag serializer instance."}, {"name": "module_name", "is_optional": true, "type": "string", "default_value": "None", "description": "str, the name of the Python module declaring this flag.\nIf not provided, it will be computed using the stack trace of this call."}, {"name": "**args", "is_optional": false, "type": "others", "description": "dict, the extra keyword args that are passed to Flag init."}]}},
{"id": "flag_type", "type": "function", "code": "flag_type()", "summary": "Parser of boolean values.\n\nInherits From: ArgumentParser", "description": "", "code-info": {"name": "flag_type", "parameters": []}},
{"id": "tf.compat.v1.flags.declare_key_flag", "type": "function", "code": "tf.compat.v1.flags.declare_key_flag(flag_name,flag_values=_flagvalues.FLAGS)", "summary": "Declares one flag as key to the current module.", "description": "", "code-info": {"name": "tf.compat.v1.flags.declare_key_flag", "parameters": [{"name": "flag_name", "is_optional": false, "type": "string", "description": "str, the name of an already declared flag.\n(Redeclaring flags as key, including flags implicitly key\nbecause they were declared in this module, is a no-op.)"}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance in which the flag will\nbe declared as a key flag. This should almost never need to be\noverridden."}]}},
{"id": "serialize", "type": "function", "code": "serialize(value)", "summary": "Base class for generating string representations of a flag value.", "description": "", "code-info": {"name": "serialize", "parameters": [{"name": "value", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.BaseListParser", "type": "function", "code": "tf.compat.v1.flags.BaseListParser(token=None,name=None)", "summary": "Base class for a parser of lists of strings.\n\nInherits From: ArgumentParser", "description": "", "code-info": {"name": "tf.compat.v1.flags.BaseListParser", "parameters": [{"name": "token", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.flags.BooleanFlag", "type": "function", "code": "tf.compat.v1.flags.BooleanFlag(name,default,help,short_name=None,**args)", "summary": "Basic boolean flag.\n\nInherits From: Flag", "description": "", "code-info": {"name": "tf.compat.v1.flags.BooleanFlag", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": ""}, {"name": "default", "is_optional": false, "type": "others", "description": ""}, {"name": "help", "is_optional": false, "type": "others", "description": ""}, {"name": "short_name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "**args", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.flags.adopt_module_key_flags", "type": "function", "code": "tf.compat.v1.flags.adopt_module_key_flags(module,flag_values=_flagvalues.FLAGS)", "summary": "Declares that all flags key to a module are key to the current module.", "description": "", "code-info": {"name": "tf.compat.v1.flags.adopt_module_key_flags", "parameters": [{"name": "module", "is_optional": false, "type": "others", "description": "module, the module object from which all key flags will be declared\nas key flags to the current module."}, {"name": "flag_values", "is_optional": true, "type": "others", "default_value": "_flagvalues.FLAGS", "description": "FlagValues, the FlagValues instance in which the flags will\nbe declared as key flags. This should almost never need to be\noverridden."}]}},
{"id": "tf.compat.v1.feature_column.shared_embedding_columns", "type": "function", "code": "tf.compat.v1.feature_column.shared_embedding_columns(categorical_columns,dimension,combiner='mean',initializer=None,shared_embedding_collection_name=None,ckpt_to_load_from=None,tensor_name_in_ckpt=None,max_norm=None,trainable=True)", "summary": "List of dense columns that convert from sparse, categorical input.", "description": "", "code-info": {"name": "tf.compat.v1.feature_column.shared_embedding_columns", "parameters": [{"name": "categorical_columns", "is_optional": false, "type": "others", "description": "List of categorical columns created by a\ncategorical_column_with_* function. These columns produce the sparse IDs\nthat are inputs to the embedding lookup. All columns must be of the same\ntype and have the same arguments except key. E.g. they can be\ncategorical_column_with_vocabulary_file with the same vocabulary_file.\nSome or all columns could also be weighted_categorical_column."}, {"name": "dimension", "is_optional": false, "type": "int", "description": "An integer specifying dimension of the embedding, must be &gt; 0."}, {"name": "combiner", "is_optional": true, "type": "string", "default_value": "'mean'", "description": "A string specifying how to reduce if there are multiple entries in\na single row. Currently 'mean', 'sqrtn' and 'sum' are supported, with\n'mean' the default. 'sqrtn' often achieves good accuracy, in particular\nwith bag-of-words columns. Each of this can be thought as example level\nnormalizations on the column. For more information, see\ntf.embedding_lookup_sparse."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "A variable initializer function to be used in embedding\nvariable initialization. If not specified, defaults to\ntruncated_normal_initializer with mean 0.0 and\nstandard deviation 1/sqrt(dimension)."}, {"name": "shared_embedding_collection_name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name of the collection where\nshared embedding weights are added. If not given, a reasonable name will\nbe chosen based on the names of categorical_columns. This is also used\nin variable_scope when creating shared embedding weights."}, {"name": "ckpt_to_load_from", "is_optional": true, "type": "string", "default_value": "None", "description": "String representing checkpoint name/pattern from which to\nrestore column weights. Required if tensor_name_in_ckpt is not None."}, {"name": "tensor_name_in_ckpt", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Name of the Tensor in ckpt_to_load_from from which\nto restore the column weights. Required if ckpt_to_load_from is not\nNone."}, {"name": "max_norm", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, each embedding is clipped if its l2-norm is larger\nthan this value, before combining."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether or not the embedding is trainable. Default is True."}]}},
{"id": "tf.compat.v1.feature_column.make_parse_example_spec", "type": "function", "code": "tf.compat.v1.feature_column.make_parse_example_spec(feature_columns)", "summary": "Creates parsing spec dictionary from input feature_columns.", "description": "", "code-info": {"name": "tf.compat.v1.feature_column.make_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from _FeatureColumn."}]}},
{"id": "tf.compat.v1.feature_column.linear_model", "type": "function", "code": "tf.compat.v1.feature_column.linear_model(features,feature_columns,units=1,sparse_combiner='sum',weight_collections=None,trainable=True,cols_to_vars=None)", "summary": "Returns a linear prediction Tensor based on given feature_columns.", "description": "", "code-info": {"name": "tf.compat.v1.feature_column.linear_model", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A mapping from key to tensors. _FeatureColumns look up via these\nkeys. For example numeric_column('price') will look at 'price' key in\nthis dict. Values are Tensor or SparseTensor depending on\ncorresponding _FeatureColumn."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns to use as inputs\nto your model. All items should be instances of classes derived from\n_FeatureColumns."}, {"name": "units", "is_optional": true, "type": "int", "default_value": "1", "description": "An integer, dimensionality of the output space. Default value is 1."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent. Except numeric_column, almost all columns passed to\nlinear_model are considered as categorical columns.  It combines each\ncategorical column independently. Currently \"mean\", \"sqrtn\" and \"sum\" are\nsupported, with \"sum\" the default for linear model. \"sqrtn\" often achieves\ngood accuracy, in particular with bag-of-words columns.\n\n\"sum\": do not normalize features in the column\n\"mean\": do l1 normalization on features in the column\n\"sqrtn\": do l2 normalization on features in the column\n"}, {"name": "weight_collections", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of collection names to which the Variable will be\nadded. Note that, variables will also be added to collections\ntf.GraphKeys.GLOBAL_VARIABLES and ops.GraphKeys.MODEL_VARIABLES."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True also add the variable to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable)."}, {"name": "cols_to_vars", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, must be a dictionary that will be filled with a\nmapping from _FeatureColumn to associated list of Variables.  For\nexample, after the call, we might have cols_to_vars = {\n_NumericColumn(\n  key='numeric_feature1', shape=(1,):\n[],\n'bias': [],\n_NumericColumn(\n  key='numeric_feature2', shape=(2,)):\n[]}\nIf a column creates no variables, its value will be an empty list. Note\nthat cols_to_vars will also contain a string key 'bias' that maps to a\nlist of Variables."}]}},
{"id": "flag_type", "type": "function", "code": "flag_type()", "summary": "Base class used to parse and convert arguments.", "description": "", "code-info": {"name": "flag_type", "parameters": []}},
{"id": "tf.compat.v1.experimental.output_all_intermediates", "type": "function", "code": "tf.compat.v1.experimental.output_all_intermediates(state)", "summary": "Whether to output all intermediates from functional control flow ops.", "description": "", "code-info": {"name": "tf.compat.v1.experimental.output_all_intermediates", "parameters": [{"name": "state", "is_optional": false, "type": "others", "description": "True, False or None. None restores the default behavior."}]}},
{"id": "tf.compat.v1.feature_column.input_layer", "type": "function", "code": "tf.compat.v1.feature_column.input_layer(features,feature_columns,weight_collections=None,trainable=True,cols_to_vars=None,cols_to_output_tensors=None)", "summary": "Returns a dense Tensor as input layer based on given feature_columns.", "description": "", "code-info": {"name": "tf.compat.v1.feature_column.input_layer", "parameters": [{"name": "features", "is_optional": false, "type": "tensor", "description": "A mapping from key to tensors. _FeatureColumns look up via these\nkeys. For example numeric_column('price') will look at 'price' key in\nthis dict. Values can be a SparseTensor or a Tensor depends on\ncorresponding _FeatureColumn."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing the FeatureColumns to use as inputs\nto your model. All items should be instances of classes derived from\n_DenseColumn such as numeric_column, embedding_column,\nbucketized_column, indicator_column. If you have categorical features,\nyou can wrap them with an embedding_column or indicator_column."}, {"name": "weight_collections", "is_optional": true, "type": "string", "default_value": "None", "description": "A list of collection names to which the Variable will be\nadded. Note that variables will also be added to collections\ntf.GraphKeys.GLOBAL_VARIABLES and ops.GraphKeys.MODEL_VARIABLES."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True also add the variable to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable)."}, {"name": "cols_to_vars", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, must be a dictionary that will be filled with a\nmapping from _FeatureColumn to list of Variables.  For example, after\nthe call, we might have cols_to_vars =\n{_EmbeddingColumn(\ncategorical_column=_HashedCategoricalColumn(\n  key='sparse_feature', hash_bucket_size=5, dtype=tf.string),\ndimension=10): [&lt;tf.Variable 'some_variable:0' shape=(5, 10),\n                &lt;tf.Variable 'some_variable:1' shape=(5, 10)]}\nIf a column creates no variables, its value will be an empty list."}, {"name": "cols_to_output_tensors", "is_optional": true, "type": "others", "default_value": "None", "description": "If not None, must be a dictionary that will be\nfilled with a mapping from '_FeatureColumn' to the associated\noutput Tensors."}]}},
{"id": "tf.compat.v1.feature_column.categorical_column_with_vocabulary_file", "type": "function", "code": "tf.compat.v1.feature_column.categorical_column_with_vocabulary_file(key,vocabulary_file,vocabulary_size=None,num_oov_buckets=0,default_value=None,dtype=tf.dtypes.string)", "summary": "A CategoricalColumn with a vocabulary file.", "description": "", "code-info": {"name": "tf.compat.v1.feature_column.categorical_column_with_vocabulary_file", "parameters": [{"name": "key", "is_optional": false, "type": "string", "description": "A unique string identifying the input feature. It is used as the\ncolumn name and the dictionary key for feature parsing configs, feature\nTensor objects, and feature columns."}, {"name": "vocabulary_file", "is_optional": false, "type": "string", "description": "The vocabulary file name."}, {"name": "vocabulary_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of the elements in the vocabulary. This must be no\ngreater than length of vocabulary_file, if less than length, later\nvalues are ignored. If None, it is set to the length of vocabulary_file."}, {"name": "num_oov_buckets", "is_optional": true, "type": "int", "default_value": "0", "description": "Non-negative integer, the number of out-of-vocabulary\nbuckets. All out-of-vocabulary inputs will be assigned IDs in the range\n[vocabulary_size, vocabulary_size+num_oov_buckets) based on a hash of\nthe input value. A positive num_oov_buckets can not be specified with\ndefault_value."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "None", "description": "The integer ID value to return for out-of-vocabulary feature\nvalues, defaults to -1. This can not be specified with a positive\nnum_oov_buckets."}, {"name": "dtype", "is_optional": true, "type": "int", "default_value": "tf.dtypes.string", "description": "The type of features. Only string and integer types are supported."}]}},
{"id": "tf.compat.v1.estimator.tpu.TPUEstimator", "type": "class", "code": "tf.compat.v1.estimator.tpu.TPUEstimator(model_fn=None,model_dir=None,config=None,params=None,use_tpu=True,train_batch_size=None,eval_batch_size=None,predict_batch_size=None,batch_axis=None,eval_on_tpu=True,export_to_tpu=True,export_to_cpu=True,warm_start_from=None,embedding_config_spec=None,export_saved_model_api_version=ExportSavedModelApiVersion.V1)", "summary": "Estimator with TPU support.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.tpu.TPUEstimator", "parameters": [{"name": "model_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "Model function as required by Estimator which returns\nEstimatorSpec or TPUEstimatorSpec. training_hooks, 'evaluation_hooks',\nand prediction_hooks must not capure any TPU Tensor inside the\nmodel_fn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator to\ncontinue training a previously saved model. If None, the model_dir in\nconfig will be used if set. If both are set, they must be same. If\nboth are None, a temporary directory will be used."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "An tpu_config.RunConfig configuration object. Cannot be None."}, {"name": "params", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional dict of hyper parameters that will be passed into\ninput_fn and model_fn.  Keys are names of parameters, values are\nbasic python types. There are reserved keys for TPUEstimator,\nincluding 'batch_size'."}, {"name": "use_tpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool indicating whether TPU support is enabled. Currently, -\nTPU training and evaluation respect this bit, but eval_on_tpu can\noverride execution of eval. See below."}, {"name": "train_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int representing the global training batch size.\nTPUEstimator transforms this global batch size to a per-shard batch\nsize, as params['batch_size'], when calling input_fn and model_fn.\nCannot be None if use_tpu is True. Must be divisible by total\nnumber of replicas."}, {"name": "eval_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int representing evaluation batch size. Must be\ndivisible by total number of replicas."}, {"name": "predict_batch_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int representing the prediction batch size. Must be\ndivisible by total number of replicas."}, {"name": "batch_axis", "is_optional": true, "type": "others", "default_value": "None", "description": "A python tuple of int values describing how each tensor\nproduced by the Estimator input_fn should be split across the TPU\ncompute shards. For example, if your input_fn produced (images, labels)\nwhere the images tensor is in HWCN format, your shard dimensions would\nbe [3, 0], where 3 corresponds to the N dimension of your images\nTensor, and 0 corresponds to the dimension along which to split the\nlabels to match up with the corresponding images. If None is supplied,\nand per_host_input_for_training is True, batches will be sharded based\non the major dimension. If tpu_config.per_host_input_for_training is\nFalse or PER_HOST_V2, batch_axis is ignored."}, {"name": "eval_on_tpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "If False, evaluation runs on CPU or GPU. In this case, the\nmodel_fn must return EstimatorSpec when called with mode as EVAL."}, {"name": "export_to_tpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, export_saved_model() exports a metagraph for\nserving on TPU. Note that unsupported export modes such as EVAL will be\nignored. For those modes, only a CPU model will be exported.\nCurrently, export_to_tpu only supports PREDICT."}, {"name": "export_to_cpu", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, export_saved_model() exports a metagraph for\nserving on CPU."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string filepath to a checkpoint or SavedModel to\nwarm-start from, or a tf.estimator.WarmStartSettings object to fully\nconfigure warm-starting.  If the string filepath is provided instead of\na WarmStartSettings, then all variables are warm-started, and it is\nassumed that vocabularies and Tensor names are unchanged."}, {"name": "embedding_config_spec", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional EmbeddingConfigSpec instance\nto support using TPU embedding."}, {"name": "export_saved_model_api_version", "is_optional": true, "type": "others", "default_value": "ExportSavedModelApiVersion.V1", "description": "ExportSavedModelApiVersion, V1 or V2.\nWith V1, export_saved_model() adds rewrite() and TPUPartitionedCallOp()\nfor user; while in v2, user is expected to add rewrite(),\nTPUPartitionedCallOp() etc in their model_fn.\nA helper function inference_on_tpu is provided for V2.\nbrn_tpu_estimator.py includes examples for both versions\ni.e. TPUEstimatorExportTest and TPUEstimatorExportV2Test."}]}},
{"id": "tf.compat.v1.estimator.inputs.pandas_input_fn", "type": "function", "code": "tf.compat.v1.estimator.inputs.pandas_input_fn(x,y=None,batch_size=128,num_epochs=1,shuffle=None,queue_capacity=1000,num_threads=1,target_column='target')", "summary": "Returns input function that would feed Pandas DataFrame into the model.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.inputs.pandas_input_fn", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "pandas DataFrame object."}, {"name": "y", "is_optional": true, "type": "others", "default_value": "None", "description": "pandas Series object or DataFrame. None if absent."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "128", "description": "int, size of batches to return."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "1", "description": "int, number of epochs to iterate over data. If not None,\nread attempts that would exceed this value will raise OutOfRangeError."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "None", "description": "bool, whether to read the records in random order."}, {"name": "queue_capacity", "is_optional": true, "type": "int", "default_value": "1000", "description": "int, size of the read queue. If None, it will be set\nroughly to the size of x."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "Integer, number of threads used for reading and enqueueing. In\norder to have predicted and repeatable order of reading and enqueueing,\nsuch as in prediction and evaluation mode, num_threads should be 1."}, {"name": "target_column", "is_optional": true, "type": "string", "default_value": "'target'", "description": "str, name to give the target column y. This parameter\nis not used when y is a DataFrame."}]}},
{"id": "tf.compat.v1.estimator.tpu.RunConfig", "type": "class", "code": "tf.compat.v1.estimator.tpu.RunConfig(tpu_config=None,evaluation_master=None,master=None,cluster=None,**kwargs)", "summary": "RunConfig with TPU support.\n\nInherits From: RunConfig", "description": "", "code-info": {"name": "tf.compat.v1.estimator.tpu.RunConfig", "parameters": [{"name": "tpu_config", "is_optional": true, "type": "others", "default_value": "None", "description": "the TPUConfig that specifies TPU-specific configuration."}, {"name": "evaluation_master", "is_optional": true, "type": "string", "default_value": "None", "description": "a string. The address of the master to use for eval.\nDefaults to master if not set."}, {"name": "master", "is_optional": true, "type": "string", "default_value": "None", "description": "a string. The address of the master to use for training."}, {"name": "cluster", "is_optional": true, "type": "others", "default_value": "None", "description": "a ClusterResolver"}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "keyword config parameters."}]}},
{"id": "tf.compat.v1.estimator.inputs.numpy_input_fn", "type": "function", "code": "tf.compat.v1.estimator.inputs.numpy_input_fn(x,y=None,batch_size=128,num_epochs=1,shuffle=None,queue_capacity=1000,num_threads=1)", "summary": "Returns input function that would feed dict of numpy arrays into the model.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.inputs.numpy_input_fn", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "numpy array object or dict of numpy array objects. If an array,\nthe array will be treated as a single feature."}, {"name": "y", "is_optional": true, "type": "others", "default_value": "None", "description": "numpy array object or dict of numpy array object. None if absent."}, {"name": "batch_size", "is_optional": true, "type": "int", "default_value": "128", "description": "Integer, size of batches to return."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "1", "description": "Integer, number of epochs to iterate over data. If None will\nrun forever."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "None", "description": "Boolean, if True shuffles the queue. Avoid shuffle at prediction\ntime."}, {"name": "queue_capacity", "is_optional": true, "type": "int", "default_value": "1000", "description": "Integer, size of queue to accumulate."}, {"name": "num_threads", "is_optional": true, "type": "int", "default_value": "1", "description": "Integer, number of threads used for reading and enqueueing. In\norder to have predicted and repeatable order of reading and enqueueing,\nsuch as in prediction and evaluation mode, num_threads should be 1."}]}},
{"id": "tf.compat.v1.estimator.experimental.linear_logit_fn_builder", "type": "function", "code": "tf.compat.v1.estimator.experimental.linear_logit_fn_builder(units,feature_columns,sparse_combiner='sum')", "summary": "Function builder for a linear logit_fn.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.experimental.linear_logit_fn_builder", "parameters": [{"name": "units", "is_optional": false, "type": "others", "description": "An int indicating the dimension of the logit layer."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent.  One of \"mean\", \"sqrtn\", and \"sum\"."}]}},
{"id": "tf.compat.v1.estimator.LinearRegressor", "type": "class", "code": "tf.compat.v1.estimator.LinearRegressor(feature_columns,model_dir=None,label_dimension=1,weight_column=None,optimizer='Ftrl',config=None,partitioner=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear regression problems.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.LinearRegressor", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": ""}]}},
{"id": "tf.compat.v1.estimator.regressor_parse_example_spec", "type": "function", "code": "tf.compat.v1.estimator.regressor_parse_example_spec(feature_columns,label_key,label_dtype=tf.dtypes.float32,label_default=None,label_dimension=1,weight_column=None)", "summary": "Generates parsing spec for tf.parse_example to be used with regressors.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.regressor_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from _FeatureColumn."}, {"name": "label_key", "is_optional": false, "type": "string", "description": "A string identifying the label. It means tf.Example stores labels\nwith this key."}, {"name": "label_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "A tf.dtype identifies the type of labels. By default it is\ntf.float32."}, {"name": "label_default", "is_optional": true, "type": "others", "default_value": "None", "description": "used as label if label_key does not exist in given\ntf.Example. By default default_value is none, which means\ntf.parse_example will error out if there is any missing label."}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": "Number of regression targets per example. This is the\nsize of the last dimension of the labels and logits Tensor objects\n(typically, these have shape [batch_size, label_dimension])."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}]}},
{"id": "tf.compat.v1.estimator.experimental.dnn_logit_fn_builder", "type": "function", "code": "tf.compat.v1.estimator.experimental.dnn_logit_fn_builder(units,hidden_units,feature_columns,activation_fn,dropout,input_layer_partitioner,batch_norm)", "summary": "Function builder for a dnn logit_fn.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.experimental.dnn_logit_fn_builder", "parameters": [{"name": "units", "is_optional": false, "type": "others", "description": "An int indicating the dimension of the logit layer.  In the\nMultiHead case, this should be the sum of all component Heads' logit\ndimensions."}, {"name": "hidden_units", "is_optional": false, "type": "int", "description": "Iterable of integer number of hidden units per layer."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "Iterable of feature_column._FeatureColumn model inputs."}, {"name": "activation_fn", "is_optional": false, "type": "others", "description": "Activation function applied to each layer."}, {"name": "dropout", "is_optional": false, "type": "others", "description": "When not None, the probability we will drop out a given\ncoordinate."}, {"name": "input_layer_partitioner", "is_optional": false, "type": "others", "description": "Partitioner for input layer."}, {"name": "batch_norm", "is_optional": false, "type": "others", "description": "Whether to use batch normalization after each hidden layer."}]}},
{"id": "tf.compat.v1.estimator.Estimator", "type": "class", "code": "tf.compat.v1.estimator.Estimator(model_fn,model_dir=None,config=None,params=None,warm_start_from=None)", "summary": "Estimator class to train and evaluate TensorFlow models.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.Estimator", "parameters": [{"name": "model_fn", "is_optional": false, "type": "others", "description": "Model function. Follows the signature:\n\n\nArgs:\nfeatures: This is the first item returned from the input_fn\n   passed to train, evaluate, and predict. This should be a\n   single tf.Tensor or dict of same.\nlabels: This is the second item returned from the input_fn\n   passed to train, evaluate, and predict. This should be a\n   single tf.Tensor or dict of same (for multi-head models).\n   If mode is tf.estimator.ModeKeys.PREDICT, labels=None will\n   be passed. If the model_fn's signature does not accept\n   mode, the model_fn must still be able to handle\n   labels=None.\nmode: Optional. Specifies if this is training, evaluation or\n   prediction. See tf.estimator.ModeKeys.\nparams: Optional dict of hyperparameters.  Will receive what\n   is passed to Estimator in params parameter. This allows\n   to configure Estimators from hyper parameter tuning.\nconfig: Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n"}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "params", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional dict of hyperparameters.  Will receive what\n   is passed to Estimator in params parameter. This allows\n   to configure Estimators from hyper parameter tuning.\nconfig: Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used.\nconfig: estimator.RunConfig configuration object."}, {"name": "warm_start_from", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string filepath to a checkpoint or SavedModel to\n             warm-start from, or a tf.estimator.WarmStartSettings\n             object to fully configure warm-starting.\n         If None, only TRAINABLE variables are warm-started."}]}},
{"id": "tf.compat.v1.estimator.DNNLinearCombinedRegressor", "type": "class", "code": "tf.compat.v1.estimator.DNNLinearCombinedRegressor(model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,label_dimension=1,weight_column=None,input_layer_partitioner=None,config=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,batch_norm=False,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined models for regression.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNLinearCombinedRegressor", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": ""}]}},
{"id": "tf.compat.v1.estimator.DNNRegressor", "type": "class", "code": "tf.compat.v1.estimator.DNNRegressor(hidden_units,feature_columns,model_dir=None,label_dimension=1,weight_column=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,input_layer_partitioner=None,config=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,batch_norm=False)", "summary": "A regressor for TensorFlow DNN models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNRegressor", "parameters": [{"name": "hidden_units", "is_optional": false, "type": "others", "description": ""}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.estimator.LinearClassifier", "type": "class", "code": "tf.compat.v1.estimator.LinearClassifier(feature_columns,model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Ftrl',config=None,partitioner=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,sparse_combiner='sum')", "summary": "Linear classifier model.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.LinearClassifier", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_vocabulary", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": ""}]}},
{"id": "tf.compat.v1.estimator.experimental.KMeans", "type": "class", "code": "tf.compat.v1.estimator.experimental.KMeans(num_clusters,model_dir=None,initial_clusters=RANDOM_INIT,distance_metric=SQUARED_EUCLIDEAN_DISTANCE,seed=None,use_mini_batch=True,mini_batch_steps_per_iteration=1,kmeans_plus_plus_num_retries=2,relative_tolerance=None,config=None,feature_columns=None)", "summary": "An Estimator for K-Means clustering.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.experimental.KMeans", "parameters": [{"name": "num_clusters", "is_optional": false, "type": "tensor", "description": "An integer tensor specifying the number of clusters. This\nargument is ignored if initial_clusters is a tensor or numpy array."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "The directory to save the model results and log files."}, {"name": "initial_clusters", "is_optional": true, "type": "others", "default_value": "RANDOM_INIT", "description": "Specifies how the initial cluster centers are chosen.\nOne of the following: * a tensor or numpy array with the initial cluster\ncenters. * a callable f(inputs, k) that selects and returns up to\nk centers from an input batch. f is free to return any number of\ncenters from 0 to k. It will be invoked on successive input\nbatches as necessary until all num_clusters centers are chosen.\n\nKMeansClustering.RANDOM_INIT: Choose centers randomly from an input\nbatch. If the batch size is less than num_clusters then the entire\nbatch is chosen to be initial cluster centers and the remaining\ncenters are chosen from successive input batches.\nKMeansClustering.KMEANS_PLUS_PLUS_INIT: Use kmeans++ to choose\ncenters from the first input batch. If the batch size is less than\nnum_clusters, a TensorFlow runtime error occurs.\n"}, {"name": "distance_metric", "is_optional": true, "type": "others", "default_value": "SQUARED_EUCLIDEAN_DISTANCE", "description": "The distance metric used for clustering. One of:\n\nKMeansClustering.SQUARED_EUCLIDEAN_DISTANCE: Euclidean distance\nbetween vectors u and v is defined as \\(||u - v||_2\\) which is\nthe square root of the sum of the absolute squares of the elements'\ndifference.\nKMeansClustering.COSINE_DISTANCE: Cosine distance between vectors\nu and v is defined as \\(1 - (u . v) / (||u||_2 ||v||_2)\\).\n"}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "Python integer. Seed for PRNG used to initialize centers."}, {"name": "use_mini_batch", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean specifying whether to use the mini-batch k-means\nalgorithm. See explanation above."}, {"name": "mini_batch_steps_per_iteration", "is_optional": true, "type": "int", "default_value": "1", "description": "The number of steps after which the\nupdated cluster centers are synced back to a master copy. Used only if\nuse_mini_batch=True. See explanation above."}, {"name": "kmeans_plus_plus_num_retries", "is_optional": true, "type": "int", "default_value": "2", "description": "For each point that is sampled during\nkmeans++ initialization, this parameter specifies the number of\nadditional points to draw from the current distribution before selecting\nthe best. If a negative value is specified, a heuristic is used to\nsample O(log(num_to_sample)) additional points. Used only if\ninitial_clusters=KMeansClustering.KMEANS_PLUS_PLUS_INIT."}, {"name": "relative_tolerance", "is_optional": true, "type": "others", "default_value": "None", "description": "A relative tolerance of change in the loss between\niterations. Stops learning if the loss changes less than this amount.\nThis may not work correctly if use_mini_batch=True."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "See tf.estimator.Estimator."}, {"name": "feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": "An optionable iterable containing all the feature columns\nused by the model. All items in the set should be feature column\ninstances that can be passed to tf.feature_column.input_layer. If this\nis None, all features will be used."}]}},
{"id": "tf.compat.v1.estimator.LinearEstimator", "type": "class", "code": "tf.compat.v1.estimator.LinearEstimator(head,feature_columns,model_dir=None,optimizer='Ftrl',config=None,partitioner=None,sparse_combiner='sum')", "summary": "An estimator for TensorFlow linear models with user-specified head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.LinearEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "string", "description": "A _Head instance constructed with a method such as\ntf.contrib.estimator.multi_label_head."}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all the feature columns used by\nthe model. All items in the set should be instances of classes derived\nfrom FeatureColumn."}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": "Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into a estimator\nto continue training a previously saved model."}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": "An instance of tf.Optimizer used to train the model. Can also\nbe a string (one of 'Adagrad', 'Adam', 'Ftrl', 'RMSProp', 'SGD'), or\ncallable. Defaults to FTRL optimizer."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "RunConfig object to configure the runtime settings."}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. Partitioner for input layer."}, {"name": "sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": "A string specifying how to reduce if a categorical column\nis multivalent.  One of \"mean\", \"sqrtn\", and \"sum\" -- these are\neffectively different ways to do example-level normalization, which can\nbe useful for bag-of-words features. for more details, see\ntf.feature_column.linear_model."}]}},
{"id": "tf.compat.v1.estimator.DNNLinearCombinedEstimator", "type": "class", "code": "tf.compat.v1.estimator.DNNLinearCombinedEstimator(head,model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,input_layer_partitioner=None,config=None,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined models with custom head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNLinearCombinedEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": ""}]}},
{"id": "tf.compat.v1.estimator.DNNLinearCombinedClassifier", "type": "class", "code": "tf.compat.v1.estimator.DNNLinearCombinedClassifier(model_dir=None,linear_feature_columns=None,linear_optimizer='Ftrl',dnn_feature_columns=None,dnn_optimizer='Adagrad',dnn_hidden_units=None,dnn_activation_fn=tf.nn.relu,dnn_dropout=None,n_classes=2,weight_column=None,label_vocabulary=None,input_layer_partitioner=None,config=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,batch_norm=False,linear_sparse_combiner='sum')", "summary": "An estimator for TensorFlow Linear and DNN joined classification models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNLinearCombinedClassifier", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "linear_optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "dnn_feature_columns", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "dnn_hidden_units", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dnn_activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dnn_dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_vocabulary", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "linear_sparse_combiner", "is_optional": true, "type": "string", "default_value": "'sum'", "description": ""}]}},
{"id": "tf.compat.v1.estimator.DNNEstimator", "type": "class", "code": "tf.compat.v1.estimator.DNNEstimator(head,hidden_units,feature_columns,model_dir=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,input_layer_partitioner=None,config=None,warm_start_from=None,batch_norm=False)", "summary": "An estimator for TensorFlow DNN models with user-specified head.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "others", "description": ""}, {"name": "hidden_units", "is_optional": false, "type": "others", "description": ""}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.estimator.DNNClassifier", "type": "class", "code": "tf.compat.v1.estimator.DNNClassifier(hidden_units,feature_columns,model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Adagrad',activation_fn=tf.nn.relu,dropout=None,input_layer_partitioner=None,config=None,warm_start_from=None,loss_reduction=losses.Reduction.SUM,batch_norm=False)", "summary": "A classifier for TensorFlow DNN models.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.DNNClassifier", "parameters": [{"name": "hidden_units", "is_optional": false, "type": "others", "description": ""}, {"name": "feature_columns", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_vocabulary", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Adagrad'", "description": ""}, {"name": "activation_fn", "is_optional": true, "type": "others", "default_value": "tf.nn.relu", "description": ""}, {"name": "dropout", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input_layer_partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec\n\nmodel_dir: Directory to save model parameters, graph and etc. This can\nalso be used to load checkpoints from the directory into an estimator to\ncontinue training a previously saved model. If PathLike object, the\npath will be resolved. If None, the model_dir in config will be used\nif set. If both are set, they must be same. If both are None, a\ntemporary directory will be used."}, {"name": "warm_start_from", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}, {"name": "batch_norm", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.estimator.classifier_parse_example_spec", "type": "function", "code": "tf.compat.v1.estimator.classifier_parse_example_spec(feature_columns,label_key,label_dtype=tf.dtypes.int64,label_default=None,weight_column=None)", "summary": "Generates parsing spec for tf.parse_example to be used with classifiers.", "description": "", "code-info": {"name": "tf.compat.v1.estimator.classifier_parse_example_spec", "parameters": [{"name": "feature_columns", "is_optional": false, "type": "others", "description": "An iterable containing all feature columns. All items\nshould be instances of classes derived from FeatureColumn."}, {"name": "label_key", "is_optional": false, "type": "string", "description": "A string identifying the label. It means tf.Example stores labels\nwith this key."}, {"name": "label_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "A tf.dtype identifies the type of labels. By default it is\ntf.int64. If user defines a label_vocabulary, this should be set as\ntf.string. tf.float32 labels are only supported for binary\nclassification."}, {"name": "label_default", "is_optional": true, "type": "others", "default_value": "None", "description": "used as label if label_key does not exist in given\ntf.Example. An example usage: let's say label_key is 'clicked' and\ntf.Example contains clicked data only for positive examples in following\nformat key:clicked, value:1. This means that if there is no data with\nkey 'clicked' it should count as negative example by setting\nlabel_deafault=0. Type of this value should be compatible with\nlabel_dtype."}, {"name": "weight_column", "is_optional": true, "type": "string", "default_value": "None", "description": "A string or a NumericColumn created by\ntf.feature_column.numeric_column defining feature column representing\nweights. It is used to down weight or boost examples during training. It\nwill be multiplied by the loss of the example. If it is a string, it is\nused as a key to fetch weight tensor from the features. If it is a\nNumericColumn, raw tensor is fetched by key weight_column.key,\nthen weight_column.normalizer_fn is applied on it to get weight tensor."}]}},
{"id": "tf.compat.v1.estimator.BaselineRegressor", "type": "class", "code": "tf.compat.v1.estimator.BaselineRegressor(model_dir=None,label_dimension=1,weight_column=None,optimizer='Ftrl',config=None,loss_reduction=losses.Reduction.SUM)", "summary": "A regressor that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.BaselineRegressor", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_dimension", "is_optional": true, "type": "int", "default_value": "1", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}]}},
{"id": "tf.compat.v1.estimator.BaselineEstimator", "type": "class", "code": "tf.compat.v1.estimator.BaselineEstimator(head,model_dir=None,optimizer='Ftrl',config=None)", "summary": "An estimator that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.BaselineEstimator", "parameters": [{"name": "head", "is_optional": false, "type": "others", "description": ""}, {"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional estimator.RunConfig object. Will receive what\n   is passed to Estimator as its config parameter, or a default\n   value. Allows setting up things in your model_fn based on\n   configuration such as num_ps_replicas, or model_dir.\nReturns:\ntf.estimator.EstimatorSpec"}]}},
{"id": "tf.compat.v1.estimator.BaselineClassifier", "type": "class", "code": "tf.compat.v1.estimator.BaselineClassifier(model_dir=None,n_classes=2,weight_column=None,label_vocabulary=None,optimizer='Ftrl',config=None,loss_reduction=losses.Reduction.SUM)", "summary": "A classifier that can establish a simple baseline.\n\nInherits From: Estimator", "description": "", "code-info": {"name": "tf.compat.v1.estimator.BaselineClassifier", "parameters": [{"name": "model_dir", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "n_classes", "is_optional": true, "type": "int", "default_value": "2", "description": ""}, {"name": "weight_column", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "label_vocabulary", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "optimizer", "is_optional": true, "type": "string", "default_value": "'Ftrl'", "description": ""}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "loss_reduction", "is_optional": true, "type": "others", "default_value": "losses.Reduction.SUM", "description": ""}]}},
{"id": "tf.compat.v1.distributions.ReparameterizationType", "type": "function", "code": "tf.compat.v1.distributions.ReparameterizationType(rep_type)", "summary": "Instances of this class represent how sampling is reparameterized.", "description": "", "code-info": {"name": "tf.compat.v1.distributions.ReparameterizationType", "parameters": [{"name": "rep_type", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "__enter__", "type": "function", "code": "__enter__()", "summary": "Context manager to check for C API status.\n\n\n\nMethods\n\n__enter__\n\nView source\n__enter__()\n\n__exit__\n\nView source\n__exit__(\n    type_arg, value_arg, traceback_arg\n)", "description": "", "code-info": {"name": "__enter__", "parameters": []}},
{"id": "tf.compat.v1.errors.error_code_from_exception_type", "type": "function", "code": "tf.compat.v1.errors.error_code_from_exception_type(cls)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.errors.error_code_from_exception_type", "parameters": [{"name": "cls", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.distributions.Uniform", "type": "class", "code": "tf.compat.v1.distributions.Uniform(low=0.0,high=1.0,validate_args=False,allow_nan_stats=True,name='Uniform')", "summary": "Uniform distribution with low and high parameters.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Uniform", "parameters": [{"name": "low", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "Floating point tensor, lower boundary of the output interval. Must\nhave low &lt; high."}, {"name": "high", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "Floating point tensor, upper boundary of the output interval. Must\nhave low &lt; high."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Uniform'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.errors.exception_type_from_error_code", "type": "function", "code": "tf.compat.v1.errors.exception_type_from_error_code(error_code)", "summary": "", "description": "", "code-info": {"name": "tf.compat.v1.errors.exception_type_from_error_code", "parameters": [{"name": "error_code", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.distributions.Multinomial", "type": "class", "code": "tf.compat.v1.distributions.Multinomial(total_count,logits=None,probs=None,validate_args=False,allow_nan_stats=True,name='Multinomial')", "summary": "Multinomial distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Multinomial", "parameters": [{"name": "total_count", "is_optional": false, "type": "tensor", "description": "Non-negative floating point tensor with shape broadcastable\nto [N1,..., Nm] with m &gt;= 0. Defines this as a batch of\nN1 x ... x Nm different Multinomial distributions. Its components\nshould be equal to integer values."}, {"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Floating point tensor representing unnormalized log-probabilities\nof a positive event with shape broadcastable to\n[N1,..., Nm, K] m &gt;= 0, and the same dtype as total_count. Defines\nthis as a batch of N1 x ... x Nm different K class Multinomial\ndistributions. Only one of logits or probs should be passed in."}, {"name": "probs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Positive floating point tensor with shape broadcastable to\n[N1,..., Nm, K] m &gt;= 0 and same dtype as total_count. Defines\nthis as a batch of N1 x ... x Nm different K class Multinomial\ndistributions. probs's components in the last portion of its shape\nshould sum to 1. Only one of logits or probs should be passed in."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Multinomial'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.RegisterKL", "type": "function", "code": "tf.compat.v1.distributions.RegisterKL(dist_cls_a,dist_cls_b)", "summary": "Decorator to register a KL divergence implementation function.", "description": "", "code-info": {"name": "tf.compat.v1.distributions.RegisterKL", "parameters": [{"name": "dist_cls_a", "is_optional": false, "type": "others", "description": "the class of the first argument of the KL divergence."}, {"name": "dist_cls_b", "is_optional": false, "type": "others", "description": "the class of the second argument of the KL divergence."}]}},
{"id": "tf.compat.v1.distributions.StudentT", "type": "class", "code": "tf.compat.v1.distributions.StudentT(df,loc,scale,validate_args=False,allow_nan_stats=True,name='StudentT')", "summary": "Student's t-distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.StudentT", "parameters": [{"name": "df", "is_optional": false, "type": "tensor", "description": "Floating-point Tensor. The degrees of freedom of the\ndistribution(s). df must contain only positive values."}, {"name": "loc", "is_optional": false, "type": "tensor", "description": "Floating-point Tensor. The mean(s) of the distribution(s)."}, {"name": "scale", "is_optional": false, "type": "tensor", "description": "Floating-point Tensor. The scaling factor(s) for the\ndistribution(s). Note that scale is not technically the standard\ndeviation of this distribution but has semantics more similar to\nstandard deviation than variance."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True,\nstatistics (e.g., mean, mode, variance) use the value \"NaN\" to\nindicate the result is undefined. When False, an exception is raised\nif one or more of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'StudentT'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Exponential", "type": "class", "code": "tf.compat.v1.distributions.Exponential(rate,validate_args=False,allow_nan_stats=True,name='Exponential')", "summary": "Exponential distribution.\n\nInherits From: Gamma", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Exponential", "parameters": [{"name": "rate", "is_optional": false, "type": "tensor", "description": "Floating point tensor, equivalent to 1 / mean. Must contain only\npositive values."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Exponential'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.kl_divergence", "type": "function", "code": "tf.compat.v1.distributions.kl_divergence(distribution_a,distribution_b,allow_nan_stats=True,name=None)", "summary": "Get the KL-divergence KL(distribution_a || distribution_b). (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.distributions.kl_divergence", "parameters": [{"name": "distribution_a", "is_optional": false, "type": "string", "description": "The first distribution."}, {"name": "distribution_b", "is_optional": false, "type": "string", "description": "The second distribution."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True,\nstatistics (e.g., mean, mode, variance) use the value \"NaN\" to\nindicate the result is undefined. When False, an exception is raised\nif one or more of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Normal", "type": "class", "code": "tf.compat.v1.distributions.Normal(loc,scale,validate_args=False,allow_nan_stats=True,name='Normal')", "summary": "The Normal distribution with location loc and scale parameters.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Normal", "parameters": [{"name": "loc", "is_optional": false, "type": "tensor", "description": "Floating point tensor; the means of the distribution(s)."}, {"name": "scale", "is_optional": false, "type": "tensor", "description": "Floating point tensor; the stddevs of the distribution(s).\nMust contain only positive values."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True,\nstatistics (e.g., mean, mode, variance) use the value \"NaN\" to\nindicate the result is undefined. When False, an exception is raised\nif one or more of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Normal'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Laplace", "type": "class", "code": "tf.compat.v1.distributions.Laplace(loc,scale,validate_args=False,allow_nan_stats=True,name='Laplace')", "summary": "The Laplace distribution with location loc and scale parameters.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Laplace", "parameters": [{"name": "loc", "is_optional": false, "type": "tensor", "description": "Floating point tensor which characterizes the location (center)\nof the distribution."}, {"name": "scale", "is_optional": false, "type": "tensor", "description": "Positive floating point tensor which characterizes the spread of\nthe distribution."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True,\nstatistics (e.g., mean, mode, variance) use the value \"NaN\" to\nindicate the result is undefined. When False, an exception is raised\nif one or more of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Laplace'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Categorical", "type": "class", "code": "tf.compat.v1.distributions.Categorical(logits=None,probs=None,dtype=tf.dtypes.int32,validate_args=False,allow_nan_stats=True,name='Categorical')", "summary": "Categorical distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Categorical", "parameters": [{"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An N-D Tensor, N &gt;= 1, representing the log probabilities\nof a set of Categorical distributions. The first N - 1 dimensions\nindex into a batch of independent distributions and the last dimension\nrepresents a vector of logits for each class. Only one of logits or\nprobs should be passed in."}, {"name": "probs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An N-D Tensor, N &gt;= 1, representing the probabilities\nof a set of Categorical distributions. The first N - 1 dimensions\nindex into a batch of independent distributions and the last dimension\nrepresents a vector of probabilities for each class. Only one of\nlogits or probs should be passed in."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "The type of the event samples (default: int32)."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Categorical'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Gamma", "type": "class", "code": "tf.compat.v1.distributions.Gamma(concentration,rate,validate_args=False,allow_nan_stats=True,name='Gamma')", "summary": "Gamma distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Gamma", "parameters": [{"name": "concentration", "is_optional": false, "type": "tensor", "description": "Floating point tensor, the concentration params of the\ndistribution(s). Must contain only positive values."}, {"name": "rate", "is_optional": false, "type": "tensor", "description": "Floating point tensor, the inverse scale params of the\ndistribution(s). Must contain only positive values."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Gamma'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Distribution", "type": "class", "code": "tf.compat.v1.distributions.Distribution(dtype,reparameterization_type,validate_args,allow_nan_stats,parameters=None,graph_parents=None,name=None)", "summary": "A generic probability distribution base class.", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Distribution", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": "The type of the event samples. None implies no type-enforcement."}, {"name": "reparameterization_type", "is_optional": false, "type": "string", "description": "Instance of ReparameterizationType.\nIf distributions.FULLY_REPARAMETERIZED, this\nDistribution can be reparameterized in terms of some standard\ndistribution with a function whose Jacobian is constant for the support\nof the standard distribution. If distributions.NOT_REPARAMETERIZED,\nthen no such reparameterization is available."}, {"name": "validate_args", "is_optional": false, "type": "bool", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": false, "type": "bool", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "parameters", "is_optional": true, "type": "others", "default_value": "None", "description": "Python dict of parameters used to instantiate this\nDistribution."}, {"name": "graph_parents", "is_optional": true, "type": "string", "default_value": "None", "description": "Python list of graph prerequisites of this\nDistribution."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Python str name prefixed to Ops created by this class. Default:\nsubclass name."}]}},
{"id": "tf.compat.v1.distributions.DirichletMultinomial", "type": "class", "code": "tf.compat.v1.distributions.DirichletMultinomial(total_count,concentration,validate_args=False,allow_nan_stats=True,name='DirichletMultinomial')", "summary": "Dirichlet-Multinomial compound distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.DirichletMultinomial", "parameters": [{"name": "total_count", "is_optional": false, "type": "tensor", "description": " Non-negative floating point tensor, whose dtype is the same\nas concentration. The shape is broadcastable to [N1,..., Nm] with\nm &gt;= 0. Defines this as a batch of N1 x ... x Nm different\nDirichlet multinomial distributions. Its components should be equal to\ninteger values."}, {"name": "concentration", "is_optional": false, "type": "tensor", "description": "Positive floating point tensor, whose dtype is the\nsame as n with shape broadcastable to [N1,..., Nm, K] m &gt;= 0.\nDefines this as a batch of N1 x ... x Nm different K class Dirichlet\nmultinomial distributions."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'DirichletMultinomial'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Beta", "type": "class", "code": "tf.compat.v1.distributions.Beta(concentration1=None,concentration0=None,validate_args=False,allow_nan_stats=True,name='Beta')", "summary": "Beta distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Beta", "parameters": [{"name": "concentration1", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Positive floating-point Tensor indicating mean\nnumber of successes; aka \"alpha\". Implies self.dtype and\nself.batch_shape, i.e.,\nconcentration1.shape = [N1, N2, ..., Nm] = self.batch_shape."}, {"name": "concentration0", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Positive floating-point Tensor indicating mean\nnumber of failures; aka \"beta\". Otherwise has same semantics as\nconcentration1."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Beta'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Dirichlet", "type": "class", "code": "tf.compat.v1.distributions.Dirichlet(concentration,validate_args=False,allow_nan_stats=True,name='Dirichlet')", "summary": "Dirichlet distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Dirichlet", "parameters": [{"name": "concentration", "is_optional": false, "type": "tensor", "description": "Positive floating-point Tensor indicating mean number\nof class occurrences; aka \"alpha\". Implies self.dtype, and\nself.batch_shape, self.event_shape, i.e., if\nconcentration.shape = [N1, N2, ..., Nm, k] then\nbatch_shape = [N1, N2, ..., Nm] and\nevent_shape = [k]."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True, statistics\n(e.g., mean, mode, variance) use the value \"NaN\" to indicate the\nresult is undefined. When False, an exception is raised if one or\nmore of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Dirichlet'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distributions.Bernoulli", "type": "class", "code": "tf.compat.v1.distributions.Bernoulli(logits=None,probs=None,dtype=tf.dtypes.int32,validate_args=False,allow_nan_stats=True,name='Bernoulli')", "summary": "Bernoulli distribution.\n\nInherits From: Distribution", "description": "", "code-info": {"name": "tf.compat.v1.distributions.Bernoulli", "parameters": [{"name": "logits", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An N-D Tensor representing the log-odds of a 1 event. Each\nentry in the Tensor parametrizes an independent Bernoulli distribution\nwhere the probability of an event is sigmoid(logits). Only one of\nlogits or probs should be passed in."}, {"name": "probs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An N-D Tensor representing the probability of a 1\nevent. Each entry in the Tensor parameterizes an independent\nBernoulli distribution. Only one of logits or probs should be passed\nin."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "The type of the event samples. Default: int32."}, {"name": "validate_args", "is_optional": true, "type": "bool", "default_value": "False", "description": "Python bool, default False. When True distribution\nparameters are checked for validity despite possibly degrading runtime\nperformance. When False invalid inputs may silently render incorrect\noutputs."}, {"name": "allow_nan_stats", "is_optional": true, "type": "bool", "default_value": "True", "description": "Python bool, default True. When True,\nstatistics (e.g., mean, mode, variance) use the value \"NaN\" to\nindicate the result is undefined. When False, an exception is raised\nif one or more of the statistic's batch members are undefined."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Bernoulli'", "description": "Python str name prefixed to Ops created by this class."}]}},
{"id": "tf.compat.v1.distribute.StrategyExtended", "type": "function", "code": "tf.compat.v1.distribute.StrategyExtended(container_strategy)", "summary": "Additional APIs for algorithms that need to be distribution-aware.\n\nInherits From: StrategyExtended", "description": "", "code-info": {"name": "tf.compat.v1.distribute.StrategyExtended", "parameters": [{"name": "container_strategy", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.distribute.Strategy", "type": "function", "code": "tf.compat.v1.distribute.Strategy(extended)", "summary": "A list of devices with a state &amp; compute distribution policy.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.Strategy", "parameters": [{"name": "extended", "is_optional": false, "type": "string", "description": "  tf.distribute.StrategyExtended with additional methods.\nnum_replicas_in_sync:   Returns number of replicas over which gradients are aggregated."}]}},
{"id": "tf.compat.v1.distribute.experimental.ParameterServerStrategy", "type": "function", "code": "tf.compat.v1.distribute.experimental.ParameterServerStrategy(cluster_resolver=None)", "summary": "An asynchronous multi-worker parameter server tf.distribute strategy.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.experimental.ParameterServerStrategy", "parameters": [{"name": "cluster_resolver", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.distribute.experimental.CentralStorageStrategy", "type": "function", "code": "tf.compat.v1.distribute.experimental.CentralStorageStrategy(compute_devices=None,parameter_device=None)", "summary": "A one-machine strategy that puts all variables on a single device.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.experimental.CentralStorageStrategy", "parameters": [{"name": "compute_devices", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "parameter_device", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.distribute.get_loss_reduction", "type": "function", "code": "tf.compat.v1.distribute.get_loss_reduction()", "summary": "tf.distribute.ReduceOp corresponding to the last loss reduction.", "description": "", "code-info": {"name": "tf.compat.v1.distribute.get_loss_reduction", "parameters": []}},
{"id": "tf.compat.v1.distribute.experimental.TPUStrategy", "type": "class", "code": "tf.compat.v1.distribute.experimental.TPUStrategy(tpu_cluster_resolver=None,steps_per_run=None,device_assignment=None)", "summary": "TPU distribution strategy implementation.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.experimental.TPUStrategy", "parameters": [{"name": "tpu_cluster_resolver", "is_optional": true, "type": "string", "default_value": "None", "description": "A tf.distribute.cluster_resolver.TPUClusterResolver,\nwhich provides information about the TPU cluster."}, {"name": "steps_per_run", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of steps to run on device before returning to the\nhost. Note that this can have side-effects on performance, hooks,\nmetrics, summaries etc.\nThis parameter is only used when Distribution Strategy is used with\nestimator or keras."}, {"name": "device_assignment", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional tf.tpu.experimental.DeviceAssignment to\nspecify the placement of replicas on the TPU cluster. Currently only\nsupports the usecase of using a single core within a TPU cluster."}]}},
{"id": "tf.compat.v1.distribute.OneDeviceStrategy", "type": "class", "code": "tf.compat.v1.distribute.OneDeviceStrategy(device)", "summary": "A distribution strategy for running on a single device.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.OneDeviceStrategy", "parameters": [{"name": "device", "is_optional": false, "type": "string", "description": "Device string identifier for the device on which the variables\nshould be placed. See class docs for more details on how the device is\nused. Examples: \"/cpu:0\", \"/gpu:0\", \"/device:CPU:0\", \"/device:GPU:0\""}]}},
{"id": "tf.compat.v1.distribute.experimental.MultiWorkerMirroredStrategy", "type": "function", "code": "tf.compat.v1.distribute.experimental.MultiWorkerMirroredStrategy(communication=tf.distribute.experimental.CollectiveCommunication.AUTO,cluster_resolver=None)", "summary": "A distribution strategy for synchronous training on multiple workers.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.experimental.MultiWorkerMirroredStrategy", "parameters": [{"name": "communication", "is_optional": true, "type": "others", "default_value": "tf.distribute.experimental.CollectiveCommunication.AUTO", "description": ""}, {"name": "cluster_resolver", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.distribute.MirroredStrategy", "type": "class", "code": "tf.compat.v1.distribute.MirroredStrategy(devices=None,cross_device_ops=None)", "summary": "Mirrors vars to distribute across multiple devices and machines.\n\nInherits From: Strategy", "description": "", "code-info": {"name": "tf.compat.v1.distribute.MirroredStrategy", "parameters": [{"name": "devices", "is_optional": true, "type": "string", "default_value": "None", "description": "a list of device strings.  If None, all available GPUs are used.\nIf no GPUs are found, CPU is used."}, {"name": "cross_device_ops", "is_optional": true, "type": "others", "default_value": "None", "description": "optional, a descedant of CrossDeviceOps. If this is not\nset, nccl will be used by default."}]}},
{"id": "tf.compat.v1.debugging.assert_shapes", "type": "function", "code": "tf.compat.v1.debugging.assert_shapes(shapes,data=None,summarize=None,message=None,name=None)", "summary": "Assert tensor shapes and dimension size relationships between tensors.", "description": "", "code-info": {"name": "tf.compat.v1.debugging.assert_shapes", "parameters": [{"name": "shapes", "is_optional": false, "type": "tensor", "description": "dictionary with (Tensor to shape) items. A shape must be an\niterable."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The tensors to print out if the condition is False.  Defaults to error\nmessage and first few entries of the violating tensor."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of the tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_shapes\"."}]}},
{"id": "tf.compat.v1.data.experimental.TensorStructure", "type": "function", "code": "tf.compat.v1.data.experimental.TensorStructure(dtype,shape)", "summary": "DEPRECATED FUNCTION", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.TensorStructure", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": ""}, {"name": "shape", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.data.experimental.SparseTensorStructure", "type": "function", "code": "tf.compat.v1.data.experimental.SparseTensorStructure(dtype,shape)", "summary": "DEPRECATED FUNCTION", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.SparseTensorStructure", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": ""}, {"name": "shape", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.data.experimental.TensorArrayStructure", "type": "function", "code": "tf.compat.v1.data.experimental.TensorArrayStructure(dtype,element_shape,dynamic_size,infer_shape)", "summary": "DEPRECATED FUNCTION", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.TensorArrayStructure", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": ""}, {"name": "element_shape", "is_optional": false, "type": "others", "description": ""}, {"name": "dynamic_size", "is_optional": false, "type": "others", "description": ""}, {"name": "infer_shape", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.data.experimental.StatsAggregator", "type": "function", "code": "tf.compat.v1.data.experimental.StatsAggregator()", "summary": "A stateful resource that aggregates statistics from one or more iterators.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.StatsAggregator", "parameters": []}},
{"id": "tf.compat.v1.data.experimental.sample_from_datasets", "type": "function", "code": "tf.compat.v1.data.experimental.sample_from_datasets(datasets,weights=None,seed=None)", "summary": "Samples elements at random from the datasets in datasets.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.sample_from_datasets", "parameters": [{"name": "datasets", "is_optional": false, "type": "others", "description": "A list of tf.data.Dataset objects with compatible structure."}, {"name": "weights", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A list of len(datasets) floating-point values where\nweights[i] represents the probability with which an element should be\nsampled from datasets[i], or a tf.data.Dataset object where each\nelement is such a list. Defaults to a uniform distribution across\ndatasets."}, {"name": "seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the\nrandom seed that will be used to create the distribution. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.compat.v1.data.experimental.RandomDataset", "type": "class", "code": "tf.compat.v1.data.experimental.RandomDataset(seed=None)", "summary": "A Dataset of pseudorandom values.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.RandomDataset", "parameters": [{"name": "seed", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor, representing the random\nseed that will be used to create the distribution. See\ntf.compat.v1.set_random_seed for behavior."}]}},
{"id": "tf.compat.v1.data.experimental.SqlDataset", "type": "class", "code": "tf.compat.v1.data.experimental.SqlDataset(driver_name,data_source_name,query,output_types)", "summary": "A Dataset consisting of the results from a SQL query.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.SqlDataset", "parameters": [{"name": "driver_name", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing the database type.\nCurrently, the only supported value is 'sqlite'."}, {"name": "data_source_name", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing a connection string\nto connect to the database."}, {"name": "query", "is_optional": false, "type": "tensor", "description": "A 0-D tf.string tensor containing the SQL query to execute."}, {"name": "output_types", "is_optional": false, "type": "others", "description": "A tuple of tf.DType objects representing the types of the\ncolumns returned by query."}]}},
{"id": "tf.compat.v1.data.experimental.RaggedTensorStructure", "type": "function", "code": "tf.compat.v1.data.experimental.RaggedTensorStructure(dtype,shape,ragged_rank)", "summary": "DEPRECATED FUNCTION", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.RaggedTensorStructure", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": ""}, {"name": "shape", "is_optional": false, "type": "others", "description": ""}, {"name": "ragged_rank", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.data.experimental.choose_from_datasets", "type": "function", "code": "tf.compat.v1.data.experimental.choose_from_datasets(datasets,choice_dataset)", "summary": "Creates a dataset that deterministically chooses elements from datasets.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.choose_from_datasets", "parameters": [{"name": "datasets", "is_optional": false, "type": "others", "description": "A list of tf.data.Dataset objects with compatible structure."}, {"name": "choice_dataset", "is_optional": false, "type": "tensor", "description": "A tf.data.Dataset of scalar tf.int64 tensors between\n0 and len(datasets) - 1."}]}},
{"id": "tf.compat.v1.data.experimental.Counter", "type": "function", "code": "tf.compat.v1.data.experimental.Counter(start=0,step=1,dtype=tf.dtypes.int64)", "summary": "Creates a Dataset that counts from start in steps of size step.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.Counter", "parameters": [{"name": "start", "is_optional": true, "type": "int", "default_value": "0", "description": "(Optional.) The starting value for the counter. Defaults to 0."}, {"name": "step", "is_optional": true, "type": "int", "default_value": "1", "description": "(Optional.) The step size for the counter. Defaults to 1."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "(Optional.) The data type for counter elements. Defaults to\ntf.int64."}]}},
{"id": "tf.compat.v1.data.experimental.map_and_batch_with_legacy_function", "type": "function", "code": "tf.compat.v1.data.experimental.map_and_batch_with_legacy_function(map_func,batch_size,num_parallel_batches=None,drop_remainder=False,num_parallel_calls=None)", "summary": "Fused implementation of map and batch. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.map_and_batch_with_legacy_function", "parameters": [{"name": "map_func", "is_optional": false, "type": "tensor", "description": "A function mapping a nested structure of tensors to another\nnested structure of tensors."}, {"name": "batch_size", "is_optional": false, "type": "tensor", "description": "A tf.int64 scalar tf.Tensor, representing the number of\nconsecutive elements of this dataset to combine in a single batch."}, {"name": "num_parallel_batches", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int64 scalar tf.Tensor,\nrepresenting the number of batches to create in parallel. On one hand,\nhigher values can help mitigate the effect of stragglers. On the other\nhand, higher values can increase contention if CPU is scarce."}, {"name": "drop_remainder", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar tf.Tensor, representing\nwhether the last batch should be dropped in case its size is smaller than\ndesired; the default behavior is not to drop the smaller batch."}, {"name": "num_parallel_calls", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A tf.int32 scalar tf.Tensor,\nrepresenting the number of elements to process in parallel. If not\nspecified, batch_size * num_parallel_batches elements will be processed\nin parallel. If the value tf.data.experimental.AUTOTUNE is used, then\nthe number of parallel calls is set dynamically based on available CPU."}]}},
{"id": "tf.compat.v1.data.experimental.make_csv_dataset", "type": "function", "code": "tf.compat.v1.data.experimental.make_csv_dataset(file_pattern,batch_size,column_names=None,column_defaults=None,label_name=None,select_columns=None,field_delim=',',use_quote_delim=True,na_value='',header=True,num_epochs=None,shuffle=True,shuffle_buffer_size=10000,shuffle_seed=None,prefetch_buffer_size=None,num_parallel_reads=None,sloppy=False,num_rows_for_inference=100,compression_type=None,ignore_errors=False)", "summary": "Reads CSV files into a dataset.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.make_csv_dataset", "parameters": [{"name": "file_pattern", "is_optional": false, "type": "others", "description": "List of files or patterns of file paths containing CSV\nrecords. See tf.io.gfile.glob for pattern rules."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "An int representing the number of records to combine\nin a single batch."}, {"name": "column_names", "is_optional": true, "type": "string", "default_value": "None", "description": "An optional list of strings that corresponds to the CSV\ncolumns, in order. One per column of the input record. If this is not\nprovided, infers the column names from the first row of the records.\nThese names will be the keys of the features dict of each dataset element."}, {"name": "column_defaults", "is_optional": true, "type": "others", "default_value": "None", "description": "A optional list of default values for the CSV fields. One\nitem per selected column of the input record. Each item in the list is\neither a valid CSV dtype (float32, float64, int32, int64, or string), or a\nTensor with one of the aforementioned types. The tensor can either be\na scalar default value (if the column is optional), or an empty tensor (if\nthe column is required). If a dtype is provided instead of a tensor, the\ncolumn is also treated as required. If this list is not provided, tries\nto infer types based on reading the first num_rows_for_inference rows of\nfiles specified, and assumes all columns are optional, defaulting to 0\nfor numeric values and \"\" for string values. If both this and\nselect_columns are specified, these must have the same lengths, and\ncolumn_defaults is assumed to be sorted in order of increasing column\nindex."}, {"name": "label_name", "is_optional": true, "type": "string", "default_value": "None", "description": "A optional string corresponding to the label column. If\nprovided, the data for this column is returned as a separate Tensor from\nthe features dictionary, so that the dataset complies with the format\nexpected by a tf.Estimator.train or tf.Estimator.evaluate input\nfunction."}, {"name": "select_columns", "is_optional": true, "type": "int", "default_value": "None", "description": "An optional list of integer indices or string column\nnames, that specifies a subset of columns of CSV data to select. If\ncolumn names are provided, these must correspond to names provided in\ncolumn_names or inferred from the file header lines. When this argument\nis specified, only a subset of CSV columns will be parsed and returned,\ncorresponding to the columns specified. Using this results in faster\nparsing and lower memory usage. If both this and column_defaults are\nspecified, these must have the same lengths, and column_defaults is\nassumed to be sorted in order of increasing column index."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True. If false, treats\ndouble quotation marks as regular characters inside of the string fields."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "Additional string to recognize as NA/NaN."}, {"name": "header", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool that indicates whether the first rows of provided CSV files\ncorrespond to header lines with column names, and should not be included\nin the data."}, {"name": "num_epochs", "is_optional": true, "type": "others", "default_value": "None", "description": "An int specifying the number of times this dataset is repeated.\nIf None, cycles through the dataset forever."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool that indicates whether the input should be shuffled."}, {"name": "shuffle_buffer_size", "is_optional": true, "type": "int", "default_value": "10000", "description": "Buffer size to use for shuffling. A large buffer size\nensures better shuffling, but increases memory usage and startup time."}, {"name": "shuffle_seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Randomization seed to use for shuffling."}, {"name": "prefetch_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int specifying the number of feature\nbatches to prefetch for performance improvement. Recommended value is the\nnumber of batches consumed per training step. Defaults to auto-tune."}, {"name": "num_parallel_reads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads used to read CSV records from files.\nIf &gt;1, the results will be interleaved. Defaults to 1."}, {"name": "sloppy", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, reading performance will be improved at\nthe cost of non-deterministic ordering. If False, the order of elements\nproduced is deterministic prior to shuffling (elements are still\nrandomized if shuffle=True. Note that if the seed is set, then order\nof elements after shuffling is deterministic). Defaults to False."}, {"name": "num_rows_for_inference", "is_optional": true, "type": "int", "default_value": "100", "description": "Number of rows of a file to use for type inference\nif record_defaults is not provided. If None, reads all the rows of all\nthe files. Defaults to 100."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\". Defaults to no compression."}, {"name": "ignore_errors", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) If True, ignores errors with CSV file parsing,\nsuch as malformed data or empty lines, and moves on to the next valid\nCSV record. Otherwise, the dataset raises an error and stops processing\nwhen encountering any invalid records. Defaults to False."}]}},
{"id": "tf.compat.v1.data.experimental.make_batched_features_dataset", "type": "function", "code": "tf.compat.v1.data.experimental.make_batched_features_dataset(file_pattern,batch_size,features,reader=None,label_key=None,reader_args=None,num_epochs=None,shuffle=True,shuffle_buffer_size=10000,shuffle_seed=None,prefetch_buffer_size=None,reader_num_threads=None,parser_num_threads=None,sloppy_ordering=False,drop_final_batch=False)", "summary": "Returns a Dataset of feature dictionaries from Example protos.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.make_batched_features_dataset", "parameters": [{"name": "file_pattern", "is_optional": false, "type": "others", "description": "List of files or patterns of file paths containing\nExample records. See tf.io.gfile.glob for pattern rules."}, {"name": "batch_size", "is_optional": false, "type": "others", "description": "An int representing the number of records to combine\nin a single batch."}, {"name": "features", "is_optional": false, "type": "others", "description": "{\n  \"age\": FixedLenFeature([], dtype=tf.int64, default_value=-1),\n  \"gender\": FixedLenFeature([], dtype=tf.string),\n  \"kws\": VarLenFeature(dtype=tf.string),\n}\n\nAnd the expected output is:\n{\n  \"age\": [[0], [-1]],\n  \"gender\": [[\"f\"], [\"f\"]],\n  \"kws\": SparseTensor(\n    indices=[[0, 0], [0, 1], [1, 0]],\n    values=[\"code\", \"art\", \"sports\"]\n    dense_shape=[2, 2]),\n}\n\nArgs:\n\n\nfile_pattern: List of files or patterns of file paths containing\nExample records. See tf.io.gfile.glob for pattern rules.\nbatch_size: An int representing the number of records to combine\nin a single batch."}, {"name": "reader", "is_optional": true, "type": "others", "default_value": "None", "description": "A function or class that can be\ncalled with a filenames tensor and (optional) reader_args and returns\na Dataset of Example tensors. Defaults to tf.data.TFRecordDataset."}, {"name": "label_key", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A string corresponding to the key labels are stored in\ntf.Examples. If provided, it must be one of the features key,\notherwise results in ValueError."}, {"name": "reader_args", "is_optional": true, "type": "others", "default_value": "None", "description": "Additional arguments to pass to the reader class."}, {"name": "num_epochs", "is_optional": true, "type": "int", "default_value": "None", "description": "Integer specifying the number of times to read through the\ndataset. If None, cycles through the dataset forever. Defaults to None."}, {"name": "shuffle", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean, indicates whether the input should be shuffled. Defaults\nto True."}, {"name": "shuffle_buffer_size", "is_optional": true, "type": "int", "default_value": "10000", "description": "Buffer size of the ShuffleDataset. A large capacity\nensures better shuffling but would increase memory usage and startup time."}, {"name": "shuffle_seed", "is_optional": true, "type": "others", "default_value": "None", "description": "Randomization seed to use for shuffling."}, {"name": "prefetch_buffer_size", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of feature batches to prefetch in order to\nimprove performance. Recommended value is the number of batches consumed\nper training step. Defaults to auto-tune."}, {"name": "reader_num_threads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads used to read Example records. If &gt;1,\nthe results will be interleaved. Defaults to 1."}, {"name": "parser_num_threads", "is_optional": true, "type": "others", "default_value": "None", "description": "Number of threads to use for parsing Example tensors\ninto a dictionary of Feature tensors. Defaults to 2."}, {"name": "sloppy_ordering", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, reading performance will be improved at\nthe cost of non-deterministic ordering. If False, the order of elements\nproduced is deterministic prior to shuffling (elements are still\nrandomized if shuffle=True. Note that if the seed is set, then order\nof elements after shuffling is deterministic). Defaults to False."}, {"name": "drop_final_batch", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, and the batch size does not evenly divide the\ninput dataset size, the final smaller batch will be dropped. Defaults to\nFalse."}]}},
{"id": "tf.compat.v1.data.experimental.CsvDataset", "type": "class", "code": "tf.compat.v1.data.experimental.CsvDataset(filenames,record_defaults,compression_type=None,buffer_size=None,header=False,field_delim=',',use_quote_delim=True,na_value='',select_cols=None)", "summary": "A Dataset comprising lines from one or more CSV files.", "description": "", "code-info": {"name": "tf.compat.v1.data.experimental.CsvDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor containing one or more filenames."}, {"name": "record_defaults", "is_optional": false, "type": "others", "description": "A list of default values for the CSV fields. Each item in\nthe list is either a valid CSV DType (float32, float64, int32, int64,\nstring), or a Tensor object with one of the above types. One per\ncolumn of CSV data, with either a scalar Tensor default value for the\ncolumn if it is optional, or DType or empty Tensor if required. If\nboth this and select_columns are specified, these must have the same\nlengths, and column_defaults is assumed to be sorted in order of\nincreasing column index."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\". Defaults to no\ncompression."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar denoting the number of bytes\nto buffer while reading files. Defaults to 4MB."}, {"name": "header", "is_optional": true, "type": "bool", "default_value": "False", "description": "(Optional.) A tf.bool scalar indicating whether the CSV file(s)\nhave header line(s) that should be skipped when parsing. Defaults to\nFalse."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "(Optional.) A tf.bool scalar. If False, treats\ndouble quotation marks as regular characters inside of string fields\n(ignoring RFC 4180, Section 2, Bullet 5). Defaults to True."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "(Optional.) A tf.string scalar indicating a value that will\nbe treated as NA/NaN."}, {"name": "select_cols", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) A sorted list of column indices to select from\nthe input data. If specified, only this subset of columns will be\nparsed. Defaults to parsing all columns."}]}},
{"id": "tf.compat.v1.data.make_one_shot_iterator", "type": "function", "code": "tf.compat.v1.data.make_one_shot_iterator(dataset)", "summary": "Creates a tf.compat.v1.data.Iterator for enumerating the elements of a dataset.", "description": "", "code-info": {"name": "tf.compat.v1.data.make_one_shot_iterator", "parameters": [{"name": "dataset", "is_optional": false, "type": "others", "description": "A tf.data.Dataset."}]}},
{"id": "tf.compat.v1.data.TFRecordDataset", "type": "class", "code": "tf.compat.v1.data.TFRecordDataset(filenames,compression_type=None,buffer_size=None,num_parallel_reads=None)", "summary": "A Dataset comprising records from one or more TFRecord files.", "description": "", "code-info": {"name": "tf.compat.v1.data.TFRecordDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes in the read buffer. If your input pipeline is I/O bottlenecked,\nconsider setting this parameter to a value 1-100 MBs. If None, a\nsensible default for both local and remote file systems is used."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.compat.v1.data.make_initializable_iterator", "type": "function", "code": "tf.compat.v1.data.make_initializable_iterator(dataset,shared_name=None)", "summary": "Creates a tf.compat.v1.data.Iterator for enumerating the elements of a dataset.", "description": "", "code-info": {"name": "tf.compat.v1.data.make_initializable_iterator", "parameters": [{"name": "dataset", "is_optional": false, "type": "others", "description": "A tf.data.Dataset."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If non-empty, the returned iterator will be shared\nunder the given name across multiple sessions that share the same devices\n(e.g. when using a remote server)."}]}},
{"id": "tf.compat.v1.data.TextLineDataset", "type": "class", "code": "tf.compat.v1.data.TextLineDataset(filenames,compression_type=None,buffer_size=None,num_parallel_reads=None)", "summary": "A Dataset comprising lines from one or more text files.", "description": "", "code-info": {"name": "tf.compat.v1.data.TextLineDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar denoting the number of bytes\nto buffer. A value of 0 results in the default buffering values chosen\nbased on the compression type."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.compat.v1.data.Iterator", "type": "class", "code": "tf.compat.v1.data.Iterator(iterator_resource,initializer,output_types,output_shapes,output_classes)", "summary": "Represents the state of iterating through a Dataset.", "description": "", "code-info": {"name": "tf.compat.v1.data.Iterator", "parameters": [{"name": "iterator_resource", "is_optional": false, "type": "tensor", "description": "A tf.resource scalar tf.Tensor representing the\niterator."}, {"name": "initializer", "is_optional": false, "type": "others", "description": "A tf.Operation that should be run to initialize this\niterator."}, {"name": "output_types", "is_optional": false, "type": "string", "description": "A nested structure of tf.DType objects corresponding to\neach component of an element of this iterator."}, {"name": "output_shapes", "is_optional": false, "type": "tensor", "description": "A nested structure of tf.TensorShape objects\ncorresponding to each component of an element of this iterator."}, {"name": "output_classes", "is_optional": false, "type": "string", "description": "A nested structure of Python type objects corresponding\nto each component of an element of this iterator."}]}},
{"id": "tf.compat.v1.data.get_output_shapes", "type": "function", "code": "tf.compat.v1.data.get_output_shapes(dataset_or_iterator)", "summary": "Returns the output shapes of a Dataset or Iterator elements.", "description": "", "code-info": {"name": "tf.compat.v1.data.get_output_shapes", "parameters": [{"name": "dataset_or_iterator", "is_optional": false, "type": "others", "description": "A tf.data.Dataset or tf.data.Iterator."}]}},
{"id": "tf.compat.v1.data.FixedLengthRecordDataset", "type": "class", "code": "tf.compat.v1.data.FixedLengthRecordDataset(filenames,record_bytes,header_bytes=None,footer_bytes=None,buffer_size=None,compression_type=None,num_parallel_reads=None)", "summary": "A Dataset of fixed-length records from one or more binary files.", "description": "", "code-info": {"name": "tf.compat.v1.data.FixedLengthRecordDataset", "parameters": [{"name": "filenames", "is_optional": false, "type": "tensor", "description": "A tf.string tensor or tf.data.Dataset containing one or\nmore filenames."}, {"name": "record_bytes", "is_optional": false, "type": "float", "description": "A tf.int64 scalar representing the number of bytes in each\nrecord."}, {"name": "header_bytes", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to skip at the start of a file."}, {"name": "footer_bytes", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to ignore at the end of a file."}, {"name": "buffer_size", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the number of\nbytes to buffer when reading."}, {"name": "compression_type", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.string scalar evaluating to one of\n\"\" (no compression), \"ZLIB\", or \"GZIP\"."}, {"name": "num_parallel_reads", "is_optional": true, "type": "float", "default_value": "None", "description": "(Optional.) A tf.int64 scalar representing the\nnumber of files to read in parallel. If greater than one, the records of\nfiles read in parallel are outputted in an interleaved order. If your\ninput pipeline is I/O bottlenecked, consider setting this parameter to a\nvalue greater than one to parallelize the I/O. If None, files will be\nread sequentially."}]}},
{"id": "tf.compat.v1.data.Dataset", "type": "class", "code": "tf.compat.v1.data.Dataset()", "summary": "Represents a potentially large set of elements.\n\nInherits From: Dataset", "description": "", "code-info": {"name": "tf.compat.v1.data.Dataset", "parameters": []}},
{"id": "tf.compat.v1.data.get_output_types", "type": "function", "code": "tf.compat.v1.data.get_output_types(dataset_or_iterator)", "summary": "Returns the output shapes of a Dataset or Iterator elements.", "description": "", "code-info": {"name": "tf.compat.v1.data.get_output_types", "parameters": [{"name": "dataset_or_iterator", "is_optional": false, "type": "others", "description": "A tf.data.Dataset or tf.data.Iterator."}]}},
{"id": "tf.compat.v1.data.get_output_classes", "type": "function", "code": "tf.compat.v1.data.get_output_classes(dataset_or_iterator)", "summary": "Returns the output classes of a Dataset or Iterator elements.", "description": "", "code-info": {"name": "tf.compat.v1.data.get_output_classes", "parameters": [{"name": "dataset_or_iterator", "is_optional": false, "type": "others", "description": "A tf.data.Dataset or tf.data.Iterator."}]}},
{"id": "tf.compat.v1.autograph.to_code", "type": "function", "code": "tf.compat.v1.autograph.to_code(entity,recursive=True,arg_values=None,arg_types=None,indentation='',experimental_optional_features=None)", "summary": "Returns the source code generated by AutoGraph, as a string.", "description": "", "code-info": {"name": "tf.compat.v1.autograph.to_code", "parameters": [{"name": "entity", "is_optional": false, "type": "others", "description": "Python callable or class."}, {"name": "recursive", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to recursively convert any functions that the converted\nfunction may call."}, {"name": "arg_values", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated."}, {"name": "arg_types", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated."}, {"name": "indentation", "is_optional": true, "type": "string", "default_value": "''", "description": "Deprecated."}, {"name": "experimental_optional_features", "is_optional": true, "type": "others", "default_value": "None", "description": "None, a tuple of, or a single\ntf.autograph.experimental.Feature value."}]}},
{"id": "tf.compat.v1.autograph.to_graph", "type": "function", "code": "tf.compat.v1.autograph.to_graph(entity,recursive=True,arg_values=None,arg_types=None,experimental_optional_features=None)", "summary": "Converts a Python entity into a TensorFlow graph.", "description": "", "code-info": {"name": "tf.compat.v1.autograph.to_graph", "parameters": [{"name": "entity", "is_optional": false, "type": "others", "description": "Python callable or class to convert."}, {"name": "recursive", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to recursively convert any functions that the converted\nfunction may call."}, {"name": "arg_values", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated."}, {"name": "arg_types", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated."}, {"name": "experimental_optional_features", "is_optional": true, "type": "others", "default_value": "None", "description": "None, a tuple of, or a single\ntf.autograph.experimental.Feature value."}]}},
{"id": "tf.compat.v1.WholeFileReader", "type": "class", "code": "tf.compat.v1.WholeFileReader(name=None)", "summary": "A Reader that outputs the entire contents of a file as a value.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.WholeFileReader", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.wrap_function", "type": "function", "code": "tf.compat.v1.wrap_function(fn,signature,name=None)", "summary": "Wraps the TF 1.x function fn into a graph function.", "description": "", "code-info": {"name": "tf.compat.v1.wrap_function", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "python function to be wrapped"}, {"name": "signature", "is_optional": false, "type": "others", "description": "the placeholder and python arguments to be passed to the wrapped\nfunction"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional. The name of the function."}]}},
{"id": "tf.compat.v1.app.run", "type": "function", "code": "tf.compat.v1.app.run(main=None,argv=None)", "summary": "Runs the program with an optional 'main' function and 'argv' list.", "description": "", "code-info": {"name": "tf.compat.v1.app.run", "parameters": [{"name": "main", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "argv", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.where", "type": "function", "code": "tf.compat.v1.where(condition,x=None,y=None,name=None)", "summary": "Return the elements, either from x or y, depending on the condition.", "description": "", "code-info": {"name": "tf.compat.v1.where", "parameters": [{"name": "condition", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool"}, {"name": "x", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor which may have the same shape as condition. If condition is\nrank 1, x may have higher rank, but its first dimension must match the\nsize of condition."}, {"name": "y", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A tensor with the same shape and type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name of the operation (optional)"}]}},
{"id": "tf.compat.v1.while_loop", "type": "function", "code": "tf.compat.v1.while_loop(cond,body,loop_vars,shape_invariants=None,parallel_iterations=10,back_prop=True,swap_memory=False,name=None,maximum_iterations=None,return_same_structure=False)", "summary": "Repeat body while the condition cond is true.", "description": "", "code-info": {"name": "tf.compat.v1.while_loop", "parameters": [{"name": "cond", "is_optional": false, "type": "others", "description": "A callable that represents the termination condition of the loop."}, {"name": "body", "is_optional": false, "type": "others", "description": "A callable that represents the loop body."}, {"name": "loop_vars", "is_optional": false, "type": "string", "description": "A (possibly nested) tuple, namedtuple or list of numpy array,\nTensor, and TensorArray objects."}, {"name": "shape_invariants", "is_optional": true, "type": "others", "default_value": "None", "description": "The shape invariants for the loop variables."}, {"name": "parallel_iterations", "is_optional": true, "type": "int", "default_value": "10", "description": "The number of iterations allowed to run in parallel. It\nmust be a positive integer."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether backprop is enabled for this while loop."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether GPU-CPU memory swap is enabled for this loop."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the returned tensors."}, {"name": "maximum_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional maximum number of iterations of the while loop\nto run.  If provided, the cond output is AND-ed with an additional\ncondition ensuring the number of iterations executed is no greater than\nmaximum_iterations."}, {"name": "return_same_structure", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, output has same structure as loop_vars. If\neager execution is enabled, this is ignored (and always treated as True)."}]}},
{"id": "tf.compat.v1.variable_axis_size_partitioner", "type": "function", "code": "tf.compat.v1.variable_axis_size_partitioner(max_shard_bytes,axis=0,bytes_per_string_element=16,max_shards=None)", "summary": "Get a partitioner for VariableScope to keep shards below max_shard_bytes.", "description": "", "code-info": {"name": "tf.compat.v1.variable_axis_size_partitioner", "parameters": [{"name": "max_shard_bytes", "is_optional": false, "type": "others", "description": "The maximum size any given shard is allowed to be."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "The axis to partition along.  Default: outermost axis."}, {"name": "bytes_per_string_element", "is_optional": true, "type": "int", "default_value": "16", "description": "If the Variable is of type string, this provides\nan estimate of how large each scalar in the Variable is."}, {"name": "max_shards", "is_optional": true, "type": "others", "default_value": "None", "description": "The maximum number of shards in int created taking precedence\nover max_shard_bytes."}]}},
{"id": "tf.compat.v1.zeros_like", "type": "function", "code": "tf.compat.v1.zeros_like(tensor,dtype=None,name=None,optimize=True)", "summary": "Creates a tensor with all elements set to zero.", "description": "", "code-info": {"name": "tf.compat.v1.zeros_like", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A type for the returned Tensor. Must be float16, float32,\nfloat64, int8, uint8, int16, uint16, int32, int64,\ncomplex64, complex128, bool or string."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "optimize", "is_optional": true, "type": "bool", "default_value": "True", "description": "if true, attempt to statically determine the shape of 'tensor' and\nencode it as a constant."}]}},
{"id": "tf.compat.v1.variables_initializer", "type": "function", "code": "tf.compat.v1.variables_initializer(var_list,name='init')", "summary": "Returns an Op that initializes a list of variables.", "description": "", "code-info": {"name": "tf.compat.v1.variables_initializer", "parameters": [{"name": "var_list", "is_optional": false, "type": "others", "description": "List of Variable objects to initialize."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'init'", "description": "Optional name for the returned operation."}]}},
{"id": "tf.compat.v1.verify_tensor_all_finite", "type": "function", "code": "tf.compat.v1.verify_tensor_all_finite(t=None,msg=None,name=None,x=None,message=None)", "summary": "Assert that the tensor does not contain any NaN's or Inf's.", "description": "", "code-info": {"name": "tf.compat.v1.verify_tensor_all_finite", "parameters": [{"name": "t", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Tensor to check."}, {"name": "msg", "is_optional": true, "type": "others", "default_value": "None", "description": "Message to log on failure."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "x", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for t."}, {"name": "message", "is_optional": true, "type": "others", "default_value": "None", "description": "Alias for msg."}]}},
{"id": "tf.compat.v1.uniform_unit_scaling_initializer", "type": "function", "code": "tf.compat.v1.uniform_unit_scaling_initializer(factor=1.0,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors without scaling variance.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.uniform_unit_scaling_initializer", "parameters": [{"name": "factor", "is_optional": true, "type": "float", "default_value": "1.0", "description": "Float.  A multiplicative factor by which the values will be scaled."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.Variable", "type": "class", "code": "tf.compat.v1.Variable(initial_value=None,trainable=None,collections=None,validate_shape=True,caching_device=None,name=None,variable_def=None,dtype=None,expected_shape=None,import_scope=None,constraint=None,use_resource=None,synchronization=tf.VariableSynchronization.AUTO,aggregation=tf.compat.v1.VariableAggregation.NONE,shape=None)", "summary": "See the Variables Guide.\n\nInherits From: Variable", "description": "", "code-info": {"name": "tf.compat.v1.Variable", "parameters": [{"name": "initial_value", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor, or Python object convertible to a Tensor,\nwhich is the initial value for the Variable. The initial value must have\na shape specified unless validate_shape is set to False. Can also be a\ncallable with no argument that returns the initial value when called. In\nthat case, dtype must be specified. (Note that initializer functions\nfrom init_ops.py must first be bound to a shape before being used here.)"}, {"name": "trainable", "is_optional": true, "type": "others", "default_value": "None", "description": "If True, also adds the variable to the graph collection\nGraphKeys.TRAINABLE_VARIABLES. This collection is used as the default\nlist of variables to use by the Optimizer classes. Defaults to True,\nunless synchronization is set to ON_READ, in which case it defaults\nto False."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "List of graph collections keys. The new variable is added to\nthese collections. Defaults to [GraphKeys.GLOBAL_VARIABLES]."}, {"name": "validate_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "If False, allows the variable to be initialized with a\nvalue of unknown shape. If True, the default, the shape of\ninitial_value must be known."}, {"name": "caching_device", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device string describing where the Variable\nshould be cached for reading.  Defaults to the Variable's device. If not\nNone, caches on another device.  Typical use is to cache on the device\nwhere the Ops using the Variable reside, to deduplicate copying through\nSwitch and other conditional statements."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the variable. Defaults to 'Variable' and gets\nuniquified automatically."}, {"name": "variable_def", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableDef protocol buffer. If not None, recreates the\nVariable object with its contents, referencing the variable's nodes in\nthe graph, which must already exist. The graph is not changed.\nvariable_def and the other arguments are mutually exclusive."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, initial_value will be converted to the given type. If\nNone, either the datatype will be kept (if initial_value is a\nTensor), or convert_to_tensor will decide."}, {"name": "expected_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A TensorShape. If set, initial_value is expected to have\nthis shape."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope to add to the Variable. Only\nused when initializing from protocol buffer."}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value (which must have\nthe same shape). Constraints are not safe to use when doing asynchronous\ndistributed training."}, {"name": "use_resource", "is_optional": true, "type": "others", "default_value": "None", "description": "whether to use resource variables."}, {"name": "synchronization", "is_optional": true, "type": "string", "default_value": "tf.VariableSynchronization.AUTO", "description": "Indicates when a distributed a variable will be\naggregated. Accepted values are constants defined in the class\ntf.VariableSynchronization. By default the synchronization is set to\nAUTO and the current DistributionStrategy chooses when to\nsynchronize."}, {"name": "aggregation", "is_optional": true, "type": "string", "default_value": "tf.compat.v1.VariableAggregation.NONE", "description": "Indicates how a distributed variable will be aggregated.\nAccepted values are constants defined in the class\ntf.VariableAggregation."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The shape of this variable. If None, the shape of\ninitial_value will be used. When setting this argument to\ntf.TensorShape(None) (representing an unspecified shape), the variable\ncan be assigned with values of different shapes."}]}},
{"id": "tf.compat.v1.tuple", "type": "function", "code": "tf.compat.v1.tuple(tensors,name=None,control_inputs=None)", "summary": "Group tensors together.", "description": "", "code-info": {"name": "tf.compat.v1.tuple", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "A list of Tensors or IndexedSlices, some entries can be None."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional) A name to use as a name_scope for the operation."}, {"name": "control_inputs", "is_optional": true, "type": "others", "default_value": "None", "description": "List of additional ops to finish before returning."}]}},
{"id": "tf.compat.v1.VariableScope", "type": "function", "code": "tf.compat.v1.VariableScope(reuse,name='',initializer=None,regularizer=None,caching_device=None,partitioner=None,custom_getter=None,name_scope='',dtype=tf.dtypes.float32,use_resource=None,constraint=None)", "summary": "Variable scope object to carry defaults to provide to get_variable.", "description": "", "code-info": {"name": "tf.compat.v1.VariableScope", "parameters": [{"name": "reuse", "is_optional": false, "type": "bool", "description": "Boolean, None, or tf.compat.v1.AUTO_REUSE, setting the reuse in\nget_variable. When eager execution is enabled this argument is always\nforced to be False.\ncaching_device: string, callable, or None: the caching device passed to\nget_variable.\npartitioner: callable or None: the partitioner passed to get_variable.\ncustom_getter: default custom getter passed to get_variable.\nname_scope: The name passed to tf.name_scope.\ndtype: default type passed to get_variable (defaults to DT_FLOAT).\nuse_resource: if False, create a normal Variable; if True create an\nexperimental ResourceVariable with well-defined semantics. Defaults to\nFalse (will later change to True). When eager execution is enabled this\nargument is always forced to be True.\nconstraint: An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value (which must have\nthe same shape). Constraints are not safe to use when doing asynchronous\ndistributed training.* original_name_scope\n\n\nMethods\n\nget_collection\n\nView source\nget_collection(\n    name\n)\n\nGet this scope's variables.\n\nget_variable\n\nView source\nget_variable(\n    var_store, name, shape=None, dtype=None, initializer=None, regularizer=None,\n    reuse=None, trainable=None, collections=None, caching_device=None,\n    partitioner=None, validate_shape=True, use_resource=None, custom_getter=None,\n    constraint=None, synchronization=tf.VariableSynchronization.AUTO,\n    aggregation=tf.compat.v1.VariableAggregation.NONE\n)\n\nGets an existing variable with this name or create a new one.\n\nglobal_variables\n\nView source\nglobal_variables()\n\nGet this scope's global variables.\n\nlocal_variables\n\nView source\nlocal_variables()\n\nGet this scope's local variables.\n\nreuse_variables\n\nView source\nreuse_variables()\n\nReuse variables in this scope.\n\nset_caching_device\n\nView source\nset_caching_device(\n    caching_device\n)\n\nSet caching_device for this scope.\n\nset_custom_getter\n\nView source\nset_custom_getter(\n    custom_getter\n)\n\nSet custom getter for this scope.\n\nset_dtype\n\nView source\nset_dtype(\n    dtype\n)\n\nSet data type for this scope.\n\nset_initializer\n\nView source\nset_initializer(\n    initializer\n)\n\nSet initializer for this scope.\n\nset_partitioner\n\nView source\nset_partitioner(\n    partitioner\n)\n\nSet partitioner for this scope.\n\nset_regularizer\n\nView source\nset_regularizer(\n    regularizer\n)\n\nSet regularizer for this scope.\n\nset_use_resource\n\nView source\nset_use_resource(\n    use_resource\n)\n\nSets whether to use ResourceVariables for this scope.\n\ntrainable_variables\n\nView source\ntrainable_variables()\n\nGet this scope's trainable variables.\n\n          "}, {"name": "name", "is_optional": true, "type": "string", "default_value": "''", "description": "name of the current scope, used as prefix in get_variable."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "default initializer passed to get_variable."}, {"name": "regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "default regularizer passed to get_variable.\nreuse: Boolean, None, or tf.compat.v1.AUTO_REUSE, setting the reuse in\nget_variable. When eager execution is enabled this argument is always\nforced to be False."}, {"name": "caching_device", "is_optional": true, "type": "string", "default_value": "None", "description": "string, callable, or None: the caching device passed to\nget_variable."}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": "callable or None: the partitioner passed to get_variable."}, {"name": "custom_getter", "is_optional": true, "type": "others", "default_value": "None", "description": "default custom getter passed to get_variable."}, {"name": "name_scope", "is_optional": true, "type": "string", "default_value": "''", "description": "The name passed to tf.name_scope."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "default type passed to get_variable (defaults to DT_FLOAT)."}, {"name": "use_resource", "is_optional": true, "type": "others", "default_value": "None", "description": "if False, create a normal Variable; if True create an\nexperimental ResourceVariable with well-defined semantics. Defaults to\nFalse (will later change to True). When eager execution is enabled this\nargument is always forced to be True."}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value (which must have\nthe same shape). Constraints are not safe to use when doing asynchronous\ndistributed training.* original_name_scope"}]}},
{"id": "tf.compat.v1.variable_scope", "type": "function", "code": "tf.compat.v1.variable_scope(name_or_scope,default_name=None,values=None,initializer=None,regularizer=None,caching_device=None,partitioner=None,custom_getter=None,reuse=None,dtype=None,use_resource=None,constraint=None,auxiliary_name_scope=True)", "summary": "A context manager for defining ops that creates variables (layers).", "description": "", "code-info": {"name": "tf.compat.v1.variable_scope", "parameters": [{"name": "name_or_scope", "is_optional": false, "type": "string", "description": "string or VariableScope: the scope to open."}, {"name": "default_name", "is_optional": true, "type": "string", "default_value": "None", "description": "The default name to use if the name_or_scope argument is\nNone, this name will be uniquified. If name_or_scope is provided it\nwon't be used and therefore it is not required and can be None."}, {"name": "values", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The list of Tensor arguments that are passed to the op function."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "default initializer for variables within this scope."}, {"name": "regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": "default regularizer for variables within this scope."}, {"name": "caching_device", "is_optional": true, "type": "others", "default_value": "None", "description": "default caching device for variables within this scope."}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": "default partitioner for variables within this scope."}, {"name": "custom_getter", "is_optional": true, "type": "others", "default_value": "None", "description": "default custom getter for variables within this scope."}, {"name": "reuse", "is_optional": true, "type": "others", "default_value": "None", "description": "True, None, or tf.compat.v1.AUTO_REUSE; if True, we go into\nreuse mode for this scope as well as all sub-scopes; if\ntf.compat.v1.AUTO_REUSE, we create variables if they do not exist, and\nreturn them otherwise; if None, we inherit the parent scope's reuse\nflag. When eager execution is enabled, new variables are always created\nunless an EagerVariableStore or template is currently active."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "type of variables created in this scope (defaults to the type in\nthe passed scope, or inherited from parent scope)."}, {"name": "use_resource", "is_optional": true, "type": "others", "default_value": "None", "description": "If False, all variables will be regular Variables. If True,\nexperimental ResourceVariables with well-defined semantics will be used\ninstead. Defaults to False (will later change to True). When eager\nexecution is enabled this argument is always forced to be True."}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value (which must have\nthe same shape). Constraints are not safe to use when doing asynchronous\ndistributed training."}, {"name": "auxiliary_name_scope", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, we create an auxiliary name scope with\nthe scope. If False, we don't create it. Note that the argument is not\ninherited, and it only takes effect for once when creating. You should\nonly use it for re-entering a premade variable scope."}]}},
{"id": "tf.compat.v1.transpose", "type": "function", "code": "tf.compat.v1.transpose(a,perm=None,name='transpose',conjugate=False)", "summary": "Transposes a.", "description": "", "code-info": {"name": "tf.compat.v1.transpose", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "perm", "is_optional": true, "type": "others", "default_value": "None", "description": "A permutation of the dimensions of a."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'transpose'", "description": "A name for the operation (optional)."}, {"name": "conjugate", "is_optional": true, "type": "bool", "default_value": "False", "description": "Optional bool. Setting it to True is mathematically equivalent\nto tf.math.conj(tf.transpose(input))."}]}},
{"id": "tf.compat.v1.to_int64", "type": "function", "code": "tf.compat.v1.to_int64(x,name='ToInt64')", "summary": "Casts a tensor to type int64. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_int64", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToInt64'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.to_int32", "type": "function", "code": "tf.compat.v1.to_int32(x,name='ToInt32')", "summary": "Casts a tensor to type int32. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_int32", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToInt32'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.to_float", "type": "function", "code": "tf.compat.v1.to_float(x,name='ToFloat')", "summary": "Casts a tensor to type float32. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_float", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToFloat'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.truncated_normal_initializer", "type": "function", "code": "tf.compat.v1.truncated_normal_initializer(mean=0.0,stddev=1.0,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates a truncated normal distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.truncated_normal_initializer", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values to\ngenerate."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "a python scalar or a scalar tensor. Standard deviation of the random\nvalues to generate."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.to_bfloat16", "type": "function", "code": "tf.compat.v1.to_bfloat16(x,name='ToBFloat16')", "summary": "Casts a tensor to type bfloat16. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_bfloat16", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToBFloat16'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.to_complex128", "type": "function", "code": "tf.compat.v1.to_complex128(x,name='ToComplex128')", "summary": "Casts a tensor to type complex128. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_complex128", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToComplex128'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.TFRecordReader", "type": "class", "code": "tf.compat.v1.TFRecordReader(name=None,options=None)", "summary": "A Reader that outputs the records from a TFRecords file.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.TFRecordReader", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "A TFRecordOptions object (optional)."}]}},
{"id": "tf.compat.v1.TextLineReader", "type": "class", "code": "tf.compat.v1.TextLineReader(skip_header_lines=None,name=None)", "summary": "A Reader that outputs the lines of a file delimited by newlines.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.TextLineReader", "parameters": [{"name": "skip_header_lines", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0.  Number of lines\nto skip from the beginning of every file."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.to_double", "type": "function", "code": "tf.compat.v1.to_double(x,name='ToDouble')", "summary": "Casts a tensor to type float64. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_double", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToDouble'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.tables_initializer", "type": "function", "code": "tf.compat.v1.tables_initializer(name='init_all_tables')", "summary": "Returns an Op that initializes all tables of the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.tables_initializer", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'init_all_tables'", "description": "Optional name for the initialization op."}]}},
{"id": "tf.compat.v1.to_complex64", "type": "function", "code": "tf.compat.v1.to_complex64(x,name='ToComplex64')", "summary": "Casts a tensor to type complex64. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.to_complex64", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'ToComplex64'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.trainable_variables", "type": "function", "code": "tf.compat.v1.trainable_variables(scope=None)", "summary": "Returns all variables created with trainable=True.", "description": "", "code-info": {"name": "tf.compat.v1.trainable_variables", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A string. If supplied, the resulting list is filtered to\ninclude only items whose name attribute matches scope using\nre.match. Items without a name attribute are never returned if a scope\nis supplied. The choice of re.match means that a scope without special\ntokens filters by prefix."}]}},
{"id": "tf.compat.v1.substr", "type": "function", "code": "tf.compat.v1.substr(input,pos,len,name=None,unit='BYTE')", "summary": "Return substrings from Tensor of strings.", "description": "", "code-info": {"name": "tf.compat.v1.substr", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor of type string. Tensor of strings"}, {"name": "pos", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nScalar defining the position of first character in each substring"}, {"name": "len", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as pos.\nScalar defining the number of characters to include in each substring\nunit: An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is used to create the substring.  One of: \"BYTE\" (for\ndefining position and length by bytes) or \"UTF8_CHAR\" (for the UTF-8\nencoded Unicode code points).  The default is \"BYTE\". Results are undefined if\nunit=UTF8_CHAR and the input strings do not contain structurally valid\nUTF-8."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor of type string.\n\n          "}, {"name": "unit", "is_optional": true, "type": "string", "default_value": "'BYTE'", "description": "An optional string from: \"BYTE\", \"UTF8_CHAR\". Defaults to \"BYTE\".\nThe unit that is used to create the substring.  One of: \"BYTE\" (for\ndefining position and length by bytes) or \"UTF8_CHAR\" (for the UTF-8\nencoded Unicode code points).  The default is \"BYTE\". Results are undefined if\nunit=UTF8_CHAR and the input strings do not contain structurally valid\nUTF-8.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.sparse_to_dense", "type": "function", "code": "tf.compat.v1.sparse_to_dense(sparse_indices,output_shape,sparse_values,default_value=0,validate_indices=True,name=None)", "summary": "Converts a sparse representation into a dense tensor. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_to_dense", "parameters": [{"name": "sparse_indices", "is_optional": false, "type": "tensor", "description": "A 0-D, 1-D, or 2-D Tensor of type int32 or int64.\nsparse_indices[i] contains the complete index where sparse_values[i]\nwill be placed."}, {"name": "output_shape", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor of the same type as sparse_indices.  Shape\nof the dense output tensor."}, {"name": "sparse_values", "is_optional": false, "type": "tensor", "description": "A 0-D or 1-D Tensor.  Values corresponding to each row of\nsparse_indices, or a scalar value to be used for all sparse indices."}, {"name": "default_value", "is_optional": true, "type": "int", "default_value": "0", "description": "A 0-D Tensor of the same type as sparse_values.  Value\nto set for indices not specified in sparse_indices.  Defaults to zero."}, {"name": "validate_indices", "is_optional": true, "type": "bool", "default_value": "True", "description": "A boolean value.  If True, indices are checked to make\nsure they are sorted in lexicographic order and that there are no repeats."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.string_to_number", "type": "function", "code": "tf.compat.v1.string_to_number(string_tensor=None,out_type=tf.dtypes.float32,name=None,input=None)", "summary": "Converts each string in the input Tensor to the specified numeric type.", "description": "", "code-info": {"name": "tf.compat.v1.string_to_number", "parameters": [{"name": "string_tensor", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type string."}, {"name": "out_type", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "An optional tf.DType from: tf.float32, tf.float64, tf.int32, tf.int64. Defaults to tf.float32.\nThe numeric type to interpret each string in string_tensor as."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.string_to_hash_bucket", "type": "function", "code": "tf.compat.v1.string_to_hash_bucket(string_tensor=None,num_buckets=None,name=None,input=None)", "summary": "Converts each string in the input Tensor to its hash mod by a number of buckets.", "description": "", "code-info": {"name": "tf.compat.v1.string_to_hash_bucket", "parameters": [{"name": "string_tensor", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor of type string."}, {"name": "num_buckets", "is_optional": true, "type": "others", "default_value": "None", "description": "An int that is &gt;= 1. The number of buckets."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "input", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.string_split", "type": "function", "code": "tf.compat.v1.string_split(source,sep=None,skip_empty=True,delimiter=None,result_type='SparseTensor',name=None)", "summary": "Split elements of source based on delimiter. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.string_split", "parameters": [{"name": "source", "is_optional": false, "type": "tensor", "description": "1-D string Tensor, the strings to split."}, {"name": "sep", "is_optional": true, "type": "tensor", "default_value": "None", "description": "0-D string Tensor, the delimiter character, the string should\nbe length 0 or 1. Default is ' '."}, {"name": "skip_empty", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool. If True, skip the empty strings from the result."}, {"name": "delimiter", "is_optional": true, "type": "others", "default_value": "None", "description": "deprecated alias for sep."}, {"name": "result_type", "is_optional": true, "type": "string", "default_value": "'SparseTensor'", "description": "The tensor type for the result: one of \"RaggedTensor\" or\n\"SparseTensor\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.squeeze", "type": "function", "code": "tf.compat.v1.squeeze(input,axis=None,name=None,squeeze_dims=None)", "summary": "Removes dimensions of size 1 from the shape of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.squeeze", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. The input to squeeze."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of ints. Defaults to []. If specified, only\nsqueezes the dimensions listed. The dimension index starts at 0. It is an\nerror to squeeze a dimension that is not 1. Must be in the range\n[-rank(input), rank(input)). Must be specified if input is a\nRaggedTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "squeeze_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated keyword argument that is now axis."}]}},
{"id": "tf.compat.v1.sparse_split", "type": "function", "code": "tf.compat.v1.sparse_split(keyword_required=KeywordRequired(),sp_input=None,num_split=None,axis=None,name=None,split_dim=None)", "summary": "Split a SparseTensor into num_split tensors along axis. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_split", "parameters": [{"name": "keyword_required", "is_optional": true, "type": "others", "default_value": "KeywordRequire", "description": "Python 2 standin for * (temporary for argument reorder)\nsp_input: The SparseTensor to split.\nnum_split: A Python integer. The number of ways to split.\naxis: A 0-D int32 Tensor. The dimension along which to split.\nname: A name for the operation (optional).\nsplit_dim: Deprecated old name for axis."}]}},
{"id": "tf.compat.v1.sparse_segment_sum", "type": "function", "code": "tf.compat.v1.sparse_segment_sum(data,indices,segment_ids,name=None,num_segments=None)", "summary": "Computes the sum along sparse segments of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.sparse_segment_sum", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}]}},
{"id": "tf.compat.v1.sparse_reduce_max", "type": "function", "code": "tf.compat.v1.sparse_reduce_max(sp_input,axis=None,keepdims=None,reduction_axes=None,keep_dims=None)", "summary": "Computes the max of elements across dimensions of a SparseTensor. (deprecated arguments) (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_reduce_max", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "reduction_axes", "is_optional": true, "type": "string", "default_value": "None", "description": "Deprecated name of axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": " Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.sparse_merge", "type": "function", "code": "tf.compat.v1.sparse_merge(sp_ids,sp_values,vocab_size,name=None,already_sorted=False)", "summary": "Combines a batch of feature ids and values into a single SparseTensor. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_merge", "parameters": [{"name": "sp_ids", "is_optional": false, "type": "tensor", "description": "A single SparseTensor with values property of type int32\nor int64 or a Python list of such SparseTensors or a list thereof."}, {"name": "sp_values", "is_optional": false, "type": "tensor", "description": "A SparseTensor of any type."}, {"name": "vocab_size", "is_optional": false, "type": "tensor", "description": "A scalar int64 Tensor (or Python int) containing the new size\nof the last dimension, all(0 &lt;= sp_ids.values &lt; vocab_size).\nOr a list thereof with all(0 &lt;= sp_ids[i].values &lt; vocab_size[i]) for\nall i."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)"}, {"name": "already_sorted", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean to specify whether the per-batch values in\nsp_values are already sorted. If so skip sorting, False by default\n(optional)."}]}},
{"id": "tf.compat.v1.sparse_reduce_max_sparse", "type": "function", "code": "tf.compat.v1.sparse_reduce_max_sparse(sp_input,axis=None,keepdims=None,reduction_axes=None,keep_dims=None)", "summary": "Computes the max of elements across dimensions of a SparseTensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_reduce_max_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "reduction_axes", "is_optional": true, "type": "string", "default_value": "None", "description": "Deprecated name of axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.sparse_reduce_sum", "type": "function", "code": "tf.compat.v1.sparse_reduce_sum(sp_input,axis=None,keepdims=None,reduction_axes=None,keep_dims=None)", "summary": "Computes the sum of elements across dimensions of a SparseTensor. (deprecated arguments) (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_reduce_sum", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "reduction_axes", "is_optional": true, "type": "string", "default_value": "None", "description": "Deprecated name of axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.sparse_segment_sqrt_n", "type": "function", "code": "tf.compat.v1.sparse_segment_sqrt_n(data,indices,segment_ids,name=None,num_segments=None)", "summary": "Computes the sum along sparse segments of a tensor divided by the sqrt(N).", "description": "", "code-info": {"name": "tf.compat.v1.sparse_segment_sqrt_n", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}]}},
{"id": "tf.compat.v1.sparse_segment_mean", "type": "function", "code": "tf.compat.v1.sparse_segment_mean(data,indices,segment_ids,name=None,num_segments=None)", "summary": "Computes the mean along sparse segments of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.sparse_segment_mean", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor with data that will be assembled in the output."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into data. Has same rank as\nsegment_ids."}, {"name": "segment_ids", "is_optional": false, "type": "tensor", "description": "A 1-D Tensor with indices into the output Tensor. Values\nshould be sorted and can be repeated."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "num_segments", "is_optional": true, "type": "float", "default_value": "None", "description": "An optional int32 scalar. Indicates the size of the output\nTensor."}]}},
{"id": "tf.compat.v1.sparse_reduce_sum_sparse", "type": "function", "code": "tf.compat.v1.sparse_reduce_sum_sparse(sp_input,axis=None,keepdims=None,reduction_axes=None,keep_dims=None)", "summary": "Computes the sum of elements across dimensions of a SparseTensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_reduce_sum_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The SparseTensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "The dimensions to reduce; list or scalar. If None (the\ndefault), reduces all dimensions."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retain reduced dimensions with length 1."}, {"name": "reduction_axes", "is_optional": true, "type": "string", "default_value": "None", "description": "Deprecated name of axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.sparse_add", "type": "function", "code": "tf.compat.v1.sparse_add(a,b,threshold=None,thresh=None)", "summary": "Adds two tensors, at least one of each is a SparseTensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_add", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "The first operand; SparseTensor or Tensor."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "The second operand; SparseTensor or Tensor. At least one operand\nmust be sparse."}, {"name": "threshold", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An optional 0-D Tensor (defaults to 0). The magnitude\nthreshold that determines if an output value/index pair takes space. Its\ndtype should match that of the values if they are real; if the latter are\ncomplex64/complex128, then the dtype should be float32/float64,\ncorrespondingly."}, {"name": "thresh", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for threshold."}]}},
{"id": "tf.compat.v1.sparse_matmul", "type": "function", "code": "tf.compat.v1.sparse_matmul(a,b,transpose_a=False,transpose_b=False,a_is_sparse=False,b_is_sparse=False,name=None)", "summary": "Multiply matrix \"a\" by matrix \"b\".", "description": "", "code-info": {"name": "tf.compat.v1.sparse_matmul", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, bfloat16."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, bfloat16."}, {"name": "transpose_a", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "transpose_b", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "a_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "b_is_sparse", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.sparse_placeholder", "type": "function", "code": "tf.compat.v1.sparse_placeholder(dtype,shape=None,name=None)", "summary": "Inserts a placeholder for a sparse tensor that will be always fed.", "description": "", "code-info": {"name": "tf.compat.v1.sparse_placeholder", "parameters": [{"name": "dtype", "is_optional": false, "type": "tensor", "description": "The type of values elements in the tensor to be fed."}, {"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The shape of the tensor to be fed (optional). If the shape is not\nspecified, you can feed a sparse tensor of any shape."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for prefixing the operations (optional)."}]}},
{"id": "tf.compat.v1.sparse_concat", "type": "function", "code": "tf.compat.v1.sparse_concat(axis,sp_inputs,name=None,expand_nonconcat_dim=False,concat_dim=None,expand_nonconcat_dims=None)", "summary": "Concatenates a list of SparseTensor along the specified dimension. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.sparse_concat", "parameters": [{"name": "axis", "is_optional": false, "type": "others", "description": "Dimension to concatenate along. Must be in range [-rank, rank),\nwhere rank is the number of dimensions in each input SparseTensor."}, {"name": "sp_inputs", "is_optional": false, "type": "tensor", "description": "List of SparseTensor to concatenate."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}, {"name": "expand_nonconcat_dim", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether to allow the expansion in the non-concat\ndimensions. Defaulted to False."}, {"name": "concat_dim", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "expand_nonconcat_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "alias for expand_nonconcat_dim"}]}},
{"id": "tf.compat.v1.SparseConditionalAccumulator", "type": "class", "code": "tf.compat.v1.SparseConditionalAccumulator(dtype,shape=None,shared_name=None,name='sparse_conditional_accumulator',reduction_type='MEAN')", "summary": "A conditional accumulator for aggregating sparse gradients.\n\nInherits From: ConditionalAccumulatorBase", "description": "", "code-info": {"name": "tf.compat.v1.SparseConditionalAccumulator", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": "Datatype of the accumulated gradients."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of the accumulated gradients."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. If non-empty, this accumulator will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'sparse_conditional_accumulator'", "description": "Optional name for the accumulator."}, {"name": "reduction_type", "is_optional": true, "type": "string", "default_value": "'MEAN'", "description": "Reduction type to use when taking the gradient."}]}},
{"id": "tf.compat.v1.space_to_depth", "type": "function", "code": "tf.compat.v1.space_to_depth(input,block_size,name=None,data_format='NHWC')", "summary": "SpaceToDepth for tensors of type T.", "description": "", "code-info": {"name": "tf.compat.v1.space_to_depth", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "block_size", "is_optional": false, "type": "others", "description": "An int that is &gt;= 2. The size of the spatial block.\ndata_format: An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor. Has the same type as input.\n\n          "}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\".\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.space_to_batch", "type": "function", "code": "tf.compat.v1.space_to_batch(input,paddings,block_size=None,name=None,block_shape=None)", "summary": "SpaceToBatch for 4-D tensors of type T.", "description": "", "code-info": {"name": "tf.compat.v1.space_to_batch", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D with shape [batch, height, width, depth]."}, {"name": "paddings", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n2-D tensor of non-negative integers with shape [2, 2]. It specifies\nthe padding of the input with zeros across the spatial dimensions as follows:\npaddings = [[pad_top, pad_bottom], [pad_left, pad_right]]\n\nThe effective spatial dimensions of the zero-padded input tensor will be:\nheight_pad = pad_top + height + pad_bottom\nwidth_pad = pad_left + width + pad_right\n\nThe attr block_size must be greater than one. It indicates the block size.\n\n\nNon-overlapping blocks of size block_size x block size in the height and\nwidth dimensions are rearranged into the batch dimension at each location.\nThe batch of the output tensor is batch * block_size * block_size.\nBoth height_pad and width_pad must be divisible by block_size.\n\n\nThe shape of the output will be:\n\n[batchblock_sizeblock_size, height_pad/block_size, width_pad/block_size,\n   depth]\n\nSome examples:\n\n(1) For the following input of shape [1, 2, 2, 1] and block_size of 2:\n\n\n\nx = [[[[1], [2]], [[3], [4]]]]\n\n\nThe output tensor has shape [4, 1, 1, 1] and value:\n\n\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n\n\n(2) For the following input of shape [1, 2, 2, 3] and block_size of 2:\n\n\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n\n\nThe output tensor has shape [4, 1, 1, 3] and value:\n\n\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n\n\n(3) For the following input of shape [1, 4, 4, 1] and block_size of 2:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [4, 2, 2, 1] and value:\n\n\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n\n\n(4) For the following input of shape [2, 2, 4, 1] and block_size of 2:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [8, 1, 2, 1] and value:\n\n\nx = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]],\n     [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]]\n\n\nAmong others, this operation is useful for reducing atrous convolution into\n  regular convolution.\n\n"}, {"name": "block_size", "is_optional": true, "type": "others", "default_value": "None", "description": "An int that is &gt;= 2."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "block_shape", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.size", "type": "function", "code": "tf.compat.v1.size(input,name=None,out_type=tf.dtypes.int32)", "summary": "Returns the size of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.size", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "(Optional) The specified non-quantized numeric output type of the\noperation. Defaults to tf.int32."}]}},
{"id": "tf.compat.v1.shape", "type": "function", "code": "tf.compat.v1.shape(input,name=None,out_type=tf.dtypes.int32)", "summary": "Returns the shape of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.shape", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "(Optional) The specified output type of the operation (int32 or\nint64). Defaults to tf.int32."}]}},
{"id": "tf.compat.v1.set_random_seed", "type": "function", "code": "tf.compat.v1.set_random_seed(seed)", "summary": "Sets the graph-level random seed for the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.set_random_seed", "parameters": [{"name": "seed", "is_optional": false, "type": "int", "description": "integer."}]}},
{"id": "tf.compat.v1.setdiff1d", "type": "function", "code": "tf.compat.v1.setdiff1d(x,y,index_dtype=tf.dtypes.int32,name=None)", "summary": "Computes the difference between two lists of numbers or strings.", "description": "", "code-info": {"name": "tf.compat.v1.setdiff1d", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. 1-D. Values to keep."}, {"name": "y", "is_optional": false, "type": "others", "description": ""}, {"name": "index_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_sub", "type": "function", "code": "tf.compat.v1.scatter_sub(ref,indices,updates,use_locking=False,name=None)", "summary": "Subtracts sparse updates to a variable reference.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_sub", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int32, uint8, int16, int8, complex64, int64,\nqint8, quint8, qint32, bfloat16, uint16, complex128, half,\nuint32, uint64. Should be from a Variable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA tensor of updated values to subtract from ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf True, the subtraction will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.serialize_many_sparse", "type": "function", "code": "tf.compat.v1.serialize_many_sparse(sp_input,name=None,out_type=tf.dtypes.string)", "summary": "Serialize N-minibatch SparseTensor into an [N, 3] Tensor.", "description": "", "code-info": {"name": "tf.compat.v1.serialize_many_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input rank R SparseTensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.string", "description": "The dtype to use for serialization."}]}},
{"id": "tf.compat.v1.scatter_nd_add", "type": "function", "code": "tf.compat.v1.scatter_nd_add(ref,indices,updates,use_locking=False,name=None)", "summary": "Applies sparse addition to individual values or slices in a Variable.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_nd_add", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int32, uint8, int16, int8, complex64, int64,\nqint8, quint8, qint32, bfloat16, uint16, complex128, half,\nuint32, uint64. A mutable Tensor. Should be from a Variable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA tensor of updated values to add to ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_nd_update", "type": "function", "code": "tf.compat.v1.scatter_nd_update(ref,indices,updates,use_locking=True,name=None)", "summary": "Applies sparse updates to individual values or slices in a Variable.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_nd_update", "parameters": [{"name": "ref", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA Tensor. Must have the same type as ref. A tensor of updated\nvalues to add to ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nAn optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.serialize_sparse", "type": "function", "code": "tf.compat.v1.serialize_sparse(sp_input,name=None,out_type=tf.dtypes.string)", "summary": "Serialize a SparseTensor into a 3-vector (1-D Tensor) object.", "description": "", "code-info": {"name": "tf.compat.v1.serialize_sparse", "parameters": [{"name": "sp_input", "is_optional": false, "type": "tensor", "description": "The input SparseTensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A name prefix for the returned tensors (optional)."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.string", "description": "The dtype to use for serialization."}]}},
{"id": "tf.compat.v1.scatter_update", "type": "function", "code": "tf.compat.v1.scatter_update(ref,indices,updates,use_locking=True,name=None)", "summary": "Applies sparse updates to a variable reference.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_update", "parameters": [{"name": "ref", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA tensor of updated values to store in ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nIf True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_nd_sub", "type": "function", "code": "tf.compat.v1.scatter_nd_sub(ref,indices,updates,use_locking=False,name=None)", "summary": "Applies sparse subtraction to individual values or slices in a Variable.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_nd_sub", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int32, uint8, int16, int8, complex64, int64,\nqint8, quint8, qint32, bfloat16, uint16, complex128, half,\nuint32, uint64. A mutable Tensor. Should be from a Variable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA tensor of updated values to add to ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nAn optional bool. Defaults to True. If True, the assignment will\nbe protected by a lock; otherwise the behavior is undefined,\nbut may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.Session", "type": "class", "code": "tf.compat.v1.Session(target='',graph=None,config=None)", "summary": "A class for running TensorFlow operations.", "description": "", "code-info": {"name": "tf.compat.v1.Session", "parameters": [{"name": "target", "is_optional": true, "type": "string", "default_value": "''", "description": "(Optional.) The execution engine to connect to. Defaults to using\nan in-process engine. See\nDistributed TensorFlow for\nmore examples."}, {"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) The Graph to be launched (described above)."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) A\nConfigProto\nprotocol buffer with configuration options for the session."}]}},
{"id": "tf.compat.v1.scatter_min", "type": "function", "code": "tf.compat.v1.scatter_min(ref,indices,updates,use_locking=False,name=None)", "summary": "Reduces sparse updates into a variable reference using the min operation.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_min", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: half,\nbfloat16, float32, float64, int32, int64. Should be from a\nVariable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. A\ntensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to reduce into ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False. If True, the update\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_mul", "type": "function", "code": "tf.compat.v1.scatter_mul(ref,indices,updates,use_locking=False,name=None)", "summary": "Multiplies sparse updates into a variable reference.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_mul", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int32, uint8, int16, int8, complex64, int64,\nqint8, quint8, qint32, bfloat16, uint16, complex128, half,\nuint32, uint64. Should be from a Variable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. A\ntensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to multiply to ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False. If True, the operation\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_div", "type": "function", "code": "tf.compat.v1.scatter_div(ref,indices,updates,use_locking=False,name=None)", "summary": "Divides a variable reference by sparse updates.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_div", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int32, uint8, int16, int8, complex64, int64,\nqint8, quint8, qint32, bfloat16, uint16, complex128, half,\nuint32, uint64. Should be from a Variable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. A\ntensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref. A tensor of values\nthat ref is divided by."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False. If True, the operation\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_max", "type": "function", "code": "tf.compat.v1.scatter_max(ref,indices,updates,use_locking=False,name=None)", "summary": "Reduces sparse updates into a variable reference using the max operation.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_max", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: half,\nbfloat16, float32, float64, int32, int64. Should be from a\nVariable node."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. A\ntensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref. A tensor of updated\nvalues to reduce into ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False. If True, the update\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scatter_add", "type": "function", "code": "tf.compat.v1.scatter_add(ref,indices,updates,use_locking=False,name=None)", "summary": "Adds sparse updates to the variable referenced by resource.", "description": "", "code-info": {"name": "tf.compat.v1.scatter_add", "parameters": [{"name": "ref", "is_optional": false, "type": "others", "description": "A Variable."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nA tensor of indices into the first dimension of ref."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as ref.\nA tensor of updated values to store in ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "False", "description": "An optional bool. Defaults to False.\nIf True, the assignment will be protected by a lock;\notherwise the behavior is undefined, but may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.scalar_mul", "type": "function", "code": "tf.compat.v1.scalar_mul(scalar,x,name=None)", "summary": "Multiplies a scalar times a Tensor or IndexedSlices object.", "description": "", "code-info": {"name": "tf.compat.v1.scalar_mul", "parameters": [{"name": "scalar", "is_optional": false, "type": "tensor", "description": "A 0-D scalar Tensor. Must have known shape."}, {"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or IndexedSlices to be scaled."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.resource_variables_enabled", "type": "function", "code": "tf.compat.v1.resource_variables_enabled()", "summary": "Returns True if resource variables are enabled.", "description": "", "code-info": {"name": "tf.compat.v1.resource_variables_enabled", "parameters": []}},
{"id": "tf.compat.v1.reset_default_graph", "type": "function", "code": "tf.compat.v1.reset_default_graph()", "summary": "Clears the default graph stack and resets the global default graph.", "description": "", "code-info": {"name": "tf.compat.v1.reset_default_graph", "parameters": []}},
{"id": "tf.compat.v1.report_uninitialized_variables", "type": "function", "code": "tf.compat.v1.report_uninitialized_variables(var_list=None,name='report_uninitialized_variables')", "summary": "Adds ops to list the names of uninitialized variables.", "description": "", "code-info": {"name": "tf.compat.v1.report_uninitialized_variables", "parameters": [{"name": "var_list", "is_optional": true, "type": "others", "default_value": "None", "description": "List of Variable objects to check. Defaults to the value of\nglobal_variables() + local_variables()"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'report_uninitialized_variables'", "description": "Optional name of the Operation."}]}},
{"id": "tf.compat.v1.reverse_sequence", "type": "function", "code": "tf.compat.v1.reverse_sequence(input,seq_lengths,seq_axis=None,batch_axis=None,name=None,seq_dim=None,batch_dim=None)", "summary": "Reverses variable length slices. (deprecated arguments) (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reverse_sequence", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. The input to reverse."}, {"name": "seq_lengths", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32,\n  int64. 1-D with length input.dims(batch_dim) and max(seq_lengths) &lt;=\n  input.dims(seq_dim)"}, {"name": "seq_axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. The dimension which is partially reversed."}, {"name": "batch_axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0. The dimension along which\n  reversal is performed."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "seq_dim", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "batch_dim", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.reduce_sum", "type": "function", "code": "tf.compat.v1.reduce_sum(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the sum of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_sum", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_max", "type": "function", "code": "tf.compat.v1.reduce_max(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the maximum of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_max", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have real numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_any", "type": "function", "code": "tf.compat.v1.reduce_any(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the \"logical or\" of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_any", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The boolean tensor to reduce."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_mean", "type": "function", "code": "tf.compat.v1.reduce_mean(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the mean of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.reduce_mean", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_min", "type": "function", "code": "tf.compat.v1.reduce_min(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the minimum of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_min", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have real numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_logsumexp", "type": "function", "code": "tf.compat.v1.reduce_logsumexp(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes log(sum(exp(elements across dimensions of a tensor))). (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_logsumexp", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_all", "type": "function", "code": "tf.compat.v1.reduce_all(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the \"logical and\" of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_all", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The boolean tensor to reduce."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.reduce_prod", "type": "function", "code": "tf.compat.v1.reduce_prod(input_tensor,axis=None,keepdims=None,name=None,reduction_indices=None,keep_dims=None)", "summary": "Computes the product of elements across dimensions of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.reduce_prod", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The tensor to reduce. Should have numeric type."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.ReaderBase", "type": "class", "code": "tf.compat.v1.ReaderBase(reader_ref,supports_serialize=False)", "summary": "Base class for different Reader types, that produce a record every step.", "description": "", "code-info": {"name": "tf.compat.v1.ReaderBase", "parameters": [{"name": "reader_ref", "is_optional": false, "type": "others", "description": "The operation that implements the reader."}, {"name": "supports_serialize", "is_optional": true, "type": "bool", "default_value": "False", "description": "True if the reader implementation can\nserialize its state."}]}},
{"id": "tf.compat.v1.reduce_join", "type": "function", "code": "tf.compat.v1.reduce_join(inputs,axis=None,keep_dims=None,separator='',name=None,reduction_indices=None,keepdims=None)", "summary": "Joins all strings into a single string, or joins along an axis.", "description": "", "code-info": {"name": "tf.compat.v1.reduce_join", "parameters": [{"name": "inputs", "is_optional": false, "type": "tensor", "description": "A tf.string tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "separator", "is_optional": true, "type": "string", "default_value": "''", "description": "a string added between each string being joined."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "reduction_indices", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1.\nseparator: a string added between each string being joined.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.random_poisson", "type": "function", "code": "tf.compat.v1.random_poisson(lam,shape,dtype=tf.dtypes.float32,seed=None,name=None)", "summary": "Draws shape samples from each of the given Poisson distribution(s).", "description": "", "code-info": {"name": "tf.compat.v1.random_poisson", "parameters": [{"name": "lam", "is_optional": false, "type": "tensor", "description": "A Tensor or Python value or N-D array of type dtype.\nlam provides the rate parameter(s) describing the poisson\ndistribution(s) to sample."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor or Python array. The shape of the output samples\nto be drawn per \"rate\"-parameterized distribution."}, {"name": "dtype", "is_optional": true, "type": "float", "default_value": "tf.dtypes.float32", "description": "The type of the output: float16, float32, float64, int32 or\nint64."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distributions.\nSee\ntf.compat.v1.set_random_seed\nfor behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.compat.v1.random_uniform_initializer", "type": "function", "code": "tf.compat.v1.random_uniform_initializer(minval=0,maxval=None,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors with a uniform distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.random_uniform_initializer", "parameters": [{"name": "minval", "is_optional": true, "type": "int", "default_value": "0", "description": "A python scalar or a scalar tensor. Lower bound of the range of\nrandom values to generate."}, {"name": "maxval", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A python scalar or a scalar tensor. Upper bound of the range of\nrandom values to generate.  Defaults to 1 for float types."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer."}]}},
{"id": "tf.compat.v1.random_normal_initializer", "type": "function", "code": "tf.compat.v1.random_normal_initializer(mean=0.0,stddev=1.0,seed=None,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors with a normal distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.compat.v1.random_normal_initializer", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values to\ngenerate."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "1.0", "description": "a python scalar or a scalar tensor. Standard deviation of the random\nvalues to generate."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed for behavior."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Default data type, used if no dtype argument is provided when\ncalling the initializer. Only floating point types are supported."}]}},
{"id": "tf.compat.v1.placeholder_with_default", "type": "function", "code": "tf.compat.v1.placeholder_with_default(input,shape,name=None)", "summary": "A placeholder op that passes through input when its output is not fed.", "description": "", "code-info": {"name": "tf.compat.v1.placeholder_with_default", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. The default value to produce when output is not fed."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A tf.TensorShape or list of ints. The (possibly partial) shape of\nthe tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.quantize_v2", "type": "function", "code": "tf.compat.v1.quantize_v2(input,min_range,max_range,T,mode='MIN_COMBINED',name=None,round_mode='HALF_AWAY_FROM_ZERO',narrow_range=False,axis=None,ensure_minimum_range=0.01)", "summary": "Please use tf.quantization.quantize instead.", "description": "", "code-info": {"name": "tf.compat.v1.quantize_v2", "parameters": [{"name": "input", "is_optional": false, "type": "others", "description": ""}, {"name": "min_range", "is_optional": false, "type": "others", "description": ""}, {"name": "max_range", "is_optional": false, "type": "others", "description": ""}, {"name": "T", "is_optional": false, "type": "others", "description": ""}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'MIN_COMBINED'", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "round_mode", "is_optional": true, "type": "string", "default_value": "'HALF_AWAY_FROM_ZERO'", "description": ""}, {"name": "narrow_range", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "ensure_minimum_range", "is_optional": true, "type": "others", "default_value": "0.01", "description": ""}]}},
{"id": "tf.compat.v1.placeholder", "type": "function", "code": "tf.compat.v1.placeholder(dtype,shape=None,name=None)", "summary": "Inserts a placeholder for a tensor that will be always fed.", "description": "", "code-info": {"name": "tf.compat.v1.placeholder", "parameters": [{"name": "dtype", "is_optional": false, "type": "tensor", "description": "The type of elements in the tensor to be fed."}, {"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The shape of the tensor to be fed (optional). If the shape is not\nspecified, you can feed a tensor of any shape."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.py_func", "type": "function", "code": "tf.compat.v1.py_func(func,inp,Tout,stateful=True,name=None)", "summary": "Wraps a python function and uses it as a TensorFlow op.", "description": "", "code-info": {"name": "tf.compat.v1.py_func", "parameters": [{"name": "func", "is_optional": false, "type": "others", "description": "A Python function, which accepts ndarray objects as arguments and\nreturns a list of ndarray objects (or a single ndarray). This function\nmust accept as many arguments as there are tensors in inp, and these\nargument types will match the corresponding tf.Tensor objects in inp.\nThe returns ndarrays must match the number and types defined Tout.\nImportant Note: Input and output numpy ndarrays of func are not\nguaranteed to be copies. In some cases their underlying memory will be\nshared with the corresponding TensorFlow tensors. In-place modification\nor storing func input or return values in python datastructures\nwithout explicit (np.)copy can have non-deterministic consequences."}, {"name": "inp", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects."}, {"name": "Tout", "is_optional": false, "type": "tensor", "description": "A list or tuple of tensorflow data types or a single tensorflow data\ntype if there is only one, indicating what func returns."}, {"name": "stateful", "is_optional": true, "type": "bool", "default_value": "True", "description": "(Boolean.) If True, the function should be considered stateful. If\na function is stateless, when given the same input it will return the same\noutput and have no observable side effects. Optimizations such as common\nsubexpression elimination are only performed on stateless operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.Print", "type": "function", "code": "tf.compat.v1.Print(input_,data,message=None,first_n=None,summarize=None,name=None)", "summary": "Prints a list of tensors. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.Print", "parameters": [{"name": "input_", "is_optional": false, "type": "tensor", "description": "A tensor passed through this op."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A list of tensors to print out when op is evaluated."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string, prefix of the error message."}, {"name": "first_n", "is_optional": true, "type": "others", "default_value": "None", "description": "Only log first_n number of times. Negative numbers log always;\nthis is the default."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Only print this many entries of each tensor. If None, then a\nmaximum of 3 elements are printed per input tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.parse_single_example", "type": "function", "code": "tf.compat.v1.parse_single_example(serialized,features,name=None,example_names=None)", "summary": "Parses a single Example proto.", "description": "", "code-info": {"name": "tf.compat.v1.parse_single_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A scalar string Tensor, a single serialized Example."}, {"name": "features", "is_optional": false, "type": "others", "description": "A dict mapping feature keys to FixedLenFeature or\nVarLenFeature values."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional)."}, {"name": "example_names", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional) A scalar string Tensor, the associated name."}]}},
{"id": "tf.compat.v1.parse_example", "type": "function", "code": "tf.compat.v1.parse_example(serialized,features,name=None,example_names=None)", "summary": "Parses Example protos into a dict of tensors.", "description": "", "code-info": {"name": "tf.compat.v1.parse_example", "parameters": [{"name": "serialized", "is_optional": false, "type": "tensor", "description": "A vector (1-D Tensor) of strings, a batch of binary\nserialized Example protos."}, {"name": "features", "is_optional": false, "type": "string", "description": "{\n    \"kw\": VarLenFeature(tf.string),\n    \"dank\": VarLenFeature(tf.int64),\n    \"gps\": VarLenFeature(tf.float32),\n}\n\nThen the output is a dictionary:\n{\n  \"kw\": SparseTensor(\n      indices=[[0, 0], [0, 1], [1, 0]],\n      values=[\"knit\", \"big\", \"emmy\"]\n      dense_shape=[2, 2]),\n  \"dank\": SparseTensor(\n      indices=[[1, 0]],\n      values=[42],\n      dense_shape=[2, 1]),\n  \"gps\": SparseTensor(\n      indices=[],\n      values=[],\n      dense_shape=[2, 0]),\n}\n\nFor dense results in two serialized Examples:\n[\n  features {\n    feature { key: \"age\" value { int64_list { value: [ 0 ] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n   },\n   features {\n    feature { key: \"age\" value { int64_list { value: [] } } }\n    feature { key: \"gender\" value { bytes_list { value: [ \"f\" ] } } }\n  }\n]\n\nWe can use arguments:\nexample_names: [\"input0\", \"input1\"],"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).\n\n\nReturns:\n\nA dict mapping feature keys to Tensor, SparseTensor, and\nRaggedTensor values.\n\nRaises:\n\n\nValueError: if any feature is invalid.\n\n\n          "}, {"name": "example_names", "is_optional": true, "type": "others", "default_value": "None", "description": "[\"input0\", \"input1\"],\nfeatures: {\n    \"kw\": VarLenFeature(tf.string),\n    \"dank\": VarLenFeature(tf.int64),\n    \"gps\": VarLenFeature(tf.float32),\n}"}]}},
{"id": "tf.compat.v1.pad", "type": "function", "code": "tf.compat.v1.pad(tensor,paddings,mode='CONSTANT',name=None,constant_values=0)", "summary": "Pads a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.pad", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "paddings", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'CONSTANT'", "description": "One of \"CONSTANT\", \"REFLECT\", or \"SYMMETRIC\" (case-insensitive)"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "constant_values", "is_optional": true, "type": "int", "default_value": "0", "description": "In \"CONSTANT\" mode, the scalar pad value to use. Must be\nsame type as tensor."}]}},
{"id": "tf.compat.v1.ones_like", "type": "function", "code": "tf.compat.v1.ones_like(tensor,dtype=None,name=None,optimize=True)", "summary": "Creates a tensor with all elements set to 1.", "description": "", "code-info": {"name": "tf.compat.v1.ones_like", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A type for the returned Tensor. Must be float32, float64,\nint8, uint8, int16, uint16, int32, int64, complex64,\ncomplex128 or bool."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "optimize", "is_optional": true, "type": "bool", "default_value": "True", "description": "if true, attempt to statically determine the shape of 'tensor' and\nencode it as a constant."}]}},
{"id": "tf.compat.v1.multinomial", "type": "function", "code": "tf.compat.v1.multinomial(logits,num_samples,seed=None,name=None,output_dtype=None)", "summary": "Draws samples from a multinomial distribution. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.multinomial", "parameters": [{"name": "logits", "is_optional": false, "type": "tensor", "description": "2-D Tensor with shape [batch_size, num_classes].  Each slice\n[i, :] represents the unnormalized log-probabilities for all classes."}, {"name": "num_samples", "is_optional": false, "type": "others", "description": "0-D.  Number of independent samples to draw for each row slice."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create a random seed for the distribution.\nSee tf.compat.v1.set_random_seed for behavior."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}, {"name": "output_dtype", "is_optional": true, "type": "int", "default_value": "None", "description": "integer type to use for the output. Defaults to int64."}]}},
{"id": "tf.compat.v1.no_regularizer", "type": "function", "code": "tf.compat.v1.no_regularizer(_)", "summary": "Use this function to prevent regularization of variables.", "description": "", "code-info": {"name": "tf.compat.v1.no_regularizer", "parameters": [{"name": "_", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.compat.v1.norm", "type": "function", "code": "tf.compat.v1.norm(tensor,ord='euclidean',axis=None,keepdims=None,name=None,keep_dims=None)", "summary": "Computes the norm of vectors, matrices, and tensors. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.norm", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of types float32, float64, complex64, complex128"}, {"name": "ord", "is_optional": true, "type": "string", "default_value": "'euclidean'", "description": "Order of the norm. Supported values are 'fro', 'euclidean',\n1, 2, np.inf and any positive real number yielding the corresponding\np-norm. Default is 'euclidean' which is equivalent to Frobenius norm if\ntensor is a matrix and equivalent to 2-norm for vectors.\nSome restrictions apply:\na) The Frobenius norm fro is not defined for vectors,\nb) If axis is a 2-tuple (matrix norm), only 'euclidean', 'fro', 1,\n   2, np.inf are supported.\nSee the description of axis on how to compute norms for a batch of\nvectors or matrices stored in a tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "If axis is None (the default), the input is considered a vector\nand a single vector norm is computed over the entire set of values in the\ntensor, i.e. norm(tensor, ord=ord) is equivalent to\nnorm(reshape(tensor, [-1]), ord=ord).\nIf axis is a Python integer, the input is considered a batch of vectors,\nand axis determines the axis in tensor over which to compute vector\nnorms.\nIf axis is a 2-tuple of Python integers it is considered a batch of\nmatrices and axis determines the axes in tensor over which to compute\na matrix norm.\nNegative indices are supported. Example: If you are passing a tensor that\ncan be either a matrix or a batch of matrices at runtime, pass\naxis=[-2,-1] instead of axis=None to make sure that matrix norms are\ncomputed."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If True, the axis indicated in axis are kept with size 1.\nOtherwise, the dimensions in axis are removed from the output shape."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the op."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}]}},
{"id": "tf.compat.v1.moving_average_variables", "type": "function", "code": "tf.compat.v1.moving_average_variables(scope=None)", "summary": "Returns all variables that maintain their moving averages.", "description": "", "code-info": {"name": "tf.compat.v1.moving_average_variables", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A string. If supplied, the resulting list is filtered to\ninclude only items whose name attribute matches scope using\nre.match. Items without a name attribute are never returned if a scope\nis supplied. The choice of re.match means that a scope without special\ntokens filters by prefix."}]}},
{"id": "tf.compat.v1.model_variables", "type": "function", "code": "tf.compat.v1.model_variables(scope=None)", "summary": "Returns all variables in the MODEL_VARIABLES collection.", "description": "", "code-info": {"name": "tf.compat.v1.model_variables", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A string. If supplied, the resulting list is filtered to\ninclude only items whose name attribute matches scope using\nre.match. Items without a name attribute are never returned if a scope\nis supplied. The choice of re.match means that a scope without special\ntokens filters by prefix."}]}},
{"id": "tf.compat.v1.min_max_variable_partitioner", "type": "function", "code": "tf.compat.v1.min_max_variable_partitioner(max_partitions=1,axis=0,min_slice_size=(256&lt;&lt;10),bytes_per_string_element=16)", "summary": "Partitioner to allocate minimum size per slice.", "description": "", "code-info": {"name": "tf.compat.v1.min_max_variable_partitioner", "parameters": [{"name": "max_partitions", "is_optional": true, "type": "int", "default_value": "1", "description": "Upper bound on the number of partitions. Defaults to 1."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "Axis along which to partition the variable. Defaults to 0."}, {"name": "min_slice_size", "is_optional": false, "type": "others", "description": "Minimum size of the variable slice per partition. Defaults\nto 256K.\nbytes_per_string_element: If the Variable is of type string, this provides\nan estimate of how large each scalar in the Variable is."}]}},
{"id": "tf.compat.v1.make_template", "type": "function", "code": "tf.compat.v1.make_template(name_,func_,create_scope_now_=False,unique_name_=None,custom_getter_=None,**kwargs)", "summary": "Given an arbitrary function, wrap it so that it does variable sharing.", "description": "", "code-info": {"name": "tf.compat.v1.make_template", "parameters": [{"name": "name_", "is_optional": false, "type": "string", "description": "A name for the scope created by this template. If necessary, the name\nwill be made unique by appending _N to the name."}, {"name": "func_", "is_optional": false, "type": "others", "description": "The function to wrap."}, {"name": "create_scope_now_", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean controlling whether the scope should be created\nwhen the template is constructed or when the template is called. Default\nis False, meaning the scope is created when the template is called."}, {"name": "unique_name_", "is_optional": true, "type": "string", "default_value": "None", "description": "When used, it overrides name_ and is not made unique. If a\ntemplate of the same scope/unique_name already exists and reuse is false,\nan error is raised. Defaults to None."}, {"name": "custom_getter_", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional custom getter for variables used in func_. See\nthe tf.compat.v1.get_variable custom_getter documentation for more\ninformation."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "Keyword arguments to apply to func_."}]}},
{"id": "tf.compat.v1.local_variables_initializer", "type": "function", "code": "tf.compat.v1.local_variables_initializer()", "summary": "Returns an Op that initializes all local variables.", "description": "", "code-info": {"name": "tf.compat.v1.local_variables_initializer", "parameters": []}},
{"id": "tf.compat.v1.local_variables", "type": "function", "code": "tf.compat.v1.local_variables(scope=None)", "summary": "Returns local variables.", "description": "", "code-info": {"name": "tf.compat.v1.local_variables", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A string. If supplied, the resulting list is filtered to\ninclude only items whose name attribute matches scope using\nre.match. Items without a name attribute are never returned if a scope\nis supplied. The choice of re.match means that a scope without special\ntokens filters by prefix."}]}},
{"id": "tf.compat.v1.is_variable_initialized", "type": "function", "code": "tf.compat.v1.is_variable_initialized(variable)", "summary": "Tests if a variable has been initialized.", "description": "", "code-info": {"name": "tf.compat.v1.is_variable_initialized", "parameters": [{"name": "variable", "is_optional": false, "type": "others", "description": "A Variable."}]}},
{"id": "tf.compat.v1.load_file_system_library", "type": "function", "code": "tf.compat.v1.load_file_system_library(library_filename)", "summary": "Loads a TensorFlow plugin, containing file system implementation. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.load_file_system_library", "parameters": [{"name": "library_filename", "is_optional": false, "type": "others", "description": "Path to the plugin.\nRelative or absolute filesystem path to a dynamic library file."}]}},
{"id": "tf.compat.v1.LMDBReader", "type": "class", "code": "tf.compat.v1.LMDBReader(name=None,options=None)", "summary": "A Reader that outputs the records from a LMDB file.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.LMDBReader", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "options", "is_optional": true, "type": "others", "default_value": "None", "description": "A LMDBRecordOptions object (optional)."}]}},
{"id": "tf.compat.v1.initialize_all_variables", "type": "function", "code": "tf.compat.v1.initialize_all_variables()", "summary": "See tf.compat.v1.global_variables_initializer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.initialize_all_variables", "parameters": []}},
{"id": "tf.compat.v1.InteractiveSession", "type": "class", "code": "tf.compat.v1.InteractiveSession(target='',graph=None,config=None)", "summary": "A TensorFlow Session for use in interactive contexts, such as a shell.", "description": "", "code-info": {"name": "tf.compat.v1.InteractiveSession", "parameters": [{"name": "target", "is_optional": true, "type": "string", "default_value": "''", "description": "(Optional.) The execution engine to connect to. Defaults to using\nan in-process engine."}, {"name": "graph", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) The Graph to be launched (described above)."}, {"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional) ConfigProto proto used to configure the session."}]}},
{"id": "tf.compat.v1.initialize_variables", "type": "function", "code": "tf.compat.v1.initialize_variables(var_list,name='init')", "summary": "See tf.compat.v1.variables_initializer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.initialize_variables", "parameters": [{"name": "var_list", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'init'", "description": ""}]}},
{"id": "tf.compat.v1.initialize_all_tables", "type": "function", "code": "tf.compat.v1.initialize_all_tables(name='init_all_tables')", "summary": "Returns an Op that initializes all tables of the default graph. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.initialize_all_tables", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "'init_all_tables'", "description": "Optional name for the initialization op."}]}},
{"id": "tf.compat.v1.initialize_local_variables", "type": "function", "code": "tf.compat.v1.initialize_local_variables()", "summary": "See tf.compat.v1.local_variables_initializer. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.initialize_local_variables", "parameters": []}},
{"id": "tf.compat.v1.hessians", "type": "function", "code": "tf.compat.v1.hessians(ys,xs,name='hessians',colocate_gradients_with_ops=False,gate_gradients=False,aggregation_method=None)", "summary": "Constructs the Hessian of sum of ys with respect to x in xs.", "description": "", "code-info": {"name": "tf.compat.v1.hessians", "parameters": [{"name": "ys", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be differentiated."}, {"name": "xs", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be used for differentiation."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'hessians'", "description": "Optional name to use for grouping all the gradient ops together.\ndefaults to 'hessians'."}, {"name": "colocate_gradients_with_ops", "is_optional": true, "type": "bool", "default_value": "False", "description": "See gradients() documentation for details."}, {"name": "gate_gradients", "is_optional": true, "type": "bool", "default_value": "False", "description": "See gradients() documentation for details."}, {"name": "aggregation_method", "is_optional": true, "type": "others", "default_value": "None", "description": "See gradients() documentation for details."}]}},
{"id": "tf.compat.v1.IdentityReader", "type": "class", "code": "tf.compat.v1.IdentityReader(name=None)", "summary": "A Reader that outputs the queued work as both the key and value.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.IdentityReader", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.gradients", "type": "function", "code": "tf.compat.v1.gradients(ys,xs,grad_ys=None,name='gradients',colocate_gradients_with_ops=False,gate_gradients=False,aggregation_method=None,stop_gradients=None,unconnected_gradients=tf.UnconnectedGradients.NONE)", "summary": "Constructs symbolic derivatives of sum of ys w.r.t. x in xs.", "description": "", "code-info": {"name": "tf.compat.v1.gradients", "parameters": [{"name": "ys", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be differentiated."}, {"name": "xs", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be used for differentiation."}, {"name": "grad_ys", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional. A Tensor or list of tensors the same size as\nys and holding the gradients computed for each y in ys."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'gradients'", "description": "Optional name to use for grouping all the gradient ops together.\ndefaults to 'gradients'."}, {"name": "colocate_gradients_with_ops", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, try colocating gradients with\nthe corresponding op."}, {"name": "gate_gradients", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, add a tuple around the gradients returned\nfor an operations.  This avoids some race conditions."}, {"name": "aggregation_method", "is_optional": true, "type": "others", "default_value": "None", "description": "Specifies the method used to combine gradient terms.\nAccepted values are constants defined in the class AggregationMethod."}, {"name": "stop_gradients", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional. A Tensor or list of tensors not to differentiate\nthrough."}, {"name": "unconnected_gradients", "is_optional": true, "type": "others", "default_value": "tf.UnconnectedGradients.NONE", "description": "Optional. Specifies the gradient value returned when\nthe given input tensors are unconnected. Accepted values are constants\ndefined in the class tf.UnconnectedGradients and the default value is\nnone."}]}},
{"id": "tf.compat.v1.global_variables_initializer", "type": "function", "code": "tf.compat.v1.global_variables_initializer()", "summary": "Returns an Op that initializes global variables.", "description": "", "code-info": {"name": "tf.compat.v1.global_variables_initializer", "parameters": []}},
{"id": "tf.compat.v1.global_variables", "type": "function", "code": "tf.compat.v1.global_variables(scope=None)", "summary": "Returns global variables.", "description": "", "code-info": {"name": "tf.compat.v1.global_variables", "parameters": [{"name": "scope", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional.) A string. If supplied, the resulting list is filtered to\ninclude only items whose name attribute matches scope using\nre.match. Items without a name attribute are never returned if a scope\nis supplied. The choice of re.match means that a scope without special\ntokens filters by prefix."}]}},
{"id": "tf.compat.v1.get_variable_scope", "type": "function", "code": "tf.compat.v1.get_variable_scope()", "summary": "Returns the current variable scope.", "description": "", "code-info": {"name": "tf.compat.v1.get_variable_scope", "parameters": []}},
{"id": "tf.compat.v1.get_session_handle", "type": "function", "code": "tf.compat.v1.get_session_handle(data,name=None)", "summary": "Return the handle of data.", "description": "", "code-info": {"name": "tf.compat.v1.get_session_handle", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A tensor to be stored in the session."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the return tensor."}]}},
{"id": "tf.compat.v1.get_variable", "type": "function", "code": "tf.compat.v1.get_variable(name,shape=None,dtype=None,initializer=None,regularizer=None,trainable=None,collections=None,caching_device=None,partitioner=None,validate_shape=True,use_resource=None,custom_getter=None,constraint=None,synchronization=tf.VariableSynchronization.AUTO,aggregation=tf.compat.v1.VariableAggregation.NONE)", "summary": "Gets an existing variable with these parameters or create a new one.", "description": "", "code-info": {"name": "tf.compat.v1.get_variable", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The name of the new or existing variable."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of the new or existing variable."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Type of the new or existing variable (defaults to DT_FLOAT)."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "Initializer for the variable if one is created. Can either be\nan initializer object or a Tensor. If it's a Tensor, its shape must be known\nunless validate_shape is False."}, {"name": "regularizer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A (Tensor -&gt; Tensor or None) function; the result of\napplying it on a newly created variable will be added to the collection\ntf.GraphKeys.REGULARIZATION_LOSSES and can be used for regularization."}, {"name": "trainable", "is_optional": true, "type": "others", "default_value": "None", "description": "If True also add the variable to the graph collection\nGraphKeys.TRAINABLE_VARIABLES (see tf.Variable)."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "List of graph collections keys to add the Variable to.\nDefaults to [GraphKeys.GLOBAL_VARIABLES] (see tf.Variable)."}, {"name": "caching_device", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device string or function describing where the\nVariable should be cached for reading.  Defaults to the Variable's\ndevice.  If not None, caches on another device.  Typical use is to\ncache on the device where the Ops using the Variable reside, to\ndeduplicate copying through Switch and other conditional statements."}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional callable that accepts a fully defined TensorShape\nand dtype of the Variable to be created, and returns a list of\npartitions for each axis (currently only one axis can be partitioned)."}, {"name": "validate_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "If False, allows the variable to be initialized with a\nvalue of unknown shape. If True, the default, the shape of initial_value\nmust be known. For this to be used the initializer must be a Tensor and\nnot an initializer object."}, {"name": "use_resource", "is_optional": true, "type": "others", "default_value": "None", "description": "If False, creates a regular Variable. If true, creates an\nexperimental ResourceVariable instead with well-defined semantics.\nDefaults to False (will later change to True). When eager execution is\nenabled this argument is always forced to be True."}, {"name": "custom_getter", "is_optional": true, "type": "others", "default_value": "None", "description": "Callable that takes as a first argument the true getter, and\nallows overwriting the internal get_variable method.\nThe signature of custom_getter should match that of this method,\nbut the most future-proof version will allow for changes:\ndef custom_getter(getter, *args, **kwargs).  Direct access to\nall get_variable parameters is also allowed:\ndef custom_getter(getter, name, *args, **kwargs).  A simple identity\ncustom getter that simply creates variables with modified names is:\n\n\n\ndef custom_getter(getter, name, *args, **kwargs):\n  return getter(name + '_suffix', *args, **kwargs)\n\n\n"}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value\n(which must have the same shape). Constraints are not safe to\nuse when doing asynchronous distributed training."}, {"name": "synchronization", "is_optional": true, "type": "string", "default_value": "tf.VariableSynchronization.AUTO", "description": "Indicates when a distributed a variable will be\naggregated. Accepted values are constants defined in the class\ntf.VariableSynchronization. By default the synchronization is set to\nAUTO and the current DistributionStrategy chooses\nwhen to synchronize."}, {"name": "aggregation", "is_optional": true, "type": "string", "default_value": "tf.compat.v1.VariableAggregation.NONE", "description": "Indicates how a distributed variable will be aggregated.\nAccepted values are constants defined in the class\ntf.VariableAggregation."}]}},
{"id": "tf.compat.v1.get_session_tensor", "type": "function", "code": "tf.compat.v1.get_session_tensor(handle,dtype,name=None)", "summary": "Get the tensor of type dtype by feeding a tensor handle.", "description": "", "code-info": {"name": "tf.compat.v1.get_session_tensor", "parameters": [{"name": "handle", "is_optional": false, "type": "tensor", "description": "The string representation of a persistent tensor handle."}, {"name": "dtype", "is_optional": false, "type": "tensor", "description": "The type of the output tensor."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the return tensor."}]}},
{"id": "tf.compat.v1.get_seed", "type": "function", "code": "tf.compat.v1.get_seed(op_seed)", "summary": "Returns the local seeds an operation should use given an op-specific seed.", "description": "", "code-info": {"name": "tf.compat.v1.get_seed", "parameters": [{"name": "op_seed", "is_optional": false, "type": "int", "description": "integer."}]}},
{"id": "tf.compat.v1.get_local_variable", "type": "function", "code": "tf.compat.v1.get_local_variable(name,shape=None,dtype=None,initializer=None,regularizer=None,trainable=False,collections=None,caching_device=None,partitioner=None,validate_shape=True,use_resource=None,custom_getter=None,constraint=None,synchronization=tf.VariableSynchronization.AUTO,aggregation=tf.compat.v1.VariableAggregation.NONE)", "summary": "Gets an existing local variable or creates a new one.", "description": "", "code-info": {"name": "tf.compat.v1.get_local_variable", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The name of the new or existing variable."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of the new or existing variable."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "Type of the new or existing variable (defaults to DT_FLOAT)."}, {"name": "initializer", "is_optional": true, "type": "others", "default_value": "None", "description": "Initializer for the variable if one is created. Can either be\nan initializer object or a Tensor. If it's a Tensor, its shape must be known\nunless validate_shape is False."}, {"name": "regularizer", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "List of graph collections keys to add the Variable to.\nDefaults to [GraphKeys.LOCAL_VARIABLES] (see tf.Variable)."}, {"name": "caching_device", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device string or function describing where the\nVariable should be cached for reading.  Defaults to the Variable's\ndevice.  If not None, caches on another device.  Typical use is to\ncache on the device where the Ops using the Variable reside, to\ndeduplicate copying through Switch and other conditional statements."}, {"name": "partitioner", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional callable that accepts a fully defined TensorShape\nand dtype of the Variable to be created, and returns a list of\npartitions for each axis (currently only one axis can be partitioned)."}, {"name": "validate_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "If False, allows the variable to be initialized with a\nvalue of unknown shape. If True, the default, the shape of initial_value\nmust be known. For this to be used the initializer must be a Tensor and\nnot an initializer object."}, {"name": "use_resource", "is_optional": true, "type": "others", "default_value": "None", "description": "If False, creates a regular Variable. If true, creates an\nexperimental ResourceVariable instead with well-defined semantics.\nDefaults to False (will later change to True). When eager execution is\nenabled this argument is always forced to be True."}, {"name": "custom_getter", "is_optional": true, "type": "others", "default_value": "None", "description": "Callable that takes as a first argument the true getter, and\nallows overwriting the internal get_variable method.\nThe signature of custom_getter should match that of this method,\nbut the most future-proof version will allow for changes:\ndef custom_getter(getter, *args, **kwargs).  Direct access to\nall get_variable parameters is also allowed:\ndef custom_getter(getter, name, *args, **kwargs).  A simple identity\ncustom getter that simply creates variables with modified names is:\n\n\n\ndef custom_getter(getter, name, *args, **kwargs):\n  return getter(name + '_suffix', *args, **kwargs)\n\n\n"}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value\n(which must have the same shape). Constraints are not safe to\nuse when doing asynchronous distributed training."}, {"name": "synchronization", "is_optional": true, "type": "string", "default_value": "tf.VariableSynchronization.AUTO", "description": "Indicates when a distributed a variable will be\naggregated. Accepted values are constants defined in the class\ntf.VariableSynchronization. By default the synchronization is set to\nAUTO and the current DistributionStrategy chooses\nwhen to synchronize."}, {"name": "aggregation", "is_optional": true, "type": "string", "default_value": "tf.compat.v1.VariableAggregation.NONE", "description": "Indicates how a distributed variable will be aggregated.\nAccepted values are constants defined in the class\ntf.VariableAggregation."}]}},
{"id": "tf.compat.v1.get_default_session", "type": "function", "code": "tf.compat.v1.get_default_session()", "summary": "Returns the default session for the current thread.", "description": "", "code-info": {"name": "tf.compat.v1.get_default_session", "parameters": []}},
{"id": "tf.compat.v1.gather", "type": "function", "code": "tf.compat.v1.gather(params,indices,validate_indices=None,name=None,axis=None,batch_dims=0)", "summary": "Gather slices from params axis axis according to indices.", "description": "", "code-info": {"name": "tf.compat.v1.gather", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "The Tensor from which to gather values. Must be at least rank\naxis + 1."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "The index Tensor.  Must be one of the following types: int32,\nint64. Must be in range [0, params.shape[axis])."}, {"name": "validate_indices", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Deprecated, does nothing.\naxis: A Tensor. Must be one of the following types: int32, int64. The\naxis in params to gather indices from. Must be greater than or equal\nto batch_dims.  Defaults to the first non-batch dimension. Supports\nnegative indexes.\nbatch_dims: An integer.  The number of batch dimensions.  Must be less\nthan rank(indices)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor. Has the same type as params.\n\n          "}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64. The\naxis in params to gather indices from. Must be greater than or equal\nto batch_dims.  Defaults to the first non-batch dimension. Supports\nnegative indexes."}, {"name": "batch_dims", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer.  The number of batch dimensions.  Must be less\nthan rank(indices).\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.get_default_graph", "type": "function", "code": "tf.compat.v1.get_default_graph()", "summary": "Returns the default graph for the current thread.", "description": "", "code-info": {"name": "tf.compat.v1.get_default_graph", "parameters": []}},
{"id": "tf.compat.v1.get_collection_ref", "type": "function", "code": "tf.compat.v1.get_collection_ref(key)", "summary": "Wrapper for Graph.get_collection_ref() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.get_collection_ref", "parameters": [{"name": "key", "is_optional": false, "type": "others", "description": "The key for the collection. For example, the GraphKeys class contains\nmany standard names for collections."}]}},
{"id": "tf.compat.v1.get_collection", "type": "function", "code": "tf.compat.v1.get_collection(key,scope=None)", "summary": "Wrapper for Graph.get_collection() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.get_collection", "parameters": [{"name": "key", "is_optional": false, "type": "others", "description": "The key for the collection. For example, the GraphKeys class contains\nmany standard names for collections."}, {"name": "scope", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) If supplied, the resulting list is filtered to include\nonly items whose name attribute matches using re.match. Items without\na name attribute are never returned if a scope is supplied and the\nchoice or re.match means that a scope without special tokens filters\nby prefix."}]}},
{"id": "tf.compat.v1.gather_nd", "type": "function", "code": "tf.compat.v1.gather_nd(params,indices,name=None,batch_dims=0)", "summary": "Gather slices from params into a Tensor with shape specified by indices.", "description": "", "code-info": {"name": "tf.compat.v1.gather_nd", "parameters": [{"name": "params", "is_optional": false, "type": "tensor", "description": "A Tensor. The tensor from which to gather values."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "batch_dims", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer or a scalar 'Tensor'. The number of batch dimensions."}]}},
{"id": "tf.compat.v1.expand_dims", "type": "function", "code": "tf.compat.v1.expand_dims(input,axis=None,name=None,dim=None)", "summary": "Inserts a dimension of 1 into a tensor's shape. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.expand_dims", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "axis", "is_optional": true, "type": "float", "default_value": "None", "description": "0-D (scalar). Specifies the dimension index at which to expand the\nshape of input. Must be in the range [-rank(input) - 1, rank(input)]."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The name of the output Tensor (optional)."}, {"name": "dim", "is_optional": true, "type": "float", "default_value": "None", "description": "0-D (scalar). Equivalent to axis, to be deprecated."}]}},
{"id": "tf.compat.v1.enable_v2_tensorshape", "type": "function", "code": "tf.compat.v1.enable_v2_tensorshape()", "summary": "In TensorFlow 2.0, iterating over a TensorShape instance returns values.", "description": "", "code-info": {"name": "tf.compat.v1.enable_v2_tensorshape", "parameters": []}},
{"id": "tf.compat.v1.floor_div", "type": "function", "code": "tf.compat.v1.floor_div(x,y,name=None)", "summary": "Returns x // y element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.floor_div", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.FixedLengthRecordReader", "type": "class", "code": "tf.compat.v1.FixedLengthRecordReader(record_bytes,header_bytes=None,footer_bytes=None,hop_bytes=None,name=None,encoding=None)", "summary": "A Reader that outputs fixed-length records from a file.\n\nInherits From: ReaderBase", "description": "", "code-info": {"name": "tf.compat.v1.FixedLengthRecordReader", "parameters": [{"name": "record_bytes", "is_optional": false, "type": "others", "description": "An int."}, {"name": "header_bytes", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0."}, {"name": "footer_bytes", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0."}, {"name": "hop_bytes", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "encoding", "is_optional": true, "type": "others", "default_value": "None", "description": "The type of encoding for the file. Defaults to none."}]}},
{"id": "tf.compat.v1.executing_eagerly", "type": "function", "code": "tf.compat.v1.executing_eagerly()", "summary": "Checks whether the current thread has eager execution enabled.", "description": "", "code-info": {"name": "tf.compat.v1.executing_eagerly", "parameters": []}},
{"id": "tf.compat.v1.extract_image_patches", "type": "function", "code": "tf.compat.v1.extract_image_patches(images,ksizes=None,strides=None,rates=None,padding=None,name=None,sizes=None)", "summary": "Extract patches from images and put them in the \"depth\" output dimension.", "description": "", "code-info": {"name": "tf.compat.v1.extract_image_patches", "parameters": [{"name": "images", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, int64, bfloat16, uint16, half, uint32, uint64.\n4-D Tensor with shape [batch, in_rows, in_cols, depth]."}, {"name": "ksizes", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of ints that has length &gt;= 4.\nThe size of the sliding window for each dimension of images."}, {"name": "strides", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of ints that has length &gt;= 4.\nHow far the centers of two consecutive patches are in\nthe images. Must be: [1, stride_rows, stride_cols, 1]."}, {"name": "rates", "is_optional": true, "type": "others", "default_value": "None", "description": "A list of ints that has length &gt;= 4.\nMust be: [1, rate_rows, rate_cols, 1]. This is the\ninput stride, specifying how far two consecutive patch samples are in the\ninput. Equivalent to extracting patches with\npatch_sizes_eff = patch_sizes + (patch_sizes - 1) * (rates - 1), followed by\nsubsampling them spatially by a factor of rates. This is equivalent to\nrate in dilated (a.k.a. Atrous) convolutions."}, {"name": "padding", "is_optional": true, "type": "string", "default_value": "None", "description": "A string from: \"SAME\", \"VALID\".\nThe type of padding algorithm to use."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "sizes", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.fixed_size_partitioner", "type": "function", "code": "tf.compat.v1.fixed_size_partitioner(num_shards,axis=0)", "summary": "Partitioner to specify a fixed number of shards along given axis.", "description": "", "code-info": {"name": "tf.compat.v1.fixed_size_partitioner", "parameters": [{"name": "num_shards", "is_optional": false, "type": "others", "description": "int, number of shards to partition variable."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "int, axis to partition on."}]}},
{"id": "tf.compat.v1.enable_resource_variables", "type": "function", "code": "tf.compat.v1.enable_resource_variables()", "summary": "Creates resource variables by default.", "description": "", "code-info": {"name": "tf.compat.v1.enable_resource_variables", "parameters": []}},
{"id": "tf.compat.v1.disable_tensor_equality", "type": "function", "code": "tf.compat.v1.disable_tensor_equality()", "summary": "Compare Tensors by their id and be hashable.", "description": "", "code-info": {"name": "tf.compat.v1.disable_tensor_equality", "parameters": []}},
{"id": "tf.compat.v1.enable_eager_execution", "type": "function", "code": "tf.compat.v1.enable_eager_execution(config=None,device_policy=None,execution_mode=None)", "summary": "Enables eager execution for the lifetime of this program.", "description": "", "code-info": {"name": "tf.compat.v1.enable_eager_execution", "parameters": [{"name": "config", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) A tf.compat.v1.ConfigProto to use to configure the\nenvironment in which operations are executed. Note that\ntf.compat.v1.ConfigProto is also used to configure graph execution (via\ntf.compat.v1.Session) and many options within tf.compat.v1.ConfigProto\nare not implemented (or are irrelevant) when eager execution is enabled."}, {"name": "device_policy", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Policy controlling how operations requiring\ninputs on a specific device (e.g., a GPU 0) handle inputs on a different\ndevice  (e.g. GPU 1 or CPU). When set to None, an appropriate value will\nbe picked automatically. The value picked may change between TensorFlow\nreleases.\nValid values:\n\ntf.contrib.eager.DEVICE_PLACEMENT_EXPLICIT: raises an error if the\nplacement is not correct.\ntf.contrib.eager.DEVICE_PLACEMENT_WARN: copies the tensors which are not\non the right device but logs a warning.\ntf.contrib.eager.DEVICE_PLACEMENT_SILENT: silently copies the tensors.\nNote that this may hide performance problems as there is no notification\nprovided when operations are blocked on the tensor being copied between\ndevices.\ntf.contrib.eager.DEVICE_PLACEMENT_SILENT_FOR_INT32: silently copies\nint32 tensors, raising errors on the other ones.\n"}, {"name": "execution_mode", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) Policy controlling how operations dispatched are\nactually executed. When set to None, an appropriate value will be picked\nautomatically. The value picked may change between TensorFlow releases.\nValid values:"}]}},
{"id": "tf.compat.v1.disable_v2_behavior", "type": "function", "code": "tf.compat.v1.disable_v2_behavior()", "summary": "Disables TensorFlow 2.x behaviors.", "description": "", "code-info": {"name": "tf.compat.v1.disable_v2_behavior", "parameters": []}},
{"id": "tf.compat.v1.enable_v2_behavior", "type": "function", "code": "tf.compat.v1.enable_v2_behavior()", "summary": "Enables TensorFlow 2.x behaviors.", "description": "", "code-info": {"name": "tf.compat.v1.enable_v2_behavior", "parameters": []}},
{"id": "tf.compat.v1.disable_v2_tensorshape", "type": "function", "code": "tf.compat.v1.disable_v2_tensorshape()", "summary": "Disables the V2 TensorShape behavior and reverts to V1 behavior.", "description": "", "code-info": {"name": "tf.compat.v1.disable_v2_tensorshape", "parameters": []}},
{"id": "tf.compat.v1.enable_control_flow_v2", "type": "function", "code": "tf.compat.v1.enable_control_flow_v2()", "summary": "Use control flow v2.", "description": "", "code-info": {"name": "tf.compat.v1.enable_control_flow_v2", "parameters": []}},
{"id": "tf.compat.v1.enable_tensor_equality", "type": "function", "code": "tf.compat.v1.enable_tensor_equality()", "summary": "Compare Tensors with element-wise comparison and thus be unhashable.", "description": "", "code-info": {"name": "tf.compat.v1.enable_tensor_equality", "parameters": []}},
{"id": "tf.compat.v1.device", "type": "function", "code": "tf.compat.v1.device(device_name_or_function)", "summary": "Wrapper for Graph.device() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.device", "parameters": [{"name": "device_name_or_function", "is_optional": false, "type": "string", "description": "The device name or function to use in the context."}]}},
{"id": "tf.compat.v1.disable_resource_variables", "type": "function", "code": "tf.compat.v1.disable_resource_variables()", "summary": "Opts out of resource variables. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.disable_resource_variables", "parameters": []}},
{"id": "tf.compat.v1.disable_eager_execution", "type": "function", "code": "tf.compat.v1.disable_eager_execution()", "summary": "Disables eager execution.", "description": "", "code-info": {"name": "tf.compat.v1.disable_eager_execution", "parameters": []}},
{"id": "tf.compat.v1.disable_control_flow_v2", "type": "function", "code": "tf.compat.v1.disable_control_flow_v2()", "summary": "Opts out of control flow v2.", "description": "", "code-info": {"name": "tf.compat.v1.disable_control_flow_v2", "parameters": []}},
{"id": "tf.compat.v1.Dimension", "type": "class", "code": "tf.compat.v1.Dimension(value)", "summary": "Represents the value of one dimension in a TensorShape.", "description": "", "code-info": {"name": "tf.compat.v1.Dimension", "parameters": [{"name": "value", "is_optional": false, "type": "others", "description": "  The value of this dimension, or None if it is unknown."}]}},
{"id": "tf.compat.v1.DeviceSpec", "type": "class", "code": "tf.compat.v1.DeviceSpec(job=None,replica=None,task=None,device_type=None,device_index=None)", "summary": "Represents a (possibly partial) specification for a TensorFlow device.\n\nInherits From: DeviceSpec", "description": "", "code-info": {"name": "tf.compat.v1.DeviceSpec", "parameters": [{"name": "job", "is_optional": true, "type": "string", "default_value": "None", "description": "string.  Optional job name."}, {"name": "replica", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional replica index."}, {"name": "task", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional task index."}, {"name": "device_type", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device type string (e.g. \"CPU\" or \"GPU\")"}, {"name": "device_index", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional device index.  If left\nunspecified, device represents 'any' device_index."}]}},
{"id": "tf.compat.v1.decode_csv", "type": "function", "code": "tf.compat.v1.decode_csv(records,record_defaults,field_delim=',',use_quote_delim=True,name=None,na_value='',select_cols=None)", "summary": "Convert CSV records to tensors. Each column maps to one tensor.", "description": "", "code-info": {"name": "tf.compat.v1.decode_csv", "parameters": [{"name": "records", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nEach string is a record/row in the csv and all records should have\nthe same format."}, {"name": "record_defaults", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with specific types.\nAcceptable types are float32, float64, int32, int64, string.\nOne tensor per column of the input record, with either a\nscalar default value for that column or an empty vector if the column is\nrequired."}, {"name": "field_delim", "is_optional": true, "type": "string", "default_value": "'", "description": ""}, {"name": "'", "is_optional": false, "type": "others", "description": ""}, {"name": "use_quote_delim", "is_optional": true, "type": "bool", "default_value": "True", "description": "An optional bool. Defaults to True.\nIf false, treats double quotation marks as regular\ncharacters inside of the string fields (ignoring RFC 4180, Section 2,\nBullet 5)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "na_value", "is_optional": true, "type": "string", "default_value": "''", "description": "Additional string to recognize as NA/NaN."}, {"name": "select_cols", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional sorted list of column indices to select. If specified,\nonly this subset of columns will be parsed and returned."}]}},
{"id": "tf.compat.v1.create_partitioned_variables", "type": "function", "code": "tf.compat.v1.create_partitioned_variables(shape,slicing,initializer,dtype=tf.dtypes.float32,trainable=True,collections=None,name=None,reuse=None)", "summary": "Create a list of partitioned variables according to the given slicing. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.create_partitioned_variables", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "List of integers.  The shape of the full variable."}, {"name": "slicing", "is_optional": false, "type": "int", "description": "List of integers.  How to partition the variable.\nMust be of the same length as shape.  Each value\nindicate how many slices to create in the corresponding\ndimension.  Presently only one of the values can be more than 1;\nthat is, the variable can only be sliced along one dimension.\n\nFor convenience, The requested number of partitions does not have to\ndivide the corresponding dimension evenly.  If it does not, the\nshapes of the partitions are incremented by 1 starting from partition\n0 until all slack is absorbed.  The adjustment rules may change in the\nfuture, but as you can save/restore these variables with different\nslicing specifications this should not be a problem."}, {"name": "initializer", "is_optional": false, "type": "tensor", "description": "A Tensor of shape shape or a variable initializer\nfunction.  If a function, it will be called once for each slice,\npassing the shape and data type of the slice as parameters.  The\nfunction must return a tensor with the same shape as the slice."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Type of the variables. Ignored if initializer is a Tensor."}, {"name": "trainable", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True also add all the variables to the graph collection\nGraphKeys.TRAINABLE_VARIABLES."}, {"name": "collections", "is_optional": true, "type": "others", "default_value": "None", "description": "List of graph collections keys to add the variables to.\nDefaults to [GraphKeys.GLOBAL_VARIABLES]."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the full variable.  Defaults to\n\"PartitionedVariable\" and gets uniquified automatically."}, {"name": "reuse", "is_optional": true, "type": "bool", "default_value": "None", "description": "Boolean or None; if True and name is set, it would reuse\npreviously created variables. if False it will create new variables.\nif None, it would inherit the parent scope reuse."}]}},
{"id": "tf.compat.v1.count_up_to", "type": "function", "code": "tf.compat.v1.count_up_to(ref,limit,name=None)", "summary": "Increments 'ref' until it reaches 'limit'. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.count_up_to", "parameters": [{"name": "ref", "is_optional": false, "type": "others", "description": "A Variable. Must be one of the following types: int32, int64.\nShould be from a scalar Variable node."}, {"name": "limit", "is_optional": false, "type": "others", "description": "An int.\nIf incrementing ref would bring it above limit, instead generates an\n'OutOfRange' error."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.count_nonzero", "type": "function", "code": "tf.compat.v1.count_nonzero(input_tensor=None,axis=None,keepdims=None,dtype=tf.dtypes.int64,name=None,reduction_indices=None,keep_dims=None,input=None)", "summary": "Computes number of nonzero elements across dimensions of a tensor. (deprecated arguments) (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.count_nonzero", "parameters": [{"name": "input_tensor", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The tensor to reduce. Should be of numeric type, bool, or\nstring."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If true, retains reduced dimensions with length 1."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "The output dtype; defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "reduction_indices", "is_optional": true, "type": "string", "default_value": "None", "description": "The old (deprecated) name for axis."}, {"name": "keep_dims", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated alias for keepdims."}, {"name": "input", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Overrides input_tensor. For compatibility."}]}},
{"id": "tf.compat.v1.convert_to_tensor_or_sparse_tensor", "type": "function", "code": "tf.compat.v1.convert_to_tensor_or_sparse_tensor(value,dtype=None,name=None)", "summary": "Converts value to a SparseTensor or Tensor.", "description": "", "code-info": {"name": "tf.compat.v1.convert_to_tensor_or_sparse_tensor", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A SparseTensor, SparseTensorValue, or an object whose type has a\nregistered Tensor conversion function."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional element type for the returned tensor. If missing, the type\nis inferred from the type of value."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name to use if a new Tensor is created."}]}},
{"id": "tf.compat.v1.decode_raw", "type": "function", "code": "tf.compat.v1.decode_raw(input_bytes=None,out_type=None,little_endian=True,name=None,bytes=None)", "summary": "Convert raw byte strings into tensors. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.decode_raw", "parameters": [{"name": "input_bytes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "  Each element of the input Tensor is converted to an array of bytes."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "None", "description": "  DType of the output. Acceptable types are half, float, double,\nint32, uint16, uint8, int16, int8, int64."}, {"name": "little_endian", "is_optional": true, "type": "bool", "default_value": "True", "description": "  Whether the input_bytes data is in little-endian format. Data will be\nconverted into host byte order if necessary."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}, {"name": "bytes", "is_optional": true, "type": "others", "default_value": "None", "description": "Deprecated parameter. Use input_bytes instead."}]}},
{"id": "tf.compat.v1.depth_to_space", "type": "function", "code": "tf.compat.v1.depth_to_space(input,block_size,name=None,data_format='NHWC')", "summary": "DepthToSpace for tensors of type T.", "description": "", "code-info": {"name": "tf.compat.v1.depth_to_space", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "block_size", "is_optional": false, "type": "others", "description": "An int that is &gt;= 2.\nThe size of the spatial block, same as in Space2Depth.\ndata_format: An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\"."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional).\n\n\nReturns:\n\nA Tensor. Has the same type as input.\n\n          "}, {"name": "data_format", "is_optional": true, "type": "string", "default_value": "'NHWC'", "description": "An optional string from: \"NHWC\", \"NCHW\", \"NCHW_VECT_C\". Defaults to \"NHWC\".\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.delete_session_tensor", "type": "function", "code": "tf.compat.v1.delete_session_tensor(handle,name=None)", "summary": "Delete the tensor for the given tensor handle.", "description": "", "code-info": {"name": "tf.compat.v1.delete_session_tensor", "parameters": [{"name": "handle", "is_optional": false, "type": "tensor", "description": "The string representation of a persistent tensor handle."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the return tensor."}]}},
{"id": "tf.compat.v1.convert_to_tensor", "type": "function", "code": "tf.compat.v1.convert_to_tensor(value,dtype=None,name=None,preferred_dtype=None,dtype_hint=None)", "summary": "Converts the given value to a Tensor.", "description": "", "code-info": {"name": "tf.compat.v1.convert_to_tensor", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "An object whose type has a registered Tensor conversion function."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional element type for the returned tensor. If missing, the type\nis inferred from the type of value."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name to use if a new Tensor is created."}, {"name": "preferred_dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional element type for the returned tensor, used when\ndtype is None. In some cases, a caller may not have a dtype in mind when\nconverting to a tensor, so preferred_dtype can be used as a soft\npreference.  If the conversion to preferred_dtype is not possible, this\nargument has no effect."}, {"name": "dtype_hint", "is_optional": true, "type": "others", "default_value": "None", "description": "same meaning as preferred_dtype, and overrides it."}]}},
{"id": "tf.compat.v1.control_flow_v2_enabled", "type": "function", "code": "tf.compat.v1.control_flow_v2_enabled()", "summary": "Returns True if v2 control flow is enabled.", "description": "", "code-info": {"name": "tf.compat.v1.control_flow_v2_enabled", "parameters": []}},
{"id": "tf.compat.v1.confusion_matrix", "type": "function", "code": "tf.compat.v1.confusion_matrix(labels,predictions,num_classes=None,dtype=tf.dtypes.int32,name=None,weights=None)", "summary": "Computes the confusion matrix from predictions and labels.", "description": "", "code-info": {"name": "tf.compat.v1.confusion_matrix", "parameters": [{"name": "labels", "is_optional": false, "type": "tensor", "description": "1-D Tensor of real labels for the classification task."}, {"name": "predictions", "is_optional": false, "type": "tensor", "description": "1-D Tensor of predictions for a given classification."}, {"name": "num_classes", "is_optional": true, "type": "others", "default_value": "None", "description": "The possible number of labels the classification task can have.\nIf this value is not provided, it will be calculated using both\npredictions and labels array."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "Data type of the confusion matrix."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Scope name."}, {"name": "weights", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An optional Tensor whose shape matches predictions."}]}},
{"id": "tf.compat.v1.convert_to_tensor_or_indexed_slices", "type": "function", "code": "tf.compat.v1.convert_to_tensor_or_indexed_slices(value,dtype=None,name=None)", "summary": "Converts the given object to a Tensor or an IndexedSlices.", "description": "", "code-info": {"name": "tf.compat.v1.convert_to_tensor_or_indexed_slices", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "An IndexedSlices, SparseTensor, or an object that can be consumed\nby convert_to_tensor()."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(Optional.) The required DType of the returned Tensor or\nIndexedSlices."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(Optional.) A name to use if a new Tensor is created."}]}},
{"id": "tf.compat.v1.container", "type": "function", "code": "tf.compat.v1.container(container_name)", "summary": "Wrapper for Graph.container() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.container", "parameters": [{"name": "container_name", "is_optional": false, "type": "string", "description": "The container string to use in the context."}]}},
{"id": "tf.compat.v1.constant", "type": "function", "code": "tf.compat.v1.constant(value,dtype=None,shape=None,name='Const',verify_shape=False)", "summary": "Creates a constant tensor.", "description": "", "code-info": {"name": "tf.compat.v1.constant", "parameters": [{"name": "value", "is_optional": false, "type": "others", "description": "         A constant value (or list) of output type dtype."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "         The type of the elements of the resulting tensor."}, {"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "         Optional dimensions of resulting tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Const'", "description": "          Optional name for the tensor."}, {"name": "verify_shape", "is_optional": true, "type": "bool", "default_value": "False", "description": "  Boolean that enables verification of a shape of values."}]}},
{"id": "tf.compat.v1.clip_by_average_norm", "type": "function", "code": "tf.compat.v1.clip_by_average_norm(t,clip_norm,name=None)", "summary": "Clips tensor values to a maximum average L2-norm. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.clip_by_average_norm", "parameters": [{"name": "t", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "clip_norm", "is_optional": false, "type": "tensor", "description": "A 0-D (scalar) Tensor &gt; 0. A maximum clipping value."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.ConditionalAccumulatorBase", "type": "class", "code": "tf.compat.v1.ConditionalAccumulatorBase(dtype,shape,accumulator_ref)", "summary": "A conditional accumulator for aggregating gradients.", "description": "", "code-info": {"name": "tf.compat.v1.ConditionalAccumulatorBase", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": "Datatype of the accumulated gradients."}, {"name": "shape", "is_optional": false, "type": "others", "description": "Shape of the accumulated gradients."}, {"name": "accumulator_ref", "is_optional": false, "type": "others", "description": "A handle to the conditional accumulator, created by sub-\nclasses"}]}},
{"id": "tf.compat.v1.boolean_mask", "type": "function", "code": "tf.compat.v1.boolean_mask(tensor,mask,name='boolean_mask',axis=None)", "summary": "Apply boolean mask to tensor.", "description": "", "code-info": {"name": "tf.compat.v1.boolean_mask", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": " N-D tensor."}, {"name": "mask", "is_optional": false, "type": "tensor", "description": " K-D boolean tensor, K &lt;= N and K must be known statically."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'boolean_mask'", "description": " A name for this operation (optional)."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": " A 0-D int Tensor representing the axis in tensor to mask from. By\ndefault, axis is 0 which will mask from the first dimension. Otherwise K +\naxis &lt;= N."}]}},
{"id": "tf.compat.v1.ConditionalAccumulator", "type": "class", "code": "tf.compat.v1.ConditionalAccumulator(dtype,shape=None,shared_name=None,name='conditional_accumulator',reduction_type='MEAN')", "summary": "A conditional accumulator for aggregating gradients.\n\nInherits From: ConditionalAccumulatorBase", "description": "", "code-info": {"name": "tf.compat.v1.ConditionalAccumulator", "parameters": [{"name": "dtype", "is_optional": false, "type": "others", "description": "Datatype of the accumulated gradients."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of the accumulated gradients."}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. If non-empty, this accumulator will be shared under\nthe given name across multiple sessions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'conditional_accumulator'", "description": "Optional name for the accumulator."}, {"name": "reduction_type", "is_optional": true, "type": "string", "default_value": "'MEAN'", "description": "Reduction type to use when taking the gradient."}]}},
{"id": "tf.compat.v1.cond", "type": "function", "code": "tf.compat.v1.cond(pred,true_fn=None,false_fn=None,strict=False,name=None,fn1=None,fn2=None)", "summary": "Return true_fn() if the predicate pred is true else false_fn(). (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.cond", "parameters": [{"name": "pred", "is_optional": false, "type": "float", "description": "A scalar determining whether to return the result of true_fn or\nfalse_fn."}, {"name": "true_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "The callable to be performed if pred is true."}, {"name": "false_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "The callable to be performed if pred is false."}, {"name": "strict", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean that enables/disables 'strict' mode; see above."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "fn1", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "fn2", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.bincount", "type": "function", "code": "tf.compat.v1.bincount(arr,weights=None,minlength=None,maxlength=None,dtype=tf.dtypes.int32)", "summary": "Counts the number of occurrences of each value in an integer array.", "description": "", "code-info": {"name": "tf.compat.v1.bincount", "parameters": [{"name": "arr", "is_optional": false, "type": "tensor", "description": "An int32 tensor of non-negative values."}, {"name": "weights", "is_optional": true, "type": "others", "default_value": "None", "description": "If non-None, must be the same shape as arr. For each value in\narr, the bin will be incremented by the corresponding weight instead of\n1."}, {"name": "minlength", "is_optional": true, "type": "others", "default_value": "None", "description": "If given, ensures the output has length at least minlength,\npadding with zeros at the end if necessary."}, {"name": "maxlength", "is_optional": true, "type": "others", "default_value": "None", "description": "If given, skips values in arr that are equal or greater than\nmaxlength, ensuring that the output has length at most maxlength."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "If weights is None, determines the type of the output bins."}]}},
{"id": "tf.compat.v1.case", "type": "function", "code": "tf.compat.v1.case(pred_fn_pairs,default=None,exclusive=False,strict=False,name='case')", "summary": "Create a case operation.", "description": "", "code-info": {"name": "tf.compat.v1.case", "parameters": [{"name": "pred_fn_pairs", "is_optional": false, "type": "tensor", "description": "Dict or list of pairs of a boolean scalar tensor and a\ncallable which returns a list of tensors."}, {"name": "default", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional callable that returns a list of tensors."}, {"name": "exclusive", "is_optional": true, "type": "bool", "default_value": "False", "description": "True iff at most one predicate is allowed to evaluate to True."}, {"name": "strict", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean that enables/disables 'strict' mode; see above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'case'", "description": "A name for this operation (optional)."}]}},
{"id": "tf.compat.v1.colocate_with", "type": "function", "code": "tf.compat.v1.colocate_with(op,ignore_existing=False)", "summary": "DEPRECATED FUNCTION", "description": "", "code-info": {"name": "tf.compat.v1.colocate_with", "parameters": [{"name": "op", "is_optional": false, "type": "others", "description": ""}, {"name": "ignore_existing", "is_optional": true, "type": "bool", "default_value": "False", "description": ""}]}},
{"id": "tf.compat.v1.batch_to_space_nd", "type": "function", "code": "tf.compat.v1.batch_to_space_nd(input,block_shape,crops,name=None)", "summary": "BatchToSpace for N-D tensors of type T.", "description": "", "code-info": {"name": "tf.compat.v1.batch_to_space_nd", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor.\nN-D with shape input_shape = [batch] + spatial_shape + remaining_shape,\nwhere spatial_shape has M dimensions."}, {"name": "block_shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n1-D with shape [M], all values must be &gt;= 1."}, {"name": "crops", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n2-D with shape [M, 2], all values must be &gt;= 0.\ncrops[i] = [crop_start, crop_end] specifies the amount to crop from input\ndimension i + 1, which corresponds to spatial dimension i.  It is\nrequired that\ncrop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1].\n\nThis operation is equivalent to the following steps:\n\n\nReshape input to reshaped of shape:\n[block_shape[0], ..., block_shape[M-1],\nbatch / prod(block_shape),\ninput_shape[1], ..., input_shape[N-1]]\nPermute dimensions of reshaped to produce permuted of shape\n[batch / prod(block_shape),\n\ninput_shape[1], block_shape[0],\n...,\ninput_shape[M], block_shape[M-1],\n\ninput_shape[M+1], ..., input_shape[N-1]]\nReshape permuted to produce reshaped_permuted of shape\n[batch / prod(block_shape),\n\ninput_shape[1] * block_shape[0],\n...,\ninput_shape[M] * block_shape[M-1],\n\ninput_shape[M+1],\n...,\ninput_shape[N-1]]\nCrop the start and end of dimensions [1, ..., M] of\nreshaped_permuted according to crops to produce the output of shape:\n[batch / prod(block_shape),\n\ninput_shape[1] * block_shape[0] - crops[0,0] - crops[0,1],\n...,\ninput_shape[M] * block_shape[M-1] - crops[M-1,0] - crops[M-1,1],\n\ninput_shape[M+1], ..., input_shape[N-1]]\n\n\nSome examples:\n\n(1) For the following input of shape [4, 1, 1, 1], block_shape = [2, 2], and\n  crops = [[0, 0], [0, 0]]:\n\n\n\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n\n\nThe output tensor has shape [1, 2, 2, 1] and value:\n\n\nx = [[[[1], [2]], [[3], [4]]]]\n\n\n(2) For the following input of shape [4, 1, 1, 3], block_shape = [2, 2], and\n      crops = [[0, 0], [0, 0]]:\n\n\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n\n\nThe output tensor has shape [1, 2, 2, 3] and value:\n\n\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n\n\n(3) For the following input of shape [4, 2, 2, 1], block_shape = [2, 2], and\n      crops = [[0, 0], [0, 0]]:\n\n\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n\n\nThe output tensor has shape [1, 4, 4, 1] and value:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n     [[5],   [6],  [7],  [8]],\n     [[9],  [10], [11],  [12]],\n     [[13], [14], [15],  [16]]]]\n\n\n(4) For the following input of shape [8, 1, 3, 1], block_shape = [2, 2], and\n      crops = [[0, 0], [2, 0]]:\n\n\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n\n\nThe output tensor has shape [2, 2, 4, 1] and value:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\n"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.batch_to_space", "type": "function", "code": "tf.compat.v1.batch_to_space(input,crops,block_size,name=None,block_shape=None)", "summary": "BatchToSpace for 4-D tensors of type T.", "description": "", "code-info": {"name": "tf.compat.v1.batch_to_space", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. 4-D tensor with shape\n[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,\ndepth]. Note that the batch size of the input tensor must be divisible by\nblock_size * block_size."}, {"name": "crops", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n2-D tensor of non-negative integers with shape [2, 2]. It specifies\nhow many elements to crop from the intermediate result across the spatial\ndimensions as follows:\n\ncrops = [[crop_top, crop_bottom], [crop_left, crop_right]]"}, {"name": "block_size", "is_optional": false, "type": "others", "description": "An int that is &gt;= 2."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "block_shape", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.batch_scatter_update", "type": "function", "code": "tf.compat.v1.batch_scatter_update(ref,indices,updates,use_locking=True,name=None)", "summary": "Generalization of tf.compat.v1.scatter_update to axis different than 0. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.batch_scatter_update", "parameters": [{"name": "ref", "is_optional": false, "type": "others", "description": "Variable to scatter onto."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "Tensor containing indices as described above."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "Tensor of updates to apply to ref."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean indicating whether to lock the writing operation."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional scope name string."}]}},
{"id": "tf.compat.v1.batch_gather", "type": "function", "code": "tf.compat.v1.batch_gather(params,indices,name=None)", "summary": "Gather slices from params according to indices with leading batch dims. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.batch_gather", "parameters": [{"name": "params", "is_optional": false, "type": "others", "description": ""}, {"name": "indices", "is_optional": false, "type": "others", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.compat.v1.assign_add", "type": "function", "code": "tf.compat.v1.assign_add(ref,value,use_locking=None,name=None)", "summary": "Update ref by adding value to it.", "description": "", "code-info": {"name": "tf.compat.v1.assign_add", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int64, int32, uint8, uint16, int16, int8,\ncomplex64, complex128, qint8, quint8, qint32, half. Should be\nfrom a Variable node."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same shape and dtype as ref. The value to\nbe added to the variable."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to False. If True, the addition\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.assign_sub", "type": "function", "code": "tf.compat.v1.assign_sub(ref,value,use_locking=None,name=None)", "summary": "Update ref by subtracting value from it.", "description": "", "code-info": {"name": "tf.compat.v1.assign_sub", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Must be one of the following types: float32,\nfloat64, int64, int32, uint8, uint16, int16, int8,\ncomplex64, complex128, qint8, quint8, qint32, half. Should be\nfrom a Variable node."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same shape and dtype as ref. The value to\nbe subtracted to the variable."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to False. If True, the\nsubtraction will be protected by a lock; otherwise the behavior is\nundefined, but may exhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.assign", "type": "function", "code": "tf.compat.v1.assign(ref,value,validate_shape=None,use_locking=None,name=None)", "summary": "Update ref by assigning value to it.", "description": "", "code-info": {"name": "tf.compat.v1.assign", "parameters": [{"name": "ref", "is_optional": false, "type": "tensor", "description": "A mutable Tensor. Should be from a Variable node. May be\nuninitialized."}, {"name": "value", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same shape and dtype as ref. The value to\nbe assigned to the variable."}, {"name": "validate_shape", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to True. If true, the\noperation will validate that the shape of 'value' matches the shape of the\nTensor being assigned to.  If false, 'ref' will take on the shape of\n'value'."}, {"name": "use_locking", "is_optional": true, "type": "bool", "default_value": "None", "description": "An optional bool. Defaults to True. If True, the assignment\nwill be protected by a lock; otherwise the behavior is undefined, but may\nexhibit less contention."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.assert_variables_initialized", "type": "function", "code": "tf.compat.v1.assert_variables_initialized(var_list=None)", "summary": "Returns an Op to check if variables are initialized.", "description": "", "code-info": {"name": "tf.compat.v1.assert_variables_initialized", "parameters": [{"name": "var_list", "is_optional": true, "type": "others", "default_value": "None", "description": "List of Variable objects to check. Defaults to the value of\nglobal_variables()."}]}},
{"id": "tf.compat.v1.assert_type", "type": "function", "code": "tf.compat.v1.assert_type(tensor,tf_type,message=None,name=None)", "summary": "Statically asserts that the given Tensor is of the specified type.", "description": "", "code-info": {"name": "tf.compat.v1.assert_type", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "tf_type", "is_optional": false, "type": "tensor", "description": "A tensorflow type (dtypes.float32, tf.int64, dtypes.bool,\netc)."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name to give this Op.  Defaults to \"assert_type\""}]}},
{"id": "tf.compat.v1.assert_scalar", "type": "function", "code": "tf.compat.v1.assert_scalar(tensor,name=None,message=None)", "summary": "Asserts that the given tensor is a scalar (i.e. zero-dimensional).", "description": "", "code-info": {"name": "tf.compat.v1.assert_scalar", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this operation. Defaults to \"assert_scalar\""}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}]}},
{"id": "tf.compat.v1.assert_rank_in", "type": "function", "code": "tf.compat.v1.assert_rank_in(x,ranks,data=None,summarize=None,message=None,name=None)", "summary": "Assert x has rank in ranks.", "description": "", "code-info": {"name": "tf.compat.v1.assert_rank_in", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "ranks", "is_optional": false, "type": "tensor", "description": " Iterable of scalar Tensor objects."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).\nDefaults to \"assert_rank_in\"."}]}},
{"id": "tf.compat.v1.assert_rank_at_least", "type": "function", "code": "tf.compat.v1.assert_rank_at_least(x,rank,data=None,summarize=None,message=None,name=None)", "summary": "Assert x has rank equal to rank or higher.", "description": "", "code-info": {"name": "tf.compat.v1.assert_rank_at_least", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "rank", "is_optional": false, "type": "tensor", "description": " Scalar Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).\nDefaults to \"assert_rank_at_least\"."}]}},
{"id": "tf.compat.v1.assert_none_equal", "type": "function", "code": "tf.compat.v1.assert_none_equal(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x != y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_none_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_none_equal\"."}]}},
{"id": "tf.compat.v1.assert_negative", "type": "function", "code": "tf.compat.v1.assert_negative(x,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &lt; 0 holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_negative", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_negative\"."}]}},
{"id": "tf.compat.v1.assert_rank", "type": "function", "code": "tf.compat.v1.assert_rank(x,rank,data=None,summarize=None,message=None,name=None)", "summary": "Assert x has rank equal to rank.", "description": "", "code-info": {"name": "tf.compat.v1.assert_rank", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "rank", "is_optional": false, "type": "tensor", "description": " Scalar integer Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and the shape of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_rank\"."}]}},
{"id": "tf.compat.v1.assert_non_negative", "type": "function", "code": "tf.compat.v1.assert_non_negative(x,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &gt;= 0 holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_non_negative", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_non_negative\"."}]}},
{"id": "tf.compat.v1.assert_positive", "type": "function", "code": "tf.compat.v1.assert_positive(x,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &gt; 0 holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_positive", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_positive\"."}]}},
{"id": "tf.compat.v1.assert_non_positive", "type": "function", "code": "tf.compat.v1.assert_non_positive(x,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &lt;= 0 holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_non_positive", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_non_positive\"."}]}},
{"id": "tf.compat.v1.assert_less_equal", "type": "function", "code": "tf.compat.v1.assert_less_equal(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &lt;= y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_less_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_less_equal\"."}]}},
{"id": "tf.compat.v1.arg_min", "type": "function", "code": "tf.compat.v1.arg_min(input,dimension,output_type=tf.dtypes.int64,name=None)", "summary": "Returns the index with the smallest value across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.arg_min", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "dimension", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range [-rank(input), rank(input)).\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0."}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.assert_greater", "type": "function", "code": "tf.compat.v1.assert_greater(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &gt; y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_greater", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_greater\"."}]}},
{"id": "tf.compat.v1.assert_less", "type": "function", "code": "tf.compat.v1.assert_less(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &lt; y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_less", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_less\"."}]}},
{"id": "tf.compat.v1.assert_equal", "type": "function", "code": "tf.compat.v1.assert_equal(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x == y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_equal\"."}]}},
{"id": "tf.compat.v1.assert_integer", "type": "function", "code": "tf.compat.v1.assert_integer(x,message=None,name=None)", "summary": "Assert that x is of integer dtype.", "description": "", "code-info": {"name": "tf.compat.v1.assert_integer", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "Tensor whose basetype is integer and is not quantized."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_integer\"."}]}},
{"id": "tf.compat.v1.assert_near", "type": "function", "code": "tf.compat.v1.assert_near(x,y,rtol=None,atol=None,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x and y are close element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_near", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Float or complex Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Float or complex Tensor, same dtype as, and broadcastable to, x."}, {"name": "rtol", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Tensor.  Same dtype as, and broadcastable to, x.\nThe relative tolerance.  Default is 10 * eps."}, {"name": "atol", "is_optional": true, "type": "tensor", "default_value": "None", "description": " Tensor.  Same dtype as, and broadcastable to, x.\nThe absolute tolerance.  Default is 10 * eps."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_near\"."}]}},
{"id": "tf.compat.v1.arg_max", "type": "function", "code": "tf.compat.v1.arg_max(input,dimension,output_type=tf.dtypes.int64,name=None)", "summary": "Returns the index with the largest value across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.compat.v1.arg_max", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "dimension", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range [-rank(input), rank(input)).\nDescribes which dimension of the input Tensor to reduce across. For vectors,\nuse dimension = 0."}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.assert_greater_equal", "type": "function", "code": "tf.compat.v1.assert_greater_equal(x,y,data=None,summarize=None,message=None,name=None)", "summary": "Assert the condition x &gt;= y holds element-wise.", "description": "", "code-info": {"name": "tf.compat.v1.assert_greater_equal", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "y", "is_optional": false, "type": "tensor", "description": " Numeric Tensor, same dtype as and broadcastable to x."}, {"name": "data", "is_optional": true, "type": "tensor", "default_value": "None", "description": " The tensors to print out if the condition is False.  Defaults to\nerror message and first few entries of x, y."}, {"name": "summarize", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Print this many entries of each tensor."}, {"name": "message", "is_optional": true, "type": "string", "default_value": "None", "description": "A string to prefix to the default message."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for this operation (optional).  Defaults to \"assert_greater_equal\"."}]}},
{"id": "tf.compat.v1.argmin", "type": "function", "code": "tf.compat.v1.argmin(input,axis=None,name=None,dimension=None,output_type=tf.dtypes.int64)", "summary": "Returns the index with the smallest value across axes of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.argmin", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range [-rank(input), rank(input)).\nDescribes which axis of the input Tensor to reduce across. For vectors,\nuse axis = 0.\noutput_type: An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dimension", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.argmax", "type": "function", "code": "tf.compat.v1.argmax(input,axis=None,name=None,dimension=None,output_type=tf.dtypes.int64)", "summary": "Returns the index with the largest value across axes of a tensor. (deprecated arguments)", "description": "", "code-info": {"name": "tf.compat.v1.argmax", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: float32, float64, int32, uint8, int16, int8, complex64, int64, qint8, quint8, qint32, bfloat16, uint16, complex128, half, uint32, uint64."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor. Must be one of the following types: int32, int64.\nint32 or int64, must be in the range [-rank(input), rank(input)).\nDescribes which axis of the input Tensor to reduce across. For vectors,\nuse axis = 0.\noutput_type: An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64."}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "dimension", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "output_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int64.\nname: A name for the operation (optional)."}]}},
{"id": "tf.compat.v1.all_variables", "type": "function", "code": "tf.compat.v1.all_variables()", "summary": "Use tf.compat.v1.global_variables instead. (deprecated)", "description": "", "code-info": {"name": "tf.compat.v1.all_variables", "parameters": []}},
{"id": "tf.compat.v1.add_to_collections", "type": "function", "code": "tf.compat.v1.add_to_collections(names,value)", "summary": "Wrapper for Graph.add_to_collections() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.add_to_collections", "parameters": [{"name": "names", "is_optional": false, "type": "others", "description": "The key for the collections. The GraphKeys class contains many\nstandard names for collections."}, {"name": "value", "is_optional": false, "type": "others", "description": "The value to add to the collections."}]}},
{"id": "tf.compat.v1.add_to_collection", "type": "function", "code": "tf.compat.v1.add_to_collection(name,value)", "summary": "Wrapper for Graph.add_to_collection() using the default graph.", "description": "", "code-info": {"name": "tf.compat.v1.add_to_collection", "parameters": [{"name": "name", "is_optional": false, "type": "others", "description": "The key for the collection. For example, the GraphKeys class\ncontains many standard names for collections."}, {"name": "value", "is_optional": false, "type": "others", "description": "The value to add to the collection."}]}},
{"id": "tf.compat.v1.add_check_numerics_ops", "type": "function", "code": "tf.compat.v1.add_check_numerics_ops()", "summary": "Connect a tf.debugging.check_numerics to every floating point tensor.", "description": "", "code-info": {"name": "tf.compat.v1.add_check_numerics_ops", "parameters": []}},
{"id": "tf.compat.path_to_str", "type": "function", "code": "tf.compat.path_to_str(path)", "summary": "Converts input which is a PathLike object to str type.", "description": "", "code-info": {"name": "tf.compat.path_to_str", "parameters": [{"name": "path", "is_optional": false, "type": "others", "description": "An object that can be converted to path representation."}]}},
{"id": "tf.compat.dimension_value", "type": "function", "code": "tf.compat.dimension_value(dimension)", "summary": "Compatibility utility required to allow for both V1 and V2 behavior in TF.", "description": "", "code-info": {"name": "tf.compat.dimension_value", "parameters": [{"name": "dimension", "is_optional": false, "type": "int", "description": "Either a Dimension instance, an integer, or None."}]}},
{"id": "tf.compat.as_bytes", "type": "function", "code": "tf.compat.as_bytes(bytes_or_text,encoding='utf-8')", "summary": "Converts bytearray, bytes, or unicode python input types to bytes.", "description": "", "code-info": {"name": "tf.compat.as_bytes", "parameters": [{"name": "bytes_or_text", "is_optional": false, "type": "string", "description": "A bytearray, bytes, str, or unicode object."}, {"name": "encoding", "is_optional": true, "type": "string", "default_value": "'utf-8'", "description": "A string indicating the charset for encoding unicode."}]}},
{"id": "tf.compat.forward_compatible", "type": "function", "code": "tf.compat.forward_compatible(year,month,day)", "summary": "Return true if the forward compatibility window has expired.", "description": "", "code-info": {"name": "tf.compat.forward_compatible", "parameters": [{"name": "year", "is_optional": false, "type": "others", "description": " A year (e.g., 2018). Must be an int."}, {"name": "month", "is_optional": false, "type": "others", "description": "A month (1 &lt;= month &lt;= 12) in year. Must be an int."}, {"name": "day", "is_optional": false, "type": "others", "description": "  A day (1 &lt;= day &lt;= 31, or 30, or 29, or 28) in month. Must be an\nint."}]}},
{"id": "tf.compat.as_str_any", "type": "function", "code": "tf.compat.as_str_any(value)", "summary": "Converts input to str type.", "description": "", "code-info": {"name": "tf.compat.as_str_any", "parameters": [{"name": "value", "is_optional": false, "type": "string", "description": "A object that can be converted to str."}]}},
{"id": "tf.compat.dimension_at_index", "type": "function", "code": "tf.compat.dimension_at_index(shape,index)", "summary": "Compatibility utility required to allow for both V1 and V2 behavior in TF.", "description": "", "code-info": {"name": "tf.compat.dimension_at_index", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "A TensorShape instance."}, {"name": "index", "is_optional": false, "type": "int", "description": "An integer index."}]}},
{"id": "tf.compat.as_text", "type": "function", "code": "tf.compat.as_text(bytes_or_text,encoding='utf-8')", "summary": "Converts any string-like python input types to unicode.", "description": "", "code-info": {"name": "tf.compat.as_text", "parameters": [{"name": "bytes_or_text", "is_optional": false, "type": "string", "description": "A bytes, str, or unicode object."}, {"name": "encoding", "is_optional": true, "type": "string", "default_value": "'utf-8'", "description": "A string indicating the charset for decoding unicode."}]}},
{"id": "tf.bitwise.bitwise_and", "type": "function", "code": "tf.bitwise.bitwise_and(x,y,name=None)", "summary": "Elementwise computes the bitwise AND of x and y.", "description": "", "code-info": {"name": "tf.bitwise.bitwise_and", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.bitwise.bitwise_xor", "type": "function", "code": "tf.bitwise.bitwise_xor(x,y,name=None)", "summary": "Elementwise computes the bitwise XOR of x and y.", "description": "", "code-info": {"name": "tf.bitwise.bitwise_xor", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.bitwise.invert", "type": "function", "code": "tf.bitwise.invert(x,name=None)", "summary": "Invert (flip) each bit of supported types; for example, type uint8 value 01010101 becomes 10101010.", "description": "", "code-info": {"name": "tf.bitwise.invert", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.bitwise.right_shift", "type": "function", "code": "tf.bitwise.right_shift(x,y,name=None)", "summary": "Elementwise computes the bitwise right-shift of x and y.", "description": "", "code-info": {"name": "tf.bitwise.right_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.bitwise.bitwise_or", "type": "function", "code": "tf.bitwise.bitwise_or(x,y,name=None)", "summary": "Elementwise computes the bitwise OR of x and y.", "description": "", "code-info": {"name": "tf.bitwise.bitwise_or", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.bitwise.left_shift", "type": "function", "code": "tf.bitwise.left_shift(x,y,name=None)", "summary": "Elementwise computes the bitwise left-shift of x and y.", "description": "", "code-info": {"name": "tf.bitwise.left_shift", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int8, int16, int32, int64, uint8, uint16, uint32, uint64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.autograph.trace", "type": "function", "code": "tf.autograph.trace(*args)", "summary": "Traces argument information at compilation time.", "description": "", "code-info": {"name": "tf.autograph.trace", "parameters": [{"name": "*args", "is_optional": false, "type": "others", "description": "Arguments to print to sys.stdout."}]}},
{"id": "tf.autograph.set_verbosity", "type": "function", "code": "tf.autograph.set_verbosity(level,alsologtostdout=False)", "summary": "Sets the AutoGraph verbosity level.", "description": "", "code-info": {"name": "tf.autograph.set_verbosity", "parameters": [{"name": "level", "is_optional": false, "type": "others", "description": "int, the verbosity level; larger values specify increased verbosity;\n0 means no logging. When reporting bugs, it is recommended to set this\nvalue to a larger number, like 10."}, {"name": "alsologtostdout", "is_optional": true, "type": "bool", "default_value": "False", "description": "bool, whether to also output log messages to sys.stdout."}]}},
{"id": "tf.autodiff.ForwardAccumulator", "type": "function", "code": "tf.autodiff.ForwardAccumulator(primals,tangents)", "summary": "Computes Jacobian-vector products (\"JVP\"s) using forward-mode autodiff.", "description": "", "code-info": {"name": "tf.autodiff.ForwardAccumulator", "parameters": [{"name": "primals", "is_optional": false, "type": "tensor", "description": "A tensor or nested structure of tensors to watch."}, {"name": "tangents", "is_optional": false, "type": "tensor", "description": "A tensor or nested structure of tensors, with the same nesting\nstructure as primals, with each element being a vector with the same\nsize as the corresponding primal element."}]}},
{"id": "tf.autograph.to_graph", "type": "function", "code": "tf.autograph.to_graph(entity,recursive=True,experimental_optional_features=None)", "summary": "Converts a Python entity into a TensorFlow graph.", "description": "", "code-info": {"name": "tf.autograph.to_graph", "parameters": [{"name": "entity", "is_optional": false, "type": "others", "description": "Python callable or class to convert."}, {"name": "recursive", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to recursively convert any functions that the converted\nfunction may call."}, {"name": "experimental_optional_features", "is_optional": true, "type": "others", "default_value": "None", "description": "None, a tuple of, or a single\ntf.autograph.experimental.Feature value."}]}},
{"id": "tf.autograph.to_code", "type": "function", "code": "tf.autograph.to_code(entity,recursive=True,experimental_optional_features=None)", "summary": "Returns the source code generated by AutoGraph, as a string.", "description": "", "code-info": {"name": "tf.autograph.to_code", "parameters": [{"name": "entity", "is_optional": false, "type": "others", "description": "Python callable or class to convert."}, {"name": "recursive", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to recursively convert any functions that the converted\nfunction may call."}, {"name": "experimental_optional_features", "is_optional": true, "type": "others", "default_value": "None", "description": "None, a tuple of, or a single\ntf.autograph.experimental.Feature value."}]}},
{"id": "tf.autograph.experimental.do_not_convert", "type": "function", "code": "tf.autograph.experimental.do_not_convert(func=None)", "summary": "Decorator that suppresses the conversion of a function.", "description": "", "code-info": {"name": "tf.autograph.experimental.do_not_convert", "parameters": [{"name": "func", "is_optional": true, "type": "others", "default_value": "None", "description": "function to decorate."}]}},
{"id": "tf.audio.encode_wav", "type": "function", "code": "tf.audio.encode_wav(audio,sample_rate,name=None)", "summary": "Encode audio data using the WAV file format.", "description": "", "code-info": {"name": "tf.audio.encode_wav", "parameters": [{"name": "audio", "is_optional": false, "type": "tensor", "description": "A Tensor of type float32. 2-D with shape [length, channels]."}, {"name": "sample_rate", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nScalar containing the sample frequency."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.where", "type": "function", "code": "tf.where(condition,x=None,y=None,name=None)", "summary": "Return the elements, either from x or y, depending on the condition.", "description": "", "code-info": {"name": "tf.where", "parameters": [{"name": "condition", "is_optional": false, "type": "tensor", "description": "A Tensor of type bool"}, {"name": "x", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor which is of the same type as y, and may be broadcastable with\ncondition and y."}, {"name": "y", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor which is of the same type as x, and may be broadcastable with\ncondition and x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name of the operation (optional)."}]}},
{"id": "tf.zeros_like", "type": "function", "code": "tf.zeros_like(input,dtype=None,name=None)", "summary": "Creates a tensor with all elements set to zero.", "description": "", "code-info": {"name": "tf.zeros_like", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A type for the returned Tensor. Must be float16, float32,\nfloat64, int8, uint8, int16, uint16, int32, int64,\ncomplex64, complex128, bool or string."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.zeros", "type": "function", "code": "tf.zeros(shape,dtype=tf.dtypes.float32,name=None)", "summary": "Creates a tensor with all elements set to zero.", "description": "", "code-info": {"name": "tf.zeros", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "A list of integers, a tuple of integers, or\na 1-D Tensor of type int32."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "The DType of an element in the resulting Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. A name for the operation."}]}},
{"id": "__call__", "type": "function", "code": "__call__(shape,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors initialized to 0.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "Shape of the tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "Optional dtype of the tensor. If not provided will return tensor\nof tf.float32."}]}},
{"id": "tf.vectorized_map", "type": "function", "code": "tf.vectorized_map(fn,elems)", "summary": "Parallel map on the list of tensors unpacked from elems on dimension 0.", "description": "", "code-info": {"name": "tf.vectorized_map", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "The callable to be performed. It accepts one argument, which will have\nthe same (possibly nested) structure as elems, and returns a possibly\nnested structure of Tensors and Operations, which may be different than\nthe structure of elems."}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "A tensor or (possibly nested) sequence of tensors, each of which will\nbe unpacked along their first dimension. The nested sequence of the\nresulting slices will be mapped over by fn."}]}},
{"id": "tf.while_loop", "type": "function", "code": "tf.while_loop(cond,body,loop_vars,shape_invariants=None,parallel_iterations=10,back_prop=True,swap_memory=False,maximum_iterations=None,name=None)", "summary": "Repeat body while the condition cond is true.", "description": "", "code-info": {"name": "tf.while_loop", "parameters": [{"name": "cond", "is_optional": false, "type": "others", "description": "A callable that represents the termination condition of the loop."}, {"name": "body", "is_optional": false, "type": "others", "description": "A callable that represents the loop body."}, {"name": "loop_vars", "is_optional": false, "type": "string", "description": "A (possibly nested) tuple, namedtuple or list of numpy array,\nTensor, and TensorArray objects."}, {"name": "shape_invariants", "is_optional": true, "type": "others", "default_value": "None", "description": "The shape invariants for the loop variables."}, {"name": "parallel_iterations", "is_optional": true, "type": "int", "default_value": "10", "description": "The number of iterations allowed to run in parallel. It\nmust be a positive integer."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether backprop is enabled for this while loop."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether GPU-CPU memory swap is enabled for this loop."}, {"name": "maximum_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional maximum number of iterations of the while loop\nto run.  If provided, the cond output is AND-ed with an additional\ncondition ensuring the number of iterations executed is no greater than\nmaximum_iterations."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the returned tensors."}]}},
{"id": "tf.audio.decode_wav", "type": "function", "code": "tf.audio.decode_wav(contents,desired_channels=-1,desired_samples=-1,name=None)", "summary": "Decode a 16-bit PCM WAV file to a float tensor.", "description": "", "code-info": {"name": "tf.audio.decode_wav", "parameters": [{"name": "contents", "is_optional": false, "type": "tensor", "description": "A Tensor of type string.\nThe WAV-encoded audio, usually from a file."}, {"name": "desired_channels", "is_optional": true, "type": "others", "default_value": "-1", "description": "An optional int. Defaults to -1.\nNumber of sample channels wanted."}, {"name": "desired_samples", "is_optional": true, "type": "others", "default_value": "-1", "description": "An optional int. Defaults to -1.\nLength of audio requested."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.Variable.SaveSliceInfo", "type": "class", "code": "tf.Variable.SaveSliceInfo(full_name=None,full_shape=None,var_offset=None,var_shape=None,save_slice_info_def=None,import_scope=None)", "summary": "Information on how to save this Variable as a slice.", "description": "", "code-info": {"name": "tf.Variable.SaveSliceInfo", "parameters": [{"name": "full_name", "is_optional": true, "type": "string", "default_value": "None", "description": "Name of the full variable of which this Variable is a\nslice."}, {"name": "full_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of the full variable, as a list of int."}, {"name": "var_offset", "is_optional": true, "type": "others", "default_value": "None", "description": "Offset of this Variable into the full variable, as a list\nof int."}, {"name": "var_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "Shape of this Variable, as a list of int."}, {"name": "save_slice_info_def", "is_optional": true, "type": "others", "default_value": "None", "description": "SaveSliceInfoDef protocol buffer. If not None,\nrecreates the SaveSliceInfo object its contents. save_slice_info_def\nand other arguments are mutually exclusive."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope to add. Only used when\ninitializing from protocol buffer."}]}},
{"id": "tf.Variable", "type": "class", "code": "tf.Variable(initial_value=None,trainable=None,validate_shape=True,caching_device=None,name=None,variable_def=None,dtype=None,import_scope=None,constraint=None,synchronization=tf.VariableSynchronization.AUTO,aggregation=tf.compat.v1.VariableAggregation.NONE,shape=None)", "summary": "See the variable guide.", "description": "", "code-info": {"name": "tf.Variable", "parameters": [{"name": "initial_value", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A Tensor, or Python object convertible to a Tensor,\nwhich is the initial value for the Variable. The initial value must have\na shape specified unless validate_shape is set to False. Can also be a\ncallable with no argument that returns the initial value when called. In\nthat case, dtype must be specified. (Note that initializer functions\nfrom init_ops.py must first be bound to a shape before being used here.)"}, {"name": "trainable", "is_optional": true, "type": "others", "default_value": "None", "description": "If True, GradientTapes automatically watch uses of this\nvariable. Defaults to True, unless synchronization is set to\nON_READ, in which case it defaults to False."}, {"name": "validate_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "If False, allows the variable to be initialized with a\nvalue of unknown shape. If True, the default, the shape of\ninitial_value must be known."}, {"name": "caching_device", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device string describing where the Variable\nshould be cached for reading.  Defaults to the Variable's device. If not\nNone, caches on another device.  Typical use is to cache on the device\nwhere the Ops using the Variable reside, to deduplicate copying through\nSwitch and other conditional statements."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the variable. Defaults to 'Variable' and gets\nuniquified automatically."}, {"name": "variable_def", "is_optional": true, "type": "others", "default_value": "None", "description": "VariableDef protocol buffer. If not None, recreates the\nVariable object with its contents, referencing the variable's nodes in\nthe graph, which must already exist. The graph is not changed.\nvariable_def and the other arguments are mutually exclusive."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "If set, initial_value will be converted to the given type. If\nNone, either the datatype will be kept (if initial_value is a\nTensor), or convert_to_tensor will decide."}, {"name": "import_scope", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. Name scope to add to the Variable. Only\nused when initializing from protocol buffer."}, {"name": "constraint", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional projection function to be applied to the variable\nafter being updated by an Optimizer (e.g. used to implement norm\nconstraints or value constraints for layer weights). The function must\ntake as input the unprojected Tensor representing the value of the\nvariable and return the Tensor for the projected value (which must have\nthe same shape). Constraints are not safe to use when doing asynchronous\ndistributed training."}, {"name": "synchronization", "is_optional": true, "type": "string", "default_value": "tf.VariableSynchronization.AUTO", "description": "Indicates when a distributed a variable will be\naggregated. Accepted values are constants defined in the class\ntf.VariableSynchronization. By default the synchronization is set to\nAUTO and the current DistributionStrategy chooses when to\nsynchronize."}, {"name": "aggregation", "is_optional": true, "type": "string", "default_value": "tf.compat.v1.VariableAggregation.NONE", "description": "Indicates how a distributed variable will be aggregated.\nAccepted values are constants defined in the class\ntf.VariableAggregation."}, {"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The shape of this variable. If None, the shape of\ninitial_value will be used. When setting this argument to\ntf.TensorShape(None) (representing an unspecified shape), the variable\ncan be assigned with values of different shapes."}]}},
{"id": "tf.unstack", "type": "function", "code": "tf.unstack(value,num=None,axis=0,name='unstack')", "summary": "Unpacks the given dimension of a rank-R tensor into rank-(R-1) tensors.", "description": "", "code-info": {"name": "tf.unstack", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "A rank R &gt; 0 Tensor to be unstacked."}, {"name": "num", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. The length of the dimension axis. Automatically inferred if\nNone (the default)."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "An int. The axis to unstack along. Defaults to the first dimension.\nNegative values wrap around, so the valid range is [-R, R)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'unstack'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.unique", "type": "function", "code": "tf.unique(x,out_idx=tf.dtypes.int32,name=None)", "summary": "Finds unique elements in a 1-D tensor.", "description": "", "code-info": {"name": "tf.unique", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. 1-D."}, {"name": "out_idx", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.unravel_index", "type": "function", "code": "tf.unravel_index(indices,dims,name=None)", "summary": "Converts an array of flat indices into a tuple of coordinate arrays.", "description": "", "code-info": {"name": "tf.unravel_index", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nAn 0-D or 1-D int Tensor whose elements are indices into the\nflattened version of an array of dimensions dims."}, {"name": "dims", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as indices.\nAn 1-D int Tensor. The shape of the array to use for unraveling\nindices."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.unique_with_counts", "type": "function", "code": "tf.unique_with_counts(x,out_idx=tf.dtypes.int32,name=None)", "summary": "Finds unique elements in a 1-D tensor.", "description": "", "code-info": {"name": "tf.unique_with_counts", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. 1-D."}, {"name": "out_idx", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "An optional tf.DType from: tf.int32, tf.int64. Defaults to tf.int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "__eq__", "type": "function", "code": "__eq__(other)", "summary": "Specifies a TensorFlow value type.", "description": "", "code-info": {"name": "__eq__", "parameters": [{"name": "other", "is_optional": false, "type": "others", "description": "A TypeSpec."}]}},
{"id": "tf.truncatemod", "type": "function", "code": "tf.truncatemod(x,y,name=None)", "summary": "Returns element-wise remainder of division. This emulates C semantics in that", "description": "", "code-info": {"name": "tf.truncatemod", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64, bfloat16, half, float32, float64."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.truncatediv", "type": "function", "code": "tf.truncatediv(x,y,name=None)", "summary": "Returns x / y element-wise for integer types.", "description": "", "code-info": {"name": "tf.truncatediv", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.tuple", "type": "function", "code": "tf.tuple(tensors,control_inputs=None,name=None)", "summary": "Group tensors together.", "description": "", "code-info": {"name": "tf.tuple", "parameters": [{"name": "tensors", "is_optional": false, "type": "tensor", "description": "A list of Tensors or IndexedSlices, some entries can be None."}, {"name": "control_inputs", "is_optional": true, "type": "others", "default_value": "None", "description": "List of additional ops to finish before returning."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(optional) A name to use as a name_scope for the operation."}]}},
{"id": "tf.timestamp", "type": "function", "code": "tf.timestamp(name=None)", "summary": "Provides the time since epoch in seconds.", "description": "", "code-info": {"name": "tf.timestamp", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.tile", "type": "function", "code": "tf.tile(input,multiples,name=None)", "summary": "Constructs a tensor by tiling a given tensor.", "description": "", "code-info": {"name": "tf.tile", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. 1-D or higher."}, {"name": "multiples", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n1-D. Length must be the same as the number of dimensions in input"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.transpose", "type": "function", "code": "tf.transpose(a,perm=None,conjugate=False,name='transpose')", "summary": "Transposes a.", "description": "", "code-info": {"name": "tf.transpose", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "perm", "is_optional": true, "type": "others", "default_value": "None", "description": "A permutation of the dimensions of a."}, {"name": "conjugate", "is_optional": true, "type": "bool", "default_value": "False", "description": "Optional bool. Setting it to True is mathematically equivalent\nto tf.math.conj(tf.transpose(input))."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'transpose'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.tensordot", "type": "function", "code": "tf.tensordot(a,b,axes,name=None)", "summary": "Tensor contraction of a and b along specified axes and outer product.", "description": "", "code-info": {"name": "tf.tensordot", "parameters": [{"name": "a", "is_optional": false, "type": "tensor", "description": "Tensor of type float32 or float64."}, {"name": "b", "is_optional": false, "type": "tensor", "description": "Tensor with the same type as a."}, {"name": "axes", "is_optional": false, "type": "tensor", "description": "Either a scalar N, or a list or an int32 Tensor of shape [2, k].\nIf axes is a scalar, sum over the last N axes of a and the first N axes of\nb in order. If axes is a list or Tensor the first and second row contain\nthe set of unique integers specifying axes along which the contraction is\ncomputed, for a and b, respectively. The number of axes for a and\nb must be equal. If axes=0, computes the outer product between a and\nb."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.TensorShape", "type": "class", "code": "tf.TensorShape(dims)", "summary": "Represents the shape of a Tensor.", "description": "", "code-info": {"name": "tf.TensorShape", "parameters": [{"name": "dims", "is_optional": false, "type": "others", "description": "A list of Dimensions, or None if the shape is unspecified."}]}},
{"id": "tf.tensor_scatter_nd_add", "type": "function", "code": "tf.tensor_scatter_nd_add(tensor,indices,updates,name=None)", "summary": "Adds sparse updates to an existing tensor according to indices.", "description": "", "code-info": {"name": "tf.tensor_scatter_nd_add", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. Tensor to copy/update."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as tensor.\nUpdates to scatter into output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.TensorArraySpec", "type": "class", "code": "tf.TensorArraySpec(element_shape=None,dtype=tf.dtypes.float32,dynamic_size=False,infer_shape=True)", "summary": "Type specification for a tf.TensorArray.\n\nInherits From: TypeSpec", "description": "", "code-info": {"name": "tf.TensorArraySpec", "parameters": [{"name": "element_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The shape of each element in the TensorArray."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "Data type of the TensorArray."}, {"name": "dynamic_size", "is_optional": true, "type": "bool", "default_value": "False", "description": "Whether the TensorArray can grow past its initial size."}, {"name": "infer_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether shape inference is enabled."}]}},
{"id": "tf.tensor_scatter_nd_update", "type": "function", "code": "tf.tensor_scatter_nd_update(tensor,indices,updates,name=None)", "summary": "Scatter updates into an existing tensor according to indices.", "description": "", "code-info": {"name": "tf.tensor_scatter_nd_update", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. Tensor to copy/update."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as tensor.\nUpdates to scatter into output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.tensor_scatter_nd_sub", "type": "function", "code": "tf.tensor_scatter_nd_sub(tensor,indices,updates,name=None)", "summary": "Subtracts sparse updates from an existing tensor according to indices.", "description": "", "code-info": {"name": "tf.tensor_scatter_nd_sub", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. Tensor to copy/update."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as tensor.\nUpdates to scatter into output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.TensorArray", "type": "class", "code": "tf.TensorArray(dtype,size=None,dynamic_size=None,clear_after_read=None,tensor_array_name=None,handle=None,flow=None,infer_shape=True,element_shape=None,colocate_with_first_write_call=True,name=None)", "summary": "Class wrapping dynamic-sized, per-time-step, write-once Tensor arrays.", "description": "", "code-info": {"name": "tf.TensorArray", "parameters": [{"name": "dtype", "is_optional": false, "type": "tensor", "description": "(required) data type of the TensorArray."}, {"name": "size", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) int32 scalar Tensor: the size of the TensorArray.\nRequired if handle is not provided."}, {"name": "dynamic_size", "is_optional": true, "type": "bool", "default_value": "None", "description": "(optional) Python bool: If true, writes to the TensorArray\ncan grow the TensorArray past its initial size.  Default: False."}, {"name": "clear_after_read", "is_optional": true, "type": "bool", "default_value": "None", "description": "Boolean (optional, default: True).  If True, clear\nTensorArray values after reading them.  This disables read-many\nsemantics, but allows early release of memory."}, {"name": "tensor_array_name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) Python string: the name of the TensorArray.\nThis is used when creating the TensorArray handle.  If this value is\nset, handle should be None."}, {"name": "handle", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) A Tensor handle to an existing TensorArray.  If this\nis set, tensor_array_name should be None. Only supported in graph mode."}, {"name": "flow", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) A float Tensor scalar coming from an existing\nTensorArray.flow. Only supported in graph mode."}, {"name": "infer_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional, default: True) If True, shape inference\nis enabled.  In this case, all elements must have the same shape."}, {"name": "element_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional, default: None) A TensorShape object specifying\nthe shape constraints of each of the elements of the TensorArray.\nNeed not be fully defined."}, {"name": "colocate_with_first_write_call", "is_optional": true, "type": "bool", "default_value": "True", "description": "If True, the TensorArray will be\ncolocated on the same device as the Tensor used on its first write\n(write operations include write, unstack, and split).  If False,\nthe TensorArray will be placed on the device determined by the\ndevice context available during its initialization."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.TensorSpec", "type": "class", "code": "tf.TensorSpec(shape,dtype=tf.dtypes.float32,name=None)", "summary": "Describes a tf.Tensor.", "description": "", "code-info": {"name": "tf.TensorSpec", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "Value convertible to tf.TensorShape. The shape of the tensor."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Value convertible to tf.DType. The type of the tensor values."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name for the Tensor."}]}},
{"id": "tf.Tensor", "type": "class", "code": "tf.Tensor(op,value_index,dtype)", "summary": "Represents one of the outputs of an Operation.", "description": "", "code-info": {"name": "tf.Tensor", "parameters": [{"name": "op", "is_optional": false, "type": "tensor", "description": "An Operation. Operation that computes this tensor."}, {"name": "value_index", "is_optional": false, "type": "others", "description": "An int. Index of the operation's endpoint that produces\nthis tensor."}, {"name": "dtype", "is_optional": false, "type": "tensor", "description": "A DType. Type of elements stored in this tensor."}]}},
{"id": "tf.stop_gradient", "type": "function", "code": "tf.stop_gradient(input,name=None)", "summary": "Stops gradient computation.", "description": "", "code-info": {"name": "tf.stop_gradient", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.stack", "type": "function", "code": "tf.stack(values,axis=0,name='stack')", "summary": "Stacks a list of rank-R tensors into one rank-(R+1) tensor.", "description": "", "code-info": {"name": "tf.stack", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with the same shape and type."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "An int. The axis to stack along. Defaults to the first dimension.\nNegative values wrap around, so the valid range is [-(R+1), R+1)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'stack'", "description": "A name for this operation (optional)."}]}},
{"id": "tf.switch_case", "type": "function", "code": "tf.switch_case(branch_index,branch_fns,default=None,name='switch_case')", "summary": "Create a switch/case operation, i.e. an integer-indexed conditional.", "description": "", "code-info": {"name": "tf.switch_case", "parameters": [{"name": "branch_index", "is_optional": false, "type": "tensor", "description": "An int Tensor specifying which of branch_fns should be\nexecuted."}, {"name": "branch_fns", "is_optional": false, "type": "others", "description": "A dict mapping ints to callables, or a list of\n(int, callable) pairs, or simply a list of callables (in which case the\nindex serves as the key). Each callable must return a matching structure\nof tensors."}, {"name": "default", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional callable that returns a structure of tensors."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'switch_case'", "description": "A name for this operation (optional)."}]}},
{"id": "tf.squeeze", "type": "function", "code": "tf.squeeze(input,axis=None,name=None)", "summary": "Removes dimensions of size 1 from the shape of a tensor.", "description": "", "code-info": {"name": "tf.squeeze", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. The input to squeeze."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional list of ints. Defaults to []. If specified, only\nsqueezes the dimensions listed. The dimension index starts at 0. It is an\nerror to squeeze a dimension that is not 1. Must be in the range\n[-rank(input), rank(input)). Must be specified if input is a\nRaggedTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.strided_slice", "type": "function", "code": "tf.strided_slice(input_,begin,end,strides=None,begin_mask=0,end_mask=0,ellipsis_mask=0,new_axis_mask=0,shrink_axis_mask=0,var=None,name=None)", "summary": "Extracts a strided slice of a tensor (generalized python array indexing).", "description": "", "code-info": {"name": "tf.strided_slice", "parameters": [{"name": "input_", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "begin", "is_optional": false, "type": "tensor", "description": "An int32 or int64 Tensor."}, {"name": "end", "is_optional": false, "type": "tensor", "description": "An int32 or int64 Tensor."}, {"name": "strides", "is_optional": true, "type": "tensor", "default_value": "None", "description": "An int32 or int64 Tensor."}, {"name": "begin_mask", "is_optional": true, "type": "int", "default_value": "0", "description": "An int32 mask."}, {"name": "end_mask", "is_optional": true, "type": "int", "default_value": "0", "description": "An int32 mask."}, {"name": "ellipsis_mask", "is_optional": true, "type": "int", "default_value": "0", "description": "An int32 mask."}, {"name": "new_axis_mask", "is_optional": true, "type": "int", "default_value": "0", "description": "An int32 mask."}, {"name": "shrink_axis_mask", "is_optional": true, "type": "int", "default_value": "0", "description": "An int32 mask."}, {"name": "var", "is_optional": true, "type": "others", "default_value": "None", "description": "The variable corresponding to input_ or None"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.SparseTensorSpec", "type": "class", "code": "tf.SparseTensorSpec(shape=None,dtype=tf.dtypes.float32)", "summary": "Type specification for a tf.SparseTensor.", "description": "", "code-info": {"name": "tf.SparseTensorSpec", "parameters": [{"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The dense shape of the SparseTensor, or None to allow\nany dense shape."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "tf.DType of values in the SparseTensor."}]}},
{"id": "tf.split", "type": "function", "code": "tf.split(value,num_or_size_splits,axis=0,num=None,name='split')", "summary": "Splits a tensor into sub tensors.", "description": "", "code-info": {"name": "tf.split", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "The Tensor to split."}, {"name": "num_or_size_splits", "is_optional": false, "type": "int", "description": "Either an integer indicating the number of splits along\naxis or a 1-D integer Tensor or Python list containing the sizes of\neach output tensor along axis. If a scalar, then it must evenly divide\nvalue.shape[axis]; otherwise the sum of sizes along the split axis\nmust match that of the value."}, {"name": "axis", "is_optional": true, "type": "int", "default_value": "0", "description": "An integer or scalar int32 Tensor. The dimension along which to\nsplit. Must be in the range [-rank(value), rank(value)). Defaults to 0."}, {"name": "num", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional, used to specify the number of outputs when it cannot be\ninferred from the shape of size_splits."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'split'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.space_to_batch_nd", "type": "function", "code": "tf.space_to_batch_nd(input,block_shape,paddings,name=None)", "summary": "SpaceToBatch for N-D tensors of type T.", "description": "", "code-info": {"name": "tf.space_to_batch_nd", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor.\nN-D with shape input_shape = [batch] + spatial_shape + remaining_shape,\nwhere spatial_shape has M dimensions."}, {"name": "block_shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n1-D with shape [M], all values must be &gt;= 1."}, {"name": "paddings", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n2-D with shape [M, 2], all values must be &gt;= 0.\npaddings[i] = [pad_start, pad_end] specifies the padding for input dimension\ni + 1, which corresponds to spatial dimension i.  It is required that\nblock_shape[i] divides input_shape[i + 1] + pad_start + pad_end.\n\nThis operation is equivalent to the following steps:\n\n\nZero-pad the start and end of dimensions [1, ..., M] of the\ninput according to paddings to produce padded of shape padded_shape.\nReshape padded to reshaped_padded of shape:\n\n[batch] +\n[padded_shape[1] / block_shape[0],\n block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1],\nblock_shape[M-1]] +\nremaining_shape\nPermute dimensions of reshaped_padded to produce\npermuted_reshaped_padded of shape:\n\nblock_shape +\n[batch] +\n[padded_shape[1] / block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1]] +\nremaining_shape\nReshape permuted_reshaped_padded to flatten block_shape into the batch\ndimension, producing an output tensor of shape:\n\n[batch * prod(block_shape)] +\n[padded_shape[1] / block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1]] +\nremaining_shape\n\n\nSome examples:\n\n(1) For the following input of shape [1, 2, 2, 1], block_shape = [2, 2], and\n  paddings = [[0, 0], [0, 0]]:\n\n\n\nx = [[[[1], [2]], [[3], [4]]]]\n\n\nThe output tensor has shape [4, 1, 1, 1] and value:\n\n\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n\n\n(2) For the following input of shape [1, 2, 2, 3], block_shape = [2, 2], and\n      paddings = [[0, 0], [0, 0]]:\n\n\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n\n\nThe output tensor has shape [4, 1, 1, 3] and value:\n\n\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n\n\n(3) For the following input of shape [1, 4, 4, 1], block_shape = [2, 2], and\n      paddings = [[0, 0], [0, 0]]:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [4, 2, 2, 1] and value:\n\n\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n\n\n(4) For the following input of shape [2, 2, 4, 1], block_shape = [2, 2], and\n      paddings = [[0, 0], [2, 0]]:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [8, 1, 3, 1] and value:\n\n\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n\n\nAmong others, this operation is useful for reducing atrous convolution into\n  regular convolution.\n\n"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.space_to_batch", "type": "function", "code": "tf.space_to_batch(input,block_shape,paddings,name=None)", "summary": "SpaceToBatch for N-D tensors of type T.", "description": "", "code-info": {"name": "tf.space_to_batch", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor.\nN-D with shape input_shape = [batch] + spatial_shape + remaining_shape,\nwhere spatial_shape has M dimensions."}, {"name": "block_shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n1-D with shape [M], all values must be &gt;= 1."}, {"name": "paddings", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n2-D with shape [M, 2], all values must be &gt;= 0.\npaddings[i] = [pad_start, pad_end] specifies the padding for input dimension\ni + 1, which corresponds to spatial dimension i.  It is required that\nblock_shape[i] divides input_shape[i + 1] + pad_start + pad_end.\n\nThis operation is equivalent to the following steps:\n\n\nZero-pad the start and end of dimensions [1, ..., M] of the\ninput according to paddings to produce padded of shape padded_shape.\nReshape padded to reshaped_padded of shape:\n\n[batch] +\n[padded_shape[1] / block_shape[0],\n block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1],\nblock_shape[M-1]] +\nremaining_shape\nPermute dimensions of reshaped_padded to produce\npermuted_reshaped_padded of shape:\n\nblock_shape +\n[batch] +\n[padded_shape[1] / block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1]] +\nremaining_shape\nReshape permuted_reshaped_padded to flatten block_shape into the batch\ndimension, producing an output tensor of shape:\n\n[batch * prod(block_shape)] +\n[padded_shape[1] / block_shape[0],\n...,\npadded_shape[M] / block_shape[M-1]] +\nremaining_shape\n\n\nSome examples:\n\n(1) For the following input of shape [1, 2, 2, 1], block_shape = [2, 2], and\n  paddings = [[0, 0], [0, 0]]:\n\n\n\nx = [[[[1], [2]], [[3], [4]]]]\n\n\nThe output tensor has shape [4, 1, 1, 1] and value:\n\n\n[[[[1]]], [[[2]]], [[[3]]], [[[4]]]]\n\n\n(2) For the following input of shape [1, 2, 2, 3], block_shape = [2, 2], and\n      paddings = [[0, 0], [0, 0]]:\n\n\nx = [[[[1, 2, 3], [4, 5, 6]],\n      [[7, 8, 9], [10, 11, 12]]]]\n\n\nThe output tensor has shape [4, 1, 1, 3] and value:\n\n\n[[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]]\n\n\n(3) For the following input of shape [1, 4, 4, 1], block_shape = [2, 2], and\n      paddings = [[0, 0], [0, 0]]:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]],\n      [[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [4, 2, 2, 1] and value:\n\n\nx = [[[[1], [3]], [[9], [11]]],\n     [[[2], [4]], [[10], [12]]],\n     [[[5], [7]], [[13], [15]]],\n     [[[6], [8]], [[14], [16]]]]\n\n\n(4) For the following input of shape [2, 2, 4, 1], block_shape = [2, 2], and\n      paddings = [[0, 0], [2, 0]]:\n\n\nx = [[[[1],   [2],  [3],  [4]],\n      [[5],   [6],  [7],  [8]]],\n     [[[9],  [10], [11],  [12]],\n      [[13], [14], [15],  [16]]]]\n\n\nThe output tensor has shape [8, 1, 3, 1] and value:\n\n\nx = [[[[0], [1], [3]]], [[[0], [9], [11]]],\n     [[[0], [2], [4]]], [[[0], [10], [12]]],\n     [[[0], [5], [7]]], [[[0], [13], [15]]],\n     [[[0], [6], [8]]], [[[0], [14], [16]]]]\n\n\nAmong others, this operation is useful for reducing atrous convolution into\n  regular convolution.\n\n"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sort", "type": "function", "code": "tf.sort(values,axis=-1,direction='ASCENDING',name=None)", "summary": "Sorts a tensor.", "description": "", "code-info": {"name": "tf.sort", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "1-D or higher numeric Tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The axis along which to sort. The default is -1, which sorts the last\naxis."}, {"name": "direction", "is_optional": true, "type": "string", "default_value": "'ASCENDING'", "description": "The direction in which to sort the values ('ASCENDING' or\n'DESCENDING')."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.slice", "type": "function", "code": "tf.slice(input_,begin,size,name=None)", "summary": "Extracts a slice from a tensor.", "description": "", "code-info": {"name": "tf.slice", "parameters": [{"name": "input_", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "begin", "is_optional": false, "type": "tensor", "description": "An int32 or int64 Tensor."}, {"name": "size", "is_optional": false, "type": "tensor", "description": "An int32 or int64 Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.size", "type": "function", "code": "tf.size(input,out_type=tf.dtypes.int32,name=None)", "summary": "", "description": "", "code-info": {"name": "tf.size", "parameters": [{"name": "input", "is_optional": false, "type": "others", "description": ""}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": ""}, {"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.shape_n", "type": "function", "code": "tf.shape_n(input,out_type=tf.dtypes.int32,name=None)", "summary": "Returns shape of tensors.", "description": "", "code-info": {"name": "tf.shape_n", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A list of at least 1 Tensor object with the same type."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "The specified output type of the operation (int32 or int64).\nDefaults to tf.int32(optional)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.reverse", "type": "function", "code": "tf.reverse(tensor,axis,name=None)", "summary": "Reverses specific dimensions of a tensor.", "description": "", "code-info": {"name": "tf.reverse", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: uint8, int8, uint16, int16, int32, int64, bool, bfloat16, half, float32, float64, complex64, complex128, string.\nUp to 8-D."}, {"name": "axis", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n1-D. The indices of the dimensions to reverse. Must be in the range\n[-rank(tensor), rank(tensor))."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.scatter_nd", "type": "function", "code": "tf.scatter_nd(indices,updates,shape,name=None)", "summary": "Scatter updates into a new tensor according to indices.", "description": "", "code-info": {"name": "tf.scatter_nd", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nIndex tensor."}, {"name": "updates", "is_optional": false, "type": "tensor", "description": "A Tensor. Updates to scatter into output."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as indices.\n1-D. The shape of the resulting tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.shape", "type": "function", "code": "tf.shape(input,out_type=tf.dtypes.int32,name=None)", "summary": "Returns the shape of a tensor.", "description": "", "code-info": {"name": "tf.shape", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "(Optional) The specified output type of the operation (int32 or\nint64). Defaults to tf.int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.scan", "type": "function", "code": "tf.scan(fn,elems,initializer=None,parallel_iterations=10,back_prop=True,swap_memory=False,infer_shape=True,reverse=False,name=None)", "summary": "scan on the list of tensors unpacked from elems on dimension 0.", "description": "", "code-info": {"name": "tf.scan", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "The callable to be performed.  It accepts two arguments.  The first will\nhave the same structure as initializer if one is provided, otherwise it\nwill have the same structure as elems.  The second will have the same\n(possibly nested) structure as elems.  Its output must have the same\nstructure as initializer if one is provided, otherwise it must have the\nsame structure as elems."}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "A tensor or (possibly nested) sequence of tensors, each of which will\nbe unpacked along their first dimension.  The nested sequence of the\nresulting slices will be the first argument to fn."}, {"name": "initializer", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) A tensor or (possibly nested) sequence of tensors,\ninitial value for the accumulator, and the expected output type of fn."}, {"name": "parallel_iterations", "is_optional": true, "type": "int", "default_value": "10", "description": "(optional) The number of iterations allowed to run in\nparallel."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) True enables support for back propagation."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "(optional) True enables GPU-CPU memory swapping."}, {"name": "infer_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) False disables tests for consistent output shapes."}, {"name": "reverse", "is_optional": true, "type": "bool", "default_value": "False", "description": "(optional) True scans the tensor last to first (instead of first to\nlast)."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) Name prefix for the returned tensors."}]}},
{"id": "tf.searchsorted", "type": "function", "code": "tf.searchsorted(sorted_sequence,values,side='left',out_type=tf.dtypes.int32,name=None)", "summary": "Searches input tensor for values on the innermost dimension.", "description": "", "code-info": {"name": "tf.searchsorted", "parameters": [{"name": "sorted_sequence", "is_optional": false, "type": "tensor", "description": "N-D Tensor containing a sorted sequence."}, {"name": "values", "is_optional": false, "type": "tensor", "description": "N-D Tensor containing the search values."}, {"name": "side", "is_optional": true, "type": "string", "default_value": "'left'", "description": "'left' or 'right'; 'left' corresponds to lower_bound and 'right' to\nupper_bound."}, {"name": "out_type", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": "The output type (int32 or int64).  Default is tf.int32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}},
{"id": "tf.roll", "type": "function", "code": "tf.roll(input,shift,axis,name=None)", "summary": "Rolls the elements of a tensor along an axis.", "description": "", "code-info": {"name": "tf.roll", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "shift", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nDimension must be 0-D or 1-D. shift[i] specifies the number of places by which\nelements are shifted positively (towards larger indices) along the dimension\nspecified by axis[i]. Negative shifts will roll the elements in the opposite\ndirection."}, {"name": "axis", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nDimension must be 0-D or 1-D. axis[i] specifies the dimension that the shift\nshift[i] should occur. If the same axis is referenced more than once, the\ntotal shift for that axis will be the sum of all the shifts that belong to that\naxis."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.reverse_sequence", "type": "function", "code": "tf.reverse_sequence(input,seq_lengths,seq_axis=None,batch_axis=None,name=None)", "summary": "Reverses variable length slices. (deprecated arguments) (deprecated arguments)", "description": "", "code-info": {"name": "tf.reverse_sequence", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. The input to reverse."}, {"name": "seq_lengths", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32,\n  int64. 1-D with length input.dims(batch_dim) and max(seq_lengths) &lt;=\n  input.dims(seq_dim)"}, {"name": "seq_axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. The dimension which is partially reversed."}, {"name": "batch_axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An optional int. Defaults to 0. The dimension along which\n  reversal is performed."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.sequence_mask", "type": "function", "code": "tf.sequence_mask(lengths,maxlen=None,dtype=tf.dtypes.bool,name=None)", "summary": "Returns a mask tensor representing the first N positions of each cell.", "description": "", "code-info": {"name": "tf.sequence_mask", "parameters": [{"name": "lengths", "is_optional": false, "type": "tensor", "description": "integer tensor, all its values &lt;= maxlen."}, {"name": "maxlen", "is_optional": true, "type": "tensor", "default_value": "None", "description": "scalar integer tensor, size of last dimension of returned tensor.\nDefault is the maximum value in lengths."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.bool", "description": "output type of the resulting tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "name of the op."}]}},
{"id": "tf.required_space_to_batch_paddings", "type": "function", "code": "tf.required_space_to_batch_paddings(input_shape,block_shape,base_paddings=None,name=None)", "summary": "Calculate padding required to make block_shape divide input_shape.", "description": "", "code-info": {"name": "tf.required_space_to_batch_paddings", "parameters": [{"name": "input_shape", "is_optional": false, "type": "tensor", "description": "int32 Tensor of shape [N]."}, {"name": "block_shape", "is_optional": false, "type": "tensor", "description": "int32 Tensor of shape [N]."}, {"name": "base_paddings", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional int32 Tensor of shape [N, 2].  Specifies the minimum\namount of padding to use.  All elements must be &gt;= 0.  If not specified,\ndefaults to 0."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "string.  Optional name prefix."}]}},
{"id": "tf.register_tensor_conversion_function", "type": "function", "code": "tf.register_tensor_conversion_function(base_type,conversion_func,priority=100)", "summary": "Registers a function for converting objects of base_type to Tensor.", "description": "", "code-info": {"name": "tf.register_tensor_conversion_function", "parameters": [{"name": "base_type", "is_optional": false, "type": "others", "description": "The base type or tuple of base types for all objects that\nconversion_func accepts."}, {"name": "conversion_func", "is_optional": false, "type": "others", "description": "A function that converts instances of base_type to\nTensor."}, {"name": "priority", "is_optional": true, "type": "int", "default_value": "100", "description": "Optional integer that indicates the priority for applying this\nconversion function. Conversion functions with smaller priority values run\nearlier than conversion functions with larger priority values. Defaults to\n100."}]}},
{"id": "tf.reshape", "type": "function", "code": "tf.reshape(tensor,shape,name=None)", "summary": "Reshapes a tensor.", "description": "", "code-info": {"name": "tf.reshape", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nDefines the shape of the output tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. A name for the operation."}]}},
{"id": "tf.RegisterGradient", "type": "function", "code": "tf.RegisterGradient(op_type)", "summary": "A decorator for registering the gradient function for an op type.", "description": "", "code-info": {"name": "tf.RegisterGradient", "parameters": [{"name": "op_type", "is_optional": false, "type": "string", "description": "The string type of an operation. This corresponds to the\nOpDef.name field for the proto that defines the operation."}]}},
{"id": "tf.range", "type": "function", "code": "tf.range(limit,delta=1,dtype=None,name='range')tf.range(start,limit,delta=1,dtype=None,name='range')", "summary": "Creates a sequence of numbers.", "description": "", "code-info": {"name": "tf.range", "parameters": [{"name": "limit", "is_optional": false, "type": "tensor", "description": "A 0-D Tensor (scalar). Upper limit of sequence, exclusive. If None,\ndefaults to the value of start while the first entry of the range\ndefaults to 0."}, {"name": "delta", "is_optional": true, "type": "int", "default_value": "1", "description": "A 0-D Tensor (scalar). Number that increments start. Defaults to\n1."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The type of the elements of the resulting tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'range')tf.rang", "description": "A name for the operation. Defaults to \"range\"."}]}},
{"id": "tf.reduce_all", "type": "function", "code": "tf.reduce_all(input_tensor,axis=None,keepdims=False,name=None)", "summary": "Computes the \"logical and\" of elements across dimensions of a tensor.", "description": "", "code-info": {"name": "tf.reduce_all", "parameters": [{"name": "input_tensor", "is_optional": false, "type": "tensor", "description": "The boolean tensor to reduce."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The dimensions to reduce. If None (the default), reduces all\ndimensions. Must be in the range [-rank(input_tensor),\nrank(input_tensor))."}, {"name": "keepdims", "is_optional": true, "type": "bool", "default_value": "False", "description": "If true, retains reduced dimensions with length 1."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.recompute_grad", "type": "function", "code": "tf.recompute_grad(f)", "summary": "An eager-compatible version of recompute_grad.", "description": "", "code-info": {"name": "tf.recompute_grad", "parameters": [{"name": "f", "is_optional": false, "type": "tensor", "description": "function f(*x) that returns a Tensor or sequence of Tensor outputs."}]}},
{"id": "tf.repeat", "type": "function", "code": "tf.repeat(input,repeats,axis=None,name=None)", "summary": "Repeat elements of input.", "description": "", "code-info": {"name": "tf.repeat", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "An N-dimensional Tensor."}, {"name": "repeats", "is_optional": false, "type": "tensor", "description": "An 1-D int Tensor. The number of repetitions for each element.\nrepeats is broadcasted to fit the shape of the given axis. len(repeats)\nmust equal input.shape[axis] if axis is not None."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "An int. The axis along which to repeat values. By default (axis=None),\nuse the flattened input array, and return a flat output array."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation."}]}},
{"id": "tf.realdiv", "type": "function", "code": "tf.realdiv(x,y,name=None)", "summary": "Returns x / y element-wise for real types.", "description": "", "code-info": {"name": "tf.realdiv", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, uint8, int8, uint16, int16, int32, int64, complex64, complex128."}, {"name": "y", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as x."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.rank", "type": "function", "code": "tf.rank(input,name=None)", "summary": "Returns the rank of a tensor.", "description": "", "code-info": {"name": "tf.rank", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.random_uniform_initializer", "type": "function", "code": "tf.random_uniform_initializer(minval=-0.05,maxval=0.05,seed=None)", "summary": "Initializer that generates tensors with a uniform distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.random_uniform_initializer", "parameters": [{"name": "minval", "is_optional": true, "type": "tensor", "default_value": "-0.05", "description": "A python scalar or a scalar tensor. Lower bound of the range\nof random values to generate."}, {"name": "maxval", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "A python scalar or a scalar tensor. Upper bound of the range\nof random values to generate.  Defaults to 1 for float types."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "tf.random_normal_initializer", "type": "function", "code": "tf.random_normal_initializer(mean=0.0,stddev=0.05,seed=None)", "summary": "Initializer that generates tensors with a normal distribution.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.random_normal_initializer", "parameters": [{"name": "mean", "is_optional": true, "type": "tensor", "default_value": "0.0", "description": "a python scalar or a scalar tensor. Mean of the random values\nto generate."}, {"name": "stddev", "is_optional": true, "type": "tensor", "default_value": "0.05", "description": "a python scalar or a scalar tensor. Standard deviation of the\nrandom values to generate."}, {"name": "seed", "is_optional": true, "type": "int", "default_value": "None", "description": "A Python integer. Used to create random seeds. See\ntf.compat.v1.set_random_seed\nfor behavior."}]}},
{"id": "tf.OptionalSpec", "type": "class", "code": "tf.OptionalSpec(value_structure)", "summary": "Represents an optional potentially containing a structured value.\n\nInherits From: TypeSpec", "description": "", "code-info": {"name": "tf.OptionalSpec", "parameters": [{"name": "value_structure", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.py_function", "type": "function", "code": "tf.py_function(func,inp,Tout,name=None)", "summary": "Wraps a python function into a TensorFlow op that executes it eagerly.", "description": "", "code-info": {"name": "tf.py_function", "parameters": [{"name": "func", "is_optional": false, "type": "tensor", "description": "A Python function which accepts a list of Tensor objects having\nelement types that match the corresponding tf.Tensor objects in inp\nand returns a list of Tensor objects (or a single Tensor, or None)\nhaving element types that match the corresponding values in Tout."}, {"name": "inp", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects."}, {"name": "Tout", "is_optional": false, "type": "tensor", "description": "A list or tuple of tensorflow data types or a single tensorflow data\ntype if there is only one, indicating what func returns; an empty list\nif no value is returned (i.e., if the return value is None)."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.print", "type": "function", "code": "tf.print(*inputs,**kwargs)", "summary": "Print the specified inputs.", "description": "", "code-info": {"name": "tf.print", "parameters": [{"name": "*inputs", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.Operation", "type": "class", "code": "tf.Operation(node_def,g,inputs=None,output_types=None,control_inputs=None,input_types=None,original_op=None,op_def=None)", "summary": "Represents a graph node that performs computation on tensors.", "description": "", "code-info": {"name": "tf.Operation", "parameters": [{"name": "node_def", "is_optional": false, "type": "others", "description": "node_def_pb2.NodeDef.  NodeDef for the Operation. Used for\nattributes of node_def_pb2.NodeDef, typically name, op, and\ndevice.  The input attribute is irrelevant here as it will be\ncomputed when generating the model."}, {"name": "g", "is_optional": false, "type": "others", "description": "Graph. The parent graph."}, {"name": "inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "list of Tensor objects. The inputs to this Operation."}, {"name": "output_types", "is_optional": true, "type": "others", "default_value": "None", "description": "list of DType objects.  List of the types of the Tensors\ncomputed by this operation.  The length of this list indicates the\nnumber of output endpoints of the Operation."}, {"name": "control_inputs", "is_optional": true, "type": "tensor", "default_value": "None", "description": "list of operations or tensors from which to have a control\ndependency."}, {"name": "input_types", "is_optional": true, "type": "others", "default_value": "None", "description": "List of DType objects representing the types of the tensors\naccepted by the Operation.  By default uses [x.dtype.base_dtype for x\nin inputs].  Operations that expect reference-typed inputs must specify\nthese explicitly."}, {"name": "original_op", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. Used to associate the new Operation with an\nexisting Operation (for example, a replica with the op that was\nreplicated)."}, {"name": "op_def", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional. The op_def_pb2.OpDef proto that describes the op type\nthat this Operation represents."}]}},
{"id": "tf.RaggedTensor", "type": "class", "code": "tf.RaggedTensor(values,row_splits,cached_row_lengths=None,cached_value_rowids=None,cached_nrows=None,internal=False,uniform_row_length=None)", "summary": "Represents a ragged tensor.", "description": "", "code-info": {"name": "tf.RaggedTensor", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A potentially ragged tensor of any dtype and shape [nvals, ...]."}, {"name": "row_splits", "is_optional": false, "type": "tensor", "description": "A 1-D integer tensor with shape [nrows+1]."}, {"name": "cached_row_lengths", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D integer tensor with shape [nrows]"}, {"name": "cached_value_rowids", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D integer tensor with shape [nvals]."}, {"name": "cached_nrows", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D integer scalar tensor."}, {"name": "internal", "is_optional": true, "type": "bool", "default_value": "False", "description": "True if the constructor is being called by one of the factory\nmethods.  If false, an exception will be raised."}, {"name": "uniform_row_length", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A scalar tensor, specifying the length of every\nrow.  This row-partitioning scheme may only be used if all rows have\nthe same length."}]}},
{"id": "tf.pad", "type": "function", "code": "tf.pad(tensor,paddings,mode='CONSTANT',constant_values=0,name=None)", "summary": "Pads a tensor.", "description": "", "code-info": {"name": "tf.pad", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "paddings", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32."}, {"name": "mode", "is_optional": true, "type": "string", "default_value": "'CONSTANT'", "description": "One of \"CONSTANT\", \"REFLECT\", or \"SYMMETRIC\" (case-insensitive)"}, {"name": "constant_values", "is_optional": true, "type": "int", "default_value": "0", "description": "In \"CONSTANT\" mode, the scalar pad value to use. Must be\nsame type as tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.RaggedTensorSpec", "type": "class", "code": "tf.RaggedTensorSpec(shape=None,dtype=tf.dtypes.float32,ragged_rank=None,row_splits_dtype=tf.dtypes.int64)", "summary": "Type specification for a tf.RaggedTensor.", "description": "", "code-info": {"name": "tf.RaggedTensorSpec", "parameters": [{"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The shape of the RaggedTensor, or None to allow any shape.  If\na shape is specified, then all ragged dimensions must have size None."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "tf.DType of values in the RaggedTensor."}, {"name": "ragged_rank", "is_optional": true, "type": "int", "default_value": "None", "description": "Python integer, the ragged rank of the RaggedTensor\nto be described.  Defaults to shape.ndims - 1."}, {"name": "row_splits_dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.int64", "description": "dtype for the RaggedTensor's row_splits tensor.\nOne of tf.int32 or tf.int64."}]}},
{"id": "tf.parallel_stack", "type": "function", "code": "tf.parallel_stack(values,name='parallel_stack')", "summary": "Stacks a list of rank-R tensors into one rank-(R+1) tensor in parallel.", "description": "", "code-info": {"name": "tf.parallel_stack", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects with the same shape and type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'parallel_stack'", "description": "A name for this operation (optional)."}]}},
{"id": "tf.ones", "type": "function", "code": "tf.ones(shape,dtype=tf.dtypes.float32,name=None)", "summary": "Creates a tensor with all elements set to one (1).", "description": "", "code-info": {"name": "tf.ones", "parameters": [{"name": "shape", "is_optional": false, "type": "int", "description": "A list of integers, a tuple of integers, or\na 1-D Tensor of type int32."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "Optional DType of an element in the resulting Tensor. Default is\ntf.float32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional string. A name for the operation."}]}},
{"id": "tf.no_gradient", "type": "function", "code": "tf.no_gradient(op_type)", "summary": "Specifies that ops of type op_type is not differentiable.", "description": "", "code-info": {"name": "tf.no_gradient", "parameters": [{"name": "op_type", "is_optional": false, "type": "string", "description": "The string type of an operation. This corresponds to the\nOpDef.name field for the proto that defines the operation."}]}},
{"id": "tf.ones_like", "type": "function", "code": "tf.ones_like(input,dtype=None,name=None)", "summary": "Creates a tensor with all elements set to one.", "description": "", "code-info": {"name": "tf.ones_like", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A type for the returned Tensor. Must be float16, float32,\nfloat64, int8, uint8, int16, uint16, int32, int64,\ncomplex64, complex128, bool or string."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.one_hot", "type": "function", "code": "tf.one_hot(indices,depth,on_value=None,off_value=None,axis=None,dtype=None,name=None)", "summary": "Returns a one-hot tensor.", "description": "", "code-info": {"name": "tf.one_hot", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "A Tensor of indices."}, {"name": "depth", "is_optional": false, "type": "float", "description": "A scalar defining the depth of the one hot dimension."}, {"name": "on_value", "is_optional": true, "type": "float", "default_value": "None", "description": "A scalar defining the value to fill in output when indices[j]\n= i. (default: 1)"}, {"name": "off_value", "is_optional": true, "type": "float", "default_value": "None", "description": "A scalar defining the value to fill in output when indices[j]\n!= i. (default: 0)"}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "The axis to fill (default: -1, a new inner-most axis)."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The data type of the output tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "__call__", "type": "function", "code": "__call__(shape,dtype=tf.dtypes.float32)", "summary": "Initializer that generates tensors initialized to 1.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "__call__", "parameters": [{"name": "shape", "is_optional": false, "type": "tensor", "description": "Shape of the tensor."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "tf.dtypes.float32", "description": "Optional dtype of the tensor. Only numeric or boolean dtypes are\nsupported."}]}},
{"id": "tf.numpy_function", "type": "function", "code": "tf.numpy_function(func,inp,Tout,name=None)", "summary": "Wraps a python function and uses it as a TensorFlow op.", "description": "", "code-info": {"name": "tf.numpy_function", "parameters": [{"name": "func", "is_optional": false, "type": "others", "description": "A Python function, which accepts numpy.ndarray objects as arguments\nand returns a list of numpy.ndarray objects (or a single\nnumpy.ndarray). This function must accept as many arguments as there are\ntensors in inp, and these argument types will match the corresponding\ntf.Tensor objects in inp. The returns numpy.ndarrays must match the\nnumber and types defined Tout.\nImportant Note: Input and output numpy.ndarrays of func are not\nguaranteed to be copies. In some cases their underlying memory will be\nshared with the corresponding TensorFlow tensors. In-place modification\nor storing func input or return values in python datastructures\nwithout explicit (np.)copy can have non-deterministic consequences."}, {"name": "inp", "is_optional": false, "type": "tensor", "description": "A list of tf.Tensor objects."}, {"name": "Tout", "is_optional": false, "type": "tensor", "description": "A list or tuple of tensorflow data types or a single tensorflow data\ntype if there is only one, indicating what func returns.\nstateful (bool): If True, the function should be considered stateful. If\na function is stateless, when given the same input it will return the same\noutput and have no observable side effects. Optimizations such as common\nsubexpression elimination are only performed on stateless operations."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "(Optional) A name for the operation."}]}},
{"id": "tf.nondifferentiable_batch_function", "type": "function", "code": "tf.nondifferentiable_batch_function(num_batch_threads,max_batch_size,batch_timeout_micros,allowed_batch_sizes=None,max_enqueued_batches=10,autograph=True)", "summary": "Batches the computation done by the decorated function.", "description": "", "code-info": {"name": "tf.nondifferentiable_batch_function", "parameters": [{"name": "num_batch_threads", "is_optional": false, "type": "others", "description": "Number of scheduling threads for processing batches\nof work. Determines the number of batches processed in parallel."}, {"name": "max_batch_size", "is_optional": false, "type": "others", "description": "Batch sizes will never be bigger than this."}, {"name": "batch_timeout_micros", "is_optional": false, "type": "others", "description": "Maximum number of microseconds to wait before\noutputting an incomplete batch."}, {"name": "allowed_batch_sizes", "is_optional": true, "type": "others", "default_value": "None", "description": "Optional list of allowed batch sizes. If left empty,\ndoes nothing. Otherwise, supplies a list of batch sizes, causing the op\nto pad batches up to one of those sizes. The entries must increase\nmonotonically, and the final entry must equal max_batch_size."}, {"name": "max_enqueued_batches", "is_optional": true, "type": "int", "default_value": "10", "description": "The maximum depth of the batch queue. Defaults to 10."}, {"name": "autograph", "is_optional": true, "type": "bool", "default_value": "True", "description": "Whether to use autograph to compile python and eager style code\nfor efficient graph-mode execution."}]}},
{"id": "tf.no_op", "type": "function", "code": "tf.no_op(name=None)", "summary": "Does nothing. Only useful as a placeholder for control edges.", "description": "", "code-info": {"name": "tf.no_op", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.map_fn", "type": "function", "code": "tf.map_fn(fn,elems,dtype=None,parallel_iterations=None,back_prop=True,swap_memory=False,infer_shape=True,name=None)", "summary": "map on the list of tensors unpacked from elems on dimension 0.", "description": "", "code-info": {"name": "tf.map_fn", "parameters": [{"name": "fn", "is_optional": false, "type": "others", "description": "The callable to be performed.  It accepts one argument, which will\nhave the same (possibly nested) structure as elems.  Its output\nmust have the same structure as dtype if one is provided, otherwise\nit must have the same structure as elems."}, {"name": "elems", "is_optional": false, "type": "tensor", "description": "A tensor or (possibly nested) sequence of tensors, each of which\nwill be unpacked along their first dimension.  The nested sequence\nof the resulting slices will be applied to fn."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The output type(s) of fn.  If fn returns a structure\nof Tensors differing from the structure of elems, then dtype is not\noptional and must have the same structure as the output of fn."}, {"name": "parallel_iterations", "is_optional": true, "type": "others", "default_value": "None", "description": "(optional) The number of iterations allowed to run\nin parallel. When graph building, the default value is 10. While executing\neagerly, the default value is set to 1."}, {"name": "back_prop", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) True enables support for back propagation."}, {"name": "swap_memory", "is_optional": true, "type": "bool", "default_value": "False", "description": "(optional) True enables GPU-CPU memory swapping."}, {"name": "infer_shape", "is_optional": true, "type": "bool", "default_value": "True", "description": "(optional) False disables tests for consistent output shapes."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "(optional) Name prefix for the returned tensors."}]}},
{"id": "tf.norm", "type": "function", "code": "tf.norm(tensor,ord='euclidean',axis=None,keepdims=None,name=None)", "summary": "Computes the norm of vectors, matrices, and tensors.", "description": "", "code-info": {"name": "tf.norm", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "Tensor of types float32, float64, complex64, complex128"}, {"name": "ord", "is_optional": true, "type": "string", "default_value": "'euclidean'", "description": "Order of the norm. Supported values are 'fro', 'euclidean',\n1, 2, np.inf and any positive real number yielding the corresponding\np-norm. Default is 'euclidean' which is equivalent to Frobenius norm if\ntensor is a matrix and equivalent to 2-norm for vectors.\nSome restrictions apply:\na) The Frobenius norm 'fro' is not defined for vectors,\nb) If axis is a 2-tuple (matrix norm), only 'euclidean', 'fro', 1,\n   2, np.inf are supported.\nSee the description of axis on how to compute norms for a batch of\nvectors or matrices stored in a tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "None", "description": "If axis is None (the default), the input is considered a vector\nand a single vector norm is computed over the entire set of values in the\ntensor, i.e. norm(tensor, ord=ord) is equivalent to\nnorm(reshape(tensor, [-1]), ord=ord).\nIf axis is a Python integer, the input is considered a batch of vectors,\nand axis determines the axis in tensor over which to compute vector\nnorms.\nIf axis is a 2-tuple of Python integers it is considered a batch of\nmatrices and axis determines the axes in tensor over which to compute\na matrix norm.\nNegative indices are supported. Example: If you are passing a tensor that\ncan be either a matrix or a batch of matrices at runtime, pass\naxis=[-2,-1] instead of axis=None to make sure that matrix norms are\ncomputed."}, {"name": "keepdims", "is_optional": true, "type": "others", "default_value": "None", "description": "If True, the axis indicated in axis are kept with size 1.\nOtherwise, the dimensions in axis are removed from the output shape."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "The name of the op."}]}},
{"id": "tf.name_scope", "type": "class", "code": "tf.name_scope(name)", "summary": "A context manager for use when defining a Python op.", "description": "", "code-info": {"name": "tf.name_scope", "parameters": [{"name": "name", "is_optional": false, "type": "string", "description": "The prefix to use on all names created within the name scope."}]}},
{"id": "tf.Module", "type": "function", "code": "tf.Module(name=None)", "summary": "Base neural network module class.", "description": "", "code-info": {"name": "tf.Module", "parameters": [{"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "  Returns the name of this module as passed or determined in the ctor."}]}},
{"id": "tf.meshgrid", "type": "function", "code": "tf.meshgrid(*args,**kwargs)", "summary": "Broadcasts parameters for evaluation on an N-D grid.", "description": "", "code-info": {"name": "tf.meshgrid", "parameters": [{"name": "*args", "is_optional": false, "type": "tensor", "description": "Tensors with rank 1."}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": "  - indexing: Either 'xy' or 'ij' (optional, default: 'xy')."}]}},
{"id": "tf.make_ndarray", "type": "function", "code": "tf.make_ndarray(tensor)", "summary": "Create a numpy ndarray from a tensor.", "description": "", "code-info": {"name": "tf.make_ndarray", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "A TensorProto."}]}},
{"id": "tf.load_op_library", "type": "function", "code": "tf.load_op_library(library_filename)", "summary": "Loads a TensorFlow plugin, containing custom ops and kernels.", "description": "", "code-info": {"name": "tf.load_op_library", "parameters": [{"name": "library_filename", "is_optional": false, "type": "others", "description": "Path to the plugin.\nRelative or absolute filesystem path to a dynamic library file."}]}},
{"id": "tf.is_tensor", "type": "function", "code": "tf.is_tensor(x)", "summary": "Checks whether x is a tensor or \"tensor-like\".", "description": "", "code-info": {"name": "tf.is_tensor", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": "A python object to check."}]}},
{"id": "tf.make_tensor_proto", "type": "function", "code": "tf.make_tensor_proto(values,dtype=None,shape=None,verify_shape=False,allow_broadcast=False)", "summary": "Create a TensorProto.", "description": "", "code-info": {"name": "tf.make_tensor_proto", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "        Values to put in the TensorProto."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "         Optional tensor_pb2 DataType value."}, {"name": "shape", "is_optional": true, "type": "int", "default_value": "None", "description": "         List of integers representing the dimensions of tensor."}, {"name": "verify_shape", "is_optional": true, "type": "bool", "default_value": "False", "description": "  Boolean that enables verification of a shape of values."}, {"name": "allow_broadcast", "is_optional": true, "type": "bool", "default_value": "False", "description": " Boolean that enables allowing scalars and 1 length vector\nbroadcasting. Cannot be true when verify_shape is true."}]}},
{"id": "tf.IndexedSlicesSpec", "type": "class", "code": "tf.IndexedSlicesSpec(shape=None,dtype=tf.dtypes.float32,indices_dtype=tf.dtypes.int64,dense_shape_dtype=None,indices_shape=None)", "summary": "Type specification for a tf.IndexedSlices.\n\nInherits From: TypeSpec", "description": "", "code-info": {"name": "tf.IndexedSlicesSpec", "parameters": [{"name": "shape", "is_optional": true, "type": "others", "default_value": "None", "description": "The dense shape of the IndexedSlices, or None to allow any\ndense shape."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.float32", "description": "tf.DType of values in the IndexedSlices."}, {"name": "indices_dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int64", "description": "tf.DType of the indices in the IndexedSlices.  One\nof tf.int32 or tf.int64."}, {"name": "dense_shape_dtype", "is_optional": true, "type": "others", "default_value": "None", "description": "tf.DType of the dense_shape in the IndexedSlices.\nOne of tf.int32, tf.int64, or None (if the IndexedSlices has\nno dense_shape tensor)."}, {"name": "indices_shape", "is_optional": true, "type": "others", "default_value": "None", "description": "The shape of the indices component, which indicates\nhow many slices are in the IndexedSlices."}]}},
{"id": "tf.load_library", "type": "function", "code": "tf.load_library(library_location)", "summary": "Loads a TensorFlow plugin.", "description": "", "code-info": {"name": "tf.load_library", "parameters": [{"name": "library_location", "is_optional": false, "type": "others", "description": "Path to the plugin or the folder of plugins.\nRelative or absolute filesystem path to a dynamic library file or folder."}]}},
{"id": "tf.linspace", "type": "function", "code": "tf.linspace(start,stop,num,name=None)", "summary": "Generates values in an interval.", "description": "", "code-info": {"name": "tf.linspace", "parameters": [{"name": "start", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64.\n0-D tensor. First entry in the range."}, {"name": "stop", "is_optional": false, "type": "tensor", "description": "A Tensor. Must have the same type as start.\n0-D tensor. Last entry in the range."}, {"name": "num", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\n0-D tensor. Number of values to generate."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.identity", "type": "function", "code": "tf.identity(input,name=None)", "summary": "Return a tensor with the same shape and contents as input.", "description": "", "code-info": {"name": "tf.identity", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.identity_n", "type": "function", "code": "tf.identity_n(input,name=None)", "summary": "Returns a list of tensors with the same shapes and contents as the input", "description": "", "code-info": {"name": "tf.identity_n", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.IndexedSlices", "type": "function", "code": "tf.IndexedSlices(values,indices,dense_shape=None)", "summary": "A sparse representation of a set of tensor slices at given indices.", "description": "", "code-info": {"name": "tf.IndexedSlices", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A Tensor of any dtype with shape [D0, D1, ..., Dn]."}, {"name": "indices", "is_optional": false, "type": "tensor", "description": "A 1-D integer Tensor with shape [D0].\n\n\nAn IndexedSlices is typically used to represent a subset of a larger\ntensor dense of shape [LARGE0, D1, .. , DN] where LARGE0 &gt;&gt; D0.\nThe values in indices are the indices in the first dimension of\nthe slices that have been extracted from the larger tensor.\n\nThe dense tensor dense represented by an IndexedSlices slices has\ndense[slices.indices[i], :, :, :, ...] = slices.values[i, :, :, :, ...]\n\nThe IndexedSlices class is used principally in the definition of\ngradients for operations that have sparse gradients\n(e.g. tf.gather).\n\nContrast this representation with\ntf.SparseTensor,\nwhich uses multi-dimensional indices and scalar values.\n\nAttributes:\n\n"}, {"name": "dense_shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "  A 1-D Tensor containing the shape of the corresponding dense tensor.\ndevice:   The name of the device on which values will be produced, or None.\ndtype:   The DType of elements in this tensor.\ngraph:   The Graph that contains the values, indices, and shape tensors.\nindices:   A 1-D Tensor containing the indices of the slices.\nname:   The name of this IndexedSlices.\nop:   The Operation that produces values as an output.\nshape:   Gets the tf.TensorShape representing the shape of the dense tensor.\nvalues:   A Tensor containing the values of the slices."}]}},
{"id": "tf.histogram_fixed_width_bins", "type": "function", "code": "tf.histogram_fixed_width_bins(values,value_range,nbins=100,dtype=tf.dtypes.int32,name=None)", "summary": "Bins the given values for use in a histogram.", "description": "", "code-info": {"name": "tf.histogram_fixed_width_bins", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "value_range", "is_optional": false, "type": "tensor", "description": " Shape [2] Tensor of same dtype as values.\nvalues &lt;= value_range[0] will be mapped to hist[0],\nvalues &gt;= value_range[1] will be mapped to hist[-1]."}, {"name": "nbins", "is_optional": true, "type": "int", "default_value": "100", "description": " Scalar int32 Tensor.  Number of histogram bins."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": " dtype for returned histogram."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this operation (defaults to 'histogram_fixed_width')."}]}},
{"id": "tf.histogram_fixed_width", "type": "function", "code": "tf.histogram_fixed_width(values,value_range,nbins=100,dtype=tf.dtypes.int32,name=None)", "summary": "Return histogram of values.", "description": "", "code-info": {"name": "tf.histogram_fixed_width", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": " Numeric Tensor."}, {"name": "value_range", "is_optional": false, "type": "tensor", "description": " Shape [2] Tensor of same dtype as values.\nvalues &lt;= value_range[0] will be mapped to hist[0],\nvalues &gt;= value_range[1] will be mapped to hist[-1]."}, {"name": "nbins", "is_optional": true, "type": "int", "default_value": "100", "description": " Scalar int32 Tensor.  Number of histogram bins."}, {"name": "dtype", "is_optional": true, "type": "others", "default_value": "tf.dtypes.int32", "description": " dtype for returned histogram."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": " A name for this operation (defaults to 'histogram_fixed_width')."}]}},
{"id": "tf.hessians", "type": "function", "code": "tf.hessians(ys,xs,gate_gradients=False,aggregation_method=None,name='hessians')", "summary": "Constructs the Hessian of sum of ys with respect to x in xs.", "description": "", "code-info": {"name": "tf.hessians", "parameters": [{"name": "ys", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be differentiated."}, {"name": "xs", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be used for differentiation.\nname: Optional name to use for grouping all the gradient ops together.\ndefaults to 'hessians'.\ncolocate_gradients_with_ops: See gradients() documentation for details."}, {"name": "gate_gradients", "is_optional": true, "type": "bool", "default_value": "False", "description": "See gradients() documentation for details."}, {"name": "aggregation_method", "is_optional": true, "type": "others", "default_value": "None", "description": "See gradients() documentation for details.\n\n\nReturns:\n\nA list of Hessian matrices of sum(ys) for each x in xs.\n\nRaises:\n\n\nLookupError: if one of the operations between xs and ys does not\nhave a registered gradient function.\n\n\n          "}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'hessians'", "description": "Optional name to use for grouping all the gradient ops together.\ndefaults to 'hessians'.\ncolocate_gradients_with_ops: See gradients() documentation for details.\ngate_gradients: See gradients() documentation for details.\naggregation_method: See gradients() documentation for details."}]}},
{"id": "tf.group", "type": "function", "code": "tf.group(*inputs,**kwargs)", "summary": "Create an op that groups multiple operations.", "description": "", "code-info": {"name": "tf.group", "parameters": [{"name": "*inputs", "is_optional": false, "type": "others", "description": ""}, {"name": "**kwargs", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tf.Graph", "type": "function", "code": "tf.Graph()", "summary": "A TensorFlow computation, represented as a dataflow graph.", "description": "", "code-info": {"name": "tf.Graph", "parameters": []}},
{"id": "tf.guarantee_const", "type": "function", "code": "tf.guarantee_const(input,name=None)", "summary": "Gives a guarantee to the TF runtime that the input tensor is a constant.", "description": "", "code-info": {"name": "tf.guarantee_const", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.gradients", "type": "function", "code": "tf.gradients(ys,xs,grad_ys=None,name='gradients',gate_gradients=False,aggregation_method=None,stop_gradients=None,unconnected_gradients=tf.UnconnectedGradients.NONE)", "summary": "Constructs symbolic derivatives of sum of ys w.r.t. x in xs.", "description": "", "code-info": {"name": "tf.gradients", "parameters": [{"name": "ys", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be differentiated."}, {"name": "xs", "is_optional": false, "type": "tensor", "description": "A Tensor or list of tensors to be used for differentiation."}, {"name": "grad_ys", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional. A Tensor or list of tensors the same size as\nys and holding the gradients computed for each y in ys."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'gradients'", "description": "Optional name to use for grouping all the gradient ops together.\ndefaults to 'gradients'."}, {"name": "gate_gradients", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, add a tuple around the gradients returned\nfor an operations.  This avoids some race conditions."}, {"name": "aggregation_method", "is_optional": true, "type": "others", "default_value": "None", "description": "Specifies the method used to combine gradient terms.\nAccepted values are constants defined in the class AggregationMethod."}, {"name": "stop_gradients", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional. A Tensor or list of tensors not to differentiate\nthrough."}, {"name": "unconnected_gradients", "is_optional": true, "type": "others", "default_value": "tf.UnconnectedGradients.NONE", "description": "Optional. Specifies the gradient value returned when\nthe given input tensors are unconnected. Accepted values are constants\ndefined in the class tf.UnconnectedGradients and the default value is\nnone."}]}},
{"id": "tf.GradientTape", "type": "function", "code": "tf.GradientTape(persistent=False,watch_accessed_variables=True)", "summary": "Record operations for automatic differentiation.", "description": "", "code-info": {"name": "tf.GradientTape", "parameters": [{"name": "persistent", "is_optional": true, "type": "bool", "default_value": "False", "description": "Boolean controlling whether a persistent gradient tape\nis created. False by default, which means at most one call can\nbe made to the gradient() method on this object."}, {"name": "watch_accessed_variables", "is_optional": true, "type": "bool", "default_value": "True", "description": "Boolean controlling whether the tape will\nautomatically watch any (trainable) variables accessed while the tape\nis active. Defaults to True meaning gradients can be requested from any\nresult computed in the tape derived from reading a trainable Variable.\nIf False users must explicitly watch any Variables they want to\nrequest gradients from."}]}},
{"id": "tf.grad_pass_through", "type": "function", "code": "tf.grad_pass_through(f)", "summary": "Creates a grad-pass-through op with the forward behavior provided in f.", "description": "", "code-info": {"name": "tf.grad_pass_through", "parameters": [{"name": "f", "is_optional": false, "type": "tensor", "description": "function f(*x) that returns a Tensor or nested structure of Tensor\noutputs."}]}},
{"id": "tf.get_static_value", "type": "function", "code": "tf.get_static_value(tensor,partial=False)", "summary": "Returns the constant value of the given tensor, if efficiently calculable.", "description": "", "code-info": {"name": "tf.get_static_value", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": "The Tensor to be evaluated."}, {"name": "partial", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, the returned numpy array is allowed to have partially\nevaluated values. Values that can't be evaluated will be None."}]}},
{"id": "tf.get_logger", "type": "function", "code": "tf.get_logger()", "summary": "Return TF logger instance.", "description": "", "code-info": {"name": "tf.get_logger", "parameters": []}},
{"id": "tf.dynamic_partition", "type": "function", "code": "tf.dynamic_partition(data,partitions,num_partitions,name=None)", "summary": "Partitions data into num_partitions tensors using indices from partitions.", "description": "", "code-info": {"name": "tf.dynamic_partition", "parameters": [{"name": "data", "is_optional": false, "type": "tensor", "description": "A Tensor."}, {"name": "partitions", "is_optional": false, "type": "tensor", "description": "A Tensor of type int32.\nAny shape.  Indices in the range [0, num_partitions)."}, {"name": "num_partitions", "is_optional": false, "type": "others", "description": "An int that is &gt;= 1.\nThe number of partitions to output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.device", "type": "function", "code": "tf.device(device_name)", "summary": "Specifies the device for ops created/executed in this context.", "description": "", "code-info": {"name": "tf.device", "parameters": [{"name": "device_name", "is_optional": false, "type": "string", "description": "The device name to use in the context."}]}},
{"id": "tf.custom_gradient", "type": "function", "code": "tf.custom_gradient(f=None)", "summary": "Decorator to define a function with a custom gradient.", "description": "", "code-info": {"name": "tf.custom_gradient", "parameters": [{"name": "f", "is_optional": true, "type": "others", "default_value": "None", "description": "function f(*x) that returns a tuple (y, grad_fn) where:"}]}},
{"id": "tf.DeviceSpec", "type": "class", "code": "tf.DeviceSpec(job=None,replica=None,task=None,device_type=None,device_index=None)", "summary": "Represents a (possibly partial) specification for a TensorFlow device.", "description": "", "code-info": {"name": "tf.DeviceSpec", "parameters": [{"name": "job", "is_optional": true, "type": "string", "default_value": "None", "description": "string.  Optional job name."}, {"name": "replica", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional replica index."}, {"name": "task", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional task index."}, {"name": "device_type", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional device type string (e.g. \"CPU\" or \"GPU\")"}, {"name": "device_index", "is_optional": true, "type": "others", "default_value": "None", "description": "int.  Optional device index.  If left\nunspecified, device represents 'any' device_index."}]}},
{"id": "tf.CriticalSection", "type": "function", "code": "tf.CriticalSection(name=None,shared_name=None,critical_section_def=None,import_scope=None)", "summary": "Critical section.", "description": "", "code-info": {"name": "tf.CriticalSection", "parameters": [{"name": "name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "shared_name", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "critical_section_def", "is_optional": true, "type": "others", "default_value": "None", "description": ""}, {"name": "import_scope", "is_optional": true, "type": "others", "default_value": "None", "description": ""}]}},
{"id": "tf.dynamic_stitch", "type": "function", "code": "tf.dynamic_stitch(indices,data,name=None)", "summary": "Interleave the values from the data tensors into a single tensor.", "description": "", "code-info": {"name": "tf.dynamic_stitch", "parameters": [{"name": "indices", "is_optional": false, "type": "tensor", "description": "A list of at least 1 Tensor objects with type int32."}, {"name": "data", "is_optional": false, "type": "tensor", "description": "A list with the same length as indices of Tensor objects with the same type."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.convert_to_tensor", "type": "function", "code": "tf.convert_to_tensor(value,dtype=None,dtype_hint=None,name=None)", "summary": "Converts the given value to a Tensor.", "description": "", "code-info": {"name": "tf.convert_to_tensor", "parameters": [{"name": "value", "is_optional": false, "type": "tensor", "description": "An object whose type has a registered Tensor conversion function."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional element type for the returned tensor. If missing, the type\nis inferred from the type of value."}, {"name": "dtype_hint", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional element type for the returned tensor, used when dtype\nis None. In some cases, a caller may not have a dtype in mind when\nconverting to a tensor, so dtype_hint can be used as a soft preference.\nIf the conversion to dtype_hint is not possible, this argument has no\neffect."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name to use if a new Tensor is created."}]}},
{"id": "tf.edit_distance", "type": "function", "code": "tf.edit_distance(hypothesis,truth,normalize=True,name='edit_distance')", "summary": "Computes the Levenshtein distance between sequences.", "description": "", "code-info": {"name": "tf.edit_distance", "parameters": [{"name": "hypothesis", "is_optional": false, "type": "tensor", "description": "A SparseTensor containing hypothesis sequences."}, {"name": "truth", "is_optional": false, "type": "tensor", "description": "A SparseTensor containing truth sequences."}, {"name": "normalize", "is_optional": true, "type": "bool", "default_value": "True", "description": "A bool. If True, normalizes the Levenshtein distance by\nlength of truth."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'edit_distance'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.constant_initializer", "type": "function", "code": "tf.constant_initializer(value=0)", "summary": "Initializer that generates tensors with constant values.\n\nInherits From: Initializer", "description": "", "code-info": {"name": "tf.constant_initializer", "parameters": [{"name": "value", "is_optional": true, "type": "int", "default_value": "0", "description": "A Python scalar, list or tuple of values, or a N-dimensional numpy\narray. All elements of the initialized variable will be set to the\ncorresponding value in the value argument."}]}},
{"id": "tf.constant", "type": "function", "code": "tf.constant(value,dtype=None,shape=None,name='Const')", "summary": "Creates a constant tensor from a tensor-like object.", "description": "", "code-info": {"name": "tf.constant", "parameters": [{"name": "value", "is_optional": false, "type": "others", "description": "A constant value (or list) of output type dtype."}, {"name": "dtype", "is_optional": true, "type": "tensor", "default_value": "None", "description": "The type of the elements of the resulting tensor."}, {"name": "shape", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional dimensions of resulting tensor."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'Const'", "description": "Optional name for the tensor."}]}},
{"id": "tf.cond", "type": "function", "code": "tf.cond(pred,true_fn=None,false_fn=None,name=None)", "summary": "Return true_fn() if the predicate pred is true else false_fn().", "description": "", "code-info": {"name": "tf.cond", "parameters": [{"name": "pred", "is_optional": false, "type": "float", "description": "A scalar determining whether to return the result of true_fn or\nfalse_fn."}, {"name": "true_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "The callable to be performed if pred is true."}, {"name": "false_fn", "is_optional": true, "type": "others", "default_value": "None", "description": "The callable to be performed if pred is false."}, {"name": "name", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional name prefix for the returned tensors."}]}},
{"id": "tf.concat", "type": "function", "code": "tf.concat(values,axis,name='concat')", "summary": "Concatenates tensors along one dimension.", "description": "", "code-info": {"name": "tf.concat", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "A list of Tensor objects or a single Tensor."}, {"name": "axis", "is_optional": false, "type": "tensor", "description": "0-D int32 Tensor.  Dimension along which to concatenate. Must be\nin the range [-rank(values), rank(values)). As in Python, indexing for\naxis is 0-based. Positive axis in the rage of [0, rank(values)) refers\nto axis-th dimension. And negative axis refers to axis +\nrank(values)-th dimension."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'concat'", "description": "A name for the operation (optional)."}]}},
{"id": "tf.clip_by_value", "type": "function", "code": "tf.clip_by_value(t,clip_value_min,clip_value_max,name=None)", "summary": "Clips tensor values to a specified min and max.", "description": "", "code-info": {"name": "tf.clip_by_value", "parameters": [{"name": "t", "is_optional": false, "type": "tensor", "description": "A Tensor or IndexedSlices."}, {"name": "clip_value_min", "is_optional": false, "type": "tensor", "description": "A 0-D (scalar) Tensor, or a Tensor with the same shape\nas t. The minimum value to clip by."}, {"name": "clip_value_max", "is_optional": false, "type": "tensor", "description": "A 0-D (scalar) Tensor, or a Tensor with the same shape\nas t. The maximum value to clip by."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.clip_by_norm", "type": "function", "code": "tf.clip_by_norm(t,clip_norm,axes=None,name=None)", "summary": "Clips tensor values to a maximum L2-norm.", "description": "", "code-info": {"name": "tf.clip_by_norm", "parameters": [{"name": "t", "is_optional": false, "type": "tensor", "description": "A Tensor or IndexedSlices."}, {"name": "clip_norm", "is_optional": false, "type": "tensor", "description": "A 0-D (scalar) Tensor &gt; 0. A maximum clipping value."}, {"name": "axes", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 1-D (vector) Tensor of type int32 containing the dimensions\nto use for computing the L2-norm. If None (the default), uses all\ndimensions."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.control_dependencies", "type": "function", "code": "tf.control_dependencies(control_inputs)", "summary": "Wrapper for Graph.control_dependencies() using the default graph.", "description": "", "code-info": {"name": "tf.control_dependencies", "parameters": [{"name": "control_inputs", "is_optional": false, "type": "tensor", "description": "A list of Operation or Tensor objects which must be\nexecuted or computed before running the operations defined in the context.\nCan also be None to clear the control dependencies. If eager execution\nis enabled, any callable object in the control_inputs list will be\ncalled."}]}},
{"id": "tf.clip_by_global_norm", "type": "function", "code": "tf.clip_by_global_norm(t_list,clip_norm,use_norm=None,name=None)", "summary": "Clips values of multiple tensors by the ratio of the sum of their norms.", "description": "", "code-info": {"name": "tf.clip_by_global_norm", "parameters": [{"name": "t_list", "is_optional": false, "type": "tensor", "description": "A tuple or list of mixed Tensors, IndexedSlices, or None."}, {"name": "clip_norm", "is_optional": false, "type": "tensor", "description": "A 0-D (scalar) Tensor &gt; 0. The clipping ratio."}, {"name": "use_norm", "is_optional": true, "type": "tensor", "default_value": "None", "description": "A 0-D (scalar) Tensor of type float (optional). The global\nnorm to use. If not provided, global_norm() is used to compute the norm."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.cast", "type": "function", "code": "tf.cast(x,dtype,name=None)", "summary": "Casts a tensor to a new type.", "description": "", "code-info": {"name": "tf.cast", "parameters": [{"name": "x", "is_optional": false, "type": "tensor", "description": "A Tensor or SparseTensor or IndexedSlices of numeric type. It could\nbe uint8, uint16, uint32, uint64, int8, int16, int32,\nint64, float16, float32, float64, complex64, complex128,\nbfloat16."}, {"name": "dtype", "is_optional": false, "type": "others", "description": "The destination type. The list of supported dtypes is the same as\nx."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.case", "type": "function", "code": "tf.case(pred_fn_pairs,default=None,exclusive=False,strict=False,name='case')", "summary": "Create a case operation.", "description": "", "code-info": {"name": "tf.case", "parameters": [{"name": "pred_fn_pairs", "is_optional": false, "type": "tensor", "description": "List of pairs of a boolean scalar tensor and a callable which\nreturns a list of tensors."}, {"name": "default", "is_optional": true, "type": "tensor", "default_value": "None", "description": "Optional callable that returns a list of tensors."}, {"name": "exclusive", "is_optional": true, "type": "bool", "default_value": "False", "description": "True iff at most one predicate is allowed to evaluate to True."}, {"name": "strict", "is_optional": true, "type": "bool", "default_value": "False", "description": "A boolean that enables/disables 'strict' mode; see above."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'case'", "description": "A name for this operation (optional)."}]}},
{"id": "tf.broadcast_to", "type": "function", "code": "tf.broadcast_to(input,shape,name=None)", "summary": "Broadcast an array for a compatible shape.", "description": "", "code-info": {"name": "tf.broadcast_to", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. A Tensor to broadcast."}, {"name": "shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64.\nAn 1-D int Tensor. The shape of the desired output."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.broadcast_static_shape", "type": "function", "code": "tf.broadcast_static_shape(shape_x,shape_y)", "summary": "Computes the shape of a broadcast given known shapes.", "description": "", "code-info": {"name": "tf.broadcast_static_shape", "parameters": [{"name": "shape_x", "is_optional": false, "type": "tensor", "description": "A TensorShape"}, {"name": "shape_y", "is_optional": false, "type": "tensor", "description": "A TensorShape"}]}},
{"id": "tf.broadcast_dynamic_shape", "type": "function", "code": "tf.broadcast_dynamic_shape(shape_x,shape_y)", "summary": "Computes the shape of a broadcast given symbolic shapes.", "description": "", "code-info": {"name": "tf.broadcast_dynamic_shape", "parameters": [{"name": "shape_x", "is_optional": false, "type": "tensor", "description": "A rank 1 integer Tensor, representing the shape of x."}, {"name": "shape_y", "is_optional": false, "type": "tensor", "description": "A rank 1 integer Tensor, representing the shape of y."}]}},
{"id": "tf.boolean_mask", "type": "function", "code": "tf.boolean_mask(tensor,mask,axis=None,name='boolean_mask')", "summary": "Apply boolean mask to tensor.", "description": "", "code-info": {"name": "tf.boolean_mask", "parameters": [{"name": "tensor", "is_optional": false, "type": "tensor", "description": " N-D tensor."}, {"name": "mask", "is_optional": false, "type": "tensor", "description": " K-D boolean tensor, K &lt;= N and K must be known statically."}, {"name": "axis", "is_optional": true, "type": "tensor", "default_value": "None", "description": " A 0-D int Tensor representing the axis in tensor to mask from. By\ndefault, axis is 0 which will mask from the first dimension. Otherwise K +\naxis &lt;= N."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "'boolean_mask'", "description": " A name for this operation (optional)."}]}},
{"id": "tf.bitcast", "type": "function", "code": "tf.bitcast(input,type,name=None)", "summary": "Bitcasts a tensor from one type to another without copying data.", "description": "", "code-info": {"name": "tf.bitcast", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: bfloat16, half, float32, float64, int64, int32, uint8, uint16, uint32, uint64, int8, int16, complex64, complex128, qint8, quint8, qint16, quint16, qint32."}, {"name": "type", "is_optional": false, "type": "float", "description": "A tf.DType from: tf.bfloat16, tf.half, tf.float32, tf.float64, tf.int64, tf.int32, tf.uint8, tf.uint16, tf.uint32, tf.uint64, tf.int8, tf.int16, tf.complex64, tf.complex128, tf.qint8, tf.quint8, tf.qint16, tf.quint16, tf.qint32."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.batch_to_space", "type": "function", "code": "tf.batch_to_space(input,block_shape,crops,name=None)", "summary": "BatchToSpace for N-D tensors of type T.", "description": "", "code-info": {"name": "tf.batch_to_space", "parameters": [{"name": "input", "is_optional": false, "type": "tensor", "description": "A Tensor. N-D with shape input_shape = [batch] + spatial_shape +\nremaining_shape, where spatial_shape has M dimensions."}, {"name": "block_shape", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32,\nint64. 1-D with shape [M], all values must be &gt;= 1. For backwards\ncompatibility with TF 1.0, this parameter may be an int, in which case it\nis converted to numpy.array([block_shape, block_shape],\ndtype=numpy.int64)."}, {"name": "crops", "is_optional": false, "type": "tensor", "description": "A Tensor. Must be one of the following types: int32, int64. 2-D\nwith shape [M, 2], all values must be &gt;= 0. crops[i] = [crop_start,\ncrop_end] specifies the amount to crop from input dimension i + 1,\nwhich corresponds to spatial dimension i.  It is required that\ncrop_start[i] + crop_end[i] &lt;= block_shape[i] * input_shape[i + 1].\nThis operation is equivalent to the following steps:\n\nReshape input to reshaped of shape: [block_shape[0], ...,\nblock_shape[M-1], batch / prod(block_shape), input_shape[1], ...,\ninput_shape[N-1]]  \nPermute dimensions of reshaped to produce permuted of shape \n[batch / prod(block_shape),  input_shape[1], block_shape[0], ..., \ninput_shape[M], block_shape[M-1], input_shape[M+1],\n..., input_shape[N-1]]  \nReshape permuted to produce reshaped_permuted of shape \n[batch / prod(block_shape), input_shape[1] * block_shape[0], ..., \ninput_shape[M] * block_shape[M-1], input_shape[M+1], ..., \ninput_shape[N-1]]  \nCrop the start and end of dimensions [1, ..., M] of \nreshaped_permuted according to crops to produce the output \nof shape: \n[batch / prod(block_shape),  input_shape[1] *\nblock_shape[0] - crops[0,0] - crops[0,1], ..., input_shape[M] *\nblock_shape[M-1] - crops[M-1,0] - crops[M-1,1],  input_shape[M+1],\n..., input_shape[N-1]]\nSome examples:  (1) For the following input of shape [4, 1, 1, 1],\nblock_shape = [2, 2], and crops = [[0, 0], [0, 0]]:  [[[[1]]],\n[[[2]]], [[[3]]], [[[4]]]]\nThe output tensor has shape [1, 2, 2, 1] and value:  x = [[[[1],\n[2]], [[3], [4]]]]  (2) For the following input of shape [4, 1, 1,\n3],\nblock_shape = [2, 2], and crops = [[0, 0], [0, 0]]:  [[[1, 2,\n3]], [[4, 5, 6]], [[7, 8, 9]], [[10, 11, 12]]]\nThe output tensor has shape [1, 2, 2, 3] and value:  x = [[[[1, 2,\n3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]]  (3) For the following\ninput of shape [4, 2, 2, 1],\nblock_shape = [2, 2], and crops = [[0, 0], [0, 0]]:  x =\n[[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]],\n[[13], [15]]], [[[6], [8]], [[14], [16]]]]\nThe output tensor has shape [1, 4, 4, 1] and value:  x = [[[1], [2],\n[3],  [4]], [[5],   [6],  [7],  [8]], [[9],  [10], [11],  [12]], [[13],\n[14], [15],  [16]]]  (4) For the following input of shape [8, 1, 3,\n1],\nblock_shape = [2, 2], and crops = [[0, 0], [2, 0]]:  x =\n[[[[0], [1], [3]]], [[[0], [9], [11]]], [[[0], [2], [4]]], [[[0],\n[10], [12]]], [[[0], [5], [7]]], [[[0], [13], [15]]], [[[0], [6],\n[8]]], [[[0], [14], [16]]]]\nThe output tensor has shape [2, 2, 4, 1] and value:  x = [[[[1],\n[2],  [3],  [4]], [[5],   [6],  [7],  [8]]], [[[9],  [10], [11],  [12]],\n[[13], [14], [15],  [16]]]]\n"}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "A name for the operation (optional)."}]}},
{"id": "tf.argsort", "type": "function", "code": "tf.argsort(values,axis=-1,direction='ASCENDING',stable=False,name=None)", "summary": "Returns the indices of a tensor that give its sorted order along an axis.", "description": "", "code-info": {"name": "tf.argsort", "parameters": [{"name": "values", "is_optional": false, "type": "tensor", "description": "1-D or higher numeric Tensor."}, {"name": "axis", "is_optional": true, "type": "others", "default_value": "-1", "description": "The axis along which to sort. The default is -1, which sorts the last\naxis."}, {"name": "direction", "is_optional": true, "type": "string", "default_value": "'ASCENDING'", "description": "The direction in which to sort the values ('ASCENDING' or\n'DESCENDING')."}, {"name": "stable", "is_optional": true, "type": "bool", "default_value": "False", "description": "If True, equal elements in the original tensor will not be\nre-ordered in the returned order. Unstable sort is not yet implemented,\nbut will eventually be the default for performance reasons. If you require\na stable order, pass stable=True for forwards compatibility."}, {"name": "name", "is_optional": true, "type": "string", "default_value": "None", "description": "Optional name for the operation."}]}}]
