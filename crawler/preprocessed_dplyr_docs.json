[{"id": "explain", "code": "explain(x, ...)", "summary": "     This is a generic function which gives more details about an object than print(), and is more focused on human readable output than str()", "code-info": {"name": "explain", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " An object to explain"}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "ident", "code": "ident(...)", "summary": "     ident() takes unquoted strings and flags them as identifiers", "code-info": {"name": "ident", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " A character vector, or name-value pairs"}]}},
{"id": "copy_to", "code": "copy_to(dest, df, name = deparse(substitute(df)", "summary": "     This function uploads a local data frame into a remote data source, creating the table definition as needed", "code-info": {"name": "copy_to", "parameters": [{"name": "dest", "is_optional": false, "type": "others", "description": " remote data source"}, {"name": " df", "is_optional": false, "type": "others", "description": ""}, {"name": " name ", "is_optional": true, "type": "others", "default_value": " depars", "description": ""}]}},
{"id": "with_groups", "code": "with_groups(.data, .groups, .f, ...)", "summary": "      This is an experimental new function that allows you to modify the grouping variables for a single operation", "code-info": {"name": "with_groups", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame"}, {"name": " .groups", "is_optional": false, "type": "others", "description": ""}, {"name": " .f", "is_optional": false, "type": "others", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "group_trim", "code": "group_trim(.tbl, .drop = group_by_drop_default(.tbl)", "summary": "       Drop unused levels of all factors that are used as grouping variables, then recalculates the grouping structure", "code-info": {"name": "group_trim", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A grouped data frame"}, {"name": " .drop ", "is_optional": true, "type": "others", "default_value": " group_by_drop_defaul", "description": ""}]}},
{"id": "group_split", "code": "group_split(.tbl, ..., .keep = TRUE)", "summary": "       group_split() works like base::split() but it uses the grouping structure from group_by() and therefore is subject to the data mask it does not name the elements of the list based on the grouping as this typically loses information and is confusing", "code-info": {"name": "group_split", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl"}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .keep ", "is_optional": true, "type": "others", "default_value": " TRUE", "description": ""}]}},
{"id": "sql", "code": "sql(...)", "summary": "     These functions are critical when writing functions that translate R functions to sql functions", "code-info": {"name": "sql", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " Character vectors that will be combined into a single SQL expression."}]}},
{"id": "group_map", "code": "group_map(.data, .f, ..., .keep = FALSE)", "summary": "      group_map(), group_modify() and group_walk() are purrr-style functions that can be used to iterate on grouped tibbles", "code-info": {"name": "group_map", "parameters": [{"name": ".data", "is_optional": false, "type": "others", "description": " A grouped tibble"}, {"name": " .f", "is_optional": false, "type": "others", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .keep ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "all_equal", "code": "all_equal(   target,   current,   ignore_col_order = TRUE,   ignore_row_order = TRUE,   convert = FALSE,   ... )", "summary": "       all_equal() allows you to compare data frames, optionally ignoring row and column names", "code-info": {"name": "all_equal", "parameters": [{"name": "   target", "is_optional": false, "type": "others", "description": ""}, {"name": "   current", "is_optional": false, "type": "others", "description": ""}, {"name": "   ignore_col_order ", "is_optional": true, "type": "others", "default_value": " TRUE", "description": ""}, {"name": "   ignore_row_order ", "is_optional": true, "type": "others", "default_value": " TRUE", "description": ""}, {"name": "   convert ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": "   ... ", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "tbl", "code": "tbl(src, ...)", "summary": "     This is a generic method that dispatches based on the first argument", "code-info": {"name": "tbl", "parameters": [{"name": "src", "is_optional": false, "type": "others", "description": " A data source"}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "compute", "code": "compute(x, name = random_table_name()", "summary": "     compute() stores results in a remote temporary table", "code-info": {"name": "compute", "parameters": [{"name": "x", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " name ", "is_optional": true, "type": "others", "default_value": " random_table_nam", "description": ""}]}},
{"id": "auto_copy", "code": "auto_copy(x, y, copy = FALSE, ...)", "summary": "     Copy tables to same source, if necessary     ", "code-info": {"name": "auto_copy", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": " y", "is_optional": false, "type": "others", "description": ""}, {"name": " copy ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "storms", "code": "storms", "summary": "     This data is a subset of the NOAA Atlantic hurricane database best track data, http://www.nhc.noaa.gov/data/#hurdat", "code-info": {"name": "storms", "parameters": []}},
{"id": "starwars", "code": "starwars", "summary": "     This data comes from SWAPI, the Star Wars API, http://swapi.dev/     ", "code-info": {"name": "starwars", "parameters": []}},
{"id": "band_members", "code": "band_members", "summary": "     These data sets describe band members of the Beatles and Rolling Stones", "code-info": {"name": "band_members", "parameters": []}},
{"id": "vars", "code": "vars(...)", "summary": "     vars() was only needed for the scoped verbs, which have been superseded by the use of across() in an existing verb", "code-info": {"name": "vars", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " &lt;tidy-select&gt; Variables to include/exclude in mutate/summarise. You can use same specifications as in select(. If missing, defaults to all non-grouping variables."}]}},
{"id": "all_vars", "code": "all_vars(expr)", "summary": "      all_vars() and any_vars() were only needed for the scoped verbs, which have been superseded by the use of across() in an existing verb", "code-info": {"name": "all_vars", "parameters": [{"name": "expr", "is_optional": false, "type": "others", "description": " &lt;data-masking&gt; An expression that returns a logical vector, using . to refer to the \"current\" variable."}]}},
{"id": "summarise_all", "code": "summarise_all(.tbl, .funs, ...)", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "summarise_all", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl object."}, {"name": " .funs", "is_optional": false, "type": "others", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "mutate_all", "code": "mutate_all(.tbl, .funs, ...)", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "mutate_all", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl object."}, {"name": " .funs", "is_optional": false, "type": "others", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "group_by_all", "code": "group_by_all(   .tbl,   .funs = list()", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "group_by_all", "parameters": [{"name": "   .tbl", "is_optional": false, "type": "others", "description": ""}, {"name": "   .funs ", "is_optional": true, "type": "others", "default_value": " lis", "description": ""}]}},
{"id": "top_n", "code": "top_n(x, n, wt)", "summary": "       top_n() has been superseded in favour of slice_min()/slice_max()", "code-info": {"name": "top_n", "parameters": [{"name": "x", "is_optional": false, "type": "dataframe", "description": " A data frame."}, {"name": " n", "is_optional": false, "type": "others", "description": ""}, {"name": " wt", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "filter_all", "code": "filter_all(.tbl, .vars_predicate, .preserve = FALSE)", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "filter_all", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl object."}, {"name": " .vars_predicate", "is_optional": false, "type": "others", "description": ""}, {"name": " .preserve ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "distinct_all", "code": "distinct_all(.tbl, .funs = list()", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "distinct_all", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl object."}, {"name": " .funs ", "is_optional": true, "type": "others", "default_value": " lis", "description": ""}]}},
{"id": "arrange_all", "code": "arrange_all(.tbl, .funs = list()", "summary": "      Scoped verbs (_if, _at, _all) have been superseded by the use of across() in an existing verb", "code-info": {"name": "arrange_all", "parameters": [{"name": ".tbl", "is_optional": false, "type": "others", "description": " A tbl object."}, {"name": " .funs ", "is_optional": true, "type": "others", "default_value": " lis", "description": ""}]}},
{"id": "recode", "code": "recode(.x, ..., .default = NULL, .missing = NULL)", "summary": "     This is a vectorised version of switch(): you can replace numeric values based on their position or their name, and character or factor values only by their name", "code-info": {"name": "recode", "parameters": [{"name": ".x", "is_optional": false, "type": "others", "description": " A vector to modify"}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .default ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " .missing ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "ranking", "code": "ranking(x)", "summary": "     Six variations on ranking functions, mimicking the ranking functions described in SQL2003", "code-info": {"name": "ranking", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " a vector of values to rank. Missing values are left as is. If you want to treat them as the smallest or largest values, replace with Inf or -Inf before ranking."}]}},
{"id": "sample_n", "code": "sample_n(tbl, size, replace = FALSE, weight = NULL, .env = NULL, ...)", "summary": "       sample_n() and sample_frac() have been superseded in favour of slice_sample()", "code-info": {"name": "sample_n", "parameters": [{"name": "tbl", "is_optional": false, "type": "others", "description": " A data.frame."}, {"name": " size", "is_optional": false, "type": "others", "description": ""}, {"name": " replace ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " weight ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " .env ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "nth", "code": "nth(x, n, order_by = NULL, default = default_missing(x)", "summary": "     These are straightforward wrappers around [[", "code-info": {"name": "nth", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " A vector"}, {"name": " n", "is_optional": false, "type": "others", "description": ""}, {"name": " order_by ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " default ", "is_optional": true, "type": "others", "default_value": " default_missin", "description": ""}]}},
{"id": "near", "code": "near(x, y, tol = .Machine$double.eps^0.5)", "summary": "     This is a safe way of comparing if two vectors of floating point numbers are (pairwise) equal", "code-info": {"name": "near", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": " y", "is_optional": false, "type": "others", "description": ""}, {"name": " tol ", "is_optional": true, "type": "others", "default_value": " .Machine$double.eps^0.5", "description": ""}]}},
{"id": "na_if", "code": "na_if(x, y)", "summary": "     This is a translation of the SQL command NULLIF", "code-info": {"name": "na_if", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " Vector to modify"}, {"name": " y", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "n_distinct", "code": "n_distinct(..., na.rm = FALSE)", "summary": "     This is a faster and more concise equivalent of length(unique(x))     ", "code-info": {"name": "n_distinct", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " vectors of values"}, {"name": " na.rm ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "context", "code": "context()", "summary": "     These functions return information about the \"current\" group or \"current\" variable, so only work inside specific contexts like summarise() and mutate() n() gives the current group size", "code-info": {"name": "context", "parameters": []}},
{"id": "order_by", "code": "order_by(order_by, call)", "summary": "     This function makes it possible to control the ordering of window functions in R that don't have a specific ordering parameter", "code-info": {"name": "order_by", "parameters": [{"name": "order_by", "is_optional": false, "type": "others", "description": " a vector to order_by"}, {"name": " call", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "lead-lag", "code": "lead-lag(x, n = 1L, default = NA, order_by = NULL, ...)", "summary": "     Find the \"previous\" (lag()) or \"next\" (lead()) values in a vector", "code-info": {"name": "lead-lag", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " Vector of values"}, {"name": " n ", "is_optional": true, "type": "others", "default_value": " 1L", "description": ""}, {"name": " default ", "is_optional": true, "type": "others", "default_value": " NA", "description": ""}, {"name": " order_by ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "if_else", "code": "if_else(condition, true, false, missing = NULL)", "summary": "     Compared to the base ifelse(), this function is more strict", "code-info": {"name": "if_else", "parameters": [{"name": "condition", "is_optional": false, "type": "others", "description": " Logical vector"}, {"name": " true", "is_optional": false, "type": "others", "description": ""}, {"name": " false", "is_optional": false, "type": "others", "description": ""}, {"name": " missing ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "desc", "code": "desc(x)", "summary": "     Transform a vector into a format that will be sorted in descending order", "code-info": {"name": "desc", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " vector to transform"}]}},
{"id": "cumall", "code": "cumall(x)", "summary": "     dplyr provides cumall(), cumany(), and cummean() to complete R's set of cumulative functions", "code-info": {"name": "cumall", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " For cumall( and cumany(, a logical vector; for cummean( an integer or numeric vector."}]}},
{"id": "case_when", "code": "case_when(...)", "summary": "     This function allows you to vectorise multiple if_else() statements", "code-info": {"name": "case_when", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " &lt;dynamic-dots&gt; A sequence of two-sided formulas. The left hand side (LHS determines which values match this case. The right hand side (RHS provides the replacement value. The LHS must evaluate to a logical vector. The RHS does not need to be logical, but all RHSs must evaluate to the same type of vector. Both LHS and RHS may have the same length of either 1 or n. The value of n must be consistent across all cases. The case of n == 0 is treated as a variant of n != 1. NULL inputs are ignored."}]}},
{"id": "between", "code": "between(x, left, right)", "summary": "     This is a shortcut for x &gt;= left &amp; x &lt;= right, implemented efficiently in C++ for local values, and translated to the appropriate SQL for remote tables", "code-info": {"name": "between", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": " A numeric vector of values"}, {"name": " left", "is_optional": false, "type": "others", "description": ""}, {"name": " right", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "across", "code": "across(.cols = everything()", "summary": "     across() makes it easy to apply the same transformation to multiple columns, allowing you to use select() semantics inside in summarise() and mutate()", "code-info": {"name": "across", "parameters": [{"name": ".cols ", "is_optional": true, "type": "others", "default_value": " everythin", "description": ""}]}},
{"id": "rowwise", "code": "rowwise(data, ...)", "summary": "     rowwise() allows you to compute on a data frame a row-at-a-time", "code-info": {"name": "rowwise", "parameters": [{"name": "data", "is_optional": false, "type": "others", "description": " Input data frame."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "coalesce", "code": "coalesce(...)", "summary": "     Given a set of vectors, coalesce() finds the first non-missing value at each position", "code-info": {"name": "coalesce", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " &lt;dynamic-dots&gt; Vectors. Inputs should be recyclable (either be length 1 or same length as the longest vector and coercible to a common type."}]}},
{"id": "group_cols", "code": "group_cols(vars = NULL, data = NULL)", "summary": "     This selection helpers matches grouping variables", "code-info": {"name": "group_cols", "parameters": [{"name": "vars ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " data ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "group_by", "code": "group_by(.data, ..., .add = FALSE, .drop = group_by_drop_default(.data)", "summary": "     Most data operations are done on groups defined by variables", "code-info": {"name": "group_by", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .add ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " .drop ", "is_optional": true, "type": "others", "default_value": " group_by_drop_defaul", "description": ""}]}},
{"id": "filter-joins", "code": "filter-joins(x, y, by = NULL, copy = FALSE, ...)", "summary": "     Filtering joins filter rows from x based on the presence or absence of matches in y: semi_join() return all rows from x with a match in y", "code-info": {"name": "filter-joins", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": " y", "is_optional": false, "type": "others", "description": ""}, {"name": " by ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " copy ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "nest_join", "code": "nest_join(x, y, by = NULL, copy = FALSE, keep = FALSE, name = NULL, ...)", "summary": "     nest_join() returns all rows and columns in x with a new nested-df column that contains all matches from y", "code-info": {"name": "nest_join", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": " y", "is_optional": false, "type": "others", "description": ""}, {"name": " by ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " copy ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " keep ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " name ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "mutate-joins", "code": "mutate-joins(x, y, by = NULL, copy = FALSE, suffix = c(\".x\", \".y\")", "summary": "     The mutating joins add columns from y to x, matching rows based on the keys: inner_join(): includes all rows in x and y", "code-info": {"name": "mutate-joins", "parameters": [{"name": "x", "is_optional": false, "type": "others", "description": ""}, {"name": " y", "is_optional": false, "type": "others", "description": ""}, {"name": " by ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " copy ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": " suffix ", "is_optional": true, "type": "others", "default_value": " ", "description": ""}]}},
{"id": "bind", "code": "bind(..., .id = NULL)", "summary": "     This is an efficient implementation of the common pattern of do.call(rbind, dfs) or do.call(cbind, dfs) for binding many data frames into one", "code-info": {"name": "bind", "parameters": [{"name": "...", "is_optional": false, "type": "others", "description": " Data frames to combine. Each argument can either be a data frame, a list that could be a data frame, or a list of data frames. When row-binding, columns are matched by name, and any missing columns will be filled with NA. When column-binding, rows are matched by position, so all data frames must have the same number of rows. To match by value, not position, see mutate-joins."}, {"name": " .id ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "slice", "code": "slice(.data, ..., .preserve = FALSE)", "summary": "     slice() lets you index rows by their (integer) locations", "code-info": {"name": "slice", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .preserve ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "select", "code": "select(.data, ...)", "summary": "     Select (and optionally rename) variables in a data frame, using a concise mini-language that makes it easy to refer to variables based on their name (e.g", "code-info": {"name": "select", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "summarise", "code": "summarise(.data, ..., .groups = NULL)", "summary": "     summarise() creates a new data frame", "code-info": {"name": "summarise", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .groups ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "rename", "code": "rename(.data, ...)", "summary": "     rename() changes the names of individual variables using new_name = old_name syntax; rename_with() renames columns using a function", "code-info": {"name": "rename", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "relocate", "code": "relocate(.data, ..., .before = NULL, .after = NULL)", "summary": "     Use relocate() to change column positions, using the same syntax as select() to make it easy to move blocks of columns at once", "code-info": {"name": "relocate", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .before ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " .after ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}]}},
{"id": "pull", "code": "pull(.data, var = -1, name = NULL, ...)", "summary": "     pull() is similar to $", "code-info": {"name": "pull", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " var ", "is_optional": true, "type": "others", "default_value": " -1", "description": ""}, {"name": " name ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "mutate", "code": "mutate(.data, ...)", "summary": "     mutate() adds new variables and preserves existing ones; transmute() adds new variables and drops existing ones", "code-info": {"name": "mutate", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}]}},
{"id": "filter", "code": "filter(.data, ..., .preserve = FALSE)", "summary": "     The filter() function is used to subset a data frame, retaining all rows that satisfy your conditions", "code-info": {"name": "filter", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .preserve ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "distinct", "code": "distinct(.data, ..., .keep_all = FALSE)", "summary": "     Select only unique/distinct rows from a data frame", "code-info": {"name": "distinct", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .keep_all ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "arrange", "code": "arrange(.data, ..., .by_group = FALSE)", "summary": "     arrange() order the rows of a data frame rows by the values of selected columns", "code-info": {"name": "arrange", "parameters": [{"name": ".data", "is_optional": false, "type": "dataframe", "description": " A data frame, data frame extension (e.g. a tibble, or a lazy data frame (e.g. from dbplyr or dtplyr. See Methods, below, for more details."}, {"name": " ...", "is_optional": false, "type": "others", "description": ""}, {"name": " .by_group ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}]}},
{"id": "count", "code": "count(   x,   ...,   wt = NULL,   sort = FALSE,   name = NULL,   .drop = group_by_drop_default(x)", "summary": "     count() lets you quickly count the unique values of one or more variables: df %&gt;% count(a, b) is roughly equivalent to df %&gt;% group_by(a, b) %&gt;% summarise(n = n())", "code-info": {"name": "count", "parameters": [{"name": "   x", "is_optional": false, "type": "others", "description": ""}, {"name": "   ...", "is_optional": false, "type": "others", "description": ""}, {"name": "   wt ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": "   sort ", "is_optional": true, "type": "others", "default_value": " FALSE", "description": ""}, {"name": "   name ", "is_optional": true, "type": "others", "default_value": " NULL", "description": ""}, {"name": "   .drop ", "is_optional": true, "type": "others", "default_value": " group_by_drop_defaul", "description": ""}]}}]
