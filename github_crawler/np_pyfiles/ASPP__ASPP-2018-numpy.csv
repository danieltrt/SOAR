file_path,api_count,code
automata.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom numpy.lib.stride_tricks import as_strided\n\ndef sliding_window(Z, size=2):\n    n, s = Z.shape[0], Z.strides[0]\n    return as_strided(Z, shape=(n-size+1, size), strides=(s, s))\n\n# Rule 30  (see https://en.wikipedia.org/wiki/Rule_30)\n# 0x000: 0, 0x001: 1, 0x010: 1, 0x011: 1\n# 0x100: 1, 0x101: 0, 0x110: 0, 0x111: 0\nrule = 30 \nR = np.array([int(v) for v in \'{0:08b}\'.format(rule)])[::-1]\n\n# Initial state\nZ = np.zeros((250,501), dtype=int)\nZ[0,250] = 1\n\n# Computing some iterations\nfor i in range(1, len(Z)):\n    N = sliding_window(Z[i-1],3) * [1,2,4]\n    Z[i,1:-1] = R[N.sum(axis=1)]\n\n# Display\nplt.figure(figsize=(6,3))\nplt.subplot(1,1,1,frameon=False)\nplt.imshow(Z, vmin=0, vmax=1, cmap=plt.cm.gray_r)\nplt.xticks([]), plt.yticks([])\nplt.tight_layout()\nplt.savefig(""automata.png"")\nplt.show()\n'"
bad-dither.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport imageio\nimport numpy as np\nimport scipy.spatial\n\n# Number of final colors we want\nn = 16\n\n# Original Image\nI = imageio.imread(""kitten.jpg"")\nshape = I.shape\n\n# Flattened image\nI = I.reshape(shape[0]*shape[1], shape[2])\n\n# Find the unique colors and their frequency (=counts)\ncolors, counts = np.unique(I, axis=0, return_counts=True)\n\n# Get the n most frequent colors\nsorted = np.argsort(counts)[::-1]\nC = I[sorted][:n]\n\n# Compute distance to most frequent colors\nD = scipy.spatial.distance.cdist(I, C, \'sqeuclidean\')\n\n# Replace colors with closest one\nZ = (C[D.argmin(axis=1)]).reshape(shape)\n\n# Save result\nimageio.imsave(""kitten-dithered.jpg"", Z)\n'"
basic-manipulation.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n# Create a vector with values ranging from 10 to 49\nZ = np.arange(10,50)\n\n# Create a null vector of size 100 but the fifth value which is 1\nZ = np.zeros(100)\nZ[4] = 1\n\n# Reverse a vector (first element becomes last)\nZ = np.arange(50)[::-1]\n\n# Create a 3x3 matrix with values ranging from 0 to 8\nZ = np.arange(9).reshape(3,3)\n\n# Create a 3x3 identity matrix\nZ = np.eye(3)\n\n# Create a 2d array with 1 on the border and 0 inside\nZ = np.ones((10,10))\nZ[1:-1,1:-1] = 0\n\n# Given a 1D array, negate all elements which are between 3 and 8, in place\nZ = np.arange(11)\nZ[(3 < Z) & (Z <= 8)] *= -1\n'"
diffusion.py,1,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nfrom numpy.lib.stride_tricks import as_strided\n\ndef sliding_window(Z, size=2):\n    n, s = Z.shape[0], Z.strides[0]\n    return as_strided(Z, shape=(n-size+1, size), strides=(s, s))\n\n\n# Initial conditions:\n# Domain size is 100 and we\'ll iterate over 50 time steps\nU = np.zeros((50,100))\nU[0,5::10] = 1.5\n\n# Actual iteration\nF = 0.05\nfor i in range(1, len(Z)):\n    Z[i,1:-1] = Z[i-1,1:-1] + F*(sliding_window(Z[i-1], 3)*[+1,-2,+1]).sum(axis=1)\n\n# Display\nplt.figure(figsize=(6,3))\nplt.subplot(1,1,1,frameon=False)\nplt.imshow(Z, vmin=0, vmax=1)\nplt.xticks([]), plt.yticks([])\nplt.tight_layout()\nplt.savefig(""diffusion.png"")\nplt.show()\n'"
geometry.py,7,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndtype = [(""points"",    float, (4, 2)),\n         (""scale"",     float, 1),\n         (""translate"", float, 2),\n         (""rotate"",    float, 1)]\nS = np.zeros(25, dtype = dtype)\nS[""points""] = [(-1,-1), (-1,+1), (+1,+1), (+1,-1)]\nS[""translate""] = (1,0)\nS[""scale""] = 0.1\nS[""rotate""] = np.linspace(0, 2*np.pi, len(S), endpoint=False)\n\nP = np.zeros((len(S), 4, 2))\nfor i in range(len(S)):\n    for j in range(4):\n        x = S[i][""points""][j,0]\n        y = S[i][""points""][j,1]\n        tx, ty = S[i][""translate""]\n        scale  = S[i][""scale""]\n        theta  = S[i][""rotate""]\n        x = tx + x*scale\n        y = ty + y*scale\n        x_ = x*np.cos(theta) - y*np.sin(theta)\n        y_ = x*np.sin(theta) + y*np.cos(theta)\n        P[i,j] = x_, y_\n\nfig = plt.figure(figsize=(6,6))\nax = plt.subplot(1,1,1, frameon=False)\nfor i in range(len(P)):\n    X = np.r_[P[i,:,0], P[i,0,0]]\n    Y = np.r_[P[i,:,1], P[i,0,1]]\n    plt.plot(X, Y, color=""black"")\nplt.xticks([]), plt.yticks([])\nplt.tight_layout()\nplt.savefig(""geometry.png"")\nplt.show()\n'"
imshow.py,6,"b'# Terminal visualization of 2D numpy arrays\n# Copyright (c) 2009  Nicolas P. Rougier\n#\n# This program is free software: you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation, either version 3 of the License, or (at your option) any later\n# version.\n#\n# This program is distributed in the hope that it will be useful, but WITHOUT\n# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along with\n# this program.  If not, see <http://www.gnu.org/licenses/>.\n# ------------------------------------------------------------------------------\n"""""" Terminal visualization of 2D numpy arrays\n    Using extended color capability of terminal (256 colors), the imshow function\n    renders a 2D numpy array within terminal.\n""""""\nimport sys\nimport numpy as np\nfrom matplotlib.cm import viridis\n\n\ndef imshow (Z, vmin=None, vmax=None, cmap=viridis, show_cmap=True):\n    \'\'\' Show a 2D numpy array using terminal colors \'\'\'\n\n    Z = np.atleast_2d(Z)\n    \n    if len(Z.shape) != 2:\n        print(""Cannot display non 2D array"")\n        return\n\n    vmin = vmin or Z.min()\n    vmax = vmax or Z.max()\n\n    # Build initialization string that setup terminal colors\n    init = \'\'\n    for i in range(240):\n        v = i/240 \n        r,g,b,a = cmap(v)\n        init += ""\\x1b]4;%d;rgb:%02x/%02x/%02x\\x1b\\\\"" % (16+i, int(r*255),int(g*255),int(b*255))\n\n    # Build array data string\n    data = \'\'\n    for i in range(Z.shape[0]):\n        for j in range(Z.shape[1]):\n            c = 16 + int( ((Z[Z.shape[0]-i-1,j]-vmin) / (vmax-vmin))*239)\n            if (c < 16):\n                c=16\n            elif (c > 255):\n                c=255\n            data += ""\\x1b[48;5;%dm  "" % c\n            u = vmax - (i/float(max(Z.shape[0]-1,1))) * ((vmax-vmin))\n        if show_cmap:\n            data += ""\\x1b[0m  ""\n            data += ""\\x1b[48;5;%dm  "" % (16 + (1-i/float(Z.shape[0]))*239)\n            data += ""\\x1b[0m %+.2f"" % u\n        data += ""\\n""\n\n    sys.stdout.write(init+\'\\n\')\n    sys.stdout.write(data+\'\\n\')\n\n\nif __name__ == \'__main__\':\n    def func3(x,y):\n        return (1- x/2 + x**5 + y**3)*np.exp(-x**2-y**2)\n    dx, dy = .2, .2\n    x = np.arange(-3.0, 3.0, dx)\n    y = np.arange(-3.0, 3.0, dy)\n    X,Y = np.meshgrid(x, y)\n    Z = np.array (func3(X, Y))\n    imshow (Z)\n'"
input-output.py,5,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n# Create our own dtype\ndtype = np.dtype([(\'rank\',       \'i8\'),\n                  (\'lemma\',      \'S8\'),\n                  (\'frequency\',  \'i8\'),\n                  (\'dispersion\', \'f8\')])\n\n# Load file using our own dtype\ndata = np.loadtxt(\'data.txt\', comments=\'%\', dtype=dtype)\n\n# Extract words only\nprint(data[""lemma""])\n\n# Extract the 3rd row\nprint(data[2])\n\n# Print all words with rank < 30\nprint(data[data[""rank""] < 30])\n\n# Sort the data according to frequency \nsorted = np.sort(data, order=""frequency"")\nprint(sorted)\n\n# Save unsorted and sorted array\nnp.savez(""sorted.npz"", data=data, sorted=sorted)\n\n# Load saved array\nout = np.load(""sorted.npz"")\nprint(out[""sorted""])\n'"
kmeans.py,11,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\n# Code by Gareth Rees, posted on stack overflow\n# https://codereview.stackexchange.com/questions/61598/k-mean-with-numpy\n\nimport numpy as np\nimport scipy.spatial\n\n\ndef cluster_centroids(data, clusters, k=None):\n    """"""Return centroids of clusters in data.\n\n    data is an array of observations with shape (A, B, ...).\n\n    clusters is an array of integers of shape (A,) giving the index\n    (from 0 to k-1) of the cluster to which each observation belongs.\n    The clusters must all be non-empty.\n\n    k is the number of clusters. If omitted, it is deduced from the\n    values in the clusters array.\n\n    The result is an array of shape (k, B, ...) containing the\n    centroid of each cluster.\n\n    >>> data = np.array([[12, 10, 87],\n    ...                  [ 2, 12, 33],\n    ...                  [68, 31, 32],\n    ...                  [88, 13, 66],\n    ...                  [79, 40, 89],\n    ...                  [ 1, 77, 12]])\n    >>> cluster_centroids(data, np.array([1, 1, 2, 2, 0, 1]))\n    array([[ 79.,  40.,  89.],\n           [  5.,  33.,  44.],\n           [ 78.,  22.,  49.]])\n\n    """"""\n    if k is None:\n        k = np.max(clusters) + 1\n    result = np.empty(shape=(k,) + data.shape[1:])\n    for i in range(k):\n        np.mean(data[clusters == i], axis=0, out=result[i])\n    return result\n\n\ndef kmeans(data, k=None, centroids=None, steps=20):\n    """"""Divide the observations in data into clusters using the k-means\n    algorithm, and return an array of integers assigning each data\n    point to one of the clusters.\n\n    centroids, if supplied, must be an array giving the initial\n    position of the centroids of each cluster.\n\n    If centroids is omitted, the number k gives the number of clusters\n    and the initial positions of the centroids are selected randomly\n    from the data.\n\n    The k-means algorithm adjusts the centroids iteratively for the\n    given number of steps, or until no further progress can be made.\n\n    >>> data = np.array([[12, 10, 87],\n    ...                  [ 2, 12, 33],\n    ...                  [68, 31, 32],\n    ...                  [88, 13, 66],\n    ...                  [79, 40, 89],\n    ...                  [ 1, 77, 12]])\n    >>> np.random.seed(73)\n    >>> kmeans(data, k=3)\n    (array([[79., 40., 89.],\n            [ 5., 33., 44.],\n            [78., 22., 49.]]),    array([1, 1, 2, 2, 0, 1]))\n\n    """"""\n    if centroids is not None and k is not None:\n        assert(k == len(centroids))\n    elif centroids is not None:\n        k = len(centroids)\n    elif k is not None:\n        # Forgy initialization method: choose k data points randomly.\n        centroids = data[np.random.choice(np.arange(len(data)), k, False)]\n    else:\n        raise RuntimeError(""Need a value for k or centroids."")\n\n    for _ in range(max(steps, 1)):\n        # Squared distances between each point and each centroid.\n        sqdists = scipy.spatial.distance.cdist(centroids, data, \'sqeuclidean\')\n\n        # Index of the closest centroid to each data point.\n        clusters = np.argmin(sqdists, axis=0)\n\n        new_centroids = cluster_centroids(data, clusters, k)\n        if np.array_equal(new_centroids, centroids):\n            break\n\n        centroids = new_centroids\n\n    return centroids, clusters\n\n\n\nif __name__ == \'__main__\':\n    import imageio\n\n    # Number of final colors we want\n    n = 16\n\n    # Original Image\n    I = imageio.imread(""kitten.jpg"")\n    shape = I.shape\n\n    # Flattened image\n    D = I.reshape(shape[0]*shape[1], shape[2])\n    \n    # Search for 16 centroids in D (using 20 iterations)\n    centroids, clusters = kmeans(D, k=n, steps=20)\n\n    # Create quantized image\n    I = (centroids[clusters]).reshape(shape)\n    I = np.round(I).astype(np.uint8)\n\n    # Save result\n    imageio.imsave(""kitten-quantized.jpg"", I)\n'"
moving-average.py,0,b'import numpy as np\nimport matplolib.pyplot as plt\n\n'
nan-arithmetics.py,4,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\n# Result is NaN\nprint(0 * np.nan)\n\n# Result is False\nprint(np.nan == np.nan)\n\n# Result is False\nprint(np.inf > np.nan)\n\n# Result is NaN\nprint(np.nan - np.nan)\n\n# Result is False !!!\nprint(0.3 == 3 * 0.1)\nprint(""0.1 really is {:0.56f}"".format(0.1))\n'"
perceptron.py,15,"b'# -----------------------------------------------------------------------------\r\n# Copyright (C) 2018  Nicolas P. Rougier\r\n# Distributed under the terms of the BSD License.\r\n# -----------------------------------------------------------------------------\r\nimport numpy as np\r\n\r\ndef f(x):\r\n    return x > 0\r\n\r\nclass Perceptron:\r\n    \'\'\' Perceptron class. \'\'\'\r\n\r\n    def __init__(self, n, m):\r\n        \'\'\' Initialization of the perceptron with given sizes.  \'\'\'\r\n\r\n        self.input  = np.ones(n+1)\r\n        self.output = np.ones(m)\r\n        self.weights= np.zeros((m,n+1))\r\n        self.reset()\r\n\r\n    def reset(self):\r\n        \'\'\' Reset weights \'\'\'\r\n\r\n        self.weights[...] = np.random.uniform(-.5, .5, self.weights.shape)\r\n\r\n    def propagate_forward(self, data):\r\n        \'\'\' Propagate data from input layer to output layer. \'\'\'\r\n\r\n        # Set input layer (but not bias)\r\n        self.input[1:]  = data\r\n        self.output[...] = f(np.dot(self.weights,self.input))\r\n\r\n        # Return output\r\n        return self.output\r\n\r\n    def propagate_backward(self, target, lrate=0.1):\r\n        \'\'\' Back propagate error related to target using lrate. \'\'\'\r\n\r\n        error = np.atleast_2d(target-self.output)\r\n        input = np.atleast_2d(self.input)\r\n        self.weights += lrate*np.dot(error.T,input)\r\n\r\n        # Return error\r\n        return (error**2).sum()\r\n\r\n\r\n# -----------------------------------------------------------------------------\r\nif __name__ == \'__main__\':\r\n    import numpy as np\r\n    import matplotlib.pyplot as plt\r\n    import matplotlib.animation as animation\r\n\r\n    np.random.seed(123)\r\n    \r\n    samples = np.zeros(100, dtype=[(\'input\',  float, 2),\r\n                                   (\'output\', float, 1)])\r\n\r\n    P = np.random.uniform(0.05,0.95,(len(samples),2))\r\n    samples[""input""] = P\r\n    stars = np.where(P[:,0]+P[:,1] < 1)\r\n    discs = np.where(P[:,0]+P[:,1] > 1)\r\n    samples[""output""][stars] = +1\r\n    samples[""output""][discs] = 0\r\n\r\n\r\n    network = Perceptron(2,1)\r\n    network.reset()\r\n    lrate = 0.05\r\n\r\n    fig = plt.figure(figsize=(6,6))\r\n    ax = plt.subplot(1,1,1, aspect=1, frameon=False)\r\n    ax.scatter(P[stars,0], P[stars,1], color=""red"", marker=""*"", s=50, alpha=.5)\r\n    ax.scatter(P[discs,0], P[discs,1], color=""blue"", s=25, alpha=.5)\r\n    line, = ax.plot([], [], color=""black"", linewidth=2)\r\n    ax.set_xlim(0,1)\r\n    ax.set_xticks([])\r\n    ax.set_ylim(0,1)\r\n    ax.set_yticks([])\r\n    plt.tight_layout()\r\n\r\n    def animate(i):\r\n        global lrate\r\n        error = 0\r\n\r\n        count = 0\r\n        lrate *= 0.99\r\n        while error == 0 and count < 10:\r\n            n = np.random.randint(samples.size)\r\n            network.propagate_forward( samples[\'input\'][n] )\r\n            error = network.propagate_backward( samples[\'output\'][n], lrate )\r\n            count += 1\r\n\r\n        c,a,b = network.weights[0]\r\n        x0 = -2\r\n        x1 = +2\r\n        if a != 0:\r\n            y0 = (-c -b*x0)/a\r\n            y1 = (-c -b*x1)/a\r\n        else:\r\n            y0 = 0\r\n            y1 = 1\r\n            \r\n        line.set_xdata([x0,x1])\r\n        line.set_ydata([y0,y1])\r\n        \r\n        return line,\r\n\r\n    anim = animation.FuncAnimation(fig, animate, np.arange(1, 300))\r\n    #Writer = animation.writers[\'ffmpeg\']\r\n    #writer = Writer(fps=30,\r\n    #                metadata=dict(artist=\'Nicolas P. Rougier\'), bitrate=1800)\r\n    # anim.save(\'perceptron.mp4\', writer=writer)\r\n    plt.show()\r\n'"
random-walk.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport random\nimport numpy as np\nfrom tools import timeit\n\ndef random_walk_slow(n):\n    position = 0\n    walk = [position]\n    for i in range(n):\n        position += 2*random.randint(0, 1)-1\n        walk.append(position)\n    return walk\n\n\ndef random_walk_faster(n=1000):\n    from itertools import accumulate\n    # Only available from Python 3.6\n    steps = random.choices([-1,+1], k=n)\n    return [0]+list(accumulate(steps))\n\ndef random_walk_fastest(n=1000):\n    steps = np.random.choice([-1,+1], n)\n    return np.cumsum(steps)\n\n\nif __name__ == \'__main__\':\n\n    timeit(""random_walk_slow(1000)"", globals())\n    timeit(""random_walk_faster(1000)"", globals())\n    timeit(""random_walk_fastest(1000)"", globals())\n'"
reorder.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport struct\nimport numpy as np\n\n# Generation of the array\n# Z = range(1001, 1009)\n# L = np.reshape(Z, (2,2,2), order=""F"").ravel().astype("">i8"").view(np.ubyte)\n\nL = [  0,   0,   0,   0,   0,   0,   3, 233,\n       0,   0,   0,   0,   0,   0,   3, 237,\n       0,   0,   0,   0,   0,   0,   3, 235,\n       0,   0,   0,   0,   0,   0,   3, 239,\n       0,   0,   0,   0,   0,   0,   3, 234,\n       0,   0,   0,   0,   0,   0,   3, 238,\n       0,   0,   0,   0,   0,   0,   3, 236,\n       0,   0,   0,   0,   0,   0,   3, 240]\n\n# Automatic (numpy)\nZ = np.reshape(np.array(L, dtype=np.ubyte).view(dtype="">i8""), (2,2,2), order=""F"")\nprint(Z[1,0,0])\n\n# Manual (brain)\nshape = (2,2,2)\nitemsize = 8\n# We can probably do better\nstrides = itemsize, itemsize*shape[0], itemsize*shape[0]*shape[1]\nindex = (1,0,0)\nstart = sum(i*s for i,s in zip(index,strides))\nend = start+itemsize\nvalue = struct.unpack("">Q"", bytes(L[start:end]))[0]\nprint(value)\n'"
repeat.py,2,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\nfrom numpy.lib.stride_tricks import as_strided\n\nZ = np.zeros(5)\nZ1 = np.tile(Z,(3,1))\nZ2 = as_strided(Z, shape=(3,)+Z.shape, strides=(0,)+Z.strides)\n\n# Real repeat (three times the memory)\nZ1[0,0] = 1\nprint(Z1)\n\n# Fake repeat (but less memory)\nZ2[0,0] = 1\nprint(Z2)\n'"
strides.py,3,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nimport numpy as np\n\ndef strides(Z):\n    strides = [Z.itemsize]\n    \n    # Fotran ordered array\n    if np.isfortran(Z):\n        for i in range(0, Z.ndim-1):\n            strides.append(strides[-1] * Z.shape[i])\n        return tuple(strides)\n    # C ordered array\n    else:\n        for i in range(Z.ndim-1, 0, -1):\n            strides.append(strides[-1] * Z.shape[i])\n        return tuple(strides[::-1])\n\n# This work\nZ = np.arange(24).reshape((2,3,4), order=""C"")\nprint(Z.strides, "" \xe2\x80\x93 "", strides(Z))\n\nZ = np.arange(24).reshape((2,3,4), order=""F"")\nprint(Z.strides, "" \xe2\x80\x93 "", strides(Z))\n\n# This does not work\n# Z = Z[::2]\n# print(Z.strides, "" \xe2\x80\x93 "", strides(Z))\n\n'"
tools.py,10,"b'# -----------------------------------------------------------------------------\n# Copyright (C) 2018  Nicolas P. Rougier\n# Distributed under the terms of the BSD License.\n# -----------------------------------------------------------------------------\nfrom imshow import imshow\n\ndef sysinfo():\n    import sys\n    import time\n    import numpy as np\n    import scipy as sp\n    import matplotlib\n\n    print(""Date:       %s"" % (time.strftime(""%D"")))\n    version = sys.version_info\n    major, minor, micro = version.major, version.minor, version.micro\n    print(""Python:     %d.%d.%d"" % (major, minor, micro))\n    print(""Numpy:     "", np.__version__)\n    print(""Scipy:     "", sp.__version__)\n    print(""Matplotlib:"", matplotlib.__version__)\n\n\ndef timeit(stmt, globals=globals()):\n    import numpy as np\n    import timeit as _timeit\n\n    print(""Timing \'{0}\'"".format(stmt))\n        \n    # Rough approximation of a 10 runs\n    trial = _timeit.timeit(stmt, globals=globals, number=10)/10\n    \n    # Maximum duration\n    duration = 5.0\n    \n    # Number of repeat\n    repeat = 7\n    \n    # Compute rounded number of trials\n    number = max(1,int(10**np.ceil(np.log((duration/repeat)/trial)/np.log(10))))\n    \n    # Only report best run\n    times = _timeit.repeat(stmt, globals=globals, number=number, repeat=repeat)\n    times = np.array(times)/number\n    mean = np.mean(times)\n    std = np.std(times)\n\n    # Display results\n    units = {""s"":  1, ""ms"": 1e-3, ""us"": 1e-6, ""ns"": 1e-9}\n    for key,value in units.items():\n        unit, factor = key, 1/value\n        if mean > value: break\n    mean *= factor\n    std *= factor\n\n    print(""%.3g %s \xc2\xb1 %.3g %s per loop (mean \xc2\xb1 std. dev. of %d runs, %d loops each)"" %\n          (mean, unit, std, unit, repeat, number))\n\n    \ndef info(Z):\n    import sys\n    import numpy as np\n    endianness = {\'=\': \'native (%s)\' % sys.byteorder,\n                 \'<\': \'little\',\n                 \'>\': \'big\',\n                 \'|\': \'not applicable\'}\n\n    print(""------------------------------"")\n    print(""Interface (item)"")\n    print(""  shape:      "", Z.shape)\n    print(""  dtype:      "", Z.dtype)\n    print(""  length:     "", len(Z))\n    print(""  size:       "", Z.size)\n    print(""  endianness: "", endianness[Z.dtype.byteorder])\n    if np.isfortran(Z):\n        print(""  order:       \xe2\x98\x90 C  \xe2\x98\x91 Fortran"")\n    else:\n        print(""  order:       \xe2\x98\x91 C  \xe2\x98\x90 Fortran"")\n    print("""")\n    print(""Memory (byte)"")\n    print(""  item size:  "", Z.itemsize)\n    print(""  array size: "", Z.size*Z.itemsize)\n    print(""  strides:    "", Z.strides)\n    print("""")\n    print(""Properties"")\n    if Z.flags[""OWNDATA""]:\n        print(""  own data:    \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  own data:    \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if Z.flags[""WRITEABLE""]:\n        print(""  writeable:   \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  writeable:   \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if np.isfortran(Z) and Z.flags[""F_CONTIGUOUS""]:\n        print(""  contiguous:  \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    elif not np.isfortran(Z) and Z.flags[""C_CONTIGUOUS""]:\n        print(""  contiguous:  \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  contiguous:  \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    if Z.flags[""ALIGNED""]:\n        print(""  aligned:     \xe2\x98\x91 Yes  \xe2\x98\x90 No"")\n    else:\n        print(""  aligned:     \xe2\x98\x90 Yes  \xe2\x98\x91 No"")\n    print(""------------------------------"")\n    print()\n\n\nif __name__ == \'__main__\':\n    import numpy as np\n    \n    sysinfo()\n\n    Z = np.arange(9).reshape(3,3)\n    info(Z)\n\n    timeit(""Z=np.random.uniform(0,1,1000000)"", globals())\n\n    \n'"
