file_path,api_count,code
SnakeGame copy before TFLearn.py,0,"b'# Imports\nimport pygame\nfrom random import *\n\n# Enums\nclass Direction:\n    left, right, up, down = range(4)\nclass NodeType:\n    empty, snake, food, wall = range(4)\n\n# Screen constants\nblock_size = 10\nscreen_size = (50,50)\nscreen_color = (0, 0, 0)\nwall_color = (128, 128, 128)\nsnake_color = (0, 255, 0)\nfood_color = (0, 0, 255)\n\n# Grid constants\ncolumns, rows = screen_size[0], screen_size[1];\n\n# Snake constants\nsnake_initial_size = 1\nsnake_position = (10,10)\n\nclass SnakeNode:\n        def __init__(self,x,y):\n                self.x = x\n                self.y = y\n\ndef getGrid():\n        grid = [[0 for x in range(columns)] for y in range(rows)]\n\n        for x in range(columns):\n                grid[x][0] = NodeType.wall\n                grid[x][columns-1] = NodeType.wall\n\n        for y in range(rows):\n                grid[0][y] = NodeType.wall\n                grid[rows-1][y] = NodeType.wall\n\n        return grid\n\ndef getSnakeNodes(x,y,grid):\n        # Create initial snake\n        snake_nodes = []\n        for i in range(snake_initial_size):\n            segment = SnakeNode(x+i, y)\n            snake_nodes.append(segment)\n            grid[x+i][y] = NodeType.snake\n\n        return snake_nodes\n\ndef drawNode(x,y,grid,screen):\n        if grid[x][y] == NodeType.snake:  color = snake_color\n        elif grid[x][y] == NodeType.food: color = food_color\n        elif grid[x][y] == NodeType.wall: color = wall_color\n        else:                             color = screen_color\n\n        pygame.draw.rect(screen,color,pygame.Rect(x*block_size,y*block_size,block_size,block_size))\n\ndef isGameOver(snake_nodes):\n        head = snake_nodes[0]\n        return head.x == 0\\\n                or head.y == 0\\\n                or head.x == columns-1\\\n                or head.y == rows-1\n\ndef advanceSnake(snake_nodes,direction,grid):\n        head = snake_nodes[0]\n        tail = snake_nodes.pop()\n        grid[tail.x][tail.y] = NodeType.empty\n        \n        if direction == Direction.up:\n                tail.x = head.x\n                tail.y = head.y - 1\n        elif direction == Direction.down:\n                tail.x = head.x\n                tail.y = head.y + 1\n        elif direction == Direction.left:\n                tail.x = head.x - 1\n                tail.y = head.y\n        elif direction == Direction.right:\n                tail.x = head.x + 1\n                tail.y = head.y\n\n        snake_nodes.insert(0,tail)\n        grid[tail.x][tail.y] = NodeType.snake\n        return snake_nodes\n\ndef drawNodes(grid,screen):\n        for x in range(columns):\n                for y in range(rows):\n                        drawNode(x,y, grid,screen)\n\ndef getNeighboringNodes(snake_nodes,direction,grid): # Left, forward, right nodes of snake\n        head = snake_nodes[0]\n\n        if direction == Direction.right:\n                return (grid[head.x][head.y-1],grid[head.x+1][head.y],grid[head.x][head.y+1])\n        elif direction == Direction.left:\n                return (grid[head.x][head.y+1],grid[head.x-1][head.y],grid[head.x][head.y-1])\n        elif direction == Direction.up:\n                return (grid[head.x-1][head.y],grid[head.x][head.y-1],grid[head.x+1][head.y])\n        else:\n                return (grid[head.x+1][head.y],grid[head.x][head.y+1],grid[head.x-1][head.y])\n\ndef areNeighboringNodesBlocked(left,forward,right):\n        return (left == NodeType.wall,forward == NodeType.wall,right == NodeType.wall)\n\ndef neuralInputs(snake_nodes,direction,grid):\n        return (areNeighboringNodesBlocked(*getNeighboringNodes(snake_nodes,direction,grid)),random())\n\ndef runGame():\n\n        # count = 0\n\n        # Game objects\n        direction = Direction.right\n        grid = getGrid()\n        snake_nodes = getSnakeNodes(snake_position[0],\n                                    snake_position[1],\n                                    grid)\n        pygame.init()\n        screen = pygame.display.set_mode((screen_size[0]*block_size,\n                                          screen_size[1]*block_size))\n\n        # Game loop\n        while not isGameOver(snake_nodes):\n\n                # count = count + 1\n\n                print neuralInputs(snake_nodes,direction,grid)\n\n                for event in pygame.event.get():\n                        if event.type == pygame.QUIT:\n                                game_over = True\n\n                # Controls\n                pressed = pygame.key.get_pressed()\n                if pressed[pygame.K_UP] and direction!=Direction.down: direction = Direction.up\n                elif pressed[pygame.K_DOWN] and direction!=Direction.up: direction = Direction.down\n                elif pressed[pygame.K_LEFT] and direction!=Direction.right: direction = Direction.left\n                elif pressed[pygame.K_RIGHT] and direction!=Direction.left: direction = Direction.right\n\n                # Drawing\n                screen.fill(screen_color)\n                drawNodes(grid,screen)\n                pygame.display.flip()\n\n                # Clock ticking\n                pygame.time.Clock().tick(60)\n\n                # if count % 5 == 0:\n                snake_nodes = advanceSnake(snake_nodes,direction,grid)\n        runGame()\n\nrunGame()'"
SnakeGame.py,2,"b'# Imports\nimport pygame\nfrom random import randint,shuffle\nimport numpy as np\nfrom math import pi, asin, sqrt, degrees, radians\nimport pandas as pds\nfrom keras.models import Sequential\nfrom keras.layers import Dense\nimport coremltools\n\n# Enums\nclass Direction:\n    left, right, up, down = range(4)\nclass NodeType:\n    empty, snake_head, food, wall = range(4)\n\n# Screen constants\nblock_size = 10\nscreen_size = (50,50)\nscreen_color = (0, 0, 0)\nwall_color = (128, 128, 128)\nsnake_color = (0, 255, 255)\nfood_color = (0, 255, 0)\n\n# Grid constants\ncolumns, rows = screen_size[0], screen_size[1];\n\n# Snake constants\nsnake_initial_size = 1\n\nclass SnakeNode:\n    def __init__(self,x,y):\n        self.x = x\n        self.y = y\n\ndef removeDuplicates(input_file_name,output_file_name):\n    with open(input_file_name,""r"") as input_file, open(output_file_name,""w"") as output_file:\n        output_file.writelines(unique_everseen(input_file))\n\ndef getGrid():\n    grid = [[0 for x in range(columns)] for y in range(rows)]\n\n    for x in range(columns):\n        grid[x][0] = NodeType.wall\n        grid[x][columns-1] = NodeType.wall\n\n    for y in range(rows):\n        grid[0][y] = NodeType.wall\n        grid[rows-1][y] = NodeType.wall\n\n    return grid\n\ndef getSnakeNodes(x,y,grid):\n    # Create initial snake\n    snake_nodes = []\n    for i in range(snake_initial_size):\n        segment = SnakeNode(x+i, y)\n        snake_nodes.append(segment)\n\n    grid[x][y] = NodeType.snake_head\n    for i in range(1,len(snake_nodes)):\n        grid[snake_nodes[i].x][snake_nodes[i].y] = NodeType.wall\n\n    return snake_nodes\n\ndef getGrownSnake(snake_nodes,direction,grid):\n    tail = snake_nodes[-1]\n\n    if direction == Direction.right:   new_tail = SnakeNode(tail.x-1, tail.y)\n    elif direction == Direction.left:  new_tail = SnakeNode(tail.x+1, tail.y)\n    elif direction == Direction.up:    new_tail = SnakeNode(tail.x, tail.y+1)\n    else:                              new_tail = SnakeNode(tail.x, tail.y-1)\n\n    grid[new_tail.x][new_tail.y] = NodeType.wall\n\n    snake_nodes.append(new_tail)\n\n    return snake_nodes,grid\n\ndef drawNode(x,y,grid,screen):\n    if grid[x][y] == NodeType.snake_head:  color = snake_color\n    elif grid[x][y] == NodeType.food: color = food_color\n    elif grid[x][y] == NodeType.wall: color = wall_color\n    else:                             color = screen_color\n\n    pygame.draw.rect(screen,color,pygame.Rect(x*block_size,y*block_size,block_size,block_size))\n\ndef isGameOver(snake_nodes,grid):\n    head = snake_nodes[0]\n\n    return grid[head.x][head.y] == NodeType.wall\\\n        or head.x == 0\\\n        or head.y == 0\\\n        or head.x == columns-1\\\n        or head.y == rows-1\n\ndef advanceSnake(snake_nodes,direction,grid):\n    head = snake_nodes[0]\n    tail = snake_nodes.pop()\n    grid[tail.x][tail.y] = NodeType.empty\n    \n    if direction == Direction.up:\n        tail.x = head.x\n        tail.y = head.y - 1\n    elif direction == Direction.down:\n        tail.x = head.x\n        tail.y = head.y + 1\n    elif direction == Direction.left:\n        tail.x = head.x - 1\n        tail.y = head.y\n    elif direction == Direction.right:\n        tail.x = head.x + 1\n        tail.y = head.y\n\n    snake_nodes.insert(0,tail)\n\n    if grid[tail.x][tail.y] != NodeType.food and grid[tail.x][tail.y] != NodeType.wall:\n        grid[tail.x][tail.y] = NodeType.snake_head\n\n    for i in range(1,len(snake_nodes)):\n        grid[snake_nodes[i].x][snake_nodes[i].y] = NodeType.wall\n\n    return snake_nodes\n\ndef drawNodes(grid,screen):\n    for x in range(columns):\n        for y in range(rows):\n            drawNode(x,y, grid,screen)\n\ndef getNeighboringNodes(snake_nodes,direction,grid): # Left, forward, right nodes of snake\n    head = snake_nodes[0]\n\n    if direction == Direction.right:\n        return (grid[head.x][head.y-1],grid[head.x+1][head.y],grid[head.x][head.y+1])\n    elif direction == Direction.left:\n        return (grid[head.x][head.y+1],grid[head.x-1][head.y],grid[head.x][head.y-1])\n    elif direction == Direction.up:\n        return (grid[head.x-1][head.y],grid[head.x][head.y-1],grid[head.x+1][head.y])\n    else:\n        return (grid[head.x+1][head.y],grid[head.x][head.y+1],grid[head.x-1][head.y])\n\ndef areNeighboringNodesBlocked(left,forward,right):\n    return (int(left == NodeType.wall),int(forward == NodeType.wall),int(right == NodeType.wall))\n\ndef isAnyNeighboringNodesBlocked(left,forward,right):\n    return left == NodeType.wall or forward == NodeType.wall or right == NodeType.wall\n\ndef distanceBetweenSnakeAndFood(snake_nodes,food_position):\n    head = snake_nodes[0]\n\n    food_x,food_y = food_position\n\n    base = abs(food_x - head.x)\n    perpendicular = abs(food_y - head.y)\n\n    hypotenuse = sqrt(base**2 + perpendicular**2)\n    return hypotenuse\n\ndef getOrthogonalAngle(snake_nodes,food_position,absolute_direction):\n    head = snake_nodes[0]\n\n    food_x,food_y = food_position\n\n    base = food_x - head.x\n    perpendicular = food_y - head.y\n\n    hypotenuse = sqrt(base**2 + perpendicular**2)+0.00001\n\n    angle = degrees(asin(perpendicular/hypotenuse))%90\n\n    if absolute_direction == Direction.right:\n        if base >= 0 and perpendicular <= 0:   angle = angle + 0\n        elif base <= 0 and perpendicular <= 0: angle = angle + 90\n        elif base <= 0 and perpendicular >= 0: angle = angle + 90\n        else:                                  angle = angle + 0\n    elif absolute_direction == Direction.up:\n        if base >= 0 and perpendicular <= 0:   angle = angle + 0\n        elif base <= 0 and perpendicular <= 0: angle = angle + 0\n        elif base <= 0 and perpendicular >= 0: angle = angle + 90\n        else:                                  angle = angle + 90\n    elif absolute_direction == Direction.left:\n        if base >= 0 and perpendicular <= 0:   angle = angle + 90\n        elif base <= 0 and perpendicular <= 0: angle = angle + 0\n        elif base <= 0 and perpendicular >= 0: angle = angle + 0\n        else:                                  angle = angle + 90\n    else:\n        if base >= 0 and perpendicular <= 0:   angle = angle + 90\n        elif base <= 0 and perpendicular <= 0: angle = angle + 90\n        elif base <= 0 and perpendicular >= 0: angle = angle + 0\n        else:                                  angle = angle + 0\n\n    return radians(angle-90)/(pi/2)\n\ndef neuralInputs(snake_nodes,grid,absolute_direction,food_position):\n    return (areNeighboringNodesBlocked(*getNeighboringNodes(snake_nodes,absolute_direction,grid)),\n        getOrthogonalAngle(snake_nodes,food_position,absolute_direction))\n\ndef getTrainedModel(data, labels):\n\n    model = Sequential()\n    model.add(Dense(5,input_shape=(5,),activation=""relu""))\n    model.add(Dense(25,activation=""relu""))\n    model.add(Dense(25,activation=""relu""))\n    model.add(Dense(1,activation=""linear""))\n    model.summary()\n    model.compile(loss=""mean_squared_error"",optimizer=""adam"",metrics=[""accuracy""])\n    model.fit(data,labels,epochs=1)\n    \n    return model\n\ndef getRelativeDirection(current_direction,next_direction):\n\n    if current_direction == Direction.right:\n        if next_direction == Direction.up: return -1\n        elif next_direction == Direction.right: return 0\n        else:                         return 1\n    elif current_direction == Direction.left:\n        if next_direction == Direction.down: return -1\n        elif next_direction == Direction.left: return 0\n        else:                         return 1\n    elif current_direction == Direction.up:\n        if next_direction == Direction.left: return -1\n        elif next_direction == Direction.up: return 0\n        else:                         return 1\n    else:\n        if next_direction == Direction.right: return -1\n        elif next_direction == Direction.down: return 0\n        else:                         return 1\n\ndef getPredictedDirection(snake_nodes,absolute_direction,model,inputs,grid,shuffle_predictions):\n    head = snake_nodes[0]\n\n    relative_directions = [-1,0,1]\n\n    if shuffle_predictions == True:\n        shuffle(relative_directions)\n\n    no_match_found = False\n    for relative_direction in relative_directions:\n        prediction = model.predict(np.array([[inputs[0][0],inputs[0][1],inputs[0][2],inputs[1],relative_direction]]))\n        if prediction > 0.9:\n            break\n        no_match_found = True\n\n    if no_match_found == True and shuffle_predictions == True:\n        for relative_direction in relative_directions:\n            prediction = model.predict(np.array([[inputs[0][0],inputs[0][1],inputs[0][2],inputs[1],relative_direction]]))\n            if prediction >= 0:\n                break\n\n    if absolute_direction == Direction.right:\n        if relative_direction == -1:  return Direction.up,relative_direction\n        elif relative_direction == 0: return Direction.right,relative_direction\n        else:                         return Direction.down,relative_direction\n    elif absolute_direction == Direction.left:\n        if relative_direction == -1:  return Direction.down,relative_direction\n        elif relative_direction == 0: return Direction.left,relative_direction\n        else:                         return Direction.up,relative_direction\n    elif absolute_direction == Direction.up:\n        if relative_direction == -1:  return Direction.left,relative_direction\n        elif relative_direction == 0: return Direction.up,relative_direction\n        else:                         return Direction.right,relative_direction\n    else:\n        if relative_direction == -1:  return Direction.right,relative_direction\n        elif relative_direction == 0: return Direction.down,relative_direction\n        else:                         return Direction.left,relative_direction\n\ndef getOutputForTraining(target_output,inputs,snake_nodes,relative_direction):\n\n    return ""\\n{},{},{},{},{},{}"".format(target_output,\n                                     inputs[0][0],\n                                     inputs[0][1],\n                                     inputs[0][2],\n                                     inputs[1],\n                                     relative_direction)\n\ndef generateFood(grid):\n    food_position = (randint(1, columns-snake_initial_size-1),randint(1, rows-snake_initial_size-1))\n    grid[food_position[0]][food_position[1]] = NodeType.food\n    return food_position\n\ndef checkForFoodCollision(snake_nodes,grid):\n    head = snake_nodes[0]\n    return grid[head.x][head.y] == NodeType.food\n\ndef resetStuckPosition():\n    return [[0 for x in range(columns)] for y in range(rows)]\n\ndef runGame(death_count,font,model):\n\n    # Game objects\n    score_count = 0\n    grid = getGrid()\n    directions = [Direction.right,Direction.left,Direction.up,Direction.down]\n    direction = directions[randint(0,len(directions)-1)]\n    snake_position = (randint(1, columns-snake_initial_size-1),randint(1, rows-snake_initial_size-1))\n    food_position = generateFood(grid)\n    snake_nodes = getSnakeNodes(snake_position[0],\n                                snake_position[1],\n                                grid)\n    screen = pygame.display.set_mode((screen_size[0]*block_size,\n                                      screen_size[1]*block_size))\n\n    stuck_position = resetStuckPosition()\n\n    # Game loop\n    while not isGameOver(snake_nodes,grid):\n\n        # Update score\n        game_stats_label = font.render(""Deaths: {}               Score: {}"".format(death_count,score_count), 1, (255,255,0))\n\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                game_over = True\n\n        # Drawing\n        screen.fill(screen_color)\n        drawNodes(grid,screen)\n        screen.blit(game_stats_label, (0, 0))\n        pygame.display.flip()\n\n        # Clock ticking\n        pygame.time.Clock().tick(999999999999)\n\n        # If snake gets stuck in the same position for too long (5 times), shuffle the predictions\n        stuck_position[snake_nodes[0].x][snake_nodes[0].y] += 1\n        shuffle_predictions = (stuck_position[snake_nodes[0].x][snake_nodes[0].y] > 5)\n\n        # Manual controls\n        # pressed = pygame.key.get_pressed()\n        # if pressed[pygame.K_UP] and direction!=Direction.down: direction = Direction.up\n        # elif pressed[pygame.K_DOWN] and direction!=Direction.up: direction = Direction.down\n        # elif pressed[pygame.K_LEFT] and direction!=Direction.right: direction = Direction.left\n        # elif pressed[pygame.K_RIGHT] and direction!=Direction.left: direction = Direction.right\n\n        # Random controls\n        # pressed = randint(0, 3)\n        # if pressed == 0 and direction!=Direction.down: direction = Direction.up\n        # elif pressed == 1 and direction!=Direction.up: direction = Direction.down\n        # elif pressed == 2 and direction!=Direction.right: direction = Direction.left\n        # elif pressed == 3 and direction!=Direction.left: direction = Direction.right\n\n        # AI controls\n        current_direction = direction\n        inputs = neuralInputs(snake_nodes,grid,direction,food_position)\n        direction,relative_direction = getPredictedDirection(snake_nodes,direction,model,inputs,grid,shuffle_predictions)\n\n        previous_distance_between_snake_and_food = distanceBetweenSnakeAndFood(snake_nodes,food_position)\n        snake_nodes = advanceSnake(snake_nodes,direction,grid)\n        current_distance_between_snake_and_food = distanceBetweenSnakeAndFood(snake_nodes,food_position)\n\n        # If game is over, target output is -1\n        # If snake has moved away from the goal, target output is 0\n        # If snake has moved closer to the goal, target output is 1\n        if isGameOver(snake_nodes,grid):                                                          target_output = -1\n        elif current_distance_between_snake_and_food >= previous_distance_between_snake_and_food: target_output = 0\n        else:                                                                                     target_output = 1\n\n        output = getOutputForTraining(target_output,inputs,snake_nodes,getRelativeDirection(current_direction,direction))\n        # file = open(""Data.csv"",""a"")\n        # file.write(output)\n        # file.close()\n\n        if checkForFoodCollision(snake_nodes,grid):\n            score_count += 1\n            food_position = generateFood(grid)\n            shuffle_predictions = False\n            stuck_position = resetStuckPosition()\n            snake_nodes,grid = getGrownSnake(snake_nodes,direction,grid)\n\n# Load CSV file, indicate that the first column represents labels\ndata = pds.read_csv(""Data.csv"",usecols=[1,2,3,4,5])\nlabels = pds.read_csv(""Data.csv"",usecols=[0])\nmodel = getTrainedModel(data,labels)\n# coreml_model = coremltools.converters.keras.convert(model)\n# coreml_model.save(""SnakeModel.mlmodel"")\ndeath_count = 0\npygame.init()\nfont = pygame.font.SysFont(""monospace"", 50)\n\nwhile True:\n    death_count += 1\n    runGame(death_count,font,model)\n    '"
