file_path,api_count,code
AMaDiA.py,3,"b'# This Python file uses the following encoding: utf-8\nVersion = ""0.17.0""\n# Version should be interpreted as: (MAIN).(TOPIC).(FUNCTION).(BUGFIX)\n# MAIN marks mayor milestones of the project (like the release)\n# TOPIC marks the introduction of\n#       a new functionality like the addition of a new tab or window that can handle a new mathematical topic\n#       major internal changes like the introduction of the custom window class\n#   These introductions are only that: introductions\n#   Further updates complete the TOPIC. These updates may also be part of a different TOPIC version.\n# FUNCTION marks the introduction of new functionality and aim to advance the current TOPIC\n# BUGFIX marks very minor updates that:\n#       fix bugs\n#       optimize (or even add minor) functions by changing a single line\n#       edit text\nAuthor = ""Robin \\\'Astus\\\' Albers""\nWindowTitle = ""AMaDiA v""\nWindowTitle+= Version\nWindowTitle+= "" by ""\nWindowTitle+= Author\n#region ---------------------------------- imports ----------------------------------\nCopyright_Short =   """"""\n                        Copyright (C) 2020  Robin Albers\n\n                        This program is distributed in the hope that it will be useful,\n                        but WITHOUT ANY WARRANTY; without even the implied warranty of\n                        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n                        GNU General Public License for more details.\n\n                        You should have received a copy of the GNU General Public License\n                        along with this program.  If not, see <https://www.gnu.org/licenses/>.\n                    """"""\n\nimport datetime\nimport platform\nif __name__ == ""__main__"":\n    print()\n    print(datetime.datetime.now().strftime(\'%H:%M:%S\'))\n    print(WindowTitle)\n    print(""Loading Modules"")#,end="""")\n    if platform.system() == \'Windows\':\n        try:\n            import ctypes\n            myAppId = u\'{}{}\'.format(WindowTitle , datetime.datetime.now().strftime(\'%H:%M:%S\')) # arbitrary string\n            ctypes.windll.shell32.SetCurrentProcessExplicitAppUserModelID(myAppId)\n        except:\n            pass\n\nfrom AGeLib import *\nimport AGeLib\n\n\n# import qt Modules\nfrom PyQt5.Qt import QApplication, QClipboard # pylint: disable=no-name-in-module\nfrom PyQt5 import QtWidgets,QtCore,QtGui,Qt\n#import PyQt5.Qt as Qt\n\n# import standard modules\nfrom distutils.spawn import find_executable\nimport sys\nimport socket\nimport time\nimport errno\nimport os\nimport pathlib\nimport importlib\nimport re\nimport getpass\nimport traceback\n\n# import Maths modules\nimport matplotlib\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import colors\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\nfrom matplotlib.figure import Figure\n\n# Import AMaDiA Core Modules\n# To Convert ui to py: (Commands for Anaconda Prompt)\n# cd C:""\\Users\\Robin\\Desktop\\Projects\\AMaDiA\\AMaDiA_Files""\n# cd /home/robin/Projects/AMaDiA/AMaDiA_Files/\n# pyuic5 AMaDiAUI.ui -o AMaDiAUI.py\nfrom AMaDiA_Files.AMaDiAUI import Ui_AMaDiA_Main_Window\nfrom AMaDiA_Files.AMaDiA_Options_UI import Ui_AMaDiA_Options\nfrom AMaDiA_Files import AMaDiA_Widgets as AW\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_Classes as AC\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\nfrom AMaDiA_Files import AMaDiA_Threads as AT\nfrom AMaDiA_Files import AstusChat_Client\nfrom AMaDiA_Files import AstusChat_Server\nfrom AMaDiA_Files.Test_Input import Test_Input\n\n\n\n# To limit the length of output (Currently used to reduce the length of the y vector when an error in the plotter occurs)\nimport reprlib\nr = reprlib.Repr()\nr.maxlist = 20       # max elements displayed for lists\nr.maxarray = 20       # max elements displayed for arrays\nr.maxother = 500       # max elements displayed for other including np.ndarray\nr.maxstring = 40    # max characters displayed for strings\n\n# Load External Libraries\n# These are not part of the standard Anaconda package and thus are already part of AMaDiA to make installation easy\n#from External_Libraries.python_control_master import control\ntry:\n    from External_Libraries.keyboard_master import keyboard\nexcept common_exceptions :\n    ExceptionOutput(sys.exc_info())\n    Keyboard_Remap_Works = False\nelse:\n    Keyboard_Remap_Works = True\n\n# Slycot is needed for some features of control but can not be included in AMaDiA as it needs system dependent compiling\ntry:\n    import slycot\nexcept ModuleNotFoundError:\n    slycot_Installed = False\nelse:\n    slycot_Installed = True\n\nnp.set_printoptions(threshold=100)\n\nAltModifier = QtCore.Qt.AltModifier\nControlModifier = QtCore.Qt.ControlModifier\nGroupSwitchModifier = QtCore.Qt.GroupSwitchModifier\nShiftModifier = QtCore.Qt.ShiftModifier\nMetaModifier = QtCore.Qt.MetaModifier\n#endregion\n\ndef AltGr_Shortcut(Symbol,shift_Symbol):\n    if Keyboard_Remap_Works:\n        if keyboard.is_pressed(""shift""):\n            AltGr_Shift_Shortcut(shift_Symbol)\n        else:\n            keyboard.write(Symbol)\n            keyboard.release(""alt"")\n            keyboard.release(""control"")\n    else:\n        print(""Could not load External_Libraries.keyboard_master.keyboard"")\ndef AltGr_Shift_Shortcut(Symbol):\n    if Keyboard_Remap_Works:\n        keyboard.write(Symbol)\n        keyboard.release(""alt"")\n        keyboard.release(""control"")\n        keyboard.press(""shift"")\n    else:\n        print(""Could not load External_Libraries.keyboard_master.keyboard"")\ndef Superscript_Shortcut(Symbol):\n    if Keyboard_Remap_Works:\n        #keyboard.write(""\\x08"")\n        keyboard.write(Symbol)\n        keyboard.write("" "")\n        keyboard.write(""\\x08"")\n    else:\n        print(""Could not load External_Libraries.keyboard_master.keyboard"")\n\n#region ---------------------------------- Windows ----------------------------------\nclass AMaDiA_Internal_File_Display_Window(AWWF):\n    def __init__(self,FileName,parent = None):\n        try:\n            super(AMaDiA_Internal_File_Display_Window, self).__init__(parent,True)\n            self.setWindowTitle(FileName)\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_FileDialogInfoView))\n                \n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            \n            self.TextBrowser = QtWidgets.QTextBrowser(self)\n            self.TextBrowser.setObjectName(""TextBrowser"")\n\n\n            self.gridLayout.addWidget(self.TextBrowser, 0, 0, 0, 0)\n            self.setCentralWidget(self.centralwidget)\n\n            self.load(FileName)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n\n    def load(self,FileName):\n        try:\n            if ""Patchlog"" in FileName:\n                self.setWindowTitle(""Patchlog"")\n                #self.FolderPath = os.path.dirname(__file__)\n                FileName = os.path.join(QtWidgets.QApplication.instance().FolderPath,FileName)\n                with open(FileName,\'r\',encoding=""utf-8"") as text_file:\n                    Text = text_file.read()\n                \n                List = re.split(r""\\nv(0.+):(.+)"", Text)\n                \n                NList = []\n                i=1\n                while i < len(List):\n                    NList.append([List[i],""v""+List[i]+"":""+List[i+1],List[i+2]])\n                    i+=3\n                text = """"\n                for i in reversed(NList):\n                    desc = ""<ul>""+re.sub(r""^\\+ (.+)$"",r""\\t<li>\\1</li>"",\n                                        re.sub(r""^\\+\\+ (.+)$"",r""\\t\\t\\t<ul><li>\\1</li></ul>"",\n                                                re.sub(r""^\\+\\+\\+ (.+)$"",r""\\t\\t\\t\\t<ul><ul><li>\\1</li></ul></ul>"",\n                                                    re.sub(r""^\\+\\+\\+\\+ (.+)$"",r""\\t\\t\\t\\t\\t<ul><ul><ul><li>\\1</li></ul></ul></ul>"",i[2],\n                                                            flags=re.MULTILINE),\n                                                    flags=re.MULTILINE),\n                                                flags=re.MULTILINE),\n                                        flags=re.MULTILINE)+""</ul>""\n                    text += ""{}{}<br><br>"".format(i[1],desc)\n                self.TextBrowser.setText(text)\n            else:\n                self.setWindowTitle(FileName)\n                #self.FolderPath = os.path.dirname(__file__)\n                FileName = os.path.join(QtWidgets.QApplication.instance().FolderPath,FileName)\n                with open(FileName,\'r\',encoding=""utf-8"") as text_file:\n                    Text = text_file.read()\n                #self.TextBrowser.setPlainText(Text)\n                self.TextBrowser.setText(Text)\n        except common_exceptions:\n            NC(1,""Could not load {}"".format(str(FileName)),exc=sys.exc_info(),win=self.windowTitle(),func=""AMaDiA_Internal_File_Display_Window.load"",input=FileName)\n\n    def Scroll_To_End(self):\n        self.TextBrowser.verticalScrollBar().setValue(self.TextBrowser.verticalScrollBar().maximum())\n        \nclass AMaDiA_About_Window(AWWF):\n    def __init__(self,parent = None):\n        try:\n            super(AMaDiA_About_Window, self).__init__(parent)\n            self.setWindowTitle(""About AMaDiA"")\n            self.standardSize = (400, 600)\n            self.resize(*self.standardSize)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_DialogHelpButton))\n\n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            \n            self.TextBrowser = QtWidgets.QTextBrowser(self)\n            self.TextBrowser.setObjectName(""TextBrowser"")\n\n            self.gridLayout.addWidget(self.TextBrowser, 0, 0, 0, 0)\n            #self.layout = QtWidgets.QVBoxLayout()\n            #self.layout.addWidget(self.TextBrowser)\n            #self.setLayout(self.layout)\n            self.setCentralWidget(self.centralwidget)\n\n            #Text = WindowTitle+""\\nWIP: More coming soon""\n            #<p> Send comments, ideas and bug reports to: <a href=""mailto:a011235robin@gmail.com"">a011235robin@gmail.com</a></p>\n            aboutText = """"""\n            <p> <b>AMaDiA v%s</b> </p>\n            <p> By Robin \\""Astus\\"" Albers.</p>\n            <p> AMaDiA aims to provide the similar functionality as matlab or mathematica while providing a GUI that is fun to work with.</p>\n            <p> Furthermore the open source nature and the good documentation from SymPy (which is used for most calculations) allow for scientific work as the entire process can be analysed.</p>\n            <p> License is GNU GPLv3.</p>\n            <p> Repo: <a href=""https://github.com/AstusRush/AMaDiA"">https://github.com/AstusRush/AMaDiA</a></p>\n            <p>This instance of AMaDiA runs thanks to the following external projects:</p>\n            \n            <ul>\n                    <li><a href=""https://www.python.org/"">Python %s</a></li>\n                    <li><a href=""https://github.com/AstusRush/AGeLib"">AGeLib %s</a></li>\n                    <li><a href=""https://www.sympy.org/en/index.html"">SymPy %s</a></li>\n                    <li><a href=""https://numpy.org/"">Numpy %s</a></li>\n                    <li><a href=""https://matplotlib.org/"">MatplotLib %s</a></li>\n                    <li><a href=""https://github.com/boppreh/keyboard"">keyboard</a></li>\n                    <li><a href=""https://github.com/python-control/python-control/"">Python-Control</a></li>\n                    <li><a href=""https://www.qt.io/"">PyQt %s (Qt %s)</a></li>\n            </ul>\n            """""" % (Version,\n                ""%d.%d"" % (sys.version_info.major, sys.version_info.minor),\n                AGeLib.__version__,\n                sympy.__version__,\n                np.__version__,\n                matplotlib.__version__,\n                QtCore.PYQT_VERSION_STR,\n                QtCore.qVersion())\n            \n            self.TextBrowser.setText(aboutText)\n            self.TextBrowser.setOpenExternalLinks(True)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n\nclass AMaDiA_exec_Window(AWWF): #CLEANUP: use the standard AGeLib exec_Window\n    def __init__(self,parent = None):\n        try:\n            super(AMaDiA_exec_Window, self).__init__(parent, initTopBar=False)\n            self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True, IncludeAdvancedCB=True)\n            self.setWindowTitle(""Code Execution Window"")\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n                \n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            \n            self.Input_Field = AW.AMaDiA_TextEdit(self)\n            self.Input_Field.setObjectName(""Input_Field"")\n\n\n            self.gridLayout.addWidget(self.Input_Field, 0, 0, 0, 0)\n            self.setCentralWidget(self.centralwidget)\n\n            self.Input_Field.returnCtrlPressed.connect(self.execute_code)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.windowTitle(),func=""AMaDiA_exec_Window.__init__"")\n\n    def execute_code(self):\n        input_text = self.Input_Field.toPlainText()\n        try:\n            exec(input_text)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.windowTitle(),func=""AMaDiA_exec_Window.execute_code"",input=input_text)\n\nclass AMaDiA_options_window(AWWF, Ui_AMaDiA_Options):\n    def __init__(self,parent = None):\n        try:\n            super(AMaDiA_options_window, self).__init__(parent, includeTopBar=False, initTopBar=False, includeStatusBar=True)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_FileDialogListView))\n            self.setupUi(self)\n            self.TopBar = TopBar_Widget(self,False)\n            self.tabWidget.setCornerWidget(self.TopBar, QtCore.Qt.TopRightCorner)\n            self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True)\n            self.setWindowTitle(""Options"")\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n            self.tabWidget.setCurrentIndex(0)\n            \n            self.setAutoFillBackground(True)\n            self.ConnectSignals()\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n            \n    def ConnectSignals(self):\n        self.cb_O_AdvancedMode.clicked.connect(QtWidgets.QApplication.instance().ToggleAdvancedMode)\n        QtWidgets.QApplication.instance().S_advanced_mode_changed.connect(self.cb_O_AdvancedMode.setChecked)\n        self.cb_O_Remapper_global.toggled.connect(self.ToggleGlobalRemapper)\n        self.cb_O_PairHighlighter.toggled.connect(App().S_Highlighter.emit)\n\n    def ToggleGlobalRemapper(self):\n        try:\n            if self.cb_O_Remapper_global.isChecked():\n                self.cb_O_Remapper_local.setChecked(False)\n                self.cb_O_Remapper_local.setDisabled(True)\n                altgr = ""altgr+""\n                altgrShift = ""altgr+shift+""\n                #keyboard.on_press(print)\n                #keyboard.add_hotkey(""shift"",keyboard.release, args=(""altgr""),trigger_on_release=True)\n                #keyboard.block_key(""AltGr"")\n                #keyboard.add_hotkey(""altgr"",keyboard.release, args=(""alt+control""), suppress=True)\n                #keyboard.add_hotkey(""control+alt+altgr+shift"",keyboard.release, args=(""altgr+shift""), suppress=True)\n                for i in ART.KR_Map:\n                    if i[0]!="" "":\n                        if i[2] != "" "":\n                            Key = altgr + i[0]\n                            keyboard.add_hotkey(Key, AltGr_Shortcut, args=(i[2],i[3]), suppress=True, trigger_on_release=True)\n                            #keyboard.add_hotkey(Key, keyboard.write, args=(i[2]), suppress=True, trigger_on_release=True)\n                        if i[3] != "" "":\n                            Key = altgrShift + i[0]\n                            keyboard.add_hotkey(Key, AltGr_Shift_Shortcut, args=(i[3]), suppress=True, trigger_on_release=True)\n                            #keyboard.add_hotkey(Key, keyboard.write, args=(i[3]), suppress=True, trigger_on_release=True)\n                        if i[4] != "" "":\n                            Key = ""^+""+i[0]\n                            keyboard.add_hotkey(Key, Superscript_Shortcut, args=(i[4]), suppress=True, trigger_on_release=True)\n                            #keyboard.add_hotkey(Key, keyboard.write, args=(i[4]), suppress=True, trigger_on_release=True)\n            else:\n                keyboard.clear_all_hotkeys()\n                self.cb_O_Remapper_local.setEnabled(True)\n                self.cb_O_Remapper_local.setChecked(True)\n        except common_exceptions :\n            try:\n                NC(exc=sys.exc_info(),win=self.windowTitle(),func=""AMaDiA_options_window.ToggleGlobalRemapper"",input=""Failed to map {} to {}"".format(str(i),str(Key)))\n            except common_exceptions :\n                NC(exc=sys.exc_info(),win=self.windowTitle(),func=""AMaDiA_options_window.ToggleGlobalRemapper"",input=""Could not determine failed remap operation."")\n\n#endregion\n\n# ---------------------------------- Main Application ----------------------------------\nclass AMaDiA_Main_App(Main_App):\n #\n    # See:\n    # https://doc.qt.io/qt-5/qapplication.html\n    # https://doc.qt.io/qt-5/qguiapplication.html\n    # https://doc.qt.io/qt-5/qcoreapplication.html\n    S_New_Notification = QtCore.pyqtSignal(NC)\n    S_Highlighter = QtCore.pyqtSignal(bool)\n    def __init__(self, args):\n        super(AMaDiA_Main_App, self).__init__(args)\n        self.installEventFilter(self)\n        self.MainWindow = None\n        self.setApplicationName(""AMaDiA"")\n        self.setApplicationVersion(Version)\n        \n        self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_ComputerIcon))\n\n        self.Colour_Font_Init()\n        \n        self.AMaDiA_exec_Window_Window = None\n    \n    def eventFilter(self, source, event):\n        if event.type() == 6: # QtCore.QEvent.KeyPress\n            #if event.modifiers() == ControlModifier:\n            #    pass\n            #if event.modifiers() == AltModifier:\n            #    pass\n            #    #if event.key() == QtCore.Qt.Key_O: #Already part of AGeLib\n            #    #    self.Show_Options()\n            #    #    return True\n            if source == self.MainWindow: # THIS IS SPECIFIC TO AMaDiA_Main_Window\n                if event.modifiers() == ControlModifier:\n                    if event.key() == QtCore.Qt.Key_1:\n                        self.MainWindow.tabWidget.setCurrentIndex(0)\n                        self.MainWindow.Tab_1_InputField.setFocus()\n                        return True\n                    elif event.key() == QtCore.Qt.Key_2:\n                        self.MainWindow.tabWidget.setCurrentIndex(1)\n                        self.MainWindow.Tab_2_InputField.setFocus()\n                        return True\n                    elif event.key() == QtCore.Qt.Key_3:\n                        self.MainWindow.tabWidget.setCurrentIndex(2)\n                        if self.MainWindow.Tab_3_tabWidget.currentIndex() == 0:\n                            self.MainWindow.Tab_3_1_Formula_Field.setFocus()\n                        return True\n                    elif event.key() == QtCore.Qt.Key_4:\n                        self.MainWindow.tabWidget.setCurrentIndex(3)\n                        return True\n                    elif event.key() == QtCore.Qt.Key_5:\n                        self.MainWindow.tabWidget.setCurrentIndex(4)\n                        return True\n            try:  # THIS IS SPECIFIC TO AMaDiA_Main_Window # FEATURE: Add superscript Macros\n                #if self.MainWindow.Menu_Options_action_Use_Local_Keyboard_Remapper.isChecked():\n                if self.optionWindow.cb_O_Remapper_local.isChecked():\n                    modifiers = QtWidgets.QApplication.keyboardModifiers() # instead of event.modifiers() to be more reliable\n                    if modifiers == (GroupSwitchModifier | ShiftModifier) or modifiers == (ControlModifier | AltModifier | ShiftModifier):\n                        for i in ART.KR_Map:\n                            if event.key() == i[5] and i[3]!="" "":\n                                try:\n                                    if type(source) == QtWidgets.QLineEdit or type(source) == AstusChat_Client.InputFieldClass:\n                                        source.insert(i[3])\n                                        return True\n                                except:\n                                    pass\n                                try:\n                                    cursor = source.textCursor()\n                                    cursor.insertText(i[3])\n                                    return True\n                                except:\n                                    break\n                    elif modifiers == GroupSwitchModifier or modifiers == (ControlModifier | AltModifier):\n                        for i in ART.KR_Map:\n                            if event.key() == i[5] and i[2]!="" "":\n                                try:\n                                    if type(source) == QtWidgets.QLineEdit or type(source) == AstusChat_Client.InputFieldClass:\n                                        source.insert(i[2])\n                                        return True\n                                except:\n                                    pass\n                                try:\n                                    cursor = source.textCursor()\n                                    cursor.insertText(i[2])\n                                    return True\n                                except:\n                                    break\n            except AttributeError:\n                pass\n        return super(AMaDiA_Main_App, self).eventFilter(source, event)\n\n # ---------------------------------- Colour and Font ----------------------------------\n    #def Recolour(self, Colour = ""Dark""):\n    #    super(AMaDiA_Main_App, self).Recolour(Colour)\n    #    if self.MainWindow != None: # THIS IS SPECIFIC TO AMaDiA_Main_Window\n    #        try:\n    #            self.MainWindow.init_Animations_With_Colour()\n    #            brush = self.Palette.text()\n    #            for i in range(self.MainWindow.Tab_3_1_History.count()):\n    #                if self.MainWindow.Tab_3_1_History.item(i).data(100).current_ax == None:\n    #                    self.MainWindow.Tab_3_1_History.item(i).setForeground(brush)\n    #        except common_exceptions:\n    #            ExceptionOutput(sys.exc_info())\n                \n    def r_Recolour(self):\n        if self.MainWindow != None:\n            try:\n                self.MainWindow.init_Animations_With_Colour()\n                brush = self.Palette.text()\n                for i in range(self.MainWindow.Tab_3_1_History.count()):\n                    if self.MainWindow.Tab_3_1_History.item(i).data(100).current_ax == None:\n                        self.MainWindow.Tab_3_1_History.item(i).setForeground(brush)\n                self.MainWindow.Tab_1_InputField.setPalette(self.Palette2)\n                self.MainWindow.Tab_2_InputField.setPalette(self.Palette2)\n                self.MainWindow.Tab_3_1_Formula_Field.setPalette(self.Palette2)\n                self.MainWindow.Tab_4_FormulaInput.setPalette(self.Palette2)\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n\n # ---------------------------------- SubWindows ----------------------------------\n    def r_init_Options(self):\n        self.optionWindow = AMaDiA_options_window()\n    \n    #def Show_exec_Window(self): #CLEANUP: use the standard AGeLib exec_Window\n    #    if self.AMaDiA_exec_Window_Window == None:\n    #        self.AMaDiA_exec_Window_Window = AMaDiA_exec_Window()\n    #    self.AMaDiA_exec_Window_Window.show()\n\n # ---------------------------------- Other ----------------------------------\n\n    def r_CreateFolders(self):\n        try:\n            if self.AGeLibPathOK:\n                # Create Plots folder to save plots\n                self.PlotPath = os.path.join(os.path.join(self.AGeLibPath,""AMaDiA""),""Plots"")\n                os.makedirs(self.PlotPath,exist_ok=True)\n                # Create Config folder to save configs\n                self.ConfigFolderPath = os.path.join(os.path.join(self.AGeLibPath,""AMaDiA""),""Config"")\n                os.makedirs(self.ConfigFolderPath,exist_ok=True)\n            self.pathOK = False\n            # Find the install location of AMaDiA to load the help files\n            self.selfPath = os.path.abspath(__file__)\n            self.FolderPath = os.path.dirname(__file__)\n            # Check if the path that was returned is correct\n            filePath = os.path.join(self.FolderPath,""AMaDiA.py"")\n            filePath = pathlib.Path(filePath)\n            if filePath.is_file():\n                self.pathOK = True\n        except:\n            NC(1,""Could not create/validate AMaDiA folders"",exc=sys.exc_info())\n            \n\n\n\n# ---------------------------------- Main Window ----------------------------------\nclass AMaDiA_Main_Window(AWWF, Ui_AMaDiA_Main_Window):\n    S_Terminate_Threads = QtCore.pyqtSignal()\n    def __init__(self, MainApp, parent = None):\n        super(AMaDiA_Main_Window, self).__init__(parent,initTopBar=False)\n        \n        # Read all config files:\n        # FEATURE: Implement config files\n        \n        sympy.init_printing() # doctest: +SKIP\n        self.MainApp = MainApp #CLEANUP: remove self.MainApp since App() has replaced it\n        App().setMainWindow(self)\n        \n        #FEATURE: Add Statistic Tab to easily compare numbers and check impact of variables etc\n        #FEATURE: Make a subtab that makes https://www.youtube.com/watch?v=ovJcsL7vyrk and similar things plottable\n        \n        \n       # Build the UI\n        self.init_Menu()\n        self.setupUi(self)\n        self.TopBar.init(True,True,True)\n        self.TopBar.setObjectName(""TopBar"")\n        #self.TopBarGridLayout = QtWidgets.QGridLayout(self.TopBar)\n        #self.TopBarGridLayout.setContentsMargins(0, 0, 0, 0)\n        #self.TopBarGridLayout.setSpacing(0)\n        #self.TopBarGridLayout.setObjectName(""TopBarGridLayout"")\n        #self.TopBar.setLayout(self.TopBarGridLayout)\n        \n        self.standardSize = (906, 634)\n        self.resize(*self.standardSize)\n        \n        self.tabWidget.setContentsMargins(0,0,0,0)\n        #self.tabWidget.tabBar(). # Access the TabBar of the TabWidget\n        self.tabWidget.tabBar().setUsesScrollButtons(True)\n        self.tabWidget.tabBar().setGeometry(QtCore.QRect(0, 0, 906, 20)) # CLEANUP: Is this necessary?\n        self.tabWidget.tabBar().installEventFilter(self.TopBar)\n        \n        #self.MenuBar.setContentsMargins(0,0,0,0)\n        \n        #QtWidgets.QMainWindow.setMenuBar(self,self.MenuBar) # This allows the extension functionality but has no frame...\n        #self.setMenuBar(self.MenuBar) # This breaks the extension functionality but has a frame...\n        \n        #self.MenuBar.setCornerWidget(self.TopBar)\n        \n        self.Tab_3_1_Button_Plot_SymPy.setVisible(False) # CLEANUP: The Control Tab Has broken the Sympy plotter... Repairing it is not worth it... Remove this function...\n        \n        self.Tab_3_tabWidget.removeTab(1)# FEATURE: Add Complex plotter\n        \n        # TODO: Find place to display WindowTitle. Maybe with a TextLabel in the statusbar?\n        # MAYBE: Do something with the Statusbar\n        #self.statusbar.showMessage(WindowTitle)\n        \n        #self.statusbar.setSizeGripEnabled(False)\n        \n       # Set UI variables\n        #Set starting tabs\n        self.Tab_3_tabWidget.setCurrentIndex(0)\n        self.Tab_3_1_TabWidget.setCurrentIndex(0)\n        self.Tab_4_tabWidget.setCurrentIndex(0)\n        self.tabWidget.setCurrentIndex(0)\n        \n        #Set Splitter Start Values\n        self.Tab_2_UpperSplitter.setSizes([163,699])\n        self.Tab_2_LowerSplitter.setSizes([391,70])\n        self.Tab_3_1_splitter.setSizes([297,565])\n        #To configure use:\n        #print(self.Tab_2_UpperSplitter.sizes())\n        #print(self.Tab_2_LowerSplitter.sizes())\n        #print(self.Tab_3_1_splitter.sizes())\n        \n        \n       # Initialize subwindow variables\n        self.ControlWindow = None\n        self.AMaDiA_About_Window_Window = None\n        self.Chat = None\n        self.Sever = None\n        self.AMaDiA_Text_File_Window = {}\n       # Initialize important variables and lists\n        self.workingThreads = 0\n        self.LastOpenState = self.showNormal\n        self.Bool_PreloadLaTeX = True\n        self.firstrelease = False\n        self.keylist = []\n        self.Tab_2_Eval_checkBox.setCheckState(1)\n        #QtWidgets.QCheckBox.setCheckState(1)\n        \n       # Initialize Thread Related Things:\n        self.ThreadList = []\n        self.oldThreadpools = []\n        self.threadpool = QtCore.QThreadPool()#.globalInstance()\n        #self.threadpool.setMaxThreadCount(8)\n        print(""Multithreading with maximum %d threads (when in Threadpool mode)"" % self.threadpool.maxThreadCount())\n        # Thread Mode\n        self.Threading = ""POOL""\n        #self.Threading = ""LIST""\n        \n       # Set the Text\n        _translate = QtCore.QCoreApplication.translate\n        self.setWindowTitle(_translate(""AMaDiA"" , WindowTitle))\n        \n       # EventFilter\n        self.installEventFilter(self)\n        # Set up context menus for the histories and other list widgets\n        for i in self.findChildren(QtWidgets.QListWidget):\n            i.installEventFilter(self)\n        # Set up text input related Event Handlers\n        for i in self.findChildren(QtWidgets.QTextEdit):\n            i.installEventFilter(self)\n        for i in self.findChildren(QtWidgets.QLineEdit):\n            i.installEventFilter(self)\n        \n        # Activate Pretty-LaTeX-Mode if the Computer supports it\n        if AF.LaTeX_dvipng_Installed:\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setEnabled(True)\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setChecked(True)\n        \n       # Run other init methods\n        self.ConnectSignals()\n        #self.Colour_Font_Init()\n        App().Recolour() #IMPROVE: This takes long but is necessary to initialize the Plots.\n        #                                    This could probably be done in the init of the canvas to reduce start time\n        #       But the Signal S_ColourChanged as well as the method r_Recolour are now used for other UI elements as well thus Recolour MUST be called or the other inits must be changed, too\n        self.OtherContextMenuSetup()\n        self.InstallSyntaxHighlighter()\n        self.INIT_Animation()\n        \n       # Initialize the first equation in Tab 4\n        self.Tab_4_2_New_Equation_Name_Input.setText(""Equation 1"")\n        self.Tab_4_F_New_Equation()\n        self.Tab_4_2_New_Equation_Name_Input.clear()\n        self.Tab_4_1_Dimension_Input.setText("" 3x3 "")\n        self.Tab_4_Currently_Displayed = """"\n        self.Tab_4_Currently_Displayed_Solution = """"\n        \n       # Other things:\n        \n        # VALIDATE: Check if this fixes the bug on the Laptop --> The Bug is fixed but the question remains wether this is what fixed it\n        self.Tab_3_1_F_Clear()\n        #One Little Bug Fix:\n            #If using LaTeX Display in LaTeX Mode before using the Plotter for the first time it can happen that the plotter is not responsive until cleared.\n            #Thus the plotter is now cleared on program start to **hopefully** fix this...\n            #If it does not fix the problem a more elaborate method is required...\n            # A new variable that checks if the plot has already been used and if the LaTeX view has been used.\n            # If the first is False and the second True then clear when the plot button is pressed and change the variables to ensure that this only happens once\n            #       to not accidentally erase the plots of the user as this would be really bad...\n        \n        self.Tab_1_InputField.setFocus()\n        \n       # Welcome Message and preload LaTeX\n        msg = """"\n        if not AF.LaTeX_dvipng_Installed:\n            msg += ""Please install LaTeX and dvipng to enable the LaTeX output mode""\n        elif self.Bool_PreloadLaTeX:\n            print(""Starting LaTeX"")\n            self.Tab_2_Viewer.PreloadLaTeX()\n        if not slycot_Installed:\n            if msg != """":\n                msg += ""\\n\\n""\n            msg += ""slycot is not installed. The Control Tab might not work correctly\\n""\n            msg += ""If you have conda installed use: conda install -c conda-forge slycot\\n""\n            msg += ""Otherwise refer to: https://github.com/python-control/Slycot""\n        if not Keyboard_Remap_Works:\n            if msg != """":\n                msg += ""\\n\\n""\n            msg += ""The Keyboard Remapping does not work\\n""\n            msg += ""If you are using Linux you need to run as root to enable Keyboard Remapping""\n        if msg != """":\n            NC(3,msg,win=self.windowTitle(),func=""AMaDiA_Main_Window.__init__"")\n        else:\n            try:\n                msg = ""Welcome "" + getpass.getuser()\n                #msg += "". How can I be of service?""\n                NC(10,msg,win=self.windowTitle(),func=""AMaDiA_Main_Window.__init__"")\n            except:\n                Error = ExceptionOutput(sys.exc_info())\n                NC(10,""Welcome Dave"",err=str(Error),win=self.windowTitle(),func=""AMaDiA_Main_Window.__init__"")\n    \n # ---------------------------------- Init and Maintenance ----------------------------------\n\n    def ConnectSignals(self):\n        self.Menu_Options_action_ToggleCompactMenu.changed.connect(self.ToggleCompactMenu)\n        #self.Menu_Options_action_Use_Global_Keyboard_Remapper.toggled.connect(self.ToggleRemapper)\n        self.Menu_Options_action_Options.triggered.connect(App().Show_Options)\n        \n        self.Menu_Options_action_Advanced_Mode.toggled.connect(QtWidgets.QApplication.instance().ToggleAdvancedMode)\n        QtWidgets.QApplication.instance().S_advanced_mode_changed.connect(self.Menu_Options_action_Advanced_Mode.setChecked)\n        \n        App().optionWindow.cb_F_EvalF.toggled.connect(self.Menu_Options_action_Eval_Functions.setChecked)\n        self.Menu_Options_action_Eval_Functions.toggled.connect(App().optionWindow.cb_F_EvalF.setChecked)\n\n        App().optionWindow.cb_O_PairHighlighter.toggled.connect(self.Menu_Options_action_Highlighter.setChecked)\n        self.Menu_Options_action_Highlighter.toggled.connect(App().optionWindow.cb_O_PairHighlighter.setChecked)\n        self.Menu_Options_action_Highlighter.toggled.connect(App().S_Highlighter.emit)\n\n        self.Menu_DevOptions_action_Dev_Function.triggered.connect(self.Dev_Function)\n        self.Menu_DevOptions_action_Show_AMaDiA_exec_Window.triggered.connect(App().Show_exec_Window)\n        self.Menu_DevOptions_action_Use_Threadpool.changed.connect(self.ToggleThreadMode)\n        self.Menu_DevOptions_action_Terminate_All_Threads.triggered.connect(self.TerminateAllThreads)\n\n        self.Menu_Chat_action_Open_Client.triggered.connect(self.OpenClient)\n        self.Menu_Chat_action_Open_Server.triggered.connect(self.OpenServer)\n        \n        #self.Menu_Colour_action_Dark.triggered.connect(lambda: self.Recolour(""Dark""))\n        #self.Menu_Colour_action_Bright.triggered.connect(lambda: self.Recolour(""Bright""))\n        \n        self.Menu_OtherWindows_action_SystemControl.triggered.connect(self.OpenControlWindow)\n\n        self.Menu_Help_action_Examples.triggered.connect(lambda: self.Show_AMaDiA_Text_File(""InputExamples.txt""))\n        self.Menu_Help_action_Helpful_Commands.triggered.connect(lambda: self.Show_AMaDiA_Text_File(""Helpful_Useable_Syntax.txt""))\n        self.Menu_Help_action_Patchlog.triggered.connect(lambda: self.Show_AMaDiA_Text_File(""Patchlog.txt""))\n        self.Menu_Help_action_About.triggered.connect(self.Show_About)\n        \n        self.Tab_1_History.itemDoubleClicked.connect(self.Tab_1_F_Item_doubleClicked)\n        self.Tab_1_InputField.returnPressed.connect(self.Tab_1_F_Calculate_Field_Input)\n        \n        self.Tab_2_History.itemDoubleClicked.connect(self.Tab_2_F_Item_doubleClicked)\n        self.Tab_2_LaTeXCopyButton.clicked.connect(self.Tab_2_Viewer.action_Copy_LaTeX)\n        self.Tab_2_ConvertButton.clicked.connect(self.Tab_2_F_Convert)\n        self.Tab_2_InputField.returnCtrlPressed.connect(self.Tab_2_F_Convert)\n        \n        self.Tab_3_1_History.itemDoubleClicked.connect(self.Tab_3_1_F_Item_doubleClicked)\n        self.Tab_3_1_Button_Plot.clicked.connect(self.Tab_3_1_F_Plot_Button)\n        self.Tab_3_1_Formula_Field.returnPressed.connect(self.Tab_3_1_F_Plot_Button)\n        self.Tab_3_1_Button_Clear.clicked.connect(self.Tab_3_1_F_Clear)\n        self.Tab_3_1_Button_Plot_SymPy.clicked.connect(self.Tab_3_1_F_Sympy_Plot_Button)\n        self.Tab_3_1_RedrawPlot_Button.clicked.connect(self.Tab_3_1_F_RedrawPlot)\n        self.Tab_3_1_Button_SavePlot.clicked.connect(self.action_tab_3_tab_1_Display_SavePlt)\n        \n        self.Tab_4_FormulaInput.returnPressed.connect(self.Tab_4_F_Update_Equation)\n        self.Tab_4_1_Dimension_Input.returnPressed.connect(self.Tab_4_F_Config_Matrix_Dim)\n        self.Tab_4_1_Configure_Button.clicked.connect(self.Tab_4_F_Config_Matrix_Dim)\n        self.Tab_4_1_Name_Input.returnPressed.connect(self.Tab_4_F_Save_Matrix)\n        self.Tab_4_1_Save_Matrix_Button.clicked.connect(self.Tab_4_F_Save_Matrix)\n        self.Tab_4_2_New_Equation_Button.clicked.connect(self.Tab_4_F_New_Equation)\n        self.Tab_4_2_New_Equation_Name_Input.returnPressed.connect(self.Tab_4_F_New_Equation)\n        self.Tab_4_2_Load_Selected_Button.clicked.connect(self.Tab_4_F_Load_Selected_Equation)\n    \n    def init_Menu(self,FirstTime=True):\n        if FirstTime:\n            self.Menu = QtWidgets.QMenu(self)\n            self.Menu.setObjectName(""Menu"")\n            #self.MenuBar = AW.MMenuBar(self)\n            #self.MenuBar.setObjectName(""MenuBar"")\n       # Create submenus\n        if FirstTime:\n            self.Menu_Options = QtWidgets.QMenu(self.Menu)\n            self.Menu_Options.setObjectName(""Menu_Options"")\n            self.Menu_DevOptions = QtWidgets.QMenu(self.Menu)\n            self.Menu_DevOptions.setObjectName(""Menu_DevOptions"")\n            self.Menu_Chat = QtWidgets.QMenu(self.Menu)\n            self.Menu_Chat.setObjectName(""Menu_Chat"")\n            #self.Menu_Colour = QtWidgets.QMenu(self.Menu)\n            #self.Menu_Colour.setObjectName(""Menu_Colour"")\n            self.Menu_OtherWindows = QtWidgets.QMenu(self.Menu)\n            self.Menu_OtherWindows.setObjectName(""Menu_OtherWindows"")\n            self.Menu_Help = QtWidgets.QMenu(self.Menu)\n            self.Menu_Help.setObjectName(""Menu_Help"")\n            #self.Menu_Options_MathRemap = QtWidgets.QMenu(self.Menu_Options)\n            #self.Menu_Options_MathRemap.setObjectName(""Menu_Options_MathRemap"")\n       # Create Actions\n        if FirstTime:\n            self.Menu_Options_action_Options = MenuAction(self)\n            self.Menu_Options_action_Options.setObjectName(""Menu_Options_action_Options"")\n            self.Menu_Options_action_ToggleCompactMenu = MenuAction(self)\n            self.Menu_Options_action_ToggleCompactMenu.setCheckable(True)\n            self.Menu_Options_action_ToggleCompactMenu.setObjectName(""Menu_Options_action_ToggleCompactMenu"")\n            self.Menu_Options_action_ToggleCompactMenu.setChecked(False)\n            self.Menu_Options_action_Advanced_Mode = MenuAction(self)\n            self.Menu_Options_action_Advanced_Mode.setCheckable(True)\n            self.Menu_Options_action_Advanced_Mode.setObjectName(""Menu_Options_action_Advanced_Mode"")\n            self.Menu_Options_action_Eval_Functions = MenuAction(self)\n            self.Menu_Options_action_Eval_Functions.setCheckable(True)\n            self.Menu_Options_action_Eval_Functions.setChecked(True)\n            self.Menu_Options_action_Eval_Functions.setObjectName(""Menu_Options_action_Eval_Functions"")\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display = MenuAction(self)\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setCheckable(True)\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setEnabled(False)\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setObjectName(""Menu_Options_action_Use_Pretty_LaTeX_Display"")\n            self.Menu_Options_action_Syntax_Highlighter = MenuAction(self)\n            self.Menu_Options_action_Syntax_Highlighter.setCheckable(True)\n            self.Menu_Options_action_Syntax_Highlighter.setChecked(True)\n            self.Menu_Options_action_Syntax_Highlighter.setObjectName(""Menu_Options_action_Syntax_Highlighter"")\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper = MenuAction(self)\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper.setCheckable(True)\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper.setChecked(True)\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper.setObjectName(""Menu_Options_action_Use_Local_Keyboard_Remapper"")\n            #self.Menu_Options_action_Use_Global_Keyboard_Remapper = MenuAction(self)\n            #self.Menu_Options_action_Use_Global_Keyboard_Remapper.setCheckable(True)\n            #self.Menu_Options_action_Use_Global_Keyboard_Remapper.setObjectName(""Menu_Options_action_Use_Global_Keyboard_Remapper"")\n            self.Menu_Options_action_Highlighter = MenuAction(self)\n            self.Menu_Options_action_Highlighter.setCheckable(True)\n            self.Menu_Options_action_Highlighter.setChecked(True)\n            self.Menu_Options_action_Highlighter.setObjectName(""Menu_Options_action_Highlighter"")\n\n            self.Menu_DevOptions_action_Dev_Function = MenuAction(self)\n            self.Menu_DevOptions_action_Dev_Function.setObjectName(""Menu_DevOptions_action_Dev_Function"")\n            self.Menu_DevOptions_action_Show_AMaDiA_exec_Window = MenuAction(self)\n            self.Menu_DevOptions_action_Show_AMaDiA_exec_Window.setObjectName(""Menu_DevOptions_action_Show_AMaDiA_exec_Window"")\n            self.Menu_DevOptions_action_Use_Threadpool = MenuAction(self)\n            self.Menu_DevOptions_action_Use_Threadpool.setCheckable(True)\n            self.Menu_DevOptions_action_Use_Threadpool.setChecked(True)\n            self.Menu_DevOptions_action_Use_Threadpool.setObjectName(""Menu_DevOptions_action_Use_Threadpool"")\n            self.Menu_DevOptions_action_Terminate_All_Threads = MenuAction(self)\n            self.Menu_DevOptions_action_Terminate_All_Threads.setObjectName(""Menu_DevOptions_action_Terminate_All_Threads"")\n\n            self.Menu_Chat_action_Open_Client = MenuAction(self)\n            self.Menu_Chat_action_Open_Client.setObjectName(""Menu_Chat_action_Open_Client"")\n            self.Menu_Chat_action_Open_Server = MenuAction(self)\n            self.Menu_Chat_action_Open_Server.setObjectName(""Menu_Chat_action_Open_Server"")\n\n            #self.Menu_Colour_action_Dark = MenuAction(self)\n            #self.Menu_Colour_action_Dark.setObjectName(""Menu_Colour_action_Dark"")\n            #self.Menu_Colour_action_Bright = MenuAction(self)\n            #self.Menu_Colour_action_Bright.setObjectName(""Menu_Colour_action_Bright"")\n            \n            self.Menu_OtherWindows_action_SystemControl = MenuAction(self)\n            self.Menu_OtherWindows_action_SystemControl.setObjectName(""Menu_OtherWindows_action_SystemControl"")\n\n            self.Menu_Help_action_Examples = MenuAction(self)\n            self.Menu_Help_action_Examples.setObjectName(""Menu_Help_action_Examples"")\n            self.Menu_Help_action_Helpful_Commands = MenuAction(self)\n            self.Menu_Help_action_Helpful_Commands.setObjectName(""Menu_Help_action_Helpful_Commands"")\n            self.Menu_Help_action_License = MenuAction(self)\n            self.Menu_Help_action_License.setObjectName(""Menu_Help_action_License"")\n            self.Menu_Help_action_About = MenuAction(self)\n            self.Menu_Help_action_About.setObjectName(""Menu_Help_action_About"")\n            self.Menu_Help_action_Patchlog = MenuAction(self)\n            self.Menu_Help_action_Patchlog.setObjectName(""Menu_Help_action_Patchlog"")\n       # Add the Actions to the Submenus\n        if FirstTime:\n            self.Menu_Options.addAction(self.Menu_Options_action_Options)\n            self.Menu_Options.addAction(self.Menu_Options_action_ToggleCompactMenu)\n            self.Menu_Options.addAction(self.Menu_Options_action_Advanced_Mode)\n            self.Menu_Options.addAction(self.Menu_Options_action_Eval_Functions)\n            self.Menu_Options.addAction(self.Menu_Options_action_Use_Pretty_LaTeX_Display)\n            #self.Menu_Options_MathRemap.addAction(self.Menu_Options_action_Use_Local_Keyboard_Remapper)\n            #self.Menu_Options_MathRemap.addAction(self.Menu_Options_action_Use_Global_Keyboard_Remapper)\n            #self.Menu_Options.addAction(self.Menu_Options_MathRemap.menuAction())\n            self.Menu_Options.addAction(self.Menu_Options_action_Highlighter)\n            \n            self.Menu_DevOptions.addAction(self.Menu_DevOptions_action_Dev_Function)\n            self.Menu_DevOptions.addAction(self.Menu_DevOptions_action_Show_AMaDiA_exec_Window)\n            self.Menu_DevOptions.addAction(self.Menu_DevOptions_action_Use_Threadpool)\n            self.Menu_DevOptions.addAction(self.Menu_DevOptions_action_Terminate_All_Threads)\n            \n            self.Menu_Chat.addAction(self.Menu_Chat_action_Open_Client)\n            self.Menu_Chat.addAction(self.Menu_Chat_action_Open_Server)\n            \n            #self.Menu_Colour.addAction(self.Menu_Colour_action_Dark)\n            #self.Menu_Colour.addAction(self.Menu_Colour_action_Bright)\n            \n            self.Menu_OtherWindows.addAction(self.Menu_OtherWindows_action_SystemControl)\n            \n            self.Menu_Help.addAction(self.Menu_Help_action_Examples)\n            self.Menu_Help.addAction(self.Menu_Help_action_Helpful_Commands)\n            self.Menu_Help.addAction(self.Menu_Help_action_Patchlog)\n            self.Menu_Help.addAction(self.Menu_Help_action_About)\n       # Add submenus to Menu\n        self.Menu.addAction(self.Menu_Options.menuAction())\n        self.MenuBar.addAction(self.Menu_Options.menuAction())\n        self.Menu.addAction(self.Menu_DevOptions.menuAction())\n        self.MenuBar.addAction(self.Menu_DevOptions.menuAction())\n        #self.Menu.addAction(self.Menu_Colour.menuAction())\n        #self.MenuBar.addAction(self.Menu_Colour.menuAction())\n        self.Menu.addAction(self.Menu_Chat.menuAction())\n        self.MenuBar.addAction(self.Menu_Chat.menuAction())\n        self.Menu.addAction(self.Menu_OtherWindows.menuAction())\n        self.MenuBar.addAction(self.Menu_OtherWindows.menuAction())\n        self.Menu.addAction(self.Menu_Help.menuAction())\n        self.MenuBar.addAction(self.Menu_Help.menuAction())\n        \n       # Set the text of the menus\n        if FirstTime:\n            _translate = QtCore.QCoreApplication.translate\n            self.Menu_Options.setTitle(_translate(""AMaDiA_Main_Window"", ""O&ptions""))\n            self.Menu_DevOptions.setTitle(_translate(""AMaDiA_Main_Window"", ""DevOptions""))\n            self.Menu_Chat.setTitle(_translate(""AMaDiA_Main_Window"", ""Chat""))\n            #self.Menu_Colour.setTitle(_translate(""AMaDiA_Main_Window"", ""Colour""))\n            self.Menu_OtherWindows.setTitle(_translate(""AMaDiA_Main_Window"", ""More Windows""))\n            self.Menu_Help.setTitle(_translate(""AMaDiA_Main_Window"", ""Help""))\n\n            self.Menu_Options_action_Options.setText(_translate(""AMaDiA_Main_Window"", ""&Options""))\n            self.Menu_Options_action_Options.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+O""))\n            self.Menu_Options_action_ToggleCompactMenu.setText(_translate(""AMaDiA_Main_Window"", ""&Compact Menu""))\n            self.Menu_Options_action_ToggleCompactMenu.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+C""))\n            self.Menu_Options_action_Advanced_Mode.setText(_translate(""AMaDiA_Main_Window"", ""&Advanced Mode""))\n            self.Menu_Options_action_Advanced_Mode.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+A""))\n            self.Menu_Options_action_Eval_Functions.setText(_translate(""AMaDiA_Main_Window"", ""&Eval Functions""))\n            self.Menu_Options_action_Eval_Functions.setToolTip(_translate(""AMaDiA_Main_Window"", ""If unchecked functions that would return a float are not evaluated to ensure readability""))\n            self.Menu_Options_action_Eval_Functions.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+E""))\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setText(_translate(""AMaDiA_Main_Window"", ""Use Pretty &LaTeX Display""))\n            self.Menu_Options_action_Use_Pretty_LaTeX_Display.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+L""))\n            self.Menu_Options_action_Syntax_Highlighter.setText(_translate(""AMaDiA_Main_Window"", ""Syntax Highlighter""))\n            self.Menu_Options_action_Highlighter.setToolTip(_translate(""AMaDiA_Main_Window"", ""Syntax Highlighter for Brackets""))\n            self.Menu_Options_action_Highlighter.setText(_translate(""AMaDiA_Main_Window"", ""Highlighter""))\n            \n            #self.Menu_Options_MathRemap.setTitle(_translate(""AMaDiA_Main_Window"", ""MathKeyboard""))\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>Use (Shift+)AltGr+Key to type Mathematical Symbols.<br/>Refer to AMaDiA_ReplacementTables for mapping.<br/>For a Remapping that works on all applications use the Global Remapper in the Options.</p></body></html>""))\n            #self.Menu_Options_action_Use_Local_Keyboard_Remapper.setText(_translate(""AMaDiA_Main_Window"", ""Local Keyboard Remapper""))\n            #self.Menu_Options_action_Use_Global_Keyboard_Remapper.setText(_translate(""AMaDiA_Main_Window"", ""Global Keyboard Remapper""))\n            #self.Menu_Options_action_Use_Global_Keyboard_Remapper.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>Use (Shift+)AltGr+Key to type Mathematical Symbols.<br/>Refer to AMaDiA_ReplacementTables for mapping.<br/>This works for all inputs including those in other applications!<br/>(This might cause problems with anti cheat systems in games. Use with care.)</p></body></html>""))\n\n            self.Menu_DevOptions_action_Dev_Function.setText(_translate(""AMaDiA_Main_Window"", ""&Dev Function""))\n            self.Menu_DevOptions_action_Dev_Function.setShortcut(_translate(""AMaDiA_Main_Window"", ""Alt+D""))\n            self.Menu_DevOptions_action_Show_AMaDiA_exec_Window.setText(_translate(""AMaDiA_Main_Window"", ""Show Debug Terminal""))\n            self.Menu_DevOptions_action_Use_Threadpool.setText(_translate(""AMaDiA_Main_Window"", ""Use Threadpool""))\n            self.Menu_DevOptions_action_Terminate_All_Threads.setText(_translate(""AMaDiA_Main_Window"", ""Terminate All Threads""))\n            self.Menu_DevOptions_action_Terminate_All_Threads.setToolTip(_translate(""AMaDiA_Main_Window"", ""Unstable, especially in Threadpool-mode""))\n\n            self.Menu_Chat_action_Open_Client.setText(_translate(""AMaDiA_Main_Window"", ""Open Client""))\n            self.Menu_Chat_action_Open_Server.setText(_translate(""AMaDiA_Main_Window"", ""Open Server""))\n\n            #self.Menu_Colour_action_Dark.setText(_translate(""AMaDiA_Main_Window"", ""Dark""))\n            #self.Menu_Colour_action_Bright.setText(_translate(""AMaDiA_Main_Window"", ""Bright""))\n            \n            self.Menu_OtherWindows_action_SystemControl.setText(_translate(""AMaDiA_Main_Window"", ""System Control""))\n\n            self.Menu_Help_action_Examples.setText(_translate(""AMaDiA_Main_Window"", ""Examples""))\n            self.Menu_Help_action_Helpful_Commands.setText(_translate(""AMaDiA_Main_Window"", ""Helpful Commands""))\n            self.Menu_Help_action_License.setText(_translate(""AMaDiA_Main_Window"", ""License""))\n            self.Menu_Help_action_About.setText(_translate(""AMaDiA_Main_Window"", ""About""))\n            self.Menu_Help_action_Patchlog.setText(_translate(""AMaDiA_Main_Window"", ""Patchlog""))\n\n    def Recolour(self, Colour = ""Dark""):\n        App().Recolour(Colour)\n        \n    def InstallSyntaxHighlighter(self):\n        #self.Tab_1_InputField_BracesHighlighter = AW.BracesHighlighter(self.Tab_1_InputField.document())\n        pass\n\n    def INIT_Animation(self):\n        self.init_Animations_With_Colour()\n\n    def init_Animations_With_Colour(self):\n        pass#self.init_Notification_Flash()\n        \n # ---------------------------------- Option Toolbar Functions ----------------------------------\n    def Dev_Function(self):\n        #AC.ReloadModules()\n        #AF.ReloadModules()\n        #AC.ReloadModules()\n        #AT.ReloadModules()\n        #AW.ReloadModules()\n        #importlib.reload(AW)\n        #importlib.reload(AF)\n        #importlib.reload(AC)\n        #importlib.reload(ART)\n        #importlib.reload(AT)\n        #\n        #self.ColourMain()\n\n        NC(3,""The DevFunction is currently not assigned"",win=self.windowTitle(),func=""AMaDiA_Main_Window.Dev_Function"")\n\n    def ToggleCompactMenu(self):\n        #TODO: The size behaves weird when compact->scaling-up->switching->scaling-down\n        self.init_Menu(False)\n        if self.Menu_Options_action_ToggleCompactMenu.isChecked():\n            self.MenuBar.setVisible(False)\n            self.MenuBar.setParent(self)\n            self.TopBar.setParent(self)\n            self.setMenuBar(None)\n            self.MenuBar.setCornerWidget(None)\n            self.tabWidget.setCornerWidget(self.TopBar, QtCore.Qt.TopRightCorner)\n            self.TopBar.setVisible(True)\n            #self.tabWidget.tabBar().setUsesScrollButtons(True)\n            self.TopBar.setMinimumHeight(self.MenuBar.minimumHeight())\n            self.TopBar.CloseButton.setMinimumHeight(self.MenuBar.minimumHeight())\n        else:\n            self.MenuBar.setVisible(True)\n            self.setMenuBar(self.MenuBar)\n            #for i in self.findChildren(QtWidgets.QMenu):\n            #    i.setPalette(self.Palette)\n            #for i in self.findChildren(QtWidgets.QMenu):\n            #    i.setFont(self.font())\n            self.TopBar.setParent(self)\n            self.tabWidget.setCornerWidget(None)\n            self.MenuBar.setCornerWidget(self.TopBar, QtCore.Qt.TopRightCorner)\n            self.MenuBar.updateGeometry()\n            self.TopBar.setVisible(True)\n            #self.tabWidget.tabBar().setUsesScrollButtons(False)\n            ##Palette and font need to be reset to wake up the MenuBar painter and font-setter\n            ###self.setPalette(self.style().standardPalette())\n            #App().setPalette(self.style().standardPalette())\n            ###self.setPalette(self.Palette)\n            #App().setPalette(App().Palette)\n            \n            # VALIDATE: are the following 6 lines necessary if self.MenuBar.updateGeometry() is called before?\n            org_font = self.font()\n            font = QtGui.QFont()\n            font.setFamily(""unifont"")\n            font.setPointSize(9)\n            App().SetFont(font)\n            App().SetFont(org_font)\n            \n            self.TopBar.setMinimumHeight(self.tabWidget.tabBar().minimumHeight())\n            self.TopBar.CloseButton.setMinimumHeight(self.tabWidget.tabBar().minimumHeight())\n            \n    def RUNTEST(self):\n        for i in Test_Input:\n            self.Tab_1_InputField.setText(i)\n            self.Tab_1_F_Calculate_Field_Input()\n        Text = ""Expected Entries after all calculations: ""+str(len(Test_Input))\n        print(Text)\n        self.Tab_1_InputField.setText(Text)\n\n    def ToggleThreadMode(self):\n        if self.Menu_DevOptions_action_Use_Threadpool.isChecked():\n            self.Threading = ""POOL""\n        else:\n            self.Threading = ""LIST""\n        \n # ---------------------------------- SubWindows ----------------------------------\n    def Show_AMaDiA_Text_File(self,FileName):\n        if not (FileName in self.AMaDiA_Text_File_Window):\n            self.AMaDiA_Text_File_Window[FileName] = AMaDiA_Internal_File_Display_Window(FileName)\n        self.AMaDiA_Text_File_Window[FileName].load(FileName)\n        self.AMaDiA_Text_File_Window[FileName].show()\n        QtWidgets.QApplication.instance().processEvents()\n        self.AMaDiA_Text_File_Window[FileName].positionReset()\n        QtWidgets.QApplication.instance().processEvents()\n        self.AMaDiA_Text_File_Window[FileName].activateWindow()\n        \n    def AMaDiA_Text_File_ScrollToEnd(self,window):\n        try:\n            window.Scroll_To_End()\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n        \n    def Show_About(self):\n        if self.AMaDiA_About_Window_Window == None:\n            self.AMaDiA_About_Window_Window = AMaDiA_About_Window()\n        self.AMaDiA_About_Window_Window.show()\n        QtWidgets.QApplication.instance().processEvents()\n        self.AMaDiA_About_Window_Window.positionReset()\n        QtWidgets.QApplication.instance().processEvents()\n        self.AMaDiA_About_Window_Window.activateWindow()\n\n    def OpenClient(self):\n        if self.Chat == None:\n            self.Chat = AstusChat_Client.MainWindow()\n        self.Chat.show()\n        QtWidgets.QApplication.instance().processEvents()\n        self.Chat.activateWindow()\n\n    def OpenServer(self):\n        if self.Sever == None:\n            self.Sever = AstusChat_Server.MainWindow()\n        self.Sever.show()\n        QtWidgets.QApplication.instance().processEvents()\n        self.Sever.activateWindow()\n\n    def OpenControlWindow(self):\n        try:\n            if self.ControlWindow == None:\n                from AMaDiA_Files.AMaDiA_SystemControl import AMaDiA_Control_Window # pylint: disable=no-name-in-module\n                self.ControlWindow = AMaDiA_Control_Window()\n            self.ControlWindow.show()\n            QtWidgets.QApplication.instance().processEvents()\n            self.ControlWindow.positionReset()\n            QtWidgets.QApplication.instance().processEvents()\n            self.ControlWindow.activateWindow()\n        except:\n            NC(lvl=1,msg=""Could not open Control Window"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.OpenControlWindow"",win=self.windowTitle())\n\n # ---------------------------------- Events and Context Menu ----------------------------------\n    def OtherContextMenuSetup(self):\n        try:\n            self.Tab_3_1_Display.canvas.mpl_connect(\'button_press_event\', self.Tab_3_1_Display_Context_Menu)\n        except:\n            NC(lvl=4,msg=""Could not update Tab_3_1_Display context menu"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.OtherContextMenuSetup"",win=self.windowTitle())\n        try:\n            self.Tab_4_Display.canvas.mpl_disconnect(self.Tab_4_Display.ContextMenu_cid)\n            self.Tab_4_Display.canvas.mpl_connect(\'button_press_event\', self.Tab_4_Display_Context_Menu)\n        except:\n            NC(lvl=4,msg=""Could not update Tab_4_Display context menu"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.OtherContextMenuSetup"",win=self.windowTitle())\n        \n        \n  # ---------------------------------- 2D Plot Context Menu ---------------------------------- \n    def Tab_3_1_Display_Context_Menu(self,event):\n        #print(\'%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f\' %\n        #      (\'double\' if event.dblclick else \'single\', event.button,\n        #       event.x, event.y, event.xdata, event.ydata))\n        if event.button == 3:\n            menu = QtWidgets.QMenu()\n            action = menu.addAction(\'Save Plot\')\n            action.triggered.connect(self.action_tab_3_tab_1_Display_SavePlt)\n            cursor = QtGui.QCursor()\n            menu.setPalette(self.palette())\n            menu.setFont(self.font())\n            menu.exec_(cursor.pos())\n             \n  # ---------------------------------- Multi-Dim Display Context Menu ---------------------------------- \n    def Tab_4_Display_Context_Menu(self,event):\n        #print(\'%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f\' %\n        #      (\'double\' if event.dblclick else \'single\', event.button,\n        #       event.x, event.y, event.xdata, event.ydata))\n        if event.button == 3:\n            menu = QtWidgets.QMenu()\n            action = menu.addAction(\'Copy Equation\')\n            action.triggered.connect(self.action_tab_4_Display_Copy_Displayed)\n            action = menu.addAction(\'Copy Solution\')\n            action.triggered.connect(self.action_tab_4_Display_Copy_Displayed_Solution)\n            menu = self.Tab_4_Display.add_context_action(menu)\n            cursor = QtGui.QCursor()\n            menu.setPalette(self.palette())\n            menu.setFont(self.font())\n            menu.exec_(cursor.pos())\n\n # ---------------------------------- Event Filter ----------------------------------\n\n    def eventFilter(self, source, event):\n        # TODO: Add more mouse button functionality! See https://doc.qt.io/qt-5/qt.html#MouseButton-enum and https://doc.qt.io/qt-5/qmouseevent.html\n        #print(event.type())\n        #if event.type() == 6: # QtCore.QEvent.KeyPress #CLEANUP: Already part of AGeLib\n        # # ---------------------------------- Full Screen ----------------------------------\n        #    if event.key() == QtCore.Qt.Key_F11 and source is self: # F11 to toggle Fullscreen\n        #        if not self.isFullScreen():\n        #            if self.isMaximized():\n        #                self.LastOpenState = self.showMaximized\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        #            else:\n        #                self.LastOpenState = self.showNormal\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        #            self.showFullScreen()\n        #        else:\n        #            if self.LastOpenState == self.showMaximized:\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        #            else:\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        #            self.LastOpenState()\n        if event.type() == 82: # QtCore.QEvent.ContextMenu\n         # ---------------------------------- Tab_4 Matrix List Context Menu ----------------------------------\n            if (source is self.Tab_4_Matrix_List) and source.itemAt(event.pos()):\n                menu = QtWidgets.QMenu()\n                action = menu.addAction(\'Load to Editor\')\n                action.triggered.connect(lambda: self.action_tab_4_M_Load_into_Editor(source,event))\n                action = menu.addAction(\'Display\')\n                action.triggered.connect(lambda: self.action_tab_4_M_Display(source,event))\n                action = menu.addAction(\'Copy as String\')\n                action.triggered.connect(lambda: self.action_tab_4_M_Copy_string(source,event))\n                action = menu.addAction(\'Delete\')\n                action.triggered.connect(lambda: self.action_tab_4_M_Delete(source,event))\n                menu.setPalette(self.palette())\n                menu.setFont(self.font())\n                menu.exec_(event.globalPos())\n                return True\n        #elif...\n        return super(AMaDiA_Main_Window, self).eventFilter(source, event) # let the normal eventFilter handle the event\n    \n # ---------------------------------- Tab_4_Matrix_List Context Menu Actions/Functions ----------------------------------\n    def action_tab_4_M_Load_into_Editor(self,source,event):\n        item = source.itemAt(event.pos())\n        Name = item.data(100)\n        Matrix = item.data(101)\n        self.Tab_4_F_Load_Matrix(Name,Matrix)\n    \n    def action_tab_4_M_Display(self,source,event):\n        item = source.itemAt(event.pos())\n        Name = item.data(100)\n        Matrix = item.data(101)\n        self.Tab_4_F_Display_Matrix(Name,Matrix)\n    \n    def action_tab_4_M_Copy_string(self,source,event):\n        item = source.itemAt(event.pos())\n        QApplication.clipboard().setText(str(item.data(101)))\n    \n    def action_tab_4_M_Delete(self,source,event):\n        # FEATURE: Paperbin for matrices: If only one item was deleted save it in a temporary List item (The same as the duplicate item from the save function)\n        listItems=source.selectedItems()\n        if not listItems: return        \n        for item in listItems:\n            a = source.takeItem(source.row(item))\n            del self.Tab_4_Active_Equation.Variables[a.data(100)]\n         \n # ---------------------------------- Tab_3_1_Display_Context_Menu ----------------------------------\n    def action_tab_3_tab_1_Display_SavePlt(self):\n        if App().AGeLibPathOK:\n            Filename = AF.cTimeFullStr(""-"")\n            Filename += "".png""\n            Filename = os.path.join(App().PlotPath,Filename)\n            try:\n                print(Filename)\n                self.Tab_3_1_Display.canvas.fig.savefig(Filename , facecolor=App().BG_Colour , edgecolor=App().BG_Colour )\n            except:\n                NC(lvl=1,msg=""Could not save Plot: "",exc=sys.exc_info(),func=""AMaDiA_Main_Window.action_tab_3_tab_1_Display_SavePlt"",win=self.windowTitle(),input=Filename)\n            else:\n                NC(3,""Saved plot as: {}"".format(Filename),func=""AMaDiA_Main_Window.action_tab_3_tab_1_Display_SavePlt"",win=self.windowTitle(),input=Filename)\n        else:\n            print(""Could not save Plot: Could not validate save location"")\n            NC(1,""Could not save Plot: Could not validate save location"",func=""AMaDiA_Main_Window.action_tab_3_tab_1_Display_SavePlt"",win=self.windowTitle(),input=App().AGeLibPath)\n         \n # ---------------------------------- Tab_4_Display_Context_Menu ----------------------------------\n    def action_tab_4_Display_Copy_Displayed(self):\n        QApplication.clipboard().setText(self.Tab_4_Currently_Displayed)\n        \n    def action_tab_4_Display_Copy_Displayed_Solution(self):\n        QApplication.clipboard().setText(self.Tab_4_Currently_Displayed_Solution)\n \n # ---------------------------------- HistoryHandler ----------------------------------\n\n    def HistoryHandler(self, AMaS_Object, Tab, Subtab = None):\n        \n\n        if Tab == 1:\n            if AMaS_Object.tab_1_is != True:\n                item = QtWidgets.QListWidgetItem()\n                item.setData(100,AMaS_Object)\n                item.setText(AF.Digit_Grouping(AMaS_Object.EquationReverse))\n                \n                self.Tab_1_History.addItem(item)\n                AMaS_Object.tab_1_is = True\n                AMaS_Object.tab_1_ref = item\n            else:\n                self.Tab_1_History.takeItem(self.Tab_1_History.row(AMaS_Object.tab_1_ref))\n                AMaS_Object.tab_1_ref.setText(AF.Digit_Grouping(AMaS_Object.EquationReverse))\n                self.Tab_1_History.addItem(AMaS_Object.tab_1_ref)\n\n            self.Tab_1_History.scrollToBottom()\n        \n        elif Tab == 2:\n            if AMaS_Object.tab_2_is != True:\n                item = QtWidgets.QListWidgetItem()\n                item.setData(100,AMaS_Object)\n                item.setText(AMaS_Object.Text)\n                \n                self.Tab_2_History.addItem(item)\n                AMaS_Object.tab_2_is = True\n                AMaS_Object.tab_2_ref = item\n            else:\n                self.Tab_2_History.takeItem(self.Tab_2_History.row(AMaS_Object.tab_2_ref))\n                AMaS_Object.tab_2_ref.setText(AMaS_Object.Text)\n                self.Tab_2_History.addItem(AMaS_Object.tab_2_ref)\n            \n            self.Tab_2_History.scrollToBottom()\n        \n        elif Tab == 3:\n            if Subtab == 1:\n                if AMaS_Object.Tab_3_1_is != True:\n                    item = QtWidgets.QListWidgetItem()\n                    item.setData(100,AMaS_Object)\n                    item.setText(AMaS_Object.Text)\n                    \n                    self.Tab_3_1_History.addItem(item)\n                    AMaS_Object.Tab_3_1_is = True\n                    AMaS_Object.Tab_3_1_ref = item\n                else:\n                    self.Tab_3_1_History.takeItem(self.Tab_3_1_History.row(AMaS_Object.Tab_3_1_ref))\n                    AMaS_Object.Tab_3_1_ref.setText(AMaS_Object.Text)\n                    self.Tab_3_1_History.addItem(AMaS_Object.Tab_3_1_ref)\n                \n                self.Tab_3_1_History.scrollToBottom()\n            else:\n                NC(1,""Tab {} Subtab {} is unknown"".format(str(Tab),str(Subtab)),input=""Tab {} Subtab {}"".format(str(Tab),str(Subtab)),tb=True)\n        \n        elif Tab == 4:\n            if AMaS_Object.Tab_4_is != True:\n                item = QtWidgets.QListWidgetItem()\n                item.setData(100,AMaS_Object)\n                item.setText(AMaS_Object.Name)\n                \n                self.Tab_4_History.addItem(item)\n                AMaS_Object.Tab_4_is = True\n                AMaS_Object.Tab_4_ref = item\n            else:\n                self.Tab_4_History.takeItem(self.Tab_4_History.row(AMaS_Object.Tab_4_ref))\n                AMaS_Object.Tab_4_ref.setText(AMaS_Object.Name)\n                self.Tab_4_History.addItem(AMaS_Object.Tab_4_ref)\n\n            self.Tab_4_Active_Equation = AMaS_Object\n            self.Tab_4_F_Load_Matrix_List()\n            self.Tab_4_History.scrollToBottom()\n\n        else:\n            print(""History of Tab {} is unknown"".format(Tab))\n \n # ---------------------------------- Thread Handler ----------------------------------\n\n    def TR(self, AMaS_Object , Function , ID=-1 , Eval = -1): # Thread Return: Threads report back here when they are done\n        self.Function = Function\n        \n        if Function == self.Tab_1_F_Calculate:\n            if Eval == 0 : Eval = True\n            elif Eval == 1 : Eval = False\n            else: Eval = None\n            if Eval == None:\n                Eval=App().optionWindow.cb_F_EvalF.isChecked()\n            self.Function(AMaS_Object,Eval)\n        else:\n            self.Function(AMaS_Object)\n\n    def TC(self, Kind, *args, **kwargs):\n        try:\n            if self.Threading == ""LIST"":\n                ID = len(self.ThreadList)\n                \n                if Kind == ""NEW"":\n                    Thread = AT.AMaS_Creator_Thread(self,*args,ID=ID,**kwargs)\n                elif Kind == ""WORK"":\n                    Thread = AT.AMaS_Thread(self,*args,ID=ID) # pylint: disable=no-value-for-parameter\n                \n                \n                self.ThreadList.append(Thread) # INVESTIGATE: Check size of memory leak\n\n                self.ThreadList[ID].Return.connect(self.TR)\n                self.ThreadList[ID].ReturnError.connect(self.Error_Redirect)\n                self.ThreadList[ID].finished.connect(self.ThreadFinishedSlot)\n                self.ThreadList[ID].setTerminationEnabled(True)\n                self.S_Terminate_Threads.connect(self.ThreadList[ID].terminate)\n                self.ThreadList[ID].start()\n\n            elif self.Threading == ""POOL"":\n                if Kind == ""NEW"":\n                    worker = AT.AMaS_Creator(*args,**kwargs)\n                elif Kind == ""WORK"":\n                    worker = AT.AMaS_Worker(*args) # pylint: disable=no-value-for-parameter\n                worker.signals.result.connect(self.TR)\n                worker.signals.error.connect(self.Error_Redirect)\n                worker.signals.finished.connect(self.ThreadFinishedSlot)\n                self.S_Terminate_Threads.connect(worker.terminate)\n                self.threadpool.start(worker) \n        except common_exceptions:\n            NC(lvl=1,msg=""Could not start thread"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.TC"",win=self.windowTitle(),input=""Mode = {} , Kind = {}"".format(self.Threading,Kind))\n        else:\n            self.workingThreadsDisplay(1)\n        \n    def TC_old(self,Thread): # Thread Creator: All new threads are created here # CLEANUP: TC_old\n        ID = -1\n\n        # INVESTIGATE: This causes a crash due to garbagecollector deleting threads before they are properly done cleaning themselves up\n        #       but after they have claimed to be done cleaning up\n        #for i,e in enumerate(self.ThreadList):\n        #    # This is not 100% clean but only Threats that have reported back should\n        #    #   leave the list and thus only those can be cleaned by pythons garbage collector while not completely done\n        #    #   These would cause a crash but are intercepted by notify to ensure stability\n        #    try:\n        #        running = e.isRunning()\n        #    except (RuntimeError,AttributeError):\n        #        running = False\n        #    if not running:\n        #        try:\n        #            e.setTerminationEnabled(True)\n        #            e.terminate()\n        #            e.wait()\n        #        except (RuntimeError,AttributeError):\n        #            pass\n        #        self.ThreadList.pop(i)\n        #        ID = i\n        #        self.ThreadList.insert(i,Thread(i))\n        #        break\n        #if ID == -1:\n        #    ID = len(self.ThreadList)\n        #    self.ThreadList.append(Thread(ID))\n\n        # INVESTIGATE: This causes a memory leak but is better than random crashes\n        ID = len(self.ThreadList)\n        self.ThreadList.append(Thread(ID))\n\n\n        self.ThreadList[ID].Return.connect(self.TR)\n        self.ThreadList[ID].ReturnError.connect(self.Error_Redirect)\n        self.ThreadList[ID].start()\n\n    def Error_Redirect(self, AMaS_Object , ReturnFunction , ID=-1):\n        #IMPROVE: Improve the Error_Redirect\n        AMaS_Object.sendNotifications(self.windowTitle())\n\n    def Set_AMaS_Flags(self,AMaS_Object, f_eval = None):\n        if f_eval == None:\n            f_eval = App().optionWindow.cb_F_EvalF.isChecked()\n\n        AMaS_Object.f_eval = f_eval\n\n    def ThreadFinishedSlot(self):\n        self.workingThreadsDisplay(-1)\n    def workingThreadsDisplay(self,pm):\n        self.workingThreads += pm\n        self.statusbar.showMessage(""Currently working on {} {}"".format(self.workingThreads,""equation"" if self.workingThreads==1 else ""equations""))\n\n    def TerminateAllThreads(self):\n        self.S_Terminate_Threads.emit()\n        self.threadpool.clear()\n        if self.threadpool.activeThreadCount() >= 1:\n            self.oldThreadpools.append(self.threadpool)\n            self.threadpool = QtCore.QThreadPool()\n \n # ---------------------------------- Tab_1_ Calculator ----------------------------------\n    def Tab_1_F_Calculate_Field_Input(self):\n        modifiers = QtWidgets.QApplication.keyboardModifiers()\n        if modifiers == QtCore.Qt.ControlModifier:\n            Eval = not App().optionWindow.cb_F_EvalF.isChecked()\n        else:\n            Eval = App().optionWindow.cb_F_EvalF.isChecked()\n        TheInput = self.Tab_1_InputField.text()\n        if TheInput == ""RUNTEST"":\n            self.RUNTEST()\n        else:\n            if self.Tab_1_History.count() >= 1:\n                TheInput = re.sub(r""(?<!\\w)ans(?!\\w)"",""({})"".format(self.Tab_1_History.item(self.Tab_1_History.count()-1).data(100).Solution),TheInput)\n                TheInput = re.sub(r""(?<!\\w)ans1(?!\\w)"",""({})"".format(self.Tab_1_History.item(self.Tab_1_History.count()-1).data(100).Solution),TheInput)\n                if self.Tab_1_History.count() >= 2:\n                    TheInput = re.sub(r""(?<!\\w)ans2(?!\\w)"",""({})"".format(self.Tab_1_History.item(self.Tab_1_History.count()-2).data(100).Solution),TheInput)\n                    if self.Tab_1_History.count() >= 3:\n                        TheInput = re.sub(r""(?<!\\w)ans3(?!\\w)"",""({})"".format(self.Tab_1_History.item(self.Tab_1_History.count()-3).data(100).Solution),TheInput)\n                    else:\n                        TheInput = re.sub(r""(?<!\\w)ans3(?!\\w)"",""(1)"",TheInput)\n                else:\n                    TheInput = re.sub(r""(?<!\\w)ans2(?!\\w)"",""(1)"",TheInput)\n                    TheInput = re.sub(r""(?<!\\w)ans3(?!\\w)"",""(0)"",TheInput)\n            else:\n                TheInput = re.sub(r""(?<!\\w)ans(?!\\w)"",""(1)"",TheInput)\n                TheInput = re.sub(r""(?<!\\w)ans1(?!\\w)"",""(1)"",TheInput)\n                TheInput = re.sub(r""(?<!\\w)ans2(?!\\w)"",""(0)"",TheInput)\n                TheInput = re.sub(r""(?<!\\w)ans3(?!\\w)"",""(0)"",TheInput)\n            \n            if TheInput == ""len()"":\n                TheInput = str(len(self.ThreadList))\n            #self.TC(lambda ID: AT.AMaS_Creator(TheInput,self.Tab_1_F_Calculate,ID=ID,Eval=Eval))\n            self.TC(""NEW"",TheInput,self.Tab_1_F_Calculate,Eval=Eval)\n        \n    def Tab_1_F_Calculate(self,AMaS_Object,Eval = None):\n        if Eval == None:\n            Eval = App().optionWindow.cb_F_EvalF.isChecked()\n        self.Set_AMaS_Flags(AMaS_Object,f_eval = Eval)\n        #self.TC(lambda ID: AT.AMaS_Worker(AMaS_Object, lambda:AC.AMaS.Evaluate(AMaS_Object), self.Tab_1_F_Calculate_Display , ID))\n        self.TC(""WORK"", AMaS_Object, lambda:AC.AMaS.Evaluate(AMaS_Object), self.Tab_1_F_Calculate_Display)\n        \n    def Tab_1_F_Calculate_Display(self,AMaS_Object):\n        self.HistoryHandler(AMaS_Object,1)\n         \n    def Tab_1_F_Item_doubleClicked(self,item):\n        self.Tab_1_InputField.selectAll()\n        self.Tab_1_InputField.insertPlainText(item.data(100).Input)\n\n # ---------------------------------- Tab_2_ LaTeX ----------------------------------\n    def Tab_2_F_Convert(self, Text=None):\n        EvalL = self.Tab_2_Eval_checkBox.checkState()#isChecked()\n        if type(Text) != str:\n            Text = self.Tab_2_InputField.toPlainText()\n        #self.TC(lambda ID: AT.AMaS_Creator(Text, self.Tab_2_F_Display,ID,EvalL=EvalL))\n        self.TC(""NEW"",Text, self.Tab_2_F_Display,EvalL=EvalL)\n        \n        \n    def Tab_2_F_Display(self , AMaS_Object , part = ""Normal"", HandleHistory = True):\n        if HandleHistory:\n            self.HistoryHandler(AMaS_Object,2)\n        Notification = NC(0,send=False)\n        \n        if part == ""Normal"":\n            self.Tab_2_LaTeXOutput.setText(AMaS_Object.LaTeX)\n            Notification = self.Tab_2_Viewer.Display(AMaS_Object.LaTeX\n                                            ,self.TopBar.Font_Size_spinBox.value()\n                                            ,self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                            )\n        elif part == ""Equation"":\n            if AMaS_Object.LaTeX_E == r""\\text{Not converted yet}"":\n                AMaS_Object.ConvertToLaTeX_Equation()\n            self.Tab_2_LaTeXOutput.setText(AMaS_Object.LaTeX_E)\n            Notification = self.Tab_2_Viewer.Display(AMaS_Object.LaTeX_E\n                                            ,self.TopBar.Font_Size_spinBox.value()\n                                            ,self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                            )\n        elif part == ""Solution"":\n            if AMaS_Object.LaTeX_S == r""\\text{Not converted yet}"":\n                AMaS_Object.ConvertToLaTeX_Solution()\n            self.Tab_2_LaTeXOutput.setText(AMaS_Object.LaTeX_S)\n            Notification = self.Tab_2_Viewer.Display(AMaS_Object.LaTeX_S\n                                            ,self.TopBar.Font_Size_spinBox.value()\n                                            ,self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                            )\n        #Notification.f(""AMaDiA_Main_Window.Tab_2_F_Display"")\n        #Notification.w(self.windowTitle())\n        Notification.send()\n        \n    def Tab_2_F_Item_doubleClicked(self,item): #VALIDATE: Does this work as intended?\n        if item.data(100).LaTeX_E == r""\\text{Not converted yet}"" or item.data(100).LaTeX_E == r""\\text{Could not convert}"":\n            self.Tab_2_F_Display(item.data(100),part=""Normal"",HandleHistory=False)\n        else:\n            self.Tab_2_F_Display(item.data(100),part=""Equation"",HandleHistory=False)\n        \n # ---------------------------------- Tab_3_1_ 2D-Plot ----------------------------------\n    def Tab_3_1_F_Plot_Button(self):\n        #self.TC(lambda ID: AT.AMaS_Creator(self.Tab_3_1_Formula_Field.text() , self.Tab_3_1_F_Plot_init,ID=ID, Iam=AC.Iam_2D_plot))\n        self.TC(""NEW"",self.Tab_3_1_Formula_Field.text() , self.Tab_3_1_F_Plot_init, Iam=AC.Iam_2D_plot)\n         \n    def Tab_3_1_F_Item_doubleClicked(self,item):\n        try:\n            cycle = self.Tab_3_1_Display.canvas.ax._get_lines.prop_cycler\n            item.data(100).current_ax.set_color(next(cycle)[\'color\'])\n            self.Tab_3_1_Display.canvas.draw()\n            colour = item.data(100).current_ax.get_color()\n            brush = QtGui.QBrush(QtGui.QColor(colour))\n            brush.setStyle(QtCore.Qt.SolidPattern)\n            item.setForeground(brush)\n        except common_exceptions :\n            NC(lvl=2,msg=""Could not cycle colour"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_3_1_F_Item_doubleClicked"",win=self.windowTitle())\n        #MAYBE: Replot to make ch\n        \n    def Tab_3_1_F_Plot_init(self , AMaS_Object): # MAYBE: get these values upon creation in case the User acts before the LaTeX conversion finishes? (Not very important)\n        if not AMaS_Object.Plot_is_initialized: AMaS_Object.init_2D_plot()\n        AMaS_Object.plot_ratio = self.Tab_3_1_Axis_ratio_Checkbox.isChecked()\n        AMaS_Object.plot_grid = self.Tab_3_1_Draw_Grid_Checkbox.isChecked()\n        AMaS_Object.plot_xmin = self.Tab_3_1_From_Spinbox.value()\n        AMaS_Object.plot_xmax = self.Tab_3_1_To_Spinbox.value()\n        AMaS_Object.plot_points = self.Tab_3_1_Points_Spinbox.value()\n        \n        if self.Tab_3_1_Points_comboBox.currentIndex() == 0:\n            AMaS_Object.plot_per_unit = False\n        elif self.Tab_3_1_Points_comboBox.currentIndex() == 1:\n            AMaS_Object.plot_per_unit = True\n        \n        AMaS_Object.plot_xlim = self.Tab_3_1_XLim_Check.isChecked()\n        if AMaS_Object.plot_xlim:\n            xmin , xmax = self.Tab_3_1_XLim_min.value(), self.Tab_3_1_XLim_max.value()\n            if xmax < xmin:\n                xmax , xmin = xmin , xmax\n            AMaS_Object.plot_xlim_vals = (xmin , xmax)\n        AMaS_Object.plot_ylim = self.Tab_3_1_YLim_Check.isChecked()\n        if AMaS_Object.plot_ylim:\n            ymin , ymax = self.Tab_3_1_YLim_min.value(), self.Tab_3_1_YLim_max.value()\n            if ymax < ymin:\n                ymax , ymin = ymin , ymax\n            AMaS_Object.plot_ylim_vals = (ymin , ymax)\n        \n        #self.TC(lambda ID: AT.AMaS_Worker(AMaS_Object,lambda:AC.AMaS.Plot_2D_Calc_Values(AMaS_Object),self.Tab_3_1_F_Plot ,ID))\n        self.TC(""WORK"",AMaS_Object,lambda:AC.AMaS.Plot_2D_Calc_Values(AMaS_Object),self.Tab_3_1_F_Plot)\n        \n    def Tab_3_1_F_Plot(self , AMaS_Object): # FEATURE: Add an option for each axis to scale logarithmically \n        # MAYBE: Add an extra option for this in the config tab... and change everything else accordingly\n        #if self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked():\n        #    self.Tab_3_1_Display.UseTeX(True)\n        #else:\n        #    self.Tab_3_1_Display.UseTeX(False)\n        \n        self.Tab_3_1_Display.UseTeX(False)\n\n        self.HistoryHandler(AMaS_Object,3,1)\n        \n        try:\n            if type(AMaS_Object.plot_x_vals) == int or type(AMaS_Object.plot_x_vals) == float:\n                p = self.Tab_3_1_Display.canvas.ax.axvline(x = AMaS_Object.plot_x_vals,color=\'red\')\n            else:\n                p = self.Tab_3_1_Display.canvas.ax.plot(AMaS_Object.plot_x_vals , AMaS_Object.plot_y_vals) #  (... , \'r--\') for red colour and short lines\n            try:\n                AMaS_Object.current_ax = p[0]\n            except common_exceptions:\n                AMaS_Object.current_ax = p\n            \n            if AMaS_Object.plot_grid:\n                self.Tab_3_1_Display.canvas.ax.grid(True)\n            else:\n                self.Tab_3_1_Display.canvas.ax.grid(False)\n            if AMaS_Object.plot_ratio:\n                self.Tab_3_1_Display.canvas.ax.set_aspect(\'equal\')\n            else:\n                self.Tab_3_1_Display.canvas.ax.set_aspect(\'auto\')\n            \n            self.Tab_3_1_Display.canvas.ax.relim()\n            self.Tab_3_1_Display.canvas.ax.autoscale()\n            if AMaS_Object.plot_xlim:\n                self.Tab_3_1_Display.canvas.ax.set_xlim(AMaS_Object.plot_xlim_vals)\n            if AMaS_Object.plot_ylim:\n                self.Tab_3_1_Display.canvas.ax.set_ylim(AMaS_Object.plot_ylim_vals)\n            \n            try:\n                colour = p[0].get_color()\n                brush = QtGui.QBrush(QtGui.QColor(colour))\n                brush.setStyle(QtCore.Qt.SolidPattern)\n                AMaS_Object.Tab_3_1_ref.setForeground(brush)\n            except common_exceptions:\n                colour = ""#FF0000""\n                brush = QtGui.QBrush(QtGui.QColor(colour))\n                brush.setStyle(QtCore.Qt.SolidPattern)\n                AMaS_Object.Tab_3_1_ref.setForeground(brush)\n            \n            try:\n                self.Tab_3_1_Display.canvas.draw()\n            except RuntimeError:\n                ExceptionOutput(sys.exc_info(),False)\n                print(""Trying to output without LaTeX"")\n                self.Tab_3_1_Display.UseTeX(False)\n                self.Tab_3_1_Display.canvas.draw()\n        except common_exceptions :\n            NC(msg=""y_vals = ""+str(r.repr(AMaS_Object.plot_y_vals))+str(type(AMaS_Object.plot_y_vals))+""\\nYou can copy all elements in the contextmenu if advanced mode is active""\n                    ,exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_3_1_F_Plot"",win=self.windowTitle(), input=AMaS_Object.Input)\n            #print(""y_vals = "")\n            #print(AMaS_Object.plot_y_vals)\n            #print(type(AMaS_Object.plot_y_vals))\n            AMaS_Object.plottable = False\n            \n    def Tab_3_1_F_RedrawPlot(self):\n        xmin , xmax = self.Tab_3_1_XLim_min.value(), self.Tab_3_1_XLim_max.value()\n        if xmax < xmin:\n            xmax , xmin = xmin , xmax\n        xlims = (xmin , xmax)\n        ymin , ymax = self.Tab_3_1_YLim_min.value(), self.Tab_3_1_YLim_max.value()\n        if ymax < ymin:\n            ymax , ymin = ymin , ymax\n        ylims = (ymin , ymax)\n        if self.Tab_3_1_Draw_Grid_Checkbox.isChecked():\n            self.Tab_3_1_Display.canvas.ax.grid(True)\n        else:\n            self.Tab_3_1_Display.canvas.ax.grid(False)\n        if self.Tab_3_1_Axis_ratio_Checkbox.isChecked():\n            self.Tab_3_1_Display.canvas.ax.set_aspect(\'equal\')\n        else:\n            self.Tab_3_1_Display.canvas.ax.set_aspect(\'auto\')\n        \n        self.Tab_3_1_Display.canvas.ax.relim()\n        self.Tab_3_1_Display.canvas.ax.autoscale()\n        if self.Tab_3_1_XLim_Check.isChecked():\n            self.Tab_3_1_Display.canvas.ax.set_xlim(xlims)\n        if self.Tab_3_1_YLim_Check.isChecked():\n            self.Tab_3_1_Display.canvas.ax.set_ylim(ylims)\n        \n        try:\n            self.Tab_3_1_Display.canvas.draw()\n        except RuntimeError:\n            ExceptionOutput(sys.exc_info(),False)\n            print(""Trying to output without LaTeX"")\n            self.Tab_3_1_Display.UseTeX(False)\n            self.Tab_3_1_Display.canvas.draw()\n        \n    def Tab_3_1_F_Clear(self):\n        self.Tab_3_1_Display.UseTeX(False)\n        self.Tab_3_1_Display.canvas.ax.clear()\n        try:\n            self.Tab_3_1_Display.canvas.draw()\n        except RuntimeError:\n            ExceptionOutput(sys.exc_info(),False)\n            print(""Trying to output without LaTeX"")\n            self.Tab_3_1_Display.UseTeX(False)\n            self.Tab_3_1_Display.canvas.ax.clear()\n            self.Tab_3_1_Display.canvas.draw()\n        brush = self.palette().text()\n        for i in range(self.Tab_3_1_History.count()):\n            self.Tab_3_1_History.item(i).setForeground(brush)\n            self.Tab_3_1_History.item(i).data(100).current_ax = None\n            \n\n\n    def Tab_3_1_F_Sympy_Plot_Button(self): # CLEANUP: DELETE SymPy Plotter\n        #self.TC(lambda ID: AT.AMaS_Creator(self.Tab_3_1_Formula_Field.text() , self.Tab_3_1_F_Sympy_Plot,ID))\n        self.TC(""NEW"",self.Tab_3_1_Formula_Field.text() , self.Tab_3_1_F_Sympy_Plot)\n        \n    def Tab_3_1_F_Sympy_Plot(self , AMaS_Object): # CLEANUP: DELETE SymPy Plotter\n        try:\n            #self.__SPFIG = plt.figure(num=""SP"")\n            x,y,z = sympy.symbols(\'x y z\')  # pylint: disable=unused-variable\n            \n            temp = AMaS_Object.cstr\n            if AMaS_Object.cstr.count(""="") == 1 :\n                temp1 , temp2 = AMaS_Object.cstr.split(""="",1)\n                temp = ""Eq(""+temp1\n                temp += "",""\n                temp += temp2\n                temp += "")""\n            temp = parse_expr(temp)\n            xmin , xmax = self.Tab_3_1_XLim_min.value(), self.Tab_3_1_XLim_max.value()\n            if xmax < xmin:\n                xmax , xmin = xmin , xmax\n            xlims = (xmin , xmax)\n            ymin , ymax = self.Tab_3_1_YLim_min.value(), self.Tab_3_1_YLim_max.value()\n            if ymax < ymin:\n                ymax , ymin = ymin , ymax\n            ylims = (ymin , ymax)\n            if self.Tab_3_1_XLim_Check.isChecked() and self.Tab_3_1_YLim_Check.isChecked():\n                sympy.plot(temp , xlim = xlims , ylim = ylims)\n            elif self.Tab_3_1_XLim_Check.isChecked():\n                sympy.plot(temp , xlim = xlims)\n            elif self.Tab_3_1_YLim_Check.isChecked():\n                sympy.plot(temp , ylim = ylims)\n            else:\n                sympy.plot(temp)#, num=""SP"",backend=matplotlib.backends.backend_qt5.FigureCanvasBase)\n        except common_exceptions: # MAYBE: plot_implicit uses other syntax for limits. Maybe make this work\n            ExceptionOutput(sys.exc_info())\n            try:\n                sympy.plot_implicit(temp)\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n                try:\n                    sympy.plot_implicit(parse_expr(AMaS_Object.string))\n                except common_exceptions:\n                    NC(exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_3_1_F_Sympy_Plot"",win=self.windowTitle())\n \n # ---------------------------------- Tab_3_2_ 3D-Plot ----------------------------------\n    # FEATURE: 3D-Plot\n \n # ---------------------------------- Tab_3_3_ Complex-Plot ----------------------------------\n    # FEATURE: Complex-Plot\n \n # ---------------------------------- Tab_3_4_ ND-Plot ----------------------------------\n    # FEATURE: ND-Plot\n \n # ---------------------------------- Tab_4_ Multi-Dim ----------------------------------\n    def Tab_4_F_New_Equation(self):\n        Name = """"+self.Tab_4_2_New_Equation_Name_Input.text().strip()\n        if Name == """":\n            Name=""Unnamed Equation""\n        #self.TC(lambda ID: AT.AMaS_Creator(Name,self.Tab_4_F_New_Equation_Done,ID=ID,Iam=AC.Iam_Multi_Dim))\n        self.TC(""NEW"",Name,self.Tab_4_F_New_Equation_Done,Iam=AC.Iam_Multi_Dim)\n    def Tab_4_F_New_Equation_Done(self,AMaS_Object):\n        self.HistoryHandler(AMaS_Object,4)\n\n    def Tab_4_F_Load_Selected_Equation(self):\n        item = self.Tab_4_History.selectedItems()\n        if len(item) == 1:\n            item = item[0]\n            self.HistoryHandler(item.data(100),4)\n        self.Tab_4_FormulaInput.setText(item.data(100).Input)\n        self.Tab_4_F_Display(self.Tab_4_Active_Equation)\n\n    def Tab_4_F_Load_Matrix_List(self):\n        try:\n            self.Tab_4_Matrix_List.clear()\n            try:\n                for Name, Variable in self.Tab_4_Active_Equation.Variables.items():\n                    h, w = AF.shape2(Variable)\n                    Text = Name + "" = {}"".format(str(Variable)) if h==1 and w==1 else Name + "" : {}x{}"".format(h,w)\n                    item = QtWidgets.QListWidgetItem()\n                    item.setText(Text)\n                    item.setData(100,Name)\n                    item.setData(101,Variable)\n                    self.Tab_4_Matrix_List.addItem(item)\n            except ValueError:\n                ExceptionOutput(sys.exc_info())\n                try:\n                    Name, Variable = self.Tab_4_Active_Equation.Variables.items()\n                    h, w = AF.shape2(Variable)\n                    Text = Name + "" = {}"".format(str(Variable)) if h==1 and w==1 else Name + "" : {}x{}"".format(h,w)\n                    item = QtWidgets.QListWidgetItem()\n                    item.setText(Text)\n                    item.setData(100,Name)\n                    item.setData(101,Variable)\n                    self.Tab_4_Matrix_List.addItem(item)\n                except common_exceptions:\n                    NC(msg=""Could not load the matrix list for this equation"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_4_F_Load_Matrix_List"",\n                            win=self.windowTitle(),input=self.Tab_4_Active_Equation.Input)\n        except common_exceptions:\n            NC(msg=""Could not load the matrix list"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_4_F_Load_Matrix_List"",win=self.windowTitle())\n\n    def Tab_4_F_Load_Matrix(self,Name,Matrix):\n        h,w = AF.shape2(Matrix)\n        self.Tab_4_1_Matrix_Input.setRowCount(h)\n        self.Tab_4_1_Matrix_Input.setColumnCount(w)\n        self.Tab_4_1_Dimension_Input.setText("" ""+str(h)+""x""+str(w))\n        self.Tab_4_1_Name_Input.setText(Name)\n\n        tolist = getattr(Matrix, ""tolist"", None)\n        if callable(tolist):\n            ValueList = Matrix.tolist()\n        else:\n            ValueList = [[Matrix]]\n        for i,a in enumerate(ValueList): # pylint: disable=unused-variable\n            for j,b in enumerate(ValueList[i]):\n                item = Qt.QTableWidgetItem()\n                item.setText(str(b))\n                self.Tab_4_1_Matrix_Input.setItem(i,j,item)\n\n    def Tab_4_F_Config_Matrix_Dim(self):\n        h,w = self.Tab_4_1_Dimension_Input.text().split(""x"")\n        try:\n            h = int(h) if int(h) > 0 else 1\n            self.Tab_4_1_Matrix_Input.setRowCount(h)\n        except common_exceptions:\n            pass\n        try:\n            w = int(w)\n            self.Tab_4_1_Matrix_Input.setColumnCount(w)\n        except common_exceptions:\n            pass\n        for i in range(self.Tab_4_1_Matrix_Input.columnCount()):\n            self.Tab_4_1_Matrix_Input.setColumnWidth(i,75)\n        \n    def Tab_4_F_Save_Matrix(self):\n        try:\n            NameInvalid=False\n            Name = AF.AstusParse(self.Tab_4_1_Name_Input.text()).strip()\n            if Name == """" or "" "" in Name: #IMPROVE: Better checks for Matrix Names!!!\n                NameInvalid=True\n\n            if NameInvalid:\n                NC(1,""Matrix Name Invalid"",func=""AMaDiA_Main_Window.Tab_4_F_Save_Matrix"",win=self.windowTitle(),input=Name)\n                return False\n            \n            # Read the Input and save it in a nested List\n            Matrix = []\n            MError = """"\n            for i in range(self.Tab_4_1_Matrix_Input.rowCount()):\n                Matrix.append([])\n                for j in range(self.Tab_4_1_Matrix_Input.columnCount()):\n                    try:\n                        if self.Tab_4_1_Matrix_Input.item(i,j).text() != None and self.Tab_4_1_Matrix_Input.item(i,j).text().strip() != """":\n                            Matrix[i].append(AF.AstusParse(self.Tab_4_1_Matrix_Input.item(i,j).text(),False))\n                        else:\n                            Matrix[i].append(""0"")\n                    except common_exceptions:\n                        MError += ""Could not add item to Matrix at ({},{}). Inserting a Zero instead. "".format(i+1,j+1)\n                        #MError += ExceptionOutput(sys.exc_info())\n                        MError += ""\\n""\n                        Matrix[i].append(""0"")\n            if MError != """":\n                NC(2,MError,func=""AMaDiA_Main_Window.Tab_4_F_Save_Matrix"",win=self.windowTitle(),input=str(Matrix))\n            # Convert list into Matrix and save it in the Equation\n            if len(Matrix) == 1 and len(Matrix[0]) == 1:\n                Matrix = parse_expr(Matrix[0][0])\n            else:\n                Matrix = sympy.Matrix(Matrix) # https://docs.sympy.org/latest/modules/matrices/matrices.html\n            self.Tab_4_Active_Equation.AddVariable(Name,Matrix)\n            \n            # Prepare ListWidgetItem\n            item = QtWidgets.QListWidgetItem()\n            h, w = AF.shape2(Matrix)\n            Text = Name + "" = {}"".format(str(Matrix)) if h==1 and w==1 else Name + "" : {}x{}"".format(h,w)\n            item.setText(Text)\n            item.setData(100,Name)\n            item.setData(101,Matrix)\n            SearchFor = Name+"" ""\n\n            #Remove Duplicates\n            # VALIDATE: Ensure that this works correctly in all cases!\n            # FEATURE: Save the first duplicate in a temporary List item!\n            FoundItems = self.Tab_4_Matrix_List.findItems(SearchFor,QtCore.Qt.MatchStartsWith)\n            if len(FoundItems) > 0:\n                for i in FoundItems:\n                    index = self.Tab_4_Matrix_List.indexFromItem(i)\n                    self.Tab_4_Matrix_List.takeItem(index.row())\n\n            # Add to the Matrix List\n            self.Tab_4_Matrix_List.addItem(item)\n            # Display the Matrix\n            self.Tab_4_F_Display_Matrix(Name,Matrix)\n        except common_exceptions:\n            NC(1,""Could not save matrix!"",exc=sys.exc_info(),func=""AMaDiA_Main_Window.Tab_4_F_Save_Matrix"",win=self.windowTitle())\n        \n    def Tab_4_F_Update_Equation(self):\n        modifiers = QtWidgets.QApplication.keyboardModifiers()\n        if modifiers == QtCore.Qt.ControlModifier:\n            Eval = not App().optionWindow.cb_F_EvalF.isChecked()\n        else:\n            Eval = App().optionWindow.cb_F_EvalF.isChecked()\n        Text = self.Tab_4_FormulaInput.text()\n        AMaS_Object = self.Tab_4_Active_Equation\n        self.Set_AMaS_Flags(AMaS_Object,f_eval = Eval)\n        #self.TC(lambda ID: AT.AMaS_Worker(AMaS_Object, lambda:AC.AMaS.UpdateEquation(AMaS_Object ,Text=Text), self.Tab_4_F_Display , ID))\n        self.TC(""WORK"",AMaS_Object, lambda:AC.AMaS.UpdateEquation(AMaS_Object ,Text=Text), self.Tab_4_F_Display)\n\n    def Tab_4_F_Display(self, AMaS_Object): # TODO: Display the Equation in addition to the solution\n        self.Tab_4_Currently_Displayed = AMaS_Object.Equation\n        self.Tab_4_Currently_Displayed_Solution = AMaS_Object.Solution\n        Notification = self.Tab_4_Display.Display(AMaS_Object.LaTeX_ER\n                                        ,self.TopBar.Font_Size_spinBox.value()\n                                        ,self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                        )\n        Notification.f(""AMaDiA_Main_Window.Tab_4_F_Display"")\n        Notification.w(self.windowTitle())\n        Notification.send()\n        \n    def Tab_4_F_Display_Matrix(self,Name,Matrix):\n        #Text = sympy.latex(Matrix)\n        #Text += ""$""\n        #Text1 = ""$\\\\displaystyle""+Text\n        #Text2 = ""$""+Text\n        ##Text2 = Text2.replace(""\\\\left"","""")\n        ##Text2 = Text2.replace(""\\\\right"","""")\n        ##Text2 = Text2.replace(""\\\\begin"","""")\n        ##Text2 = Text2.replace(""\\\\end"","""")\n        #Text = Name + "" = ""\n        #Text1,Text2 = Text+Text1 , Text+Text2\n        Text = r""\\text{"" + Name + ""} = "" + sympy.latex(Matrix)\n        self.Tab_4_Currently_Displayed = Text + str(Matrix)\n        self.Tab_4_Currently_Displayed_Solution = str(Matrix)\n        Notification = self.Tab_4_Display.Display(Text\n                                        ,self.TopBar.Font_Size_spinBox.value()\n                                        ,self.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                        )\n        Notification.f(""AMaDiA_Main_Window.Tab_4_F_Display_Matrix"")\n        Notification.w(self.windowTitle())\n        Notification.send()\n \n # ---------------------------------- Tab_5_ ??? ----------------------------------\n\n # ---------------------------------- Tab_6_ ??? ----------------------------------\n\n# ---------------------------------- Main ----------------------------------\nif __name__ == ""__main__"":\n    latex_installed, dvipng_installed = find_executable(\'latex\'), find_executable(\'dvipng\')\n    if latex_installed and dvipng_installed: print(""latex and dvipng are installed --> Using pretty LaTeX Display"")\n    elif latex_installed and not dvipng_installed: print(""latex is installed but dvipng was not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    elif not latex_installed and dvipng_installed: print(""dvipng is installed but latex was not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    else: print(""latex and dvipng were not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    print(""AMaDiA Startup"")\n    app = AMaDiA_Main_App([])\n    app.ModuleVersions = ""AMaDiA {}\\n"".format(Version) + app.ModuleVersions\n    window = AMaDiA_Main_Window(app)\n    print(datetime.datetime.now().strftime(\'%H:%M:%S:\'),""AMaDiA Started\\n"")\n    if app.AGeLibPathOK:\n        lastVersion = """"\n        try:\n            with open(os.path.join(app.ConfigFolderPath,""Version""),\'r\',encoding=""utf-8"") as text_file:\n                lastVersion = text_file.read()\n        except:\n            pass\n        if lastVersion != Version:\n            window.LastOpenState()\n            window.Tab_1_InputField.setFocus()\n            window.Show_AMaDiA_Text_File(""Patchlog.txt"")\n            NC(3,""AMaDiA has been updated! You are now on version: ""+Version,DplStr=""Update complete!"")\n            try:\n                with open(os.path.join(app.ConfigFolderPath,""Version""),\'w\',encoding=""utf-8"") as text_file:\n                    text_file.write(Version)\n            except:\n                pass\n        else:\n            window.LastOpenState()\n            window.Tab_1_InputField.setFocus()\n            window.activateWindow()\n    else:\n        window.LastOpenState()\n        window.Tab_1_InputField.setFocus()\n        window.activateWindow()\n    sys.exit(app.exec())\n\n'"
AGeLib/AGeColour.py,0,"b'# This Python file uses the following encoding: utf-8\n\n# if__name__ == ""__main__"":\n#     pass\n\n\n# https://doc.qt.io/qt-5/qpalette.html#ColorRole-enum\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\ndef Dark():\n    palette1 = QtGui.QPalette()\n    palette2 = QtGui.QPalette()\n    palette3 = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    PenColours = {\n\t\t""Red"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n\t\t""Green"":QtGui.QBrush(QtGui.QColor(0,255,0)),\n\t\t""Blue"":QtGui.QBrush(QtGui.QColor(55,55,255)),\n\t\t""Yellow"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n\t\t""Cyan"":QtGui.QBrush(QtGui.QColor(0,255,234)),\n\t\t""Magenta"":QtGui.QBrush(QtGui.QColor(255,0,234)),\n\t\t""Orange"":QtGui.QBrush(QtGui.QColor(255,119,0)),\n\t\t""Light Blue"":QtGui.QBrush(QtGui.QColor(0,170,255)),\n\t\t""White"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n    \t""Black"":QtGui.QBrush(QtGui.QColor(0,0,0))}\n    NotificationColours = {\n\t\t""Error"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n\t\t""Warning"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n\t\t""Notification"":QtGui.QBrush(QtGui.QColor(0,0,255)),\n\t\t""Message"":QtGui.QBrush(QtGui.QColor(0,255,0))}\n    MiscColours = {\n\t\t""Friendly"":QtGui.QBrush(QtGui.QColor(0,255,21)),\n\t\t""Hostile"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n\t\t""Neutral"":QtGui.QBrush(QtGui.QColor(209,255,203)),\n\t\t""Ally"":QtGui.QBrush(QtGui.QColor(0,136,255)),\n\t\t""Self"":QtGui.QBrush(QtGui.QColor(81,0,255)),\n\t\t""Common"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n\t\t""Uncommon"":QtGui.QBrush(QtGui.QColor(148,144,255)),\n\t\t""Rare"":QtGui.QBrush(QtGui.QColor(17,255,0)),\n\t\t""Legendary"":QtGui.QBrush(QtGui.QColor(115,0,255)),\n\t\t""Mythical"":QtGui.QBrush(QtGui.QColor(255,42,227)),\n\t\t""Artefact"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n\t\t""Broken"":QtGui.QBrush(QtGui.QColor(181,181,181)),\n\t\t""Magical"":QtGui.QBrush(QtGui.QColor(255,46,49)),\n\t\t""Important"":QtGui.QBrush(QtGui.QColor(255,183,0)),\n\t\t""Gradient1"":QtGui.QBrush(QtGui.QColor(0,0,0)),\n\t\t""Gradient2"":QtGui.QBrush(QtGui.QColor(0,0,127)),\n\t\t""Gradient3"":QtGui.QBrush(QtGui.QColor(127,0,255))}\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\n\ndef Bright():\n    palette1 = QtGui.QPalette()\n    palette2 = QtGui.QPalette()\n    palette3 = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(247,247,247))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,247))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,247))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(247,247,246))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,159))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,197))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,197))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,197))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,183))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,183))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,184))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(184,184,183))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,204))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,204))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,203))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(203,203,204))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,118))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,118))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,118))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(118,118,117))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,219))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,239))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(239,239,238))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(159,159,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    PenColours = {\n        ""Red"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Green"":QtGui.QBrush(QtGui.QColor(0,255,0)),\n        ""Blue"":QtGui.QBrush(QtGui.QColor(55,55,255)),\n        ""Yellow"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Cyan"":QtGui.QBrush(QtGui.QColor(0,255,234)),\n        ""Magenta"":QtGui.QBrush(QtGui.QColor(255,0,234)),\n        ""Orange"":QtGui.QBrush(QtGui.QColor(255,119,0)),\n        ""Light Blue"":QtGui.QBrush(QtGui.QColor(0,170,255)),\n        ""White"":QtGui.QBrush(QtGui.QColor(211,211,211)),\n        ""Black"":QtGui.QBrush(QtGui.QColor(0,0,0))}\n    NotificationColours = {\n        ""Error"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Warning"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Notification"":QtGui.QBrush(QtGui.QColor(0,0,255)),\n        ""Message"":QtGui.QBrush(QtGui.QColor(0,255,0))}\n    MiscColours = {\n        ""Friendly"":QtGui.QBrush(QtGui.QColor(0,255,21)),\n        ""Hostile"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Neutral"":QtGui.QBrush(QtGui.QColor(209,255,203)),\n        ""Ally"":QtGui.QBrush(QtGui.QColor(0,136,255)),\n        ""Self"":QtGui.QBrush(QtGui.QColor(81,0,255)),\n        ""Common"":QtGui.QBrush(QtGui.QColor(0,0,0)),\n        ""Uncommon"":QtGui.QBrush(QtGui.QColor(148,144,255)),\n        ""Rare"":QtGui.QBrush(QtGui.QColor(17,255,0)),\n        ""Legendary"":QtGui.QBrush(QtGui.QColor(115,0,255)),\n        ""Mythical"":QtGui.QBrush(QtGui.QColor(255,42,227)),\n        ""Artefact"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Broken"":QtGui.QBrush(QtGui.QColor(181,181,181)),\n        ""Magical"":QtGui.QBrush(QtGui.QColor(255,46,49)),\n        ""Important"":QtGui.QBrush(QtGui.QColor(255,183,0)),\n\t\t""Gradient1"":QtGui.QBrush(QtGui.QColor(0,0,0)),\n\t\t""Gradient2"":QtGui.QBrush(QtGui.QColor(255,100,0)),\n\t\t""Gradient3"":QtGui.QBrush(QtGui.QColor(255,255,127))}\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\n\ndef DeepSea():\n    palette1 = QtGui.QPalette()\n    palette2 = QtGui.QPalette()\n    palette3 = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,100))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,48))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,79))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,44))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,79))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,44))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,79))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,44))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,43))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(34,94,172))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13,30,107))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(34,94,172))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13,30,107))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(34,94,172))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(13,30,107))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,57,84))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(114,178,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,33))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    PenColours = {\n        ""Red"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Green"":QtGui.QBrush(QtGui.QColor(0,255,0)),\n        ""Blue"":QtGui.QBrush(QtGui.QColor(55,55,255)),\n        ""Yellow"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Cyan"":QtGui.QBrush(QtGui.QColor(0,255,234)),\n        ""Magenta"":QtGui.QBrush(QtGui.QColor(255,0,234)),\n        ""Orange"":QtGui.QBrush(QtGui.QColor(255,119,0)),\n        ""Light Blue"":QtGui.QBrush(QtGui.QColor(0,170,255)),\n        ""White"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n        ""Black"":QtGui.QBrush(QtGui.QColor(68,68,68))}\n    NotificationColours = {\n        ""Error"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Warning"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Notification"":QtGui.QBrush(QtGui.QColor(0,0,255)),\n        ""Message"":QtGui.QBrush(QtGui.QColor(0,255,0))}\n    MiscColours = {\n        ""Friendly"":QtGui.QBrush(QtGui.QColor(0,255,21)),\n        ""Hostile"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Neutral"":QtGui.QBrush(QtGui.QColor(209,255,203)),\n        ""Ally"":QtGui.QBrush(QtGui.QColor(0,136,255)),\n        ""Self"":QtGui.QBrush(QtGui.QColor(178,111,255)),\n        ""Common"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n        ""Uncommon"":QtGui.QBrush(QtGui.QColor(148,144,255)),\n        ""Rare"":QtGui.QBrush(QtGui.QColor(17,255,0)),\n        ""Legendary"":QtGui.QBrush(QtGui.QColor(226,0,255)),\n        ""Mythical"":QtGui.QBrush(QtGui.QColor(37,255,255)),\n        ""Artefact"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Broken"":QtGui.QBrush(QtGui.QColor(152,152,152)),\n        ""Magical"":QtGui.QBrush(QtGui.QColor(255,46,49)),\n        ""Important"":QtGui.QBrush(QtGui.QColor(255,183,0)),\n\t\t""Gradient1"":QtGui.QBrush(QtGui.QColor(0,0,0)),\n\t\t""Gradient2"":QtGui.QBrush(QtGui.QColor(0,0,127)),\n\t\t""Gradient3"":QtGui.QBrush(QtGui.QColor(0,255,255))}\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\n\ndef BloodMoon():\n    palette1 = QtGui.QPalette()\n    palette2 = QtGui.QPalette()\n    palette3 = QtGui.QPalette()\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(130,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(74,77,83))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(85,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,252,218))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(88,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(88,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(88,0,1))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(63,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(30,30,30))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(176,176,176))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(60,60,60))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(40,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(48,140,198))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(53,68,97))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(145,145,145))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Highlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,254))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.HighlightedText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(177,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(138,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(177,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(138,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(177,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(138,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(81,85,94))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(150,150,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Link, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.LinkVisited, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(36,38,42))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,0,255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(67,71,78))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(0,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(52,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(54,57,63))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,169,169))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,158,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,169,169))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,158,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,169,169))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,158,158))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(255,255,220))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(50,0,0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette1.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette2.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(215,213,201))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, brush)\n    brush = QtGui.QBrush(QtGui.QColor(27,28,31))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    palette3.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, brush)\n    PenColours = {\n        ""Red"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Green"":QtGui.QBrush(QtGui.QColor(0,255,0)),\n        ""Blue"":QtGui.QBrush(QtGui.QColor(55,55,255)),\n        ""Yellow"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Cyan"":QtGui.QBrush(QtGui.QColor(0,255,234)),\n        ""Magenta"":QtGui.QBrush(QtGui.QColor(255,0,234)),\n        ""Orange"":QtGui.QBrush(QtGui.QColor(255,119,0)),\n        ""Light Blue"":QtGui.QBrush(QtGui.QColor(0,170,255)),\n        ""White"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n        ""Black"":QtGui.QBrush(QtGui.QColor(0,0,0))}\n    NotificationColours = {\n        ""Error"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Warning"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Notification"":QtGui.QBrush(QtGui.QColor(0,0,255)),\n        ""Message"":QtGui.QBrush(QtGui.QColor(0,255,0))}\n    MiscColours = {\n        ""Friendly"":QtGui.QBrush(QtGui.QColor(0,255,21)),\n        ""Hostile"":QtGui.QBrush(QtGui.QColor(255,0,0)),\n        ""Neutral"":QtGui.QBrush(QtGui.QColor(209,255,203)),\n        ""Ally"":QtGui.QBrush(QtGui.QColor(0,136,255)),\n        ""Self"":QtGui.QBrush(QtGui.QColor(178,111,255)),\n        ""Common"":QtGui.QBrush(QtGui.QColor(255,255,255)),\n        ""Uncommon"":QtGui.QBrush(QtGui.QColor(148,144,255)),\n        ""Rare"":QtGui.QBrush(QtGui.QColor(17,255,0)),\n        ""Legendary"":QtGui.QBrush(QtGui.QColor(149,0,255)),\n        ""Mythical"":QtGui.QBrush(QtGui.QColor(255,80,255)),\n        ""Artefact"":QtGui.QBrush(QtGui.QColor(255,255,0)),\n        ""Broken"":QtGui.QBrush(QtGui.QColor(152,152,152)),\n        ""Magical"":QtGui.QBrush(QtGui.QColor(255,111,113)),\n        ""Important"":QtGui.QBrush(QtGui.QColor(255,183,0)),\n\t\t""Gradient1"":QtGui.QBrush(QtGui.QColor(0,0,0)),\n\t\t""Gradient2"":QtGui.QBrush(QtGui.QColor(85,0,0)),\n\t\t""Gradient3"":QtGui.QBrush(QtGui.QColor(255,0,0))}\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\n\n\n#----------------- Special -----------------\n\ndef Red_ERROR():\n    brush = QtGui.QBrush(QtGui.QColor(255, 0, 0))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n    text_brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n    brush.setStyle(QtCore.Qt.SolidPattern)\n\n    palette = QtGui.QPalette()\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.WindowText, text_brush) # Used for tab-text and for the arrows in spinboxes and scrollbars\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush) # Used for Tabs (and their background) and Buttons\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Light, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Midlight, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Dark, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Mid, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Text, text_brush) # Used for most Text\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.BrightText, text_brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, text_brush) # Used is most places as Text Colour\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Base, brush) # Used for Text Field Background\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Window, brush) # Used for main background\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Shadow, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.AlternateBase, brush) #?\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipBase, brush) # Not used (overwritten for every tooltip made in designer?)\n    palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ToolTipText, text_brush) # Not used (overwritten for every tooltip made in designer?)\n    #-----------------------------------------------------------------------------------\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.WindowText, text_brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Light, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Midlight, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Dark, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Mid, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Text, text_brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.BrightText, text_brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, text_brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Base, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Window, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Shadow, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.AlternateBase, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipBase, brush)\n    palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ToolTipText, text_brush)\n    #-----------------------------------------------------------------------------------\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.WindowText, text_brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Light, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Midlight, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Dark, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Mid, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Text, text_brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.BrightText, text_brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, text_brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Base, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Window, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Shadow, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.AlternateBase, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipBase, brush)\n    palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ToolTipText, text_brush)\n    \n    #      UI        Special Background Colour  Special Text Colour\n    return palette , (54/255, 57/255, 63/255) , (215/255, 213/255, 201/255)\n\n\nPaletteElements = {""AlternateBase"" : QtGui.QPalette.AlternateBase,\n                   ""Base"" : QtGui.QPalette.Base,\n                   ""BrightText"" : QtGui.QPalette.BrightText,\n                   ""Button"" : QtGui.QPalette.Button,\n                   ""ButtonText"" : QtGui.QPalette.ButtonText,\n                   ""Dark"" : QtGui.QPalette.Dark,\n                   ""Highlight"" : QtGui.QPalette.Highlight,\n                   ""HighlightedText"" : QtGui.QPalette.HighlightedText,\n                   ""Light"" : QtGui.QPalette.Light,\n                   ""Link"" : QtGui.QPalette.Link,\n                   ""LinkVisited"" : QtGui.QPalette.LinkVisited,\n                   ""Mid"" : QtGui.QPalette.Mid,\n                   ""Midlight"" : QtGui.QPalette.Midlight,\n                   #""PlaceholderText"" : QtGui.QPalette.PlaceholderText, # requires Qt 5.12 but is not necessary (see https://doc.qt.io/qt-5/qpalette.html#placeholderText)\n                   ""Shadow"" : QtGui.QPalette.Shadow,\n                   ""Text"" : QtGui.QPalette.Text,\n                   ""ToolTipBase"" : QtGui.QPalette.ToolTipBase,\n                   ""ToolTipText"" : QtGui.QPalette.ToolTipText,\n                   ""Window"" : QtGui.QPalette.Window,\n                   ""WindowText"" : QtGui.QPalette.WindowText}\nPaletteStates = {""Active Version 1"":QtGui.QPalette.Active , ""Inactive Version 1"":QtGui.QPalette.Inactive , ""Disabled Version 1"":QtGui.QPalette.Disabled,\n                 ""Active Version 2"":QtGui.QPalette.Active , ""Inactive Version 2"":QtGui.QPalette.Inactive , ""Disabled Version 2"":QtGui.QPalette.Disabled,\n                 ""Active Version 3"":QtGui.QPalette.Active , ""Inactive Version 3"":QtGui.QPalette.Inactive , ""Disabled Version 3"":QtGui.QPalette.Disabled}\n\nColours = {""Dark"":Dark, ""Bright"":Bright, ""Deep Sea"":DeepSea, ""Blood Moon"":BloodMoon}\n'"
AGeLib/AGeMain.py,0,"b'# Astus General Library Main File\n\nVersion = ""2.0.0""\n# Using Semantic Versioning 2.0.0 https://semver.org/\nversion = Version\nAuthor = ""Robin \\\'Astus\\\' Albers""\n""""""\n    Copyright (C) 2020  Robin Albers\n""""""\n\ntry:\n    from AGeLib import AGeColour\nexcept ModuleNotFoundError:\n    import AGeColour\n\nimport sys\nfrom PyQt5 import QtWidgets,QtCore,QtGui,Qt\nfrom PyQt5.QtWebEngineWidgets import QWebEngineView # pylint: disable=no-name-in-module\nimport datetime\nimport time\nfrom time import time as timetime\nimport platform\nimport errno\nimport os\nimport re\nimport string\nimport traceback\nimport pathlib\nimport getpass\nimport importlib\nfrom packaging.version import parse as versionParser\n\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nfrom numpy import __version__ as numpy_version\n\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas\n\nfrom distutils.spawn import find_executable\nif find_executable(\'latex\') and find_executable(\'dvipng\'): LaTeX_dvipng_Installed = True\nelse : LaTeX_dvipng_Installed = False\n\n#TODO: Add documentation to ALL classes, methods and functions\n\n#region Notifications and exceptions\n\ncommon_exceptions = (TypeError , SyntaxError , sympy.SympifyError , sympy.parsing.sympy_parser.TokenError , re.error ,  AttributeError , ValueError , NotImplementedError , Exception , RuntimeError , ImportError)\ndef ExceptionOutput(exc_info = None, extraInfo = True):\n    """"""\n    Console output for exceptions\\n\n    Use in `except:`: Error = ExceptionOutput(sys.exc_info())\\n\n    Prints Time, ExceptionType, Filename+Line and (if extraInfo in not False) the exception description to the console\\n\n    Returns a string\n    """"""\n    try:\n        if False:\n            if exc_info == None:\n                exc_info = True\n            return NC(exc=exc_info)\n        else:\n            print(cTimeSStr(),"":"")\n            if exc_info==None:\n                exc_type, exc_obj, exc_tb = sys.exc_info()\n            else:\n                exc_type, exc_obj, exc_tb = exc_info\n            fName = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]\n            if extraInfo:\n                print(exc_type, "" in"", fName, "" line"", exc_tb.tb_lineno ,"": "", exc_obj)\n            else:\n                print(exc_type, "" in"", fName, "" line"", exc_tb.tb_lineno)\n            return str(exc_type)+"": ""+str(exc_obj)\n    except common_exceptions as inst:\n        print(""An exception occurred while trying to print an exception!"")\n        print(inst)\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass NotificationEvent(QtCore.QEvent):\n    EVENT_TYPE = QtCore.QEvent.Type(QtCore.QEvent.registerEventType())\n    def __init__(self, N):\n        QtCore.QEvent.__init__(self, NotificationEvent.EVENT_TYPE)\n        self.N = N\n\nclass NC: # Notification Class\n    """"""\n    This is the basic notification class of AGeLib.  \\n\n    All notifications are stored and accessible via the Notification Window which is opened by pressing on Notification button of any (AWWF) window.   \\n\n    Notifications are used to communicate with the user and can be used for exception handling as they provide space for an entire bug report.   \\n\n    They contain the version number of all modules that are in MainApp.ModuleVersions and can extract all information from exceptions.   \\n\n    There are various levels of notifications: lvl: 0 = Nothing , 1 = Error , 2 = Warning , 3 = Notification , 4 = Advanced Mode Notification , 10 = Direct Notification  \\n\n    The notification sends itself automatically. If you want to modify the notification before it is send set ``send=False`` and call ``.send()`` after the modifications are done  \\n\n    The creation is very flexible. Here are a few examples:   \\n\n    ```python\n    NC(10,""This message is directly displayed in the top bar and should be held very short and not contain any linebreaks (a single linebreak is ok in spacial cases)"")\n    NC(""This creates a normal notification"")\n    NC(2,""This creates a warning"")\n    NC((2,""A tuple with level and message is also acceptable""))\n    NC(""This generates an error notification with the last caught exception"",exc = sys.exc_info())\n    NC(""This notification includes the callstack"",tb=True)\n    ```\n    Even this is valid: ``NC()`` (Though not recommended)   \\n\n    ``lvl=0`` can be useful if you want to create a notification in a function (with ``Notification = NC(lvl=0,send=False)``), fill it with information dynamically and return it for the caller.\n    The caller can then send the Notification. If ``lvl=0`` the MainApp will ignore the notification thus the caller does not need to care whether the function actually had anything to notify the user about.   \\n\n    If you want to notify the user about exceptions ``exc`` should be ``True`` or ``sys.exc_info()``. If the exception should be logged but is usually not important set ``lvl=4``.\n    If the exception is not critical but should be noted as it might lead to unwanted behaviour set ``lvl=2`` to warn the user.\n    Exception notifications should set ``msg`` to give a short description that a regular user can understand (for example ``msg=""The input could not be interpreted.""`` or ``msg=""Could not connect to the website.""``).\n    It is also useful to set ``input`` to log the input that lead to the error. This should also include any settings that were used.   \\n\n    Only ``lvl=int``,``time=datetime.datetime.now()``,``send=bool`` and ``exc=True or sys.exc_info()`` need a specific data type.\n    Everything else will be stored (msg will be converted into a string before storing). The access methods will return a string (and cast all input to a string before saving)\n    but the variables can still be accessed directly with the data type that was given to the init.  \\n\n    Please note that ``err`` and ``tb`` are ignored when ``exc != None`` as they will be extracted from the exception.  \\n\n    ``tb`` should be a string containing the callstack or ``True`` to generate a callstack\n    """"""\n    def __init__(self, lvl=None, msg=None, time=None, input=None, err=None, tb=None, exc=None, win=None, func=None, DplStr=None, send=True):\n        """"""\n        Creates a new notification object  \\n\n        The creation is very flexible. Here are a few examples:   \\n\n        ```python\n        NC(10,""This message is directly displayed in the top bar and should be held short and without linebreaks"")\n        NC(""This creates a normal notification"")\n        NC(2,""This creates a warning"")\n        NC((2,""A tuple with level and message is also acceptable""))\n        NC(""This generates an error notification with the last caught exception"",exc = sys.exc_info())\n        NC(""This notification includes the callstack"",tb=True)\n        ```\n        lvl: 0 = Nothing , 1 = Error , 2 = Warning , 3 = Notification , 4 = Advanced Mode Notification , 10 = Direct Notification  \\n\n        ``exc = True`` or ``sys.exc_info()``   \\n\n        ``tb`` should be a string containing the callstack or ``True`` to generate a callstack\n        """"""\n        self._time_time = timetime()\n        self._init_Values()\n        self._was_send = False\n        try:\n            self._time = datetime.datetime.now() if time == None else time\n            self.Time = self._time.strftime(\'%H:%M:%S\')\n            self.DplStr = DplStr\n            self.Window = win\n            self.Function = func\n            self.Input = input\n            if exc != None:\n                if exc == True:\n                    self.exc_type, self.exc_obj, self.exc_tb = sys.exc_info()\n                else:\n                    self.exc_type, self.exc_obj, self.exc_tb = exc\n                fName = os.path.split(self.exc_tb.tb_frame.f_code.co_filename)[1]\n                if type(lvl)==str:\n                    self.level = 1\n                    self.Message = lvl\n                elif msg==None and type(lvl) == tuple:\n                    self.level, self.Message = lvl[0], lvl[1]\n                else:\n                    self.level = 1 if lvl == None else lvl\n                    self.Message = str(msg) if msg!=None else None\n                self.ErrorTraceback = str(self.exc_type)+""  in ""+str(fName)+""  line ""+str(self.exc_tb.tb_lineno)+""\\n\\n""+str(traceback.format_exc())#[:-1]) # TODO: Use traceback.format_exc() to get full traceback or something like traceback.extract_stack()[:-1] ([:-1] removes the NC.__init__())\n                print(self.Time,"":"")\n                if len(str(self.exc_obj))<150:\n                    self.Error = str(self.exc_type)+"": ""+str(self.exc_obj)\n                    print(self.exc_type, "" in"", fName, "" line"", self.exc_tb.tb_lineno,"": "", self.exc_obj)\n                else:\n                    self.Error = str(self.exc_type)\n                    self.ErrorLongDesc = str(self.exc_obj)\n                    print(self.exc_type, "" in"", fName, "" line"", self.exc_tb.tb_lineno)\n            else:\n                if type(lvl)==str:\n                    self.level = 3\n                    self.Message = lvl\n                elif msg==None and type(lvl) == tuple:\n                    self.level, self.Message = lvl[0], lvl[1]\n                else:\n                    self.level = 3 if lvl == None else lvl\n                    self.Message = str(msg) if msg!=None else None\n                self.Error = err\n                if tb == True:\n                    self.ErrorTraceback = """"\n                    try:\n                        for i in traceback.format_stack()[0:-1]:\n                            self.ErrorTraceback += str(i)\n                    except:\n                        self.ErrorTraceback = ""Could not extract callstack""\n                else:\n                    self.ErrorTraceback = tb\n            self.GenerateLevelName()\n            if send == True:\n                self.send()\n        except common_exceptions as inst:\n            self._init_Values()\n            print(cTimeSStr(),"": An exception occurred while trying to create a Notification"")\n            print(inst)\n            self._time = datetime.datetime.now() if time == None else time\n            self.Time = self._time.strftime(\'%H:%M:%S\')\n            self.Message = ""An exception occurred while trying to create a Notification""\n            self.exc_obj = inst\n            self.Error = str(inst)\n            self.GenerateLevelName()\n            self.send(force=True)\n\n    def _init_Values(self):\n        self.exc_type, self.exc_obj, self.exc_tb = None,None,None\n        self._time, self.Time, self.Error = None,None,None\n        self.Window, self.ErrorTraceback, self.Function = None,None,None\n        self.level, self.Level, self.Message = 1,""Notification level 1"",None\n        self.Input, self.ErrorLongDesc = None,None\n        self.DplStr, self.TTStr = None,None\n        self.icon = QtGui.QIcon()\n        try:\n            self.Flash = QtWidgets.QApplication.instance().NCF_NONE\n        except common_exceptions as inst:\n            print(inst)\n            self.Flash = None\n        self.itemDict = {""Time:\\n"":self.Time,""Level: "":self.Level,""Message:\\n"":self.Message,\n                        ""Error:\\n"":self.Error,""Error Description:\\n"":self.ErrorLongDesc,""Error Traceback:\\n"":self.ErrorTraceback,\n                        ""Function:\\n"":self.Function,""Window:\\n"":self.Window,""Input:\\n"":self.Input}\n  #---------- send, print ----------#\n    def send(self,force=False):\n        """"""\n        Displays this notification (This method is thread save but this object should not be modified after using send)   \\n\n        A notification can only be send once. ``force=True`` allows to send an already send notification again\n        """"""\n        if force or not self._was_send:\n            self._was_send = True\n            QtWidgets.QApplication.postEvent(QtCore.QThread.currentThread(), NotificationEvent(self))\n\n    def print(self):\n        """"""Prints this notification to the console""""""\n        print(""\\n"",self.Level, ""at"",self.Time,""\\nMessage:"",self.Message)\n        if self.Error != None:\n            print(""Error:"",self.Error,""Traceback:"",self.ErrorTraceback,""\\n"")\n  #---------- items, unpack ----------#\n    def items(self):\n        """"""\n        Returns self.itemDict.items()   \\n\n        self.itemDict contains all relevant data about this notification.  \\n\n        Please note that not all values are strings and should be converted before diplaying them.\n        This allows ``if v!=None:`` to filter out all empty entries.    \\n\n        The keys already end with ``:\\\\n`` thus it is advised to simply use ``k+str(v)`` for formatting.  \\n\n        For an example how to use this method see the source code of ``NotificationInfoWidget``.\n        """"""\n        self.itemDict = {""Time:\\n"":self.Time,""Level: "":""({})\\n{}"".format(str(self.level),self.Level),""Message:\\n"":self.Message,\n                        ""Error:\\n"":self.Error,""Error Description:\\n"":self.ErrorLongDesc,""Error Traceback:\\n"":self.ErrorTraceback,\n                        ""Function:\\n"":self.Function,""Window:\\n"":self.Window,""Input:\\n"":self.Input,""Versions:\\n"":QtWidgets.QApplication.instance().ModuleVersions}\n        return self.itemDict.items()\n\n    def unpack(self): #CLEANUP: remove unpack\n        """"""DEPRECATED: Returns a tuple ``(int(level),str(Message),str(Time))``""""""\n        return (self.level, str(self.Message), self.Time)\n  #---------- access variables ----------#\n    def l(self, level=None):\n        """"""\n        Returns int(level)  \\n\n        An int can be given to change the level\n        """"""\n        if level != None:\n            self.level = level\n            self.GenerateLevelName()\n        return self.level\n\n    def m(self, message=None):\n        """"""\n        Returns str(Message)  \\n\n        A str can be given to change the Message\n        """"""\n        if message != None:\n            self.Message = str(message)\n        if self.Message == None and self.Error != None:\n            return str(self.Error)\n        else:\n            return str(self.Message)\n        \n    def DPS(self, DplStr = None):\n        """"""\n        Returns str(DplStr)  \\n\n        DplStr is the string that is intended to be displayed directly   \\n\n        A str can be given to change the DplStr\n        """"""\n        if DplStr != None:\n            self.DplStr = str(DplStr)\n        elif self.DplStr == None:\n            if self.level == 10:\n                self.DplStr = self.m()\n            else:\n                self.DplStr = self.Level + "" at "" + self.t()\n        return str(self.DplStr)\n        \n    def TTS(self, TTStr = None):\n        """"""\n        Returns str(TTStr)  \\n\n        TTStr is the string that is intended to be displayed as the tool tip   \\n\n        A str can be given to change the TTStr\n        """"""\n        if TTStr != None:\n            self.TTStr = str(TTStr)\n        elif self.TTStr == None:\n            if self.level == 10:\n                self.TTStr = self.Level + "" at "" + self.t()\n            else:\n                self.TTStr = self.m()\n        return str(self.TTStr)\n\n    def t(self, time=None):\n        """"""\n        Returns the time as %H:%M:%S  \\n\n        datetime.datetime.now() can be given to change the time\n        """"""\n        if time != None:\n            self._time = time\n            self.Time = self._time.strftime(\'%H:%M:%S\')\n        return self.Time\n\n    def e(self, Error=None, ErrorTraceback=None):\n        """"""\n        Returns str(Error)  \\n\n        strings can be given to change the Error and ErrorTraceback\n        """"""\n        if Error != None:\n            self.Error = str(Error)\n        if ErrorTraceback != None:\n            self.ErrorTraceback = str(ErrorTraceback)\n        return str(self.Error)\n\n    def tb(self, ErrorTraceback=None):\n        """"""\n        Returns str(ErrorTraceback)  \\n\n        A str can be given to change the ErrorTraceback\n        """"""\n        if ErrorTraceback != None:\n            self.ErrorTraceback = str(ErrorTraceback)\n        return str(self.ErrorTraceback)\n\n    def f(self, func=None):\n        """"""\n        Returns str(Function)  \\n\n        A str can be given to change the Function  \\n\n        Function is the name of the function from which this notification originates\n        """"""\n        if func != None:\n            self.Function = str(func)\n        return str(self.Function)\n\n    def w(self, win=None):\n        """"""\n        Returns str(Window)  \\n\n        A str can be given to change the Window  \\n\n        Window is the name of the window from which this notification originates\n        """"""\n        if win != None:\n            self.Window = str(win)\n        return str(self.Window)\n\n    def i(self, input=None):\n        """"""\n        Returns str(Input)  \\n\n        A str can be given to change the Input  \\n\n        Input is the (user-)input that caused this notification\n        """"""\n        if input != None:\n            self.Input = str(input)\n        return str(self.Input)\n  #---------- GenerateLevelName ----------#\n    def GenerateLevelName(self):\n        """"""\n        Generates str(self.Level) from int(self.level)\n        """"""\n        try:\n            if self.level == 0:\n                self.Level = ""Empty Notification""\n                self.icon = QtGui.QIcon()\n                self.Flash = QtWidgets.QApplication.instance().NCF_NONE\n            elif self.level == 1:\n                self.Level = ""Error""\n                self.icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxCritical)\n                self.Flash = QtWidgets.QApplication.instance().NCF_r\n            elif self.level == 2:\n                self.Level = ""Warning""\n                self.icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxWarning)\n                self.Flash = QtWidgets.QApplication.instance().NCF_y\n            elif self.level == 3:\n                self.Level = ""Notification""\n                self.icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxInformation)\n                self.Flash = QtWidgets.QApplication.instance().NCF_b\n            elif self.level == 4:\n                self.Level = ""Advanced Mode Notification""\n                self.icon = QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxInformation)\n                self.Flash = QtWidgets.QApplication.instance().NCF_b\n            elif self.level == 10:\n                self.Level = ""Direct Notification""\n                self.icon = QtGui.QIcon()\n                self.Flash = QtWidgets.QApplication.instance().NCF_NONE\n            else:\n                self.Level = ""Notification level ""+str(self.level)\n                self.Flash = QtWidgets.QApplication.instance().NCF_b\n            return self.Level\n        except common_exceptions as inst:\n            print(inst)\n            return ""Could not generate Level Name""\n  #---------- __...__ ----------#\n    def __add__(self,other):\n        if self.Error != None:\n            return str(self.Error) + str(other)\n        else:\n            return str(self.Message) + str(other)\n\n    def __radd__(self,other):\n        if self.Error != None:\n            return str(other) + str(self.Error)\n        else:\n            return str(other) + str(self.Message)\n\n    def __call__(self):\n        return str(self.Message)\n\n    def __str__(self):\n        if self.Error != None:\n            if self.Message == None:\n                return ""Exception at ""+str(self.Time)+"":\\n""+str(self.Error)\n            else:\n                return str(self.Level)+"" at ""+str(self.Time)+"":\\n""+str(self.Message)+""\\n""+str(self.Error)\n        else:\n            return str(self.Level)+"" at ""+str(self.Time)+"":\\n""+str(self.Message)\n\n#endregion\n\n#region Helper Classes\nclass ColourDict(dict):\n    """"""\n    This class is used to store the special colours. \\n\n    It is used to ensure that a missing colour does not cause a crash by returning the ""Blue"" colour.\n    """"""\n    def __getitem__(self, key):\n        try:\n            Colour = dict.__getitem__(self, key)\n        except:\n            for v in self.values():\n                Colour = v\n                break\n        return Colour\n    \n    def copyFromDict(self, dict):\n        for i,v in dict.items():\n            self[i] = v\n\n#endregion\n\n#region Functions\n\ndef cTimeStr():\n    """"""\n    Returns the time (excluding seconds) as a string\\n\n    %H:%M\n    """"""\n    return str(datetime.datetime.now().strftime(\'%H:%M\'))\n\ndef cTimeSStr():\n    """"""\n    Returns the time (including seconds) as a string\\n\n    %H:%M:%S\n    """"""\n    return str(datetime.datetime.now().strftime(\'%H:%M:%S\'))\n\ndef cTimeFullStr(separator = None):\n    """"""\n    Returns the date and time as a string\\n\n    If given uses `separator` to separate the values\\n\n    %Y.%m.%d-%H:%M:%S or separator.join([\'%Y\',\'%m\',\'%d\',\'%H\',\'%M\',\'%S\'])\n    """"""\n    if separator == None:\n        return str(datetime.datetime.now().strftime(\'%Y.%m.%d-%H:%M:%S\'))\n    else:\n        TheFormat = separator.join([\'%Y\',\'%m\',\'%d\',\'%H\',\'%M\',\'%S\'])\n        return str(datetime.datetime.now().strftime(TheFormat))\n\ndef trap_exc_during_debug(*args):\n    # when app raises uncaught exception, send info\n    NC(1,""An unhandled exception occurred in a QThread!!!"",err=str(args))\n#endregion\n\n#region Shortcut Functions\n\ndef advancedMode() -> bool:\n    """"""\n    Used to check whether the advanced mode is active in the application.   \\n\n    The ``Main_App`` emits ``S_advanced_mode_changed`` when ``ToggleAdvancedMode`` is called.   \\n\n    ""Dangerous"" functions and ""rarely used"" should only be accessible if the advanced mode is on.\n    - ""Dangerous"": Dev-functions and anything that a user should not accidentely press.\n    - ""rarely used"": Anything that is rarely used and would clutter up the UI.   \\n\n    The advanced mode can also be used to determine the behaviour of certain function:\n    - off: Functionality is easy to use but is limited to the most frequent use cases\n    - on: User has full control over behaviour (which makes the controls more complex and time consuming) \\n\n    This can also be used to control the displayed information:\n    - off: Only relevant information is shown\n    - on: All information is shown (but the GUI is flooded with text)\n    """"""\n    return QtWidgets.QApplication.instance().advanced_mode\n\ndef App() -> QtWidgets.QApplication:\n    """"""Convenient shortcut for ``QtWidgets.QApplication.instance()``""""""\n    return QtWidgets.QApplication.instance()\n#endregion\n\n#region Application\n# ---------------------------------- Main Application ----------------------------------\nAltModifier = QtCore.Qt.AltModifier\nControlModifier = QtCore.Qt.ControlModifier\nGroupSwitchModifier = QtCore.Qt.GroupSwitchModifier\nShiftModifier = QtCore.Qt.ShiftModifier\nMetaModifier = QtCore.Qt.MetaModifier\n\nclass Main_App(QtWidgets.QApplication):\n    """"""\n    This class is the core of AGeLib.   \\n\n    Methods beginning with ``r_`` are virtual templates that can be reimplemented.   \\n\n    TODO: MORE INFO\n    """"""\n    #MAYBE: Make standard hotkeys optional (in case a dev wants to use these hotkeys) but write a warning that changing these is not recommended as it might confuse users that are used to the standard AGeLib Hotkeys\n #\n    # See:\n    # https://doc.qt.io/qt-5/qapplication.html\n    # https://doc.qt.io/qt-5/qguiapplication.html\n    # https://doc.qt.io/qt-5/qcoreapplication.html\n    S_New_Notification = QtCore.pyqtSignal(NC)\n    S_FontChanged = QtCore.pyqtSignal()\n    S_ColourChanged = QtCore.pyqtSignal()\n    S_advanced_mode_changed = QtCore.pyqtSignal(bool)\n    def __init__(self, args):\n        self.enableHotkeys = True\n        super(Main_App, self).__init__(args)\n        self.setStyle(""fusion"")\n        sys.excepthook = trap_exc_during_debug\n        try:\n            msg = ""Welcome "" + getpass.getuser()\n        except:\n            msg = ""Welcome""\n        self.LastNotificationText = msg\n        self.LastNotificationToolTip = msg\n        self.LastNotificationIcon = QtGui.QIcon()\n\n        self.MainWindow = None\n        self.Notification_Window = None\n        self.exec_Window = None\n        self.optionWindow = None\n        self.AppPalettes = {}\n        \n        self.installEventFilter(self)\n        self.aboutToQuit.connect(self._SaveClipboard)\n\n        self.advanced_mode = False\n        \n        self.setOrganizationName(""Robin Albers"")\n        self.setOrganizationDomain(""https://github.com/AstusRush"")\n        self.Notification_List = []\n        self._init_NCF()\n        self._MakeAGeLibPath()\n        ###########################\n        #TODO: Load Settings like standard palette and font\n        #self.Palette , self.BG_Colour , self.TextColour = AGeColour.Dark()\n        #self.colour_Pack = (self.Palette , self.BG_Colour , self.TextColour)\n        self.Colour_Font_Init()\n        self.ModuleVersions = ""Python %s\\nAGeLib %s\\nSymPy %s\\nNumpy %s\\nMatplotLib %s\\nPyQt %s (Qt %s)"" % (""%d.%d"" % (sys.version_info.major, sys.version_info.minor),\n                version,\n                sympy.__version__,\n                numpy_version,\n                matplotlib.__version__,\n                QtCore.PYQT_VERSION_STR, QtCore.qVersion())\n        \n        self.r_init_Options()\n\n    def setMainWindow(self, TheWindow):\n        """"""\n        This method allows you to declare the primary window of your application.   \\n\n        You can use ``self.MainWindow`` to access it.   \\n\n        Setting a main window is not obligatory and does nothing on its own.   \\n\n        The intention behind declaring a main window is to make the code more readable\n        and to provide a convenient way to refer to it.   \\n\n        This can also be useful if a function needs to access the main window in an application where the main window changes.\n        """"""\n        self.MainWindow = TheWindow\n    \n    #def notify(self, obj, event): # Reimplementation of notify that does nothing other than redirecting to normal implementation for now...\n        #try:\n        #    return super().notify(obj, event)\n        #except:\n        #    ExceptionOutput(sys.exc_info())\n        #    print(""Caught: "",obj,event)\n        #    return False\n    \n    def eventFilter(self, source, event):\n        if event.type() == 6 and self.enableHotkeys: # QtCore.QEvent.KeyPress\n            if event.key() == QtCore.Qt.Key_F12:\n                if self.AGeLibPathOK:\n                    name = self.applicationName()\n                    nameValid = """"\n                    for i in name:\n                        if i in string.ascii_letters + string.digits + ""~ -_."":\n                            nameValid += i\n                    nameValid = nameValid.replace("" "","""")\n                    Filename = nameValid + ""-"" + cTimeFullStr(""-"") + "".png""\n                    Filename = os.path.join(self.ScreenshotFolderPath,Filename)\n                    try:\n                        try:\n                            WID = source.window().winId()\n                            screen = source.window().screen()\n                        except:\n                            WID = source.winId()\n                            screen = source.screen()\n                        screen.grabWindow(WID).save(Filename)\n                        print(Filename)\n                    except:\n                        NC(msg=""Could not save Screenshot"",exc=sys.exc_info(),func=""Main_App.eventFilter"",input=Filename)\n                    else:\n                        NC(3,""Screenshot of currently active window saved as:\\n""+Filename,func=""Main_App.eventFilter"",input=Filename)\n                else:\n                    print(""Could not save Screenshot: Could not validate save location"")\n                    NC(1,""Could not save Screenshot: Could not validate save location"",func=""Main_App.eventFilter"",input=self.AGeLibPath)\n                return True\n            if event.modifiers() == ControlModifier:\n                if event.key() == QtCore.Qt.Key_0: # FEATURE: HelpWindow: Inform the User that this feature exists. Make Help window that is opened with F1\n                    for w in self.topLevelWidgets():\n                        if w.isVisible():\n                            w.positionReset()\n                    return True\n                if event.key() == QtCore.Qt.Key_T:\n                    self.Show_exec_Window()\n                    return True\n            if event.modifiers() == AltModifier:\n                if event.key() == QtCore.Qt.Key_A:\n                    self.ToggleAdvancedMode(not self.advanced_mode)\n                    return True\n                elif event.key() == QtCore.Qt.Key_O:\n                    self.Show_Options()\n                    return True\n        elif event.type() == NotificationEvent.EVENT_TYPE:\n            self._NotifyUser(event.N)\n            return True\n        return super(Main_App, self).eventFilter(source, event)\n\n    def _SaveClipboard(self):\n        """"""\n        On MS Windows this method ensures that the clipboard is kept:\\n\n        The contents of the clipboard are only stored as references.\n        When you copy text from an application it can be pasted in all other applications\n        but as soon as you close the application the reference is no longer valid and the clipboard is empty.  \\n\n        Note: This is not a problem if the user has a clipboard manager as they don\'t use references but instead copy the data.  \\n\n        On MS Windows this method writes the text into the clipboard.\n        On other platforms it gives the clipboard manager an additional chance to copy the data.  \\n\n        This method is called automatically when the application exits and does not need to be called manually\n        except if you expect your program to crash regularly and want to ensure that the clipboard is not lost\n        on systems that have no active clipboard manager.\n        """"""\n        clipboard = Qt.QApplication.clipboard()\n        if platform.system() == \'Windows\':\n            try:\n                import win32clipboard\n                text = clipboard.text()\n                win32clipboard.OpenClipboard()\n                win32clipboard.EmptyClipboard()\n                win32clipboard.SetClipboardText(text)\n                win32clipboard.CloseClipboard()\n            except:\n                print(""Could not save clipboard data:"")\n                ExceptionOutput(sys.exc_info())\n        else: #FEATURE: Find a linux version of win32clipboard\n            print(""Clipboard is only saved if a clipboard manager is installed due to OS limitations."")\n            event = QtCore.QEvent(QtCore.QEvent.Clipboard)\n            Qt.QApplication.sendEvent(clipboard, event)\n            self.processEvents()\n            \n    def ToggleAdvancedMode(self, checked):\n        """"""\n        This function changes the state of the advanced mode to ``checked``.   \\n\n        ``S_advanced_mode_changed`` is emitted and the checkbox ``AdvancedCB`` of all ``TopBar_Widget``\'s is updated. \\n\n        Do not change ``advanced_mode`` manually!!! Always use this function!\n        """"""\n        try:\n            self.advanced_mode = checked\n            for w in self.topLevelWidgets():\n                for i in w.findChildren(TopBar_Widget):\n                    if i.IncludeAdvancedCB:\n                        i.AdvancedCB.setChecked(self.advanced_mode)\n            self.S_advanced_mode_changed.emit(self.advanced_mode)\n        except:\n            NC(1,""Exception while toggling advanced mode"",exc=sys.exc_info(),func=""Main_App.ToggleAdvancedMode"",input=""{}: {}"".format(str(type(checked)),str(checked)))\n\n # ---------------------------------- Colour and Font ----------------------------------\n    def Recolour(self, Colour = ""Dark""):\n        """"""\n        Applies a colour scheme:   \\n\n        This method takes the name (string) of a colour scheme. \\n\n        First AGeColour (standard AGeLib colours) and CustomColourPalettes (user created colours) are (re-)imported and their dictionaries are loaded. \\n\n        Then the AGeColour dict is searched for the name. If it is not found the dict of CustomColourPalettes is searched. AppPalettes is searched last.  \\n\n        As soon as the name is found the colourpalette is applied (by calling _Recolour). \\n\n        Please note: \\n\n        If you have code that needs to run after the palette has changed (like applying colours to specific widgets) reimplement ``r_Recolour``. \\n\n        ``r_Recolour`` is called by ``_Recolour`` after the new palette has been applied. \\n\n        Furthermore the signal ``S_ColourChanged`` is emitted after ``_Recolour``. \\n\n        To add custom colour palettes for your application use the method ``AddPalette``. \\n \\n\n        COLOURS\n        ===========\n        + ``Palette1``, ``Palette2`` and ``Palette3`` and full QPalettes that can be used to colour different ports of the UI. Use ``r_Recolour`` to apply these Palettes to widgets.\n        ``Palette`` is deprecated and only accessible for compatibility reasons! It will be removed in future versions!\n        + ``BG_Colour`` and ``TextColour`` can be used to colour different parts that are incompatible with QPalettes.\n        These are tuples with 3 floats between 0 and 1 that specify RGB values and are taken from the Base and Text colours from Palette1.\n        + ``PenColours`` is a dict containing QBrushes. Use ``.color()`` to access the QColor.\n        The colours in this dict are visually distinct from the background (and don\'t necessarily correspond to their name).\n        These colours should be used for graphs (and are automatically set as the numpy colour cycle), pen colours for editors,\n        player colours for games and all other cases where visually distinct colours are needed.\n        + ``NotificationColours`` is a dict that contains the colours for the notification flashes but can also be used for similar purposes like highlighting text.\n        + ``MiscColours`` is a dict for all other colour needs. It contains some basic colours that are labelled for games but I encourage creative interpretation!\n        The colours that are labelled for rarity for example could also be used to colourcode a dataset regarding the importance of the values:\n        Common values are coloured as common and rare values that need attention are coloured as rare. \\n\n\n        These dicts are subclassed to ensure that a bracket access (dict[""key""]) on an invalid key returns a random colour instead of raising an exception to allow expansion.\n        However it is not advisable to expand these dicts at the moment. This colour system is still WIP and might change in the future.\n        """"""\n        try:\n            try:\n                importlib.reload(AGeColour)\n            except:\n                NC(2,""Could not reload AGeColour"",exc=sys.exc_info(),func=""Main_App.Recolour"",input=str(Colour))\n            try:\n                spec = importlib.util.spec_from_file_location(""CustomColourPalettes"", os.path.join(self.AGeLibSettingsPath,""CustomColourPalettes.py""))\n                CustomColours = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(CustomColours)\n                #CustomColours.MyClass()\n            except:\n                NC(4,""Could not load custom colours"",exc=sys.exc_info(),func=""Main_App.Recolour"",input=str(Colour))\n            try:\n                self._Recolour(*AGeColour.Colours[Colour]())\n            except:\n                try:\n                    self._Recolour(*CustomColours.Colours[Colour]())\n                except:\n                    self._Recolour(*self.AppPalettes[Colour]())\n        except:\n            NC(1,""Exception while loading colour palette"",exc=sys.exc_info(),func=""Main_App.Recolour"",input=str(Colour))\n            \n    def AddPalette(self, name, palette):\n        """"""\n        Use this method to add custom colour palettes. (They are saved in the dict ``AppPalettes``.) \\n\n        ``name`` should be a string and ``palette`` must be a function that returns the palette. \\n\n        Please note that the users custom colours take priority over application palettes\n        thus you need to add a tag in front of your names that no user would ever use\n        (for example your application name in square brackets (like ``[AMaDiA] Dark``)). \\n\n        The tag must be unique enough to ensure that no user would ever use it in a custom name!\n        """"""\n        self.AppPalettes[name] = palette\n            \n    def _Recolour(self, Palette1, Palette2, Palette3, PenColours, NotificationColours, MiscColours):\n        """"""\n        This method is called by ``Recolour`` to apply the colour palette. \\n\n        For all colour palette changes ``Recolour`` should be used. \\n\n        If you have code that needs to run after the palette has changed (like applying colours to specific widgets) reimplement ``r_Recolour``.\n        """"""\n        self.Palette = Palette1 #TODO: Remove self.Palette\n        self.Palette1 = Palette1\n        self.Palette2 = Palette2\n        self.Palette3 = Palette3\n        self.PenColours = ColourDict()\n        self.PenColours.copyFromDict(PenColours)\n        self.NotificationColours = ColourDict()\n        self.NotificationColours.copyFromDict(NotificationColours)\n        self.MiscColours = ColourDict()\n        self.MiscColours.copyFromDict(MiscColours)\n        Colour = self.Palette1.color(QtGui.QPalette.Active,QtGui.QPalette.Base)\n        self.BG_Colour = (Colour.red()/255,Colour.green()/255,Colour.blue()/255)\n        Colour = self.Palette1.color(QtGui.QPalette.Active,QtGui.QPalette.Text)\n        self.TextColour = (Colour.red()/255,Colour.green()/255,Colour.blue()/255)\n        self.colour_Pack = (self.Palette , self.BG_Colour , self.TextColour) #TODO: remove self.colour_Pack\n        self.setPalette(self.Palette)\n        QtWidgets.QToolTip.setPalette(self.Palette)\n        self._update_NCF()\n        \n        c=[]\n        for v in self.PenColours.values():\n            c.append(v.color().name(0))\n        self.mplCycler = matplotlib.cycler(color=c) \n        matplotlib.rcParams[\'axes.prop_cycle\'] = self.mplCycler\n\n        for w in self.topLevelWidgets():\n            for i in w.findChildren(MplWidget):\n                i.SetColour(self.BG_Colour, self.TextColour, self.mplCycler)\n            #for i in w.findChildren(Window_Frame_Widget):\n            #    i.setPalette(FramePalette)\n        self.r_Recolour()\n        self.S_ColourChanged.emit()\n        \n    def r_Recolour(self):\n        """"""\n        This method is called after the colour palette has changed.   \\n\n        All GUI elements usually use the palette of the application but if the method ``setPalette`` is called\n        the element looses the ability to inherit from the Application and needs special treatment.   \\n\n        Reimplement this method to provide such special treatment. \\n\n        For example ``Palette2`` and ``Palette3`` should only be applied to widgets in this method! \\n\n        Furthermore everything that uses ``PenColours``, ``NotificationColours`` or ``MiscColours`` should be updated here or by connecting a custom function to ``S_ColourChanged``.\n        """"""\n        pass\n    \n    def Colour_Font_Init(self):\n        # TODO: Accept more arguments for FontFamily, PointSize and colour Palette Name and use defaults if none were given or if something went wrong while applying them\n        self.FontFamily = ""Arial""\n        font = QtGui.QFont()\n        font.setFamily(""Arial"")\n        font.setPointSize(9)\n        self.setFont(font)\n        self.Recolour()\n\n        # Always keep Statusbar Font small\n        font = QtGui.QFont()\n        font.setFamily(""Arial"")\n        font.setPointSize(9)\n        for w in self.topLevelWidgets():\n            for i in w.findChildren(QtWidgets.QStatusBar):\n                try:\n                    i.setFont(font)\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n\n    def SetFont(self, Family=None, PointSize=0, source=None, emitSignal=True):\n        """"""\n        Changes the font to ``Family`` and the font size to ``PointSize`` for the entire application.  \\n\n        ``Family``: QFont, string or None (None keeps old family and only changes font size)  \\n\n        ``PointSize``: int, if 0 ans ``Family`` is QFont the pointsize of QFont is used. \\n\n        ``source`` : The window from which the font was changed  \\n\n        If ``PointSize`` is less than 5 the value from the Font_Size_spinBox of ``source`` will be taken. If this fails it defaults to 9. \\n\n        ``emitSignal``: If True (default) ``S_FontChanged`` is emitted after the new font is applied. \\n\\n\n        Furthermore the Font_Size_spinBox of all windows is updated with the new value (the signals of Font_Size_spinBox are blocked during the update).\\n\n        All ``TopBar_Widget``s are resized. \\n\n        The fontsize of all statusbars is always kept at 9 but the font family is updated.\n        """"""\n        if type(Family) == QtGui.QFont:\n            if PointSize==0:\n                PointSize = Family.pointSize()\n            Family = Family.family()\n            self.FontFamily = Family\n        elif Family == None:\n            Family = self.FontFamily\n        else:\n            self.FontFamily = Family\n        if type(PointSize) == str:\n            PointSize = int(PointSize)\n        if PointSize < 5:\n            try:\n                PointSize = source.TopBar.Font_Size_spinBox.value()\n            except common_exceptions:\n                try:\n                    NC(msg=""Could not read Font_Size_spinBox.value()"",exc=sys.exc_info(),func=""Main_App.SetFont"",win=source.windowTitle())\n                except common_exceptions:\n                    NC(msg=""Could not read Font_Size_spinBox.value()"",exc=sys.exc_info(),func=""Main_App.SetFont"")\n                PointSize = 9\n        if type(PointSize) != int:\n            print(type(PointSize),"" is an invalid type for font size ("",PointSize,"")"")\n            try:\n                NC(msg=""{} is an invalid type for font size ({})"".format(str(type(PointSize)),str(PointSize)),exc=sys.exc_info(),func=""Main_App.SetFont"",win=source.windowTitle())\n            except:\n                NC(msg=""{} is an invalid type for font size ({})"".format(str(type(PointSize)),str(PointSize)),exc=sys.exc_info(),func=""Main_App.SetFont"")\n            PointSize = 9\n                \n        for w in self.topLevelWidgets():\n            for i in w.findChildren(TopBar_Widget):\n                try:\n                    if i.IncludeFontSpinBox:\n                        # setValue emits ValueChanged and thus calls ChangeFontSize if the new Value is different from the old one.\n                        # If the new Value is the same it is NOT emitted.\n                        # To ensure that this behaves correctly either way the signals are blocked while changing the Value.\n                        i.Font_Size_spinBox.blockSignals(True)\n                        i.Font_Size_spinBox.setValue(PointSize)\n                        i.Font_Size_spinBox.blockSignals(False)\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n        \n        font = QtGui.QFont()\n        font.setFamily(Family)\n        font.setPointSize(PointSize)\n        self.setFont(font)\n        for w in self.topLevelWidgets():\n            for i in w.findChildren(TopBar_Widget):\n                try:\n                    if type(i.parentWidget()) == MMenuBar:\n                        i.setMinimumHeight(i.parentWidget().minimumHeight())\n                    elif type(i.parentWidget()) == QtWidgets.QTabWidget:\n                        i.setMinimumHeight(i.parentWidget().tabBar().minimumHeight())\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n        # Always keep Statusbar Font small\n        font = QtGui.QFont()\n        font.setFamily(Family)\n        font.setPointSize(9)\n        for w in self.topLevelWidgets():\n            for i in w.findChildren(QtWidgets.QStatusBar):\n                try:\n                    i.setFont(font)\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n        if emitSignal:\n            self.S_FontChanged.emit()\n\n # ---------------------------------- Notifications ----------------------------------\n\n    def _init_NCF(self): # Notification_Flash\n        """"""\n        NO INTERACTION NEEDED \\n\n        Initiates the notification flash animations. This method is called automatically.\n        """"""\n        self.NCF_NONE = QtCore.QPropertyAnimation(self)\n        \n        self.NCF_r = QtCore.QPropertyAnimation(self,b\'FLASH_colour\')\n        self.NCF_r.setDuration(1000)\n        self.NCF_r.setLoopCount(1)\n        #self.NCF_r.finished.connect(self._NCF_Finished)\n        \n        self.NCF_y = QtCore.QPropertyAnimation(self,b\'FLASH_colour\')\n        self.NCF_y.setDuration(1000)\n        self.NCF_y.setLoopCount(1)\n        #self.NCF_y.finished.connect(self._NCF_Finished)\n        \n        self.NCF_g = QtCore.QPropertyAnimation(self,b\'FLASH_colour\')\n        self.NCF_g.setDuration(1000)\n        self.NCF_g.setLoopCount(1)\n        #self.NCF_g.finished.connect(self._NCF_Finished)\n        \n        self.NCF_b = QtCore.QPropertyAnimation(self,b\'FLASH_colour\')\n        self.NCF_b.setDuration(1000)\n        self.NCF_b.setLoopCount(1)\n        #self.NCF_b.finished.connect(self._NCF_Finished)\n\n    def _update_NCF(self):\n        """"""\n        NO INTERACTION NEEDED \\n\n        Updates the notification flash animations. This method is called automatically.\n        """"""\n\n        self.NCF_r.setStartValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_r.setEndValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_r.setKeyValueAt(0.5, self.NotificationColours[""Error""].color())\n        \n        self.NCF_y.setStartValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_y.setEndValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_y.setKeyValueAt(0.5, self.NotificationColours[""Warning""].color())\n        \n        self.NCF_g.setStartValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_g.setEndValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_g.setKeyValueAt(0.5, self.NotificationColours[""Message""].color())\n        \n        self.NCF_b.setStartValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_b.setEndValue(self.Palette.color(QtGui.QPalette.Window))\n        self.NCF_b.setKeyValueAt(0.5, self.NotificationColours[""Notification""].color())\n\n    def _set_FLASH_colour(self, col): # Handles changes to the Property FLASH_colour\n        """"""\n        NO INTERACTION NEEDED \\n\n        Helpfunction that handles changes to the Property FLASH_colour.\n        """"""\n        palette = self.Palette\n        palette.setColor(QtGui.QPalette.Window, col)\n        self.setPalette(palette)\n    FLASH_colour = QtCore.pyqtProperty(QtGui.QColor, fset=_set_FLASH_colour) # Defines the Property FLASH_colour\n    \n    #def _NCF_Finished(self):\n    #    """"""\n    #    This method is called when a notification flash animation is finished. \\n\n    #    """"""\n    #    pass#self.TopBar_Error_Label.setFrameShape(QtWidgets.QFrame.NoFrame)\n\n    def _NotifyUser(self, N):\n        """"""\n        NO INTERACTION NEEDED \\n\n        Displays the notification ``N`` to the user. \\n\n        This method should not be used manually!\n        """"""\n        if N.l() == 0:\n            return\n        elif N.l()!=4 or self.advanced_mode:\n            Error_Text_TT,icon = self._ListVeryRecentNotifications(N)\n            self.LastNotificationText = N.DPS()\n            self.LastNotificationToolTip = Error_Text_TT\n            self.LastNotificationIcon = icon\n            for w in self.topLevelWidgets():\n                for i in w.findChildren(TopBar_Widget):\n                    if i.IncludeErrorButton:\n                        i.Error_Label.setText(N.DPS())\n                        i.Error_Label.setToolTip(Error_Text_TT)\n                        i.Error_Label.setIcon(icon)\n            if (not N.Flash == self.NCF_NONE) and (not N.Flash == None):\n                N.Flash.start()\n        \n        self.Notification_List.append(N)\n        self.S_New_Notification.emit(N)\n        # Allow the button to adjust to the new text:\n        for w in self.topLevelWidgets():\n            for i in w.findChildren(TopBar_Widget):\n                if i.IncludeErrorButton:\n                    i.parentWidget().adjustSize()\n        # REMINDER: Somewhere you need to make the error message ""Sorry Dave, I can\'t let you do this.""\n        \n    def _ListVeryRecentNotifications(self, N):\n        """"""\n        NO INTERACTION NEEDED \\n\n        This helpfunction is used by _NotifyUser to generate the tooltip for the notification button.\n        """"""\n        cTime = time.time()\n        Error_Text_TT = N.TTS()\n        level = N.l()\n        icon = N.icon\n        for i in range(len(self.Notification_List)):\n            if i< 10 and cTime - self.Notification_List[-i-1]._time_time < 2 and len(Error_Text_TT.splitlines())<40:\n                if self.Notification_List[-i-1].l()!=0 and (self.Notification_List[-i-1].l()!=4 or self.advanced_mode):\n                    Error_Text_TT += ""\\n\\n""\n                    Error_Text_TT += str(self.Notification_List[-i-1])\n                    cTime = self.Notification_List[-i-1]._time_time\n                    if level > self.Notification_List[-i-1].l():\n                        level = self.Notification_List[-i-1].l()\n                        icon = self.Notification_List[-i-1].icon\n            else:\n                break\n        return (Error_Text_TT,icon)\n\n # ---------------------------------- SubWindows ----------------------------------\n\n    def r_init_Options(self):\n        """"""\n        This method initializes the standard options window and is called automatically. \\n\n        If you want a custom options window reimplement this method with the following code:\\n\n        ```python\n        self.optionWindow = Custom_Options_Window()\n        ```\n        and replace ``Custom_Options_Window`` with your own class that is derived from AWWF. \\n\n        Your custom options window should include the widget ``OptionsWidget_1_Appearance``!!!\n        """"""\n        self.optionWindow = Options_Window()\n    \n    def Show_Notification_Window(self):\n        """"""\n        Shows a window that lists all notifications and displays their details. \\n\n        Default access: pressing the notification button\n        """"""\n        if self.Notification_Window == None:\n            self.Notification_Window = Notification_Window()\n        self.Notification_Window.show()\n        self.processEvents()\n        self.Notification_Window.positionReset()\n        self.processEvents()\n        self.Notification_Window.activateWindow()\n\n    def Show_exec_Window(self):\n        """"""\n        Shows a window that can execute code within the program. (This window is very useful for debugging) \\n\n        Default shortcut (applicationwide): ctrl+T\n        """"""\n        if self.exec_Window == None:\n            self.exec_Window = exec_Window()\n        self.exec_Window.show()\n        self.processEvents()\n        self.exec_Window.positionReset()\n        self.processEvents()\n        self.exec_Window.activateWindow()\n\n    def Show_Options(self):\n        """"""\n        Shows the options window. \\n\n        Default shortcut (applicationwide): alt+O\n        """"""\n        self.optionWindow.show()\n        self.optionWindow.activateWindow()\n\n # ---------------------------------- Other ----------------------------------\n\n    def _MakeAGeLibPath(self):\n        """"""\n        NO INTERACTION NEEDED \\n\n        This method creates/finds/validates the path to the AGeLib config directory.\n        """"""\n        self.AGeLibPathOK = False\n        self.AGeLibPath = False\n        self.AGeLibSettingsPath = False\n        self.ScreenshotFolderPath = False\n        try:\n            self.AGeLibPath = os.path.join(os.path.expanduser(""~""),""AGeLib"")\n            os.makedirs(self.AGeLibPath,exist_ok=True)\n            #\n            self.AGeLibSettingsPath = os.path.join(self.AGeLibPath,""Settings"")#ProgramFiles\n            os.makedirs(self.AGeLibSettingsPath,exist_ok=True)\n            FileName = os.path.join(self.AGeLibSettingsPath,""CustomColourPalettes.py"")\n            with open(FileName,\'a\',encoding=""utf-8"") as text_file:\n                pass\n            if os.stat(FileName).st_size == 0:\n                with open(FileName,\'w\',encoding=""utf-8"") as text_file:\n                    text_file.write(r""Colours={}"")\n            # Create Screenshots folder\n            self.ScreenshotFolderPath = os.path.join(self.AGeLibPath,""Screenshots"")\n            os.makedirs(self.ScreenshotFolderPath,exist_ok=True)\n            #\n            self.ProgramFilesFolderPath = os.path.join(self.AGeLibPath,""ProgramFiles"")\n            os.makedirs(self.ProgramFilesFolderPath,exist_ok=True)\n            #\n            self.AGeLibPathOK = True\n        except:\n            NC(1,""Could not create/validate AGeLib folder"",exc=sys.exc_info())\n        try:\n            self.r_CreateFolders()\n        except:\n            NC(1,""Could not create/validate program specific folders"",exc=sys.exc_info())\n\n    def r_CreateFolders(self):\n        """"""\n        This Function is called automatically at the end of ``_MakeAGeLibPath`` which is called by the ``__init__``. \\n\n        Reimplement this function to create folders. \\n\n        It is recommended to create a program specific folder in ``self.AGeLibPath``. \\n\n        Example:\\n\n        ```python\n        self.Folder = os.path.join(self.AGeLibPath,""PROGRAM_NAME"")\n        os.makedirs(self.Folder,exist_ok=True)\n        ```\n        """"""\n        pass\n#endregion\n\n#region Widgets\n#FEATURE: Make a more performant Plotter Widget using pyqtgraph. This boost in performance should allow plot interactions. See https://www.learnpyqt.com/courses/graphics-plotting/plotting-pyqtgraph/\n#FEATURE: All plot widgets should be able to give the coordinates of the mouse cursor to make them easier to read. (This should be toggleable to not interfere with other interactions.)\n#MAYBE: Make a plotting widget that can take in any lists and make a plot. This specifically means detecting the dimensions and making a 2D or 3D plot depending on the input\n#FEATURE: Make a more performant LaTeX Widget\n\n#LaTeX Widget:\n#import sys\n#from PyQt5.QtWebEngineWidgets import QWebEngineView\n#\n#pageSource = r""""""\n#             <html><head>\n#             <script type=""text/javascript"" src=""https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"">                     \n#             </script></head>\n#             <body bgcolor="" """"""+str(App().palette().base().color().name(0))+r"""""" "">\n#             <p><mathjax style=""font-size:2.3em; color: """"""+str(App().palette().text().color().name(0))+r"""""""">$$\\displaystyle \\frac{2 \\cdot 3 \\int \\left(x + 2 x\\right)\\, dx}{6} $$</mathjax></p>\n#             </body></html>\n#             """"""\n#self.webWindow = AWWF()\n#self.webView = QWebEngineView()\n#self.webView.setHtml(pageSource)\n##self.webView.setUrl(QtCore.QUrl(""https://www.google.com""))\n#self.webWindow.setCentralWidget(self.webView)\n#self.webWindow.show()\n\nclass MplWidget(QtWidgets.QWidget):\n    def __init__(self, parent=None):\n        super(MplWidget, self).__init__(parent)\n        self.background_Colour = QtWidgets.QApplication.instance().BG_Colour\n        self.TextColour = QtWidgets.QApplication.instance().TextColour\n        self.Cycler = QtWidgets.QApplication.instance().mplCycler\n\n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        if BG!=None:\n            self.background_Colour = BG\n        if FG!=None:\n            self.TextColour = FG\n        if type(Cycler)!=None:\n            self.Cycler = Cycler\n        self.HexcolourText = \'#%02x%02x%02x\' % (int(self.TextColour[0]*255),int(self.TextColour[1]*255),int(self.TextColour[2]*255))\n        try:\n            self.canvas.fig.set_facecolor(self.background_Colour)\n            self.canvas.fig.set_edgecolor(self.background_Colour)\n            self.canvas.ax.set_facecolor(self.background_Colour)\n            self.canvas.ax.set_prop_cycle(self.Cycler)\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n        try:\n            self.canvas.draw()\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n\n    #def eventFilter(self, source, event):\n    #    if event.type() == QtCore.QEvent.PaletteChange:\n    #        try:\n    #            source.SetColour(QtWidgets.QApplication.instance().BG_Colour , QtWidgets.QApplication.instance().TextColour)\n    #        except common_exceptions:\n    #            ExceptionOutput(sys.exc_info())\n    #    return super(MplWidget, self).eventFilter(source, event)\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass MplCanvas_2D_Plot(Canvas):\n    def __init__(self):\n        #plt.style.use(\'dark_background\')\n        self.fig = Figure(constrained_layout =True)\n        self.fig.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n        \n        self.ax = self.fig.add_subplot(111)\n        \n        self.ax.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n        \n        Canvas.__init__(self, self.fig)\n        Canvas.setSizePolicy(self, QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        Canvas.updateGeometry(self)\n\nclass MplWidget_2D_Plot(MplWidget):\n    # Inspired by https://stackoverflow.com/questions/43947318/plotting-matplotlib-figure-inside-qwidget-using-qt-designer-form-and-pyqt5?noredirect=1&lq=1 from 10.07.2019\n    def __init__(self, parent=None):\n        super(MplWidget_2D_Plot, self).__init__(parent)\n        self.canvas = MplCanvas_2D_Plot()                  # Create canvas object\n        self.vbl = QtWidgets.QVBoxLayout()         # Set box for plotting\n        self.vbl.addWidget(self.canvas)\n        self.setLayout(self.vbl)\n        self.layout().setContentsMargins(0,0,0,0)\n        \n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        super(MplWidget_2D_Plot, self).SetColour(BG,FG,Cycler)\n        self.canvas.ax.spines[\'bottom\'].set_color(self.TextColour)\n        self.canvas.ax.spines[\'left\'].set_color(self.TextColour)\n        self.canvas.ax.xaxis.label.set_color(self.TextColour)\n        self.canvas.ax.yaxis.label.set_color(self.TextColour)\n        self.canvas.ax.tick_params(axis=\'x\', colors=self.TextColour)\n        self.canvas.ax.tick_params(axis=\'y\', colors=self.TextColour)\n        self.canvas.draw()\n    \n    def UseTeX(self,TheBool):\n        # This Method changes the settings for not only one but all widgets...\n        # This makes the clear function of the plotter slow if the LaTeX display has been used in LaTeX mode directly before\n        # It could help to separate the two widgets into two files...\n        # ... but it is also possible that this setting is global not only for the file but the program which would make the seperation a massive waste of time...\n        # Maybe test this in a little testprogram to not waste that much time...\n        \n        #Both seem to do the same:\n        matplotlib.rcParams[\'text.usetex\'] = TheBool\n        plt.rc(\'text\', usetex=TheBool)\n        return matplotlib.rcParams[\'text.usetex\']\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass MplCanvas_LaTeX(Canvas):\n    def __init__(self,w,h):\n        #plt.style.use(\'dark_background\')\n        #self.fig = Figure(constrained_layout =True)\n        self.fig = Figure(figsize = (w,h),dpi=90)\n        self.fig.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n        \n        #h = [Size.Fixed(1.0), Size.Fixed(4.5)]\n        #v = [Size.Fixed(0.7), Size.Fixed(5.)]\n        #divider = Divider(self.fig, (0.0, 0.0, 1., 1.), h, v, aspect=False)\n        \n        self.ax = self.fig.add_subplot(111)\n        #self.ax = Axes(self.fig, divider.get_position())\n        \n        self.ax.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n        self.ax.set_anchor(\'W\')\n        self.fig.subplots_adjust(left=0.01)\n        self.ax.axis(\'off\')\n        \n        #self.ax.set_axes_locator(divider.new_locator(nx=1, ny=1))\n        #self.fig.add_axes(self.ax)\n        \n        Canvas.__init__(self, self.fig)\n        #Canvas.setSizePolicy(self, QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        #Canvas.updateGeometry(self)\n\nclass MplWidget_LaTeX(MplWidget):\n    def __init__(self, parent=None):\n        super(MplWidget_LaTeX, self).__init__(parent)\n        self.canvas = MplCanvas_LaTeX(1,1)                  # Create canvas object\n        #self.vbl = QtWidgets.QVBoxLayout()         # Set box for plotting\n        #self.vbl.addWidget(self.canvas)\n        #self.setLayout(self.vbl)\n        \n        self.setLayout(QtWidgets.QVBoxLayout())\n        self.scroll = QtWidgets.QScrollArea(self)\n        self.scroll.setWidget(self.canvas)\n        \n        #self.Tab_2_LaTeX_LaTeXOutput.nav = NavigationToolbar(self.Tab_2_LaTeX_LaTeXOutput.canvas, self.Tab_2_LaTeX_LaTeXOutput)\n        #self.Tab_2_LaTeX_LaTeXOutput.layout().addWidget(self.Tab_2_LaTeX_LaTeXOutput.nav)\n        self.layout().addWidget(self.scroll)\n        self.layout().setContentsMargins(0,0,0,0)\n        \n        self.LastCall = False\n        self.LaTeX = """"\n        \n        self.ContextMenu_cid = self.canvas.mpl_connect(\'button_press_event\', self.Context_Menu)\n        \n        \n    def Context_Menu(self,event):\n        #print(\'%s click: button=%d, x=%d, y=%d, xdata=%f, ydata=%f\' %\n        #      (\'double\' if event.dblclick else \'single\', event.button,\n        #       event.x, event.y, event.xdata, event.ydata))\n        if event.button == 3:\n            menu = QtWidgets.QMenu()\n            menu = self.add_context_action(menu)\n            cursor = QtGui.QCursor()\n            menu.setPalette(self.palette())\n            menu.setFont(self.font())\n            menu.exec_(cursor.pos())\n    \n    def add_context_action(self,menu):\n        """"""Adds standard actions to menu and return menu""""""\n        action = menu.addAction(\'Copy LaTeX\')\n        action.triggered.connect(self.action_Copy_LaTeX)\n        action = menu.addAction(\'Copy LaTeX (with format)\')\n        action.triggered.connect(self.action_Copy_LaTeX_L)\n        return menu\n    \n    def action_Copy_LaTeX(self):\n        try:\n            Qt.QApplication.clipboard().setText(self.LaTeX)\n        except common_exceptions:\n            NC(2,""Could not copy LaTeX"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".action_Copy_LaTeX"")\n    \n    def action_Copy_LaTeX_L(self):\n        try:\n            Qt.QApplication.clipboard().setText(self.LaTeX_L)\n        except common_exceptions:\n            NC(2,""Could not copy LaTeX"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".action_Copy_LaTeX_L"")\n        \n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        super(MplWidget_LaTeX, self).SetColour(BG,FG,Cycler)\n        if self.LastCall != False:\n            self.DisplayRaw(self.LastCall[0],self.LastCall[1],self.LastCall[2],self.LastCall[3])\n        else:\n            try:\n                self.canvas.draw()\n            except common_exceptions:\n                pass\n    \n    def UseTeX(self,TheBool):\n        # This Method changes the settings for not only one but all widgets...\n        # This makes the clear function of the plotter slow if the LaTeX display has been used in LaTeX mode directly before\n        # It could help to separate the two widgets into two files...\n        # ... but it is also possible that this setting is global not only for the file but the program which would make the seperation a massive waste of time...\n        # Maybe test this in a little testprogram to not waste that much time...\n        \n        matplotlib.rcParams[\'text.latex.preamble\'] = r\'\\usepackage{amsmath}\'\n        #Both seem to do the same:\n        matplotlib.rcParams[\'text.usetex\'] = TheBool\n        plt.rc(\'text\', usetex=TheBool)\n        return matplotlib.rcParams[\'text.usetex\']\n\n    def PreloadLaTeX(self):\n        try:\n            self.UseTeX(True)\n            self.canvas.ax.clear()\n            self.canvas.ax.set_title(r""$\\frac{2 \\cdot 3 \\int \\left(x + 2 x\\right)\\, dx}{6}$"",\n                        loc = ""left"",\n                        y=(1.15-(20/5000)),\n                        horizontalalignment=\'left\',\n                        verticalalignment=\'top\',\n                        fontsize=20,\n                        color = ""white""\n                        ,bbox=dict(boxstyle=""round"", facecolor=""black"",\n                        ec=""0.1"", pad=0.1, alpha=0)\n                        )\n            self.canvas.ax.axis(\'off\')\n            self.canvas.draw()\n            time.sleep(0.1)\n            self.canvas.ax.clear()\n            self.canvas.ax.axis(\'off\')\n            self.canvas.draw()\n            self.UseTeX(False)\n        except common_exceptions:\n            try:\n                self.UseTeX(False)\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n            ExceptionOutput(sys.exc_info())\n    \n    def Display(self, Text, Font_Size = None, Use_LaTeX = False):\n        """"""Returns a notification with all relevant information""""""\n        #SIMPLIFY: https://matplotlib.org/3.1.1/_modules/matplotlib/text.html#Text _get_rendered_text_width and similar\n        # Use this to adjust the size of the ""plot"" to the Text?\n        \n        # Reminder: You can set Usetex for each individual text object. Example:\n        # plt.xlabel(\'$x$\', usetex=True)\n        \n        self.LaTeX = Text\n        \n        #return self.DisplayRaw(r""$\\displaystyle "" + self.LaTeX + ""$"", ""$"" + self.LaTeX + ""$"", Font_Size=Font_Size,Use_LaTeX=Use_LaTeX)\n        \n        Lines_L = self.LaTeX.splitlines()\n        Lines_N = self.LaTeX.splitlines()\n        #for i in Lines_L:\n        #    #if i == """":\n        #    #    i = \n        #    i = r""$\\displaystyle "" + i + ""$""\n        Text_L = r"" \\begin{alignat*}{2} & "" + r"" \\\\ & "".join(Lines_L) + r"" \\end{alignat*}  ""\n        #Text_L = r"" \\begin{align*} "" + r"" \\\\ & "".join(Lines_L) + r"" \\end{align*}  ""\n        #Text_L = r"" \\\\ "".join(Lines_L)\n        Text_N = ""$"" + ""$\\n$"".join(Lines_N) + ""$""\n        return self.DisplayRaw(Text_L, Text_N, Font_Size=Font_Size,Use_LaTeX=Use_LaTeX)\n        \n    def DisplayRaw(self, Text_L, Text_N, Font_Size = None, Use_LaTeX = False):\n        """"""Returns a notification with all relevant information""""""\n        if Font_Size == None:\n            Font_Size = App().font().pointSize()\n        self.LastCall = [Text_L, Text_N, Font_Size, Use_LaTeX]\n        self.LaTeX_L = Text_L\n        self.LaTeX_N = Text_N\n        self.Font_Size = Font_Size * 2\n        Notification = NC(lvl=0,win=self.window().windowTitle(),func=str(self.objectName())+"".DisplayRaw"",send=False)\n        \n        if Use_LaTeX:\n            self.UseTeX(True)\n            self.Text = self.LaTeX_L\n        else:\n            self.UseTeX(False)\n            try:\n                self.Text = self.LaTeX_N.replace(r""\\limits"","""")\n            except:\n                self.Text = self.LaTeX_N\n        \n        #self.w=9\n        #self.h=9\n        #self.canvas = MplCanvas_LaTeX(self.w+1, self.h+1) \n        #self.scroll.setWidget(self.canvas)\n        #self.layout().addWidget(self.scroll)\n        #self.canvas.resize(self.w+1, self.h+1)\n        #self.canvas.__init__(self.w+1, self.h+1)\n        \n        try:\n            self._Display(self.Text)\n        except common_exceptions:\n            Notification = NC(4,""Could not display in Mathmode"",exc=sys.exc_info(),input=self.Text,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"",send=False)\n            self.Text = self.LaTeX_N\n            if Use_LaTeX:\n                self.UseTeX(True)\n            else:\n                self.UseTeX(False)\n            try:\n                self._Display(self.Text)\n            except common_exceptions:\n                Notification = NC(2,""Could not display with LaTeX. Displaying with matplotlib instead."",exc=sys.exc_info(),input=self.Text,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"",send=False)\n                try:\n                    self.Text = self.LaTeX_N.replace(r""\\limits"","""")\n                except:\n                    self.Text = self.LaTeX_N\n                self.UseTeX(False)\n                try:\n                    self._Display(self.Text)\n                except common_exceptions:\n                    Notification = NC(1,""Could not display at all."",exc=sys.exc_info(),input=self.Text,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"",send=False)\n                    self.UseTeX(False)\n                    if Use_LaTeX:\n                        ErrorText = ""The text can\'t be displayed. Please send your input and a description of your problem to the developer""\n                    else:\n                        ErrorText = ""The text can\'t be displayed. Please note that many things can\'t be displayed without LaTeX Mode.""\n                        if not LaTeX_dvipng_Installed:\n                            ErrorText += ""\\n Please install LaTeX (and dvipng if it is not already included in your LaTeX distribution)""\n                    try:\n                        self._Display(ErrorText)\n                    except common_exceptions:\n                        Notification = NC(1,""Critical Error: MatPlotLib Display seems broken. Could not display anything"",exc=sys.exc_info(),input=ErrorText,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"",send=False)\n        finally:\n            self.UseTeX(False)\n            return Notification\n\n    def _Display(self,text):\n        self.canvas.ax.clear() # makes Space for the new text\n        y = 1.15-(self.Font_Size/5000) # For Figure(figsize = (100,100),dpi=90)\n        #y = 1.195-(self.Font_Size/180) # For Figure(figsize = (100,10),dpi=90)\n        t = self.canvas.ax.set_title(text,\n                                    loc = ""left"",\n                                    #x=-0.12,\n                                    y=y,\n                                    horizontalalignment=\'left\',\n                                    verticalalignment=\'top\',\n                                    fontsize=self.Font_Size,\n                                    color = self.TextColour\n                                    ,bbox=dict(boxstyle=""round"", facecolor=self.background_Colour,ec=""0.1"", pad=0.1, alpha=0)\n                                    )\n        #\n        r = self.canvas.get_renderer()\n        #t = self.canvas.ax.get_title()\n        bb = t.get_window_extent(renderer=r)\n\n        #NC(10,str(self.canvas.fig.dpi_scale_trans.inverted().transform((bb.width,bb.height))))\n        x,y = self.canvas.fig.dpi_scale_trans.inverted().transform((bb.width,bb.height))+self.canvas.fig.dpi_scale_trans.inverted().transform((0,y))\n        self.canvas.fig.set_size_inches(x+0.4,y+1, forward=True)\n        self.canvas.ax.clear()\n        t = self.canvas.ax.set_title(text,\n                                    loc = ""left"",\n                                    x=0.1,\n                                    y=y+0.5,\n                                    horizontalalignment=\'left\',\n                                    verticalalignment=\'top\',\n                                    fontsize=self.Font_Size,\n                                    color = self.TextColour,\n                                    #bbox=dict(boxstyle=""round"", facecolor=self.background_Colour,ec=""0.1"", pad=0.1, alpha=0),\n                                    transform = self.canvas.fig.dpi_scale_trans#.inverted()\n                                    )\n        #\n        self.canvas.ax.axis(\'off\')\n        self.canvas.draw()\n        self.canvas.adjustSize()\n        #self.scroll.adjustSize()\n        #self.adjustSize()\n\nclass MplWidget_LaTeX_J(QWebEngineView,MplWidget): # TODO: New LaTeX widget WIP\n    """"""\n    This widget is WORK IN PROGRESS and should NOT be used. \\n\n    New updates might break compatibility without warning. \\n\n    Even the name of this widget will change without warning!!! \\n\n    It is only included here to allow an insight into the active development of this Library!\n    """"""\n    def __init__(self, parent=None):\n        super(MplWidget_LaTeX_J, self).__init__(parent)\n        self.canvas = MplCanvas_LaTeX(100,100) \n        self.LastCall = False\n        self.LaTeX = """"\n        self.ContextMenu_cid = self.canvas.mpl_connect(\'button_press_event\', self.Context_Menu)\n        \n        \n    def Context_Menu(self,event):\n        pass\n    \n    def add_context_action(self,menu):\n        """"""Adds standard actions to menu and return menu""""""\n        #action = menu.addAction(\'Copy LaTeX\')\n        #action.triggered.connect(self.action_Copy_LaTeX)\n        return menu\n    \n    def action_Copy_LaTeX(self):\n        #try:\n        #    Qt.QApplication.clipboard().setText(self.LaTeX)\n        #except common_exceptions:\n        #    NC(2,""Could not copy LaTeX"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".action_Copy_LaTeX"")\n        pass\n        \n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        #super(MplWidget_LaTeX, self).SetColour(BG,FG,Cycler)\n        #if self.LastCall != False:\n        #    self.Display(self.LastCall[0],self.LastCall[1],self.LastCall[2],self.LastCall[3])\n        #else:\n        #    try:\n        #        self.canvas.draw()\n        #    except common_exceptions:\n        #        pass\n        pass\n    \n    def UseTeX(self,TheBool):\n        return TheBool\n\n    def PreloadLaTeX(self):\n        pass\n    \n    def Display(self, Text, Font_Size = None, Use_LaTeX = False):\n        """"""Returns a notification with all relevant information""""""\n        #SIMPLIFY: https://matplotlib.org/3.1.1/_modules/matplotlib/text.html#Text _get_rendered_text_width and similar\n        # Use this to adjust the size of the ""plot"" to the Text?\n        \n        # Reminder: You can set Usetex for each individual text object. Example:\n        # plt.xlabel(\'$x$\', usetex=True)\n        \n        self.LaTeX = Text\n        \n        #return self.DisplayRaw(r""$\\displaystyle "" + self.LaTeX + ""$"", ""$"" + self.LaTeX + ""$"", Font_Size=Font_Size,Use_LaTeX=Use_LaTeX)\n        \n        Lines_L = self.LaTeX.splitlines()\n        Lines_N = self.LaTeX.splitlines()\n        for i in Lines_L:\n            #if i == """":\n            #    i = \n            i = r""$\\displaystyle "" + i + ""$""\n        for i in Lines_N:\n            i = ""$"" + i + ""$""\n        Text_L = r"" \\begin{alignat*}{2} & "" + r"" \\\\ & "".join(Lines_L) + r"" \\end{alignat*}  ""\n        #Text_L = r"" \\begin{align*} "" + r"" \\\\ & "".join(Lines_L) + r"" \\end{align*}  ""\n        #Text_L = r"" \\\\ "".join(Lines_L)\n        Text_N = r"" \\\\ "".join(Lines_N)\n        return self.DisplayRaw(Text_L, Text_N, Font_Size=Font_Size,Use_LaTeX=Use_LaTeX)\n        \n    def DisplayRaw(self,Text_L,Text_N,Font_Size,Use_LaTeX = False):\n        """"""Returns a notification with all relevant information""""""\n        self.LastCall = [Text_L, Text_N, Font_Size, Use_LaTeX]\n        self.LaTeX = Text_L\n        self.Text = Text_L\n        self.Font_Size = Font_Size * 2\n        Notification = NC(lvl=0,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"",send=False)\n        #-----------IMPORTANT-----------\n        pageSource = r""""""\n                     <html><head>\n                     <script type=""text/javascript"" src=""https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"">                     \n                     </script></head>\n                     <body bgcolor="" """"""+str(App().Palette1.base().color().name(0))+r"""""" "">\n                     <p><mathjax style=""font-size:2.3em; color: """"""+str(App().palette().text().color().name(0))+r"""""""">$""""""+Text_L+r""""""$</mathjax></p>\n                     </body></html>\n                     """"""\n        self.setHtml(pageSource)\n        return Notification\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass ListWidget(QtWidgets.QListWidget):\n    """"""\n    The base class for list widgets of AGeLib. \\n\n    QtGui.QKeySequence.Copy has been reimplemented to allow copying of multiple items. (Text of items is separated by linebreaks.) \\n\n    The scrollmode is set to ScrollPerPixel and the selectionmode is set to ExtendedSelection.\n    """"""\n    def __init__(self, parent=None):\n        super(ListWidget, self).__init__(parent)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.setHorizontalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)\n        self.setVerticalScrollMode(QtWidgets.QAbstractItemView.ScrollPerPixel)\n        self.installEventFilter(self)\n\n    def keyPressEvent(self,event):\n        try:\n            if event == QtGui.QKeySequence.Copy:\n                SelectedItems = self.selectedItems()\n                if len(SelectedItems)>1:\n                    string = """"\n                    for i in SelectedItems:\n                        string += i.text()\n                        string += ""\\n""\n                    Qt.QApplication.clipboard().setText(string)\n                    event.accept()\n                    return\n            super(ListWidget, self).keyPressEvent(event)\n        except common_exceptions:\n            NC(lvl=2,exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(ListWidget).keyPressEvent"",input=str(event))\n            super(ListWidget, self).keyPressEvent(event)\n\nclass NotificationsWidget(QtWidgets.QSplitter):\n    """"""\n    This widget displays all notifications and allows (read)access to their details. \\n\n    All previous notifications are automatically loaded and all new notifications are automatically added\n    """"""\n    def __init__(self, parent=None):\n        super(NotificationsWidget, self).__init__(parent)\n        #sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)\n        #sizePolicy.setHorizontalStretch(0)\n        #sizePolicy.setVerticalStretch(20)\n        #sizePolicy.setHeightForWidth(self.Splitter.sizePolicy().hasHeightForWidth())\n        #self.Splitter.setSizePolicy(sizePolicy)\n        self.setOrientation(QtCore.Qt.Horizontal)\n        self.NotificationList = NotificationListWidget(self)\n        self.NotificationInfo = NotificationInfoWidget(self)\n        self.NotificationList.setObjectName(""NotificationList"")\n        self.NotificationInfo.setObjectName(""NotificationInfo"")\n        \n        App().S_New_Notification.connect(self.AddNotification)\n        for i in App().Notification_List:\n            self.AddNotification(i)\n        \n        self.NotificationList.currentItemChanged.connect(self.NotificationInfo.ShowNotificationDetails)\n\n    def AddNotification(self,Notification):\n        try:\n            item = QtWidgets.QListWidgetItem()\n            item.setText(str(Notification))\n            item.setData(100,Notification)\n            item.setIcon(Notification.icon)\n            \n            self.NotificationList.addItem(item)\n            self.NotificationList.scrollToBottom()\n        except common_exceptions:\n            Error = ExceptionOutput(sys.exc_info())\n            text = ""Could not add notification: ""+Error\n            item = QtWidgets.QListWidgetItem()\n            item.setText(text)\n            item.setData(100,NC(1,""Could not add notification"",err=Error,func=str(self.objectName())+"".(NotificationsWidget).AddNotification"",win=self.window().windowTitle()))\n            \n            self.NotificationList.addItem(item)\n            self.NotificationList.scrollToBottom()\n\nclass NotificationListWidget(ListWidget):\n    """"""\n    This widget is used by NotificationsWidget to display all notifications.\n    """"""\n    def __init__(self, parent=None):\n        super(NotificationListWidget, self).__init__(parent)\n        self.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)\n        self.setAlternatingRowColors(True)\n\nclass NotificationInfoWidget(ListWidget): #TODO: Add a button to copy the details of the current notification to the clipboard with a tooltip that explains how to send it to the developer\n    """"""\n    This widget is used by NotificationsWidget to display the details of the currently selected notification.\n    """"""\n    def __init__(self, parent=None):\n        super(NotificationInfoWidget, self).__init__(parent)\n        self.setAlternatingRowColors(True)\n        self.installEventFilter(self)\n        \n        item = QtWidgets.QListWidgetItem()\n        item.setText(""For more information select a notification"")\n        self.addItem(item)\n\n    def keyPressEvent(self,event):\n        try:\n            if event == QtGui.QKeySequence.Copy:\n                SelectedItems = self.selectedItems()\n                if len(SelectedItems)>1:\n                    string = """"\n                    for i in SelectedItems:\n                        string += i.text()\n                        string += ""\\n\\n""\n                    Qt.QApplication.clipboard().setText(string)\n                    event.accept()\n                    return\n            super(NotificationInfoWidget, self).keyPressEvent(event)\n        except common_exceptions:\n            NC(lvl=2,exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(NotificationInfoWidget).keyPressEvent"",input=str(event))\n            super(NotificationInfoWidget, self).keyPressEvent(event)\n\n    def ShowNotificationDetails(self,Notification):\n        try:\n            Notification = Notification.data(100)\n            self.clear()\n            for k,v in Notification.items():\n                try:\n                    if v != None:\n                        item = QtWidgets.QListWidgetItem()\n                        item.setText(k+str(v))\n                        self.addItem(item)\n                except common_exceptions:\n                    NC(msg=""Could not display{}"".format(str(k)),exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(NotificationInfoWidget).ShowNotificationDetails"")\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(NotificationInfoWidget).ShowNotificationDetails"")\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass ATextEdit(QtWidgets.QTextEdit):\n    """"""\n    The base class for Texteditor of AGeLib. \\n\n    Includes the signals returnPressed and returnCtrlPressed. \\n\n    Includes the common behaviour of the arrow key navigation. \\n\n    Tab is used to focus the next widget. If you want to use tab as a symbol set ATextEdit``.setTabChangesFocus(False)``.\n    """"""\n    returnPressed = QtCore.pyqtSignal()\n    returnCtrlPressed = QtCore.pyqtSignal()\n    def __init__(self, parent=None):\n        QtWidgets.QTextEdit.__init__(self, parent)\n        self.installEventFilter(self)\n        self.setTabChangesFocus(True)\n        \n    def eventFilter(self, source, event):\n        if event.type() == QtCore.QEvent.KeyPress:\n            if event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter: # Connects to returnPressed but does not accept the signal to allow linebreaks\n                source.returnPressed.emit()\n            if (event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter) and event.modifiers() == QtCore.Qt.ControlModifier:\n                source.returnCtrlPressed.emit()\n            if event.key() == QtCore.Qt.Key_Up and source.textCursor().blockNumber() == 0: # Move to beginning if up key pressed and in first line\n                cursor = source.textCursor()\n                if event.modifiers() == QtCore.Qt.ShiftModifier: # If shift is pressed select the text\n                    cursor.movePosition(cursor.Start,1)\n                else:\n                    cursor.movePosition(cursor.Start)\n                source.setTextCursor(cursor)\n                return True\n            elif event.key() == QtCore.Qt.Key_Down and source.textCursor().blockNumber() == source.document().blockCount()-1: # Move to end if down key pressed and in last line\n                cursor = source.textCursor()\n                if event.modifiers() == QtCore.Qt.ShiftModifier: # If shift is pressed select the text\n                    cursor.movePosition(cursor.End,1)\n                else:\n                    cursor.movePosition(cursor.End)\n                source.setTextCursor(cursor)\n                return True\n        return super(ATextEdit, self).eventFilter(source, event)\n\n    def text(self):\n        return self.toPlainText()\n\n    def insertFromMimeData(self, MIMEData):\n        try:\n            Text = MIMEData.text()\n            self.textCursor().insertText(Text)\n        except common_exceptions:\n            pass\n\nclass TextEdit(ATextEdit):\n    """"""\n    The base multiline texteditor of AGeLib. \\n\n    Includes the signals returnPressed and returnCtrlPressed. \\n\n    Includes the common behaviour of the arrow key navigation. \\n\n    Tab is used to focus the next widget. If you want to use tab as a symbol set TextEdit``.setTabChangesFocus(False)``.\n    """"""\n    def __init__(self, parent=None):\n        super(TextEdit, self).__init__(parent)\n        self.installEventFilter(self)\n\n        # FEATURE: Make subscript and superscript work and add an option to disable it (fro small font)\n        # See https://www.qtcentre.org/threads/38633-(SOLVED)-QTextEdit-subscripted-text for a startingpoint\n        \n    def eventFilter(self, source, event):\n        if event.type() == QtCore.QEvent.KeyPress:\n            if (event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter) and event.modifiers() == QtCore.Qt.ControlModifier:\n                source.returnCtrlPressed.emit()\n                return True\n        return super(TextEdit, self).eventFilter(source, event)\n\nclass LineEdit(ATextEdit):\n    """"""\n    The base single line texteditor of AGeLib. \\n\n    In contrast to QLineEdit, AGeLib\'s LineEdit supports QtGui.QSyntaxHighlighter since it is derived from QtWidgets.QTextEdit . \\n\n    Includes the signals returnPressed and returnCtrlPressed. \\n\n    Includes the common behaviour of the arrow key navigation. \\n\n    Tab is used to focus the next widget. If you want to use tab as a symbol set TextEdit``.setTabChangesFocus(False)``. \\n\n    Please note that multiline text is converted to a single line in which each former line is placed in brackets and separated by plus signs.\n    To change this behaviour reimplement ``.insertFromMimeData(self,Data)``.\n    """"""\n    def __init__(self, parent=None):\n        super(LineEdit, self).__init__(parent)\n        \n        self.RowHeight = QtGui.QFontMetrics(self.font()).lineSpacing()\n        self.setFixedHeight(2 * self.RowHeight)\n        self.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)\n        self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)\n        \n        self.installEventFilter(self)\n        # Connect Signals\n        #self.textChanged.connect(self.validateCharacters) # Turned off to fix Undo/Redo # CLEANUP: validateCharacters\n\n    def eventFilter(self, source, event):\n        if (event.type() == QtCore.QEvent.FontChange): # Rescale if font size changes\n            source.RowHeight = QtGui.QFontMetrics(source.font()).lineSpacing()+9\n            source.setFixedHeight(source.RowHeight)\n        elif event.type() == QtCore.QEvent.KeyPress:\n            if event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter:\n                source.returnPressed.emit()\n                return True\n        return super(LineEdit, self).eventFilter(source, event)\n\n    #def validateCharacters(self): # CLEANUP: validateCharacters\n     #   forbiddenChars = [\'\\n\']\n     #   cursor = self.textCursor()\n     #   curPos = cursor.position()\n     #   Text = self.toPlainText()\n     #   found = 0\n     #   for e in forbiddenChars:\n     #       found += Text.count(e)\n     #       Text = Text.replace(e, \'\')\n     #   \n     #   self.blockSignals(True)\n     #   self.setText(Text)\n     #   self.blockSignals(False)\n     #   try:\n     #       cursor.setPosition(curPos-found)\n     #       self.setTextCursor(cursor)\n     #   except common_exceptions:\n     #       ExceptionOutput(sys.exc_info())\n     #   super(LineEdit, self).validateCharacters()\n\n    def insertFromMimeData(self,Data):\n        if Data.hasText():\n            text = Data.text()\n            #text = text.replace(\'\\n\', \' + \').replace(\'\\r\', \'\')\n            lines = []\n            for i in text.splitlines():\n                if i.strip() != """":\n                    lines.append(i)\n            if len(lines) > 1:\n                text = ""( ""+"" ) + ( "".join(lines)+"" )""\n            else:\n                text = """".join(lines)\n            self.insertPlainText(text)\n            #Data.setText(text)\n        else:\n            super(LineEdit, self).insertFromMimeData(Data)\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass TableWidget(QtWidgets.QTableWidget):\n    """"""\n    The base class for table widgets of AGeLib. \\n\n    The Navigation is changed exit the widget when tab is pressed on the last item\n    and AGeLib\'s LineEdit is used for the cell editing (which enables the use of QtGui.QSyntaxHighlighter). \\n\n    Includes the signal S_Focus_Next which is emitted when tab is pressed while the last item is selected.\n    This can be used to automatically redirect the focus to a specific widget which can not be reached via the use of Qt\'s tab stops. \\n\n    """"""\n    S_Focus_Next = QtCore.pyqtSignal()\n    def __init__(self, parent=None):\n        super(TableWidget, self).__init__(parent)\n        #print(type(self.itemDelegate()))\n        self.TheDelegate = TableWidget_Delegate(self)\n        self.setItemDelegate(self.TheDelegate)\n        self.installEventFilter(self)\n        \n    def eventFilter(self, source, event):\n        if event.type() == QtCore.QEvent.KeyPress and source in self.window().findChildren(QtWidgets.QTableWidget) and source.isEnabled() and source.tabKeyNavigation():\n            index = source.currentIndex()\n            if event.key() == QtCore.Qt.Key_Backtab:\n                if index.row() == index.column() == 0:\n                    source.setCurrentCell(0,0)\n                    source.clearSelection()\n                    QtWidgets.QAbstractScrollArea.focusNextPrevChild(source, False)\n                    return True\n            elif event.key() == QtCore.Qt.Key_Tab:\n                model = source.model()\n                if (index.row() == model.rowCount() - 1 and index.column() == model.columnCount() - 1):\n                    source.setCurrentCell(0,0)\n                    source.clearSelection()\n                    QtWidgets.QAbstractScrollArea.focusNextPrevChild(source, True)\n                    self.S_Focus_Next.emit()\n                    return True\n            elif event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter or event.key() == QtCore.Qt.Key_Space:\n                self.edit(index)\n                return True\n        return super(TableWidget, self).eventFilter(source, event)\n\nclass TableWidget_Delegate(QtWidgets.QStyledItemDelegate):\n    """"""\n    TableWidget delegate for AGeLib\'s TableWidget. \\n\n    This delegate uses AGeLib\'s LineEdit to enable the use of QtGui.QSyntaxHighlighter. \\n\n    The usual navigation (key press enters edit, enter closes edit, tab focuses next item, etc) is supported.\n    """"""\n    def __init__(self, parent=None):\n        super(TableWidget_Delegate, self).__init__(parent)\n        self.installEventFilter(self)\n\n    def createEditor(self, parent, options, index):\n        return LineEdit(parent)\n\n    def setEditorData(self, editor, index):\n        editor.setText(index.data())\n        editor.selectAll()\n\n    def setModelData(self, editor, model, index):\n        model.setData(index, editor.toPlainText())\n\n    def eventFilter(self, source, event):\n        if (event.type() == QtCore.QEvent.KeyPress and (event.key() == QtCore.Qt.Key_Tab or event.key() == QtCore.Qt.Key_Backtab)):\n            # Commit Editing, end Editing mode and re-send Tab/Backtab\n            self.commitData.emit(source)\n            self.closeEditor.emit(source, QtWidgets.QAbstractItemDelegate.NoHint)\n            event = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,event.key(),event.modifiers())\n            QtWidgets.QApplication.instance().sendEvent(self.parent(),event)\n            return True\n        elif (event.type() == QtCore.QEvent.KeyPress and (event.key() == QtCore.Qt.Key_Return or event.key() == QtCore.Qt.Key_Enter)):\n            # Commit Editing and end Editing mode\n            self.commitData.emit(source)\n            self.closeEditor.emit(source, QtWidgets.QAbstractItemDelegate.NoHint)\n            #event = QtGui.QKeyEvent(QtCore.QEvent.KeyPress,event.key(),event.modifiers())\n            #QtWidgets.QApplication.instance().sendEvent(self.parent(),event)\n            return True\n        return super(TableWidget_Delegate, self).eventFilter(source, event)\n\n\n# -----------------------------------------------------------------------------------------------------------------\n        \nclass ColourPicker(QtWidgets.QToolButton):\n    """"""\n    This widget is used to display and modify a single colour. \\n\n    Pressing on this widget opens the standard colour dialogue of the OS. \\n\n    The text displays the Hex RGB code and the text colour changes automatically to ensure readability. \\n\n    This widget is used by OptionsWidget_1_Appearance.\n    """"""\n    def __init__(self, Type, Element, parent=None):\n        super(ColourPicker, self).__init__(parent)\n        self.Type, self.Element = Type, Element\n        self.setText("""")\n        self.LoadCurrentPalette()\n        self.clicked.connect(self.PickColour)\n        self.setAutoRaise(True)\n        self.setAutoFillBackground(True)\n        \n    def LoadCurrentPalette(self):\n        try:\n            if self.Type == ""Pen"":\n                self.Colour = QtWidgets.QApplication.instance().PenColours[self.Element].color()\n            elif self.Type == ""Notification"":\n                self.Colour = QtWidgets.QApplication.instance().NotificationColours[self.Element].color()\n            elif self.Type == ""Misc"":\n                self.Colour = QtWidgets.QApplication.instance().MiscColours[self.Element].color()\n        except:\n            self.Colour = QtGui.QColor(255, 0, 255)\n        self.ColourSelf()\n        \n    def PickColour(self):\n        Colour = QtWidgets.QColorDialog.getColor(self.Colour,None,""Choose the {} colour \\""{}\\"""".format(self.Type,self.Element))\n        if Colour.isValid(): # If the QColorDialog was aborted by the user the returned colour is invalid\n            self.Colour = Colour\n        self.ColourSelf()\n        \n    def ColourSelf(self):\n        palette = QtGui.QPalette()\n        brush = QtGui.QBrush(self.Colour)\n        brush.setStyle(QtCore.Qt.SolidPattern)\n        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.Button, brush)\n        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.Button, brush)\n        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.Button, brush)\n        # Generate readable text colour\n        textColour = QtGui.QColor(""black"") if (0.299 * self.Colour.red() + 0.587 * self.Colour.green() + 0.114 * self.Colour.blue())/255 > 0.5 else QtGui.QColor(""white"")\n        brush = QtGui.QBrush(textColour)\n        brush.setStyle(QtCore.Qt.SolidPattern)\n        palette.setBrush(QtGui.QPalette.Active, QtGui.QPalette.ButtonText, brush)\n        palette.setBrush(QtGui.QPalette.Inactive, QtGui.QPalette.ButtonText, brush)\n        palette.setBrush(QtGui.QPalette.Disabled, QtGui.QPalette.ButtonText, brush)\n        self.setPalette(palette)\n        # Display the HexRgb code of the colour\n        #self.setText(""#""+str(hex(self.Colour.rgb()))[4:]) # Does the same as the next line\n        self.setText(self.Colour.name(0)) # 0 = HexRgb\n\nclass PaletteColourPicker(ColourPicker):\n    """"""\n    This widget is used to display and modify a single colour of a QPalette. \\n\n    Pressing on this widget opens the standard colour dialogue of the OS. \\n\n    The text displays the Hex RGB code and the text colour changes automatically to ensure readability. \\n\n    This widget is used by OptionsWidget_1_Appearance.\n    """"""\n    def __init__(self, Mode, Element, ModeText, ElementText, parent=None):\n        QtWidgets.QToolButton.__init__(self, parent)\n        self.Mode, self.Element = Mode, Element\n        self.ModeText, self.ElementText = ModeText, ElementText\n        self.setText("""")\n        self.LoadCurrentPalette()\n        self.clicked.connect(self.PickColour)\n        if self.ElementText != ""Button"": #MAYBE: Link the Button colour buttons to the ButtonText colour buttons\n            self.setAutoRaise(True)\n            self.setAutoFillBackground(True)\n        \n    def LoadCurrentPalette(self):\n        try:\n            if self.ModeText.endswith(""Version 1""):\n                self.Colour = QtWidgets.QApplication.instance().Palette1.brush(self.Mode, self.Element).color()#QtGui.QColor(255, 255, 255)\n            elif self.ModeText.endswith(""Version 2""):\n                self.Colour = QtWidgets.QApplication.instance().Palette2.brush(self.Mode, self.Element).color()#QtGui.QColor(255, 255, 255)\n            elif self.ModeText.endswith(""Version 3""):\n                self.Colour = QtWidgets.QApplication.instance().Palette3.brush(self.Mode, self.Element).color()#QtGui.QColor(255, 255, 255)\n        except:\n            self.Colour = QtGui.QColor(255, 0, 255)\n        self.ColourSelf()\n        \n    def PickColour(self):\n        Colour = QtWidgets.QColorDialog.getColor(self.Colour,None,""Choose colour for {} when {}"".format(self.ElementText,self.ModeText))\n        if Colour.isValid(): # If the QColorDialog was aborted by the user the returned colour is invalid\n            self.Colour = Colour\n        self.ColourSelf()\n    \n\nclass OptionsWidget_1_Appearance(QtWidgets.QWidget):\n    """"""\n    This widget allows the user to change the Font and the colourpalette of the application. \\n\n    It furthermore allows the user to create, save and load their own colour palette. \\n\n    If you create your own options menu it is STRONGLY advised to include this widget! \\n\n    The freedome this widget provides to the user is the foundation of AGeLib. \\n\n    The initial reason to create this library was because I couldn\'t stand most applications anymore because they wouldn\'t allow me to change their colour.\n    """"""\n    def __init__(self, parent=None):\n        super(OptionsWidget_1_Appearance, self).__init__(parent)\n        self.PaletteColours = []\n        self.PenColours = []\n        self.NotificationColours = []\n        self.MiscColours = []\n        \n        #IMPROVE: Draw more attention to the palette selector!!! Changing the colours currently looks far too intimidating!\n        #           The users first look should be drawn to the palette selector BY ANY MEANS NECESSARY!!!\n        #TODO: Add this link somewhere: https://doc.qt.io/qt-5/qpalette.html#ColorRole-enum\n        #TODO: Add Tooltips that contain the info from https://doc.qt.io/qt-5/qpalette.html#ColorRole-enum and say which colours are used for BG and FG\n        #TODO: Add a checkbox somewhere to help automate the creation of Inactive and Disabled (keep tooltip behaviour in mind!!)\n        #MAYBE: Add Mpl/Special Colour selection\n        #MAYBE: Add a button to revert ?the last? change\n        \n        self.setLayout(QtWidgets.QGridLayout())\n        self.FontLabel = QtWidgets.QLabel(self)\n        self.FontLabel.setText(""Choose a font:"")\n        self.FontLabel.setToolTip(""The displayed fonts are the fonts that are installed on your copmuter"")\n        self.layout().addWidget(self.FontLabel,0,0)\n        self.fontComboBox = QtWidgets.QFontComboBox(self)\n        self.fontComboBox.currentFontChanged.connect(self.SetFontFamily)\n        self.layout().addWidget(self.fontComboBox,0,1)\n        self.ColourListLabel = QtWidgets.QLabel(self)\n        self.ColourListLabel.setText(""Choose a colour palette:"")\n        self.layout().addWidget(self.ColourListLabel,1,0)\n        self.ColourList = QtWidgets.QComboBox(self)\n        self.ColourList.addItems(self.LoadPaletteList())\n        self.ColourList.setCurrentText(""Dark"")\n        if versionParser(QtCore.qVersion())>=versionParser(""5.14""):\n            self.ColourList.textActivated.connect(QtWidgets.QApplication.instance().Recolour)\n        else:\n            self.ColourList.currentTextChanged.connect(QtWidgets.QApplication.instance().Recolour)\n        self.layout().addWidget(self.ColourList,1,1)\n        self.ColourTableLabel = QtWidgets.QLabel(self)\n        self.ColourTableLabel.setText(""Or create you own:"")\n        self.layout().addWidget(self.ColourTableLabel,2,0)\n        self.LoadToEditorButton = QtWidgets.QPushButton(self)\n        self.LoadToEditorButton.setText(""Load current palette to editor"")\n        self.LoadToEditorButton.clicked.connect(lambda: self.LoadCurrentPalette())\n        self.layout().addWidget(self.LoadToEditorButton,2,1)\n        # Colour Tabs #TODO: The 3 misc tabs should be combined into one tab with 3 Tables\n        self.ColourTabs = QtWidgets.QTabWidget(self)\n        self.layout().addWidget(self.ColourTabs,3,0,1,2)\n        self.PaletteTable = QtWidgets.QTableWidget(len(AGeColour.PaletteElements),len(AGeColour.PaletteStates),self)\n        self.ColourTabs.addTab(self.PaletteTable,""Palettes"")\n        #self.layout().addWidget(self.PaletteTable,3,0,1,2)\n        self.PenTable_Labels = [""Red"",""Green"",""Blue"",""Yellow"",""Cyan"",""Magenta"",""Orange"",""Light Blue"",""White"",""Black""]\n        self.PenTable = QtWidgets.QTableWidget(len(self.PenTable_Labels),1,self)\n        self.PenTable.setVerticalHeaderLabels(self.PenTable_Labels)\n        self.ColourTabs.addTab(self.PenTable,""Pen Colours"")\n        self.NotificationTable_Labels = [""Error"",""Warning"",""Notification"",""Message""]\n        self.NotificationTable = QtWidgets.QTableWidget(len(self.NotificationTable_Labels),1,self)\n        self.NotificationTable.setVerticalHeaderLabels(self.NotificationTable_Labels)\n        self.ColourTabs.addTab(self.NotificationTable,""Notification Colours"")\n        self.MiscTable_Labels = [""Friendly"",""Hostile"",""Neutral"",""Ally"",""Self"",\n                                ""Common"",""Uncommon"",""Rare"",""Legendary"",""Mythical"",""Artefact"",""Broken"",""Magical"",""Important"",\n                                ""Gradient1"",""Gradient2"",""Gradient3""]\n        self.MiscTable = QtWidgets.QTableWidget(len(self.MiscTable_Labels),1,self)\n        self.MiscTable.setVerticalHeaderLabels(self.MiscTable_Labels)\n        self.ColourTabs.addTab(self.MiscTable,""Misc Colours"")\n        #\n        self.ApplyPaletteButton = QtWidgets.QPushButton(self)\n        self.ApplyPaletteButton.setText(""Apply Palette"")\n        self.ApplyPaletteButton.clicked.connect(lambda: self.MakePalette())\n        self.layout().addWidget(self.ApplyPaletteButton,4,0)\n        self.SavePaletteButton = QtWidgets.QPushButton(self)\n        self.SavePaletteButton.setText(""Save Palette"")\n        self.SavePaletteButton.clicked.connect(lambda: self.SavePalette())\n        self.layout().addWidget(self.SavePaletteButton,4,1)\n        self.layout().setContentsMargins(0,0,0,0)\n        self.layout().setSpacing(3)\n        HLabel = [""Active Version 1"",""Inactive Version 1"",""Disabled Version 1"",""Active Version 2"",""Inactive Version 2"",""Disabled Version 2"",""Active Version 3"",""Inactive Version 3"",""Disabled Version 3""]\n        VLabel = []\n        y = 0\n        for i, v in AGeColour.PaletteElements.items():\n            VLabel.append(i)\n            #CLEANUP\n            #widget = PaletteColourPicker(AGeColour.PaletteStates[""Active""],v,""Active"",i,self.PaletteTable)\n            #self.PaletteColours.append(widget)\n            #self.PaletteTable.setCellWidget(y,0,widget)\n            #widget = PaletteColourPicker(AGeColour.PaletteStates[""Inactive""],v,""Inactive"",i,self.PaletteTable)\n            #self.PaletteColours.append(widget)\n            #self.PaletteTable.setCellWidget(y,1,widget)\n            #widget = PaletteColourPicker(AGeColour.PaletteStates[""Disabled""],v,""Disabled"",i,self.PaletteTable)\n            #self.PaletteColours.append(widget)\n            #self.PaletteTable.setCellWidget(y,2,widget)\n            x = 0\n            for ii, vi in AGeColour.PaletteStates.items():\n                widget = PaletteColourPicker(vi,v,ii,i,self.PaletteTable)\n                self.PaletteColours.append(widget)\n                self.PaletteTable.setCellWidget(y,x,widget)\n                x+=1\n            y+=1\n        self.PaletteTable.setHorizontalHeaderLabels(HLabel)\n        self.PaletteTable.setVerticalHeaderLabels(VLabel)\n        y = 0\n        for i in self.PenTable_Labels:\n            widget = ColourPicker(""Pen"",i,self.PenTable)\n            self.PenColours.append(widget)\n            self.PenTable.setCellWidget(y,0,widget)\n            y+=1\n        y = 0\n        for i in self.NotificationTable_Labels:\n            widget = ColourPicker(""Notification"",i,self.NotificationTable)\n            self.NotificationColours.append(widget)\n            self.NotificationTable.setCellWidget(y,0,widget)\n            y+=1\n        y = 0\n        for i in self.MiscTable_Labels:\n            widget = ColourPicker(""Misc"",i,self.MiscTable)\n            self.MiscColours.append(widget)\n            self.MiscTable.setCellWidget(y,0,widget)\n            y+=1\n        \n    def SetFontFamily(self,Family):\n        QtWidgets.QApplication.instance().SetFont(Family,self.window().TopBar.Font_Size_spinBox.value(),self)\n        \n    def LoadCurrentPalette(self):\n        for i in self.PaletteColours+self.PenColours+self.NotificationColours+self.MiscColours:\n            i.LoadCurrentPalette()\n        #self.PenColours = []\n        #self.NotificationColours = []\n        #self.MiscColours = []\n        \n    def LoadPaletteList(self):\n        ColourList = []\n        try:\n            try:\n                importlib.reload(AGeColour)\n            except:\n                NC(2,""Could not reload AGeColour"",exc=sys.exc_info(),func=""Main_App.Recolour"")\n            try:\n                if QtWidgets.QApplication.instance().AGeLibPathOK:\n                    spec = importlib.util.spec_from_file_location(""CustomColourPalettes"", os.path.join(QtWidgets.QApplication.instance().AGeLibSettingsPath,""CustomColourPalettes.py""))\n                    CustomColours = importlib.util.module_from_spec(spec)\n                    spec.loader.exec_module(CustomColours)\n                    #CustomColours.MyClass()\n                else:\n                    raise Exception(""AGeLibPath is not OK"")\n            except:\n                NC(4,""Could not load custom colours"",exc=sys.exc_info(),func=""Main_App.Recolour"")\n            try:\n                for i in AGeColour.Colours.keys():\n                    ColourList.append(i)\n                for i in CustomColours.Colours.keys():\n                    ColourList.append(i)\n            except:\n                pass\n        except:\n            NC(1,""Exception while loading colour palette"",exc=sys.exc_info(),func=""Main_App.Recolour"")\n        return ColourList\n        \n    def MakePalette(self):\n        self.ColourList.blockSignals(True)\n        self.ColourList.clear()\n        self.ColourList.addItems(self.LoadPaletteList())\n        self.ColourList.blockSignals(False)\n        palette1,palette2,palette3 = QtGui.QPalette(),QtGui.QPalette(),QtGui.QPalette()\n        PenColours , NotificationColours , MiscColours = {},{},{}\n        for i in self.PaletteColours:\n            brush = QtGui.QBrush(i.Colour)\n            brush.setStyle(QtCore.Qt.SolidPattern)\n            if int(i.ModeText[-1]) == 1:\n                palette1.setBrush(i.Mode, i.Element, brush)\n            elif int(i.ModeText[-1]) == 2:\n                palette2.setBrush(i.Mode, i.Element, brush)\n            elif int(i.ModeText[-1]) == 3:\n                palette3.setBrush(i.Mode, i.Element, brush)\n        for i in self.PenColours:\n            brush = QtGui.QBrush(i.Colour)\n            brush.setStyle(QtCore.Qt.SolidPattern)\n            PenColours[i.Element] = brush\n        for i in self.NotificationColours:\n            brush = QtGui.QBrush(i.Colour)\n            brush.setStyle(QtCore.Qt.SolidPattern)\n            NotificationColours[i.Element] = brush\n        for i in self.MiscColours:\n            brush = QtGui.QBrush(i.Colour)\n            brush.setStyle(QtCore.Qt.SolidPattern)\n            MiscColours[i.Element] = brush\n            #\n        QtWidgets.QApplication.instance()._Recolour(palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours)\n        return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\n    \n    def PaletteToPython(self,Palette,FunctionName,Name):\n        #window.AMaDiA_About_Window_Window.TextBrowser.setText(app.optionWindow.ColourPicker.PaletteToPython(AGeColour.Colours[app.optionWindow.ColourPicker.LoadPaletteList()[0]],app.optionWindow.ColourPicker.LoadPaletteList()[0])[0])\n        Palette1, Palette2, Palette3, _PenColours, _NotificationColours, _MiscColours = Palette()\n        PenColours, NotificationColours, MiscColours = ColourDict(),ColourDict(),ColourDict()\n        PenColours.copyFromDict(_PenColours)\n        NotificationColours.copyFromDict(_NotificationColours)\n        MiscColours.copyFromDict(_MiscColours)\n        Text = ""\\ndef ""+FunctionName+""():\\n    palette1 = QtGui.QPalette()\\n    palette2 = QtGui.QPalette()\\n    palette3 = QtGui.QPalette()""\n        for i, v in AGeColour.PaletteElements.items():\n            for ii,iv in AGeColour.PaletteStates.items():\n                if int(ii[-1]) == 1:\n                    Colour = Palette1.brush(iv, v).color()\n                elif int(ii[-1]) == 2:\n                    Colour = Palette2.brush(iv, v).color()\n                elif int(ii[-1]) == 3:\n                    Colour = Palette3.brush(iv, v).color()\n                Text += ""\\n    brush = QtGui.QBrush(QtGui.QColor({},{},{}))"".format(str(Colour.red()),str(Colour.green()),str(Colour.blue()))\n                Text += ""\\n    brush.setStyle(QtCore.Qt.SolidPattern)""\n                Text += ""\\n    palette{}.setBrush(QtGui.QPalette.{}, QtGui.QPalette.{}, brush)"".format(ii[-1],ii.split()[0],i)\n        Text += ""\\n    PenColours = {""\n        for i in self.PenTable_Labels:\n            Colour = PenColours[i].color()\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i,str(Colour.red()),str(Colour.green()),str(Colour.blue()))\n        Text = Text[:-1]+""}\\n    NotificationColours = {""\n        for i in self.NotificationTable_Labels:\n            Colour = NotificationColours[i].color()\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i,str(Colour.red()),str(Colour.green()),str(Colour.blue()))\n        Text = Text[:-1]+""}\\n    MiscColours = {""\n        for i in self.MiscTable_Labels:\n            Colour = MiscColours[i].color()\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i,str(Colour.red()),str(Colour.green()),str(Colour.blue()))\n        Text = Text[:-1]+""}\\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\\n""\n        return Text,FunctionName,Name\n    \n    def SavePalette(self,Name=None):\n        # window.AMaDiA_About_Window_Window.TextBrowser.setText(app.optionWindow.ColourPicker.SavePalette(""Test""))\n        if Name == None:\n            Name = QtWidgets.QInputDialog.getText(self,""Palette Name"",""What should the palette be called?"")[0].strip()\n            # VALIDATE: Ensure that the names can not break the dictionary\n            if Name == None or Name == """":\n                NC(2,""SavePalette has been cancelled"")\n                return """"\n        Text = ""from PyQt5 import QtCore, QtGui\\n\\ndef NewColour():\\n    palette1 = QtGui.QPalette()\\n    palette2 = QtGui.QPalette()\\n    palette3 = QtGui.QPalette()""\n        for i in self.PaletteColours:\n            Text += ""\\n    brush = QtGui.QBrush(QtGui.QColor({},{},{}))"".format(str(i.Colour.red()),str(i.Colour.green()),str(i.Colour.blue()))\n            Text += ""\\n    brush.setStyle(QtCore.Qt.SolidPattern)""\n            Text += ""\\n    palette{}.setBrush(QtGui.QPalette.{}, QtGui.QPalette.{}, brush)"".format(i.ModeText.split()[2],i.ModeText.split()[0],i.ElementText)\n        Text += ""\\n    PenColours = {""\n        for i in self.PenColours:\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i.Element,str(i.Colour.red()),str(i.Colour.green()),str(i.Colour.blue()))\n        Text = Text[:-1]+""}\\n    NotificationColours = {""\n        for i in self.NotificationColours:\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i.Element,str(i.Colour.red()),str(i.Colour.green()),str(i.Colour.blue()))\n        Text = Text[:-1]+""}\\n    MiscColours = {""\n        for i in self.MiscColours:\n            Text += ""\\n        \\""{}\\"":QtGui.QBrush(QtGui.QColor({},{},{})),"".format(i.Element,str(i.Colour.red()),str(i.Colour.green()),str(i.Colour.blue()))\n        #\n        Text = Text[:-1]+""}\\n    return palette1 , palette2 , palette3 , PenColours , NotificationColours , MiscColours\\n""\n        try:\n            if not QtWidgets.QApplication.instance().AGeLibPathOK: raise Exception(""AGeLibPath is not OK"")\n            ##\n            TheDict = {}\n            try:\n                nText = Text\n                spec = importlib.util.spec_from_file_location(""CustomColourPalettes"", os.path.join(QtWidgets.QApplication.instance().AGeLibSettingsPath,""CustomColourPalettes.py""))\n                CustomColours = importlib.util.module_from_spec(spec)\n                spec.loader.exec_module(CustomColours)\n                i=1\n                for k,v in CustomColours.Colours.items():\n                    fn = ""c""+str(i)\n                    t,fn,n = self.PaletteToPython(v,fn,k)\n                    if n == Name:\n                        msgBox = QtWidgets.QMessageBox(self)\n                        msgBox.setText(""\\""{}\\"" already exists"".format(Name))\n                        msgBox.setInformativeText(""Do you want to overwrite \\""{}\\""?"".format(Name))\n                        msgBox.setStandardButtons(QtWidgets.QMessageBox.Save | QtWidgets.QMessageBox.Cancel)\n                        msgBox.setDefaultButton(QtWidgets.QMessageBox.Cancel)\n                        ret = msgBox.exec()\n                        if ret != QtWidgets.QMessageBox.Save:\n                            return Text\n                        else:\n                            continue\n                    nText += ""\\n""\n                    nText += t\n                    TheDict[n.replace(""\\\\"",""\\\\\\\\"").replace(""\\"""",""\\\\\\"""")] = fn\n                    i+=1\n            except:\n                NC(2,""Could not load custom colours"",exc=sys.exc_info(),func=""Main_App.Recolour"")\n                msgBox = QtWidgets.QMessageBox(self)\n                msgBox.setText(""Could not load previous custom colours!"")\n                msgBox.setInformativeText(""Do you want to save the colour anyways?\\nWARNING: This will overwrite any previous colour palettes!!!"")\n                msgBox.setStandardButtons(QtWidgets.QMessageBox.Save | QtWidgets.QMessageBox.Cancel)\n                msgBox.setDefaultButton(QtWidgets.QMessageBox.Cancel)\n                ret = msgBox.exec()\n                if ret != QtWidgets.QMessageBox.Save:\n                    return Text\n            Text = nText\n            ##\n            fText = Text+""\\nColours = {\\""""+Name.replace(""\\\\"",""\\\\\\\\"").replace(""\\"""",""\\\\\\"""")+""\\"":NewColour""\n            for k,v in TheDict.items():\n                fText += "",\\""{}\\"":{}"".format(k,v)\n            fText += ""}""\n            FileName = os.path.join(QtWidgets.QApplication.instance().AGeLibSettingsPath,""CustomColourPalettes.py"")\n            with open(FileName,\'w\',encoding=""utf-8"") as text_file:\n                text_file.write(fText)\n        except:\n            NC(1,""Could not save"",exc=sys.exc_info())\n        self.ColourList.blockSignals(True)\n        self.ColourList.clear()\n        self.ColourList.addItems(self.LoadPaletteList())\n        self.ColourList.blockSignals(False)\n        return Text\n\n# -----------------------------------------------------------------------------------------------------------------\n\n#endregion\n\n#region AWWF\n\nclass AWWF(QtWidgets.QMainWindow): # Astus Window With Frame\n    """"""\n    AWWF (Astus Window With Frame) is the face of AGeLib! This window is a full reimplementation\n    of the standard window that operating systems (technically their window manager) provide. \\n\n    todo: Remove this line: (The regular window frames are boring and all professional applications use their own frame. This is my frame so I am a professional now!!!) \\n\n    TODO: Explain how the init and the top bar work! Make some simple examples!\n    """"""\n    #MAYBE: Implement borderless windowed mode as an alternative to full screen. This could be handled by adding a flag that is read in showFullScreen to decide which full screen mode to apply\n    #TODO: Remove dependencies for TopBar and StatusBar to make these entirely optional\n    def __init__(self, parent = None, includeTopBar=True, initTopBar=True, includeStatusBar=True, FullscreenHidesBars = False):\n        self.BarsHidden = False\n        super(AWWF, self).__init__(parent)\n        self.includeTopBar, self.includeStatusBar, self.FullscreenHidesBars = includeTopBar, includeStatusBar, FullscreenHidesBars\n        self.setWindowFlag(QtCore.Qt.FramelessWindowHint,True)\n        self.AWWF_CentralWidget = Window_Frame_Widget(self)\n        self.AWWF_CentralWidget_layout =  QtWidgets.QGridLayout(self.AWWF_CentralWidget)\n        self.AWWF_CentralWidget_layout.setContentsMargins(0, 0, 0, 0)\n        self.AWWF_CentralWidget_layout.setSpacing(0)\n        self.AWWF_CentralWidget_layout.setObjectName(""gridLayout"")\n        self.AWWF_CentralWidget.setLayout(self.AWWF_CentralWidget_layout)\n        \n        self.AWWF_CentralWindow = QtWidgets.QMainWindow(self)\n        self.AWWF_CentralWidget_layout.addWidget(self.AWWF_CentralWindow,1,0)\n        \n        super(AWWF, self).setCentralWidget(self.AWWF_CentralWidget)\n        self.AWWF_p_MenuBar = None\n        self.AWWF_p_CentralWidget = None\n        self.AWWF_p_StatusBar = None\n        self.standardSize = (900, 500)\n        self.LastOpenState = self.showNormal\n        self.OnTop = False\n\n        self.installEventFilter(self)\n\n        if includeTopBar:\n            self.TopBar = TopBar_Widget(self,initTopBar)\n            self.MenuBar = MMenuBar(self)\n            self.setMenuBar(self.MenuBar)\n            self.MenuBar.setCornerWidget(self.TopBar)\n            self.MenuBar.setContentsMargins(0,0,0,0)\n        if includeStatusBar:\n            self.statusbar = StatusBar_Widget(self)\n            self.statusbar.setObjectName(""statusbar"")\n            self.setStatusBar(self.statusbar)\n            self.statusbar.setSizeGripEnabled(False)\n            self.windowTitleChanged.connect(self.statusbar.setWindowTitle)\n\n ##################### Layout Attempt\n  #    def setMenuBar(self, MenuBar):\n  #        if MenuBar == None:\n  #            try:\n  #                self.AWWF_CentralWidget_layout.addWidget(QtWidgets.QWidget(self),0,0)\n  #                self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_MenuBar)\n  #            except common_exceptions:\n  #                pass\n  #        else:\n  #            self.AWWF_CentralWidget_layout.addWidget(MenuBar,0,0)\n  #            MenuBar.setCursor(MenuBar.cursor())\n  #        self.AWWF_p_MenuBar = MenuBar\n  #        return True\n  #\n  #    def menuBar(self):\n  #        return self.AWWF_p_MenuBar\n  #\n  #    def setCentralWidget(self, CentralWidget):\n  #        if CentralWidget == None:\n  #            try:\n  #                self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_CentralWidget)\n  #            except common_exceptions:\n  #                pass\n  #        else:\n  #            self.AWWF_CentralWidget_layout.addWidget(CentralWidget,1,0)\n  #            CentralWidget.setCursor(CentralWidget.cursor())\n  #        self.AWWF_p_CentralWidget = CentralWidget\n  #        return True\n  #\n  #    def centralWidget(self):\n  #        return self.AWWF_p_CentralWidget\n  #        \n  #    def setStatusBar(self, StatusBar):\n  #        if StatusBar == None:\n  #            try:\n  #                self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_StatusBar)\n  #            except common_exceptions:\n  #                pass\n  #        else:\n  #            self.AWWF_CentralWidget_layout.addWidget(StatusBar,2,0)\n  #            StatusBar.setCursor(StatusBar.cursor())\n  #        self.AWWF_p_StatusBar = StatusBar\n  #        return True\n  #\n  #    def statusBar(self):\n  #        return self.AWWF_p_StatusBar\n  #\n  #\n ##################### MenuBar/CentralWidget/StatusBar/ToolBar\n\n    def setMenuBar(self, MenuBar):\n        if MenuBar == None:\n            try:\n                self.AWWF_CentralWindow.setMenuBar(None)\n                #self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_MenuBar)\n            except common_exceptions:\n                pass\n        else:\n            self.AWWF_CentralWindow.setMenuBar(MenuBar)\n            MenuBar.setCursor(MenuBar.cursor())\n        self.AWWF_p_MenuBar = MenuBar\n        return True\n        # TODO: The following seems to be cleaner and more efficient... Use this for all of these redirects...\n        #r = self.AWWF_CentralWindow.setMenuBar(MenuBar)\n        #try:\n        #    MenuBar.setCursor(MenuBar.cursor())\n        #except:\n        #    pass\n        #return r\n\n    def menuBar(self):\n        return self.AWWF_CentralWindow.menuBar()\n\n    def setCentralWidget(self, CentralWidget):\n        if CentralWidget == None:\n            try:\n                self.AWWF_CentralWindow.setCentralWidget(None)\n            except common_exceptions:\n                pass\n        else:\n            self.AWWF_CentralWindow.setCentralWidget(CentralWidget)\n            CentralWidget.setCursor(CentralWidget.cursor())\n        self.AWWF_p_CentralWidget = CentralWidget\n        return True\n\n    def centralWidget(self):\n        return self.AWWF_CentralWindow.centralWidget()\n        \n    def setStatusBar(self, StatusBar):\n        if StatusBar == None:\n            try:\n                self.AWWF_CentralWindow.setStatusBar(None)\n            except common_exceptions:\n                pass\n        else:\n            self.AWWF_CentralWindow.setStatusBar(StatusBar)\n            StatusBar.setCursor(StatusBar.cursor())\n        self.AWWF_p_StatusBar = StatusBar\n        return True\n\n    def statusBar(self):\n        return self.AWWF_CentralWindow.statusBar()\n\n    # ToolBar #TODO:Expand\n    def addToolBar(self, *ToolBar):\n        if ToolBar == None:\n            try:\n                self.AWWF_CentralWindow.addToolBar(None)\n                #self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_MenuBar)\n            except common_exceptions:\n                pass\n        else:\n            self.AWWF_CentralWindow.addToolBar(*ToolBar)\n        return True\n\n    def insertToolBar(self, *ToolBar):\n        if ToolBar == None:\n            try:\n                self.AWWF_CentralWindow.insertToolBar(None)\n                #self.AWWF_CentralWidget_layout.removeWidget(self.AWWF_p_MenuBar)\n            except common_exceptions:\n                pass\n        else:\n            self.AWWF_CentralWindow.insertToolBar(*ToolBar)\n        return True\n\n    def toolBarArea(self):\n        return self.AWWF_CentralWindow.toolBarArea()\n\n ##################### show, restoreState and positionReset\n    def HideBars(self,b):\n        """"""\n        If b=True  the menu, top and status bar are permanently hidden. \\n\n        If b=False the menu, top and status bar will be shown again. \\n\n        Hiding these bars is not recommended!\n        """"""\n        self.BarsHidden = b\n        self.TopBar.setVisible(b)\n        try:\n            self.MenuBar.setVisible(b)\n        except:\n            pass\n        try:\n            self.statusbar.setVisible(b)\n        except:\n            pass\n    def setTopBarVisible(self,b):\n        if not self.BarsHidden:\n            self.TopBar.setVisible(b)\n            try:\n                self.MenuBar.setVisible(b)\n            except:\n                pass\n            try:\n                self.statusbar.setVisible(b)\n            except:\n                pass\n\n    def showNormal(self):\n        self.setTopBarVisible(True)\n        self.AWWF_CentralWidget.showFrame()\n        self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        super(AWWF, self).showNormal()\n    def show(self):\n        self.setTopBarVisible(True)\n        super(AWWF, self).show()\n        QtWidgets.QApplication.instance().processEvents()\n        if self.isFullScreen() or self.isMaximized():\n            self.AWWF_CentralWidget.hideFrame()\n            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        else:\n            self.AWWF_CentralWidget.showFrame()\n            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        if self.isFullScreen() and self.FullscreenHidesBars:\n            self.setTopBarVisible(False)\n    def showMaximized(self):\n        self.setTopBarVisible(True)\n        self.AWWF_CentralWidget.hideFrame()\n        self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        super(AWWF, self).showMaximized()\n    def showFullScreen(self):\n        if self.FullscreenHidesBars:\n            self.setTopBarVisible(False)\n        else:\n            self.setTopBarVisible(True)\n        self.AWWF_CentralWidget.hideFrame()\n        self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        super(AWWF, self).showFullScreen()\n        \n    def restoreState(self,state,version=0):\n        self.setTopBarVisible(True)\n        super(AWWF, self).restoreState(state,version)\n        QtWidgets.QApplication.instance().processEvents()\n        if self.isFullScreen() or self.isMaximized():\n            self.AWWF_CentralWidget.hideFrame()\n            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        else:\n            self.AWWF_CentralWidget.showFrame()\n            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        if self.isFullScreen() and self.FullscreenHidesBars:\n            self.setTopBarVisible(False)\n            \n    def positionReset(self):\n        self.showNormal()\n        QtWidgets.QApplication.instance().processEvents()\n        try:\n            self.resize(*self.standardSize)\n        except common_exceptions:\n            self.resize(900, 600)\n        QtWidgets.QApplication.instance().processEvents()\n        try:\n            frameGm = self.frameGeometry()\n            screen = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())\n            centerPoint = QtWidgets.QApplication.desktop().screenGeometry(screen).center()\n            frameGm.moveCenter(centerPoint)\n            self.move(frameGm.topLeft())\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n        QtWidgets.QApplication.instance().processEvents()\n\n ##################### eventFilter\n    def eventFilter(self, source, event):\n        if event.type() == 6 and App().enableHotkeys: # QtCore.QEvent.KeyPress\n            if event.modifiers() == QtCore.Qt.AltModifier:\n                if event.key() == QtCore.Qt.Key_T and source is self: # Alt+T to toggle on top\n                    if not self.OnTop:\n                        print(""Try OnTop"")\n                        self.OnTop = True\n                        self.setWindowFlag(QtCore.Qt.X11BypassWindowManagerHint,True)\n                        self.setWindowFlag(QtCore.Qt.BypassWindowManagerHint,True)\n                        self.setWindowFlag(QtCore.Qt.WindowStaysOnTopHint,True)\n                        QtWidgets.QApplication.instance().processEvents()\n                        self.show()\n                    else:\n                        print(""No longer OnTop"")\n                        self.OnTop = False\n                        self.setWindowFlag(QtCore.Qt.X11BypassWindowManagerHint,False)\n                        self.setWindowFlag(QtCore.Qt.BypassWindowManagerHint,False)\n                        self.setWindowFlag(QtCore.Qt.WindowStaysOnTopHint,False)\n                        QtWidgets.QApplication.instance().processEvents()\n                        self.show()\n            else:\n                if event.key() == QtCore.Qt.Key_F11 and source is self: # F11 to toggle Fullscreen\n                    if not self.isFullScreen():\n                        if self.isMaximized():\n                            self.LastOpenState = self.showMaximized\n                            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                        else:\n                            self.LastOpenState = self.showNormal\n                            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n                        self.showFullScreen()\n                    else:\n                        if self.LastOpenState == self.showMaximized:\n                            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n                        else:\n                            self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                        self.LastOpenState()\n        #    #if event.modifiers() == QtCore.Qt.MetaModifier: # Does not work on windows as the meta key is not detected this way\n        #    modifiers = QtWidgets.QApplication.keyboardModifiers() # Detects the meta key\n        #    if modifiers == QtCore.Qt.MetaModifier: # Does not work on windows as windows eats all other key while the Meta Key is pressed...\n        #        print(""win"")\n        #        screenNumber = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())\n        #        screen = QtWidgets.QApplication.desktop().availableGeometry(screenNumber)\n        #        Half_X = (screen.bottomRight().x()-screen.topLeft().x())/2+1\n        #        Full_X = (screen.bottomRight().x()-screen.topLeft().x())+1\n        #        Half_Y = (screen.bottomRight().y()-screen.topLeft().y())/2+1\n        #        Full_Y = (screen.bottomRight().y()-screen.topLeft().y())+1\n        #        # Left Side\n        #        if event.key() == QtCore.Qt.Key_Left:\n        #            self.window().resize(Half_X, Full_Y)\n        #            frameGm = self.window().frameGeometry()\n        #            frameGm.moveTopLeft(screen.topLeft())\n        #            self.window().move(frameGm.topLeft())\n        #        # Right Side\n        #        elif event.key() == QtCore.Qt.Key_Right:\n        #            self.window().resize(Half_X, Full_Y)\n        #            frameGm = self.window().frameGeometry()\n        #            frameGm.moveTopRight(screen.topRight())\n        #            self.window().move(frameGm.topLeft())\n        #        # Top Side\n        #        elif event.key() == QtCore.Qt.Key_Up:\n        #            self.window().resize(Full_X, Half_Y)\n        #            frameGm = self.window().frameGeometry()\n        #            frameGm.moveTopRight(screen.topRight())\n        #            self.window().move(frameGm.topLeft())\n        #        # Bottom Side\n        #        elif event.key() == QtCore.Qt.Key_Down:\n        #            self.window().resize(Full_X, Half_Y)\n        #            frameGm = self.window().frameGeometry()\n        #            frameGm.moveBottomLeft(screen.bottomLeft())\n        #            self.window().move(frameGm.topLeft())\n        \n        #if type(source) == QtWidgets.QAction and event.type() == QtCore.QEvent.Enter and source.toolTip()!="""": #==10\n        #    QtWidgets.QToolTip.showText(QtGui.QCursor.pos(),source.toolTip(),source)\n        return super(AWWF, self).eventFilter(source, event) # let the normal eventFilter handle the event\n\nclass TopBar_Widget(QtWidgets.QWidget):\n    def __init__(self, parent=None, DoInit=False, IncludeMenu = False, IncludeFontSpinBox = True, IncludeErrorButton = False, IncludeAdvancedCB = False):\n        super(TopBar_Widget, self).__init__(parent)\n        self.moving = False\n        self.offset = 0\n        self.IncludeMenu, self.IncludeFontSpinBox = IncludeMenu, IncludeFontSpinBox\n        self.IncludeErrorButton, self.IncludeAdvancedCB = IncludeErrorButton, IncludeAdvancedCB\n        if DoInit:\n            self.init(IncludeMenu, IncludeFontSpinBox, IncludeErrorButton, IncludeAdvancedCB)\n\n    def init(self, IncludeMenu = False, IncludeFontSpinBox = False, IncludeErrorButton = False, IncludeAdvancedCB = False):\n        # TODO: restrict the height and add the Option for a QtWidgets.QSpacerItem to make the horizontal spacing work if not corner widget\n        self.IncludeMenu, self.IncludeFontSpinBox = IncludeMenu, IncludeFontSpinBox\n        self.IncludeErrorButton, self.IncludeAdvancedCB = IncludeErrorButton, IncludeAdvancedCB\n        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        self.setObjectName(""TopBar"")\n        if self.layout() == None:\n            self.gridLayout = QtWidgets.QGridLayout(self)\n            self.gridLayout.setContentsMargins(0, 0, 0, 0)\n            self.gridLayout.setSpacing(0)\n            self.gridLayout.setObjectName(""gridLayout"")\n            #self.gridLayout.setSizeConstraint(QtWidgets.QGridLayout.SetNoConstraint)\n            self.setLayout(self.gridLayout)\n\n        self.ButtonSizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n\n        self.CloseButton = QtWidgets.QToolButton(self)\n        self.CloseButton.setObjectName(""CloseButton"")\n        self.layout().addWidget(self.CloseButton, 0, 108, 1, 1,QtCore.Qt.AlignRight)\n        self.CloseButton.setText(""\xf0\x9f\x97\x99"")\n\n        self.RedHighlightPalette = QtGui.QPalette()\n        brush = QtGui.QBrush(QtGui.QColor(155, 0, 0))\n        brush.setStyle(QtCore.Qt.SolidPattern)\n        self.RedHighlightPalette.setBrush(QtGui.QPalette.All, QtGui.QPalette.Button, brush)\n        brush = QtGui.QBrush(QtGui.QColor(255, 255, 255))\n        brush.setStyle(QtCore.Qt.SolidPattern)\n        self.RedHighlightPalette.setBrush(QtGui.QPalette.All, QtGui.QPalette.ButtonText, brush)\n        self.CloseButton.installEventFilter(self)\n        self.CloseButton.setAutoRaise(True)\n        self.CloseButton.setSizePolicy(self.ButtonSizePolicy)\n\n        self.MaximizeButton = QtWidgets.QToolButton(self)\n        self.MaximizeButton.setObjectName(""MaximizeButton"")\n        self.layout().addWidget(self.MaximizeButton, 0, 107, 1, 1,QtCore.Qt.AlignRight)\n        self.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        self.MaximizeButton.installEventFilter(self)\n        self.MaximizeButton.setAutoRaise(True)\n        self.MaximizeButton.setSizePolicy(self.ButtonSizePolicy)\n\n        self.MinimizeButton = QtWidgets.QToolButton(self)\n        self.MinimizeButton.setObjectName(""MinimizeButton"")\n        self.layout().addWidget(self.MinimizeButton, 0, 106, 1, 1,QtCore.Qt.AlignRight)\n        self.MinimizeButton.setText(""\xf0\x9f\x97\x95"")\n        self.MinimizeButton.installEventFilter(self)\n        self.MinimizeButton.setAutoRaise(True)\n        self.MinimizeButton.setSizePolicy(self.ButtonSizePolicy)\n\n        self.OptionsButton = QtWidgets.QToolButton(self)\n        self.OptionsButton.setObjectName(""OptionsButton"")\n        self.layout().addWidget(self.OptionsButton, 0, 105, 1, 1,QtCore.Qt.AlignRight)\n        self.OptionsButton.setText(""\xe2\x9a\x99"")\n        self.OptionsButton.setToolTip(""Show the options window"")\n        self.OptionsButton.installEventFilter(self)\n        self.OptionsButton.setAutoRaise(True)\n        self.OptionsButton.setSizePolicy(self.ButtonSizePolicy)\n\n        self.MoveMe = QtWidgets.QLabel(self)\n        self.MoveMe.setObjectName(""MoveMe"")\n        self.layout().addWidget(self.MoveMe, 0, 104, 1, 1,QtCore.Qt.AlignRight)\n        self.MoveMe.setText(""  \xf0\x9f\x96\x90\xe2\x80\x80\xe2\x80\x80"")#\xe2\x96\xa8#\xf0\x9f\x96\x90\n        self.MoveMe.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))\n\n        self.CloseButton.clicked.connect(self.Exit)\n        self.MaximizeButton.clicked.connect(self.ToggleMinMax)\n        self.MinimizeButton.clicked.connect(self.Minimize)\n        self.OptionsButton.clicked.connect(App().Show_Options)\n\n        try:\n            #self.window().menuBar().installEventFilter(self)\n            if IncludeMenu:\n                self.Menu = QtWidgets.QToolButton(self)\n                self.Menu.setObjectName(""Menu"")\n                self.layout().addWidget(self.Menu, 0, 103, 1, 1,QtCore.Qt.AlignRight)\n                self.Menu.setText(""\\u2630"")#\xe2\x98\xb0 #(""\xe2\x89\xa1"")\n                self.Menu.setAutoRaise(True)\n                self.Menu.setPopupMode(QtWidgets.QToolButton.InstantPopup)\n                self.Menu.setMenu(self.window().Menu)\n                self.Menu.setSizePolicy(self.ButtonSizePolicy)\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n        \n        if IncludeAdvancedCB:\n            self.AdvancedCB = QtWidgets.QCheckBox(self)\n            self.AdvancedCB.setText("""")\n            self.AdvancedCB.setToolTip(""Advanced Mode (alt+A)"")\n            self.AdvancedCB.setChecked(QtWidgets.QApplication.instance().advanced_mode)\n            self.AdvancedCB.setObjectName(""AdvancedCB"")\n            self.layout().addWidget(self.AdvancedCB, 0, 102, 1, 1,QtCore.Qt.AlignRight)\n            self.AdvancedCB.clicked.connect(QtWidgets.QApplication.instance().ToggleAdvancedMode)\n\n        if IncludeFontSpinBox:\n            self.Font_Size_spinBox = QtWidgets.QSpinBox(self)\n            self.Font_Size_spinBox.setMinimum(5)\n            self.Font_Size_spinBox.setMaximum(25)\n            self.Font_Size_spinBox.setProperty(""value"", self.font().pointSize())\n            self.Font_Size_spinBox.setObjectName(""Font_Size_spinBox"")\n            self.layout().addWidget(self.Font_Size_spinBox, 0, 101, 1, 1,QtCore.Qt.AlignRight)\n            self.Font_Size_spinBox.valueChanged.connect(self.ChangeFontSize)\n\n        if IncludeErrorButton:\n            self.Error_Label = QtWidgets.QPushButton(self)\n            self.Error_Label.setObjectName(""Error_Label"")\n            self.Error_Label.setText(QtWidgets.QApplication.instance().LastNotificationText)\n            self.Error_Label.setToolTip(QtWidgets.QApplication.instance().LastNotificationToolTip)\n            self.Error_Label.setIcon(QtWidgets.QApplication.instance().LastNotificationIcon)\n            self.layout().addWidget(self.Error_Label, 0, 100, 1, 1,QtCore.Qt.AlignRight)\n            self.Error_Label.installEventFilter(self)\n            self.Error_Label.clicked.connect(QtWidgets.QApplication.instance().Show_Notification_Window)\n\n    def Minimize(self):\n        self.window().showMinimized()\n\n    def ToggleMinMax(self):\n        if not self.window().isFullScreen():\n            if self.window().isMaximized():\n                self.window().showNormal()\n                self.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n            else:\n                self.window().setGeometry(\n                    Qt.QStyle.alignedRect(\n                        QtCore.Qt.LeftToRight,\n                        QtCore.Qt.AlignCenter,\n                        self.window().size(),\n                        QtWidgets.QApplication.instance().desktop().availableGeometry(self.window())))\n                self.window().showMaximized()\n                self.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        else:\n            try:\n                if self.window().LastOpenState == self.window().showMaximized:\n                    self.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n                else:\n                    self.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                self.window().LastOpenState()\n            except AttributeError:\n                self.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n                self.window().showMaximized()\n\n    def Exit(self):\n        self.window().close()\n\n    def ChangeFontSize(self):\n        try:\n            QtWidgets.QApplication.instance().SetFont(PointSize = self.Font_Size_spinBox.value(), source=self.window())\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n        \n    def eventFilter(self, source, event):\n        #if event.type() == 5: # QtCore.QEvent.MouseMove\n        #    if self.moving: self.window().move(event.globalPos()-self.offset)\n        #elif event.type() == 2: # QtCore.QEvent.MouseButtonPress\n        #    if event.button() == QtCore.Qt.LeftButton:\n        #        self.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n        #        self.MoveMe.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n        #        self.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        #        self.moving = True; self.offset = event.globalPos()-self.window().geometry().topLeft()\n        #elif event.type() == 3: # QtCore.QEvent.MouseButtonRelease\n        #    self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        #    self.MoveMe.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))\n        #    self.moving = False\n        #    if event.button() == QtCore.Qt.LeftButton:\n        #        pos = self.window().pos()\n        #        #if (pos.x() < 0):\n        #        #    pos.setX(0)\n        #        #    self.window().move(pos)\n        #        if (pos.y() < 0):\n        #            pos.setY(0)\n        #            self.window().move(pos)\n        if event.type() == 10 or event.type() == 11:# QtCore.QEvent.Enter or QtCore.QEvent.Leave\n            if source == self.CloseButton:\n                if event.type() == QtCore.QEvent.Enter:#HoverMove\n                    self.CloseButton.setPalette(self.RedHighlightPalette)\n                elif event.type() == QtCore.QEvent.Leave:#HoverLeave\n                    self.CloseButton.setPalette(self.palette())\n            elif source == self.MaximizeButton:\n                if event.type() == QtCore.QEvent.Enter:\n                    self.MaximizeButton.setAutoRaise(False)\n                elif event.type() == QtCore.QEvent.Leave:\n                    self.MaximizeButton.setAutoRaise(True)\n            elif source == self.MinimizeButton:\n                if event.type() == QtCore.QEvent.Enter:\n                    self.MinimizeButton.setAutoRaise(False)\n                elif event.type() == QtCore.QEvent.Leave:\n                    self.MinimizeButton.setAutoRaise(True)\n        elif self.IncludeErrorButton and source is self.Error_Label and event.type() == QtCore.QEvent.Enter: #==10\n            QtWidgets.QToolTip.showText(QtGui.QCursor.pos(),self.Error_Label.toolTip(),self.Error_Label)\n        return super(TopBar_Widget, self).eventFilter(source, event)\n\n    def mousePressEvent(self,event):\n        if event.button() == QtCore.Qt.LeftButton:\n            self.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n            self.MoveMe.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n            #if self.window().isMaximized() or self.window().isFullScreen(): # If moving the window while in fullscreen or maximized make it normal first\n            #    corPos = self.window().geometry().topRight()\n            #    self.window().showNormal()\n            #    self.window().AWWF_CentralWidget.showFrame()\n            #    QtWidgets.QApplication.instance().processEvents()\n            #    self.window().move(corPos-self.window().geometry().topRight()+self.window().geometry().topLeft())\n            self.moving = True; self.offset = event.globalPos()-self.window().geometry().topLeft()\n\n    def mouseReleaseEvent(self,event):\n        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        self.MoveMe.setCursor(QtGui.QCursor(QtCore.Qt.OpenHandCursor))\n        if event.button() == QtCore.Qt.LeftButton:\n            pos = self.window().pos()\n            #if (pos.x() < 0):\n            #    pos.setX(0)\n            #    self.window().move(pos)\n            if (pos.y() < 0):\n                pos.setY(0)\n                self.window().move(pos)\n            # If the mouse is in a corner or on a side let the window fill this corner or side of the screen\n            try:\n                Tolerance = 5\n                eventPos = event.globalPos()\n                screenNumber = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())\n                screen = QtWidgets.QApplication.desktop().availableGeometry(screenNumber)\n                Half_X = (screen.bottomRight().x()-screen.topLeft().x())/2+1\n                Full_X = (screen.bottomRight().x()-screen.topLeft().x())+1\n                Half_Y = (screen.bottomRight().y()-screen.topLeft().y())/2+1\n                Full_Y = (screen.bottomRight().y()-screen.topLeft().y())+1\n                BottomMax = screen.bottomLeft().y()\n                RightMax = screen.bottomRight().x()\n                TopMax = screen.topLeft().y()\n                LeftMax = screen.topLeft().x()\n                #if (pos.y() > BottomMax): # If Bottom Side gets removed this must be turned on to make it impossible for the window to get lost behind the task bar\n                #    pos.setY(BottomMax-50)\n                #    self.window().move(pos)\n                # Top Left\n                if eventPos.x() <= Tolerance + LeftMax and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Left\n                elif eventPos.x() <= Tolerance + LeftMax and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n                # Top Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomRight(screen.bottomRight())\n                    self.window().move(frameGm.topLeft())\n                # Left Side\n                elif eventPos.x() <= Tolerance + LeftMax:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Right Side\n                elif eventPos.x() >= RightMax-Tolerance:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Top Side\n                elif eventPos.y() <= Tolerance + TopMax:\n                    if advancedMode(): # MAYBE: Make this behaviour for advanced mode toggable in the options if a user never wants this\n                        self.window().resize(Full_X, Half_Y)\n                        frameGm = self.window().frameGeometry()\n                        frameGm.moveTopRight(screen.topRight())\n                        self.window().move(frameGm.topLeft())\n                    else:\n                        self.window().showMaximized()\n                # Bottom Side\n                elif eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Full_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n            except common_exceptions:\n                NC(exc=sys.exc_info(),win=self.window().windowTitle(),func=""TopBar_Widget.mouseReleaseEvent"")\n\n    def mouseMoveEvent(self,event):\n        if self.moving:\n            if (self.window().isMaximized() or self.window().isFullScreen()): # If moving the window while in fullscreen or maximized make it normal first\n                # TODO: Make normalizing the window relative to the previous and current window width to keep the cursor on the window regardless wether clicking right or left\n                self.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                corPos = self.window().geometry().topRight()\n                self.window().showNormal()\n                self.window().AWWF_CentralWidget.showFrame()\n                QtWidgets.QApplication.instance().processEvents()\n                self.window().move(corPos-self.window().geometry().topRight()+self.window().geometry().topLeft())\n                self.offset = event.globalPos()-self.window().geometry().topLeft()\n            self.window().move(event.globalPos()-self.offset)\n\nclass StatusBar_Widget(QtWidgets.QStatusBar):\n    def __init__(self, parent=None):\n        super(StatusBar_Widget, self).__init__(parent)\n        self.WindowNameLabel = QtWidgets.QLabel(self)\n        self.addPermanentWidget(self.WindowNameLabel)\n\n    def setWindowTitle(self, WindowTitle):\n        WindowTitle += "" ""\n        self.WindowNameLabel.setText(WindowTitle)\n\nclass MenuAction(QtWidgets.QAction):\n    def __init__(self, parent=None, text=None, tooltip=None, action=None, add=False, icon=None):\n        if text != None:\n            if icon != None:\n                super(MenuAction, self).__init__(icon,text,parent)\n            else:\n                super(MenuAction, self).__init__(text,parent)\n        else:\n            super(MenuAction, self).__init__(parent)\n        if tooltip != None:\n            self.setToolTip(tooltip)\n        if action != None:\n            if type(action) != list:\n                action = [action]\n            for i in action:\n                self.triggered.connect(i)\n        if add:\n            parent.addAction(self)\n        self.hovered.connect(self.showToolTip)\n    \n    def showToolTip(self):\n        #if self.toolTip() != """" and self.toolTip() != None and self.toolTip() != self.text():\n        QtWidgets.QToolTip.showText(QtGui.QCursor.pos(),self.toolTip())#,self)\n\nclass Window_Frame_Widget(QtWidgets.QFrame):\n    def __init__(self, parent = None):\n        super(Window_Frame_Widget, self).__init__(parent)\n        self.FrameEnabled = False\n        self.moving = False\n        self.setMouseTracking(True)\n\n        \n        # Resizing was inspired by an answer to https://stackoverflow.com/questions/37047236/qt-resizable-and-movable-main-window-without-title-bar (16.12.2019)\n        self.offset = 0\n        self.mPos = None# For dragging, relative mouse position to upper left\n        self.global_mPos = None # For resizing, global mouse position at mouse click\n        self.rs_mPos = None # for resizing\n        self.storeWidth = 0 # fix window size at mouseclick for resizing\n        self.storeHeight = 0\n        self.adjXFac = 0\n        self.adjYFac = 0\n        self.transXFac = 0\n        self.transYFac = 0\n        self.Direction = ""D""\n    \n    def showFrame(self):\n        self.FrameEnabled = True\n        self.setFrameStyle(self.Box | self.Sunken)\n        self.setLineWidth(2)\n        #self.setMidLineWidth(3)\n\n    def hideFrame(self):\n        self.FrameEnabled = False\n        self.setFrameStyle(self.NoFrame)\n        #self.setLineWidth(1)\n        #self.setMidLineWidth(3)\n\n    def mousePressEvent(self,event):\n        if (event.button() == QtCore.Qt.LeftButton):\n            # Coordinates have been mapped such that the mouse position is relative to the upper left of the main window\n            self.mPos = event.globalPos() - self.window().frameGeometry().topLeft()\n\n            # At the moment of mouse click, capture global position and lock the size of window for resizing\n            self.global_mPos = event.globalPos()\n            self.storeWidth = self.width()\n            self.storeHeight= self.height()\n            self.offset = event.globalPos()-self.window().geometry().topLeft() # event.globalPos()-frameGeometry().topLeft()\n            rs_size = 20\n            # Big if statement checks if the mouse is near the frame and if the frame is enabled\n            if ( ((abs(self.offset.x()) < rs_size) or\n                    (abs(self.offset.x()) > self.width()-rs_size) or\n                    (abs(self.offset.x()) < rs_size) or\n                    (abs(self.offset.x()) > self.width()-rs_size)or\n                    (abs(self.offset.y()) < rs_size) or\n                    (abs(self.offset.y()) <rs_size) or\n                    (abs(self.offset.y())> self.height()-rs_size) or\n                    (abs(self.offset.y())> self.height()-rs_size))\n                    and self.FrameEnabled):\n                # Use 2x2 matrix to adjust how much you are resizing and how much you\n                # are moving. Since the default coordinates are relative to upper left\n                # You cannot just have one way of resizing and moving the window.\n                # It will depend on which corner you are referring to\n                # \n                # self.adjXFac and self.adjYFac are for calculating the difference between your\n                # current mouse position and where your mouse was when you clicked.\n                # With respect to the upper left corner, moving your mouse to the right\n                # is an increase in coordinates, moving mouse to the bottom is increase etc.\n                # However, with other corners this is not so and since I chose to subtract\n                # This difference at the end for resizing, self.adjXFac and self.adjYFac should be\n                # 1 or -1 depending on whether moving the mouse in the x or y directions\n                # increases or decreases the coordinates respectively. \n                # \n                # self.transXFac self.transYFac is to move the window over. Resizing the window does not\n                # automatically pull the window back toward your mouse. This is what\n                # transfac is for (translate window in some direction). It will be either\n                # 0 or 1 depending on whether you need to translate in that direction.\n                #\n                # Initialize Matrix:\n                # Upper left corner section\n                if ( (abs(self.offset.x()) < rs_size and abs(self.offset.y()) < rs_size)):\n                    self.setCursor(QtCore.Qt.SizeFDiagCursor)\n                    # Upper left. No flipping of axis, no translating window\n                    self.adjXFac=1\n                    self.adjYFac=1\n                    self.transXFac=0\n                    self.transYFac=0\n                    self.Direction = ""D""\n                    self.moving = True\n                # Upper right corner section\n                elif(abs(self.offset.x()) > self.width()-rs_size and abs(self.offset.y()) <rs_size):\n                    self.setCursor(QtCore.Qt.SizeBDiagCursor)\n                    # upper right. Flip displacements in mouse movement across x axis\n                    # and translate window left toward the mouse\n                    self.adjXFac=-1\n                    self.adjYFac=1\n                    self.transXFac=1\n                    self.transYFac=0\n                    self.Direction = ""D""\n                    self.moving = True\n                # Lower left corner section\n                elif(abs(self.offset.x()) < rs_size and abs(self.offset.y())> self.height()-rs_size):\n                    self.setCursor(QtCore.Qt.SizeBDiagCursor)\n                    # lower left. Flip displacements in mouse movement across y axis\n                    # and translate window up toward mouse\n                    self.adjXFac=1\n                    self.adjYFac=-1\n                    self.transXFac=0\n                    self.transYFac=1\n                    self.Direction = ""D""\n                    self.moving = True\n                # Lower right corner section\n                elif(abs(self.offset.x()) > self.width()-rs_size and abs(self.offset.y())> self.height()-rs_size):\n                    self.setCursor(QtCore.Qt.SizeFDiagCursor)\n                    # lower right. Flip mouse displacements on both axis and\n                    # translate in both x and y direction left and up toward mouse.\n                    self.adjXFac=-1\n                    self.adjYFac=-1\n                    self.transXFac=1\n                    self.transYFac=1\n                    self.Direction = ""D""\n                    self.moving = True\n\n\n                # Upper Side\n                elif abs(self.offset.y()) < rs_size:\n                    self.setCursor(QtCore.Qt.SizeVerCursor)\n                    self.adjXFac=-1#1\n                    self.adjYFac=1\n                    self.transXFac=1#0\n                    self.transYFac=0\n                    self.Direction = ""y""\n                    self.moving = True\n                # Lower side\n                elif abs(self.offset.y()) > self.height()-rs_size:\n                    self.setCursor(QtCore.Qt.SizeVerCursor)\n                    self.adjXFac=-1\n                    self.adjYFac=-1\n                    self.transXFac=1\n                    self.transYFac=1\n                    self.Direction = ""y""\n                    self.moving = True\n                # Right Side\n                elif abs(self.offset.x()) > self.width()-rs_size:\n                    self.setCursor(QtCore.Qt.SizeHorCursor)\n                    self.adjXFac=-1\n                    self.adjYFac=-1#1\n                    self.transXFac=1\n                    self.transYFac=1#0\n                    self.Direction = ""x""\n                    self.moving = True\n                # Left Side\n                elif abs(self.offset.x()) < rs_size:\n                    self.setCursor(QtCore.Qt.SizeHorCursor)\n                    self.adjXFac=1\n                    self.adjYFac=-1\n                    self.transXFac=0\n                    self.transYFac=1\n                    self.Direction = ""x""\n                    self.moving = True\n\n            event.accept()\n\n    def mouseReleaseEvent(self,event):\n        self.moving = False\n        self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))\n\n    def mouseMoveEvent(self,event):\n        if self.moving:\n            #if (event.buttons()==QtCore.Qt.LeftButton ):\n            if self.Direction == ""D"":\n                # Calculation of displacement. self.adjXFac=1 means normal displacement\n                # self.adjXFac=-1 means flip over axis     \n                adjXDiff = self.adjXFac*(event.globalPos().x() - self.global_mPos.x())\n                adjYDiff = self.adjYFac*(event.globalPos().y() - self.global_mPos.y())\n                # if transfac is 1 then movepoint of mouse is translated     \n                movePoint = QtCore.QPoint(self.mPos.x() - self.transXFac*adjXDiff, self.mPos.y()-self.transYFac*adjYDiff)\n                self.window().move(event.globalPos()-movePoint)\n                self.window().resize(self.storeWidth-adjXDiff, self.storeHeight-adjYDiff)\n            elif self.Direction == ""y"":\n                # Calculation of displacement. self.adjXFac=1 means normal displacement\n                # self.adjXFac=-1 means flip over axis     \n                adjXDiff = self.adjXFac*(event.globalPos().x() - self.global_mPos.x())\n                adjYDiff = self.adjYFac*(event.globalPos().y() - self.global_mPos.y())\n                # if transfac is 1 then movepoint of mouse is translated     \n                movePoint = QtCore.QPoint(self.mPos.x() - self.transXFac*adjXDiff, self.mPos.y()-self.transYFac*adjYDiff)\n                self.window().move(event.globalPos()-movePoint)\n                self.window().resize(self.storeWidth, self.storeHeight-adjYDiff)\n            elif self.Direction == ""x"":\n                # Calculation of displacement. self.adjXFac=1 means normal displacement\n                # self.adjXFac=-1 means flip over axis     \n                adjXDiff = self.adjXFac*(event.globalPos().x() - self.global_mPos.x())\n                adjYDiff = self.adjYFac*(event.globalPos().y() - self.global_mPos.y())\n                # if transfac is 1 then movepoint of mouse is translated     \n                movePoint = QtCore.QPoint(self.mPos.x() - self.transXFac*adjXDiff, self.mPos.y()-self.transYFac*adjYDiff)\n                self.window().move(event.globalPos()-movePoint)\n                self.window().resize(self.storeWidth-adjXDiff, self.storeHeight)\n            event.accept()\n        else:\n            self.offset = event.globalPos()-self.window().geometry().topLeft()\n            rs_size = 20\n            if ( ((abs(self.offset.x()) < rs_size) or\n                    (abs(self.offset.x()) > self.width()-rs_size) or\n                    (abs(self.offset.x()) < rs_size) or\n                    (abs(self.offset.x()) > self.width()-rs_size)or\n                    (abs(self.offset.y()) < rs_size) or\n                    (abs(self.offset.y()) <rs_size) or\n                    (abs(self.offset.y())> self.height()-rs_size) or\n                    (abs(self.offset.y())> self.height()-rs_size))\n                    and self.FrameEnabled):\n                # Upper left corner section\n                if ( (abs(self.offset.x()) < rs_size and abs(self.offset.y()) < rs_size)):\n                    self.setCursor(QtCore.Qt.SizeFDiagCursor)\n                # Upper right corner section\n                elif(abs(self.offset.x()) > self.width()-rs_size and abs(self.offset.y()) <rs_size):\n                    self.setCursor(QtCore.Qt.SizeBDiagCursor)\n                    self.Direction = ""D""\n                # Lower left corner section\n                elif(abs(self.offset.x()) < rs_size and abs(self.offset.y())> self.height()-rs_size):\n                    self.setCursor(QtCore.Qt.SizeBDiagCursor)\n                # Lower right corner section\n                elif(abs(self.offset.x()) > self.width()-rs_size and abs(self.offset.y())> self.height()-rs_size):\n                    self.setCursor(QtCore.Qt.SizeFDiagCursor)\n\n\n                # Upper Side\n                elif abs(self.offset.y()) < rs_size:\n                    self.setCursor(QtCore.Qt.SizeVerCursor)\n                # Lower side\n                elif abs(self.offset.y()) > self.height()-rs_size:\n                    self.setCursor(QtCore.Qt.SizeVerCursor)\n                # Right Side\n                elif abs(self.offset.x()) > self.width()-rs_size:\n                    self.setCursor(QtCore.Qt.SizeHorCursor)\n                # Left Side\n                elif abs(self.offset.x()) < rs_size:\n                    self.setCursor(QtCore.Qt.SizeHorCursor)\n                    \n            # In any move event if it is not in a resize region use the default cursor\n            else:\n                self.setCursor(QtCore.Qt.ArrowCursor)\n\n    def leaveEvent(self,event):\n        self.setCursor(QtCore.Qt.ArrowCursor)\n\nclass MMenuBar(QtWidgets.QMenuBar): # Moveable Menu Bar\n    def __init__(self, parent=None):\n        super(MMenuBar, self).__init__(parent)\n        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        self.moving = False\n        self.offset = 0\n        self.setMouseTracking(True)\n\n    def mousePressEvent(self,event):\n        if event.button() == QtCore.Qt.LeftButton and self.actionAt(event.pos())==None and self.moving == False and self.activeAction()==None:\n            self.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n            self.moving = True\n            self.offset = event.globalPos()-self.window().geometry().topLeft()\n            self.window().AWWF_CentralWidget.moving = False\n            event.accept()\n        else:\n            self.moving = False\n        super(MMenuBar, self).mousePressEvent(event)\n\n    def mouseReleaseEvent(self,event):\n        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        self.window().AWWF_CentralWidget.moving = False\n        if event.button() == QtCore.Qt.LeftButton and self.moving:\n            self.moving = False\n            pos = self.window().pos()\n            #if (pos.x() < 0):\n            #    pos.setX(0)\n            #    self.window().move(pos)\n            if (pos.y() < 0):\n                pos.setY(0)\n                self.window().move(pos)\n            # If the mouse is in a corner or on a side let the window fill this corner or side of the screen\n            try:\n                Tolerance = 5\n                eventPos = event.globalPos()\n                screenNumber = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())\n                screen = QtWidgets.QApplication.desktop().availableGeometry(screenNumber)\n                Half_X = (screen.bottomRight().x()-screen.topLeft().x())/2+1\n                Full_X = (screen.bottomRight().x()-screen.topLeft().x())+1\n                Half_Y = (screen.bottomRight().y()-screen.topLeft().y())/2+1\n                Full_Y = (screen.bottomRight().y()-screen.topLeft().y())+1\n                BottomMax = screen.bottomLeft().y()\n                RightMax = screen.bottomRight().x()\n                TopMax = screen.topLeft().y()\n                LeftMax = screen.topLeft().x()\n                #if (pos.y() > BottomMax): # If Bottom Side gets removed this must be turned on to make it impossible for the window to get lost behind the task bar\n                #    pos.setY(BottomMax-50)\n                #    self.window().move(pos)\n                # Top Left\n                if eventPos.x() <= Tolerance + LeftMax and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Left\n                elif eventPos.x() <= Tolerance + LeftMax and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n                # Top Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomRight(screen.bottomRight())\n                    self.window().move(frameGm.topLeft())\n                # Left Side\n                elif eventPos.x() <= Tolerance + LeftMax:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Right Side\n                elif eventPos.x() >= RightMax-Tolerance:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Top Side\n                elif eventPos.y() <= Tolerance + TopMax:\n                    if advancedMode():\n                        self.window().resize(Full_X, Half_Y)\n                        frameGm = self.window().frameGeometry()\n                        frameGm.moveTopRight(screen.topRight())\n                        self.window().move(frameGm.topLeft())\n                    else:\n                        self.window().showMaximized()\n                # Bottom Side\n                elif eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Full_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n            except common_exceptions:\n                NC(exc=sys.exc_info(),win=self.window().windowTitle(),func=""MMenuBar.mouseReleaseEvent"")\n        else:\n            self.moving = False\n            super(MMenuBar, self).mouseReleaseEvent(event)\n\n    def mouseMoveEvent(self,event):\n        if self.moving:\n            event.accept()\n            self.window().AWWF_CentralWidget.moving = False\n            if (self.window().isMaximized() or self.window().isFullScreen()): # If moving the window while in fullscreen or maximized make it normal first\n                try:\n                    self.window().TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                except common_exceptions:\n                    pass\n                corPos = self.window().geometry().topRight()\n                self.window().showNormal()\n                self.window().AWWF_CentralWidget.showFrame()\n                QtWidgets.QApplication.instance().processEvents()\n                self.window().move(corPos-self.window().geometry().topRight()+self.window().geometry().topLeft())\n                self.offset = event.globalPos()-self.window().geometry().topLeft()\n            self.window().move(event.globalPos()-self.offset)\n        else:\n            if self.actionAt(event.pos())!=None:\n                self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))\n            else:\n                self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n            super(MMenuBar, self).mouseMoveEvent(event)\n\nclass MTabWidget(QtWidgets.QTabWidget): # Moveable Tab Widget\n    def __init__(self, parent=None):\n        super(MTabWidget, self).__init__(parent)\n        #self.TabBar = MTabBar(self)\n        #self.setTabBar(self.TabBar)\n        ####self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n        self.tabBar().setUsesScrollButtons(True)\n        self.moving = False\n        self.offset = 0\n        self.setMouseTracking(True)\n\n    def mousePressEvent(self,event):\n        if event.button() == QtCore.Qt.LeftButton and self.moving == False and self.childAt(event.pos())==None:\n            event.accept()\n            self.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n            self.moving = True\n            self.offset = event.globalPos()-self.window().geometry().topLeft()\n            self.window().AWWF_CentralWidget.moving = False\n        else:\n            self.moving = False\n        super(MTabWidget, self).mousePressEvent(event)\n\n    def mouseReleaseEvent(self,event):\n        self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))\n        self.window().AWWF_CentralWidget.moving = False\n        if event.button() == QtCore.Qt.LeftButton and self.moving:\n            self.moving = False\n            pos = self.window().pos()\n            #if (pos.x() < 0):\n            #    pos.setX(0)\n            #    self.window().move(pos)\n            if (pos.y() < 0):\n                pos.setY(0)\n                self.window().move(pos)\n            # If the mouse is in a corner or on a side let the window fill this corner or side of the screen\n            try:\n                Tolerance = 5\n                eventPos = event.globalPos()\n                screenNumber = QtWidgets.QApplication.desktop().screenNumber(QtWidgets.QApplication.desktop().cursor().pos())\n                screen = QtWidgets.QApplication.desktop().availableGeometry(screenNumber)\n                Half_X = (screen.bottomRight().x()-screen.topLeft().x())/2+1\n                Full_X = (screen.bottomRight().x()-screen.topLeft().x())+1\n                Half_Y = (screen.bottomRight().y()-screen.topLeft().y())/2+1\n                Full_Y = (screen.bottomRight().y()-screen.topLeft().y())+1\n                BottomMax = screen.bottomLeft().y()\n                RightMax = screen.bottomRight().x()\n                TopMax = screen.topLeft().y()\n                LeftMax = screen.topLeft().x()\n                #if (pos.y() > BottomMax): # If Bottom Side gets removed this must be turned on to make it impossible for the window to get lost behind the task bar\n                #    pos.setY(BottomMax-50)\n                #    self.window().move(pos)\n                # Top Left\n                if eventPos.x() <= Tolerance + LeftMax and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Left\n                elif eventPos.x() <= Tolerance + LeftMax and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n                # Top Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() <= Tolerance + TopMax:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Bottom Right\n                elif eventPos.x() >= RightMax-Tolerance and eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Half_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomRight(screen.bottomRight())\n                    self.window().move(frameGm.topLeft())\n                # Left Side\n                elif eventPos.x() <= Tolerance + LeftMax:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopLeft(screen.topLeft())\n                    self.window().move(frameGm.topLeft())\n                # Right Side\n                elif eventPos.x() >= RightMax-Tolerance:\n                    self.window().resize(Half_X, Full_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveTopRight(screen.topRight())\n                    self.window().move(frameGm.topLeft())\n                # Top Side\n                elif eventPos.y() <= Tolerance + TopMax:\n                    if advancedMode():\n                        self.window().resize(Full_X, Half_Y)\n                        frameGm = self.window().frameGeometry()\n                        frameGm.moveTopRight(screen.topRight())\n                        self.window().move(frameGm.topLeft())\n                    else:\n                        self.window().showMaximized()\n                # Bottom Side\n                elif eventPos.y() >= BottomMax-Tolerance:\n                    self.window().resize(Full_X, Half_Y)\n                    frameGm = self.window().frameGeometry()\n                    frameGm.moveBottomLeft(screen.bottomLeft())\n                    self.window().move(frameGm.topLeft())\n            except common_exceptions:\n                NC(exc=sys.exc_info(),win=self.window().windowTitle(),func=""MTabWidget.mouseReleaseEvent"")\n        else:\n            self.moving = False\n            super(MTabWidget, self).mouseReleaseEvent(event)\n\n    def mouseMoveEvent(self,event): # Only registers if mouse is pressed...\n        if self.moving:\n            event.accept()\n            self.window().AWWF_CentralWidget.moving = False\n            if (self.window().isMaximized() or self.window().isFullScreen()): # If moving the window while in fullscreen or maximized make it normal first\n                try:\n                    self.window().TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n                except common_exceptions:\n                    pass\n                corPos = self.window().geometry().topRight()\n                self.window().showNormal()\n                self.window().AWWF_CentralWidget.showFrame()\n                QtWidgets.QApplication.instance().processEvents()\n                self.window().move(corPos-self.window().geometry().topRight()+self.window().geometry().topLeft())\n                self.offset = event.globalPos()-self.window().geometry().topLeft()\n            self.window().move(event.globalPos()-self.offset)\n        else:\n            #if self.childAt(event.pos())==None:\n            #    self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n            #else: # Does not work... Maybe all widgets need self.setMouseTracking(True) ?\n            #    self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))\n            super(MTabWidget, self).mouseMoveEvent(event)\n\n\n# class MTabBar(QtWidgets.QTabBar): # Moveable Tab Bar # Does not work since the TabBar is only the space of the tab names but not the free space next to the names...\n #    def __init__(self, parent=None):\n #        super(MTabBar, self).__init__(parent)\n #        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n #        self.moving = False\n #        self.setMouseTracking(True)\n #        self.offset = 0\n #\n #    def mousePressEvent(self,event):\n #        if event.button() == QtCore.Qt.LeftButton and self.tabAt(event.pos())==None and self.moving == False:\n #            self.setCursor(QtGui.QCursor(QtCore.Qt.ClosedHandCursor))\n #            self.moving = True\n #            self.offset = event.globalPos()-self.window().geometry().topLeft()\n #        else:\n #            self.moving = False\n #        super(MTabBar, self).mousePressEvent(event)\n #\n #    def mouseReleaseEvent(self,event):\n #        self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n #        if event.button() == QtCore.Qt.LeftButton and self.moving:\n #            self.moving = False\n #            pos = self.window().pos()\n #            #if (pos.x() < 0):\n #            #    pos.setX(0)\n #            #    self.window().move(pos)\n #            if (pos.y() < 0):\n #                pos.setY(0)\n #                self.window().move(pos)\n #        else:\n #            self.moving = False\n #            super(MTabBar, self).mouseReleaseEvent(event)\n #\n #    def mouseMoveEvent(self,event):\n #        if self.moving:\n #            self.window().move(event.globalPos()-self.offset)\n #        else:\n #            if self.tabAt(event.pos())!=None:\n #                self.setCursor(QtGui.QCursor(QtCore.Qt.ArrowCursor))\n #            else:\n #                self.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))\n #            super(MTabBar, self).mouseMoveEvent(event)\n\n\n#endregion\n\n\n#region Windows\n\nclass Notification_Window(AWWF):\n    def __init__(self,parent = None):\n        try:\n            super(Notification_Window, self).__init__(parent)\n            self.setWindowTitle(""Notifications"")\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_MessageBoxInformation))\n            \n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            \n            self.NotificationsWidget = NotificationsWidget(self)\n            self.NotificationsWidget.setObjectName(""NotificationsWidget"")\n            self.gridLayout.addWidget(self.NotificationsWidget, 0, 0)\n            \n            self.setCentralWidget(self.centralwidget)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            ExceptionOutput(sys.exc_info())\n\nclass exec_Window(AWWF):\n    def __init__(self,parent = None):\n        try:\n            super(exec_Window, self).__init__(parent, initTopBar=False)\n            self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True,IncludeAdvancedCB=True)\n            self.setWindowTitle(""Code Execution Window"")\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_ComputerIcon))\n                \n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            \n            self.Input_Field = TextEdit(self)\n            self.Input_Field.setObjectName(""Input_Field"")\n            self.Input_Field.setTabChangesFocus(False)\n            self.Input_Field.setText(""# If you have Spyder installed use this to activate the \'Spyder/Dark\' syntax highlighter:\\nself.highlight()"")\n            \n            self.gridLayout.addWidget(self.Input_Field, 0, 0, 0, 0)\n            self.gridLayout.setContentsMargins(0,0,0,0)\n            self.setCentralWidget(self.centralwidget)\n\n            self.Input_Field.returnCtrlPressed.connect(self.execute_code)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.windowTitle(),func=""exec_Window.__init__"")\n\n    def execute_code(self):\n        input_text = self.Input_Field.toPlainText()\n        try:\n            # Set app and window for the local dictionary so that they can be used in the execution\n            app = QtWidgets.QApplication.instance() # pylint: disable=unused-variable\n            window = QtWidgets.QApplication.instance().MainWindow # pylint: disable=unused-variable\n            exec(input_text)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.windowTitle(),func=""exec_Window.execute_code"",input=input_text)\n\n    def highlight(self):\n        try:\n            from spyder.utils.syntaxhighlighters import PythonSH\n            self.Input_Field_Highlighter = PythonSH(self.Input_Field.document(),color_scheme=\'Spyder/Dark\')\n        except:\n            pass\n\nclass Options_Window(AWWF):\n    def __init__(self,parent = None):\n        #REMINDER: Add more tabs with other option stuff...\n        try:\n            super(Options_Window, self).__init__(parent, initTopBar=False)\n            self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True,IncludeAdvancedCB=True)\n            self.setWindowTitle(""Options Window"")\n            self.standardSize = (900, 500)\n            self.resize(*self.standardSize)\n            self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_ComputerIcon))\n            \n            self.centralwidget = QtWidgets.QWidget(self)\n            self.centralwidget.setAutoFillBackground(True)\n            self.centralwidget.setObjectName(""centralwidget"")\n            self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n            self.gridLayout.setObjectName(""gridLayout"")\n            self.Input_Field = OptionsWidget_1_Appearance(self)\n            self.Input_Field.setObjectName(""Input_Field"")\n            \n            self.gridLayout.addWidget(self.Input_Field, 0, 0, 0, 0)\n            self.gridLayout.setContentsMargins(3,3,3,3)\n            self.setCentralWidget(self.centralwidget)\n            \n            self.setAutoFillBackground(True)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),win=self.windowTitle(),func=""exec_Window.__init__"")\n\n\n#endregion\n\n# TODO: Move this example to its own file and change the docu of the __init__ accordingly\n# ---------------------------------- Main Window ----------------------------------\nclass _AGe_Test_Window(AWWF):\n    def __init__(self, MainApp, parent = None):\n        super(_AGe_Test_Window, self).__init__(parent, initTopBar=False)\n        self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True)\n        self.MainApp = MainApp\n        self.MainApp.setMainWindow(self)\n        self.standardSize = (906, 634)\n        self.resize(*self.standardSize)\n        self.setWindowTitle(""AGe Test Window"")\n        self.setWindowIcon(QtWidgets.QApplication.style().standardIcon(QtWidgets.QStyle.SP_CommandLink))\n\n# ---------------------------------- Main ----------------------------------\n\nif __name__ == ""__main__"":\n    latex_installed, dvipng_installed = find_executable(\'latex\'), find_executable(\'dvipng\')\n    if latex_installed and dvipng_installed: print(""latex and dvipng are installed --> Using pretty LaTeX Display"")\n    elif latex_installed and not dvipng_installed: print(""latex is installed but dvipng was not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    elif not latex_installed and dvipng_installed: print(""dvipng is installed but latex was not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    else: print(""latex and dvipng were not detected --> Using standard LaTeX Display (Install both to use the pretty version)"")\n    print(""Test Window Startup"")\n    app = Main_App([])\n    app.setStyle(""fusion"")\n    window = _AGe_Test_Window(app)\n    app.setMainWindow(window)\n    print(datetime.datetime.now().strftime(\'%H:%M:%S:\'),""Test Window Started\\n"")\n    window.show()\n    sys.exit(app.exec())\n'"
AGeLib/__init__.py,0,"b'""""""\nAstus\' General Library  \\n\nThis library provides a prebuild QApplication (with standard options window (alt+O) and basic global shortcuts)\nand custom windows (including custom frames and a space efficient notification display) for PyQt5 applications. \\n\nUse Main_App instead of QtWidgets.QApplication and AWWF instead of QtWidgets.QMainWindow. \\n\nFor communication with the user and exception output use NC.\nNC is AGeLib\'s standard notification class and is especially useful for exception handling as it can create a full bug report. \\n\nImport the exc submodule to access all exception handling functions. \\n \\n\nIn addition to this AGeLib also provides several advanced widgets to provide a sophisticated alterernative to the barebone Qt base widgets. \\n\nAGeMain.py includes a basic example with a main function and a test window. \\n\nFor a more advanced example please visit https://github.com/AstusRush/AMaDiA .\\n\nAMaDiA was not only build to fully utilise most to all features of AGeLib but was also the origin of AGeLib: \\n\nAs AMaDiA\'s basic application grew it became apparent that it should be turned into a separate Library: AGeLib\n""""""\ntry:\n    from AGeLib.AGeMain import *\nexcept ModuleNotFoundError:\n    from AGeMain import *\ntry:\n    from AGeLib import exc\nexcept ModuleNotFoundError:\n    import exc\n__version__ = Version\n__all__ = [""Main_App"",\n           ""AWWF"",""common_exceptions"",\n           ""ExceptionOutput"",\n           ""NC"",\n           ""MplWidget"",\n           ""MplWidget_2D_Plot"",\n           ""MplWidget_LaTeX"",\n           ""ListWidget"",\n           ""NotificationInfoWidget"",\n           ""TextEdit"",\n           ""LineEdit"",\n           ""TableWidget"",\n           ""TableWidget_Delegate"",\n           ""TopBar_Widget"",\n           ""MenuAction"",\n           ""advancedMode"",\n           ""App""\n           ]'"
AGeLib/exc.py,0,"b'""""""\nAGeLib Exception Handling and Notifications\n""""""\ntry:\n    from AGeLib.AGeMain import NC,common_exceptions,ExceptionOutput\nexcept ModuleNotFoundError:\n    from AGeMain import NC,common_exceptions,ExceptionOutput'"
AMaDiA_Files/AMaDiAUI.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'AMaDiAUI.ui\'\n#\n# Created by: PyQt5 UI code generator 5.9.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_AMaDiA_Main_Window(object):\n    def setupUi(self, AMaDiA_Main_Window):\n        AMaDiA_Main_Window.setObjectName(""AMaDiA_Main_Window"")\n        AMaDiA_Main_Window.resize(906, 634)\n        AMaDiA_Main_Window.setAutoFillBackground(True)\n        self.centralwidget = QtWidgets.QWidget(AMaDiA_Main_Window)\n        self.centralwidget.setAutoFillBackground(True)\n        self.centralwidget.setObjectName(""centralwidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.tabWidget = MTabWidget(self.centralwidget)\n        self.tabWidget.setAutoFillBackground(True)\n        self.tabWidget.setUsesScrollButtons(False)\n        self.tabWidget.setObjectName(""tabWidget"")\n        self.Tab_1 = QtWidgets.QWidget()\n        self.Tab_1.setAutoFillBackground(True)\n        self.Tab_1.setObjectName(""Tab_1"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.Tab_1)\n        self.gridLayout_2.setContentsMargins(4, 4, 4, 4)\n        self.gridLayout_2.setSpacing(3)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.Tab_1_History = HistoryWidget(self.Tab_1)\n        self.Tab_1_History.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.Tab_1_History.setObjectName(""Tab_1_History"")\n        self.gridLayout_2.addWidget(self.Tab_1_History, 0, 0, 1, 1)\n        self.Tab_1_InputField = AMaDiA_LineEdit(self.Tab_1)\n        self.Tab_1_InputField.setObjectName(""Tab_1_InputField"")\n        self.gridLayout_2.addWidget(self.Tab_1_InputField, 1, 0, 1, 1)\n        self.tabWidget.addTab(self.Tab_1, """")\n        self.Tab_2 = QtWidgets.QWidget()\n        self.Tab_2.setAutoFillBackground(True)\n        self.Tab_2.setObjectName(""Tab_2"")\n        self.gridLayout_3 = QtWidgets.QGridLayout(self.Tab_2)\n        self.gridLayout_3.setContentsMargins(4, 4, 4, 4)\n        self.gridLayout_3.setSpacing(3)\n        self.gridLayout_3.setObjectName(""gridLayout_3"")\n        self.Tab_2_LowerSplitter = QtWidgets.QSplitter(self.Tab_2)\n        self.Tab_2_LowerSplitter.setOrientation(QtCore.Qt.Vertical)\n        self.Tab_2_LowerSplitter.setObjectName(""Tab_2_LowerSplitter"")\n        self.Tab_2_UpperSplitter = QtWidgets.QSplitter(self.Tab_2_LowerSplitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Preferred)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(20)\n        sizePolicy.setHeightForWidth(self.Tab_2_UpperSplitter.sizePolicy().hasHeightForWidth())\n        self.Tab_2_UpperSplitter.setSizePolicy(sizePolicy)\n        self.Tab_2_UpperSplitter.setOrientation(QtCore.Qt.Horizontal)\n        self.Tab_2_UpperSplitter.setObjectName(""Tab_2_UpperSplitter"")\n        self.Tab_2_History = HistoryWidget(self.Tab_2_UpperSplitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_2_History.sizePolicy().hasHeightForWidth())\n        self.Tab_2_History.setSizePolicy(sizePolicy)\n        self.Tab_2_History.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.Tab_2_History.setObjectName(""Tab_2_History"")\n        self.layoutWidget = QtWidgets.QWidget(self.Tab_2_UpperSplitter)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout_13 = QtWidgets.QGridLayout(self.layoutWidget)\n        self.gridLayout_13.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_13.setSpacing(0)\n        self.gridLayout_13.setObjectName(""gridLayout_13"")\n        self.Tab_2_LaTeXOutput = QtWidgets.QLineEdit(self.layoutWidget)\n        self.Tab_2_LaTeXOutput.setObjectName(""Tab_2_LaTeXOutput"")\n        self.gridLayout_13.addWidget(self.Tab_2_LaTeXOutput, 1, 0, 1, 1)\n        self.Tab_2_LaTeXCopyButton = QtWidgets.QPushButton(self.layoutWidget)\n        self.Tab_2_LaTeXCopyButton.setObjectName(""Tab_2_LaTeXCopyButton"")\n        self.gridLayout_13.addWidget(self.Tab_2_LaTeXCopyButton, 1, 1, 1, 1)\n        self.Tab_2_Viewer = MplWidget_LaTeX(self.layoutWidget)\n        self.Tab_2_Viewer.setObjectName(""Tab_2_Viewer"")\n        self.gridLayout_13.addWidget(self.Tab_2_Viewer, 0, 0, 1, 2)\n        self.Tab_2_InputField = AMaDiA_TextEdit(self.Tab_2_LowerSplitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_2_InputField.sizePolicy().hasHeightForWidth())\n        self.Tab_2_InputField.setSizePolicy(sizePolicy)\n        self.Tab_2_InputField.setObjectName(""Tab_2_InputField"")\n        self.gridLayout_3.addWidget(self.Tab_2_LowerSplitter, 0, 0, 1, 3)\n        self.Tab_2_ConvertButton = QtWidgets.QPushButton(self.Tab_2)\n        self.Tab_2_ConvertButton.setObjectName(""Tab_2_ConvertButton"")\n        self.gridLayout_3.addWidget(self.Tab_2_ConvertButton, 1, 2, 2, 1)\n        spacerItem = QtWidgets.QSpacerItem(780, 17, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout_3.addItem(spacerItem, 1, 0, 1, 1)\n        self.Tab_2_Eval_checkBox = QtWidgets.QCheckBox(self.Tab_2)\n        self.Tab_2_Eval_checkBox.setChecked(True)\n        self.Tab_2_Eval_checkBox.setTristate(True)\n        self.Tab_2_Eval_checkBox.setObjectName(""Tab_2_Eval_checkBox"")\n        self.gridLayout_3.addWidget(self.Tab_2_Eval_checkBox, 1, 1, 1, 1)\n        self.tabWidget.addTab(self.Tab_2, """")\n        self.Tab_3 = QtWidgets.QWidget()\n        self.Tab_3.setObjectName(""Tab_3"")\n        self.gridLayout_10 = QtWidgets.QGridLayout(self.Tab_3)\n        self.gridLayout_10.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_10.setSpacing(0)\n        self.gridLayout_10.setObjectName(""gridLayout_10"")\n        self.Tab_3_tabWidget = QtWidgets.QTabWidget(self.Tab_3)\n        self.Tab_3_tabWidget.setObjectName(""Tab_3_tabWidget"")\n        self.Tab_3_1 = QtWidgets.QWidget()\n        self.Tab_3_1.setObjectName(""Tab_3_1"")\n        self.gridLayout_12 = QtWidgets.QGridLayout(self.Tab_3_1)\n        self.gridLayout_12.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_12.setSpacing(0)\n        self.gridLayout_12.setObjectName(""gridLayout_12"")\n        self.Tab_3_1_gridLayout = QtWidgets.QGridLayout()\n        self.Tab_3_1_gridLayout.setContentsMargins(3, 0, 3, 3)\n        self.Tab_3_1_gridLayout.setSpacing(3)\n        self.Tab_3_1_gridLayout.setObjectName(""Tab_3_1_gridLayout"")\n        self.Tab_3_1_Button_Clear = QtWidgets.QPushButton(self.Tab_3_1)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_Button_Clear.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_Button_Clear.setSizePolicy(sizePolicy)\n        self.Tab_3_1_Button_Clear.setObjectName(""Tab_3_1_Button_Clear"")\n        self.Tab_3_1_gridLayout.addWidget(self.Tab_3_1_Button_Clear, 1, 1, 1, 1)\n        self.Tab_3_1_Formula_Field = AMaDiA_LineEdit(self.Tab_3_1)\n        self.Tab_3_1_Formula_Field.setObjectName(""Tab_3_1_Formula_Field"")\n        self.Tab_3_1_gridLayout.addWidget(self.Tab_3_1_Formula_Field, 1, 0, 1, 1)\n        self.Tab_3_1_Button_Plot = QtWidgets.QPushButton(self.Tab_3_1)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_Button_Plot.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_Button_Plot.setSizePolicy(sizePolicy)\n        self.Tab_3_1_Button_Plot.setObjectName(""Tab_3_1_Button_Plot"")\n        self.Tab_3_1_gridLayout.addWidget(self.Tab_3_1_Button_Plot, 1, 2, 1, 1)\n        self.Tab_3_1_splitter = QtWidgets.QSplitter(self.Tab_3_1)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_splitter.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_splitter.setSizePolicy(sizePolicy)\n        self.Tab_3_1_splitter.setOrientation(QtCore.Qt.Horizontal)\n        self.Tab_3_1_splitter.setObjectName(""Tab_3_1_splitter"")\n        self.layoutWidget1 = QtWidgets.QWidget(self.Tab_3_1_splitter)\n        self.layoutWidget1.setObjectName(""layoutWidget1"")\n        self.Tab_3_1_gridLayout_upper = QtWidgets.QGridLayout(self.layoutWidget1)\n        self.Tab_3_1_gridLayout_upper.setContentsMargins(0, 0, 0, 0)\n        self.Tab_3_1_gridLayout_upper.setObjectName(""Tab_3_1_gridLayout_upper"")\n        self.Tab_3_1_TabWidget = QtWidgets.QTabWidget(self.layoutWidget1)\n        self.Tab_3_1_TabWidget.setObjectName(""Tab_3_1_TabWidget"")\n        self.Tab_3_1_tab_1_History = QtWidgets.QWidget()\n        self.Tab_3_1_tab_1_History.setObjectName(""Tab_3_1_tab_1_History"")\n        self.gridLayout_5 = QtWidgets.QGridLayout(self.Tab_3_1_tab_1_History)\n        self.gridLayout_5.setContentsMargins(3, 3, 3, 3)\n        self.gridLayout_5.setSpacing(0)\n        self.gridLayout_5.setObjectName(""gridLayout_5"")\n        self.Tab_3_1_History = HistoryWidget(self.Tab_3_1_tab_1_History)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_History.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_History.setSizePolicy(sizePolicy)\n        self.Tab_3_1_History.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.Tab_3_1_History.setObjectName(""Tab_3_1_History"")\n        self.gridLayout_5.addWidget(self.Tab_3_1_History, 0, 0, 1, 1)\n        self.Tab_3_1_TabWidget.addTab(self.Tab_3_1_tab_1_History, """")\n        self.Tab_3_1_tab_2_Config = QtWidgets.QWidget()\n        self.Tab_3_1_tab_2_Config.setObjectName(""Tab_3_1_tab_2_Config"")\n        self.gridLayout_8 = QtWidgets.QGridLayout(self.Tab_3_1_tab_2_Config)\n        self.gridLayout_8.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_8.setSpacing(0)\n        self.gridLayout_8.setObjectName(""gridLayout_8"")\n        self.Tab_3_1_tab_2_Config_scrollArea = QtWidgets.QScrollArea(self.Tab_3_1_tab_2_Config)\n        self.Tab_3_1_tab_2_Config_scrollArea.setWidgetResizable(True)\n        self.Tab_3_1_tab_2_Config_scrollArea.setObjectName(""Tab_3_1_tab_2_Config_scrollArea"")\n        self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents = QtWidgets.QWidget()\n        self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 260, 311))\n        self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents.setObjectName(""Tab_3_1_tab_2_Config_scrollAreaWidgetContents"")\n        self.gridLayout_11 = QtWidgets.QGridLayout(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.gridLayout_11.setContentsMargins(4, 4, 4, 4)\n        self.gridLayout_11.setSpacing(3)\n        self.gridLayout_11.setObjectName(""gridLayout_11"")\n        self.Tab_3_1_YLim_Check = QtWidgets.QCheckBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_YLim_Check.setObjectName(""Tab_3_1_YLim_Check"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_YLim_Check, 8, 0, 1, 1)\n        self.Tab_3_1_XLim_max = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_XLim_max.setDecimals(5)\n        self.Tab_3_1_XLim_max.setMinimum(-1000000.0)\n        self.Tab_3_1_XLim_max.setMaximum(1000000.0)\n        self.Tab_3_1_XLim_max.setProperty(""value"", 5.0)\n        self.Tab_3_1_XLim_max.setObjectName(""Tab_3_1_XLim_max"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_XLim_max, 7, 1, 1, 1)\n        self.Tab_3_1_XLim_min = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_XLim_min.setDecimals(5)\n        self.Tab_3_1_XLim_min.setMinimum(-1000000.0)\n        self.Tab_3_1_XLim_min.setMaximum(1000000.0)\n        self.Tab_3_1_XLim_min.setProperty(""value"", -5.0)\n        self.Tab_3_1_XLim_min.setObjectName(""Tab_3_1_XLim_min"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_XLim_min, 7, 0, 1, 1)\n        self.line_2 = QtWidgets.QFrame(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_2.setObjectName(""line_2"")\n        self.gridLayout_11.addWidget(self.line_2, 4, 0, 1, 2)\n        self.Tab_3_1_Axis_ratio_Checkbox = QtWidgets.QCheckBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Axis_ratio_Checkbox.setObjectName(""Tab_3_1_Axis_ratio_Checkbox"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Axis_ratio_Checkbox, 5, 1, 1, 1)\n        self.Tab_3_1_To_Spinbox = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_To_Spinbox.setDecimals(5)\n        self.Tab_3_1_To_Spinbox.setMinimum(-1000000.0)\n        self.Tab_3_1_To_Spinbox.setMaximum(1000000.0)\n        self.Tab_3_1_To_Spinbox.setProperty(""value"", 10.0)\n        self.Tab_3_1_To_Spinbox.setObjectName(""Tab_3_1_To_Spinbox"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_To_Spinbox, 1, 1, 1, 1)\n        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        self.gridLayout_11.addItem(spacerItem1, 12, 0, 1, 2)\n        self.Tab_3_1_Points_comboBox = QtWidgets.QComboBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Points_comboBox.setObjectName(""Tab_3_1_Points_comboBox"")\n        self.Tab_3_1_Points_comboBox.addItem("""")\n        self.Tab_3_1_Points_comboBox.addItem("""")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Points_comboBox, 2, 0, 1, 1)\n        self.Tab_3_1_YLim_max = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_YLim_max.setDecimals(5)\n        self.Tab_3_1_YLim_max.setMinimum(-1000000.0)\n        self.Tab_3_1_YLim_max.setMaximum(1000000.0)\n        self.Tab_3_1_YLim_max.setProperty(""value"", 50.0)\n        self.Tab_3_1_YLim_max.setObjectName(""Tab_3_1_YLim_max"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_YLim_max, 9, 1, 1, 1)\n        self.Tab_3_1_From_Spinbox = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_From_Spinbox.setDecimals(5)\n        self.Tab_3_1_From_Spinbox.setMinimum(-1000000.0)\n        self.Tab_3_1_From_Spinbox.setMaximum(1000000.0)\n        self.Tab_3_1_From_Spinbox.setProperty(""value"", -10.0)\n        self.Tab_3_1_From_Spinbox.setObjectName(""Tab_3_1_From_Spinbox"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_From_Spinbox, 0, 1, 1, 1)\n        self.Tab_3_1_Label_from = QtWidgets.QLabel(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Label_from.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.Tab_3_1_Label_from.setObjectName(""Tab_3_1_Label_from"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Label_from, 0, 0, 1, 1)\n        self.Tab_3_1_XLim_Check = QtWidgets.QCheckBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_XLim_Check.setObjectName(""Tab_3_1_XLim_Check"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_XLim_Check, 6, 0, 1, 1)\n        self.line = QtWidgets.QFrame(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.line.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line.setObjectName(""line"")\n        self.gridLayout_11.addWidget(self.line, 11, 0, 1, 2)\n        self.Tab_3_1_YLim_min = QtWidgets.QDoubleSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_YLim_min.setDecimals(5)\n        self.Tab_3_1_YLim_min.setMinimum(-1000000.0)\n        self.Tab_3_1_YLim_min.setMaximum(1000000.0)\n        self.Tab_3_1_YLim_min.setProperty(""value"", -25.0)\n        self.Tab_3_1_YLim_min.setObjectName(""Tab_3_1_YLim_min"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_YLim_min, 9, 0, 1, 1)\n        self.Tab_3_1_Draw_Grid_Checkbox = QtWidgets.QCheckBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Draw_Grid_Checkbox.setChecked(True)\n        self.Tab_3_1_Draw_Grid_Checkbox.setObjectName(""Tab_3_1_Draw_Grid_Checkbox"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Draw_Grid_Checkbox, 5, 0, 1, 1)\n        self.Tab_3_1_Points_Spinbox = QtWidgets.QSpinBox(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Points_Spinbox.setMinimum(2)\n        self.Tab_3_1_Points_Spinbox.setMaximum(100000)\n        self.Tab_3_1_Points_Spinbox.setProperty(""value"", 1000)\n        self.Tab_3_1_Points_Spinbox.setObjectName(""Tab_3_1_Points_Spinbox"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Points_Spinbox, 2, 1, 1, 1)\n        self.Tab_3_1_Label_to = QtWidgets.QLabel(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Label_to.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)\n        self.Tab_3_1_Label_to.setObjectName(""Tab_3_1_Label_to"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Label_to, 1, 0, 1, 1)\n        self.Tab_3_1_Button_Plot_SymPy = QtWidgets.QPushButton(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Button_Plot_SymPy.setObjectName(""Tab_3_1_Button_Plot_SymPy"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Button_Plot_SymPy, 13, 1, 1, 1)\n        self.Tab_3_1_RedrawPlot_Button = QtWidgets.QPushButton(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_RedrawPlot_Button.setObjectName(""Tab_3_1_RedrawPlot_Button"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_RedrawPlot_Button, 10, 0, 1, 2)\n        self.Tab_3_1_Button_SavePlot = QtWidgets.QPushButton(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.Tab_3_1_Button_SavePlot.setObjectName(""Tab_3_1_Button_SavePlot"")\n        self.gridLayout_11.addWidget(self.Tab_3_1_Button_SavePlot, 13, 0, 1, 1)\n        self.Tab_3_1_tab_2_Config_scrollArea.setWidget(self.Tab_3_1_tab_2_Config_scrollAreaWidgetContents)\n        self.gridLayout_8.addWidget(self.Tab_3_1_tab_2_Config_scrollArea, 12, 0, 1, 1)\n        self.Tab_3_1_TabWidget.addTab(self.Tab_3_1_tab_2_Config, """")\n        self.Tab_3_1_gridLayout_upper.addWidget(self.Tab_3_1_TabWidget, 0, 2, 1, 1)\n        self.Tab_3_1_ScrollArea = QtWidgets.QScrollArea(self.Tab_3_1_splitter)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)\n        sizePolicy.setHorizontalStretch(5)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_ScrollArea.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_ScrollArea.setSizePolicy(sizePolicy)\n        self.Tab_3_1_ScrollArea.setSizeAdjustPolicy(QtWidgets.QAbstractScrollArea.AdjustToContents)\n        self.Tab_3_1_ScrollArea.setWidgetResizable(True)\n        self.Tab_3_1_ScrollArea.setObjectName(""Tab_3_1_ScrollArea"")\n        self.Tab_3_1_ScrollArea_Layout = QtWidgets.QWidget()\n        self.Tab_3_1_ScrollArea_Layout.setGeometry(QtCore.QRect(0, 0, 618, 340))\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_ScrollArea_Layout.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_ScrollArea_Layout.setSizePolicy(sizePolicy)\n        self.Tab_3_1_ScrollArea_Layout.setObjectName(""Tab_3_1_ScrollArea_Layout"")\n        self.gridLayout_6 = QtWidgets.QGridLayout(self.Tab_3_1_ScrollArea_Layout)\n        self.gridLayout_6.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_6.setSpacing(0)\n        self.gridLayout_6.setObjectName(""gridLayout_6"")\n        self.Tab_3_1_Display = MplWidget_2D_Plot(self.Tab_3_1_ScrollArea_Layout)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.Tab_3_1_Display.sizePolicy().hasHeightForWidth())\n        self.Tab_3_1_Display.setSizePolicy(sizePolicy)\n        self.Tab_3_1_Display.setObjectName(""Tab_3_1_Display"")\n        self.gridLayout_6.addWidget(self.Tab_3_1_Display, 0, 0, 1, 1)\n        self.Tab_3_1_ScrollArea.setWidget(self.Tab_3_1_ScrollArea_Layout)\n        self.Tab_3_1_gridLayout.addWidget(self.Tab_3_1_splitter, 0, 0, 1, 3)\n        self.gridLayout_12.addLayout(self.Tab_3_1_gridLayout, 0, 0, 1, 1)\n        self.Tab_3_tabWidget.addTab(self.Tab_3_1, """")\n        self.Tab_3_2 = QtWidgets.QWidget()\n        self.Tab_3_2.setObjectName(""Tab_3_2"")\n        self.Tab_3_tabWidget.addTab(self.Tab_3_2, """")\n        self.gridLayout_10.addWidget(self.Tab_3_tabWidget, 0, 0, 1, 1)\n        self.tabWidget.addTab(self.Tab_3, """")\n        self.Tab_4 = QtWidgets.QWidget()\n        self.Tab_4.setObjectName(""Tab_4"")\n        self.gridLayout_7 = QtWidgets.QGridLayout(self.Tab_4)\n        self.gridLayout_7.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_7.setSpacing(0)\n        self.gridLayout_7.setObjectName(""gridLayout_7"")\n        self.Tab_4_Splitter_Main = QtWidgets.QSplitter(self.Tab_4)\n        self.Tab_4_Splitter_Main.setOrientation(QtCore.Qt.Horizontal)\n        self.Tab_4_Splitter_Main.setObjectName(""Tab_4_Splitter_Main"")\n        self.Tab_4_Splitter_Left = QtWidgets.QSplitter(self.Tab_4_Splitter_Main)\n        self.Tab_4_Splitter_Left.setOrientation(QtCore.Qt.Vertical)\n        self.Tab_4_Splitter_Left.setObjectName(""Tab_4_Splitter_Left"")\n        self.Tab_4_tabWidget = QtWidgets.QTabWidget(self.Tab_4_Splitter_Left)\n        self.Tab_4_tabWidget.setObjectName(""Tab_4_tabWidget"")\n        self.Tab_4_tab_1 = QtWidgets.QWidget()\n        self.Tab_4_tab_1.setObjectName(""Tab_4_tab_1"")\n        self.gridLayout_9 = QtWidgets.QGridLayout(self.Tab_4_tab_1)\n        self.gridLayout_9.setContentsMargins(4, 0, 0, 4)\n        self.gridLayout_9.setSpacing(3)\n        self.gridLayout_9.setObjectName(""gridLayout_9"")\n        self.Tab_4_1_Dimension_Input = QtWidgets.QLineEdit(self.Tab_4_tab_1)\n        self.Tab_4_1_Dimension_Input.setMaxLength(5)\n        self.Tab_4_1_Dimension_Input.setCursorPosition(0)\n        self.Tab_4_1_Dimension_Input.setObjectName(""Tab_4_1_Dimension_Input"")\n        self.gridLayout_9.addWidget(self.Tab_4_1_Dimension_Input, 1, 0, 1, 1)\n        self.Tab_4_1_Matrix_Input = AMaDiA_TableWidget(self.Tab_4_tab_1)\n        self.Tab_4_1_Matrix_Input.setRowCount(3)\n        self.Tab_4_1_Matrix_Input.setColumnCount(3)\n        self.Tab_4_1_Matrix_Input.setObjectName(""Tab_4_1_Matrix_Input"")\n        self.Tab_4_1_Matrix_Input.horizontalHeader().setDefaultSectionSize(75)\n        self.gridLayout_9.addWidget(self.Tab_4_1_Matrix_Input, 0, 0, 1, 4)\n        self.Tab_4_1_Save_Matrix_Button = QtWidgets.QPushButton(self.Tab_4_tab_1)\n        self.Tab_4_1_Save_Matrix_Button.setObjectName(""Tab_4_1_Save_Matrix_Button"")\n        self.gridLayout_9.addWidget(self.Tab_4_1_Save_Matrix_Button, 1, 3, 1, 1)\n        self.Tab_4_1_Configure_Button = QtWidgets.QPushButton(self.Tab_4_tab_1)\n        self.Tab_4_1_Configure_Button.setObjectName(""Tab_4_1_Configure_Button"")\n        self.gridLayout_9.addWidget(self.Tab_4_1_Configure_Button, 1, 1, 1, 1)\n        self.Tab_4_1_Name_Input = QtWidgets.QLineEdit(self.Tab_4_tab_1)\n        self.Tab_4_1_Name_Input.setObjectName(""Tab_4_1_Name_Input"")\n        self.gridLayout_9.addWidget(self.Tab_4_1_Name_Input, 1, 2, 1, 1)\n        self.Tab_4_tabWidget.addTab(self.Tab_4_tab_1, """")\n        self.Tab_4_tab_2 = QtWidgets.QWidget()\n        self.Tab_4_tab_2.setObjectName(""Tab_4_tab_2"")\n        self.gridLayout_4 = QtWidgets.QGridLayout(self.Tab_4_tab_2)\n        self.gridLayout_4.setContentsMargins(4, 4, 4, 4)\n        self.gridLayout_4.setSpacing(3)\n        self.gridLayout_4.setObjectName(""gridLayout_4"")\n        self.Tab_4_2_New_Equation_Button = QtWidgets.QPushButton(self.Tab_4_tab_2)\n        self.Tab_4_2_New_Equation_Button.setObjectName(""Tab_4_2_New_Equation_Button"")\n        self.gridLayout_4.addWidget(self.Tab_4_2_New_Equation_Button, 1, 3, 1, 1)\n        self.Tab_4_History = HistoryWidget(self.Tab_4_tab_2)\n        self.Tab_4_History.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.Tab_4_History.setObjectName(""Tab_4_History"")\n        self.gridLayout_4.addWidget(self.Tab_4_History, 0, 0, 1, 4)\n        self.Tab_4_2_Load_Selected_Button = QtWidgets.QPushButton(self.Tab_4_tab_2)\n        self.Tab_4_2_Load_Selected_Button.setObjectName(""Tab_4_2_Load_Selected_Button"")\n        self.gridLayout_4.addWidget(self.Tab_4_2_Load_Selected_Button, 1, 2, 1, 1)\n        self.Tab_4_2_New_Equation_Name_Input = QtWidgets.QLineEdit(self.Tab_4_tab_2)\n        self.Tab_4_2_New_Equation_Name_Input.setObjectName(""Tab_4_2_New_Equation_Name_Input"")\n        self.gridLayout_4.addWidget(self.Tab_4_2_New_Equation_Name_Input, 1, 1, 1, 1)\n        self.Tab_4_tabWidget.addTab(self.Tab_4_tab_2, """")\n        self.Tab_4_Matrix_List = ListWidget(self.Tab_4_Splitter_Left)\n        self.Tab_4_Matrix_List.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)\n        self.Tab_4_Matrix_List.setObjectName(""Tab_4_Matrix_List"")\n        self.Tab_4_Splitter_Right = QtWidgets.QSplitter(self.Tab_4_Splitter_Main)\n        self.Tab_4_Splitter_Right.setOrientation(QtCore.Qt.Vertical)\n        self.Tab_4_Splitter_Right.setObjectName(""Tab_4_Splitter_Right"")\n        self.layoutWidget2 = QtWidgets.QWidget(self.Tab_4_Splitter_Right)\n        self.layoutWidget2.setObjectName(""layoutWidget2"")\n        self.Tab_4_Display_gridLayout = QtWidgets.QGridLayout(self.layoutWidget2)\n        self.Tab_4_Display_gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.Tab_4_Display_gridLayout.setSpacing(0)\n        self.Tab_4_Display_gridLayout.setObjectName(""Tab_4_Display_gridLayout"")\n        self.Tab_4_Display = MplWidget_LaTeX(self.layoutWidget2)\n        self.Tab_4_Display.setObjectName(""Tab_4_Display"")\n        self.Tab_4_Display_gridLayout.addWidget(self.Tab_4_Display, 0, 0, 1, 1)\n        self.Tab_4_FormulaInput = AMaDiA_LineEdit(self.layoutWidget2)\n        self.Tab_4_FormulaInput.setObjectName(""Tab_4_FormulaInput"")\n        self.Tab_4_Display_gridLayout.addWidget(self.Tab_4_FormulaInput, 1, 0, 1, 1)\n        self.Tab_4_DirectInput = AMaDiA_TextEdit(self.Tab_4_Splitter_Right)\n        self.Tab_4_DirectInput.setObjectName(""Tab_4_DirectInput"")\n        self.gridLayout_7.addWidget(self.Tab_4_Splitter_Main, 0, 0, 1, 1)\n        self.tabWidget.addTab(self.Tab_4, """")\n        self.gridLayout.addWidget(self.tabWidget, 0, 0, 1, 2)\n        AMaDiA_Main_Window.setCentralWidget(self.centralwidget)\n\n        self.retranslateUi(AMaDiA_Main_Window)\n        self.tabWidget.setCurrentIndex(0)\n        self.Tab_3_tabWidget.setCurrentIndex(0)\n        self.Tab_3_1_TabWidget.setCurrentIndex(0)\n        self.Tab_3_1_Points_comboBox.setCurrentIndex(0)\n        self.Tab_4_tabWidget.setCurrentIndex(0)\n        QtCore.QMetaObject.connectSlotsByName(AMaDiA_Main_Window)\n        AMaDiA_Main_Window.setTabOrder(self.tabWidget, self.Tab_1_History)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_1_History, self.Tab_1_InputField)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_1_InputField, self.Tab_2_InputField)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_2_InputField, self.Tab_2_ConvertButton)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_2_ConvertButton, self.Tab_2_LaTeXOutput)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_2_LaTeXOutput, self.Tab_2_History)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_2_History, self.Tab_3_1_ScrollArea)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_ScrollArea, self.Tab_3_1_TabWidget)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_TabWidget, self.Tab_3_1_History)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_History, self.Tab_3_1_tab_2_Config_scrollArea)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_tab_2_Config_scrollArea, self.Tab_3_1_From_Spinbox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_From_Spinbox, self.Tab_3_1_To_Spinbox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_To_Spinbox, self.Tab_3_1_Points_comboBox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_Points_comboBox, self.Tab_3_1_Points_Spinbox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_Points_Spinbox, self.Tab_3_1_Draw_Grid_Checkbox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_Draw_Grid_Checkbox, self.Tab_3_1_Axis_ratio_Checkbox)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_Axis_ratio_Checkbox, self.Tab_3_1_XLim_Check)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_XLim_Check, self.Tab_3_1_XLim_min)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_XLim_min, self.Tab_3_1_XLim_max)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_XLim_max, self.Tab_3_1_YLim_Check)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_YLim_Check, self.Tab_3_1_YLim_min)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_YLim_min, self.Tab_3_1_YLim_max)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_YLim_max, self.Tab_3_1_RedrawPlot_Button)\n        AMaDiA_Main_Window.setTabOrder(self.Tab_3_1_RedrawPlot_Button, self.Tab_3_1_Button_Plot_SymPy)\n\n    def retranslateUi(self, AMaDiA_Main_Window):\n        _translate = QtCore.QCoreApplication.translate\n        AMaDiA_Main_Window.setWindowTitle(_translate(""AMaDiA_Main_Window"", ""AMaDiA""))\n        self.Tab_1_InputField.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""Enter something and hit return to calculate. Use ctrl+return to not solve divisions, roots, etc.""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Tab_1), _translate(""AMaDiA_Main_Window"", ""Calculator""))\n        self.Tab_2_LaTeXOutput.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>This is only a preview! All linebreaks are removed!</p><p>Rightklick on the <span style=\\"" text-decoration: underline;\\"">formula</span> in the display above or cklick the button to the right to copy the LaTeX!</p></body></html>""))\n        self.Tab_2_LaTeXCopyButton.setText(_translate(""AMaDiA_Main_Window"", ""Copy LaTeX""))\n        self.Tab_2_InputField.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""Add Mathematical Expression to be Converted to LaTeX. Use ctrl+return or the Convert button to display. Please give Feedback if return should convert and shift+return adds a new line instead!""))\n        self.Tab_2_ConvertButton.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>Shortcut: ctrl+return while having the Input field selected</p></body></html>""))\n        self.Tab_2_ConvertButton.setText(_translate(""AMaDiA_Main_Window"", ""Convert""))\n        self.Tab_2_Eval_checkBox.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>Evaluate Function:<br/>Controls if functions in the input should be evaluated.<br/>If unchecked some things (like Derivatives) might look weird.<br/>If half-checked only basic functions will be evaluated and only if they return integers<br/>If checked most things will be evaluated</p><p>Example:<br/>Input: sin(pi)<br/>Output if half-checked: 0<br/>Output if unchecked: sin(pi)</p><p>Input: exp(ln(x))<br/>Output if half-checked: x<br/>Output if unchecked: exp(ln(x))</p></body></html>""))\n        self.Tab_2_Eval_checkBox.setText(_translate(""AMaDiA_Main_Window"", ""Eval""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Tab_2), _translate(""AMaDiA_Main_Window"", ""LaTeX""))\n        self.Tab_3_1_Button_Clear.setText(_translate(""AMaDiA_Main_Window"", ""Clear""))\n        self.Tab_3_1_Formula_Field.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""Enter a function f(x) (eg. \\""x^2\\"") or a constant (eg. \\""23+4\\"" for a horizontal line or \\""x=23+4\\"" for a vertical line at 27) and hit return.""))\n        self.Tab_3_1_Button_Plot.setText(_translate(""AMaDiA_Main_Window"", ""Plot""))\n        self.Tab_3_1_TabWidget.setTabText(self.Tab_3_1_TabWidget.indexOf(self.Tab_3_1_tab_1_History), _translate(""AMaDiA_Main_Window"", ""History""))\n        self.Tab_3_1_YLim_Check.setToolTip(_translate(""AMaDiA_Main_Window"", ""Limit the part of the y axis that is shown""))\n        self.Tab_3_1_YLim_Check.setText(_translate(""AMaDiA_Main_Window"", ""Limit Y""))\n        self.Tab_3_1_Axis_ratio_Checkbox.setText(_translate(""AMaDiA_Main_Window"", ""1:1 axis ratio""))\n        self.Tab_3_1_Points_comboBox.setCurrentText(_translate(""AMaDiA_Main_Window"", ""Points total""))\n        self.Tab_3_1_Points_comboBox.setItemText(0, _translate(""AMaDiA_Main_Window"", ""Points total""))\n        self.Tab_3_1_Points_comboBox.setItemText(1, _translate(""AMaDiA_Main_Window"", ""Points per Unit""))\n        self.Tab_3_1_Label_from.setText(_translate(""AMaDiA_Main_Window"", ""From""))\n        self.Tab_3_1_XLim_Check.setToolTip(_translate(""AMaDiA_Main_Window"", ""Limit the part of the x axis that is shown""))\n        self.Tab_3_1_XLim_Check.setText(_translate(""AMaDiA_Main_Window"", ""Limit X""))\n        self.Tab_3_1_Draw_Grid_Checkbox.setText(_translate(""AMaDiA_Main_Window"", ""Draw Grid""))\n        self.Tab_3_1_Label_to.setText(_translate(""AMaDiA_Main_Window"", ""To""))\n        self.Tab_3_1_Button_Plot_SymPy.setToolTip(_translate(""AMaDiA_Main_Window"", ""<!DOCTYPE HTML PUBLIC \\""-//W3C//DTD HTML 4.0//EN\\"" \\""http://www.w3.org/TR/REC-html40/strict.dtd\\"">\\n""\n""<html><head><meta name=\\""qrichtext\\"" content=\\""1\\"" /><style type=\\""text/css\\"">\\n""\n""p, li { white-space: pre-wrap; }\\n""\n""</style></head><body style=\\"" font-family:\\\'MS Shell Dlg 2\\\'; font-size:8pt; font-weight:400; font-style:normal;\\"">\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">It is advised to use the normal Plot.</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">Note:</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- Control the Plotted area with Limit X and Limit Y</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">    (Don\\\'t forget to enable these with the checkboxes)</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- Opens new window</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">Advantages of SymPy Plotting:</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- Easier zomming</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- More options when saving the Plot</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">Disadvantages:</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- Plots are not saved in the History</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- (Currently) Only one graph per plot</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- (Currently) Limited configuration via the main window</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">- Can not plot as many functions as the main plotter</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">  (The main plotter has several methods of plotting which are used</span></p>\\n""\n""<p style=\\"" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\\""><span style=\\"" font-family:\\\'MS Shell Dlg 2\\\';\\"">   if the normal method fails while the SymPy plotter only has the normal method)</span></p>\\n""\n""<p style=\\""-qt-paragraph-type:empty; margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px; font-family:\\\'MS Shell Dlg 2\\\';\\""><br /></p></body></html>""))\n        self.Tab_3_1_Button_Plot_SymPy.setText(_translate(""AMaDiA_Main_Window"", ""Plot with SymPy""))\n        self.Tab_3_1_RedrawPlot_Button.setToolTip(_translate(""AMaDiA_Main_Window"", ""Apply settings""))\n        self.Tab_3_1_RedrawPlot_Button.setText(_translate(""AMaDiA_Main_Window"", ""Redraw Plot""))\n        self.Tab_3_1_Button_SavePlot.setToolTip(_translate(""AMaDiA_Main_Window"", ""<html><head/><body><p>Save the current Plot (exactly as displayed including size and resoltuion)</p><p>as a .png in the Plots folder where the AMaDiA.py is located.</p><p>Tip: This option is also accessible in the right klick menu of the Plot.</p></body></html>""))\n        self.Tab_3_1_Button_SavePlot.setText(_translate(""AMaDiA_Main_Window"", ""Save Plot""))\n        self.Tab_3_1_TabWidget.setTabText(self.Tab_3_1_TabWidget.indexOf(self.Tab_3_1_tab_2_Config), _translate(""AMaDiA_Main_Window"", ""Config""))\n        self.Tab_3_tabWidget.setTabText(self.Tab_3_tabWidget.indexOf(self.Tab_3_1), _translate(""AMaDiA_Main_Window"", ""2D""))\n        self.Tab_3_tabWidget.setTabText(self.Tab_3_tabWidget.indexOf(self.Tab_3_2), _translate(""AMaDiA_Main_Window"", ""WIP""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Tab_3), _translate(""AMaDiA_Main_Window"", ""Plotter""))\n        self.Tab_4_1_Dimension_Input.setInputMask(_translate(""AMaDiA_Main_Window"", ""00\\\\xD0""))\n        self.Tab_4_1_Dimension_Input.setText(_translate(""AMaDiA_Main_Window"", ""3x3""))\n        self.Tab_4_1_Save_Matrix_Button.setText(_translate(""AMaDiA_Main_Window"", ""Save""))\n        self.Tab_4_1_Configure_Button.setText(_translate(""AMaDiA_Main_Window"", ""Configure""))\n        self.Tab_4_1_Name_Input.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""Name""))\n        self.Tab_4_tabWidget.setTabText(self.Tab_4_tabWidget.indexOf(self.Tab_4_tab_1), _translate(""AMaDiA_Main_Window"", ""Matrix Input""))\n        self.Tab_4_2_New_Equation_Button.setText(_translate(""AMaDiA_Main_Window"", ""New Equation""))\n        self.Tab_4_2_Load_Selected_Button.setText(_translate(""AMaDiA_Main_Window"", ""Load Selected""))\n        self.Tab_4_2_New_Equation_Name_Input.setToolTip(_translate(""AMaDiA_Main_Window"", ""Enter the equation name""))\n        self.Tab_4_2_New_Equation_Name_Input.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""Enter the equation name""))\n        self.Tab_4_tabWidget.setTabText(self.Tab_4_tabWidget.indexOf(self.Tab_4_tab_2), _translate(""AMaDiA_Main_Window"", ""History""))\n        self.Tab_4_FormulaInput.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""WIP: Input a formula (using the names of the matrices) and hit return""))\n        self.Tab_4_DirectInput.setPlaceholderText(_translate(""AMaDiA_Main_Window"", ""WIP: This Widget has currently no function and is a placholder...""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.Tab_4), _translate(""AMaDiA_Main_Window"", ""Multi-Dim""))\n\nfrom AGeLib.AGeMain import ListWidget, MTabWidget, MplWidget_2D_Plot, MplWidget_LaTeX\nfrom AMaDiA_Files.AMaDiA_Widgets import AMaDiA_LineEdit, AMaDiA_TableWidget, AMaDiA_TextEdit, HistoryWidget\n'"
AMaDiA_Files/AMaDiA_Classes.py,17,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Sep  4 14:55:31 2019\n\n@author: Robin\n""""""\n\n# if__name__ == ""__main__"":\n#     pass\n\nfrom AGeLib.exc import *\n\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5 import QtWidgets,QtCore,QtGui # Maybe Needs a change of the interpreter of Qt Creator to work there\nimport socket\nimport datetime\nimport platform\nimport errno\nimport os\nimport sympy\nimport re\nimport warnings\n\nfrom PyQt5 import QtCore\n\nfrom sympy.parsing.latex import parse_latex\nfrom sympy.parsing.sympy_parser import parse_expr\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import colors\nimport scipy\n\n\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\n\n\nimport importlib\ndef ReloadModules():\n    importlib.reload(AF)\n    importlib.reload(ART)\n\n\n\nIam_Lost = ""Lost""\nIam_Normal = ""Normal""\nIam_2D_plot = ""2D-plot""\nIam_ODE = ""ODE""\nIam_Multi_Dim = ""Multi-Dim""\nIamList = [Iam_Lost, Iam_Normal, Iam_2D_plot, Iam_ODE, Iam_Multi_Dim]\n\n\n#parse_expr\\((.*),evaluate=False,local_dict=self.Variables,global_dict=self.global_dict()\\)\n#\n\nclass AMaS: # Astus\' Mathematical Structure\n    warningMutex = QtCore.QMutex()\n # ---------------------------------- INIT ----------------------------------\n    def __init__(self, string, Iam, EvalL = 1):\n        self.Input = string\n        self.TimeStamp = AF.cTimeSStr()\n        self.TimeStampFull = AF.cTimeFullStr()\n        self.mutex = QtCore.QMutex()\n        self.NotificationMutex = QtCore.QMutex()\n        self.Name = ""No Name Given""\n        self.init_bools()\n        self.init_Flags()\n        self.f_eval_LaTeX = EvalL\n        self.Iam = Iam\n        self.Variables = {}\n        self.VariablesUnev = {}\n        with QtCore.QMutexLocker(self.NotificationMutex):\n            self.NotificationList = []\n        \n        if string == """":\n            N = NC(1,""ERROR: No input"",func=""AMaS.__init__"",DplStr=""Please give an input"",send=False)\n            self.Notify(N)\n            self.Exists = False\n        else:\n            try:\n                self.INIT_WhatAmI(string)\n            except common_exceptions :\n                self.Notify(NC(1,""Could not create AMaS object"",func=""AMaS.__init__"",exc=sys.exc_info(),send=False))\n                self.Exists = False\n            else:\n                self.Exists = True\n    \n    def init_bools(self):\n        self.multiline = False\n        self.Plot_is_initialized = False\n        self.plot_data_exists = False\n        self.disable_units = False\n        self.init_history()\n\n    def INIT_WhatAmI(self,string):\n        if self.Iam == Iam_Normal:\n            self.INIT_Normal(string)\n        elif self.Iam == Iam_2D_plot:\n            self.INIT_2D_plot(string)\n        elif self.Iam == Iam_ODE:\n            self.INIT_ODE(string)\n        elif self.Iam == Iam_Multi_Dim:\n            self.INIT_Multi_Dim(string)\n        else:\n            print(""AMaS Object: I am Lost! I don\'t know who I am! ""+self.Iam+"" is not known to me! I\'m gonna pretend I am normal!"")\n            self.Iam = Iam_Lost\n            self.INIT_Normal(string)\n\n\n    def INIT_Normal(self,string):\n        string = string.splitlines()\n        if type(string) == list :\n            if len(string) > 1 :\n                self.stringList = string\n                self.string = string[0]\n                self.multiline = True\n            else:\n                self.string = string[0]\n        else:\n            self.string = string\n        self.init_Critical()\n\n    def INIT_2D_plot(self,string):\n        self.string = string\n        self.init_Critical()\n        self.init_2D_plot()\n\n    def INIT_ODE(self,string):\n        #FEATURE: INIT_ODE\n        # https://docs.sympy.org/latest/modules/solvers/ode.html\n        print(""Iam_ODE IS NOT IMPLEMENTED YET!"")\n        self.INIT_Normal(string)\n\n    def INIT_Multi_Dim(self,string):\n        self.Name = string\n        self.string = ""0""\n        self.init_Critical()\n\n    def init_Critical(self):\n        self.Separator = "" = ""\n        self.Text = AF.AstusParseInverse(self.string)\n        self.Solution = ""Not evaluated yet""\n        self.EquationReverse = ""? = "" + self.Text\n        self.Equation = self.Text + "" = ?""\n        self.cstr = AF.AstusParse(self.string) # the converted string that is interpretable\n        if self.multiline:\n            self.cstrList = []\n            for i in self.stringList:\n                self.cstrList.append(AF.AstusParse(i,False))\n        self.LaTeX    = r""\\text{Not converted yet}"" # LaTeX of the input\n        self.LaTeX_S  = r""\\text{Not converted yet}"" # LaTeX of the Solution\n        self.LaTeX_E  = r""\\text{Not converted yet}"" # LaTeX of the Equation\n        self.LaTeX_ER = r""\\text{Not converted yet}"" # LaTeX of the Equation in Reverse order\n        self.Am_I_Plottable()\n        self.ConvertToLaTeX()\n        \n\n    def Am_I_Plottable(self):\n        # IMPROVE: Improve the criteria for ""plottable""\n        if ""x"" in self.cstr and not ""="" in self.cstr:\n            self.plottable = True\n        else:\n            self.plottable = False\n                \n                \n    def init_history(self):\n        self.tab_1_is = False\n        self.tab_1_ref = None\n        self.tab_2_is = False\n        self.tab_2_ref = None\n        self.Tab_3_1_is = False\n        self.Tab_3_1_ref = None\n        self.Tab_4_is = False\n        self.Tab_4_ref = None\n                \n    def init_2D_plot(self):\n        self.Plot_is_initialized = True\n        self.current_ax = None\n        self.plot_ratio = False\n        self.plot_grid = True\n        self.plot_xmin = -5\n        self.plot_xmax = 5\n        self.plot_xlim = False\n        self.plot_xlim_vals = (-5, 5)\n        self.plot_ylim = False\n        self.plot_ylim_vals = (-5, 5)\n        self.plot_points = 1000\n        self.plot_per_unit = False\n        self.plot_x_vals = np.arange(10)\n        self.plot_y_vals = np.zeros_like(self.plot_x_vals)\n        \n\n    \n # ---------------------------------- Update, Rename, etc ----------------------------------\n    def Update(self,string=None):\n        if string != None:\n            self.string = string\n        self.init_Critical()\n        return True\n\n    def Rename(self,Name):\n        self.Name = Name\n        return True\n\n # ---------------------------------- Flags ----------------------------------\n    def init_Flags(self):\n        self.f_eval = True         # converted to floating-point approximations (decimal numbers)\n        self.f_eval_LaTeX = 1      # If 0 prohibits all evaluation when converting to LaTeX\n                                   # If 2 Allows most Solution\n        \n        \n        \n        # REMINDER : FOLLOWING ARE NOT SET BUT READ DIRECTLY:\n        self.f_simplify = None     # Simplifies\n        self.f_powsimp = None      # Simplifies/Collects exponents\n        self.f_expand = None       # Solve all * and **\n        self.f_factor = None       # takes a polynomial and factors it into irreducible factors (Inverse of expand)\n        self.f_collect = None      # collects common powers of a term in an expression\n        self.f_collect_arg = """"\n        self.f_cancel = None       # will take any rational function and put it into the standard canonical form p/q\n        self.f_apart = None        # performs a partial fraction decomposition on a rational function\n        self.f_expand_trig = None  # To expand trigonometric functions, that is, apply the sum or double angle identities\n        \n        \n        \n        # REMINDER : FOLLOWING NEED IMPLEMENTATION:\n        \n        \n        # Simplify: https://docs.sympy.org/latest/tutorial/simplification.html\n        self.f_rewrite = None      # A common way to deal with special functions is to rewrite them in terms of one another\n        self.f_rewrite_arg = """"       # For example: tan(x).rewrite(sin)\n\n        #self.f_ = False\n\n    def ExecuteFlags(self,expr):\n        if type(expr) == dict:\n            temp_dict = {}\n            for k,v in expr.items():\n                try:\n                    if type(k) in [int,str,float,bool]:\n                        temp_dict[k] = self.ExecuteFlags(v)\n                    else:\n                        temp_dict[self.ExecuteFlags(k)] = self.ExecuteFlags(v)\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n                    temp_dict[k] = v\n            expr = temp_dict\n        else:\n            try:\n                if self.f_eval:\n                    expr = expr.evalf()\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_simplify == True or self.f_simplify == None and QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked():\n                    expr = sympy.simplify(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_powsimp == True or self.f_powsimp == None and QtWidgets.QApplication.instance().optionWindow.cb_F_powsimp.isChecked():\n                    if type(expr) == sympy.Equality:\n                        expr = sympy.Eq(sympy.powsimp(expr.lhs),sympy.powsimp(expr.rhs))\n                    else:\n                        expr = sympy.powsimp(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_expand == True or self.f_expand == None and QtWidgets.QApplication.instance().optionWindow.cb_F_expand.isChecked():\n                    expr = sympy.expand(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_factor == True or self.f_factor == None and QtWidgets.QApplication.instance().optionWindow.cb_F_factor.isChecked():\n                    expr = sympy.factor(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_collect == True:\n                    expr = sympy.collect(expr,AF.parse(self.f_collect_arg))\n                elif self.f_collect == None and QtWidgets.QApplication.instance().optionWindow.cb_F_collect.isChecked():\n                    expr = sympy.collect(expr,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_collect.text()))\n            except common_exceptions :\n                self.Notify(NC(2,""Could not collect term"",exc=sys.exc_info(),func=""AMaS.ExecuteFlags"",send=False))\n            try:\n                if self.f_cancel == True or self.f_cancel == None and QtWidgets.QApplication.instance().optionWindow.cb_F_cancel.isChecked():\n                    expr = sympy.cancel(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_apart == True or self.f_apart == None and QtWidgets.QApplication.instance().optionWindow.cb_F_apart.isChecked():\n                    expr = sympy.apart(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            try:\n                if self.f_expand_trig == True or self.f_expand_trig == None and QtWidgets.QApplication.instance().optionWindow.cb_F_expand_trig.isChecked():\n                    expr = sympy.expand_trig(expr)\n            except common_exceptions :\n                ExceptionOutput(sys.exc_info())\n            # TODO : Add the others\n        return expr\n        """"""\n        try:\n            if self.f_? == True or self.f_? == None and QtWidgets.QApplication.instance().optionWindow.cb_F_?.isChecked():\n                expr = sympy.?(expr)\n        except common_exceptions :\n            ExceptionOutput(sys.exc_info())\n        """""" # pylint: disable=unreachable\n\n    def global_dict(self):\n        if QtWidgets.QApplication.instance().optionWindow.cb_U_EnableUnits.isChecked() and not self.disable_units:\n            global_dict = {}\n            exec(\'from sympy import *\', global_dict)\n            exec(\'from sympy.physics.units import *\', global_dict)\n            return global_dict\n        else:\n            return None\n # ---------------------------------- Notifications ----------------------------------\n\n    def sendNotifications(self,win=None):\n        """"""\n        Sends all Notifications and clears them   \\n\n        Optionally sets the window of all notifications to win\n        """"""\n        with QtCore.QMutexLocker(self.NotificationMutex):\n            if win != None:\n                for i in self.NotificationList:\n                    i.w(win)\n            for i in self.NotificationList:\n                i.send()\n                QtWidgets.QApplication.instance().processEvents()\n            self.NotificationList = []\n\n    def Notify(self,Notification):\n        """"""Used to add Notifications""""""\n        with QtCore.QMutexLocker(self.NotificationMutex):\n            In = """"\n            if Notification.i()!=self.Input:\n                In += ""Specific Input:\\n""\n                try:\n                    In += Notification.i()\n                except:\n                    In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n                In += ""\\n\\n""\n            In += ""The state of the object while the notification was triggered (not final state):\\nself.Input:\\n""\n            try:\n                In += self.Input\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.cstr:\\n""\n            try:\n                In += self.cstr\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.TimeStampFull (time of creation of the AMaS object):\\n""\n            try:\n                In += self.TimeStampFull\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.Name (Usually: No Name Given):\\n""\n            try:\n                In += self.Name\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.Iam:\\n""\n            try:\n                In += self.Iam\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.LaTeX:\\n""\n            try:\n                In += self.LaTeX\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            In += ""\\n\\nself.Solution:\\n""\n            try:\n                In += self.Solution\n            except:\n                In += ""ERROR: ATTRIBUTE DOES NOT EXIST""\n            Notification.i(In)\n            #Notification.i(""    self.Input: ""+self.Input+""\\nSpecific Input: ""+In)\n            self.NotificationList.append(Notification)\n\n    def NotifyFromNumpy(self,text,flag=""""):\n        """"""Used to add Notifications from Numpy and scipy""""""\n        print(text,flag)\n        text += flag\n        self.Notify(NC(3,text,send=False))\n\n    def NotifyWarning(self, message, category, filename, lineno, file=None, line=None):\n        TheWarning = warnings.formatwarning(message, category, filename, lineno, line)\n        print(""Warning in AMaS for"",self.Input,""\\n"",TheWarning)\n        self.Notify(NC(2,TheWarning,err=message,tb=""filename: {}\\nlineno: {}"".format(str(filename),str(lineno)),send=False))\n\n # ---------------------------------- LaTeX Converter ----------------------------------\n    # MAYBE: set a time limit for conversions that can be disabled in the options (if this is even possible)\n    \n    def ConvertToLaTeX(self):\n        """"""\n        Converts the Input into LaTeX.\n        """"""\n        if self.multiline:\n            self.LaTeX = """"\n            n = len(self.cstrList)\n            for i,e in enumerate(self.cstrList):\n                n -= 1\n                LineText = """"\n                try:\n                    #if e.strip() == """":\n                    #    #LineText += ""-""\n                    #    if n > 0:\n                    #        LineText += ""\\n""\n                    #        #self.LaTeX_L += ""$\\displaystyle""\n                    #        #self.LaTeX_N += ""$""\n                    #    self.LaTeX += LineText\n                    #    continue\n                    #if ""="" in e:\n                    #    parts = self.cstrList[i].split(""="")\n                    #    conv = """"\n                    #    for j in parts:\n                    #        if len(j)>0:\n                    #            conv += AF.LaTeX(j,local_dict=self.VariablesUnev,evalf=self.f_eval_LaTeX)\n                    #        conv += "" = ""\n                    #    LineText += conv[:-3]\n                    #else:\n                    LineText = AF.LaTeX(e,local_dict=self.VariablesUnev,evalf=self.f_eval_LaTeX)\n                except common_exceptions: #as inst:\n                    ExceptionOutput(sys.exc_info())\n                    # LineText += AF.AstusParseInverse(e) #MAYBE: Unicodesymbols seem to brake LaTeX Output... Maybe there is a way to fix it?\n                    LineText += e\n                    LineText = r"" \\text{ "" + LineText.replace(""\\t"",r"" \\qquad "") + "" } ""\n                    if n > 0:\n                        LineText += ""\\n""\n                    self.LaTeX += LineText\n                else:\n                    #LineText += ""$""\n                    if ""#"" in e:\n                        LineText += r"" \\qquad \\text{ "" + e.split(""#"",1)[1] + "" } ""\n                    if n > 0:\n                        LineText += ""\\n""\n                    #self.LaTeX_L += r""$\\displaystyle ""\n                    #self.LaTeX_N += ""$""\n                    #self.LaTeX_L += LineText\n                    self.LaTeX += r"" \\qquad ""*e.count(""\\t"") + LineText\n        else:\n            try:\n                #if ""="" in self.cstr:\n                #    parts = self.cstr.split(""="")\n                #    self.LaTeX = """"\n                #    for i in parts:\n                #        if len(i)>0:\n                #            self.LaTeX += AF.LaTeX(i,local_dict=self.VariablesUnev,evalf=self.f_eval_LaTeX)\n                #        self.LaTeX += "" = ""\n                #    self.LaTeX = self.LaTeX[:-3]\n                #else:\n                self.LaTeX = AF.LaTeX(self.cstr,local_dict=self.VariablesUnev,evalf=self.f_eval_LaTeX)\n                if ""#"" in self.cstr:\n                    self.LaTeX += r"" \\qquad \\text{ "" + self.cstr.split(""#"",1)[1] + "" } ""\n            except common_exceptions:\n                self.Notify(NC(exc=sys.exc_info(),lvl=2,msg=""Could not convert input to LaTeX"",func=""AMaS.ConvertToLaTeX"",send=False))\n                self.LaTeX = r""\\text{Could not convert}""\n    \n    def ConvertToLaTeX_Solution(self, expr=None):\n        """"""\n        Converts the solution into LaTeX and creates a LaTeX version of the equation. \\n\n        Handles ``self.LaTeX_S``, ``self.LaTeX_E`` and ``self.LaTeX_ER``. \\n\n        expr must be a Sympy Expression (NOT A STRING!)   \\n\n        If not given or not convertable try to convert self.Solution\n        """"""\n        try:\n            if expr != None:\n                try:\n                    self.LaTeX_S = sympy.latex(expr)\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n                    self.LaTeX_S = r""\\text{Could not convert}""\n                    self.LaTeX_E = r""\\text{Could not convert}""\n                    self.LaTeX_ER = r""\\text{Could not convert}""\n                    expr = None\n            if expr == None:\n                try:\n                    if self.Solution == ""Not evaluated yet"":\n                        raise Exception(""Equation has not been evaluated yet"")\n                    #if ""="" in self.Solution:\n                    #    parts = self.Solution.split(""="")\n                    #    self.LaTeX_S = """"\n                    #    for i in parts:\n                    #        if len(i)>0:\n                    #            #self.LaTeX_S += sympy.latex( sympy.S(i,evaluate=False))\n                    #            expr = parse_expr(i,evaluate=False,local_dict=self.Variables,global_dict=self.global_dict())\n                    #            self.LaTeX_S += sympy.latex(expr)\n                    #        self.LaTeX_S += "" = ""\n                    #    self.LaTeX_S = self.LaTeX_S[:-3]\n                    #else:\n                    #    #self.LaTeX_S = sympy.latex( sympy.S(self.Solution,evaluate=False))\n                    #    expr = parse_expr(self.Solution,evaluate=False,local_dict=self.Variables,global_dict=self.global_dict())\n                    #    self.LaTeX_S = sympy.latex(expr)\n                    self.LaTeX_S = AF.LaTeX(self.Solution,local_dict=self.VariablesUnev,evalf=1)\n                except common_exceptions:\n                    if expr==None: expr=self.Solution\n                    self.Notify(NC(exc=sys.exc_info(),lvl=2,msg=""Could not convert Solution to LaTeX"",input=expr,func=""AMaS.ConvertToLaTeX_Solution"",send=False))\n                    return False\n        except common_exceptions:\n            self.LaTeX_S = r""\\text{Could not convert}""\n            self.LaTeX_E = r""\\text{Could not convert}""\n            self.LaTeX_ER = r""\\text{Could not convert}""\n            self.Notify(NC(exc=sys.exc_info(),lvl=2,msg=""Could not convert Solution to LaTeX"",input=expr,func=""AMaS.ConvertToLaTeX_Solution"",send=False))\n            return False\n        else:\n            try:\n                LaTeX = self.LaTeX\n                if LaTeX == r""\\text{Could not convert}"":\n                    LaTeX = r""\\text{"" + self.Text + ""}""\n                self.LaTeX_S = AF.number_shaver(self.LaTeX_S)\n                if self.Separator == "" = "":\n                    self.LaTeX_E  = LaTeX + "" = "" + self.LaTeX_S\n                    self.LaTeX_ER = self.LaTeX_S + "" = "" + LaTeX\n                elif self.Separator == ""   ==>   "":\n                    self.LaTeX_E  = LaTeX + r"" \\Longrightarrow "" + self.LaTeX_S\n                    self.LaTeX_ER = self.LaTeX_S + r"" \\Longleftarrow "" + LaTeX\n                else:\n                    self.LaTeX_E  = LaTeX + r"" \\Longrightarrow "" + self.LaTeX_S\n                    self.LaTeX_ER = self.LaTeX_S + r"" \\Longleftarrow "" + LaTeX\n            except common_exceptions:\n                self.LaTeX_E = r""\\text{Could not convert}""\n                self.LaTeX_ER = r""\\text{Could not convert}""\n                self.Notify(NC(exc=sys.exc_info(),lvl=2,msg=""Could not convert Equation to LaTeX"",input=expr,func=""AMaS.ConvertToLaTeX_Solution"",send=False))\n                return False\n            else:\n                return True\n    \n # ---------------------------------- Calculator Methods ----------------------------------\n    # MAYBE: set a time limit for evaluations that can be disabled in the options (if this is even possible)\n\n\n    def Evaluate(self, Method=1):\n        """"""\n        This method redirects to the various solver methods\n        """"""\n        if QtWidgets.QApplication.instance().optionWindow.cb_D_NewSolver.isChecked():\n            return self.Evaluate_SymPy()\n        elif Method==0:\n            return self.Evaluate_SymPy()\n        elif Method==1:\n            return self.Evaluate_SymPy_old()\n        else:\n            self.Notify(NC(2,""Invalid evaluate method number. Using standard method instead."",func=""AMaS.Evaluate"",send=False))\n            return self.Evaluate_SymPy_old()\n        \n    def CheckForNonesense(self,expr): #REMINDER: check for more dangerous things\n        """"""\n        This method searches for mathematical ""nonesense"" and warns the user. \\n\n        It currently searches for: \\n\n        Sums that don\'t converge.\n        """"""\n        try:\n            if type(expr) in [str,int,float,complex,bool]:\n                return\n            elif type(expr) == dict:\n                for k,i in expr.items():\n                    self.CheckForNonesense(k)\n                    self.CheckForNonesense(i)\n            elif type(expr) == list:\n                for i in expr:\n                    self.CheckForNonesense(i)\n            else:\n                if expr.func in [sympy.Sum, sympy.Product]:\n                    if expr.func == sympy.Sum:\n                        f_s = ""Sum""\n                    elif expr.func == sympy.Product:\n                        f_s = ""Product""\n                    try:\n                        if not expr.is_convergent():\n                            self.Notify(NC(2,""The input contains a {} that does NOT converge! The result is not to be trusted!"".format(f_s),func=""AMaS.Evaluate"",input=""{}:\\n{}"".format(f_s,str(expr)),send=False))\n                    except NotImplementedError:\n                        self.Notify(NC(2,""The input contains a {} that can not be checked for convergence! The result is not to be trusted!"".format(f_s),func=""AMaS.Evaluate"",input=""{}:\\n{}"".format(f_s,str(expr)),send=False))\n                # CHECK HERE\n                for arg in expr.args:\n                    self.CheckForNonesense(arg)\n        except AttributeError:\n            pass\n        except:\n            self.Notify(NC(2,""The input could not be completely scanned for \\""nonesense\\"""",func=""AMaS.Evaluate"",input=""Expression: ""+str(expr),exc=sys.exc_info(),send=False))\n\n    def Evaluate_SymPy(self):\n        Notification = NC(0,send=False)\n        \n        try:\n            if self.Input.count(""="") >= 1 and self.Input.count("","") >= 1:\n                try:\n                    if self.Solve_ODE_Version_1():\n                        self.init_Flags()\n                        return True\n                except common_exceptions:\n                    ExceptionOutput(sys.exc_info())\n            try:\n                pass #TODO: Try to solve it\n            except common_exceptions:\n                Notification = NC(1,""Could not solve"",func=""AMaS.Evaluate_SymPy"",exc=sys.exc_info(),send=False)\n            # TODO: reimplement the two solvers from the old one (one equalsign or none) but make the code less redundant and cleaner and handle dicts even better\n        except common_exceptions:\n            Notification = NC(1,""Could not solve"",func=""AMaS.Evaluate_SymPy"",exc=sys.exc_info(),send=False)\n            self.Solution = ""Fail""\n        \n        self.Equation = self.Solution + self.Separator\n        self.Equation += self.Text\n        \n        self.init_Flags() # Reset All Flags\n        \n        self.Equation = AF.number_shaver(self.Equation)\n        self.Solution = AF.number_shaver(self.Solution)\n        \n        if self.Solution == ""Fail"":\n            self.Notify(Notification)\n            return False\n        else:\n            return True\n        return True\n\n    def Evaluate_SymPy_old(self):\n        #TODO: CALCULATE EVEN MORE STUFF (how can solveset be used?)\n        #TODO: Dirac does not work... what does the sympy documentation say to dirac...?\n        #TODO: If a Sum is involved it should be checked for convergence with https://docs.sympy.org/latest/modules/concrete.html#sympy.concrete.summations.Sum.is_convergent\n        #      If it is not convergent the user should be notified that the solution can not be trusted!\n        # https://docs.sympy.org/latest/modules/evalf.html\n        # https://docs.sympy.org/latest/modules/solvers/solvers.html\n        \n        Notification = NC(0,send=False)\n        ODE = False\n        if self.Input.count(""="") >= 1 and self.Input.count("","") >= 1:\n            try:\n                ODE = self.Solve_ODE_Version_1()\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n                ODE = False\n        if ODE == True:\n            self.init_Flags() # Reset All Flags\n            return ODE\n        \n        if self.cstr.count(""="") == 1 and self.cstr.split(""="")[0].count(""("")==self.cstr.split(""="")[0].count("")""):\n            try:\n                temp = self.cstr\n                #if Eval:\n                #    temp.replace(""Integral"",""integrate"")\n                temp = ""("" + temp\n                temp = temp.replace(""="" , "") - ("")\n                temp = temp + "")""\n                temp = AF.UnpackDualOperators(temp,Brackets=(""["",""]""))\n                print(temp)\n                ans = parse_expr(temp,local_dict=self.Variables,global_dict=self.global_dict())\n                self.CheckForNonesense(ans)\n                ParsedInput = ans\n                try:\n                    ans = ans.doit()\n                except common_exceptions:\n                    pass\n                try:\n                    if self.f_simplify==None:\n                        ans = sympy.dsolve(ans,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                    else:\n                        ans = sympy.dsolve(ans,simplify=self.f_simplify)\n                    try:\n                        classification = sympy.classify_ode(ParsedInput)\n                        self.Notify(NC(3,""ODE Classification:\\n""+str.join(""\\n"",classification),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                    except common_exceptions:\n                        Notification = NC(1,""Could not classify ODE"",func=""AMaS.Evaluate_SymPy_old"",exc=sys.exc_info(),send=False)\n                    try:\n                        ansF = self.ExecuteFlags(ans)\n                        self.Solution = str(ansF.lhs) + "" = ""\n                        self.Solution += str(ansF.rhs)\n                        self.ConvertToLaTeX_Solution(ansF)\n                    except common_exceptions:\n                        ansF = self.ExecuteFlags(ans)\n                        self.Solution = str(ansF)\n                        self.ConvertToLaTeX_Solution(ansF)\n                except common_exceptions:\n                    Notification = NC(1,""Could not solve as ODE"",func=""AMaS.Evaluate_SymPy_old"",exc=sys.exc_info(),send=False)\n                    if type(ans)==list:\n                        self.Solution = ""[ "" if len(ans)>1 else """"\n                        for ji in ans:\n                            if QtWidgets.QApplication.instance().optionWindow.cb_F_solveFor.isChecked():\n                                try:\n                                    if self.f_simplify==None:\n                                        j = sympy.solve(ji,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                    else:\n                                        j = sympy.solve(ji,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=self.f_simplify)\n                                except common_exceptions:\n                                    self.Notify(NC(2,""Could not solve for ""+QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text(),exc=sys.exc_info(),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                                    if self.f_simplify==None:\n                                        j = sympy.solve(ji,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                    else:\n                                        j = sympy.solve(ji,dict=True,simplify=self.f_simplify)\n                            else:\n                                if self.f_simplify==None:\n                                    j = sympy.solve(ji,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                else:\n                                    j = sympy.solve(ji,dict=True,simplify=self.f_simplify)\n                            self.Solution += ""[ "" if len(ji)>1 else """"\n                            le = len(self.Solution)\n                            for i in j:\n                                i = self.ExecuteFlags(i)\n                                i_temp = str(i)\n                                #i_temp = i_temp.rstrip(\'0\').rstrip(\'.\') if \'.\' in i_temp else i_temp #CLEANUP: Delete this, Already implemented\n                                self.Solution += i_temp\n                                self.Solution += "" , ""\n                            if len(self.Solution) > le:\n                                self.Solution = self.Solution[:-3]\n                                self.Solution += "" ]"" if len(ji)>1 else """"\n                            else:\n                                self.Solution = self.Solution[:-2]\n                                j = parse_expr(str(ji),local_dict=self.Variables,global_dict=self.global_dict())\n                                try:\n                                    j = j.doit()\n                                except common_exceptions:\n                                    ExceptionOutput(sys.exc_info())\n                                try: # MAYBE: get rid of this evalf()\n                                    if self.f_eval: j = j.evalf()\n                                except common_exceptions:\n                                    ExceptionOutput(sys.exc_info())\n                                #j = self.ExecuteFlags(j) #MAYBE: Should this be done?\n                                #self.Solution = ""True"" if j == 0 else ""False: right side deviates by ""+str(j)\n                                try:\n                                    if j == 0 or str(j) == ""0"":\n                                        self.Solution = ""True""\n                                    elif sympy.cancel(j) == 0 or str(sympy.cancel(j)) == ""0"":\n                                        self.Solution = ""True""\n                                        self.Notify(NC(3,""True in the sense that the terms cancel. Without cancling the right side deviates by ""+str(j),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                                    else:\n                                        self.Solution = ""False: right side deviates by ""+str(j)\n                                except common_exceptions:\n                                    self.Solution = ""True"" if j == 0 or str(j) == ""0"" else ""False: right side deviates by ""+str(j)\n                            self.Solution += "" , ""\n                        self.Solution = self.Solution[:-3]\n                        self.Solution += "" ]"" if len(ans)>1 else """"\n                    else:\n                        if QtWidgets.QApplication.instance().optionWindow.cb_F_solveFor.isChecked():\n                            try:\n                                if self.f_simplify==None:\n                                    ans = sympy.solve(ans,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                else:\n                                    ans = sympy.solve(ans,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=self.f_simplify)\n                            except common_exceptions:\n                                self.Notify(NC(2,""Could not solve for ""+QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text(),exc=sys.exc_info(),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                                if self.f_simplify==None:\n                                    ans = sympy.solve(ans,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                else:\n                                    ans = sympy.solve(ans,dict=True,simplify=self.f_simplify)\n                        else:\n                            if self.f_simplify==None:\n                                ans = sympy.solve(ans,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                            else:\n                                ans = sympy.solve(ans,dict=True,simplify=self.f_simplify)\n                        self.Solution = ""[ "" if len(ans)>1 else """"\n                        for i in ans:\n                            i = self.ExecuteFlags(i)\n                            i_temp = str(i)\n                            #i_temp = i_temp.rstrip(\'0\').rstrip(\'.\') if \'.\' in i_temp else i_temp #CLEANUP: Delete this, Already implemented\n                            self.Solution += i_temp\n                            self.Solution += "" , ""\n                        self.Solution = self.Solution[:-3]\n                        if len(self.Solution) > 0:\n                            self.Solution += "" ]"" if len(ans)>1 else """"\n                        else:\n                            ans = parse_expr(temp,local_dict=self.Variables,global_dict=self.global_dict())\n                            try:\n                                ans = ans.doit()\n                            except common_exceptions:\n                                ExceptionOutput(sys.exc_info())\n                            try: # MAYBE: get rid of this evalf()\n                                if self.f_eval: ans = ans.evalf()\n                            except common_exceptions:\n                                ExceptionOutput(sys.exc_info())\n                            #ans = self.ExecuteFlags(ans) #MAYBE: Should this be done?\n                            #self.Solution = ""True"" if ans == 0 else ""False: right side deviates by ""+str(ans)\n                            try:\n                                if ans == 0 or str(ans) == ""0"":\n                                    self.Solution = ""True""\n                                elif sympy.cancel(ans) == 0 or str(sympy.cancel(ans)) == ""0"":\n                                    self.Solution = ""True""\n                                    self.Notify(NC(3,""True in the sense that the terms cancel. Without cancling the right side deviates by ""+str(ans),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                                else:\n                                    self.Solution = ""False: right side deviates by ""+str(ans)\n                            except common_exceptions:\n                                self.Solution = ""True"" if ans == 0 or str(ans) == ""0"" else ""False: right side deviates by ""+str(ans)\n                    self.ConvertToLaTeX_Solution()\n                    \n            except common_exceptions: #as inst:\n                Notification = NC(1,""Could not solve"",func=""AMaS.Evaluate_SymPy_old"",exc=sys.exc_info(),send=False)\n                #print(inst.args)\n                #if callable(inst.args):\n                #    print(inst.args())\n                self.Solution = ""Fail""\n            self.Separator = ""   ==>   ""\n            self.EquationReverse = AF.AstusParseInverse(self.Solution, True) + ""   <==   ""\n            self.EquationReverse += self.Text\n            self.Equation = self.Text + ""   ==>   ""\n            self.Equation += AF.AstusParseInverse(self.Solution, True)\n        else:\n            try:\n                temp = AF.UnpackDualOperators(self.cstr,Brackets=(""{"",""}""))\n                ans = parse_expr(temp,local_dict=self.Variables,global_dict=self.global_dict())\n                self.CheckForNonesense(ans)\n                separator = ""   <==   ""\n                self.Separator = ""   ==>   ""\n                ParsedInput = ans\n                if type(ans) == bool:\n                    self.Solution = str(ans)\n                else:\n                    try: # A problem was introduced with version 0.7.0 which necessitates this when inputting integrate(sqrt(sin(x))/(sqrt(sin(x))+sqrt(cos(x))))\n                        # The Problem seems to be gone at least since version 0.8.0.3 but Keep this anyways in case other problems occur here...\n                        ans = ans.doit()\n                    except common_exceptions:\n                        print(""Could not simplify ""+str(ans))\n                        ExceptionOutput(sys.exc_info())\n                    try:\n                        if self.f_simplify==None:\n                            ans = sympy.dsolve(ans,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                        else:\n                            ans = sympy.dsolve(ans,simplify=self.f_simplify)\n                        try:\n                            classification = sympy.classify_ode(ParsedInput)\n                            self.Notify(NC(3,""ODE Classification:\\n""+str.join(""\\n"",classification),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                        except common_exceptions:\n                            Notification = NC(1,""Could not classify ODE"",func=""AMaS.Evaluate_SymPy_old"",exc=sys.exc_info(),send=False)\n                        ansF = self.ExecuteFlags(ans)\n                        try:\n                            self.Solution = str(ansF.lhs) + "" = ""\n                            self.Solution += str(ansF.rhs)\n                            self.ConvertToLaTeX_Solution(ansF)\n                        except common_exceptions:\n                            self.Solution = str(ansF)\n                            self.ConvertToLaTeX_Solution(ansF)\n                    except common_exceptions:\n                        separator = "" = "" #TODO: inequalities should use the other separator\n                        self.Separator = "" = ""\n                        if self.f_eval:\n                            try:\n                                ans = ans.evalf()\n                            except common_exceptions:\n                                try:\n                                    if QtWidgets.QApplication.instance().optionWindow.cb_F_solveFor.isChecked():\n                                        try:\n                                            if self.f_simplify==None:\n                                                ans_S = sympy.solve(ans,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                            else:\n                                                ans_S = sympy.solve(ans,AF.parse(QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text()),dict=True,simplify=self.f_simplify)\n                                        except common_exceptions:\n                                            self.Notify(NC(2,""Could not solve for ""+QtWidgets.QApplication.instance().optionWindow.tf_F_solveFor.text(),exc=sys.exc_info(),func=""AMaS.Evaluate_SymPy_old"",send=False))\n                                            if self.f_simplify==None:\n                                                ans_S = sympy.solve(ans,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                            else:\n                                                ans_S = sympy.solve(ans,dict=True,simplify=self.f_simplify)\n                                    else:\n                                        if self.f_simplify==None:\n                                            ans_S = sympy.solve(ans,dict=True,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n                                        else:\n                                            ans_S = sympy.solve(ans,dict=True,simplify=self.f_simplify)\n                                    try:\n                                        if not (type(ans_S)==list and len(ans_S)==0):\n                                            ans = ans_S\n                                    except common_exceptions:\n                                        ans = ans_S\n                                except common_exceptions:\n                                    pass\n                        ansF = self.ExecuteFlags(ans)\n                        self.Solution = str(ansF)\n                        self.ConvertToLaTeX_Solution(ansF)\n                    #self.Solution = self.Solution.rstrip(\'0\').rstrip(\'.\') if \'.\' in self.Solution else self.Solution #CLEANUP: Delete this, Already implemented\n            except common_exceptions: #as inst:\n                Notification = NC(1,""Could not solve"",func=""AMaS.Evaluate_SymPy_old"",exc=sys.exc_info(),send=False)\n                #print(inst.args)\n                #if callable(inst.args):\n                #    print(inst.args())\n                self.Solution = ""Fail""\n                separator = ""   <==   ""\n                self.Separator = ""   ==>   ""\n            self.EquationReverse = AF.AstusParseInverse(self.Solution, True) + separator\n            self.EquationReverse += self.Text\n            if separator == ""   <==   "":\n                separator = ""   ==>   ""\n            self.Equation = self.Text + separator\n            self.Equation += AF.AstusParseInverse(self.Solution, True)\n        \n        self.init_Flags() # Reset All Flags\n        \n        self.Equation = AF.number_shaver(self.Equation)\n        self.EquationReverse = AF.number_shaver(self.EquationReverse)\n        self.Solution = AF.number_shaver(self.Solution)\n        #self.ConvertToLaTeX_Equation()\n\n        #self.Solution = AF.AstusParseInverse(self.Solution, True) # TODO: Inverse Parse the solution.\n                                        # This currently breaks everything with E notation and probably much more when working with ""ans"".\n                                        # The current way of only converting the displayed Equation works and does not have this problem.\n                                        # The reason the Solution should be inverse-parsed is to give the user a prettier solution to copy.\n        \n        \n        if self.Solution == ""Fail"":\n            if QtWidgets.QApplication.instance().optionWindow.cb_U_EnableUnits.isChecked() and not self.disable_units:\n                self.disable_units = True\n                Notification.m(""Could not solve. Trying to solve without units...\\n(Units can be turned off in the options.)"")\n                Notification.l(3)\n                self.Notify(Notification)\n                return self.Evaluate(1)\n            else:\n                self.Notify(Notification)\n                return False\n        else:\n            return True\n        \n    def EvaluateEquation_1(self): # This is currently being used\n        temp = self.cstr\n        #if Eval:\n        #    temp.replace(""Integral"",""integrate"")\n        temp = ""("" + temp\n        temp = temp.replace(""="" , "") - ("")\n        temp = temp + "")""\n        return True\n        \n    def EvaluateEquation_2(self): #IMPROVE: This might be better BUT: This is weird and does not always work and needs a lot of reprogramming and testing...\n        temp = self.cstr\n        temp1 , temp2 = self.cstr.split(""="",1)\n        temp = ""Eq(""+temp1\n        temp += "",""\n        temp += temp2\n        temp += "")""\n        return True\n                \n    def EvaluateLaTeX(self):\n        # https://docs.sympy.org/latest/modules/solvers/solvers.html\n        try:\n            ans = parse_latex(self.LaTeX)\n            ans = ans.evalf()\n            self.Solution = str(ans)\n        except common_exceptions: #as inst:\n            self.Notify(NC(1,""Could not solve"",func=""AMaS.EvaluateLaTeX"",exc=sys.exc_info(),send=False))\n            self.Solution = ""Fail""\n            return False\n        return True\n\n    def Solve_ODE_Version_1(self):\n        Notification = NC(0,send=False)\n        try:\n            Input = self.Input\n            Input = Input.split("","")\n            func = Input[1].strip()[0]\n            equation = AF.AstusParse(Input.pop(0))\n            if equation.count(""="") == 1 :\n                equation = ""("" + equation\n                equation = equation.replace(""="" , "") - ("")\n                equation = equation + "")""\n            var = equation.split(func,1)[1].split(""("",1)[1].split("")"",1)[0].strip()\n            print(""Function:"",func)\n            print(""Variable:"",var)\n            var_Parsed = parse_expr(var)\n            equation = parse_expr(equation,local_dict=self.Variables,global_dict=self.global_dict())\n            classification = sympy.classify_ode(equation)\n            print(""ODE Classification:\\n"",classification)\n            self.Notify(NC(3,""ODE Classification:\\n""+str.join(""\\n"",classification),func=""AMaS.Solve_ODE_Version_1"",send=False))\n            ics = {}\n            for i in Input:\n                f,y=i.split(""="")\n                f,x = f.split(""("",1)\n                x = x.split("")"",1)[0].strip()\n                f+=""(""\n                f+=var\n                f+="")""\n                f,x,y = parse_expr(AF.AstusParse(f,False)),parse_expr(AF.AstusParse(x,False),local_dict=self.Variables,global_dict=self.global_dict()),parse_expr(AF.AstusParse(y,False),local_dict=self.Variables,global_dict=self.global_dict())\n                f = f.subs(var_Parsed,x)\n                ics[f] = y\n            #ics = {f1.subs(x,x1):y1,f2.subs(x,x2):y2}\n            func += ""(""\n            func += var\n            func += "")""\n            func = parse_expr(func)\n            if self.f_simplify==None:\n                equation = sympy.dsolve(equation,func=func,ics=ics,simplify=QtWidgets.QApplication.instance().optionWindow.cb_F_simplify.isChecked())\n            else:\n                equation = sympy.dsolve(equation,func=func,ics=ics,simplify=self.f_simplify)\n            equation = self.ExecuteFlags(equation)\n            try:\n                self.Solution = str(equation.lhs) + "" = ""\n                self.Solution += str(equation.rhs)\n                self.ConvertToLaTeX_Solution(equation)\n            except common_exceptions:\n                self.Solution = str(equation)\n                self.ConvertToLaTeX_Solution(equation)\n\n        except common_exceptions:\n            Notification = NC(1,""Could not solve ODE"",func=""AMaS.Solve_ODE_Version_1"",exc=sys.exc_info(),send=False)\n            self.Solution = ""Fail""\n        \n        self.Separator = ""   ==>   ""\n        self.EquationReverse = AF.AstusParseInverse(self.Solution, True) + ""   <==   ""\n        self.EquationReverse += self.Text\n        self.Equation = self.Text + ""   ==>   ""\n        self.Equation += AF.AstusParseInverse(self.Solution, True)\n        #self.ConvertToLaTeX_Equation()\n            \n        if self.Solution == ""Fail"":\n            return Notification\n        else:\n            return True\n            \n    def Solve_PDE_Version_1(self):\n        #FEATURE: Add support for Partial Differential Equations\n        # https://docs.sympy.org/latest/modules/solvers/pde.html\n        # PDEs are currently solveable with:\n        # pdsolve(1 + (2*(d(u(x,y))/dx)) + (3*(d(u(x,y))/dy)))\n        pass\n\n            \n # ---------------------------------- 2D Plotter Methods ----------------------------------\n            \n    def Plot_2D_Calc_Values(self):\n        oldErrCall = np.seterrcall(self.NotifyFromNumpy)\n        oldErrCall_sp = scipy.seterrcall(self.NotifyFromNumpy)\n        if self.cstr.count(""="")>=1:\n            try:\n                temp_line_split = self.cstr.split(""="",1)\n                temp_line_split[0] = temp_line_split[0].strip()\n                if temp_line_split[0] == ""x"":\n                    temp_line_x_val = parse_expr(temp_line_split[1],local_dict=self.Variables,global_dict=self.global_dict())\n                    temp_line_x_val = float(temp_line_x_val.evalf())\n                    if type(temp_line_x_val) == int or type(temp_line_x_val) == float :\n                        self.plot_x_vals = temp_line_x_val\n                        self.plot_data_exists = True\n                        np.seterrcall(oldErrCall)\n                        scipy.seterrcall(oldErrCall_sp)\n                        return True\n            except common_exceptions:\n                pass\n        \n        \n        if True : #self.plottable: #IMPROVE: The ""plottable"" thing is not exact. Try to plot it even if not ""plottable"" and handle the exceptions\n            x = sympy.symbols(\'x\')\n            n = sympy.symbols(\'n\') # pylint: disable=unused-variable\n            try:\n                Function = parse_expr(self.cstr,local_dict=self.Variables,global_dict=self.global_dict())\n            except common_exceptions: #as inst:\n                self.Notify(NC(1,""Could not calculate values for plot"",func=""AMaS.Plot_2D_Calc_Values"",exc=sys.exc_info(),send=False))\n                self.plottable = False\n                np.seterrcall(oldErrCall)\n                scipy.seterrcall(oldErrCall_sp)\n                return False\n            try:\n                Function = Function.doit()\n            except common_exceptions: #as inst:\n                ExceptionOutput(sys.exc_info())\n                \n            if self.plot_xmax < self.plot_xmin:\n                self.plot_xmax , self.plot_xmin = self.plot_xmin , self.plot_xmax\n            \n            if self.plot_per_unit:\n                step_size = 1/(self.plot_points-1)\n            else:\n                step_size = (self.plot_xmax - self.plot_xmin)/(self.plot_points-1)\n                \n            #                                 from     up to (excluding the last!) step size\n            self.plot_x_vals = np.arange(self.plot_xmin, self.plot_xmax+step_size, step_size)\n\n            try:\n                evalfunc = sympy.lambdify(x, Function, modules=[\'numpy\',\'sympy\'])\n                print(self.plot_x_vals,type(self.plot_x_vals))\n                self.plot_y_vals = evalfunc(self.plot_x_vals)\n                \n                \n                if type(self.plot_y_vals) == int or type(self.plot_y_vals) == float or self.plot_y_vals.shape == (): #This also catches the case exp(x)\n                    self.plot_y_vals = np.full_like(self.plot_x_vals , self.plot_y_vals)\n                if self.plot_y_vals.shape != self.plot_x_vals.shape:\n                    raise Exception(""Dimensions do not match"")\n                \n            except common_exceptions: #as inst:\n                TheException = sys.exc_info()\n                #print(inst.args)\n                #if callable(inst.args):\n                #    print(inst.args())\n                # To Catch AttributeError \'ImmutableDenseNDimArray\' object has no attribute \'could_extract_minus_sign\'\n                # This occurs, for example, when trying to plot integrate(sqrt(sin(x))/(sqrt(sin(x))+sqrt(cos(x))))\n                # This is a known Sympy bug since ~2011 and is yet to be fixed...  See https://github.com/sympy/sympy/issues/5721\n                try:\n                    self.warningMutex.lock()\n                    oldNPWarn = np.warnings.showwarning\n                    oldWarn = warnings.showwarning\n                    np.warnings.showwarning = self.NotifyWarning\n                    warnings.showwarning = self.NotifyWarning\n                    if self.cstr.count(""Integral"") == 0:\n                        evalfunc = sympy.lambdify(x, self.cstr, modules=\'numpy\')\n                        self.plot_y_vals = evalfunc(self.plot_x_vals)\n                        self.plot_y_vals = np.asarray(self.plot_y_vals)\n                        \n                        if type(self.plot_y_vals) == int or type(self.plot_y_vals) == float or self.plot_y_vals.shape == ():\n                            self.plot_y_vals = np.full_like(self.plot_x_vals , self.plot_y_vals)\n                        if self.plot_y_vals.shape != self.plot_x_vals.shape:\n                            print(self.plot_y_vals.shape)\n                            raise Exception(""Dimensions do not match"")\n                        self.Notify(NC(3,msg=""Could not calculate plot with sympy.\\nUsing numpy instead."",exc=TheException,func=""AMaS.Plot_2D_Calc_Values"",send=False))\n                    elif self.cstr.count(""Integral"") == 1 and( ( re.fullmatch(r""Integral\\((.(?<!Integral))+,x\\)"",self.cstr) and self.cstr.count("",x)"") == 1 ) or ( re.fullmatch(r""Integral\\((.(?<!Integral))+\\)"",self.cstr) and self.cstr.count("",x)"") == 0 )):\n                        temp_Text = self.cstr\n                        temp_Text = temp_Text.replace(""Integral"","""")\n                        temp_Text = re.sub(r"",x\\)$"","")"",temp_Text)\n                        evalfunc = sympy.lambdify(x, temp_Text, modules=\'numpy\')\n                        \n                        def F(X):\n                            try:\n                                return [scipy.integrate.quad(evalfunc, 0, y) for y in X]\n                            except TypeError:\n                                return scipy.integrate.quad(evalfunc, 0, X)\n                        \n                        self.plot_y_vals = evalfunc(self.plot_x_vals)\n                        self.plot_y_vals = [F(X)[0] for X in self.plot_x_vals]\n                        self.plot_y_vals = np.asarray(self.plot_y_vals)\n                        \n                        if type(self.plot_y_vals) == int or type(self.plot_y_vals) == float or self.plot_y_vals.shape == 1:\n                            self.plot_y_vals = np.full_like(self.plot_x_vals , self.plot_y_vals)\n                        if self.plot_y_vals.shape != self.plot_x_vals.shape:\n                            raise Exception(""Dimensions do not match"")\n                        self.Notify(NC(2,msg=""Could not calculate plot with sympy.\\nInstead using numpy to generate the data for the function and scipy to generate the integral of this data.""\n                                                +""\\nWARNING: The displayed plot is not the plot of the input integral but of the integral of the plot of the function."",exc=TheException,func=""AMaS.Plot_2D_Calc_Values"",send=False))\n                    else:\n                        raise Exception(""Can not calculate plot data"")\n                except common_exceptions: #as inst:\n                    self.Notify(NC(1,""Could not calculate values for plot"",func=""AMaS.Plot_2D_Calc_Values"",exc=sys.exc_info(),send=False))\n                    np.seterrcall(oldErrCall)\n                    scipy.seterrcall(oldErrCall_sp)\n                    return False\n                finally:\n                    np.warnings.showwarning = oldNPWarn\n                    warnings.showwarning = oldWarn\n                    self.warningMutex.unlock()\n                    \n            self.plot_data_exists = True\n            np.seterrcall(oldErrCall)\n            scipy.seterrcall(oldErrCall_sp)\n            return True\n        else:\n            np.seterrcall(oldErrCall)\n            scipy.seterrcall(oldErrCall_sp)\n            return False\n\n\n # ---------------------------------- Variable (and Multi-Dim) Methods ----------------------------------\n\n    def AddVariable(self, Name, Value):\n        self.Variables[Name] = Value\n        self.VariablesUnev[Name] = sympy.UnevaluatedExpr(Value)\n        return True\n\n    def UpdateEquation(self, Text = None):\n        try:\n            if Text == None:\n                Text = self.Input\n            else:\n                self.Input = Text\n            self.string = Text\n            self.init_Critical()\n            \n            temp = self.Text\n            for i,v in self.Variables.items():\n                temp = re.sub(""((?<!\\w)|(?<=\\d))""+str(i)+""(?!\\w)"",str(v),temp) # pylint: disable=anomalous-backslash-in-string\n            self.Text = temp\n            \n            self.Evaluate()\n            #self.cstr = self.Solution\n            self.ConvertToLaTeX()\n            return True\n        except common_exceptions:\n            self.Notify(NC(lvl=1,msg=""Could not update Equation"",exc=sys.exc_info(),func=""AMaS.UpdateEquation"",send=False))\n            return False\n\n\n # ---------------------------------- ... ----------------------------------\n\n\n'"
AMaDiA_Files/AMaDiA_Functions.py,0,"b'# This Python file uses the following encoding: utf-8\n\n# if__name__ == ""__main__"":\n#     pass\n\nfrom AGeLib.exc import *\n\nimport sys \nsys.path.append(\'..\')\nimport subprocess\nfrom PyQt5 import QtWidgets,QtCore,QtGui # Maybe Needs a change of the interpreter of Qt Creator to work there\nimport socket\nimport datetime\nimport time\nfrom time import time as timetime\nimport platform\nimport errno\nimport os\nimport sympy\nimport re\nimport traceback\n\n\nfrom sympy.parsing.sympy_parser import parse_expr\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import colors\n\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\n\nimport importlib\n\nfrom distutils.spawn import find_executable\nif find_executable(\'latex\') and find_executable(\'dvipng\'): LaTeX_dvipng_Installed = True\nelse : LaTeX_dvipng_Installed = False\n\ndef ReloadModules():\n    importlib.reload(AC)\n    importlib.reload(ART)\n\n\n# -----------------------------------------------------------------------------------------------------------------\n\n\nbackground_Colour = (54/255, 57/255, 63/255)\n\nfrom AMaDiA_Files import AMaDiA_Classes as AC\n# -----------------------------------------------------------------------------------------------------------------\n\ndef cTimeStr():\n    """"""\n    Returns the time (excluding seconds) as a string\\n\n    %H:%M\n    """"""\n    return str(datetime.datetime.now().strftime(\'%H:%M\'))\n\ndef cTimeSStr():\n    """"""\n    Returns the time (including seconds) as a string\\n\n    %H:%M:%S\n    """"""\n    return str(datetime.datetime.now().strftime(\'%H:%M:%S\'))\n\ndef cTimeFullStr(separator = None):\n    """"""\n    Returns the date and time as a string\\n\n    If given uses `separator` to separate the values\\n\n    %Y.%m.%d-%H:%M:%S or separator.join([\'%Y\',\'%m\',\'%d\',\'%H\',\'%M\',\'%S\'])\n    """"""\n    if separator == None:\n        return str(datetime.datetime.now().strftime(\'%Y.%m.%d-%H:%M:%S\'))\n    else:\n        TheFormat = separator.join([\'%Y\',\'%m\',\'%d\',\'%H\',\'%M\',\'%S\'])\n        return str(datetime.datetime.now().strftime(TheFormat))\n\ndef takeFirst(elem):\n    return elem[0]\ndef takeSecond(elem):\n    return elem[1]\n\ndef FindNthOccurrence(string, toFind, n=1, start=0, end=0):\n    """"""Finds nth occurrence of toFind in string between start and end\\n\n    returns the index or -1 if not found""""""\n    if end == 0:\n        end = len(string)\n    val = start - 1\n    for i in range(0, n):  # pylint: disable=unused-variable\n        val = string.find(toFind, val + 1, end)\n        if val == -1:\n            return val\n    return val\n\n\ndef FindPair(string, AB, start=0, end=0, listlist=ART.LIST_l_normal_pairs):\n    """"""\n    Finds the first occurrence of A and the nth occurrence of B with n being the amount of occurrence of A between the A and the nth B\\n\n    recognizes all pairs so that it returns -1 for ""({)}"" when searching for [""("","")""]\\n\n    \\n\n    DOES NOT WORK YET IF AT LEAST 2 OPENING TOO MANY\n    """"""\n    # FIXME: DOES NOT WORK IF AT LEAST 2 OPENING TOO MANY\n    if end == 0:\n        end = len(string)+1\n    if start >= end-1 or start<0 or end > len(string)+1 or start<0 or start >= end:\n        return(-1,-1)\n    Apos = string.find(AB[0], start, end)\n    if Apos==-1:\n        return(-1,-1)\n    try:\n        if end < 0 or ( AB[1] != ""d"" and string.find(AB[1], Apos, end) == -1 ) or ( AB[1] == ""d"" and re.search(r""(?<![^\\W\\d])d(?=[^\\W\\d](?![^\\W\\d]))"",string[Apos:end-1]) == None ):\n            return(Apos,-1)\n    except:\n        pass\n    tApos = -1\n    for k in listlist:\n        for o in k:\n            index = string.find(o[0], Apos+len(AB[0]), end)\n            if not index == -1 and ( tApos == -1 or index < tApos ):\n                tApos = index\n    if tApos == -1:\n        #return FindPair_simple(string,AB,start,end)\n        #Bpos = string.find(AB[1], Apos+len(AB[0]), end)\n        if AB[1] == ""d"":\n            try:\n                Bpos = re.search(r""(?<![^\\W\\d])d(?=[^\\W\\d](?![^\\W\\d]))"", string[Apos+len(AB[0]):end-1] ).start() + Apos + len(AB[0])\n            except:\n                Bpos = string.find(AB[1], Apos+len(AB[0]), end)\n        else:\n            Bpos = string.find(AB[1], Apos+len(AB[0]), end)\n        return(Apos, Bpos)\n    \n    BlockEnd = FindEndOfBlock(string, AB[1], listlist, Apos+len(AB[0]), end)\n    if BlockEnd <= start or BlockEnd <= 0 or BlockEnd >= end or BlockEnd==-1:\n        return(Apos, -1)\n    if AB[1] == ""d"":\n        try:\n            Bpos = re.search(r""(?<![^\\W\\d])d(?=[^\\W\\d](?![^\\W\\d]))"", string[BlockEnd:end-1] ).start() + BlockEnd\n        except:\n            Bpos = string.find(AB[1], BlockEnd, end)\n    else:\n        Bpos = string.find(AB[1], BlockEnd, end)\n    return(Apos, Bpos)\n\ndef FindEndOfBlock(string, Target, listlist, start=0, end=0):\n    if end == 0:\n        end = len(string)+1\n    if start >= end:\n        return start\n    if Target == ""d"":\n        try:\n            tApos = re.search(r""(?<![^\\W\\d])d(?=[^\\W\\d](?![^\\W\\d]))"",string[start:end-1]).start() + start\n        except:\n            tApos = string.find(Target, start, end)\n    else:\n        tApos = string.find(Target, start, end)\n    isEnd = True\n    for k in listlist:\n        for o in k:\n            index = string.find(o[0], start, end)\n            if not index == -1 and index <= tApos:\n                tApos = index\n                isEnd = False\n                CurrentPair = o\n    if isEnd:\n        return start\n    nStart = FindPair(string, CurrentPair, start, end, listlist)[1] + len(CurrentPair[1])\n    if nStart == -1 or nStart <= start:\n        return start\n    else:\n        return FindEndOfBlock(string, Target, listlist, nStart, end)\n\n\ndef FindPair_simple(string, AB, start=0, end=0):\n    """"""Finds the first occurrence of A and the nth occurrence of B with n being the amount of occurrence of A between the A and the nth B""""""\n    if end == 0:\n        end = len(string)+1\n    Apos = string.find(AB[0], start, end)\n    if Apos==-1:\n        return(-1,-1)\n        \n    Bpos = string.find(AB[1], Apos, end)\n    As = string.count(AB[0], Apos, Bpos+len(AB[1]))\n    if As==0:\n        return(Apos, Bpos)\n    \n    while True:\n        Bpos = FindNthOccurrence(string, AB[1], As, Apos, end)\n        As = string.count(AB[0], Apos, Bpos+len(AB[1]))\n        Bs = string.count(AB[1], Apos, Bpos+len(AB[1]))\n        if As==Bs:\n            return(Apos, Bpos)\n        if Bpos == -1:\n            return(Apos, Bpos)\n\nclass Counterpart_Result_List:\n    def __init__(self,Both):\n        self.List = []\n        self.Both = Both\n        self.FirstResult = None\n\n    def append(self , x):\n        self.List.append(x)\n        return self\n        \n    def __getitem__(self, key):\n        if self.Both and type(self.FirstResult) == list:\n            return self.FirstResult[key]\n        else:\n            return self.List[key]\n    \n    def __len__(self):\n        return len(self.List)\n\n    def __iadd__(self,value):\n        if len(self.List) == 0:\n            self.FirstResult = value\n        self.List.append(value)\n        return self\n\n    def __call__(self):\n        return self.FirstResult\n\n    def __repr__(self):\n        return self.FirstResult\n\n    def __str__(self):\n        return str(self.FirstResult)\n\n    def __contains__(self,keyword): # FIXME: Does not work as it opens all internal lists as well...\n        return keyword in self.List\n\n    def HalfList(self,Column):\n        if self.Both:\n            t = []\n            for i in self.List:\n                t.append(i[Column])\n            return t\n        else:\n            return self.FirstResult\n            \ndef Counterpart(String,ListOfLists=ART.LIST_l_all_pairs,Both=False):\n    result = Counterpart_Result_List(Both)\n    for i in ListOfLists:\n        for j in i:\n            if String == j[0]:\n                result += j[1] if not Both else j\n            elif String == j[1]:\n                result += j[0] if not Both else j\n    if len(result)>=1:\n        return result\n    ErrMsg = String+"" has no counterpart""\n    raise Exception(ErrMsg)\n    \n\n# -----------------------------------------------------------------------------------------------------------------\n\ndef LaTeX(expr,local_dict=None,evalf=1):\n    """"""This function parses a string into a sympy construct without evaluating anything!""""""\n    global_dict = {}\n    exec(\'from sympy import *\', global_dict)\n    if QtWidgets.QApplication.instance().optionWindow.cb_U_EnableUnits.isChecked():\n        exec(\'from sympy.physics.units import *\', global_dict)\n    try:\n        expr = Matrix_Encaser(expr)\n    except common_exceptions:\n        ExceptionOutput(sys.exc_info())\n    \n    sl = expr.split("","")\n    l = []\n    c = """"\n    for i in sl:\n        if c.count(""("")+i.count(""("")==c.count("")"")+i.count("")"") and c.count(""["")+i.count(""["")==c.count(""]"")+i.count(""]""):\n            if c.strip()=="""":\n                isl = i.split(""="")\n            else:\n                isl = (c+"",""+i).split(""="")\n            il = []\n            ic = """"\n            for j in isl:\n                if ic.count(""("")+j.count(""("")==ic.count("")"")+j.count("")"") and ic.count(""["")+j.count(""["")==ic.count(""]"")+j.count(""]""):\n                    if ic.strip() == """":\n                        il.append(_LaTeX_helper(j.strip(),local_dict,global_dict,evalf))\n                    else:\n                        il.append(_LaTeX_helper(ic+""=""+j.strip(),local_dict,global_dict,evalf))\n                    ic = """"\n                else:\n                    if ic.strip() != """":\n                        ic = ic + ""="" + j\n                    else:\n                        ic = j\n            l.append(""="".join(il))\n            c = """"\n        else:\n            if c.strip() != """":\n                c = c + "","" + i\n            else:\n                c = i\n    \n    rtnexpr = "","".join(l)\n    \n    return rtnexpr # _LaTeX_helper(expr,local_dict,global_dict,evalf)\n\ndef _LaTeX_helper(expr,local_dict,global_dict,evalf):\n    if expr.strip() == """": return expr\n    try:\n        if evalf == 2 or type(evalf)==bool and evalf == True:\n            if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""True"")\n            expr = expr.replace(""evalf"","""",1)\n            rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict,global_dict=global_dict)\n            rtnexpr = sympy.latex(rtnexpr)\n        elif evalf == 1 or type(evalf)==bool and evalf == False:\n            if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""False"")\n            rtnexpr = parse_expr(expr,evaluate=False,local_dict=local_dict,global_dict=global_dict)\n            rtnexpr = sympy.latex(rtnexpr)\n            try:\n                if parse_expr(expr,local_dict=local_dict,global_dict=global_dict) - sympy.parsing.latex.parse_latex(rtnexpr) != 0:\n                    rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict,global_dict=global_dict)\n                    rtnexpr = sympy.latex(rtnexpr)\n            except common_exceptions:\n                rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict,global_dict=global_dict)\n                rtnexpr = sympy.latex(rtnexpr)\n        elif not QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked():\n            rtnexpr = parse_expr(expr,evaluate=False,local_dict=local_dict,global_dict=global_dict)\n            rtnexpr = sympy.latex(rtnexpr)\n\n        else:\n            try:\n                if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""File"")\n                Path = os.path.dirname(__file__)\n                #if platform.system() == \'Windows\':\n                #    Path += r""\\NoEvalParse.py""\n                #elif platform.system() == \'Linux\':\n                #    Path += r""/NoEvalParse.py""\n                Path = os.path.join(Path,""NoEvalParse.py"")\n                rtnexpr = subprocess.check_output([sys.executable, Path, expr])#, local_dict]) # IMPROVE: Make local_dict work\n                rtnexpr = rtnexpr.decode(""utf8"")\n                sympy.evaluate(True)\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n                if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""Failed-->False"")\n                sympy.evaluate(True)\n                rtnexpr = parse_expr(expr,evaluate=False,local_dict=local_dict)\n                rtnexpr = sympy.latex(rtnexpr)\n                try:\n                    if parse_expr(expr,local_dict=local_dict) - sympy.parsing.latex.parse_latex(rtnexpr) != 0:\n                        rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                        rtnexpr = sympy.latex(rtnexpr)\n                except common_exceptions:\n                    rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                    rtnexpr = sympy.latex(rtnexpr)\n    except common_exceptions:\n        ExceptionOutput(sys.exc_info())\n        if ""="" in expr:\n            if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""Failed--> = detected --> Special Treatment"")\n            try:\n                rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                rtnexpr = sympy.latex(rtnexpr)\n                try:\n                    if parse_expr(expr,local_dict=local_dict) - sympy.parsing.latex.parse_latex(rtnexpr) != 0:\n                        rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                        rtnexpr = sympy.latex(rtnexpr)\n                except common_exceptions:\n                    rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                    rtnexpr = sympy.latex(rtnexpr)\n            except:\n                eq = expr.split(""="",1)\n                c = eq[0].rsplit(""("",1) + eq[1].split("")"",1)\n                rtnexpr = sympy.latex(parse_expr(c[0],evaluate=False,local_dict=local_dict,global_dict=global_dict)) + ""("" + \\\n                          sympy.latex(parse_expr(c[1],evaluate=False,local_dict=local_dict,global_dict=global_dict)) + ""="" + \\\n                          sympy.latex(parse_expr(c[2],evaluate=False,local_dict=local_dict,global_dict=global_dict)) + "")""\n                if len(c) == 4:\n                    if c[3].strip() != """":\n                        rtnexpr += sympy.latex(parse_expr(c[3],evaluate=False,local_dict=local_dict,global_dict=global_dict))\n        else:\n            if QtWidgets.QApplication.instance().optionWindow.cb_D_NoEvalFile.isChecked(): print(""Failed-->True"")\n            sympy.evaluate(True)\n            rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n            rtnexpr = sympy.latex(rtnexpr)\n            try:\n                if parse_expr(expr,local_dict=local_dict) - sympy.parsing.latex.parse_latex(rtnexpr) != 0:\n                    rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                    rtnexpr = sympy.latex(rtnexpr)\n            except common_exceptions:\n                rtnexpr = parse_expr(expr,evaluate=True,local_dict=local_dict)\n                rtnexpr = sympy.latex(rtnexpr)\n    \n    return rtnexpr\n\ndef Matrix_Encaser(string):\n    if ""Matrix("" in string:\n        Before,Matrix = string.split(""Matrix("",1)\n        Before = Before + ""UnevaluatedExpr(Matrix""\n        Matrix = ""(""+Matrix\n        Matrix = Matrix_Encaser(Matrix)\n        Close = FindPair(Matrix,[""("","")""])[1]\n        M,A = Matrix[:Close],Matrix[Close:]\n        A = "")""+A\n        string = Before+M+A\n    return string\n    \n\n# -----------------------------------------------------------------------------------------------------------------\n# Useful links:\n    # https://pypi.org/project/parse/  # New library not in Anaconda so probably not good to use...\n    # https://pyformat.info/\n    # https://docs.python.org/3.4/library/string.html\n\ndef parse(string):\n    """"""Returns the sympy object of a string""""""\n    return parse_expr(AstusParse(string,False))\n\ndef AstusParse(string,ConsoleOutput = True, Iam = AC.Iam_Normal ,LocalVars = None):\n    # FEATURE: MultiDim support\n    # If Iam_Multi_Dim replace everything except multiplication signs\n    # Then search with re for the LocalVars\n    # Then Parse the multiplication signs in accordance to the position of the LocalVars\n    \n    string = re.sub(r""\xe2\x88\x9a(\\w+)"",r""sqrt(\\1)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\\'\\\'\\(([^\\W\\d\xcf\x80])\\)"",r""diff(diff(diff(diff(diff(\\1(\\2),\\2),\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\""\\""\\\'\\(([^\\W\\d\xcf\x80])\\)""  ,  r""diff(diff(diff(diff(diff(\\1(\\2),\\2),\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\\'\\(([^\\W\\d\xcf\x80])\\)"",r""diff(diff(diff(diff(\\1(\\2),\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\""\\""\\(([^\\W\\d\xcf\x80])\\)""  ,  r""diff(diff(diff(diff(\\1(\\2),\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\(([^\\W\\d\xcf\x80])\\)"",r""diff(diff(diff(\\1(\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\""\\\'\\(([^\\W\\d\xcf\x80])\\)"" , r""diff(diff(diff(\\1(\\2),\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\(([^\\W\\d\xcf\x80])\\)"",r""diff(diff(\\1(\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\""\\(([^\\W\\d\xcf\x80])\\)"" , r""diff(diff(\\1(\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\\'\\(([^\\W\\d\xcf\x80])\\)"",r""diff(\\1(\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\\'\\\'\\(\\d\\)"",r""diff(diff(diff(diff(diff(\\1(x),x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\""\\\'\\(\\d\\)""  ,  r""diff(diff(diff(diff(diff(\\1(x),x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\\'\\(\\d\\)"",r""diff(diff(diff(diff(\\1(x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\""\\(\\d\\)""  ,  r""diff(diff(diff(diff(\\1(x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\(\\d\\)"",r""diff(diff(diff(\\1(x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\\'\\(\\d\\)"" , r""diff(diff(diff(\\1(x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\(\\d\\)"",r""diff(diff(\\1(x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\(\\d\\)"" , r""diff(diff(\\1(x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\(\\d\\)"",r""diff(\\1(x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'\\\'"",r""diff(diff(diff(diff(\\1(x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\""""  ,  r""diff(diff(diff(diff(\\1(x),x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'\\\'"",r""diff(diff(diff(\\1(x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\""\\\'"" , r""diff(diff(diff(\\1(x),x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'\\\'"",r""diff(diff(\\1(x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\"""",r""diff(diff(\\1(x),x),x)"",string)\n    string = re.sub(r""(\\w+)\\\'"",r""diff(\\1(x),x)"",string)\n    string = re.sub(r""(\\w+)\\u0308\\(([^\\W\\d\xcf\x80])\\)"",r""diff(diff(\\1(\\2),\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\u0307\\(([^\\W\\d\xcf\x80])\\)"",r""diff(\\1(\\2),\\2)"",string)\n    string = re.sub(r""(\\w+)\\u0308\\(\\d\\)"",r""diff(diff(\\1(t),t),t)"",string)\n    string = re.sub(r""(\\w+)\\u0307\\(\\d\\)"",r""diff(\\1(t),t)"",string)\n    string = re.sub(r""(\\w+)\\u0308\\u0307"",r""diff(diff(diff(\\1(t),t),t),t)"",string)\n    string = re.sub(r""(\\w+)\\u0308"",r""diff(diff(\\1(t),t),t)"",string)\n    string = re.sub(r""(\\w+)\\u0307"",r""diff(\\1(t),t)"",string)\n    string = Replace(string,ART.LIST_n_all)\n    string = Replace(string,ART.LIST_r_s_scripts)\n    #----\n    #---- Temporary Integral Handling for Astus\' Integral Syntax\n    string = IntegralParser_Astus(string)\n    #----\n    string = IntegralParser(string)\n    string = Derivative_and_IndefiniteIntegral_Parser(string) # Do this after all other integral parsers\n    \n    \n    # Getting rid of not interpretable brackets\n    # string = NonInterpretableBracketReplace(string)\n    \n    \n    # Add multiplication signs where a human might leave them out\n    string = string.replace("")("","")*("") # Add them between brackets\n    string = re.sub(r""((?:\\d+)|(?:[a-zA-Z]\\w*\\(\\w+\\)))((?:[a-zA-Z]\\w*)|\\()"", r""\\1*\\2"", string)\n\n    # string = UnpackDualOperators(string) # This does not work here if ""="" is used so this is instead implemented in the calculation method\n    if ConsoleOutput:\n        print(""Input parsed: "",string)\n    return string\n\ndef IntegralParser_Astus(string):\n    if ""Integral{("" in string:\n        Before,From = string.split(""Integral{("",1)\n        From,To = From.split("")("",1)\n        To,Func = To.split("")}"",1)\n        Func = IntegralParser_Astus(Func) # Find other integrals if there are any and handle them\n        #Func,After = Func.split(""d"",1)\n        Func,After = re.split(r""(?<![^\\W\\d])d(?=[^\\W\\d](?![^\\W\\d]))"",Func,1)\n        try:\n            if Func[-1]==""*"":\n                Func = Func[:-1]\n        except:\n            pass\n        x = After[0]\n        After = After[1:]\n        string = Before + "" Integral("" + Func + "",(""+x+"",""+From+"",""+To+""))"" + After\n    return string\n    \ndef IntegralParser(string):\n    #FEATURE: Make IntegralParser work for user-defined Syntax\n    return string\n\ndef Derivative_and_IndefiniteIntegral_Parser(string):\n    for i in ART.l_pairs_special_I_D:\n        amount = string.count(i[0])\n        counter = 0\n        if amount > 0:\n            start = 0\n            while counter < amount:\n                Pair = FindPair(string, i,start=start)\n                if not Pair[0] == -1 and not Pair[1] == -1:\n                    A,B,C = string[:Pair[0]] , string[Pair[0]:Pair[1]] , string[Pair[1]:]\n                    B = B.replace(i[0],i[2],1)\n                    if B[-1] == ""*"":\n                        B = B[:-1]\n                    x , C = C[len(i[1]):len(i[1])+1] , C[len(i[1])+1:]\n                    B += "","" \n                    B += x\n                    B += "")""\n                    string = A+B\n                    string += C\n                    counter+=1\n                    start = Pair[0]+len(i[0])\n                else:\n                    break\n    return string\n\ndef NonInterpretableBracketReplace(string):\n    for i in ART.l_pairs_brackets_not_interpretable:\n        string = string.replace(i[0],""("")\n        string = string.replace(i[1],"")"")\n    return string\n\n""""""\n\n    for i in ART:\n        string.replace(i[0],i[1])\n    \n""""""\n""""""\n\n    for i in ART:\n        for j in i:\n            string.replace(j[0],j[1])\n    \n""""""\n\ndef UnpackDualOperators(string,Brackets=(""["",""]"")):\n    List = [string]\n    for i in ART.n_operators_dual:\n        tList = []\n        for j in List:\n            if i[0] in j:\n                tList.extend(UnpackDualOperators_Helper(j.replace(i[0],i[1],1)))\n                tList.extend(UnpackDualOperators_Helper(j.replace(i[0],i[2],1)))\n            else:\n                tList.append(j)\n        List = tList\n    if len(List)>1:\n        string = Brackets[0]\n        for i in List:\n            string+=i\n            string+="",""\n        string = string[:-1]\n        string+= Brackets[1]\n    return string\n\ndef UnpackDualOperators_Helper(string):\n    List = [string]\n    for i in ART.n_operators_dual:\n        tList = []\n        for j in List:\n            if i[0] in j:\n                tList.extend(UnpackDualOperators_Helper(j.replace(i[0],i[1],1)))\n                tList.extend(UnpackDualOperators_Helper(j.replace(i[0],i[2],1)))\n            else:\n                tList.append(j)\n        List = tList\n    return List\n\ndef AstusParseInverse(string, Validate=False):\n    string_i = string\n    string = Replace(string,ART.n_operators)\n    string = Replace(string,ART.n_standard_integrals)\n    string = Replace(string,ART.LIST_r_s_scripts,1,0)\n    string = Replace(string,ART.LIST_n_invertable,1,0)\n    for i in ART.n_greek_letters_nospace:\n        string = re.sub(r""(?<!\\w){}(?!\\w)"".format(i[1]),i[0],string) \n        \n    #string = string.replace("" * "","" \xc2\xb7 "")\n    \n    \n    # TODO: Use this check\n    if (not Validate) or string_i == AstusParse(string,False):\n        return string\n    else:\n        return string_i\n\n\ndef Replace(string,List,a=0,b=1):\n    """"""\n    Replaces everything in string that is in List[][a] with List[][b]\\n\n    The List must only contain lists with that all contain at least two strings or Lists that contain such lists\\n\n    Alternatively takes a dictionary and replaces all keys in the string with their Value\n    """"""\n    if type(List) == dict:\n        for Key, Value in List.items():\n            string = string.replace(Key,str(Value))\n    elif len(List) > 0 and len(List[0]) > 0:\n        if type(List[0][0]) == list:\n            for i in List:\n                string = Replace(string,i,a,b)\n        elif type(List[0][0]) == str:\n            for i in List:\n                string = string.replace(i[a],i[b])\n    return string\n\n# -----------------------------------------------------------------------------------------------------------------\n\ndef number_shaver(ch,\n                  expr = re.compile(\'(?<![\\d.])0*(?:\'               # pylint: disable=anomalous-backslash-in-string\n                                    \'(\\d+)\\.?|\\.(0)\'                # pylint: disable=anomalous-backslash-in-string\n                                    \'|(\\.\\d+?)|(\\d+\\.\\d+?)\'         # pylint: disable=anomalous-backslash-in-string\n                                    \')0*(?![\\d.])\')  ,              # pylint: disable=anomalous-backslash-in-string\n                  repl = lambda mat: mat.group(mat.lastindex)\n                                     if mat.lastindex!=3\n                                     else \'0\' + mat.group(3) ):\n    return expr.sub(repl,ch)\n\n\ndef Digit_Grouping(text):\n    text_org = text\n    try:\n        if QtWidgets.QApplication.instance().optionWindow.cb_F_Digit_Grouping.isChecked():\n            textparts = text.split(""."")\n            textparts[0] = re.sub(r""(\\d)(?=(\\d{3})+(?!\\d))"", r""\\1,"", textparts[0])\n            i = 1\n            while i < len(textparts):\n                items = re.split(r""(\\D)"",textparts[i],1)\n                if len(items)==3:\n                    textparts[i] = items[0]+items[1]+re.sub(r""(\\d)(?=(\\d{3})+(?!\\d))"", r""\\1,"", items[2])\n                i+=1\n            text = ""."".join(textparts)\n        return text\n    except common_exceptions:\n        NC(4,""Could not apply thousand separators."",exc=sys.exc_info(),func=""Digit_Grouping"",input=text_org)\n        return text_org\n# -----------------------------------------------------------------------------------------------------------------\n\n\n# -----------------------------------------------------------------------------------------------------------------\n\ndef shape2(Item):\n    shape = getattr(Item, ""tolist"", None)\n    if callable(shape):\n        try:\n            i,j = Item.shape()\n        except common_exceptions:\n            i,j = Item.shape\n    elif shape != None:\n        i,j = Item.shape\n    else:\n        i,j = 1,1\n    return i,j\n\ndef shape3(Item):\n    shape = getattr(Item, ""tolist"", None)\n    if callable(shape):\n        try:\n            i,j,k = Item.shape()\n        except common_exceptions:\n            i,j,k = Item.shape\n    elif shape != None:\n        i,j,k = Item.shape\n    else:\n        i,j,k = 1,1,1\n    return i,j,k\n    \n# -----------------------------------------------------------------------------------------------------------------\n\n'"
AMaDiA_Files/AMaDiA_Options_UI.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'AMaDiA_Options_UI.ui\'\n#\n# Created by: PyQt5 UI code generator 5.9.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_AMaDiA_Options(object):\n    def setupUi(self, AMaDiA_Options):\n        AMaDiA_Options.setObjectName(""AMaDiA_Options"")\n        AMaDiA_Options.resize(800, 600)\n        self.centralwidget = QtWidgets.QWidget(AMaDiA_Options)\n        self.centralwidget.setObjectName(""centralwidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.tabWidget = MTabWidget(self.centralwidget)\n        self.tabWidget.setObjectName(""tabWidget"")\n        self.tab_Options = QtWidgets.QWidget()\n        self.tab_Options.setObjectName(""tab_Options"")\n        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab_Options)\n        self.gridLayout_2.setContentsMargins(9, 9, 9, 9)\n        self.gridLayout_2.setSpacing(6)\n        self.gridLayout_2.setObjectName(""gridLayout_2"")\n        self.L_O = QtWidgets.QWidget(self.tab_Options)\n        self.L_O.setObjectName(""L_O"")\n        self.gridLayout_4 = QtWidgets.QGridLayout(self.L_O)\n        self.gridLayout_4.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_4.setObjectName(""gridLayout_4"")\n        self.cb_U_EnableUnits = QtWidgets.QCheckBox(self.L_O)\n        self.cb_U_EnableUnits.setChecked(True)\n        self.cb_U_EnableUnits.setObjectName(""cb_U_EnableUnits"")\n        self.gridLayout_4.addWidget(self.cb_U_EnableUnits, 15, 0, 1, 1)\n        self.cb_O_AdvancedMode = QtWidgets.QCheckBox(self.L_O)\n        self.cb_O_AdvancedMode.setObjectName(""cb_O_AdvancedMode"")\n        self.gridLayout_4.addWidget(self.cb_O_AdvancedMode, 3, 0, 1, 1)\n        self.line_17 = QtWidgets.QFrame(self.L_O)\n        self.line_17.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_17.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_17.setObjectName(""line_17"")\n        self.gridLayout_4.addWidget(self.line_17, 14, 0, 1, 1)\n        self.cb_O_Remapper_local = QtWidgets.QCheckBox(self.L_O)\n        self.cb_O_Remapper_local.setChecked(True)\n        self.cb_O_Remapper_local.setObjectName(""cb_O_Remapper_local"")\n        self.gridLayout_4.addWidget(self.cb_O_Remapper_local, 5, 0, 1, 1)\n        self.line_2 = QtWidgets.QFrame(self.L_O)\n        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_2.setObjectName(""line_2"")\n        self.gridLayout_4.addWidget(self.line_2, 7, 0, 1, 1)\n        self.cb_O_Remapper_global = QtWidgets.QCheckBox(self.L_O)\n        self.cb_O_Remapper_global.setObjectName(""cb_O_Remapper_global"")\n        self.gridLayout_4.addWidget(self.cb_O_Remapper_global, 6, 0, 1, 1)\n        self.cb_O_PairHighlighter = QtWidgets.QCheckBox(self.L_O)\n        self.cb_O_PairHighlighter.setChecked(True)\n        self.cb_O_PairHighlighter.setObjectName(""cb_O_PairHighlighter"")\n        self.gridLayout_4.addWidget(self.cb_O_PairHighlighter, 8, 0, 1, 1)\n        self.line = QtWidgets.QFrame(self.L_O)\n        self.line.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line.setObjectName(""line"")\n        self.gridLayout_4.addWidget(self.line, 4, 0, 1, 1)\n        self.g_O_HCopyStandard = QtWidgets.QWidget(self.L_O)\n        self.g_O_HCopyStandard.setObjectName(""g_O_HCopyStandard"")\n        self.gridLayout_12 = QtWidgets.QGridLayout(self.g_O_HCopyStandard)\n        self.gridLayout_12.setObjectName(""gridLayout_12"")\n        self.comb_O_HCopyStandard = QtWidgets.QComboBox(self.g_O_HCopyStandard)\n        self.comb_O_HCopyStandard.setObjectName(""comb_O_HCopyStandard"")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.comb_O_HCopyStandard.addItem("""")\n        self.gridLayout_12.addWidget(self.comb_O_HCopyStandard, 0, 1, 1, 1)\n        self.Label_O_HCopyStandard = QtWidgets.QLabel(self.g_O_HCopyStandard)\n        self.Label_O_HCopyStandard.setWordWrap(True)\n        self.Label_O_HCopyStandard.setObjectName(""Label_O_HCopyStandard"")\n        self.gridLayout_12.addWidget(self.Label_O_HCopyStandard, 0, 0, 1, 1)\n        self.gridLayout_4.addWidget(self.g_O_HCopyStandard, 12, 0, 1, 1)\n        self.line_3 = QtWidgets.QFrame(self.L_O)\n        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_3.setObjectName(""line_3"")\n        self.gridLayout_4.addWidget(self.line_3, 10, 0, 1, 1)\n        self.line_19 = QtWidgets.QFrame(self.L_O)\n        self.line_19.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_19.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_19.setObjectName(""line_19"")\n        self.gridLayout_4.addWidget(self.line_19, 16, 0, 1, 1)\n        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        self.gridLayout_4.addItem(spacerItem, 17, 0, 1, 1)\n        self.gridLayout_2.addWidget(self.L_O, 8, 0, 1, 1)\n        self.tabWidget.addTab(self.tab_Options, """")\n        self.tab_Appearance = QtWidgets.QWidget()\n        self.tab_Appearance.setObjectName(""tab_Appearance"")\n        self.gridLayout_13 = QtWidgets.QGridLayout(self.tab_Appearance)\n        self.gridLayout_13.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_13.setSpacing(0)\n        self.gridLayout_13.setObjectName(""gridLayout_13"")\n        self.ColourPicker = OptionsWidget_1_Appearance(self.tab_Appearance)\n        self.ColourPicker.setObjectName(""ColourPicker"")\n        self.gridLayout_13.addWidget(self.ColourPicker, 0, 0, 1, 1)\n        self.tabWidget.addTab(self.tab_Appearance, """")\n        self.tab_Flags = QtWidgets.QWidget()\n        self.tab_Flags.setObjectName(""tab_Flags"")\n        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_Flags)\n        self.gridLayout_3.setContentsMargins(9, 9, 9, 9)\n        self.gridLayout_3.setSpacing(6)\n        self.gridLayout_3.setObjectName(""gridLayout_3"")\n        self.R_F = QtWidgets.QWidget(self.tab_Flags)\n        self.R_F.setObjectName(""R_F"")\n        self.gridLayout_7 = QtWidgets.QGridLayout(self.R_F)\n        self.gridLayout_7.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_7.setObjectName(""gridLayout_7"")\n        self.cb_F_cancel = QtWidgets.QCheckBox(self.R_F)\n        self.cb_F_cancel.setObjectName(""cb_F_cancel"")\n        self.gridLayout_7.addWidget(self.cb_F_cancel, 10, 0, 1, 1)\n        self.cb_F_simplify = QtWidgets.QCheckBox(self.R_F)\n        self.cb_F_simplify.setChecked(True)\n        self.cb_F_simplify.setObjectName(""cb_F_simplify"")\n        self.gridLayout_7.addWidget(self.cb_F_simplify, 2, 0, 1, 1)\n        self.cb_F_expand_trig = QtWidgets.QCheckBox(self.R_F)\n        self.cb_F_expand_trig.setObjectName(""cb_F_expand_trig"")\n        self.gridLayout_7.addWidget(self.cb_F_expand_trig, 13, 0, 1, 1)\n        self.line_8 = QtWidgets.QFrame(self.R_F)\n        self.line_8.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_8.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_8.setObjectName(""line_8"")\n        self.gridLayout_7.addWidget(self.line_8, 5, 0, 1, 1)\n        self.g_F_Exp_fac = QtWidgets.QWidget(self.R_F)\n        self.g_F_Exp_fac.setObjectName(""g_F_Exp_fac"")\n        self.gridLayout_8 = QtWidgets.QGridLayout(self.g_F_Exp_fac)\n        self.gridLayout_8.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_8.setObjectName(""gridLayout_8"")\n        self.cb_F_factor = QtWidgets.QCheckBox(self.g_F_Exp_fac)\n        self.cb_F_factor.setAutoExclusive(True)\n        self.cb_F_factor.setObjectName(""cb_F_factor"")\n        self.gridLayout_8.addWidget(self.cb_F_factor, 1, 1, 1, 1)\n        self.cb_F_expand = QtWidgets.QCheckBox(self.g_F_Exp_fac)\n        self.cb_F_expand.setAutoExclusive(True)\n        self.cb_F_expand.setObjectName(""cb_F_expand"")\n        self.gridLayout_8.addWidget(self.cb_F_expand, 1, 0, 1, 1)\n        self.cb_F_exp_fac_NONE = QtWidgets.QCheckBox(self.g_F_Exp_fac)\n        self.cb_F_exp_fac_NONE.setChecked(True)\n        self.cb_F_exp_fac_NONE.setAutoExclusive(True)\n        self.cb_F_exp_fac_NONE.setObjectName(""cb_F_exp_fac_NONE"")\n        self.gridLayout_8.addWidget(self.cb_F_exp_fac_NONE, 1, 2, 1, 1)\n        self.gridLayout_7.addWidget(self.g_F_Exp_fac, 6, 0, 1, 1)\n        self.line_10 = QtWidgets.QFrame(self.R_F)\n        self.line_10.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_10.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_10.setObjectName(""line_10"")\n        self.gridLayout_7.addWidget(self.line_10, 3, 0, 1, 1)\n        self.line_12 = QtWidgets.QFrame(self.R_F)\n        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_12.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_12.setObjectName(""line_12"")\n        self.gridLayout_7.addWidget(self.line_12, 12, 0, 1, 1)\n        self.cb_F_apart = QtWidgets.QCheckBox(self.R_F)\n        self.cb_F_apart.setObjectName(""cb_F_apart"")\n        self.gridLayout_7.addWidget(self.cb_F_apart, 11, 0, 1, 1)\n        self.cb_F_powsimp = QtWidgets.QCheckBox(self.R_F)\n        self.cb_F_powsimp.setChecked(True)\n        self.cb_F_powsimp.setObjectName(""cb_F_powsimp"")\n        self.gridLayout_7.addWidget(self.cb_F_powsimp, 4, 0, 1, 1)\n        self.line_11 = QtWidgets.QFrame(self.R_F)\n        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_11.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_11.setObjectName(""line_11"")\n        self.gridLayout_7.addWidget(self.line_11, 9, 0, 1, 1)\n        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        self.gridLayout_7.addItem(spacerItem1, 15, 0, 1, 1)\n        self.line_9 = QtWidgets.QFrame(self.R_F)\n        self.line_9.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_9.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_9.setObjectName(""line_9"")\n        self.gridLayout_7.addWidget(self.line_9, 7, 0, 1, 1)\n        self.g_F_collect = QtWidgets.QWidget(self.R_F)\n        self.g_F_collect.setObjectName(""g_F_collect"")\n        self.gridLayout_9 = QtWidgets.QGridLayout(self.g_F_collect)\n        self.gridLayout_9.setObjectName(""gridLayout_9"")\n        self.cb_F_collect = QtWidgets.QCheckBox(self.g_F_collect)\n        self.cb_F_collect.setObjectName(""cb_F_collect"")\n        self.gridLayout_9.addWidget(self.cb_F_collect, 0, 0, 1, 1)\n        self.tf_F_collect = QtWidgets.QLineEdit(self.g_F_collect)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.tf_F_collect.sizePolicy().hasHeightForWidth())\n        self.tf_F_collect.setSizePolicy(sizePolicy)\n        self.tf_F_collect.setMaxLength(20)\n        self.tf_F_collect.setObjectName(""tf_F_collect"")\n        self.gridLayout_9.addWidget(self.tf_F_collect, 1, 0, 1, 1)\n        self.gridLayout_7.addWidget(self.g_F_collect, 8, 0, 1, 1)\n        self.line_14 = QtWidgets.QFrame(self.R_F)\n        self.line_14.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_14.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_14.setObjectName(""line_14"")\n        self.gridLayout_7.addWidget(self.line_14, 14, 0, 1, 1)\n        self.gridLayout_3.addWidget(self.R_F, 3, 2, 1, 1)\n        self.L_F = QtWidgets.QWidget(self.tab_Flags)\n        self.L_F.setObjectName(""L_F"")\n        self.gridLayout_5 = QtWidgets.QGridLayout(self.L_F)\n        self.gridLayout_5.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_5.setObjectName(""gridLayout_5"")\n        spacerItem2 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        self.gridLayout_5.addItem(spacerItem2, 9, 0, 1, 1)\n        self.g_F_solveFor = QtWidgets.QWidget(self.L_F)\n        self.g_F_solveFor.setObjectName(""g_F_solveFor"")\n        self.gridLayout_10 = QtWidgets.QGridLayout(self.g_F_solveFor)\n        self.gridLayout_10.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_10.setObjectName(""gridLayout_10"")\n        self.tf_F_solveFor = QtWidgets.QLineEdit(self.g_F_solveFor)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.tf_F_solveFor.sizePolicy().hasHeightForWidth())\n        self.tf_F_solveFor.setSizePolicy(sizePolicy)\n        self.tf_F_solveFor.setMaxLength(20)\n        self.tf_F_solveFor.setObjectName(""tf_F_solveFor"")\n        self.gridLayout_10.addWidget(self.tf_F_solveFor, 0, 1, 1, 1)\n        self.cb_F_solveFor = QtWidgets.QCheckBox(self.g_F_solveFor)\n        self.cb_F_solveFor.setObjectName(""cb_F_solveFor"")\n        self.gridLayout_10.addWidget(self.cb_F_solveFor, 0, 0, 1, 1)\n        self.gridLayout_5.addWidget(self.g_F_solveFor, 5, 0, 1, 1)\n        self.cb_F_Digit_Grouping = QtWidgets.QCheckBox(self.L_F)\n        self.cb_F_Digit_Grouping.setChecked(True)\n        self.cb_F_Digit_Grouping.setObjectName(""cb_F_Digit_Grouping"")\n        self.gridLayout_5.addWidget(self.cb_F_Digit_Grouping, 7, 0, 1, 1)\n        self.line_6 = QtWidgets.QFrame(self.L_F)\n        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_6.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_6.setObjectName(""line_6"")\n        self.gridLayout_5.addWidget(self.line_6, 4, 0, 1, 1)\n        self.line_13 = QtWidgets.QFrame(self.L_F)\n        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_13.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_13.setObjectName(""line_13"")\n        self.gridLayout_5.addWidget(self.line_13, 6, 0, 1, 1)\n        self.cb_F_EvalF = QtWidgets.QCheckBox(self.L_F)\n        self.cb_F_EvalF.setChecked(True)\n        self.cb_F_EvalF.setObjectName(""cb_F_EvalF"")\n        self.gridLayout_5.addWidget(self.cb_F_EvalF, 3, 0, 1, 1)\n        self.line_20 = QtWidgets.QFrame(self.L_F)\n        self.line_20.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_20.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_20.setObjectName(""line_20"")\n        self.gridLayout_5.addWidget(self.line_20, 8, 0, 1, 1)\n        self.gridLayout_3.addWidget(self.L_F, 3, 0, 1, 1)\n        self.Label_FlagExplanation = QtWidgets.QLabel(self.tab_Flags)\n        self.Label_FlagExplanation.setWordWrap(True)\n        self.Label_FlagExplanation.setObjectName(""Label_FlagExplanation"")\n        self.gridLayout_3.addWidget(self.Label_FlagExplanation, 1, 0, 1, 3)\n        self.line_4 = QtWidgets.QFrame(self.tab_Flags)\n        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_4.setObjectName(""line_4"")\n        self.gridLayout_3.addWidget(self.line_4, 2, 0, 1, 3)\n        self.line_7 = QtWidgets.QFrame(self.tab_Flags)\n        self.line_7.setFrameShape(QtWidgets.QFrame.VLine)\n        self.line_7.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_7.setObjectName(""line_7"")\n        self.gridLayout_3.addWidget(self.line_7, 3, 1, 1, 1)\n        self.tabWidget.addTab(self.tab_Flags, """")\n        self.tab_DevOptions = QtWidgets.QWidget()\n        self.tab_DevOptions.setObjectName(""tab_DevOptions"")\n        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab_DevOptions)\n        self.gridLayout_6.setContentsMargins(9, 9, 9, 9)\n        self.gridLayout_6.setObjectName(""gridLayout_6"")\n        self.L_D = QtWidgets.QWidget(self.tab_DevOptions)\n        self.L_D.setObjectName(""L_D"")\n        self.gridLayout_11 = QtWidgets.QGridLayout(self.L_D)\n        self.gridLayout_11.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_11.setObjectName(""gridLayout_11"")\n        self.line_16 = QtWidgets.QFrame(self.L_D)\n        self.line_16.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_16.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_16.setObjectName(""line_16"")\n        self.gridLayout_11.addWidget(self.line_16, 1, 0, 1, 1)\n        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)\n        self.gridLayout_11.addItem(spacerItem3, 4, 0, 1, 1)\n        self.cb_D_NewSolver = QtWidgets.QCheckBox(self.L_D)\n        self.cb_D_NewSolver.setObjectName(""cb_D_NewSolver"")\n        self.gridLayout_11.addWidget(self.cb_D_NewSolver, 0, 0, 1, 1)\n        self.cb_D_NoEvalFile = QtWidgets.QCheckBox(self.L_D)\n        self.cb_D_NoEvalFile.setObjectName(""cb_D_NoEvalFile"")\n        self.gridLayout_11.addWidget(self.cb_D_NoEvalFile, 2, 0, 1, 1)\n        self.line_18 = QtWidgets.QFrame(self.L_D)\n        self.line_18.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_18.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_18.setObjectName(""line_18"")\n        self.gridLayout_11.addWidget(self.line_18, 3, 0, 1, 1)\n        self.gridLayout_6.addWidget(self.L_D, 2, 0, 1, 1)\n        self.Label_DevOption_Explanation = QtWidgets.QLabel(self.tab_DevOptions)\n        self.Label_DevOption_Explanation.setWordWrap(True)\n        self.Label_DevOption_Explanation.setObjectName(""Label_DevOption_Explanation"")\n        self.gridLayout_6.addWidget(self.Label_DevOption_Explanation, 0, 0, 1, 1)\n        self.line_15 = QtWidgets.QFrame(self.tab_DevOptions)\n        self.line_15.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_15.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_15.setObjectName(""line_15"")\n        self.gridLayout_6.addWidget(self.line_15, 1, 0, 1, 1)\n        self.tabWidget.addTab(self.tab_DevOptions, """")\n        self.gridLayout.addWidget(self.tabWidget, 0, 0, 1, 1)\n        AMaDiA_Options.setCentralWidget(self.centralwidget)\n\n        self.retranslateUi(AMaDiA_Options)\n        self.tabWidget.setCurrentIndex(0)\n        QtCore.QMetaObject.connectSlotsByName(AMaDiA_Options)\n\n    def retranslateUi(self, AMaDiA_Options):\n        _translate = QtCore.QCoreApplication.translate\n        AMaDiA_Options.setWindowTitle(_translate(""AMaDiA_Options"", ""MainWindow""))\n        self.cb_U_EnableUnits.setToolTip(_translate(""AMaDiA_Options"", ""If checked the calculator is sensitive for units.<br>\\n""\n""For example m is no longer a variable but instead \\""meter\\"".""))\n        self.cb_U_EnableUnits.setText(_translate(""AMaDiA_Options"", ""Enable Units""))\n        self.cb_O_AdvancedMode.setToolTip(_translate(""AMaDiA_Options"", ""If checked more notifications are displayed, more context menu options are displayed and various other functions become available.<br>\\n""\n""This can clutter the context menus, flood you with neglectable errors and unlock dangerous functions that should only be used if you know what you are doing.""))\n        self.cb_O_AdvancedMode.setText(_translate(""AMaDiA_Options"", ""Advanced Mode""))\n        self.cb_O_Remapper_local.setToolTip(_translate(""AMaDiA_Options"", ""<html><head/><body><p>Use (Shift+)AltGr+Key to type Mathematical Symbols.<br/>Refer to AMaDiA_ReplacementTables for mapping.<br/>For a Remapping that works on all applications use the Global Remapper in the Options.</p></body></html>""))\n        self.cb_O_Remapper_local.setText(_translate(""AMaDiA_Options"", ""Local Keyboard Remapper""))\n        self.cb_O_Remapper_global.setToolTip(_translate(""AMaDiA_Options"", ""<html><head/><body><p>Use (Shift+)AltGr+Key to type Mathematical Symbols.<br/>Refer to AMaDiA_ReplacementTables for mapping.<br/>This works for all inputs including those in other applications!<br/>(This might cause problems with anti cheat systems in games. Use with care.)</p></body></html>""))\n        self.cb_O_Remapper_global.setText(_translate(""AMaDiA_Options"", ""Global Keyboard Remapper""))\n        self.cb_O_PairHighlighter.setToolTip(_translate(""AMaDiA_Options"", ""Syntax highlighter for brackets, Integrals, etc.""))\n        self.cb_O_PairHighlighter.setText(_translate(""AMaDiA_Options"", ""Pair Highlighter""))\n        self.comb_O_HCopyStandard.setItemText(0, _translate(""AMaDiA_Options"", ""Normal""))\n        self.comb_O_HCopyStandard.setItemText(1, _translate(""AMaDiA_Options"", ""Solution""))\n        self.comb_O_HCopyStandard.setItemText(2, _translate(""AMaDiA_Options"", ""Equation""))\n        self.comb_O_HCopyStandard.setItemText(3, _translate(""AMaDiA_Options"", ""Text""))\n        self.comb_O_HCopyStandard.setItemText(4, _translate(""AMaDiA_Options"", ""LaTeX""))\n        self.comb_O_HCopyStandard.setItemText(5, _translate(""AMaDiA_Options"", ""LaTeX Equation""))\n        self.Label_O_HCopyStandard.setText(_translate(""AMaDiA_Options"", ""Set what ctrl+c should try to copy when having a single history item selected""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_Options), _translate(""AMaDiA_Options"", ""Options""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_Appearance), _translate(""AMaDiA_Options"", ""Appearance""))\n        self.cb_F_cancel.setToolTip(_translate(""AMaDiA_Options"", ""Will take any rational function and put it into the standard canonical form p/q""))\n        self.cb_F_cancel.setText(_translate(""AMaDiA_Options"", ""Cancel""))\n        self.cb_F_simplify.setToolTip(_translate(""AMaDiA_Options"", ""Applies standard simplifications""))\n        self.cb_F_simplify.setText(_translate(""AMaDiA_Options"", ""Simplify""))\n        self.cb_F_expand_trig.setToolTip(_translate(""AMaDiA_Options"", ""Set this to expand trigonometric functions, that is, apply the sum or double angle identities""))\n        self.cb_F_expand_trig.setText(_translate(""AMaDiA_Options"", ""Expand trigonometric functions""))\n        self.cb_F_factor.setToolTip(_translate(""AMaDiA_Options"", ""Takes a polynomial and factors it into irreducible factors (Inverse of expand)""))\n        self.cb_F_factor.setText(_translate(""AMaDiA_Options"", ""Factor""))\n        self.cb_F_expand.setToolTip(_translate(""AMaDiA_Options"", ""Solves all multiplications and powers""))\n        self.cb_F_expand.setText(_translate(""AMaDiA_Options"", ""Expand""))\n        self.cb_F_exp_fac_NONE.setText(_translate(""AMaDiA_Options"", ""None""))\n        self.cb_F_apart.setToolTip(_translate(""AMaDiA_Options"", ""Performs a partial fraction decomposition on a rational function""))\n        self.cb_F_apart.setText(_translate(""AMaDiA_Options"", ""Apart""))\n        self.cb_F_powsimp.setToolTip(_translate(""AMaDiA_Options"", ""Simplifies/Collects exponents""))\n        self.cb_F_powsimp.setText(_translate(""AMaDiA_Options"", ""Simplify exponents""))\n        self.cb_F_collect.setToolTip(_translate(""AMaDiA_Options"", ""Collects common powers of a term in an expression""))\n        self.cb_F_collect.setText(_translate(""AMaDiA_Options"", ""Collect term:""))\n        self.tf_F_collect.setText(_translate(""AMaDiA_Options"", ""x""))\n        self.tf_F_solveFor.setText(_translate(""AMaDiA_Options"", ""y""))\n        self.cb_F_solveFor.setToolTip(_translate(""AMaDiA_Options"", ""Set the variables for which equations should be solved.<br>\\n""\n""You can separate variables with commas to create a priority list.<br>\\n""\n""If turned off the variable will be automatically determined based on the equation.""))\n        self.cb_F_solveFor.setText(_translate(""AMaDiA_Options"", ""Solve for Variable:""))\n        self.cb_F_Digit_Grouping.setToolTip(_translate(""AMaDiA_Options"", ""If checked the display in the calculator tab groups digits.<br>\\n""\n""For example 5000666.12345 is displayed as 5,000,666.12345<br>\\n""\n""This only influences the displayed text and does not change anything else.""))\n        self.cb_F_Digit_Grouping.setText(_translate(""AMaDiA_Options"", ""Group digits for display""))\n        self.cb_F_EvalF.setToolTip(_translate(""AMaDiA_Options"", ""If unchecked functions that would return a float are not evaluated to ensure readability.<br>\\n""\n""Holding ctrl while pressing return inverts this setting in single line input fields.""))\n        self.cb_F_EvalF.setText(_translate(""AMaDiA_Options"", ""Evaluate Functions""))\n        self.Label_FlagExplanation.setText(_translate(""AMaDiA_Options"", ""These Flags are used when evaluating an equation.<br>\\n""\n""All Flags except \\""Evaluate Functions\\"" are read during the calculations and thus should not be changed while a calculation is running.""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_Flags), _translate(""AMaDiA_Options"", ""Calculator Flags""))\n        self.cb_D_NewSolver.setToolTip(_translate(""AMaDiA_Options"", ""Use the new experimental solver.<br>\\n""\n""The new solver is a long term project.<br>\\n""\n""This checkbox is only for development purposes and should never be checked by users.<br>\\n""\n""The new solver can not solve anything at the moment.""))\n        self.cb_D_NewSolver.setText(_translate(""AMaDiA_Options"", ""Use New Solver""))\n        self.cb_D_NoEvalFile.setToolTip(_translate(""AMaDiA_Options"", ""Use th NoEvalFile that uses \\""with sympy.evaluate(False)\\""<br>\\n""\n""It still influences the main process and thus can mess up all calculations.<br>\\n""\n""To keep the calculator reliable this checkbox should be kept unchecked.<br>\\n""\n""Sympy\\\'s \\""with sympy.evaluate(False)\\"" is currently experimental anyways.""))\n        self.cb_D_NoEvalFile.setText(_translate(""AMaDiA_Options"", ""Enable LaTeX No Eval""))\n        self.Label_DevOption_Explanation.setText(_translate(""AMaDiA_Options"", ""WARNING: This page is only for development purposes and should not be used by normal users. Everything on this page can crash the program or cause other nasty bugs.""))\n        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_DevOptions), _translate(""AMaDiA_Options"", ""DevOptions""))\n\nfrom AGeLib.AGeMain import MTabWidget, OptionsWidget_1_Appearance\n'"
AMaDiA_Files/AMaDiA_ReplacementTables.py,1,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Thu Sep  5 16:22:05 2019\n\n@author: Robin\n""""""\nfrom PyQt5.QtCore import Qt # pylint: disable=no-name-in-module\n\n# ---------------------------------- Keyboard Remapper KR_ ----------------------------------\n\nKR_Map = [\n    # Sorted for German Keyboard but mostly compatible with all Keyboards\n    # Note that not all Symbols are currently supported\n    # This is my custom Layout for my Linux Laptop\n    #Normal\n        #Shift\n            #AltGr\n                #AltGr+Shift\n                    # ^\n                        # Qt Key\n    # Line 1 (Numbers)\n    [""^"",""\xc2\xb0"",""\xe2\x80\xb2"",""\xe2\x80\xb3"","" "",Qt.Key_Dead_Circumflex],\n    [""1"",""!"",""\xe2\x88\xab"",""\xe2\x82\x81"",""\xc2\xb9"",Qt.Key_1],         ["" "",""!"","" "",""\xe2\x82\x81"","" "",Qt.Key_Exclam],\n    [""2"",""\\"""",""\xe1\xb5\x80"",""\xe2\x82\x82"",""\xc2\xb2"",Qt.Key_2],       ["" "",""\\"""","" "",""\xe2\x82\x82"","" "",Qt.Key_QuoteDbl],     ["" "",""\\"""",""\xe1\xb5\x80"",""\xe2\x82\x82"",""\xc2\xb2"",Qt.Key_twosuperior],\n    [""3"",""\xc2\xa7"",""\xe2\x88\x9a"",""\xe2\x82\x83"",""\xc2\xb3"",Qt.Key_3],         ["" "",""\xc2\xa7"","" "",""\xe2\x82\x83"","" "",Qt.Key_paragraph],     ["" "",""\xc2\xa7"",""\xe2\x88\x9a"",""\xe2\x82\x83"",""\xc2\xb3"",Qt.Key_threesuperior],\n    [""4"",""$"",""\\u2260"",""\xe2\x82\x84"",""\xe2\x81\xb4"",Qt.Key_4],    ["" "",""$"","" "",""\xe2\x82\x84"","" "",Qt.Key_Dollar],\n    [""5"",""%"",""\xe2\x89\x88"",""\xe2\x82\x85"",""\xe2\x81\xb5"",Qt.Key_5],         ["" "",""%"","" "",""\xe2\x82\x85"","" "",Qt.Key_Percent],\n    [""6"",""&"",""\xe2\x89\x99"",""\xe2\x82\x86"",""\xe2\x81\xb6"",Qt.Key_6],         ["" "",""&"","" "",""\xe2\x82\x86"","" "",Qt.Key_Ampersand],\n    [""7"",""/"",""{"",""\xe2\x82\x87"",""\xe2\x81\xb7"",Qt.Key_7],         ["" "",""/"","" "",""\xe2\x82\x87"","" "",Qt.Key_Slash],\n    [""8"",""("",""["",""\xe2\x82\x88"",""\xe2\x81\xb8"",Qt.Key_8],         ["" "",""("","" "",""\xe2\x82\x88"","" "",Qt.Key_ParenLeft],\n    [""9"","")"",""]"",""\xe2\x82\x89"",""\xe2\x81\xb9"",Qt.Key_9],         ["" "","")"","" "",""\xe2\x82\x89"","" "",Qt.Key_ParenRight],\n    [""0"",""="",""}"",""\xe2\x82\x80"",""\xe2\x81\xb0"",Qt.Key_0],         ["" "",""="","" "",""\xe2\x82\x80"","" "",Qt.Key_Equal],\n    [""\xc3\x9f"",""?"",""\\\\"",""\xc2\xbf"","" "",Qt.Key_ssharp],\n    [""\xc2\xb4"",""`"",""\xe2\x89\xa4"",""\xe2\x89\xa5"","" "",Qt.Key_acute],\n    # Line 2 (QWERTZ...)\n    [""q"",""Q"",""@"",""\xc2\xb1"","" "",Qt.Key_Q],\n    [""w"",""W"",r""\xe2\x80\x80"",r""\xc4\xa7"","" "",Qt.Key_W],\n    [""e"",""E"",""\xce\xb5"",""\xe2\x88\x88"","" "",Qt.Key_E],\n    [""r"",""R"",""\xcf\x81"",""\xe2\x84\x9d"","" "",Qt.Key_R],\n    [""t"",""T"",""\xce\xb8"",""\xce\x98"","" "",Qt.Key_T],\n    [""z"",""Z"",""\xce\xb6"",""\xcf\x84"","" "",Qt.Key_Z],\n    [""u"",""U"",""\\u0332"",""\\u0305"","" "",Qt.Key_U],\n    [""i"",""I"",""\xcf\x88"",""\xce\xa8"","" "",Qt.Key_I],\n    [""o"",""O"",""\xcf\x89"",""\xce\xa9"","" "",Qt.Key_O],\n    [""p"",""P"",""\xcf\x80"",""\xce\xa0"","" "",Qt.Key_P],\n    [""\xc3\xbc"",""\xc3\x9c"",""\\u0307"",""\\u0308"","" "",Qt.Key_Udiaeresis],\n    [""plus"",""*"","" "","" "",""\xe2\x81\xba"",Qt.Key_Plus],\n    # Line 3 (ASD...)\n    [""a"",""A"",""\xce\xb1"",""\xe2\x88\x82"","" "",Qt.Key_A],\n    [""s"",""S"",""\xcf\x83"",""\xce\xa3"","" "",Qt.Key_S],\n    [""d"",""D"",""\xce\xb4"",""\xce\x94"","" "",Qt.Key_D],\n    [""f"",""F"",""\xcf\x86"",""\xce\xa6"","" "",Qt.Key_F],\n    [""g"",""G"",""\xce\xb3"",""\xce\x93"","" "",Qt.Key_G],\n    [""h"",""H"",""\xe2\x86\x91"",""\xe2\x86\x93"","" "",Qt.Key_H],\n    [""j"",""J"",""\xe2\x86\x92"",""\xe2\x86\x90"","" "",Qt.Key_J],\n    [""k"",""K"",""\xce\xba"",""\xe2\x88\x9e"","" "",Qt.Key_K],\n    [""l"",""L"",""\xce\xbb"",""\xce\x9b"","" "",Qt.Key_L],\n    [""\xc3\xb6"",""\xc3\x96"",""\\u005E"","" "","" "",Qt.Key_Odiaeresis],\n    [""\xc3\xa4"",""\xc3\x84"",""\xe2\x86\xb3"",""\\u0303"","" "",Qt.Key_Adiaeresis],\n    [""#"",r""\'"",""\xe2\x80\x99"","" "","" "",Qt.Key_NumberSign],\n    # Line 4 (YXC...)\n    [""<"","">"",""|"",""\xe2\x87\x94"","" "",Qt.Key_Less],                  ["" "","">"",""|"",""\xe2\x87\x94"","" "",Qt.Key_Greater],\n    [""y"",""Y"",""\xe2\x87\x92"",""\xe2\x87\x90"","" "",Qt.Key_Y],\n    [""x"",""X"",""\xce\xbe"",""\xce\x9e"","" "",Qt.Key_X],\n    [""c"",""C"",""\xe2\x84\x82"",""\xe2\x81\xbf"","" "",Qt.Key_C],\n    [""v"",""V"",""\\u20D7"",""\xe2\x82\x99"","" "",Qt.Key_V],\n    [""b"",""B"",""\xce\xb2"","" "","" "",Qt.Key_B],\n    [""n"",""N"",""\xce\xbd"",""\xce\xb7"",""\xe2\x81\xbf"",Qt.Key_N],\n    [""m"",""M"",""\\u03bc"","" "","" "",Qt.Key_M],                ["" "",""M"",""\\u03bc"","" "","" "",Qt.Key_mu],\n    [""comma"","";"",""\\u00B7"",""\\u00D7"","" "",Qt.Key_Comma],   ["" "","";"",""\\u00B7"",""\\u00D7"","" "",Qt.Key_Semicolon],\n    [""."","":"",""\xe2\x80\xa6"",""\xc3\xb7"","" "",Qt.Key_Period],                ["" "","":"",""\xe2\x80\xa6"",""\xc3\xb7"","" "",Qt.Key_Colon],\n    [""-"",""_"",""\xe2\x80\x93"",""\xe2\x80\x94"",""\xe2\x81\xbb"",Qt.Key_Minus],                 ["" "",""_"",""\xe2\x80\x93"",""\xe2\x80\x94"",""\xe2\x81\xbb"",Qt.Key_Underscore]]\n\n# ---------------------------------- Lists l_ ----------------------------------\n\nl_beginning_symbols = [\'=\',\'(\',\'{\',\'[\']\nl_pairs_brackets = [[\'(\',\')\'],[\'[\',\']\'],[\'{\',\'}\']]\nl_pairs_brackets_special = [[\'<\',\'>\']]\nl_pairs_brackets_not_interpretable = [[\'{\',\'}\'],[\'[\',\']\']]\nl_pairs_quotation = [[""\\"""",""\\""""],[""\\\'"",""\\\'""]]\n#CLEANUP: Clean this up...:\nl_pairs_special_I_D = [[""Integral"",""d"",""Integral(""],[""d("","")/d"",""diff(""],[""\xe2\x88\x82("","")/\xe2\x88\x82"",""diff(""]]\nl_pairs_special_I_D_all_Integrals = [[""Integral"",""d"",""Integral(""],[""d("","")/d"",""diff(""],[""\xe2\x88\x82("","")/\xe2\x88\x82"",""diff(""],[""integral"",""d"",""Integral(""],\n                                [""Integrate"",""d"",""Integral(""],[""integrate"",""d"",""Integral(""],[""int "",""d"",""Integral(""],[""Int "",""d"",""Integral(""],[""\xe2\x88\xab"",""d"",""Integral(""]]\nl_pairs_special_I_D_Unicode = [[""\xe2\x88\xab"",""d"",""Integral(""],[""d("","")/d"",""diff(""],[""\xe2\x88\x82("","")/\xe2\x88\x82"",""diff(""]]\n\nl_pairs_special = [[""sqrt("","")""],[""\xe2\x88\x9a("","")""]]\nl_separators = [\',\']\n\nLIST_l_normal_pairs = [l_pairs_brackets , l_pairs_special_I_D_all_Integrals , l_pairs_special]\nLIST_l_normal_pairs_Unicode = [l_pairs_brackets , l_pairs_special_I_D_Unicode , l_pairs_special]\nLIST_l_all_pairs = [l_pairs_brackets , l_pairs_brackets_special , l_pairs_quotation , l_pairs_special_I_D , l_pairs_special]\n\n\n# ---------------------------------- Normal Replacements n_ ----------------------------------\n\nn_standard = [["""",""""]]\nn_standard_integrals = [[""integral"",""Integral""],[""Integrate"",""Integral""],[""integrate"",""Integral""],[""int "",""Integral""],[""Int "",""Integral""],[""\xe2\x88\xab"",""Integral""]]\nn_greek_letters = [[""\\u0391"","" Alpha ""],[""\\u03b1"","" alpha ""],\n                   [""\\u0392"","" Beta ""],[""\\u03b2"","" beta ""],\n                   [""\\u0393"","" Gamma ""],[""\\u03b3"","" gamma ""],\n                   [""\\u0394"","" Delta ""],[""\\u03b4"","" delta ""],\n                   [""\\u0395"","" Epsilon ""],[""\\u03b5"","" epsilon ""],\n                   [""\\u0396"","" Zeta ""],[""\\u03b6"","" zeta ""],\n                   [""\\u0397"","" Eta ""],[""\\u03b7"","" eta ""],\n                   [""\\u0398"","" Theta ""],[""\\u03b8"","" theta ""],\n                   [""\\u0399"","" Iota ""],[""\\u03b9"","" iota ""],\n                   [""\\u039a"","" Kappa ""],[""\\u03ba"","" kappa ""],\n                   [""\\u039b"","" Lamda ""],[""\\u03bb"","" lamda ""], # Lambda is a function in sympy so they spell the letter lamda\n                   [""\\u039c"","" Mu ""],[""\\u03bc"","" mu ""],[""\xc2\xb5"","" mu ""],\n                   [""\\u039d"","" Nu ""],[""\\u03bd"","" nu ""],\n                   [""\\u039e"","" Xi ""],[""\\u03be"","" xi ""],\n                   [""\\u039f"","" Omicron ""],[""\\u03bf"","" omicron ""],\n                   [""\\u03a0"","" Pi ""],[""\\u03c0"","" pi ""],\n                   [""\\u03a1"","" Rho ""],[""\\u03c1"","" rho ""],\n                   [""\\u03a3"","" Sigma ""],[""\\u03c3"","" sigma ""],\n                   [""\\u03a4"","" Tau ""],[""\\u03c4"","" tau ""],\n                   [""\\u03a5"","" Upsilon ""],[""\\u03c5"","" upsilon ""],\n                   [""\\u03a6"","" Phi ""],[""\\u03c6"","" phi ""],\n                   [""\\u03a7"","" chi ""],[""\\u03c7"","" chi ""], #Capital Chi is a function in sympy!!! Converting into lower case chi instead\n                   [""\\u03a8"","" Psi ""],[""\\u03c8"","" psi ""],\n                   [""\\u03a9"","" Omega ""],[""\\u03c9"","" omega ""]\n                   ]\nn_greek_letters_nospace = [[""\\u0391"",""Alpha""],[""\\u03b1"",""alpha""],\n                   [""\\u0392"",""Beta""],[""\\u03b2"",""beta""],\n                   [""\\u0393"",""Gamma""],[""\\u03b3"",""gamma""],\n                   [""\\u0394"",""Delta""],[""\\u03b4"",""delta""],\n                   [""\\u0395"",""Epsilon""],[""\\u03b5"",""epsilon""],\n                   [""\\u0396"",""Zeta""],[""\\u03b6"",""zeta""],\n                   [""\\u0397"",""Eta""],[""\\u03b7"",""eta""],\n                   [""\\u0398"",""Theta""],[""\\u03b8"",""theta""],\n                   [""\\u0399"",""Iota""],[""\\u03b9"",""iota""],\n                   [""\\u039a"",""Kappa""],[""\\u03ba"",""kappa""],\n                   [""\\u039b"",""Lamda""],[""\\u03bb"",""lamda""], # Lambda is a function in sympy so they spell the letter lamda\n                   [""\\u039c"",""Mu""],[""\\u03bc"",""mu""],[""\xc2\xb5"","" mu ""],\n                   [""\\u039d"",""Nu""],[""\\u03bd"",""nu""],\n                   [""\\u039e"",""Xi""],[""\\u03be"",""xi""],\n                   [""\\u039f"",""Omicron""],[""\\u03bf"",""omicron""],\n                   [""\\u03a0"",""Pi""],[""\\u03c0"",""pi""],\n                   [""\\u03a1"",""Rho""],[""\\u03c1"",""rho""],\n                   [""\\u03a3"",""Sigma""],[""\\u03c3"",""sigma""],\n                   [""\\u03a4"",""Tau""],[""\\u03c4"",""tau""],\n                   [""\\u03a5"",""Upsilon""],[""\\u03c5"",""upsilon""],\n                   [""\\u03a6"",""Phi""],[""\\u03c6"",""phi""],\n                   [""\\u03a7"",""chi""],[""\\u03c7"",""chi""], #Capital Chi is a function in sympy!!! Converting into lower case chi instead\n                   [""\\u03a8"",""Psi""],[""\\u03c8"",""psi""],\n                   [""\\u03a9"",""Omega""],[""\\u03c9"",""omega""]\n                   ]\nn_constants = [[""\\u03c0"","" pi ""],[""\xe2\x88\x9e"","" oo ""]]\nn_operators = [[""^"",""**""],[""\xc2\xb7"",""*""]]\nn_operators_special = [[""\xe2\x88\x9a"",""sqrt""],[""\xe2\x88\xab"",""Integral""]]\nn_operators_notinv = [[""\xe2\x80\x93"",""-""],[""\xe2\x80\x94"",""-""],[""\xc3\x97"",""*""],[""\xc3\xb7"",""/""],[""\xc2\xb0C"",""degC""],[""\xc2\xb0F"",""*5/9*degC-32*5/9*degC""],[""/\xc2\xb0"",""*(360/pi/2)""],[""\xc2\xb0"",""/(360/pi/2)""]]\nn_operators_dual = [[""\xc2\xb1"",""+"",""-""],[""\xe2\x88\x93"",""-"",""+""]]\nn_space = [[""\xe2\x80\x80"","" ""]]\n\nn_priority_Invertable = [[""\xc2\xb0C"",""*degC""],[""\xc2\xb0C"",""degC""],[""\xc2\xb0F"",""*5/9*degC-32*5/9*degC""],[""/\xc2\xb0"",""*(360/pi/2)""],[""\xc2\xb0"",""/(360/pi/2)""]]\n\nLIST_n_all = [n_standard_integrals , n_greek_letters_nospace , n_constants , n_operators , n_operators_special , n_operators_notinv , n_space]\n\nn_constants_nospace = [[""\xcf\x80"","" pi ""]]\nLIST_n_invertable = [n_priority_Invertable , n_operators , n_operators_special]\n# ---------------------------------- Special Replacements s_ ----------------------------------\n\ns_constants_math = [[""i"","" I ""],[""e"","" E ""]]\ns_constants_engineering = [[""j"","" I ""],[""e"","" E ""]]\n\n# ---------------------------------- Replacements Simple to Python r_s_ ----------------------------------\n\nr_s_superscript_numbers_neg = [[""\xe2\x81\xbb\xc2\xb9"",""**(-1)""],[""\xe2\x81\xbb\xc2\xb2"",""**(-2)""],[""\xe2\x81\xbb\xc2\xb3"",""**(-3)""],[""\xe2\x81\xbb\xe2\x81\xb4"",""**(-4)""],[""\xe2\x81\xbb\xe2\x81\xb5"",""**(-5)""],[""\xe2\x81\xbb\xe2\x81\xb6"",""**(-6)""],[""\xe2\x81\xbb\xe2\x81\xb7"",""**(-7)""],[""\xe2\x81\xbb\xe2\x81\xb8"",""**(-8)""],[""\xe2\x81\xbb\xe2\x81\xb9"",""**(-9)""],[""\xe2\x81\xbb\xe2\x81\xb0"",""**(-0)""]]\nr_s_superscript_numbers = [[""\xc2\xb9"",""**(1)""],[""\xc2\xb2"",""**(2)""],[""\xc2\xb3"",""**(3)""],[""\xe2\x81\xb4"",""**(4)""],[""\xe2\x81\xb5"",""**(5)""],[""\xe2\x81\xb6"",""**(6)""],[""\xe2\x81\xb7"",""**(7)""],[""\xe2\x81\xb8"",""**(8)""],[""\xe2\x81\xb9"",""**(9)""],[""\xe2\x81\xb0"",""**(0)""]]\nr_s_subscript_numbers = [[""\xe2\x82\x81"",""_1""],[""\xe2\x82\x82"",""_2""],[""\xe2\x82\x83"",""_3""],[""\xe2\x82\x84"",""_4""],[""\xe2\x82\x85"",""_5""],[""\xe2\x82\x86"",""_6""],[""\xe2\x82\x87"",""_7""],[""\xe2\x82\x88"",""_8""],[""\xe2\x82\x89"",""_9""],[""\xe2\x82\x80"",""_0""]]\nr_s_superscript_letters = [[""\xe2\x81\xbf"",""**(n)""],[""\xe1\xb5\x80"","".T""]]\nr_s_subscript_letters = [[""\xe2\x82\x99"",""_n""]]\n\nLIST_r_s_scripts = [r_s_superscript_numbers_neg, r_s_superscript_numbers , r_s_subscript_numbers , r_s_superscript_letters , r_s_subscript_letters]\n\n\n\n# ---------------------------------- Replacements Complex to Python r_c_ ----------------------------------\n\n# number references number of parts in addition to symbol replacement\nr_c_operators_1 = [[""\xe2\x88\x9a"",""""]]\nr_c_operators_2 = [[]]\nr_c_operators_3 = [[""\xce\xa3"",""""],[""\xce\xa0"",""""]]\nr_c_operators_4 = [\n                    [""\xe2\x88\xab"",""""], # 1: from 2: to 3: f(x) 4: dx\n                    []]\n\n\n# ---------------------------------- PYTHON_TO_LATEX_ ----------------------------------\n\nPYTHON_TO_LATEX_simple_replacements = [\n                        [\'**\', \'^\'],\n                        [\'*\', \' \\\\cdot \'], [\'\xc2\xb7\', \' \\\\cdot \'],\n                        [\'math.\', \'\'], [\'np.\', \'\'],\n                        [\'pi\', \'\\\\pi\'] , [\'\xcf\x80\', \'\\\\pi\'],\n                        [\'tan\', \'\\\\tan\'], [\'cos\', \'\\\\cos\'], [\'sin\', \'\\\\sin\'], [\'sec\', \'\\\\sec\'], [\'csc\', \'\\\\csc\']]\nPYTHON_TO_LATEX_complex_replacements =[\n                        [\'^\', \'{{{i1}}}^{{{i2}}}\'],\n                        [\'_\', \'{{{i1}}}_{{{i2}}}\'],\n                        [\'/\', \'\\\\frac{{{i1}}}{{{i2}}}\'],\n                        [\'sqrt\',\'\\\\sqrt{{{i2}}}\'], [\'\xe2\x88\x9a\',\'\\\\sqrt{{{i2}}}\']]\n\n# ---------------------------------- MASTERLISTS M_ ----------------------------------\n\nM_pair_LIST_LIST_LIST = [LIST_l_all_pairs]\n\n\n\n# ---------------------------------- _ ----------------------------------\n'"
AMaDiA_Files/AMaDiA_SystemControl.py,0,"b'\n\nfrom AGeLib import *\n\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5.Qt import QApplication, QClipboard # pylint: disable=no-name-in-module\nfrom PyQt5 import QtWidgets,QtCore,QtGui,Qt\n\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\n\nfrom External_Libraries.python_control_master import control\n\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_Classes as AC\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\nfrom AMaDiA_Files.AMaDiA_SystemControl_UI import Ui_SystemControlWindow\nfrom AMaDiA_Files.AMaDiA_SystemControl_Widgets import MplCanvas_CONTROL\nfrom AMaDiA_Files.AMaDiA_SystemControl_Widgets import SystemClass\n\n\n# ---------------------------------- Main Window ----------------------------------\nclass AMaDiA_Control_Window(AWWF, Ui_SystemControlWindow):\n    def __init__(self, parent = None):\n        super(AMaDiA_Control_Window, self).__init__(parent, includeTopBar=False, initTopBar=False, includeStatusBar=True)\n        self.setupUi(self)\n        self.TopBar = TopBar_Widget(self,False)\n        self.ControlSystems_tabWidget.setCornerWidget(self.TopBar, QtCore.Qt.TopRightCorner)\n        self.TopBar.init(IncludeFontSpinBox=True,IncludeErrorButton=True,IncludeAdvancedCB=True)\n        \n        self.standardSize = (906, 634)\n        self.resize(*self.standardSize)\n        \n        self.ControlSystems_tabWidget.setCurrentIndex(0)\n        self.ControlSystems_1_Output_tabWidget.removeTab(1)\n        \n        ControlSystems_4_Dirty_Input_Text = ""#Example:\\n\\n""\n        ControlSystems_4_Dirty_Input_Text += ""K_P = 5\\nK_D = 0\\nK_i = 0\\n\\nsys1 = tf([K_D,K_P,K_i],[1,1.33+K_D,1+K_P,K_i])\\n\\n""\n        ControlSystems_4_Dirty_Input_Text += ""#Other example:\\n#sys1 = tf([1],[1,2,3])\\n\\n""\n        ControlSystems_4_Dirty_Input_Text += ""#Other example:\\n#sys1 = ss([[2,8],[1,0]],[[1],[-0.5000]],[-1/8,-1],[0])\\n\\n""\n        ControlSystems_4_Dirty_Input_Text += ""#Setting Input Function u(s):\\nu=\\""sin(s)\\""\\n#u=\\""1/(s+1)\\""""\n        \n        self.ControlSystems_4_Dirty_Input.setPlaceholderText(ControlSystems_4_Dirty_Input_Text)\n        self.ControlSystems_4_Dirty_Input.setText(ControlSystems_4_Dirty_Input_Text)\n        \n        # EventFilter\n        self.installEventFilter(self)\n        # Set up context menus for the histories and other list widgets\n        for i in self.findChildren(QtWidgets.QListWidget):\n            i.installEventFilter(self)\n        # Set up text input related Event Handlers\n        for i in self.findChildren(QtWidgets.QTextEdit):\n            i.installEventFilter(self)\n        for i in self.findChildren(QtWidgets.QLineEdit):\n            i.installEventFilter(self)\n        \n        # Run other init methods\n        self.ConnectSignals()\n        \n        # Other things:\n        self.ControlSystems_1_System_Set_Order()\n        \n        for i in self.findChildren(MplWidget):\n            i.SetColour()\n        NC(10,""Welcome to CONTROL (WIP)"",win=self.windowTitle(),func=""{}.__init__"".format(str(self.objectName())))\n    \n # ---------------------------------- Init and Maintenance ----------------------------------\n    \n    def ConnectSignals(self):\n        self.ControlSystems_1_SystemOrder_Confrim.clicked.connect(self.ControlSystems_1_System_Set_Order)\n        self.ControlSystems_1_SaveButton.clicked.connect(self.ControlSystems_1_System_Save)\n        self.ControlSystems_1_SavePlotButton.clicked.connect(self.ControlSystems_1_System_Plot_and_Save)\n        \n        self.ControlSystems_1_System_4ATF_Ys.returnPressed.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_System_4ATF_Xs))\n        self.ControlSystems_1_System_4ATF_Xs.returnPressed.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_NameInput))\n        self.ControlSystems_1_System_1TF_tableWidget.S_Focus_Next.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_NameInput))\n        self.ControlSystems_1_System_2SS_A_tableWidget.S_Focus_Next.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_System_2SS_B_tableWidget))\n        self.ControlSystems_1_System_2SS_B_tableWidget.S_Focus_Next.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_System_2SS_C_tableWidget))\n        self.ControlSystems_1_System_2SS_C_tableWidget.S_Focus_Next.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_System_2SS_D_tableWidget))\n        self.ControlSystems_1_System_2SS_D_tableWidget.S_Focus_Next.connect(lambda: self.ControlSystems_1_SetFocus_on(self.ControlSystems_1_NameInput))\n        self.ControlSystems_1_NameInput.returnPressed.connect(self.ControlSystems_1_System_Plot_and_Save)\n        \n        \n        self.ControlSystems_2_Display.canvas.mpl_connect(\'button_press_event\', self.ControlSystems_2_Maximize_Axes)\n        \n        self.ControlSystems_4_Dirty_Input.returnCtrlPressed.connect(self.ControlSystems_4_Dirty_Display)\n    \n # ---------------------------------- Event Filter ----------------------------------\n    \n    def eventFilter(self, source, event):\n        #print(event.type())\n        #if event.type() == 6: # QtCore.QEvent.KeyPress\n        # # ---------------------------------- Full Screen ----------------------------------\n        #    if event.key() == QtCore.Qt.Key_F11 and source is self: # F11 to toggle Fullscreen\n        #        if not self.isFullScreen():\n        #            if self.isMaximized():\n        #                self.LastOpenState = self.showMaximized\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        #            else:\n        #                self.LastOpenState = self.showNormal\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        #            self.showFullScreen()\n        #        else:\n        #            if self.LastOpenState == self.showMaximized:\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x97"")\n        #            else:\n        #                self.TopBar.MaximizeButton.setText(""\xf0\x9f\x97\x96"")\n        #            self.LastOpenState()\n        if event.type() == 82: # QtCore.QEvent.ContextMenu\n         # ---------------------------------- Tab_4 Matrix List Context Menu ----------------------------------\n            if (source is self.ControlSystems_1_SystemList) and source.itemAt(event.pos()):\n                menu = QtWidgets.QMenu()\n                action = menu.addAction(\'Load to Editor\')\n                action.triggered.connect(lambda: self.action_SystemList_Load_into_Editor(source,event))\n                action = menu.addAction(\'Copy as String\')\n                action.triggered.connect(lambda: self.action_SystemList_Copy_string(source,event))\n                action = menu.addAction(\'Display\')\n                action.triggered.connect(lambda: self.action_SystemList_Display(source,event))\n                action = menu.addAction(\'Plot\')\n                action.triggered.connect(lambda: self.action_SystemList_Plot(source,event))\n                action = menu.addAction(\'Plot Closed-Loop System\')\n                action.triggered.connect(lambda: self.action_SystemList_Plot_Closed(source,event))\n                action = menu.addAction(\'Delete\')\n                action.triggered.connect(lambda: self.action_SystemList_Delete(source,event))\n                menu.setPalette(self.palette())\n                menu.setFont(self.font())\n                menu.exec_(event.globalPos())\n                return True\n        #elif...\n        return super(AMaDiA_Control_Window, self).eventFilter(source, event) # let the normal eventFilter handle the event\n # ---------------------------------- Tab_4_Matrix_List Context Menu Actions/Functions ----------------------------------\n    def action_SystemList_Load_into_Editor(self,source,event):\n        item = source.itemAt(event.pos())\n        system = item.data(100)\n        self.ControlSystems_1_System_tabWidget.setCurrentIndex(system.Tab)\n        self.ControlSystems_1_SystemOrder_Spinbox.setValue(system.Order)\n        self.ControlSystems_1_System_Set_Order(system.Order)\n        if system.Tab == 0:\n            Ys, Xs = system.systemInput\n            self.ControlSystems_1_System_4ATF_Ys.setText(Ys)\n            self.ControlSystems_1_System_4ATF_Xs.setText(Xs)\n        elif system.Tab == 1:\n            Ys, Xs, Order = system.systemInput\n            self.ControlSystems_1_System_Set_Order(Order)\n            for j in range(self.ControlSystems_1_System_1TF_tableWidget.columnCount()):\n                item = Qt.QTableWidgetItem()\n                t = AF.number_shaver(str(Ys[j])) if AF.number_shaver(str(Ys[j])) != ""0"" else """"\n                item.setText(t)\n                self.ControlSystems_1_System_1TF_tableWidget.setItem(0,j,item)\n                item = Qt.QTableWidgetItem()\n                t = AF.number_shaver(str(Xs[j])) if AF.number_shaver(str(Xs[j])) != ""0"" else """"\n                item.setText(t)\n                self.ControlSystems_1_System_1TF_tableWidget.setItem(1,j,item)\n        elif system.Tab == 2:\n            A,B,C,D = system.systemInput\n            for i in range(system.Order):\n                for j in range(system.Order):\n                    item = Qt.QTableWidgetItem()\n                    item.setText(AF.number_shaver(str(A[i][j])))\n                    self.ControlSystems_1_System_2SS_A_tableWidget.setItem(i,j,item)\n                item = Qt.QTableWidgetItem()\n                item.setText(AF.number_shaver(str(B[i][0])))\n                self.ControlSystems_1_System_2SS_B_tableWidget.setItem(i,0,item)\n                item = Qt.QTableWidgetItem()\n                item.setText(AF.number_shaver(str(C[i])))\n                self.ControlSystems_1_System_2SS_C_tableWidget.setItem(0,i,item)\n            item = Qt.QTableWidgetItem()\n            t = AF.number_shaver(str(D[0][0])) if AF.number_shaver(str(D[0][0])) != ""0"" else """"\n            item.setText(t)\n            self.ControlSystems_1_System_2SS_D_tableWidget.setItem(0,0,item)\n    \n    def action_SystemList_Copy_string(self,source,event):\n        item = source.itemAt(event.pos())\n        system = item.data(100)\n        QApplication.clipboard().setText(str(system.sys))\n    \n    def action_SystemList_Display(self,source,event):\n        item = source.itemAt(event.pos())\n        system = item.data(100)\n        self.ControlSystems_1_System_Display_LaTeX(system)\n    \n    def action_SystemList_Plot(self,source,event):\n        item = source.itemAt(event.pos())\n        system = item.data(100)\n        self.ControlSystems_1_System_Display_LaTeX(system)\n        self.ControlSystems_1_System_Plot(system)\n    \n    def action_SystemList_Plot_Closed(self,source,event):\n        open_system = source.itemAt(event.pos()).data(100)\n        item = open_system.Close()\n        closed_system = item.data(100)\n        self.ControlSystems_1_SystemList.addItem(item)\n        self.ControlSystems_1_System_Display_LaTeX(closed_system)\n        self.ControlSystems_1_System_Plot(closed_system)\n    \n    def action_SystemList_Delete(self,source,event):\n        # FEATURE: Paperbin for matrices: If only one item was deleted save it in a temporary List item (The same as the duplicate item from the save function)\n        listItems=source.selectedItems()\n        if not listItems: return        \n        for item in listItems:\n            source.takeItem(source.row(item))\n    \n  # ---------------------------------- Control Plot Interaction ---------------------------------- \n    def ControlSystems_2_Maximize_Axes(self,event):\n        try:\n            if event.button == 1 and event.dblclick and event.inaxes.title.get_text() in MplCanvas_CONTROL.Titles[:9]+[""  ""]:\n                if self.ControlSystems_3_SingleDisplay.Plot(self.ControlSystems_2_Display.Curr_Sys, event.inaxes.title.get_text()):\n                    self.ControlSystems_tabWidget.setCurrentIndex(2)\n        except common_exceptions as inst:\n            if type(inst) != AttributeError:\n                NC(exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_2_Maximize_Axes"",win=self.windowTitle())\n            self.ControlSystems_tabWidget.setCurrentIndex(1)\n        self.ControlSystems_tabWidget.setFocus()\n    \n # ---------------------------------- ControlSystems_ (Mind-)Control ----------------------------------\n    def ControlSystems_1_System_Set_Order(self,Order=None):\n        if type(Order) != int:\n            Order = self.ControlSystems_1_SystemOrder_Spinbox.value()\n        \n        # Transfer\n        ## Add/Remove Columns\n        shift = Order+1-self.ControlSystems_1_System_1TF_tableWidget.columnCount()\n        if shift > 0:\n            for i in range(abs(shift)):\n                self.ControlSystems_1_System_1TF_tableWidget.insertColumn(0)\n        elif shift < 0:\n            for i in range(abs(shift)):\n                self.ControlSystems_1_System_1TF_tableWidget.removeColumn(0)\n        \n        ## Set Header Labels\n        HeaderLabel = []\n        i=Order\n        while i >= 0:\n            s=""s{}"".format(i)\n            HeaderLabel.append(u\'\'.join(dict(zip(u""0123456789"", u""\xe2\x81\xb0\xc2\xb9\xc2\xb2\xc2\xb3\xe2\x81\xb4\xe2\x81\xb5\xe2\x81\xb6\xe2\x81\xb7\xe2\x81\xb8\xe2\x81\xb9"")).get(c, c) for c in s))\n            i-=1\n        self.ControlSystems_1_System_1TF_tableWidget.setHorizontalHeaderLabels(HeaderLabel)\n        \n        # State System\n        q,p = 1,1 # Future use for multi dimensional input and output (See https://en.wikipedia.org/wiki/State-space_representation)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setRowCount(Order)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setColumnCount(Order)\n        \n        self.ControlSystems_1_System_2SS_B_tableWidget.setRowCount(Order)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setColumnCount(p)\n        \n        self.ControlSystems_1_System_2SS_C_tableWidget.setRowCount(q)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setColumnCount(Order)\n        \n        self.ControlSystems_1_System_2SS_D_tableWidget.setRowCount(q)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setColumnCount(p)\n        \n        ## Set Header Labels\n        HeaderLabelX = []\n        i=1\n        while i <= Order:\n            s=""x{}\xc2\xb7"".format(i)\n            HeaderLabelX.append(u\'\'.join(dict(zip(u""0123456789"", u""\xe2\x82\x80\xe2\x82\x81\xe2\x82\x82\xe2\x82\x83\xe2\x82\x84\xe2\x82\x85\xe2\x82\x86\xe2\x82\x87\xe2\x82\x88\xe2\x82\x89"")).get(c, c) for c in s))\n            i+=1\n        HeaderLabelXDiff = []\n        i=1\n        while i <= Order:\n            s=""x\xcc\x87{}="".format(i)\n            HeaderLabelXDiff.append(u\'\'.join(dict(zip(u""0123456789"", u""\xe2\x82\x80\xe2\x82\x81\xe2\x82\x82\xe2\x82\x83\xe2\x82\x84\xe2\x82\x85\xe2\x82\x86\xe2\x82\x87\xe2\x82\x88\xe2\x82\x89"")).get(c, c) for c in s))\n            i+=1\n        HeaderLabelU = [""u\xc2\xb7""]\n        HeaderLabelY = [""y=""]\n        self.ControlSystems_1_System_2SS_A_tableWidget.setHorizontalHeaderLabels(HeaderLabelX)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setVerticalHeaderLabels(HeaderLabelXDiff)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setHorizontalHeaderLabels(HeaderLabelU)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setVerticalHeaderLabels(HeaderLabelXDiff)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setHorizontalHeaderLabels(HeaderLabelX)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setVerticalHeaderLabels(HeaderLabelY)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setHorizontalHeaderLabels(HeaderLabelU)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setVerticalHeaderLabels(HeaderLabelY)\n    \n    def ControlSystems_1_SetFocus_on(self,item):\n        if item == self.ControlSystems_1_System_4ATF_Xs:\n            self.ControlSystems_1_System_4ATF_Xs.setFocus()\n            self.ControlSystems_1_System_4ATF_Xs.selectAll()\n        elif item == self.ControlSystems_1_NameInput:\n            self.ControlSystems_1_System_2SS_tabWidget.setCurrentIndex(0)\n            self.ControlSystems_1_NameInput.setFocus()\n            self.ControlSystems_1_NameInput.selectAll()\n        elif item == self.ControlSystems_1_System_2SS_B_tableWidget:\n            self.ControlSystems_1_System_2SS_tabWidget.setCurrentIndex(1)\n            self.ControlSystems_1_System_2SS_B_tableWidget.setFocus()\n        elif item == self.ControlSystems_1_System_2SS_C_tableWidget:\n            self.ControlSystems_1_System_2SS_tabWidget.setCurrentIndex(2)\n            self.ControlSystems_1_System_2SS_C_tableWidget.setFocus()\n        elif item == self.ControlSystems_1_System_2SS_D_tableWidget:\n            self.ControlSystems_1_System_2SS_tabWidget.setCurrentIndex(3)\n            self.ControlSystems_1_System_2SS_D_tableWidget.setFocus()\n    \n    def ControlSystems_1_System_Save(self):\n        Tab = self.ControlSystems_1_System_tabWidget.currentIndex()\n        sys1 = None\n        try:\n            NameInvalid=False\n            Name = AF.AstusParse(self.ControlSystems_1_NameInput.text()).strip()\n            if Name == """" or "" "" in Name: #IMPROVE: Better checks for System Name!!!\n                NameInvalid=True\n            \n            if NameInvalid:\n                NC(1,""System Name Invalid"",func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=Name)\n                return False\n            \n            \n            \n            if Tab == 0: #Autoarrange Transfer Function\n                # Parse the input and find out the coefficients of the powers of s\n                systemInput = (self.ControlSystems_1_System_4ATF_Ys.text(),self.ControlSystems_1_System_4ATF_Xs.text())\n                s = sympy.symbols(""s"")\n                # FEATURE: check if s or z is in systemInput and create a time discrete system if it is z and add a field to THIS TAB to set the Abtastzeit\n                try:\n                    success = False\n                    mult = 0\n                    Yt = ""(""+self.ControlSystems_1_System_4ATF_Ys.text()+"")""\n                    Xt = ""(""+self.ControlSystems_1_System_4ATF_Xs.text()+"")""\n                    termsY,termsX = ""Fail"",""Fail""\n                    while not success:\n                        try:\n                            Ys_s = sympy.expand(parse_expr(AF.AstusParse(Yt)).doit().evalf())\n                            print(type(Ys_s),Ys_s)\n                            if type(Ys_s) == type(parse_expr(""1/s"")):\n                                pass\n                            Ys_r = sympy.poly(Ys_s,s)\n                            termsY = Ys_r.all_terms()\n                            Xs_s = sympy.expand(parse_expr(AF.AstusParse(Xt)).doit().evalf())\n                            Xs_r = sympy.poly(Xs_s,s)\n                            termsX = Xs_r.all_terms()\n                            success = True\n                        except:\n                            Yt+=""*s""\n                            Xt+=""*s""\n                            mult+=1\n                            if mult>20:\n                                NC(msg=""Could not normalize"",exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=""Input:{}\\nX:{}\\nY:{}"".format(self.ControlSystems_1_System_4ATF_Ys.text(),str(termsY),str(termsX)))\n                                return False\n                    temp_list_y = []\n                    temp_list_x = []\n                    for i in termsY:\n                        temp_list_y.append(int(i[0][0]))\n                    for i in termsX:\n                        temp_list_x.append(int(i[0][0]))\n                    while min(temp_list_y)<0 or min(temp_list_x)<0:\n                        Yt+=""*s""\n                        Xt+=""*s""\n                        Ys_r = sympy.poly(sympy.expand(parse_expr(AF.AstusParse(Yt)).doit().evalf()),s)\n                        termsY = Ys_r.all_terms()\n                        Xs_r = sympy.poly(sympy.expand(parse_expr(AF.AstusParse(Xt)).doit().evalf()),s)\n                        termsX = Xs_r.all_terms()\n                        temp_list_y = []\n                        temp_list_x = []\n                        for i in termsY:\n                            temp_list_y.append(int(i[0][0]))\n                        for i in termsX:\n                            temp_list_x.append(int(i[0][0]))\n                        mult+=1\n                        if mult>20:\n                            raise Exception(""Could not normalize\\nX:{}\\nY:{}"".format(str(termsY),str(termsX)))\n                    Ys = []\n                    for i in termsY:\n                        Ys.append(float(i[1]))\n                    print(Ys)\n                except common_exceptions:\n                    NC(msg=""Error in Y(s)"",exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=self.ControlSystems_1_System_4ATF_Ys.text())\n                    return False\n                try:\n                    Xs = []\n                    for i in termsX:\n                        Xs.append(float(i[1]))\n                    print(Xs)\n                except common_exceptions:\n                    NC(msg=""Error in X(s)"",exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=self.ControlSystems_1_System_4ATF_Xs.text())\n                    return False\n                sys1 = control.tf(Ys,Xs)\n            elif Tab == 1: #Transfer\n                Ys,YsI = [],[]\n                Xs,XsI = [],[]\n                MError = """"\n                for j in range(self.ControlSystems_1_System_1TF_tableWidget.columnCount()):\n                    try:\n                        if self.ControlSystems_1_System_1TF_tableWidget.item(0,j) != None and self.ControlSystems_1_System_1TF_tableWidget.item(0,j).text().strip() != """":\n                            Ys.append(float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_1TF_tableWidget.item(0,j).text(),True)).doit().evalf()))\n                        else:\n                            Ys.append(0)\n                    except common_exceptions:\n                        MError += ""Could not add item to System at ({},{}). Inserting a Zero instead. "".format(1,j+1)\n                        #MError += ExceptionOutput(sys.exc_info())\n                        MError += ""\\n""\n                        Ys.append(0)\n                    try:\n                        if self.ControlSystems_1_System_1TF_tableWidget.item(1,j) != None and self.ControlSystems_1_System_1TF_tableWidget.item(1,j).text().strip() != """":\n                            Xs.append(float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_1TF_tableWidget.item(1,j).text(),True)).doit().evalf()))\n                        else:\n                            Xs.append(0)\n                    except common_exceptions:\n                        MError += ""Could not add item to System at ({},{}). Inserting a Zero instead. "".format(2,j+1)\n                        #MError += ExceptionOutput(sys.exc_info())\n                        MError += ""\\n""\n                        Xs.append(0)\n                    YsI.append(Ys[j])\n                    XsI.append(Xs[j])\n                systemInput = (YsI,XsI,self.ControlSystems_1_System_1TF_tableWidget.columnCount()-1)\n                if MError != """":\n                    NC(2,MError,func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=""X(s) = {}\\nY(s) = {}"".format(str(Xs),str(Ys)))\n                # Remove empty leading entries\n                while Ys[0]==0:\n                    Ys.pop(0)\n                while Xs[0]==0:\n                    Xs.pop(0)\n                #print(Ys,r""/"",Xs)\n                sys1 = control.tf(Ys,Xs)\n            elif Tab == 2: #State System\n                A,B,C,D = [],[],[],[]\n                # Loading A\n                MError = """"\n                for i in range(self.ControlSystems_1_System_2SS_A_tableWidget.rowCount()):\n                    A.append([])\n                    for j in range(self.ControlSystems_1_System_2SS_A_tableWidget.columnCount()):\n                        try:\n                            if self.ControlSystems_1_System_2SS_A_tableWidget.item(i,j) != None and self.ControlSystems_1_System_2SS_A_tableWidget.item(i,j).text().strip() != """":\n                                A[i].append(float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_2SS_A_tableWidget.item(i,j).text(),False)).doit().evalf()))\n                            else:\n                                A[i].append(0)\n                        except common_exceptions:\n                            MError += ""Could not add item to A at ({},{}). Inserting a Zero instead. "".format(i+1,j+1)\n                            MError += ExceptionOutput(sys.exc_info())\n                            MError += ""\\n""\n                            A[i].append(0)\n                # Loading B\n                for j in range(self.ControlSystems_1_System_2SS_B_tableWidget.rowCount()):\n                    try:\n                        if self.ControlSystems_1_System_2SS_B_tableWidget.item(j,0) != None and self.ControlSystems_1_System_2SS_B_tableWidget.item(j,0).text().strip() != """":\n                            B.append([float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_2SS_B_tableWidget.item(j,0).text(),False)).doit().evalf())])\n                        else:\n                            B.append([0])\n                    except common_exceptions:\n                        MError += ""Could not add item to B at ({},{}). Inserting a Zero instead. "".format(j+1,1)\n                        MError += ExceptionOutput(sys.exc_info())\n                        MError += ""\\n""\n                        B.append([0])\n                # Loading C\n                for j in range(self.ControlSystems_1_System_2SS_C_tableWidget.columnCount()):\n                    try:\n                        if self.ControlSystems_1_System_2SS_C_tableWidget.item(0,j) != None and self.ControlSystems_1_System_2SS_C_tableWidget.item(0,j).text().strip() != """":\n                            C.append(float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_2SS_C_tableWidget.item(0,j).text(),False)).doit().evalf()))\n                        else:\n                            C.append(0)\n                    except common_exceptions:\n                        MError += ""Could not add item to C at ({},{}). Inserting a Zero instead. "".format(1,j+1)\n                        MError += ExceptionOutput(sys.exc_info())\n                        MError += ""\\n""\n                        C.append(0)\n                # Loading D\n                for i in range(self.ControlSystems_1_System_2SS_D_tableWidget.rowCount()):\n                    D.append([])\n                    for j in range(self.ControlSystems_1_System_2SS_D_tableWidget.columnCount()):\n                        try:\n                            if self.ControlSystems_1_System_2SS_D_tableWidget.item(i,j) != None and self.ControlSystems_1_System_2SS_D_tableWidget.item(i,j).text().strip() != """":\n                                D[i].append(float(parse_expr(AF.AstusParse(self.ControlSystems_1_System_2SS_D_tableWidget.item(i,j).text(),False)).doit().evalf()))\n                            else:\n                                D[i].append(0)\n                        except common_exceptions:\n                            MError += ""Could not add item to D at ({},{}). Inserting a Zero instead. "".format(i+1,j+1)\n                            MError += ExceptionOutput(sys.exc_info())\n                            MError += ""\\n""\n                            D[i].append(0)\n                # Send Errors\n                if MError != """":\n                    NC(2,MError,func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=""A:\\n{}\\n\\nB:\\n{}\\n\\nC:\\n{}\\n\\nD:\\n{}"".format(str(A),str(B),str(C),str(D)))\n                # Creating System\n                systemInput = (A,B,C,D)\n                sys1 = control.ss(A,B,C,D)\n            elif Tab == 3: #ODE\n                raise Exception(""ODE Input is not implemented yet"")\n            else: # Can not occur...\n                raise Exception(""Tab {} in Control->Input Tab is unknown"".format(str(Tab)))\n            \n            sysObject = SystemClass(sys1,Name,Tab,systemInput)\n            self.ControlSystems_1_System_Display_LaTeX(sysObject)\n            self.ControlSystems_1_SystemList.addItem(sysObject.Item())\n            # TODO: Deal with duplicated names\n            # REMINDER: Save duplicate in other list item to prevent accidental overwrites\n            # REMINDER: Save deleted items in other list item to prevent accidental deletions\n            \n            print(sys1)\n            return sysObject\n        except common_exceptions:\n            NC(exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Save"",win=self.windowTitle(),input=""Control->Input Tab Number = {}\\nSystem: {}"".format(str(Tab),str(sys1)))\n            return False\n    \n    def ControlSystems_1_System_Plot_and_Save(self):\n        sysObject = self.ControlSystems_1_System_Save()\n        if sysObject == False:\n            pass\n        else:\n            self.ControlSystems_1_System_Plot(sysObject)\n    \n    def ControlSystems_1_System_Plot(self,sysObject):\n        try:\n            self.ControlSystems_2_Display.Display(sysObject.sys, Ufunc=self.ControlSystems_1_Input_InputFunction.text())\n            self.ControlSystems_tabWidget.setFocus()\n            self.ControlSystems_3_SingleDisplay.clear()\n            self.ControlSystems_tabWidget.setCurrentIndex(1)\n        except common_exceptions:\n            NC(exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Plot"",win=self.windowTitle(),input=str(sysObject.sys))\n    \n    def ControlSystems_1_System_Display_LaTeX(self,sysObject):\n        try:\n            self.ControlSystems_1_Output_2L_LaTeXDisplay.DisplayRaw(sysObject.Sys_LaTeX_L,sysObject.Sys_LaTeX_N\n                                            ,self.TopBar.Font_Size_spinBox.value()\n                                            ,QtWidgets.QApplication.instance().MainWindow.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                            )\n        except common_exceptions:\n            NC(exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_1_System_Display_LaTeX"",win=self.windowTitle(),input=str(sysObject.sys))\n    \n    def ControlSystems_4_Dirty_Display(self):\n        if not QtWidgets.QApplication.instance().advanced_mode:\n            NC(3,""This is the \\""danger zone\\""!\\nPlease activate Advanced Mode to confirm that you know what you are doing!"",func=""AMaDiA_Control_Window.ControlSystems_4_Dirty_Display"",win=str(self.windowTitle()),input=""Advanced Mode: {}"".format(str(QtWidgets.QApplication.instance().advanced_mode)))\n        else:\n            self.ControlSystems_tabWidget.setCurrentIndex(1)\n            input_text = ""from External_Libraries.python_control_master.control import * \\nglobal sys1\\nglobal u\\nu=\\""\\""\\n"" + self.ControlSystems_4_Dirty_Input.toPlainText()\n            #K_D,K_P,K_i = 0,1,0\n            try:\n                g,l = dict(),dict()\n                exec(input_text,g,l)\n                print(g[""sys1""])\n                self.ControlSystems_2_Display.Display(g[""sys1""],Ufunc=g[""u""])\n                self.ControlSystems_tabWidget.setFocus()\n                self.ControlSystems_3_SingleDisplay.clear()\n                # Generate LaTeX of tf:\n                sys1 = g[""sys1""]\n                Ys,Xs = control.tfdata(sys1)\n                Ys,Xs = Ys[0][0],Xs[0][0]\n                Gs = ""Eq(G(s),(""\n                YStr = []\n                i = len(Ys)-1\n                while i >= 0:\n                    if Ys[len(Ys)-i-1] != 0:\n                        if i == 0:\n                            s = ""{}"".format(Ys[len(Ys)-i-1])\n                        else:\n                            s = ""{}*s**({})"".format(Ys[len(Ys)-i-1],i)\n                        YStr.append(s)\n                    i-=1\n                Gs += ""+"".join(YStr)\n                Gs += "")/(""\n                XStr = []\n                i = len(Xs)-1\n                while i >= 0:\n                    if Xs[len(Xs)-i-1] != 0:\n                        if i == 0:\n                            s = ""{}"".format(Xs[len(Xs)-i-1])\n                        else:\n                            s = ""{}*s**({})"".format(Xs[len(Xs)-i-1],i)\n                        XStr.append(s)\n                    i-=1\n                Gs += ""+"".join(XStr)\n                Gs += ""))""\n                Gs = AF.number_shaver(Gs)\n                Sys_Gs = parse_expr(Gs,evaluate=False)\n                Sys_Gs_LaTeX = sympy.latex(Sys_Gs)\n                Sys_Gs_LaTeX_L = r""$\\displaystyle ""\n                Sys_Gs_LaTeX_N = ""$""\n                Sys_Gs_LaTeX_L += Sys_Gs_LaTeX\n                Sys_Gs_LaTeX_N += Sys_Gs_LaTeX\n                Sys_Gs_LaTeX_L += ""$""\n                Sys_Gs_LaTeX_N += ""$""\n                \n                # Generate LaTeX of ss:\n                A,B,C,D = control.ssdata(sys1)\n                Order = A.shape[0]\n                x_vec = []\n                x_vec_diff = []\n                i=1\n                while i <= Order:\n                    x_vec.append(""x_{}(t)"".format(i))\n                    x_vec_diff.append(""diff(x_{}(t),t)"".format(i))\n                    i+=1\n                x_vec = str(sympy.Matrix(x_vec))\n                x_vec_diff = str(sympy.Matrix(x_vec_diff))\n                A,B = AF.number_shaver(str(sympy.Matrix(A))) , AF.number_shaver(str(sympy.Matrix(B)))\n                C,D = AF.number_shaver(str(sympy.Matrix(C))) , AF.number_shaver(str(sympy.Matrix(D)))\n                SSx_LaTeX = AF.LaTeX(""Eq(""+x_vec_diff+"",""+A+""*""+x_vec+""+""+B+""*u(t))"")\n                SSy_LaTeX = AF.LaTeX(""Eq(y(t),""+C+""*""+x_vec+""+""+D+""*u(t))"")\n                Sys_SS_LaTeX_L = r""$\\displaystyle "" + SSx_LaTeX + ""$\\n"" + r""$\\displaystyle "" + SSy_LaTeX + ""$""\n                Sys_SS_LaTeX_N = ""$"" + SSx_LaTeX + ""$\\n$"" + SSy_LaTeX + ""$""\n                \n                \n                # Display LaTeX:\n                Sys_LaTeX_L = ""From Code Input:\\nTransfer Function:\\n"" + Sys_Gs_LaTeX_L + ""\\nState Space:\\n"" + Sys_SS_LaTeX_L\n                Sys_LaTeX_N = ""From Code Input:\\nTransfer Function:\\n"" + Sys_Gs_LaTeX_N + ""\\nState Space:\\n"" + Sys_SS_LaTeX_N\n                self.ControlSystems_1_Output_2L_LaTeXDisplay.DisplayRaw(Sys_LaTeX_L,Sys_LaTeX_N\n                                                ,self.TopBar.Font_Size_spinBox.value()\n                                                ,QtWidgets.QApplication.instance().MainWindow.Menu_Options_action_Use_Pretty_LaTeX_Display.isChecked()\n                                                )\n            except common_exceptions:\n                NC(1,""Could not execute code to generate the system"",exc=sys.exc_info(),func=""AMaDiA_Control_Window.ControlSystems_4_Dirty_Display"",win=self.windowTitle(),input=input_text)\n                self.ControlSystems_tabWidget.setCurrentIndex(3)\n'"
AMaDiA_Files/AMaDiA_SystemControl_UI.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'AMaDiA_SystemControl_UI.ui\'\n#\n# Created by: PyQt5 UI code generator 5.9.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_SystemControlWindow(object):\n    def setupUi(self, SystemControlWindow):\n        SystemControlWindow.setObjectName(""SystemControlWindow"")\n        SystemControlWindow.resize(800, 600)\n        self.centralwidget = QtWidgets.QWidget(SystemControlWindow)\n        self.centralwidget.setObjectName(""centralwidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n        self.gridLayout.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout.setSpacing(0)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.ControlSystems_tabWidget = MTabWidget(self.centralwidget)\n        self.ControlSystems_tabWidget.setObjectName(""ControlSystems_tabWidget"")\n        self.ControlSystems_1 = QtWidgets.QWidget()\n        self.ControlSystems_1.setObjectName(""ControlSystems_1"")\n        self.gridLayout_26 = QtWidgets.QGridLayout(self.ControlSystems_1)\n        self.gridLayout_26.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_26.setSpacing(0)\n        self.gridLayout_26.setObjectName(""gridLayout_26"")\n        self.ControlSystems_1_Splitter_M = QtWidgets.QSplitter(self.ControlSystems_1)\n        self.ControlSystems_1_Splitter_M.setOrientation(QtCore.Qt.Horizontal)\n        self.ControlSystems_1_Splitter_M.setObjectName(""ControlSystems_1_Splitter_M"")\n        self.ControlSystems_1_Splitter_L = QtWidgets.QSplitter(self.ControlSystems_1_Splitter_M)\n        self.ControlSystems_1_Splitter_L.setOrientation(QtCore.Qt.Vertical)\n        self.ControlSystems_1_Splitter_L.setObjectName(""ControlSystems_1_Splitter_L"")\n        self.layoutWidget = QtWidgets.QWidget(self.ControlSystems_1_Splitter_L)\n        self.layoutWidget.setObjectName(""layoutWidget"")\n        self.gridLayout_15 = QtWidgets.QGridLayout(self.layoutWidget)\n        self.gridLayout_15.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_15.setObjectName(""gridLayout_15"")\n        self.ControlSystems_1_SystemOrder_Confrim = QtWidgets.QPushButton(self.layoutWidget)\n        self.ControlSystems_1_SystemOrder_Confrim.setObjectName(""ControlSystems_1_SystemOrder_Confrim"")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_SystemOrder_Confrim, 1, 1, 1, 1)\n        self.ControlSystems_1_NameInput = QtWidgets.QLineEdit(self.layoutWidget)\n        self.ControlSystems_1_NameInput.setObjectName(""ControlSystems_1_NameInput"")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_NameInput, 1, 2, 1, 1)\n        self.ControlSystems_1_SystemOrder_Spinbox = QtWidgets.QSpinBox(self.layoutWidget)\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Maximum, QtWidgets.QSizePolicy.Maximum)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.ControlSystems_1_SystemOrder_Spinbox.sizePolicy().hasHeightForWidth())\n        self.ControlSystems_1_SystemOrder_Spinbox.setSizePolicy(sizePolicy)\n        self.ControlSystems_1_SystemOrder_Spinbox.setMinimum(1)\n        self.ControlSystems_1_SystemOrder_Spinbox.setProperty(""value"", 3)\n        self.ControlSystems_1_SystemOrder_Spinbox.setObjectName(""ControlSystems_1_SystemOrder_Spinbox"")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_SystemOrder_Spinbox, 1, 0, 1, 1)\n        self.ControlSystems_1_SavePlotButton = QtWidgets.QPushButton(self.layoutWidget)\n        self.ControlSystems_1_SavePlotButton.setObjectName(""ControlSystems_1_SavePlotButton"")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_SavePlotButton, 1, 4, 1, 1)\n        self.ControlSystems_1_SaveButton = QtWidgets.QPushButton(self.layoutWidget)\n        self.ControlSystems_1_SaveButton.setObjectName(""ControlSystems_1_SaveButton"")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_SaveButton, 1, 3, 1, 1)\n        self.ControlSystems_1_System_tabWidget = QtWidgets.QTabWidget(self.layoutWidget)\n        self.ControlSystems_1_System_tabWidget.setObjectName(""ControlSystems_1_System_tabWidget"")\n        self.ControlSystems_1_System_4ATF = QtWidgets.QWidget()\n        self.ControlSystems_1_System_4ATF.setObjectName(""ControlSystems_1_System_4ATF"")\n        self.gridLayout_28 = QtWidgets.QGridLayout(self.ControlSystems_1_System_4ATF)\n        self.gridLayout_28.setObjectName(""gridLayout_28"")\n        self.gridLayout_27 = QtWidgets.QGridLayout()\n        self.gridLayout_27.setObjectName(""gridLayout_27"")\n        self.ControlSystems_1_System_4ATF_Ys = AMaDiA_LineEdit(self.ControlSystems_1_System_4ATF)\n        self.ControlSystems_1_System_4ATF_Ys.setObjectName(""ControlSystems_1_System_4ATF_Ys"")\n        self.gridLayout_27.addWidget(self.ControlSystems_1_System_4ATF_Ys, 0, 0, 1, 1)\n        self.line_3 = QtWidgets.QFrame(self.ControlSystems_1_System_4ATF)\n        self.line_3.setFrameShadow(QtWidgets.QFrame.Raised)\n        self.line_3.setLineWidth(4)\n        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_3.setObjectName(""line_3"")\n        self.gridLayout_27.addWidget(self.line_3, 1, 0, 1, 1)\n        self.ControlSystems_1_System_4ATF_Xs = AMaDiA_LineEdit(self.ControlSystems_1_System_4ATF)\n        self.ControlSystems_1_System_4ATF_Xs.setObjectName(""ControlSystems_1_System_4ATF_Xs"")\n        self.gridLayout_27.addWidget(self.ControlSystems_1_System_4ATF_Xs, 2, 0, 1, 1)\n        self.gridLayout_28.addLayout(self.gridLayout_27, 0, 0, 1, 1)\n        self.ControlSystems_1_System_tabWidget.addTab(self.ControlSystems_1_System_4ATF, """")\n        self.ControlSystems_1_System_1TF = QtWidgets.QWidget()\n        self.ControlSystems_1_System_1TF.setObjectName(""ControlSystems_1_System_1TF"")\n        self.gridLayout_25 = QtWidgets.QGridLayout(self.ControlSystems_1_System_1TF)\n        self.gridLayout_25.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_25.setSpacing(0)\n        self.gridLayout_25.setObjectName(""gridLayout_25"")\n        self.ControlSystems_1_System_1TF_tableWidget = TableWidget(self.ControlSystems_1_System_1TF)\n        self.ControlSystems_1_System_1TF_tableWidget.setRowCount(2)\n        self.ControlSystems_1_System_1TF_tableWidget.setColumnCount(5)\n        self.ControlSystems_1_System_1TF_tableWidget.setObjectName(""ControlSystems_1_System_1TF_tableWidget"")\n        self.ControlSystems_1_System_1TF_tableWidget.horizontalHeader().setDefaultSectionSize(50)\n        self.ControlSystems_1_System_1TF_tableWidget.verticalHeader().setVisible(False)\n        self.gridLayout_25.addWidget(self.ControlSystems_1_System_1TF_tableWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_tabWidget.addTab(self.ControlSystems_1_System_1TF, """")\n        self.ControlSystems_1_System_2SS = QtWidgets.QWidget()\n        self.ControlSystems_1_System_2SS.setObjectName(""ControlSystems_1_System_2SS"")\n        self.gridLayout_19 = QtWidgets.QGridLayout(self.ControlSystems_1_System_2SS)\n        self.gridLayout_19.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_19.setSpacing(0)\n        self.gridLayout_19.setObjectName(""gridLayout_19"")\n        self.ControlSystems_1_System_2SS_tabWidget = QtWidgets.QTabWidget(self.ControlSystems_1_System_2SS)\n        self.ControlSystems_1_System_2SS_tabWidget.setObjectName(""ControlSystems_1_System_2SS_tabWidget"")\n        self.ControlSystems_1_System_2SS_A = QtWidgets.QWidget()\n        self.ControlSystems_1_System_2SS_A.setObjectName(""ControlSystems_1_System_2SS_A"")\n        self.gridLayout_21 = QtWidgets.QGridLayout(self.ControlSystems_1_System_2SS_A)\n        self.gridLayout_21.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_21.setSpacing(0)\n        self.gridLayout_21.setObjectName(""gridLayout_21"")\n        self.ControlSystems_1_System_2SS_A_tableWidget = TableWidget(self.ControlSystems_1_System_2SS_A)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setRowCount(3)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setColumnCount(3)\n        self.ControlSystems_1_System_2SS_A_tableWidget.setObjectName(""ControlSystems_1_System_2SS_A_tableWidget"")\n        self.ControlSystems_1_System_2SS_A_tableWidget.horizontalHeader().setDefaultSectionSize(50)\n        self.gridLayout_21.addWidget(self.ControlSystems_1_System_2SS_A_tableWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_2SS_tabWidget.addTab(self.ControlSystems_1_System_2SS_A, """")\n        self.ControlSystems_1_System_2SS_B = QtWidgets.QWidget()\n        self.ControlSystems_1_System_2SS_B.setObjectName(""ControlSystems_1_System_2SS_B"")\n        self.gridLayout_22 = QtWidgets.QGridLayout(self.ControlSystems_1_System_2SS_B)\n        self.gridLayout_22.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_22.setSpacing(0)\n        self.gridLayout_22.setObjectName(""gridLayout_22"")\n        self.ControlSystems_1_System_2SS_B_tableWidget = TableWidget(self.ControlSystems_1_System_2SS_B)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setRowCount(3)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setColumnCount(1)\n        self.ControlSystems_1_System_2SS_B_tableWidget.setObjectName(""ControlSystems_1_System_2SS_B_tableWidget"")\n        self.gridLayout_22.addWidget(self.ControlSystems_1_System_2SS_B_tableWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_2SS_tabWidget.addTab(self.ControlSystems_1_System_2SS_B, """")\n        self.ControlSystems_1_System_2SS_C = QtWidgets.QWidget()\n        self.ControlSystems_1_System_2SS_C.setObjectName(""ControlSystems_1_System_2SS_C"")\n        self.gridLayout_23 = QtWidgets.QGridLayout(self.ControlSystems_1_System_2SS_C)\n        self.gridLayout_23.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_23.setSpacing(0)\n        self.gridLayout_23.setObjectName(""gridLayout_23"")\n        self.ControlSystems_1_System_2SS_C_tableWidget = TableWidget(self.ControlSystems_1_System_2SS_C)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setRowCount(1)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setColumnCount(3)\n        self.ControlSystems_1_System_2SS_C_tableWidget.setObjectName(""ControlSystems_1_System_2SS_C_tableWidget"")\n        self.ControlSystems_1_System_2SS_C_tableWidget.horizontalHeader().setDefaultSectionSize(50)\n        self.gridLayout_23.addWidget(self.ControlSystems_1_System_2SS_C_tableWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_2SS_tabWidget.addTab(self.ControlSystems_1_System_2SS_C, """")\n        self.ControlSystems_1_System_2SS_D = QtWidgets.QWidget()\n        self.ControlSystems_1_System_2SS_D.setObjectName(""ControlSystems_1_System_2SS_D"")\n        self.gridLayout_24 = QtWidgets.QGridLayout(self.ControlSystems_1_System_2SS_D)\n        self.gridLayout_24.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_24.setSpacing(0)\n        self.gridLayout_24.setObjectName(""gridLayout_24"")\n        self.ControlSystems_1_System_2SS_D_tableWidget = TableWidget(self.ControlSystems_1_System_2SS_D)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setRowCount(1)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setColumnCount(1)\n        self.ControlSystems_1_System_2SS_D_tableWidget.setObjectName(""ControlSystems_1_System_2SS_D_tableWidget"")\n        self.gridLayout_24.addWidget(self.ControlSystems_1_System_2SS_D_tableWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_2SS_tabWidget.addTab(self.ControlSystems_1_System_2SS_D, """")\n        self.gridLayout_19.addWidget(self.ControlSystems_1_System_2SS_tabWidget, 0, 0, 1, 1)\n        self.ControlSystems_1_System_tabWidget.addTab(self.ControlSystems_1_System_2SS, """")\n        self.ControlSystems_1_System_3DE = QtWidgets.QWidget()\n        self.ControlSystems_1_System_3DE.setObjectName(""ControlSystems_1_System_3DE"")\n        self.gridLayout_29 = QtWidgets.QGridLayout(self.ControlSystems_1_System_3DE)\n        self.gridLayout_29.setObjectName(""gridLayout_29"")\n        self.label = QtWidgets.QLabel(self.ControlSystems_1_System_3DE)\n        self.label.setWordWrap(True)\n        self.label.setObjectName(""label"")\n        self.gridLayout_29.addWidget(self.label, 0, 0, 1, 1)\n        self.ControlSystems_1_System_tabWidget.addTab(self.ControlSystems_1_System_3DE, """")\n        self.gridLayout_15.addWidget(self.ControlSystems_1_System_tabWidget, 0, 0, 1, 5)\n        self.gridLayoutWidget = QtWidgets.QWidget(self.ControlSystems_1_Splitter_L)\n        self.gridLayoutWidget.setObjectName(""gridLayoutWidget"")\n        self.gridLayout_20 = QtWidgets.QGridLayout(self.gridLayoutWidget)\n        self.gridLayout_20.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_20.setObjectName(""gridLayout_20"")\n        self.ControlSystems_1_SystemList = ListWidget(self.gridLayoutWidget)\n        self.ControlSystems_1_SystemList.setObjectName(""ControlSystems_1_SystemList"")\n        self.gridLayout_20.addWidget(self.ControlSystems_1_SystemList, 0, 0, 1, 1)\n        self.ControlSystems_1_Splitter_R = QtWidgets.QSplitter(self.ControlSystems_1_Splitter_M)\n        self.ControlSystems_1_Splitter_R.setOrientation(QtCore.Qt.Vertical)\n        self.ControlSystems_1_Splitter_R.setObjectName(""ControlSystems_1_Splitter_R"")\n        self.ControlSystems_1_Output_tabWidget = QtWidgets.QTabWidget(self.ControlSystems_1_Splitter_R)\n        self.ControlSystems_1_Output_tabWidget.setObjectName(""ControlSystems_1_Output_tabWidget"")\n        self.ControlSystems_1_Output_2L = QtWidgets.QWidget()\n        self.ControlSystems_1_Output_2L.setObjectName(""ControlSystems_1_Output_2L"")\n        self.gridLayout_18 = QtWidgets.QGridLayout(self.ControlSystems_1_Output_2L)\n        self.gridLayout_18.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_18.setSpacing(0)\n        self.gridLayout_18.setObjectName(""gridLayout_18"")\n        self.ControlSystems_1_Output_2L_LaTeXDisplay = MplWidget_LaTeX(self.ControlSystems_1_Output_2L)\n        self.ControlSystems_1_Output_2L_LaTeXDisplay.setObjectName(""ControlSystems_1_Output_2L_LaTeXDisplay"")\n        self.gridLayout_18.addWidget(self.ControlSystems_1_Output_2L_LaTeXDisplay, 0, 0, 1, 1)\n        self.ControlSystems_1_Output_tabWidget.addTab(self.ControlSystems_1_Output_2L, """")\n        self.ControlSystems_1_Output_1R = QtWidgets.QWidget()\n        self.ControlSystems_1_Output_1R.setObjectName(""ControlSystems_1_Output_1R"")\n        self.ControlSystems_1_Output_tabWidget.addTab(self.ControlSystems_1_Output_1R, """")\n        self.ControlSystems_1_Input_tabWidget = QtWidgets.QTabWidget(self.ControlSystems_1_Splitter_R)\n        self.ControlSystems_1_Input_tabWidget.setObjectName(""ControlSystems_1_Input_tabWidget"")\n        self.ControlSystems_1_Input_1I = QtWidgets.QWidget()\n        self.ControlSystems_1_Input_1I.setObjectName(""ControlSystems_1_Input_1I"")\n        self.gridLayout_30 = QtWidgets.QGridLayout(self.ControlSystems_1_Input_1I)\n        self.gridLayout_30.setObjectName(""gridLayout_30"")\n        self.ControlSystems_1_Input_InputFunction = AMaDiA_LineEdit(self.ControlSystems_1_Input_1I)\n        self.ControlSystems_1_Input_InputFunction.setObjectName(""ControlSystems_1_Input_InputFunction"")\n        self.gridLayout_30.addWidget(self.ControlSystems_1_Input_InputFunction, 1, 1, 1, 1)\n        self.ControlSystems_1_Input_InputFunction_Label = QtWidgets.QLabel(self.ControlSystems_1_Input_1I)\n        self.ControlSystems_1_Input_InputFunction_Label.setWordWrap(True)\n        self.ControlSystems_1_Input_InputFunction_Label.setObjectName(""ControlSystems_1_Input_InputFunction_Label"")\n        self.gridLayout_30.addWidget(self.ControlSystems_1_Input_InputFunction_Label, 1, 0, 1, 1)\n        self.line_4 = QtWidgets.QFrame(self.ControlSystems_1_Input_1I)\n        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)\n        self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)\n        self.line_4.setObjectName(""line_4"")\n        self.gridLayout_30.addWidget(self.line_4, 0, 0, 1, 2)\n        self.ControlSystems_1_Input_tabWidget.addTab(self.ControlSystems_1_Input_1I, """")\n        self.ControlSystems_1_Input_2P = QtWidgets.QWidget()\n        self.ControlSystems_1_Input_2P.setObjectName(""ControlSystems_1_Input_2P"")\n        self.ControlSystems_1_Input_tabWidget.addTab(self.ControlSystems_1_Input_2P, """")\n        self.gridLayout_26.addWidget(self.ControlSystems_1_Splitter_M, 0, 0, 1, 1)\n        self.ControlSystems_tabWidget.addTab(self.ControlSystems_1, """")\n        self.ControlSystems_2 = QtWidgets.QWidget()\n        self.ControlSystems_2.setObjectName(""ControlSystems_2"")\n        self.gridLayout_14 = QtWidgets.QGridLayout(self.ControlSystems_2)\n        self.gridLayout_14.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_14.setSpacing(0)\n        self.gridLayout_14.setObjectName(""gridLayout_14"")\n        self.ControlSystems_2_Display = MplWidget_CONTROL(self.ControlSystems_2)\n        self.ControlSystems_2_Display.setObjectName(""ControlSystems_2_Display"")\n        self.gridLayout_14.addWidget(self.ControlSystems_2_Display, 0, 0, 1, 1)\n        self.ControlSystems_tabWidget.addTab(self.ControlSystems_2, """")\n        self.ControlSystems_3 = QtWidgets.QWidget()\n        self.ControlSystems_3.setObjectName(""ControlSystems_3"")\n        self.gridLayout_17 = QtWidgets.QGridLayout(self.ControlSystems_3)\n        self.gridLayout_17.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_17.setSpacing(0)\n        self.gridLayout_17.setObjectName(""gridLayout_17"")\n        self.ControlSystems_3_SingleDisplay = MplWidget_CONTROL_single_plot(self.ControlSystems_3)\n        self.ControlSystems_3_SingleDisplay.setObjectName(""ControlSystems_3_SingleDisplay"")\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        sizePolicy.setHeightForWidth(self.ControlSystems_3_SingleDisplay.sizePolicy().hasHeightForWidth())\n        self.ControlSystems_3_SingleDisplay.setSizePolicy(sizePolicy)\n        self.gridLayout_17.addWidget(self.ControlSystems_3_SingleDisplay, 0, 0, 1, 1)\n        self.ControlSystems_tabWidget.addTab(self.ControlSystems_3, """")\n        self.ControlSystems_4 = QtWidgets.QWidget()\n        self.ControlSystems_4.setObjectName(""ControlSystems_4"")\n        self.gridLayout_16 = QtWidgets.QGridLayout(self.ControlSystems_4)\n        self.gridLayout_16.setContentsMargins(0, 0, 0, 0)\n        self.gridLayout_16.setObjectName(""gridLayout_16"")\n        self.ControlSystems_4_Dirty_Input = AMaDiA_TextEdit(self.ControlSystems_4)\n        self.ControlSystems_4_Dirty_Input.setObjectName(""ControlSystems_4_Dirty_Input"")\n        self.gridLayout_16.addWidget(self.ControlSystems_4_Dirty_Input, 0, 0, 1, 1)\n        self.ControlSystems_tabWidget.addTab(self.ControlSystems_4, """")\n        self.gridLayout.addWidget(self.ControlSystems_tabWidget, 0, 0, 1, 1)\n        SystemControlWindow.setCentralWidget(self.centralwidget)\n\n        self.retranslateUi(SystemControlWindow)\n        self.ControlSystems_tabWidget.setCurrentIndex(0)\n        self.ControlSystems_1_System_tabWidget.setCurrentIndex(0)\n        self.ControlSystems_1_System_2SS_tabWidget.setCurrentIndex(0)\n        self.ControlSystems_1_Output_tabWidget.setCurrentIndex(0)\n        self.ControlSystems_1_Input_tabWidget.setCurrentIndex(0)\n        QtCore.QMetaObject.connectSlotsByName(SystemControlWindow)\n\n    def retranslateUi(self, SystemControlWindow):\n        _translate = QtCore.QCoreApplication.translate\n        SystemControlWindow.setWindowTitle(_translate(""SystemControlWindow"", ""System Control Window""))\n        self.ControlSystems_1_SystemOrder_Confrim.setToolTip(_translate(""SystemControlWindow"", ""Not necessary for Transfer-Tab""))\n        self.ControlSystems_1_SystemOrder_Confrim.setText(_translate(""SystemControlWindow"", ""Set Order""))\n        self.ControlSystems_1_NameInput.setPlaceholderText(_translate(""SystemControlWindow"", ""Name""))\n        self.ControlSystems_1_SavePlotButton.setText(_translate(""SystemControlWindow"", ""Save and Plot""))\n        self.ControlSystems_1_SaveButton.setText(_translate(""SystemControlWindow"", ""Save""))\n        self.ControlSystems_1_System_4ATF_Ys.setPlaceholderText(_translate(""SystemControlWindow"", ""Y(s)""))\n        self.ControlSystems_1_System_4ATF_Xs.setPlaceholderText(_translate(""SystemControlWindow"", ""X(s)""))\n        self.ControlSystems_1_System_tabWidget.setTabText(self.ControlSystems_1_System_tabWidget.indexOf(self.ControlSystems_1_System_4ATF), _translate(""SystemControlWindow"", ""Transfer""))\n        self.ControlSystems_1_System_tabWidget.setTabText(self.ControlSystems_1_System_tabWidget.indexOf(self.ControlSystems_1_System_1TF), _translate(""SystemControlWindow"", ""TF Table""))\n        self.ControlSystems_1_System_2SS_tabWidget.setTabText(self.ControlSystems_1_System_2SS_tabWidget.indexOf(self.ControlSystems_1_System_2SS_A), _translate(""SystemControlWindow"", ""A: State Matrix""))\n        self.ControlSystems_1_System_2SS_tabWidget.setTabText(self.ControlSystems_1_System_2SS_tabWidget.indexOf(self.ControlSystems_1_System_2SS_B), _translate(""SystemControlWindow"", ""B: Input Vector""))\n        self.ControlSystems_1_System_2SS_tabWidget.setTabText(self.ControlSystems_1_System_2SS_tabWidget.indexOf(self.ControlSystems_1_System_2SS_C), _translate(""SystemControlWindow"", ""C: Output Vector""))\n        self.ControlSystems_1_System_2SS_tabWidget.setTabText(self.ControlSystems_1_System_2SS_tabWidget.indexOf(self.ControlSystems_1_System_2SS_D), _translate(""SystemControlWindow"", ""D: Feedthrough Vector""))\n        self.ControlSystems_1_System_tabWidget.setTabText(self.ControlSystems_1_System_tabWidget.indexOf(self.ControlSystems_1_System_2SS), _translate(""SystemControlWindow"", ""State Space""))\n        self.label.setText(_translate(""SystemControlWindow"", ""Not implemented yet""))\n        self.ControlSystems_1_System_tabWidget.setTabText(self.ControlSystems_1_System_tabWidget.indexOf(self.ControlSystems_1_System_3DE), _translate(""SystemControlWindow"", ""ODE""))\n        self.ControlSystems_1_Output_tabWidget.setTabText(self.ControlSystems_1_Output_tabWidget.indexOf(self.ControlSystems_1_Output_2L), _translate(""SystemControlWindow"", ""LaTeX""))\n        self.ControlSystems_1_Output_tabWidget.setTabText(self.ControlSystems_1_Output_tabWidget.indexOf(self.ControlSystems_1_Output_1R), _translate(""SystemControlWindow"", ""Results""))\n        self.ControlSystems_1_Input_InputFunction.setPlaceholderText(_translate(""SystemControlWindow"", ""u(s)""))\n        self.ControlSystems_1_Input_InputFunction_Label.setToolTip(_translate(""SystemControlWindow"", ""This function will be used for the \\""Forced Response\\"" plot""))\n        self.ControlSystems_1_Input_InputFunction_Label.setText(_translate(""SystemControlWindow"", ""Input Function:""))\n        self.ControlSystems_1_Input_tabWidget.setTabText(self.ControlSystems_1_Input_tabWidget.indexOf(self.ControlSystems_1_Input_1I), _translate(""SystemControlWindow"", ""Input""))\n        self.ControlSystems_1_Input_tabWidget.setTabText(self.ControlSystems_1_Input_tabWidget.indexOf(self.ControlSystems_1_Input_2P), _translate(""SystemControlWindow"", ""Plot Config""))\n        self.ControlSystems_tabWidget.setTabText(self.ControlSystems_tabWidget.indexOf(self.ControlSystems_1), _translate(""SystemControlWindow"", ""Input""))\n        self.ControlSystems_tabWidget.setTabText(self.ControlSystems_tabWidget.indexOf(self.ControlSystems_2), _translate(""SystemControlWindow"", ""Plots""))\n        self.ControlSystems_tabWidget.setTabText(self.ControlSystems_tabWidget.indexOf(self.ControlSystems_3), _translate(""SystemControlWindow"", ""Single Plot""))\n        self.ControlSystems_tabWidget.setTabText(self.ControlSystems_tabWidget.indexOf(self.ControlSystems_4), _translate(""SystemControlWindow"", ""Code Input""))\n\nfrom AGeLib.AGeMain import ListWidget, MTabWidget, MplWidget_LaTeX, TableWidget\nfrom AMaDiA_Files.AMaDiA_SystemControl_Widgets import MplWidget_CONTROL, MplWidget_CONTROL_single_plot\nfrom AMaDiA_Files.AMaDiA_Widgets import AMaDiA_LineEdit, AMaDiA_TextEdit\n'"
AMaDiA_Files/AMaDiA_SystemControl_Widgets.py,9,"b'from AGeLib import *\n\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5.Qt import QApplication, QClipboard # pylint: disable=no-name-in-module\nfrom PyQt5 import QtWidgets,QtCore,QtGui,Qt\n\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\nimport matplotlib\nimport matplotlib.pyplot as plt\n#matplotlib.use(\'Qt5Agg\')\nfrom mpl_toolkits.axes_grid1 import Divider, Size\nfrom mpl_toolkits.axes_grid1.mpl_axes import Axes\nimport numpy as np\nimport scipy\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nimport re\nimport time\n\nimport warnings\n\nfrom External_Libraries.python_control_master import control\n\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_Classes as AC\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\nfrom AMaDiA_Files import AMaDiA_Widgets as AW\n# -----------------------------------------------------------------------------------------------------------------\n#FEATURE: Try to use pyqtgraph for the plots to greatly increase performance\nclass MplCanvas_CONTROL(Canvas):\n    Titles = [\'Step Response\',\'Impulse Response\',\'Forced Response\',\n                        \'Bode Plot\',\'BODE_PLOT_2\',\n                        \'Nyquist Plot\',\'Nichols Plot\',\'Pole-Zero-Plot\',\n                        \'Root-Locus-Plot\',\'LaTeX-Display\']\n    def __init__(self):\n        #self.fig = Figure()\n        self.fig = plt.figure(num=""CONTROL"",constrained_layout =True)\n        self.fig.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n\n        combined = True # should Phase and Magnitude of the Bodeplot share a plot?\n        if combined:\n            self.gs = self.fig.add_gridspec(3, 3)\n            \n            self.p_step_response = self.fig.add_subplot(self.gs[0,0])\n            self.p_impulse_response = self.fig.add_subplot(self.gs[0,1])\n            self.p_forced_response = self.fig.add_subplot(self.gs[0,2])\n            self.p_bode_plot_1 = self.fig.add_subplot(self.gs[1,0])\n            self.p_bode_plot_2 = self.p_bode_plot_1.twinx()\n            self.p_nyquist_plot = self.fig.add_subplot(self.gs[1,1])\n            self.p_nichols_plot = self.fig.add_subplot(self.gs[1,2])\n            self.p_pzmap = self.fig.add_subplot(self.gs[2:,0])\n            self.p_root_locus = self.fig.add_subplot(self.gs[2:,1])\n            self.p_LaTeX_Display = self.fig.add_subplot(self.gs[2:,2])\n        \n        else:\n            self.gs = self.fig.add_gridspec(6, 3)\n            \n            self.p_step_response = self.fig.add_subplot(self.gs[0:2,0])\n            self.p_impulse_response = self.fig.add_subplot(self.gs[0:2,1])\n            self.p_TODO = self.fig.add_subplot(self.gs[0:2,2])     #TODO\n            self.p_bode_plot_2 = self.fig.add_subplot(self.gs[3,0])\n            self.p_bode_plot_1 = self.fig.add_subplot(self.gs[2,0],sharex=self.p_bode_plot_2)\n            self.p_nyquist_plot = self.fig.add_subplot(self.gs[2:4,1])\n            self.p_nichols_plot = self.fig.add_subplot(self.gs[2:4,2])\n            self.p_pzmap = self.fig.add_subplot(self.gs[4:,0])\n            self.p_root_locus = self.fig.add_subplot(self.gs[4:,1])\n            self.p_LaTeX_Display = self.fig.add_subplot(self.gs[4:,2])\n\n        self.p_plot_LIST = [ self.p_step_response, self.p_impulse_response, self.p_forced_response,\n                            self.p_bode_plot_1, self.p_bode_plot_2,\n                            self.p_nyquist_plot, self.p_nichols_plot, self.p_pzmap,\n                            self.p_root_locus, self.p_LaTeX_Display]\n        \n        for i,p in enumerate(self.p_plot_LIST):\n            p.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n            if self.Titles[i] == ""BODE_PLOT_2"":\n                p.set_title(""  "")\n            elif self.Titles[i] != \'LaTeX-Display\':\n                p.set_title(self.Titles[i])\n            # set labels that control can find the axes\n            if self.Titles[i] == ""Bode Plot"":\n                p.set_label(\'control-bode-magnitude\')\n            elif self.Titles[i] == ""BODE_PLOT_2"":\n                p.set_label(\'control-bode-phase\')\n            #elif self.Titles[i] == \'Nyquist Plot\':\n            #    p.set_label(\'control-nyquist\')\n        #self.fig.tight_layout()\n        \n        Canvas.__init__(self, self.fig)\n        Canvas.setSizePolicy(self, QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        Canvas.updateGeometry(self)\n\nclass MplWidget_CONTROL(MplWidget):\n    def __init__(self, parent=None):\n        super(MplWidget_CONTROL, self).__init__(parent)\n        QtWidgets.QWidget.__init__(self)           # Inherit from QWidget\n        self.canvas = MplCanvas_CONTROL()                  # Create canvas object\n        self.vbl = QtWidgets.QVBoxLayout()         # Set box for plotting\n        self.vbl.addWidget(self.canvas)\n        self.setLayout(self.vbl)\n        self.layout().setContentsMargins(0,0,0,0)\n        \n        \n        #self.setLayout(QtWidgets.QVBoxLayout())\n        #self.scroll = QtWidgets.QScrollArea(self)\n        #self.scroll.setWidget(self.canvas)\n\n        self.Curr_Sys = (None, None, 0.0, 0.0, """", """")\n        self.LastCall = False\n        self.Curr_Sys_LaTeX = """"\n        \n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        try:\n            if BG != None and FG != None:\n                self.background_Colour = BG\n                self.TextColour = FG\n                self.HexcolourText = \'#%02x%02x%02x\' % (int(self.TextColour[0]*255),int(self.TextColour[1]*255),int(self.TextColour[2]*255))\n            self.canvas.fig.set_facecolor(self.background_Colour)\n            self.canvas.fig.set_edgecolor(self.background_Colour)\n            for i,p in enumerate(self.canvas.p_plot_LIST):\n                p.set_facecolor(self.background_Colour)\n                if p.get_title() == ""N/A"":\n                    p.axis(\'off\')\n                    p.text(0.5,0.5,""N/A"", horizontalalignment=\'center\', verticalalignment=\'center\',color=self.TextColour)\n                    p.set_title(self.canvas.Titles[i],color=self.TextColour)\n                    continue\n                if self.canvas.Titles[i] == ""BODE_PLOT_2"":\n                    p.set_title(""  "",color=self.TextColour)\n                elif self.canvas.Titles[i] != \'LaTeX-Display\':\n                    p.set_title(self.canvas.Titles[i],color=self.TextColour)\n                if self.canvas.Titles[i] == ""BODE_PLOT_2"" or self.canvas.Titles[i] == \'Bode Plot\':\n                    p.spines[\'right\'].set_color(self.TextColour)\n                else:\n                    p.yaxis.label.set_color(self.TextColour)\n                p.xaxis.label.set_color(self.TextColour)\n                p.spines[\'bottom\'].set_color(self.TextColour)\n                p.spines[\'left\'].set_color(self.TextColour)\n                p.tick_params(axis=\'x\', colors=self.TextColour)\n                p.tick_params(axis=\'y\', colors=self.TextColour)\n                if self.canvas.Titles[i] == \'LaTeX-Display\':\n                    p.axis(\'off\')\n            self.canvas.p_LaTeX_Display.text(0.5,0.5,self.Curr_Sys_LaTeX, horizontalalignment=\'center\', verticalalignment=\'center\',color=self.TextColour)#,usetex=True)\n            if self.Curr_Sys[4] != """" and False: # Disabled since the Legend covers the entire axes when Window not fullscreen\n                self.canvas.p_forced_response.legend([""Input Function: ""+self.Curr_Sys[4]])#,color=self.TextColour)\n        except common_exceptions:\n            NC(2,""Could not set all colours for the system plots"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".SetColour"")\n        try:\n            self.canvas.draw()\n        except common_exceptions:\n            NC(1,""Could not draw system plots"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".SetColour"")\n        \n        #if self.LastCall != False:\n        #    self.Display(self.LastCall[0],self.LastCall[1],self.LastCall[2],self.LastCall[3])\n        #else:\n        #    try:\n        #        self.canvas.draw()\n        #    except common_exceptions:\n        #        pass\n    \n    def UseTeX(self,TheBool):\n        # This Method changes the settings for not only one but all widgets...\n        # This makes the clear function of the plotter slow if the LaTeX display has been used in LaTeX mode directly before\n        # It could help to separate the two widgets into two files...\n        # ... but it is also possible that this setting is global not only for the file but the program which would make the seperation a massive waste of time...\n        # Maybe test this in a little testprogram to not waste that much time...\n        \n        matplotlib.rcParams[\'text.latex.preamble\'] = r\'\\usepackage{amsmath}\'\n        #Both seem to do the same:\n        matplotlib.rcParams[\'text.usetex\'] = TheBool\n        plt.rc(\'text\', usetex=TheBool)\n        return matplotlib.rcParams[\'text.usetex\']\n    \n    def Display(self,sys1,Use_LaTeX = False, T=None, X0 = 0.0, U=0.0, Ufunc = """"):\n        """"""\n        Retrun value compatible as argument to init NC   \\n\n        sys1 = System   \\n\n        Use_LaTeX = bool   \\n\n        T = Time steps at which the input is defined; values must be evenly spaced.   \\n\n        X0 = Initial condition   \\n\n        U = Input array giving input at each time T used for ""Forced Response""-plot   \\n\n        Ufunc = string (Name of the function that created U)\n        """"""\n        try:\n            with warnings.catch_warnings():\n                warnings.simplefilter(""ignore"")\n                for i in self.canvas.p_plot_LIST:\n                    i.clear()\n            Torig = T\n            Uorig = U\n            try:\n                if T == None:\n                    syst = control.timeresp._get_ss_simo(sys1)\n                    T = scipy.signal.ltisys._default_response_times(syst.A, 500)\n\n                # If U not given try to create using Ufunc. If Ufunc not given or creation failed set U and Ufunc to 0\n                if U == 0.0:\n                    if Ufunc != """":\n                        try:\n                            Function = parse_expr(AF.AstusParse(Ufunc))\n                            s = sympy.symbols(\'s\')\n                            evalfunc = sympy.lambdify(s, Function, modules=[\'numpy\',\'sympy\'])\n                            U = evalfunc(T)\n                            U = np.asarray(U)\n                            if type(U) == int or type(U) == float or U.shape == (): #This also catches the case exp(x)\n                                U = np.full_like(T, U)\n                            if U.shape != T.shape:\n                                raise Exception(""Dimensions do not match"")\n                        except common_exceptions:\n                            NC(2,""Could not interpret u(s)"",exc=sys.exc_info(),input=Ufunc,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n                            Ufunc = """"\n                    if Ufunc == """":\n                        Ufunc = ""0""\n            except common_exceptions:\n                NC(1,""Could not calculate time steps"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n\n\n            self.Curr_Sys_LaTeX = str(sys1) #TODO: MAKE PROPER LaTeX\n            self.Curr_Sys = (sys1, Torig, X0, Uorig, Ufunc, self.Curr_Sys_LaTeX)\n\n\n            self.canvas.p_bode_plot_1.set_label(\'control-bode-magnitude\')\n            self.canvas.p_bode_plot_2.set_label(\'control-bode-phase\')\n            \n        except common_exceptions:\n            NC(1,""Could not prepare the control display"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.UseTeX(False)\n            return\n        \n        try: # 0\n            oT,y = control.step_response(sys1, number_of_samples=500, T=T, X0 = X0)\n            self.canvas.p_step_response.plot(oT,y,c=App().PenColours[""Red""].color().name(0))\n        except common_exceptions:\n            NC(1,""Could not plot step response"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_step_response.set_title(""N/A"")\n\n        try: # 1\n            oT,y = control.impulse_response(sys1, number_of_samples=500, T=T, X0 = X0)\n            self.canvas.p_impulse_response.plot(oT,y,c=App().PenColours[""Red""].color().name(0))\n        except common_exceptions:\n            NC(1,""Could not plot impulse response"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_impulse_response.set_title(""N/A"")\n\n        try: # 2\n            oT,y, xout = control.forced_response(sys1, T=T, X0 = X0, U=U) # pylint: disable=unused-variable\n            self.canvas.p_forced_response.plot(oT,y,c=App().PenColours[""Red""].color().name(0))\n        except common_exceptions:\n            NC(1,""Could not plot forced response"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_forced_response.set_title(""N/A"")\n\n        try: # 3+4\n            plt.figure(self.canvas.fig.number) # set figure to current that .gfc() in control.bode_plot can find it\n            control.bode_plot(sys1, dB=True, omega_num=500, App=App())\n        except common_exceptions:\n            NC(1,""Could not generate Bode plot"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_bode_plot_1.set_title(""N/A"")\n\n        try: # 5\n            plt.sca(self.canvas.p_nyquist_plot)\n            control.nyquist_plot(sys1,number_of_samples=500,App=App())\n        except common_exceptions:\n            NC(1,""Could not generate Nyquist plot"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_nyquist_plot.set_title(""N/A"")\n\n        try: # 6\n            plt.sca(self.canvas.p_nichols_plot)\n            control.nichols_plot(sys1, number_of_samples=500)\n        except common_exceptions:\n            NC(1,""Could not generate Nichols plot"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_nichols_plot.set_title(""N/A"")\n\n        try: # 7\n            poles,zeros = control.pzmap(sys1,Plot=False)\n            if len(poles) > 0:\n                self.canvas.p_pzmap.scatter(np.real(poles), np.imag(poles), s=50, marker=\'x\', c=App().PenColours[""Red""].color().name(0))\n            if len(zeros) > 0:\n                self.canvas.p_pzmap.scatter(np.real(zeros), np.imag(zeros), s=25, marker=\'o\', c=App().PenColours[""Orange""].color().name(0))\n            self.canvas.p_pzmap.grid(True)\n        except common_exceptions:\n            NC(1,""Could not generate pole-zero-map"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_pzmap.set_title(""N/A"")\n\n        try: # 8\n            #plt.sca(self.canvas.p_root_locus)\n            #control.rlocus(sys1)\n            control.root_locus_AMaDiA(sys1,self.canvas.p_root_locus, App=App())\n            self.canvas.p_root_locus.grid(True)\n        except common_exceptions:\n            NC(1,""Could not generate root locus plot"",exc=sys.exc_info(),input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Display"")\n            self.canvas.p_root_locus.set_title(""N/A"")\n\n        # 9 + Plot\n        self.SetColour() # Set Colour, Titles, etc... and the Display\n        self.UseTeX(False)\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass MplCanvas_CONTROL_single_plot(Canvas):\n    def __init__(self):\n        #self.fig = Figure()\n        self.fig = plt.figure(constrained_layout = True)\n        self.fig.set_facecolor(QtWidgets.QApplication.instance().BG_Colour)\n        \n        self.ax = self.fig.add_subplot(111)\n        self.ax1 = self.ax.twinx()\n        self.ax1.axis(\'off\')\n        \n        Canvas.__init__(self, self.fig)\n        Canvas.setSizePolicy(self, QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)\n        Canvas.updateGeometry(self)\n\nclass MplWidget_CONTROL_single_plot(MplWidget):\n    def __init__(self, parent=None):\n        super(MplWidget_CONTROL_single_plot, self).__init__(parent)\n        self.Bode = False\n        self.FuncLabel = """"\n        self.Title = ""Doubleclick on a control plot to display it here""\n\n        self.Grid = QtWidgets.QGridLayout(self)\n        self.Grid.setContentsMargins(0, 0, 0, 0)\n        self.Grid.setSpacing(0)\n        self.Grid.setObjectName(""Grid"")\n\n        ##self.ScrollWidgetC = QtWidgets.QWidget(self)\n        ##self.ScrollWidgetCGrid = QtWidgets.QGridLayout(self.ScrollWidgetC)\n        ##self.ScrollWidgetCGrid.setContentsMargins(0, 0, 0, 0)\n        ##self.ScrollWidgetCGrid.setSpacing(0)\n        ##self.ScrollWidgetCGrid.setObjectName(""ScrollWidgetCGrid"")\n        #self.ScrollWidget = QtWidgets.QScrollArea(self)#.ScrollWidgetC)\n        #self.ScrollWidget.setWidgetResizable(True)\n        #self.ScrollWidget.setObjectName(""ScrollWidget"")\n        self.ScrollWidgetContents = QtWidgets.QWidget()\n        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Maximum)\n        #sizePolicy.setHorizontalStretch(0)\n        sizePolicy.setVerticalStretch(0)\n        #sizePolicy.setHeightForWidth(self.ScrollWidgetContents.sizePolicy().hasHeightForWidth())\n        self.ScrollWidgetContents.setSizePolicy(sizePolicy)\n        ##self.ScrollWidgetContents.setGeometry(QtCore.QRect(0, 0, 221, 264))\n        self.ScrollWidgetContents.setObjectName(""ScrollWidgetContents"")\n        self.ScrollGrid = QtWidgets.QGridLayout(self.ScrollWidgetContents)\n        self.ScrollGrid.setContentsMargins(0, 0, 0, 0)\n        self.ScrollGrid.setSpacing(0)\n        self.ScrollGrid.setObjectName(""ScrollGrid"")\n\n        self.canvas = MplCanvas_CONTROL_single_plot()\n        self.x_from_input = QtWidgets.QDoubleSpinBox(self.ScrollWidgetContents)\n        self.x_to_input = QtWidgets.QDoubleSpinBox(self.ScrollWidgetContents)\n        self.x_checkbox = QtWidgets.QCheckBox(self.ScrollWidgetContents)\n        self.y_from_input = QtWidgets.QDoubleSpinBox(self.ScrollWidgetContents)\n        self.y_to_input = QtWidgets.QDoubleSpinBox(self.ScrollWidgetContents)\n        self.y_checkbox = QtWidgets.QCheckBox(self.ScrollWidgetContents)\n        self.ratio_checkbox = QtWidgets.QCheckBox(self.ScrollWidgetContents)\n        self.apply_zoom_button = QtWidgets.QPushButton(self.ScrollWidgetContents)\n        \n        self.lim_scale_setting = False\n        self.lim_y_0 = None\n        self.lim_y_1 = None\n        self.lim_x_0 = None\n        self.lim_x_1 = None\n        self.scale_y_0 = None\n        self.scale_y_1 = None\n        self.scale_x_0 = None\n        self.scale_x_1 = None\n\n        self.x_from_input.setDecimals(5)\n        self.x_from_input.setMinimum(-1000000.0)\n        self.x_from_input.setMaximum(1000000.0)\n        self.x_from_input.setProperty(""value"", -10.0)\n        self.x_to_input.setDecimals(5)\n        self.x_to_input.setMinimum(-1000000.0)\n        self.x_to_input.setMaximum(1000000.0)\n        self.x_to_input.setProperty(""value"", 10.0)\n        self.x_checkbox.setText(""Limit x"")\n        self.y_from_input.setDecimals(5)\n        self.y_from_input.setMinimum(-1000000.0)\n        self.y_from_input.setMaximum(1000000.0)\n        self.y_from_input.setProperty(""value"", 0.0)\n        self.y_to_input.setDecimals(5)\n        self.y_to_input.setMinimum(-1000000.0)\n        self.y_to_input.setMaximum(1000000.0)\n        self.y_to_input.setProperty(""value"", 5.0)\n        self.y_checkbox.setText(""Limit y"")\n        self.ratio_checkbox.setText(""1:1 axis ratio"")\n        self.apply_zoom_button.setText(""Apply Limits"")\n        \n        #self.ScrollWidget.setWidget(self.ScrollWidgetContents)\n\n        self.ScrollGrid.addWidget(self.x_from_input,1,0)\n        self.ScrollGrid.addWidget(self.x_to_input,1,1)\n        self.ScrollGrid.addWidget(self.x_checkbox,1,2)\n        self.ScrollGrid.addWidget(self.y_from_input,1,3)\n        self.ScrollGrid.addWidget(self.y_to_input,1,4)\n        self.ScrollGrid.addWidget(self.y_checkbox,1,5)\n        self.ScrollGrid.addWidget(self.ratio_checkbox,1,6)\n        self.ScrollGrid.addWidget(self.apply_zoom_button,1,7)\n\n        ##self.ScrollWidgetCGrid.addWidget(self.ScrollWidget,1,0)\n\n        self.vbl = QtWidgets.QVBoxLayout()         # Set box for plotting\n        self.vbl.addWidget(self.canvas)\n        self.plotW = QtWidgets.QWidget(self)\n        self.plotW.setLayout(self.vbl)\n        self.plotW.layout().setContentsMargins(0,0,0,0)\n        \n        self.Grid.addWidget(self.plotW,0,0)\n        self.Grid.addWidget(self.ScrollWidgetContents,1,0)#self.Grid.addWidget(self.ScrollWidget,1,0)#C\n        \n        self.setLayout(self.Grid)\n\n        # TODO: Reimplement these to let them fit the height to the contents automatically\n        #self.ScrollWidgetContents.setMaximumHeight(50)\n        #self.ScrollWidget.setMaximumHeight(70)\n        \n        self.apply_zoom_button.clicked.connect(self.ApplyZoom)\n        \n    def ApplyZoom(self):\n        try:\n            xmin , xmax = self.x_from_input.value(), self.x_to_input.value()\n            if xmax < xmin:\n                xmax , xmin = xmin , xmax\n            xlims = (xmin , xmax)\n            ymin , ymax = self.y_from_input.value(), self.y_to_input.value()\n            if ymax < ymin:\n                ymax , ymin = ymin , ymax\n            ylims = (ymin , ymax)\n            \n            if self.lim_scale_setting:\n                try:\n                    self.canvas.ax.set_ylim(self.lim_y_0)\n                    if self.Bode: self.canvas.ax1.set_ylim(self.lim_y_1)\n                    self.canvas.ax.set_xlim(self.lim_x_0)\n                    if self.Bode: self.canvas.ax1.set_xlim(self.lim_x_1)\n                    self.canvas.ax.set_yscale(self.scale_y_0)\n                    if self.Bode: self.canvas.ax1.set_yscale(self.scale_y_1)\n                    self.canvas.ax.set_xscale(self.scale_x_0)\n                    if self.Bode: self.canvas.ax1.set_xscale(self.scale_x_1)\n                except:\n                    self.canvas.ax.relim()\n                    if self.Bode: self.canvas.ax1.relim()\n                    self.canvas.ax.autoscale()\n                    if self.Bode: self.canvas.ax1.autoscale()\n            else:\n                self.canvas.ax.relim()\n                if self.Bode: self.canvas.ax1.relim()\n                self.canvas.ax.autoscale()\n                if self.Bode: self.canvas.ax1.autoscale()\n            \n            if self.ratio_checkbox.isChecked():\n                self.canvas.ax.set_aspect(\'equal\')\n                if self.Bode: self.canvas.ax1.set_aspect(\'equal\')\n                # self.canvas.ax.relim()\n                # if self.Bode: self.canvas.ax1.relim()\n                # self.canvas.ax.autoscale()\n                # if self.Bode: self.canvas.ax1.autoscale()\n            else:\n                self.canvas.ax.set_aspect(\'auto\')\n                if self.Bode: self.canvas.ax1.set_aspect(\'auto\')\n            \n            if self.x_checkbox.isChecked():\n                self.canvas.ax.set_xlim(xlims)\n                if self.Bode: self.canvas.ax1.set_xlim(xlims)\n            if self.y_checkbox.isChecked():\n                self.canvas.ax.set_ylim(ylims)\n                if self.Bode: self.canvas.ax1.set_ylim(ylims)\n            \n            try:\n                self.canvas.draw()\n            except RuntimeError: #This is only a failsave\n                ExceptionOutput(sys.exc_info(),False)\n                print(""Trying to output without LaTeX"")\n                self.UseTeX(False)\n                self.canvas.draw()\n        except common_exceptions:\n            Error = ExceptionOutput(sys.exc_info())\n            self.window().NotifyUser(1,Error)\n        \n    def SetColour(self,BG=None,FG=None,Cycler=None):\n        if BG != None and FG != None:\n            super(MplWidget_CONTROL_single_plot, self).SetColour(BG,FG,Cycler)\n        try:\n            self.canvas.ax.set_facecolor(self.background_Colour)\n            self.canvas.ax.spines[\'bottom\'].set_color(self.TextColour)\n            self.canvas.ax.spines[\'left\'].set_color(self.TextColour)\n            if not self.Bode:\n                self.canvas.ax.yaxis.label.set_color(self.TextColour)\n            self.canvas.ax.xaxis.label.set_color(self.TextColour)\n            self.canvas.ax.tick_params(axis=\'x\', colors=self.TextColour)\n            self.canvas.ax.tick_params(axis=\'y\', colors=self.TextColour)\n            self.canvas.ax.set_title(self.Title, color=self.TextColour)\n            if self.Bode:\n                self.canvas.ax1.set_facecolor(self.background_Colour)\n                self.canvas.ax1.spines[\'bottom\'].set_color(self.TextColour)\n                self.canvas.ax1.spines[\'left\'].set_color(self.TextColour)\n                self.canvas.ax1.tick_params(axis=\'x\', colors=self.TextColour)\n                self.canvas.ax1.tick_params(axis=\'y\', colors=self.TextColour)\n                self.canvas.ax.grid( c=App().PenColours[""Cyan""].color().name(0),ls=(0, (4, 6)),  linewidth=1  ,which=\'major\',axis=\'y\')\n                self.canvas.ax.grid( c=App().MiscColours[""Broken""].color().name(0), ls=(0, (4, 6)), linewidth=1   ,which=\'major\',axis=\'x\')\n                self.canvas.ax.grid( c=App().MiscColours[""Broken""].color().name(0), ls=(0, (2, 8)), linewidth=0.5 ,which=\'minor\',axis=\'x\')\n                self.canvas.ax1.grid(c=App().PenColours[""Orange""].color().name(0),ls=(0, (2, 8)), linewidth=1 ,axis=\'y\')\n                self.canvas.ax.spines[\'right\'].set_color(self.TextColour)\n                self.canvas.ax1.spines[\'right\'].set_color(self.TextColour)\n            if self.FuncLabel != """":\n                self.canvas.ax.legend()\n        except common_exceptions:\n            NC(2,""Could not set all colours for the single system plot"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".SetColour"")\n        try:\n            self.canvas.draw()\n            return True\n        except common_exceptions:\n            NC(1,""Could not draw the single system plot"",exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".SetColour"")\n            return False\n    \n    def UseTeX(self,TheBool):\n        # This Method changes the settings for not only one but all widgets...\n        # This makes the clear function of the plotter slow if the LaTeX display has been used in LaTeX mode directly before\n        # It could help to separate the two widgets into two files...\n        # ... but it is also possible that this setting is global not only for the file but the program which would make the seperation a massive waste of time...\n        # Maybe test this in a little testprogram to not waste that much time...\n        \n        #Both seem to do the same:\n        matplotlib.rcParams[\'text.usetex\'] = TheBool\n        plt.rc(\'text\', usetex=TheBool)\n        return matplotlib.rcParams[\'text.usetex\']\n\n    def clear(self):\n        self.Title = ""Doubleclick on a control plot to display it here""\n        self.lim_scale_setting = False\n        self.lim_y_0 = None\n        self.lim_y_1 = None\n        self.lim_x_0 = None\n        self.lim_x_1 = None\n        self.scale_y_0 = None\n        self.scale_y_1 = None\n        self.scale_x_0 = None\n        self.scale_x_1 = None\n        try:\n            self.canvas.ax.remove()\n        except common_exceptions:\n            pass\n        try:\n            if self.Bode:\n                self.canvas.ax1.remove()\n        except common_exceptions:\n            pass\n        try:\n            self.canvas.fig.clear()\n        except common_exceptions:\n            pass\n        try:\n            self.canvas.ax = self.canvas.fig.add_subplot(111)\n        except common_exceptions:\n            pass\n        self.Bode = False\n        try: # CLEANUP: Clean up clear function\n            self.canvas.ax.set_facecolor(self.background_Colour)\n            self.canvas.ax.spines[\'bottom\'].set_color(self.TextColour)\n            self.canvas.ax.spines[\'left\'].set_color(self.TextColour)\n            #if not self.Bode:\n            self.canvas.ax.yaxis.label.set_color(self.TextColour)\n            self.canvas.ax.xaxis.label.set_color(self.TextColour)\n            self.canvas.ax.tick_params(axis=\'both\',which=\'both\', colors=self.TextColour)\n            #self.canvas.ax.tick_params(axis=\'y\', colors=self.TextColour)\n            self.canvas.ax.set_title(self.Title, color=self.TextColour)\n            #if self.Bode:\n            #    self.canvas.ax1.set_facecolor(self.background_Colour)\n            #    self.canvas.ax1.spines[\'bottom\'].set_color(self.TextColour)\n            #    self.canvas.ax1.spines[\'left\'].set_color(self.TextColour)\n            #    self.canvas.ax1.tick_params(axis=\'both\',which=\'both\', colors=self.TextColour)\n            #    #self.canvas.ax1.tick_params(axis=\'y\', colors=self.TextColour)\n            #if self.Bode:\n            #    self.canvas.ax1.grid(c=\'orange\',ls=\'--\')\n            #    self.canvas.ax.spines[\'right\'].set_color(self.TextColour)\n            #    self.canvas.ax1.spines[\'right\'].set_color(self.TextColour)\n        except common_exceptions:\n            pass\n        try:\n            self.canvas.draw()\n        except common_exceptions:\n            pass\n\n    def Plot(self,system,PlotName):\n        """"""\n        Plot the plot ""Plotname""\n        """"""\n        ret = False\n        self.FuncLabel = """"\n        Titles = MplCanvas_CONTROL.Titles\n        (sys1, T, X0 , U, Ufunc, Curr_Sys_LaTeX) = system # pylint: disable=unused-variable\n        try:\n            if T == None:\n                syst = control.timeresp._get_ss_simo(sys1)\n                T = scipy.signal.ltisys._default_response_times(syst.A, 5000)\n        except common_exceptions:\n            pass\n        self.clear()\n\n        # Plot the Plot\n        try:\n            if PlotName == Titles[0]:\n                oT,y = control.step_response(sys1, number_of_samples=5000, T=T, X0 = X0)\n                self.canvas.ax.plot(oT,y)\n            elif PlotName == Titles[1]:\n                oT,y = control.impulse_response(sys1, number_of_samples=5000, T=T, X0 = X0)\n                self.canvas.ax.plot(oT,y)\n            elif PlotName == Titles[2]:\n                # If U not given try to create using Ufunc. If Ufunc not given or creation failed set U and Ufunc to 0\n                if U == 0.0:\n                    if Ufunc != """":\n                        try:\n                            Function = parse_expr(AF.AstusParse(Ufunc))\n                            s = sympy.symbols(\'s\')\n                            evalfunc = sympy.lambdify(s, Function, modules=[\'numpy\',\'sympy\'])\n                            U = evalfunc(T)\n                            U = np.asarray(U)\n                            if type(U) == int or type(U) == float or U.shape == (): #This also catches the case exp(s)\n                                U = np.full_like(T, U)\n                            if U.shape != T.shape:\n                                raise Exception(""Dimensions do not match"")\n                        except common_exceptions:\n                            NC(2,""Could not interpret u(s)"",exc=sys.exc_info(),input=Ufunc,win=self.window().windowTitle(),func=str(self.objectName())+"".Plot"")\n                            Ufunc = """"\n                    if Ufunc == """":\n                        Ufunc = ""0""\n                \n                self.FuncLabel = ""u(s) = ""+Ufunc\n                oT,y,xout = control.forced_response(sys1, T=T, X0 = X0, U=U) # pylint: disable=unused-variable\n                self.canvas.ax.plot(oT,y,label=""Response"")\n                self.canvas.ax.plot(T,U,label=""Input Function: u(s) = ""+Ufunc)\n            elif PlotName == Titles[3] or PlotName == Titles[4] or PlotName == ""  "":\n                self.Bode = True\n                self.canvas.ax1 = self.canvas.ax.twinx()\n                self.canvas.ax1.axis(\'off\')\n                self.canvas.ax1.axis(\'on\')\n                self.canvas.ax.set_label(\'control-bode-magnitude\')\n                self.canvas.ax1.set_label(\'control-bode-phase\')\n                plt.figure(self.canvas.fig.number)\n                control.bode_plot(sys1, dB=True, omega_num=5000,Dense_Phase_Major_Ticks=True, margins=True, App=App())\n            elif PlotName == Titles[5]:\n                plt.sca(self.canvas.ax)\n                control.nyquist_plot(sys1, number_of_samples=5000,App=App())\n                self.FuncLabel = ""Nyquist""\n            elif PlotName == Titles[6]:\n                plt.sca(self.canvas.ax)\n                control.nichols_plot(sys1, number_of_samples=5000)\n            elif PlotName == Titles[7]:\n                poles,zeros = control.pzmap(sys1,Plot=False)\n                if len(poles) > 0:\n                    self.canvas.ax.scatter(np.real(poles), np.imag(poles), s=50, marker=\'x\', c=App().PenColours[""Red""].color().name(0))\n                if len(zeros) > 0:\n                    self.canvas.ax.scatter(np.real(zeros), np.imag(zeros), s=25, marker=\'o\', c=App().PenColours[""Orange""].color().name(0))\n                self.canvas.ax.grid(True)\n            elif PlotName == Titles[8]:\n                control.root_locus_AMaDiA(sys1,self.canvas.ax, App=App())\n                self.canvas.ax.grid(True)\n                self.canvas.ax.legend()\n            else: # LaTeX Display (Uses Title as display string) # This can currently not occur\n                #NC(2,""The system display can not be magnified yet"",input=sys1,win=self.window().windowTitle(),func=str(self.objectName())+"".Plot"")\n                return False\n            \n\n\n            # Get Plotname\n            if PlotName == Titles[3] or PlotName == Titles[4] or PlotName == ""  "":\n                self.Title = Titles[3]\n            else:\n                self.Title = PlotName\n\n            #Colour everything and draw it\n            ret = self.SetColour()\n            self.lim_y_0 = self.canvas.ax.get_ylim()\n            self.lim_x_0 = self.canvas.ax.get_xlim()\n            self.scale_y_0 = self.canvas.ax.get_yscale()\n            self.scale_x_0 = self.canvas.ax.get_xscale()\n            if self.Bode:\n                self.lim_y_1 = self.canvas.ax1.get_ylim()\n                self.lim_x_1 = self.canvas.ax1.get_xlim()\n                self.scale_y_1 = self.canvas.ax1.get_yscale()\n                self.scale_x_1 = self.canvas.ax1.get_xscale()\n            else:\n                self.lim_y_1 = None\n                self.lim_x_1 = None\n                self.scale_y_1 = None\n                self.scale_x_1 = None\n            self.lim_scale_setting = True\n        except common_exceptions:\n            NC(1,""Could not plot {}"".format(str(PlotName)),exc=sys.exc_info(),input=""System:\\n{}\\n\\nPlot: {}"".format(str(sys1),str(PlotName)),win=self.window().windowTitle(),func=str(self.objectName())+"".Plot"")\n            self.UseTeX(False)\n            return False\n        self.UseTeX(False)\n        return ret\n\n\n\n# ----------------------\nclass SystemClass():\n    def __init__(self,sysIn,Name,Tab=None,systemInput=None):\n        self.sys = sysIn\n        self.Name = Name\n        self.Tab = Tab\n        self.systemInput = systemInput\n        # Generate LaTeX of tf:\n        Ys,Xs = control.tfdata(self.sys)\n        Ys,Xs = Ys[0][0],Xs[0][0]\n        Gs = ""Eq(G(s),(""\n        YStr = []\n        i = len(Ys)-1\n        while i >= 0:\n            if Ys[len(Ys)-i-1] != 0:\n                if i == 0:\n                    s = ""{}"".format(Ys[len(Ys)-i-1])\n                else:\n                    s = ""{}*s**({})"".format(Ys[len(Ys)-i-1],i)\n                YStr.append(s)\n            i-=1\n        Gs += ""+"".join(YStr)\n        Gs += "")/(""\n        XStr = []\n        i = len(Xs)-1\n        while i >= 0:\n            if Xs[len(Xs)-i-1] != 0:\n                if i == 0:\n                    s = ""{}"".format(Xs[len(Xs)-i-1])\n                else:\n                    s = ""{}*s**({})"".format(Xs[len(Xs)-i-1],i)\n                XStr.append(s)\n            i-=1\n        Gs += ""+"".join(XStr)\n        Gs += ""))""\n        Gs = AF.number_shaver(Gs)\n        Sys_Gs = parse_expr(Gs,evaluate=False)\n        Sys_Gs_LaTeX = sympy.latex(Sys_Gs)\n        self.Sys_Gs_LaTeX_L = r""$\\displaystyle ""\n        self.Sys_Gs_LaTeX_N = ""$""\n        self.Sys_Gs_LaTeX_L += Sys_Gs_LaTeX\n        self.Sys_Gs_LaTeX_N += Sys_Gs_LaTeX\n        self.Sys_Gs_LaTeX_L += ""$""\n        self.Sys_Gs_LaTeX_N += ""$""\n        \n        # Generate LaTeX of ss:\n        try:\n            A,B,C,D = control.ssdata(self.sys)\n            self.Order = A.shape[0]\n            x_vec = []\n            x_vec_diff = []\n            i=1\n            while i <= self.Order:\n                x_vec.append(""x_{}(t)"".format(i))\n                x_vec_diff.append(""diff(x_{}(t),t)"".format(i))\n                i+=1\n            x_vec = str(sympy.Matrix(x_vec))\n            x_vec_diff = str(sympy.Matrix(x_vec_diff))\n            A,B = AF.number_shaver(str(sympy.Matrix(A))) , AF.number_shaver(str(sympy.Matrix(B)))\n            C,D = AF.number_shaver(str(sympy.Matrix(C))) , AF.number_shaver(str(sympy.Matrix(D)))\n            self.SSx_LaTeX = AF.LaTeX(""Eq(""+x_vec_diff+"",""+A+""*""+x_vec+""+""+B+""*u(t))"")\n            self.SSy_LaTeX = AF.LaTeX(""Eq(y(t),""+C+""*""+x_vec+""+""+D+""*u(t))"")\n            self.Sys_SS_LaTeX_L = r""$\\displaystyle "" + self.SSx_LaTeX + ""$\\n"" + r""$\\displaystyle "" + self.SSy_LaTeX + ""$""\n            self.Sys_SS_LaTeX_N = ""$"" + self.SSx_LaTeX + ""$\\n$"" + self.SSy_LaTeX + ""$""\n        except common_exceptions:\n            NC(lvl=2,msg=""Could not create LaTeX for state space"",exc=sys.exc_info(),input=self.sys,func=""SystemClass.__init__"",win=""System Control Window"")\n            self.SSx_LaTeX = ""ERROR""\n            self.SSy_LaTeX = ""ERROR""\n            self.Sys_SS_LaTeX_L = ""ERROR""\n            self.Sys_SS_LaTeX_N = ""ERROR""\n        \n        \n        # Combine LaTeX of ss and tf:\n        self.CheckStability()\n        try:\n            self.Sys_LaTeX_L = ""System: ${}$ \\nBIBO-Stable: ${}$\\nTransfer Function:\\n"".format(AF.LaTeX(AF.AstusParse(self.Name)),self.BIBOStabel) + self.Sys_Gs_LaTeX_L + ""\\nState Space:\\n"" + self.Sys_SS_LaTeX_L\n            self.Sys_LaTeX_N = ""System: ${}$ \\nBIBO-Stable: ${}$\\nTransfer Function:\\n"".format(AF.LaTeX(AF.AstusParse(self.Name)),self.BIBOStabel) + self.Sys_Gs_LaTeX_N + ""\\nState Space:\\n"" + self.Sys_SS_LaTeX_N\n        except common_exceptions:\n            NC(1,""Invalid Name (Could not convert name to LaTeX)"",exc=sys.exc_info(),func=""SystemClass.__init__"",input=self.Name,win=""System Control Window"")\n            raise Exception(""Invalid Name (Could not convert name to LaTeX)"")\n\n    def Item(self):\n        item = QtWidgets.QListWidgetItem()\n        item.setText(self.Name)\n        item.setData(100,self)\n        return item\n\n    def Close(self):\n        SystemObject = SystemClass(control.feedback(self.sys),self.Name+""_closed"",self.Tab,self.systemInput)\n        item = QtWidgets.QListWidgetItem()\n        item.setText(SystemObject.Name)\n        item.setData(100,SystemObject)\n        return item\n\n    def CheckStability(self):\n        try:\n            self.BIBOStabel = True\n            #A = sympy.Matrix(control.ssdata(self.sys)[0])\n            #eigenvals = A.eigenvals()\n            poles = self.sys.pole()\n            for i in poles:\n                if np.real(i) >= 0:\n                    self.BIBOStabel = False\n                    break\n        except common_exceptions:\n            NC(lvl=2,msg=""Could not check BIBO stability! Setting stability to False"",exc=sys.exc_info(),input=self.sys,func=""SystemClass.CheckStability"",win=""System Control Window"")\n            self.BIBOStabel = False\n'"
AMaDiA_Files/AMaDiA_Threads.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Fri Sep 13 12:51:32 2019\n\n@author: Robin\n""""""\n\nfrom AGeLib.exc import *\n\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5 import QtWidgets,QtCore,QtGui\nfrom PyQt5.Qt import QApplication, QClipboard # pylint: disable=no-name-in-module\nimport socket\nimport datetime\nimport platform\nimport errno\nimport os\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nimport importlib\nimport types\nimport time\n\nimport numpy as np\nimport scipy.integrate\n\n#import AMaDiA\nfrom AMaDiA_Files import AMaDiA_Widgets as AW\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_Classes as AC\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\n\n\ndef ReloadModules():\n    importlib.reload(AW)\n    importlib.reload(AF)\n    importlib.reload(AC)\n    importlib.reload(ART)\n#------------------------------------------------------------------------------\nclass WorkerSignals(QtCore.QObject):\n    \'\'\'\n    Defines the signals available from a running AMaS_Creator.\n\n    Supported signals are:\n\n    finished\n        No data\n    \n    error\n        `tuple` (AC.AMaS , types.MethodType , int)\n        (self.AMaS_Object , self.Return_Function , self.ID)\n    \n    result\n        `tuple` (AC.AMaS , types.MethodType , int , int)\n        (self.AMaS_Object , self.Return_Function , self.ID , self.Eval)\n\n    \'\'\'\n    finished = QtCore.pyqtSignal()\n    error = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int)\n    result = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int , int)\n#------------------------------------------------------------------------------\nclass AMaS_Creator(QtCore.QRunnable):\n    \'\'\'\n    Worker thread\n    \'\'\'\n    def __init__(self, Text, Return_Function, Eval=None, EvalL=1, Iam = AC.Iam_Normal):\n        super(AMaS_Creator, self).__init__()\n        self.exiting = False\n        self.Text = Text\n        self.Iam = Iam\n        self.EvalL = EvalL\n        if Eval == None : self.Eval = -1\n        elif Eval : self.Eval = 0\n        else: self.Eval = 1\n        self.Return_Function = Return_Function\n        self.ID = -1\n        self.signals = WorkerSignals()\n        self.Thread = None\n\n    @QtCore.pyqtSlot()\n    def run(self):\n        self.Thread = QtCore.QThread.currentThread()\n        self.AMaS_Object = AC.AMaS(self.Text, self.Iam, EvalL=self.EvalL)\n        if self.AMaS_Object.Exists == True:\n            self.signals.result.emit(self.AMaS_Object , self.Return_Function , self.ID , self.Eval)\n        self.signals.error.emit(self.AMaS_Object , self.Return_Function , self.ID)\n        self.signals.finished.emit()\n        self.exiting = True\n\n    def terminate(self):\n        if self.Thread != None:\n            self.signals.finished.emit()\n            try:\n                self.signals.finished.disconnect()\n            except common_exceptions:\n                ExceptionOutput(sys.exc_info())\n            self.Thread.setTerminationEnabled(True)\n            self.Thread.terminate()\n            self.Thread = None\n#------------------------------------------------------------------------------\n\nclass AMaS_Worker(QtCore.QRunnable):\n    def __init__(self, AMaS_Object, AMaS_Function, Return_Function):\n        super(AMaS_Worker, self).__init__()\n        self.ID = -1\n        self.exiting = False\n        self.AMaS_Object = AMaS_Object\n        self.AMaS_Function = AMaS_Function\n        self.Return_Function = Return_Function\n        self.signals = WorkerSignals()\n        \n    def run(self):\n        self.Thread = QtCore.QThread.currentThread()\n        Success = self.AMaS_Function()\n        if Success == True:\n            self.signals.result.emit(self.AMaS_Object , self.Return_Function , self.ID, -1)\n        self.signals.error.emit(self.AMaS_Object , self.Return_Function , self.ID)\n        self.signals.finished.emit()\n        self.exiting = True\n\n    def terminate(self):\n        self.signals.finished.emit()\n        self.Thread.setTerminationEnabled(True)\n        self.Thread.terminate()\n        \n        \n""""""Usage: only replace __***__\nself.TC(lambda ID: AT.AMaS_Thread(self, AMaS_Object,lambda:AC.AMaS.__METHOD__(AMaS_Object, __ARGUMENTS__ ),self.__Return_to_Method__ ,ID))\n""""""\n#------------------------------------------------------------------------------\n\nclass Timer(QtCore.QRunnable):\n    def __init__(self, Time):\n        super(Timer, self).__init__()\n        self.Time = Time\n        self.signals = WorkerSignals()\n        \n    def run(self):\n        time.sleep(self.Time)\n        self.signals.finished.emit()\n\n#------------------------------------------------------------------------------ Threads ------------------------------------------------------------------------------\nclass AMaS_Creator_Thread(QtCore.QThread):\n    ReturnError = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int)\n    Return = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int , int)\n    finished = QtCore.pyqtSignal()\n    def __init__(self, Parent, Text, Return_Function, ID, Eval=None, EvalL=1, Iam = AC.Iam_Normal):\n        QtCore.QThread.__init__(self, Parent)\n        self.exiting = False\n        self.Text = Text\n        self.Iam = Iam\n        self.EvalL = EvalL\n        if Eval == None : self.Eval = -1\n        elif Eval : self.Eval = 0\n        else: self.Eval = 1\n        self.Return_Function = Return_Function\n        self.ID = ID\n        \n    def run(self):\n        self.AMaS_Object = AC.AMaS(self.Text, self.Iam, EvalL=self.EvalL)\n        if self.AMaS_Object.Exists == True:\n            self.Return.emit(self.AMaS_Object , self.Return_Function , self.ID , self.Eval)\n        self.ReturnError.emit(self.AMaS_Object , self.Return_Function , self.ID)\n        self.finished.emit()\n        self.exiting = True\n        self.exit()\n        #self.quit()\n        #self.deleteLater()\n\n    def terminate(self):\n        self.finished.emit()\n        super(AMaS_Creator_Thread, self).terminate()\n        \n""""""Usage: only replace __***__\nself.TC(lambda ID: AT.AMaS_Creator(self, __Text__ , self.__Return_to_Method__ ,ID))\n""""""\n#------------------------------------------------------------------------------\n\nclass AMaS_Thread(QtCore.QThread):\n    ReturnError = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int)\n    Return = QtCore.pyqtSignal(AC.AMaS , types.MethodType , int)\n    finished = QtCore.pyqtSignal()\n    def __init__(self, Parent, AMaS_Object, AMaS_Function, Return_Function, ID):\n        QtCore.QThread.__init__(self, Parent)\n        self.ID = ID\n        self.exiting = False\n        self.AMaS_Object = AMaS_Object\n        self.AMaS_Function = AMaS_Function\n        self.Return_Function = Return_Function\n        \n    def run(self):\n        Success = self.AMaS_Function()\n        if Success == True:\n            self.Return.emit(self.AMaS_Object , self.Return_Function , self.ID)\n        self.ReturnError.emit(self.AMaS_Object , self.Return_Function , self.ID)\n        self.finished.emit()\n        self.exiting = True\n        self.exit()\n        #self.quit()\n        #self.deleteLater()\n\n    def terminate(self):\n        self.finished.emit()\n        super(AMaS_Thread, self).terminate()\n        \n        \n""""""Usage: only replace __***__\nself.TC(lambda ID: AT.AMaS_Thread(self, AMaS_Object,lambda:AC.AMaS.__METHOD__(AMaS_Object, __ARGUMENTS__ ),self.__Return_to_Method__ ,ID))\n""""""\n\n\'\'\' Usage:\nself.New_AMaS_Thread = AMaS_Calc_Thread(self, AMaS_Object , AC.Method , self.Return_Function)\nself.New_AMaS_Thread.Calculator_Return.connect(self.RT)\nself.New_AMaS_Thread.start()\n\n\nalso use\n\ndef Perform(f):\n    f()\n\nPerform(lambda: Action1())\nPerform(lambda: Action2(p))\nPerform(lambda: Action3(p, r))\n\n\'\'\'\n\n#------------------------------------------------------------------------------\n\n\n\n'"
AMaDiA_Files/AMaDiA_Widgets.py,0,"b'# This Python file uses the following encoding: utf-8\n\n# if__name__ == ""__main__"":\n#     pass\n\nfrom AGeLib import *\n\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5 import QtWidgets,QtCore,QtGui,Qt#,QtQuick\n#QtQuick.\n#from PyQt5.QtQuick import Controls as QtControls\nfrom matplotlib.figure import Figure\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as Canvas\nfrom matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas #CLEANUP: Delete this line?\nfrom matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\nimport matplotlib\nimport matplotlib.pyplot as plt\n#matplotlib.use(\'Qt5Agg\')\nfrom mpl_toolkits.axes_grid1 import Divider, Size\nfrom mpl_toolkits.axes_grid1.mpl_axes import Axes\nimport numpy as np\nimport scipy\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nimport re\nimport time\n\nimport warnings\n\nfrom AMaDiA_Files import AMaDiA_Functions as AF\nfrom AMaDiA_Files import AMaDiA_Classes as AC\nfrom AMaDiA_Files import AMaDiA_ReplacementTables as ART\n\nimport importlib\ndef ReloadModules():\n    importlib.reload(AF)\n    importlib.reload(AC)\n    importlib.reload(ART)\n\n\n\n# -----------------------------------------------------------------------------------------------------------------\n\n#FEATURE: Add autocomplete for AMaDiA_TextEdit and AMaDiA_LineEdit. For Example:\n#       ""sq"" should suggest ""\xe2\x88\x9a(*)"" with * being the cursor position\n#       ""int"" should suggest ""\xe2\x88\xab{(*)()}dx"" or ""\xe2\x88\xab{(*From*)(To)} f(x) dx"" with ""*From*"" being selected or even fancier\n\nclass AMaDiA_TextEdit(TextEdit):\n    def __init__(self, parent=None):\n        super(AMaDiA_TextEdit, self).__init__(parent)\n        self.Highlighter = LineEditHighlighter(self.document(), self)\n        self.cursorPositionChanged.connect(self.CursorPositionChanged)\n\n    def CursorPositionChanged(self):\n        self.Highlighter.blockSignals(True) #block signals because rehighlight might trigger the change signal? but this blocking might also be unnecessary\n        self.Highlighter.rehighlight()\n        self.Highlighter.blockSignals(False)\n        cursor = self.textCursor()\n        curPos = cursor.position()\n        self.document().contentsChange.emit(curPos,0,0)\n\n\nclass AMaDiA_LineEdit(LineEdit):\n    def __init__(self, parent=None):\n        super(AMaDiA_LineEdit, self).__init__(parent)\n        self.Highlighter = LineEditHighlighter(self.document(), self)\n        self.cursorPositionChanged.connect(self.CursorPositionChanged)\n\n    def CursorPositionChanged(self):\n        cursor = self.textCursor()\n        curPos = cursor.position()\n        self.document().contentsChange.emit(curPos,0,0)\n\n\n\nclass LineEditHighlighter(QtGui.QSyntaxHighlighter): # TODO: performance, Fix FindPair\n    def __init__(self, document, Widget):\n        QtGui.QSyntaxHighlighter.__init__(self, document)\n        self.Widget = Widget\n        self.init_Styles()\n        try:\n            self.enabled = QtWidgets.QApplication.instance().optionWindow.cb_O_PairHighlighter.isChecked()\n        except common_exceptions:\n            self.enabled = True\n        QtWidgets.QApplication.instance().S_Highlighter.connect(self.ToggleActive)\n\n        # init the rules # Currently Unused...\n        rules = [(r\'%s\' % b, 0, self.STYLES[\'brace\']) for b in self.braces]\n        self.rules = [(QtCore.QRegExp(pat), index, fmt) for (pat, index, fmt) in rules]\n\n        App().S_ColourChanged.connect(self.UpdateFormats)\n\n    def ToggleActive(self,Active):\n        self.enabled = Active\n\n    def UpdateFormats(self):\n        self.RedFormat.setForeground(App().PenColours[""Red""].color())\n        self.GreenFormat.setForeground(App().PenColours[""Green""].color())\n        self.BlueFormat.setForeground(App().PenColours[""Blue""].color())\n        self.CyanFormat.setForeground(App().PenColours[""Cyan""].color())\n        self.MagentaFormat.setForeground(App().PenColours[""Magenta""].color())\n\n    def init_Styles(self):\n        # init Lists\n        self.braces = [\'\\{\', \'\\}\', \'\\(\', \'\\)\', \'\\[\', \'\\]\'] # pylint: disable=anomalous-backslash-in-string\n\n        # Init Formats\n        self.RedFormat = QtGui.QTextCharFormat()\n        self.RedFormat.setForeground(QtGui.QColor(\'red\'))\n        self.GreenFormat = QtGui.QTextCharFormat()\n        self.GreenFormat.setForeground(QtGui.QColor(\'green\'))\n        self.BlueFormat = QtGui.QTextCharFormat()\n        self.BlueFormat.setForeground(QtGui.QColor(\'blue\'))\n        self.CyanFormat = QtGui.QTextCharFormat()\n        self.CyanFormat.setForeground(QtGui.QColor(\'cyan\'))\n        self.MagentaFormat = QtGui.QTextCharFormat()\n        self.MagentaFormat.setForeground(QtGui.QColor(\'magenta\'))\n\n        # Collect all Formats in a dictionary\n        self.STYLES = {\'brace\': self.RedFormat,\'pair\': self.RedFormat}\n\n    def highlightBlock(self, text):\n        if not self.enabled:\n            self.setCurrentBlockState(0)\n            return\n        cursor = self.Widget.textCursor()\n        if not cursor.block() == self.currentBlock():\n            #self.setCurrentBlockState(0)\n            return\n        curPos = cursor.positionInBlock()\n        pattern = """"\n        TheList = []\n        for i in ART.LIST_l_normal_pairs:\n            for j in i:\n                if not j[0] in TheList:\n                    TheList.append(j[0])\n                if not j[1] in TheList:\n                    TheList.append(j[1])\n        TheList.sort(key=len,reverse=True)\n        for i in TheList:\n            pattern += re.escape(i)\n            pattern += ""|""\n            pattern += re.escape(i)\n            pattern += ""|""\n        pattern = pattern[:-1]\n        braces_list = [[m.start(),m.end()] for m in re.finditer(pattern, text)]\n        braces_list.sort(key=AF.takeFirst,reverse=False)\n        for i in braces_list:\n            if curPos <= i[1] and curPos >= i[0]:\n                self.setFormat(i[0], i[1]-i[0], self.STYLES[\'pair\'])\n                Element = text[i[0]:i[1]]\n                try:\n                    Pair = AF.Counterpart(Element, ListOfLists=ART.LIST_l_normal_pairs, Both=True)\n                except Exception:\n                    ExceptionOutput(sys.exc_info())#break\n                if Pair[0] == Element:\n                    Pair = Pair.FirstResult\n                    a,b = AF.FindPair(text,Pair,i[0])\n                    self.setFormat(b, len(Pair[1]), self.STYLES[\'pair\'])\n                else:\n                    # IMPROVE: Opening pair finder\n\n                    #---------method1----------\n                    # FIXME: Does not work!!!!!!!!!!!!!! NEEDS FIX OF AF.FindPair ???\n                        #k=0\n                        #found = False\n                        #while k < len(Pair):\n                        #    a,b = AF.FindPair(text,Pair.List[k],end=i[1])\n                        #    if b == i[0] and Pair.List[k][1] == Element:\n                        #        c,d = a, len(Pair.List[k][0])\n                        #        found = True\n                        #    k+=1\n                    #if found:\n                    #    self.setFormat(c, d, self.STYLES[\'pair\'])\n\n\n                    #---------method2----------\n                    found = False\n                    for j in braces_list:\n                        Element2 = text[j[0]:j[1]]\n                        try:\n                            Pair2 = AF.Counterpart(Element2, ListOfLists=ART.LIST_l_normal_pairs, Both=True)\n                        except Exception:\n                            ExceptionOutput(sys.exc_info())#break\n                        else: #VALIDATE: This ""else"" was added to ensure that Pair2 exists but this code ran without problems before...\n                            #               (previously the following code was always executed)\n                            #               What did I think when I wrote this?\n                            #               Why did I use the ExceptionOutput? Why did I want to use ""break"" instead of ""continue""?\n                            k=0\n                            while k < len(Pair2):\n                                a,b = AF.FindPair(text,Pair2.List[k],j[0])\n                                if b == i[0] and Pair2.List[k][1] == Element:\n                                    c,d = a, len(Pair2.List[k][0])\n                                    found = True\n                                    break\n                                k+=1\n                    if found:\n                        self.setFormat(c, d, self.STYLES[\'pair\'])\n\n\n                break\n        \n        self.setCurrentBlockState(0)\n\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass AMaDiA_TableWidget(TableWidget):\n    def __init__(self, parent=None):\n        super(AMaDiA_TableWidget, self).__init__(parent)\n        self.TheDelegate = AMaDiA_TableWidget_Delegate(self)\n        self.setItemDelegate(self.TheDelegate)\n\nclass AMaDiA_TableWidget_Delegate(TableWidget_Delegate):\n    def __init__(self, parent=None):\n        super(AMaDiA_TableWidget_Delegate, self).__init__(parent)\n\n    def createEditor(self, parent, options, index):\n        return AMaDiA_LineEdit(parent)\n\n\n# -----------------------------------------------------------------------------------------------------------------\n\nclass HistoryWidget(ListWidget):\n    def __init__(self, parent=None):\n        super(HistoryWidget, self).__init__(parent)\n        self.installEventFilter(self)\n\n    def keyPressEvent(self,event):\n        try:\n            if event == QtGui.QKeySequence.Copy:\n                SelectedItems = self.selectedItems()\n                if len(SelectedItems)==1:\n                    item = SelectedItems[0]\n                    if QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""Normal"":\n                        if (self == QtWidgets.QApplication.instance().MainWindow.Tab_1_History \n                                or self == QtWidgets.QApplication.instance().MainWindow.Tab_4_History) and item.data(100).Solution != ""Not evaluated yet"":\n                            Qt.QApplication.clipboard().setText(item.data(100).Equation)\n                        else:\n                            Qt.QApplication.clipboard().setText(item.text())\n                    elif (QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""Solution""\n                            and item.data(100).Solution != ""Not evaluated yet""):\n                        Qt.QApplication.clipboard().setText(item.data(100).Solution)\n                    elif (QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""Equation""\n                            and item.data(100).Solution != ""Not evaluated yet""):\n                        Qt.QApplication.clipboard().setText(item.data(100).Equation)\n                    elif QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""Text"":\n                        Qt.QApplication.clipboard().setText(item.data(100).Text)\n                    elif (QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""LaTeX""\n                            and item.data(100).LaTeX != r""\\text{Not converted yet}""\n                            and item.data(100).LaTeX != r""\\text{Could not convert}""):\n                        Qt.QApplication.clipboard().setText(item.data(100).LaTeX)\n                    elif (QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()==""LaTeX Equation""\n                            and item.data(100).LaTeX_E != r""\\text{Not converted yet}""\n                            and item.data(100).LaTeX_E != r""\\text{Could not convert}""):\n                        Qt.QApplication.clipboard().setText(item.data(100).LaTeX_E)\n                    else:\n                        NC(4,QtWidgets.QApplication.instance().optionWindow.comb_O_HCopyStandard.currentText()+"" can not be copied. Using normal copy mode"",win=self.window().windowTitle(),func=str(self.objectName())+"".(HistoryWidget).keyPressEvent"",input=item.text())\n                        Qt.QApplication.clipboard().setText(item.text())\n                    event.accept()\n                    return\n                elif self == QtWidgets.QApplication.instance().MainWindow.Tab_1_History:\n                    string = """"\n                    for i in SelectedItems:\n                        string += i.data(100).Equation\n                        string += ""\\n""\n                    Qt.QApplication.clipboard().setText(string)\n                    event.accept()\n                    return\n            super(HistoryWidget, self).keyPressEvent(event)\n        except common_exceptions:\n            NC(lvl=2,exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(HistoryWidget).keyPressEvent"",input=str(event))\n            super(HistoryWidget, self).keyPressEvent(event)\n\n    def eventFilter(self, source, event): #TODO: Add Tooltips for the Actions! These should also specify whether the action will be executed on all selected items or only the right-clicked-one! ""Delete"" should also mention ""Del"" as the hotkey!\n        try:\n            if event.type() == 82: # QtCore.QEvent.ContextMenu\n            # ---------------------------------- History Context Menu ----------------------------------\n                if source.itemAt(event.pos()):\n                    menu = QtWidgets.QMenu()\n                    if source.itemAt(event.pos()).data(100).Solution != ""Not evaluated yet"":\n                        action = menu.addAction(\'Copy Solution\')\n                        action.triggered.connect(lambda: self.action_H_Copy_Solution(source,event))\n                        action = menu.addAction(\'Copy Equation\')\n                        action.triggered.connect(lambda: self.action_H_Copy_Equation(source,event))\n                    action = menu.addAction(\'Copy Text\')\n                    action.triggered.connect(lambda: self.action_H_Copy_Text(source,event))\n                    action = menu.addAction(\'Copy LaTeX\')\n                    action.triggered.connect(lambda: self.action_H_Copy_LaTeX(source,event))\n                    if source.itemAt(event.pos()).data(100).LaTeX_E != r""\\text{Not converted yet}"" and source.itemAt(event.pos()).data(100).LaTeX_E != r""\\text{Could not convert}"":\n                        action = menu.addAction(\'Copy LaTeX Equation\')\n                        action.triggered.connect(lambda: self.action_H_Copy_LaTeX_E(source,event))\n                    if QtWidgets.QApplication.instance().advanced_mode:\n                        action = menu.addAction(\'+ Copy Input\')\n                        action.triggered.connect(lambda: self.action_H_Copy_Input(source,event))\n                        action = menu.addAction(\'+ Copy cString\')\n                        action.triggered.connect(lambda: self.action_H_Copy_cstr(source,event))\n                    menu.addSeparator()\n                    # MAYBE: Only ""Calculate"" if the equation has not been evaluated yet or if in Advanced Mode? Maybe? Maybe not?\n                    # It currently is handy to have it always because of the EvalF thing...\n                    action = menu.addAction(\'Calculate\')\n                    action.triggered.connect(lambda: self.action_H_Calculate(source,event))\n                    action = menu.addAction(\'Display LaTeX\')\n                    action.triggered.connect(lambda: self.action_H_Display_LaTeX(source,event))\n                    if source.itemAt(event.pos()).data(100).Solution != ""Not evaluated yet"":\n                        action = menu.addAction(\'Display LaTeX Equation\')\n                        action.triggered.connect(lambda: self.action_H_Display_LaTeX_Equation(source,event))\n                        action = menu.addAction(\'Display LaTeX Solution\')\n                        action.triggered.connect(lambda: self.action_H_Display_LaTeX_Solution(source,event))\n                    menu.addSeparator()\n                    if source.itemAt(event.pos()).data(100).plot_data_exists :\n                        action = menu.addAction(\'Load Plot\')\n                        action.triggered.connect(lambda: self.action_H_Load_Plot(source,event))\n                    if source.itemAt(event.pos()).data(100).plottable :\n                        action = menu.addAction(\'New Plot\')\n                        action.triggered.connect(lambda: self.action_H_New_Plot(source,event))\n                    elif QtWidgets.QApplication.instance().advanced_mode :\n                        action = menu.addAction(\'+ New Plot\')\n                        action.triggered.connect(lambda: self.action_H_New_Plot(source,event))\n                    if source.itemAt(event.pos()).data(100).plot_data_exists and QtWidgets.QApplication.instance().advanced_mode:\n                        menu.addSeparator()\n                        action = menu.addAction(\'+ Copy x Values\')\n                        action.triggered.connect(lambda: self.action_H_Copy_x_Values(source,event))\n                        action = menu.addAction(\'+ Copy y Values\')\n                        action.triggered.connect(lambda: self.action_H_Copy_y_Values(source,event))\n                    menu.addSeparator()\n                    action = menu.addAction(\'Delete\')\n                    action.triggered.connect(lambda: self.action_H_Delete(source,event))\n                    menu.setPalette(self.palette())\n                    menu.setFont(self.font())\n                    menu.exec_(event.globalPos())\n                    return True\n            elif event.type() == 6: # QtCore.QEvent.KeyPress\n                if event.key() == QtCore.Qt.Key_Delete:\n                    self.action_H_Delete(source,event)\n\n            return super(HistoryWidget, self).eventFilter(source, event)\n        except common_exceptions:\n            NC(lvl=1,exc=sys.exc_info(),win=self.window().windowTitle(),func=str(self.objectName())+"".(HistoryWidget).eventFilter"",input=str(event))\n            return super(HistoryWidget, self).eventFilter(source, event)\n # ---------------------------------- History Context Menu Actions/Functions ----------------------------------\n  # ----------------\n         \n    def action_H_Copy_Solution(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).Solution)\n         \n    def action_H_Copy_Equation(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).Equation)\n         \n    def action_H_Copy_Text(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).Text)\n        \n    def action_H_Copy_LaTeX(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).LaTeX)\n        \n    def action_H_Copy_LaTeX_E(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).LaTeX_E)\n        \n    def action_H_Copy_Input(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).Input)\n        \n    def action_H_Copy_cstr(self,source,event):\n        item = source.itemAt(event.pos())\n        Qt.QApplication.clipboard().setText(item.data(100).cstr)\n        \n  # ----------------\n         \n    def action_H_Calculate(self,source,event):\n        item = source.itemAt(event.pos())\n        self.window().tabWidget.setCurrentIndex(0)\n        self.window().Tab_1_F_Calculate(item.data(100))\n        \n    def action_H_Display_LaTeX(self,source,event): #TODO: Move all selected items to the LaTeX Tab History but only display LaTeX of the right-clicked-one (and update the tooltip for this action)\n        item = source.itemAt(event.pos())\n        self.window().tabWidget.setCurrentIndex(1)\n        self.window().Tab_2_F_Display(item.data(100))\n\n    def action_H_Display_LaTeX_Equation(self,source,event):\n        item = source.itemAt(event.pos())\n        self.window().tabWidget.setCurrentIndex(1)\n        self.window().Tab_2_F_Display(item.data(100),part=""Equation"")\n\n    def action_H_Display_LaTeX_Solution(self,source,event):\n        item = source.itemAt(event.pos())\n        self.window().tabWidget.setCurrentIndex(1)\n        self.window().Tab_2_F_Display(item.data(100),part=""Solution"")\n         \n  # ----------------\n         \n    def action_H_Load_Plot(self,source,event):\n        TheItem = source.itemAt(event.pos())\n        if source is self.window().Tab_3_1_History:\n            listItems=source.selectedItems()\n            if not listItems: return\n        else:\n            listItems = [TheItem]\n        for item in listItems:\n            self.window().tabWidget.setCurrentIndex(2)\n            if not item.data(100).Plot_is_initialized:\n                item.data(100).init_2D_plot()\n            if item.data(100).current_ax != None:\n                item.data(100).current_ax.remove()\n                item.data(100).current_ax = None\n                self.window().Tab_3_1_F_RedrawPlot()\n            self.window().Tab_3_1_F_Plot(item.data(100))\n        \n    def action_H_New_Plot(self,source,event):\n        TheItem = source.itemAt(event.pos())\n        if source is self.window().Tab_3_1_History:\n            listItems=source.selectedItems()\n            if not listItems: return\n        else:\n            listItems = [TheItem]\n        for item in listItems:\n            self.window().tabWidget.setCurrentIndex(2)\n            if not item.data(100).Plot_is_initialized:\n                item.data(100).init_2D_plot()\n            if item.data(100).current_ax != None:\n                item.data(100).current_ax.remove()\n                item.data(100).current_ax = None\n                self.window().Tab_3_1_F_RedrawPlot()\n            self.window().Tab_3_1_F_Plot_init(item.data(100))\n         \n  # ----------------\n        \n    def action_H_Copy_x_Values(self,source,event):\n        try:\n            item = source.itemAt(event.pos())\n            Text = ""[ ""\n            for i in item.data(100).plot_x_vals:\n                Text += str(i)\n                Text += "" , ""\n            Text = Text[:-3]\n            Text += "" ]""\n            Qt.QApplication.clipboard().setText(Text)\n        except common_exceptions:\n            NC(lvl=2,msg=""Could not copy x values"",exc=sys.exc_info(),func=""HistoryWidget.action_H_Copy_x_Values"",win=self.window().windowTitle(),input=item.data(100).Input)\n        \n    def action_H_Copy_y_Values(self,source,event):\n        try:\n            item = source.itemAt(event.pos())\n            Text = ""[ ""\n            for i in item.data(100).plot_y_vals:\n                Text += str(i)\n                Text += "" , ""\n            Text = Text[:-3]\n            Text += "" ]""\n            Qt.QApplication.clipboard().setText(Text)\n        except common_exceptions:\n            NC(lvl=2,msg=""Could not copy y values"",exc=sys.exc_info(),func=""HistoryWidget.action_H_Copy_y_Values"",win=self.window().windowTitle(),input=item.data(100).Input)\n \n  # ----------------\n         \n    def action_H_Delete(self,source,event):\n        listItems=source.selectedItems()\n        if not listItems: return        \n        for item in listItems:\n            source.takeItem(source.row(item))\n            # The cleanup below is apparently unnecessary but it is cleaner to do it anyways...\n            if source is self.window().Tab_1_History:\n                item.data(100).tab_1_is = False\n                item.data(100).tab_1_ref = None\n            elif source is self.window().Tab_2_History:\n                item.data(100).tab_2_is = False\n                item.data(100).tab_2_ref = None\n            elif source is self.window().Tab_3_1_History:\n                item.data(100).Tab_3_1_is = False\n                item.data(100).Tab_3_1_ref = None\n                if item.data(100).current_ax != None:\n                    item.data(100).current_ax.remove()\n                    item.data(100).current_ax = None\n                    self.window().Tab_3_1_F_RedrawPlot()\n            elif source is self.window().Tab_4_History:\n                if item.data(100) == self.window().Tab_4_Active_Equation:\n                    self.window().Tab_4_History.addItem(item)\n                else:\n                    item.data(100).Tab_4_is = False\n                    item.data(100).Tab_4_ref = None\n'"
AMaDiA_Files/AstusChat_Client.py,0,"b'#!/usr/bin/env python3\n# Client Version\nClientVersion = ""5.6""\n# Compatible with Server Version (Or Newer)\nServerVersion = ""4.5""\nAuthor = ""Robin \\\'Astus\\\' Albers""\n\nWindowTitle = ""Client v""\nWindowTitle+= ClientVersion\nWindowTitle+= "" by ""\nWindowTitle+= Author\n\nfrom AGeLib import AGeMain\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5 import QtWidgets,QtCore,QtGui\nimport socket\nimport platform\nimport errno\nimport os\nfrom AMaDiA_Files.AMaDiA_Functions import common_exceptions, ExceptionOutput\nfrom AMaDiA_Files.AstusChat_Client_UI import Ui_ClientInterface\n\n\nbConnected = False\n\n\nclass InputFieldClass(QtWidgets.QLineEdit):\n    def __init__(self, type, parent=None):\n        super(InputFieldClass, self).__init__(parent)\n        #self.setIconSize(QtCore.QSize(124, 124))\n        #self.setDragDropMode(QtGui.QAbstractItemView.DragDrop)\n        #self.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)\n        self.setAcceptDrops(True)\n\n    def dragEnterEvent(self, event):\n        if event.mimeData().hasUrls():\n            event.accept()\n        else:\n            super(InputFieldClass, self).dragEnterEvent(event)\n\n    def dragMoveEvent(self, event):\n        if event.mimeData().hasUrls():\n            event.setDropAction(QtCore.Qt.CopyAction)\n            event.accept()\n        else:\n            super(InputFieldClass, self).dragMoveEvent(event)\n\n    def dropEvent(self, event):\n        global bConnected\n        try:\n            if bConnected:\n                if event.mimeData().hasUrls():\n                    url = event.mimeData().text()\n                    filename = url[url.rfind(""/"")+1:]\n                    myFile = ""S/f/""\n                    myFile += filename\n                    myFile += ""/""\n                    \n                    if platform.system() == \'Linux\':\n                        with open(str(os.path.join(event.mimeData().text()[7:])),\'r\') as text_file:\n                            myFile += text_file.read()\n                    elif ""rt.e-technik.tu-dortmund.de"" in url:\n                        with open(event.mimeData().text()[5:],\'r\') as text_file:\n                            myFile += text_file.read()\n                    else:\n                        with open(event.mimeData().text()[8:],\'r\') as text_file:\n                            myFile += text_file.read()\n                    \n                    sockclient.send(myFile.encode(\'utf8\'))\n        except Exception as inst:\n            inst\n            pass\n\n\nclass MainWindow(QtWidgets.QMainWindow, Ui_ClientInterface): \n\n    def __init__(self, parent = None):\n        super(MainWindow, self).__init__(parent)\n        self.setupUi(self)\n\n        self.InputField = InputFieldClass(self.centralwidget)\n        self.InputField.setAutoFillBackground(True)\n        self.InputField.setObjectName(""InputField"")\n        self.gridLayout.addWidget(self.InputField, 3, 2, 1, 11)\n        \n        #self.retranslateUi(self)\n        \n        global sockclient\n        sockclient = socket.socket()\n        #sockclient.settimeout(5)\n        \n        \n        self.RequestChatHistoryBox.setToolTip(""Request Chat History on Login"")\n        self.OnlineList.setPlainText(""No Server Connected"")\n        \n        try:\n            self.PortField.setText(""32005"")\n            myIP = str(socket.gethostbyname(socket.gethostname()))\n        \n            if platform.system() == \'Linux\':\n                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                s.connect((""8.8.8.8"", 80))\n                myIP =  str(s.getsockname()[0])\n                del s\n                \n            if platform.system() == \'Linux\':\n                self.IPField.setText(myIP)\n        except:\n            pass\n            \n        #sockclient.bind((myIP,0))\n        self.ConnectCheckBox.clicked.connect(self.on_ConnectBoxChanged) \n        self.SendButton.clicked.connect(self.on_sendButtonClicked)\n        self.InputField.returnPressed.connect(self.on_sendButtonClicked)\n        #self.FontSizeBox.valueChanged.connect(self.ChangeFontSize) #TODO\n        self.FontSizeBox.setVisible(False)\n        self.FontText.setVisible(False)\n        \n\n    def on_sendButtonClicked(self):\n        if self.ConnectCheckBox.isChecked():\n            msg = ""S""\n            msg += self.InputField.text()\n            if len(msg)>= 3 and msg[1] == ""/"":\n                if msg[2]==""u"" or msg[2]==""f"":\n                    msg = ""S"" + msg[3:]\n            self.InputField.clear()\n            sockclient.send(msg.encode(\'utf8\'))\n        else:\n            msg = self.InputField.text()\n            self.InputField.clear()\n            self.ChatDisplay.append(msg)\n\n    def SendFile(self , MyFile):\n        if self.ConnectCheckBox.isChecked() :\n            sockclient.send(MyFile.encode(\'utf8\'))\n    \n    \n    def on_ConnectBoxChanged(self):\n        global sockclient\n        global bConnected\n        if self.ConnectCheckBox.isChecked() :\n            self.ChatDisplay.append(""Trying to connect..."")\n            IP = self.IPField.text()\n            Port = int(self.PortField.text())\n            try:\n                sockclient.connect((IP,Port))\n                if self.RequestChatHistoryBox.isChecked() :\n                    msg = ""requHist""\n                    sockclient.send(msg.encode(\'utf8\'))        \n                self.ChatDisplay.append(""... Connected ..."")\n                self.NewListener = listener()\n                self.NewListener.start()\n                self.NewListener.receiver.connect(self.print_message)\n                self.NewListener.ConnectCheckBoxUnset.connect(self.ConnectCheckBoxUnset)\n                self.NewListener.UserListUpdater.connect(self.UpdateUserList)\n            except Exception as inst:\n                self.ChatDisplay.append(""Could not connect to Server. Maybe IP and Port are wrong"")\n                #self.ChatDisplay.append(str(inst.args))\n                sockclient.close()\n                sockclient = socket.socket()\n                self.ConnectCheckBox.setChecked(False)\n                inst\n            finally:\n                bConnected = self.ConnectCheckBox.isChecked()\n        else:\n            msg = ""S/d""\n            sockclient.send(msg.encode(\'utf8\'))\n            sockclient.close()\n            self.ChatDisplay.append(""... Disconnecting ..."")\n            self.OnlineList.clear()\n            sockclient = socket.socket()\n            #sockclient.settimeout(5)\n            bConnected = self.ConnectCheckBox.isChecked()\n\n\n    def ConnectCheckBoxUnset(self):\n        global sockclient\n        global bConnected\n        sockclient.close()\n        sockclient = socket.socket()\n        #sockclient.settimeout(5)\n        self.ConnectCheckBox.setChecked(False)\n        bConnected = self.ConnectCheckBox.isChecked()\n        \n\n    def print_message(self,msg):\n        self.ChatDisplay.append(msg)\n        \n    def retranslateUi(self, ClientInterface):\n        global WindowTitle\n        _translate = QtCore.QCoreApplication.translate\n        ClientInterface.setWindowTitle(_translate(""ClientInterface"", WindowTitle))\n        self.SendButton.setText(_translate(""ClientInterface"", ""Send""))\n        self.ConnectCheckBox.setText(_translate(""ClientInterface"", ""Connect""))\n        self.IPField.setPlaceholderText(_translate(""ClientInterface"", ""IP""))\n        self.InputField.setPlaceholderText(_translate(""ClientInterface"", ""Message""))\n        self.FontText.setText(_translate(""ClientInterface"", ""Set Font Size""))\n        self.PortField.setPlaceholderText(_translate(""ClientInterface"", ""Port""))\n        self.RequestChatHistoryBox.setToolTip(""Request Chat History on Login"")\n        \n    def UpdateUserList(self, msg):\n        self.OnlineList.setPlainText(msg)\n        \n    #def ChangeFontSize(self): #TODO\n    #    Size = self.FontSizeBox.value()\n    #    newFont = QtGui.QFont()\n    #    newFont.setFamily(self.FontFamily)\n    #    newFont.setPointSize(Size)\n    #    self.setFont(newFont)\n    #    self.centralwidget.setFont(newFont)\n        \n    #def wheelEvent(self, QWheelEvent):\n    #    modifiers = QtGui.QGuiApplication.keyboardModifiers()\n    #    numDegrees = QWheelEvent.angleDelta().y() / 8\n    #    numSteps = numDegrees / 15\n    #    #self.print_message(str(numSteps))\n    #    if modifiers == QtCore.Qt.ControlModifier:\n    #        #self.print_message(str(modifiers))\n    #        if self.FontSizeBox.value() + numSteps <= self.FontSizeBox.maximum() and self.FontSizeBox.value() + numSteps >= self.FontSizeBox.minimum() :\n    #            self.FontSizeBox.setValue(self.FontSizeBox.value() + numSteps)\n    #            self.ChangeFontSize()\n    #            #self.print_message(str(self.FontSizeBox.value() + numSteps))\n\n \nclass listener(QtCore.QThread):\n    receiver = QtCore.pyqtSignal(str)\n    ConnectCheckBoxUnset = QtCore.pyqtSignal()\n    UserListUpdater = QtCore.pyqtSignal(str)\n    def __init__(self):\n        QtCore.QThread.__init__(self)\n        self.exiting = False\n\n    def run(self):\n        self.receiver.emit(""... Receiving ..."")\n        try:\n            while True:\n                Message = sockclient.recv(32767).decode(\'utf8\')\n                if len(Message) == 0:\n                    raise socket.error()\n                elif len(Message) >= 3 and Message[0]==""/"" and Message[1]==""u"":\n                    self.UserListUpdater.emit(Message[3:])\n                elif len(Message) >= 3 and Message[0]==""/"" and Message[1]==""f"":\n                    if platform.system() == \'Linux\':\n                        filename = ""Downloads/""\n                    else:\n                        filename = ""Downloads\\\\""\n                    filename += Message.split(\'/\',4)[2]\n                    try:\n                        os.makedirs(""Downloads"")\n                    except OSError as e:\n                        if e.errno != errno.EEXIST:\n                            pass\n                    fliecount = 1\n                    brakets = False\n                    if ""."" in filename:\n                        #extension = (filename + \'.\')[:-1]\n                        #bareName = (filename + \'.\')[:-1]\n                        extension = filename[filename.rfind("".""):]\n                        bareName = filename[:filename.rfind(""."")]\n                    else:\n                        bareName = filename\n                        extension = """"\n                    \n                    # This ""if"" case is usefull if a file is passed back and forth\n                    #     between people who change it and you want to track the iteration.\n                    # It is however annoying if the file is, for examplce, marked\n                    #     with a year in brackets.\n                    if bareName.endswith("")""):\n                        try:\n                            fliecount = int(bareName[bareName.rfind(""("")+1:bareName.rfind("")"")])\n                            bareName = bareName[:bareName.rfind(""("")]\n                            brakets = True\n                        except:\n                            pass\n                    while True:\n                        exists = os.path.isfile(filename)\n                        if exists:\n                            if brakets:\n                                filename = bareName\n                                filename += ""(""\n                                filename += str(fliecount)\n                                filename += "")""\n                                filename += extension\n                            else:\n                                filename = bareName\n                                filename += ""(1)""\n                                filename += extension\n                                brakets = True\n                            fliecount += 1\n                        else:\n                            break\n                    with open(filename,\'w\') as text_file:\n                        text_file.write(Message.split(\'/\',4)[3])\n                else:\n                    self.receiver.emit(Message)\n        except:\n            self.receiver.emit(""... Connection to server lost"")\n            self.ConnectCheckBoxUnset.emit()\n            self.UserListUpdater.emit(""No Server Connected"")\n            self.exiting = True\n\n#def main():\n#    app = QtWidgets.QApplication(sys.argv)\n#    app.setStyle(""fusion"")\n#\n#    form = MainWindow()\n#    form.show()\n#    sys.exit(app.exec_())\n# \n#if __name__==""__main__"":\n#    main()'"
AMaDiA_Files/AstusChat_Client_UI.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'AstusChat_Client_UI.ui\'\n#\n# Created by: PyQt5 UI code generator 5.9.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_ClientInterface(object):\n    def setupUi(self, ClientInterface):\n        ClientInterface.setObjectName(""ClientInterface"")\n        ClientInterface.resize(1018, 622)\n        self.centralwidget = QtWidgets.QWidget(ClientInterface)\n        self.centralwidget.setObjectName(""centralwidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.SendButton = QtWidgets.QPushButton(self.centralwidget)\n        self.SendButton.setObjectName(""SendButton"")\n        self.gridLayout.addWidget(self.SendButton, 3, 13, 1, 1)\n        self.FontSizeBox = QtWidgets.QSpinBox(self.centralwidget)\n        self.FontSizeBox.setMinimum(6)\n        self.FontSizeBox.setMaximum(18)\n        self.FontSizeBox.setProperty(""value"", 9)\n        self.FontSizeBox.setObjectName(""FontSizeBox"")\n        self.gridLayout.addWidget(self.FontSizeBox, 1, 9, 1, 1)\n        self.ConnectCheckBox = QtWidgets.QCheckBox(self.centralwidget)\n        self.ConnectCheckBox.setObjectName(""ConnectCheckBox"")\n        self.gridLayout.addWidget(self.ConnectCheckBox, 1, 5, 1, 1)\n        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem, 1, 6, 1, 1)\n        self.OnlineList = QtWidgets.QTextBrowser(self.centralwidget)\n        self.OnlineList.setObjectName(""OnlineList"")\n        self.gridLayout.addWidget(self.OnlineList, 1, 0, 3, 2)\n        self.IPField = QtWidgets.QLineEdit(self.centralwidget)\n        self.IPField.setAutoFillBackground(True)\n        self.IPField.setInputMask("""")\n        self.IPField.setText("""")\n        self.IPField.setObjectName(""IPField"")\n        self.gridLayout.addWidget(self.IPField, 1, 3, 1, 1)\n        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem1, 1, 2, 1, 1)\n        self.ChatDisplay = QtWidgets.QTextBrowser(self.centralwidget)\n        self.ChatDisplay.setObjectName(""ChatDisplay"")\n        self.gridLayout.addWidget(self.ChatDisplay, 2, 2, 1, 12)\n        self.FontText = QtWidgets.QLabel(self.centralwidget)\n        self.FontText.setObjectName(""FontText"")\n        self.gridLayout.addWidget(self.FontText, 1, 7, 1, 1)\n        self.PortField = QtWidgets.QLineEdit(self.centralwidget)\n        self.PortField.setAutoFillBackground(True)\n        self.PortField.setInputMask("""")\n        self.PortField.setObjectName(""PortField"")\n        self.gridLayout.addWidget(self.PortField, 1, 4, 1, 1, QtCore.Qt.AlignLeft)\n        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem2, 1, 10, 1, 1)\n        self.RequestChatHistoryBox = QtWidgets.QCheckBox(self.centralwidget)\n        self.RequestChatHistoryBox.setToolTipDuration(-1)\n        self.RequestChatHistoryBox.setText("""")\n        self.RequestChatHistoryBox.setObjectName(""RequestChatHistoryBox"")\n        self.gridLayout.addWidget(self.RequestChatHistoryBox, 1, 13, 1, 1, QtCore.Qt.AlignRight)\n        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem3, 1, 11, 1, 2)\n        self.InputField = QtWidgets.QLineEdit(self.centralwidget)\n        self.InputField.setAutoFillBackground(True)\n        self.InputField.setObjectName(""InputField"")\n        self.gridLayout.addWidget(self.InputField, 3, 2, 1, 11)\n        ClientInterface.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(ClientInterface)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 1018, 21))\n        self.menubar.setObjectName(""menubar"")\n        ClientInterface.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(ClientInterface)\n        self.statusbar.setObjectName(""statusbar"")\n        ClientInterface.setStatusBar(self.statusbar)\n\n        self.retranslateUi(ClientInterface)\n        QtCore.QMetaObject.connectSlotsByName(ClientInterface)\n\n    def retranslateUi(self, ClientInterface):\n        _translate = QtCore.QCoreApplication.translate\n        ClientInterface.setWindowTitle(_translate(""ClientInterface"", ""MainWindow""))\n        self.SendButton.setText(_translate(""ClientInterface"", ""Send""))\n        self.ConnectCheckBox.setText(_translate(""ClientInterface"", ""Connect""))\n        self.IPField.setPlaceholderText(_translate(""ClientInterface"", ""IP""))\n        self.FontText.setText(_translate(""ClientInterface"", ""Set Font Size""))\n        self.PortField.setPlaceholderText(_translate(""ClientInterface"", ""Port""))\n        self.RequestChatHistoryBox.setToolTip(_translate(""ClientInterface"", ""Request Chat History on Login""))\n        self.InputField.setPlaceholderText(_translate(""ClientInterface"", ""Message""))\n\n'"
AMaDiA_Files/AstusChat_Server.py,0,"b'#!/usr/bin/env python3\n#Server Version\nServerVersion = ""5.6""\n#Compatible with Client Version (Or Newer)\nClientVersion = ""4.3""\nAuthor = ""Robin \\\'Astus\\\' Albers""\n\nServerVersionAuthor = ""Server v""\nServerVersionAuthor+= ServerVersion\nServerVersionAuthor+= "" by ""\nServerVersionAuthor+= Author\n\n\nfrom AGeLib import AGeMain\nimport sys\nsys.path.append(\'..\')\nfrom PyQt5 import QtWidgets, QtCore, QtGui\nimport socket\nimport time\nimport platform\nimport datetime\nfrom AMaDiA_Files.AMaDiA_Functions import common_exceptions, ExceptionOutput\nfrom AMaDiA_Files.AstusChat_Server_UI import Ui_ServerInterface\n\nWindowTitle = ServerVersionAuthor\n\nglobal bConnected\nbConnected = False\n\nMakeHistory = False\n\n\n#--------------------------------------------------------------------------------------------------------------------------\ndef cTimeStr():\n    return str(datetime.datetime.now().strftime(\'%H:%M : \'))\n\ndef cTimeSStr():\n    return str(datetime.datetime.now().strftime(\'%H:%M:%S : \'))\n\nclass NameTaken(Exception):\n    def __init__(self, Message):\n        self.Message = Message\n    def __str__(self):\n        return repr(self.Message)\nclass ExcBanned(Exception):\n    def __init__(self, Message):\n        self.Message = Message\n    def __str__(self):\n        return repr(self.Message)\n\nclass ConnectionList(QtCore.QThread):\n    # Do not do ""List = []"" here as it would be shared by all objects of\n    # this class (even thoough it would probably not matter in this programm\n    printer = QtCore.pyqtSignal(str)\n    ServerUserListUpdater = QtCore.pyqtSignal()\n    \n    def __init__(self):\n        QtCore.QThread.__init__(self)\n        self.exiting = False\n        self.List = []  # creates a new List for each object of this class\n        self.Banned = [] # List of Banned IP for current session\n        \n    def append(self , x):\n        self.List.append(x)\n        \n    def __getitem__(self, key):\n        return self.List[key]\n    \n    def __len__(self):\n        return len(self.List)\n    \n    def CloseAll(self):\n        self.SendToAll(""THE SERVER IS CLOSING NOW"")\n        formmsg = cTimeSStr() + ""THE SERVER IS CLOSING NOW""\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(formmsg+\'\\n\')\n            except:\n                pass\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn:\n                try:\n                    self[i].client_socket.close()\n                except Exception as inst:\n                    msg = cTimeSStr()+"" Exception when Closing connection to ID ""\n                    msg += str(i)\n                    self.printer.emit(msg)\n                    self.printer.emit(str(inst.args))\n            i+=1\n\n    \n    def SendToAll(self,Message):\n        # Encode the massage here once to save the time to encode it for every user\n        Message = cTimeStr() + Message\n        if MakeHistory:\n            try:\n                with open(\'ClientChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(Message+""\\n"")\n            except:\n                pass\n        Message = Message.encode(""utf8"")\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn:\n                try:\n                    self[i].client_socket.send(Message)\n                except Exception as inst:\n                    self.printer.emit(cTimeSStr()+\'user logged off while A message was send. This is nigh impossible\')\n                    self.printer.emit(str(inst.args))\n            i+=1\n    \n    def SendToAllButOne(self,MyID,Message):\n        # Encode the massage here once to save the time to encode it for every user\n        Message = cTimeStr() + Message\n        if MakeHistory:\n            try:\n                with open(\'ClientChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(Message+""\\n"")\n            except:\n                pass\n        Message = Message.encode(""utf8"")\n        i=0\n        while i < len(self) :\n            if i != MyID and self[i].IsLoggedIn:\n                try:\n                    self[i].client_socket.send(Message)\n                except Exception as inst:\n                    formmsg = cTimeSStr() + \'user logged off while A message was send. This is nigh impossible\'\n                    self.printer.emit(formmsg)\n                    formmsg = str(inst.args)\n                    self.printer.emit(formmsg)\n            i+=1\n            \n    def SendToName(self, Recipient, Message):\n        i=0\n        bFound = False\n        while i < len(self) :\n            if self[i].IsLoggedIn and str(self[i].Username) == Recipient:\n                self[i].send(Message)\n                bFound = True\n            i+=1\n        if not bFound:\n            ErrorMessage = ""Could not send Message to User ""\n            ErrorMessage += str(Recipient)\n            ErrorMessage += "" as this Name is not logged in""\n            formmsg = cTimeSStr() + ErrorMessage\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+ErrorMessage+""\\n"")\n                except:\n                    pass\n            raise Exception(ErrorMessage)\n        \n    def SendToIP(self, RecipientIP, Message):\n        Message = str(datetime.datetime.now().strftime(\'%H:%M\')) + Message\n        Message = Message.encode(""utf8"")\n        i=0\n        bFound = False\n        while i < len(self) :\n            if self[i].IsLoggedIn and str(self[i].IP) == RecipientIP:\n                self[i].client_socket.send(Message)\n                bFound = True\n            i+=1\n        if not bFound:\n            ErrorMessage = ""Could not send Message to IP ""\n            ErrorMessage += str(RecipientIP)\n            ErrorMessage += "" as this IP is not logged in""\n            formmsg = cTimeSStr() + ErrorMessage\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+ErrorMessage+""\\n"")\n                except:\n                    pass\n            raise Exception(ErrorMessage)\n            \n        \n    def SendToIPPort(self, RecipientIP , RecipientPort , Message):\n        i=0\n        bFound = False\n        while i < len(self) :\n            if self[i].IsLoggedIn and str(self[i].IP) == RecipientIP and str(self[i].Port) == RecipientPort:\n                self[i].send(Message)\n                bFound = True\n            i+=1\n        if not bFound:\n            ErrorMessage = ""Could not send Message to ""\n            ErrorMessage += str(RecipientIP)\n            ErrorMessage += "":""\n            ErrorMessage += str(RecipientPort)\n            ErrorMessage += "" as it is not logged in""\n            formmsg = cTimeSStr() + ErrorMessage\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+ErrorMessage+""\\n"")\n                except:\n                    pass\n            raise Exception(ErrorMessage)\n            \n    def SendToID(self, RecipientID, Message):\n        if RecipientID in range(0,len(self)) and self[RecipientID].IsLoggedIn:\n            self[RecipientID].send(Message)\n        else:\n            ErrorMessage = ""Could not send Message to ID ""\n            ErrorMessage += str(RecipientID)\n            ErrorMessage += "" as this ID is not logged in""\n            formmsg = cTimeSStr() + ErrorMessage\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+ErrorMessage+""\\n"")\n                except:\n                    pass\n            raise Exception(ErrorMessage)\n            \n    def CheckUsername(self, Username):\n        if len(Username) == 0:\n            raise NameTaken(""Please actually ENTER SOMETHING instead of bashing return!"")\n        Username = Username.replace(\'""\',\'\')\n        Username = Username.replace(\'/\',\'\')\n        Username = Username.replace(\'>\',\'\')\n        if len(Username) == 0:\n            raise NameTaken(""> , \\"" and / are invalid"")\n        Username = Username.strip()\n        if len(Username) == 0:\n            raise NameTaken(""Spaces are obviously invalid"")\n        if len(Username) > 20:\n            raise NameTaken(""Username too long"")\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn and self[i].Username == Username:\n                raise NameTaken(""Username already taken"")\n            i+=1\n        return Username\n    \n    def SendToAll_Updated_Client_List(self):\n        self.ServerUserListUpdater.emit()\n        time.sleep(0.1)\n        Message = ""/u Users Online:\\n\\n""\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn:\n                Message += self[i]()\n                Message += ""\\n""\n            i+=1\n        Message = Message.encode(""utf8"")\n        formmsg = cTimeSStr() + ""Sending updated User list""\n        self.printer.emit(formmsg)\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn:\n                try:\n                    self[i].client_socket.send(Message)\n                except Exception as inst:\n                    formmsg = cTimeSStr() + \'user logged off while A message was send. This is nigh impossible\'\n                    self.printer.emit(formmsg)\n                    formmsg = str(inst.args)\n                    self.printer.emit(formmsg)\n            i+=1\n            \n    def SendFileToAllButOne(self,ID,MyFile):\n        Message = self[ID].Username\n        Message += "" has send the file \\""""\n        Message += MyFile.split(\'/\',4)[2]\n        Message += ""\\""""\n        formmsg = cTimeSStr() + Message\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(cTimeSStr()+Message+\'\\n\')\n            except:\n                pass\n        self.SendToAll(Message)\n        time.sleep(0.1)\n        i=0\n        while i < len(self) :\n            if self[i].IsLoggedIn and i != ID:\n                try:\n                    self[i].client_socket.send(MyFile.encode(""utf8""))\n                except Exception as inst:\n                    formmsg = cTimeSStr() + \'user logged off while A message was send. This is nigh impossible\'\n                    self.printer.emit(formmsg)\n                    formmsg = str(inst.args)\n                    self.printer.emit(formmsg)\n            i+=1\n        \n\n    def HandleMessage(self,ID,rawMessage):\n        global ServerVersionAuthor\n        Commands = LookForCommands(rawMessage)\n        if not self[ID].CommandRights:\n            Message = self[ID].Username\n            Message += "": ""\n            Message += rawMessage\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            self.SendToAll(Message)\n            \n        elif Commands[0] == ""none"":\n            Message = self[ID].Username\n            Message += "": ""\n            Message += Commands[2]\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            self.SendToAll(Message)\n            \n        elif len(Commands[0]) >= 2 and Commands[0][1]==""w"":\n            try:\n                Message = self[ID].Username\n                Message += "" whispers to ""\n                if len(Commands[0]) >= 3 and Commands[0] == ""/wd"":\n                    sMessage = ""user with ID ""\n                    sMessage += Commands[1]\n                elif len(Commands[0]) >= 3 and Commands[0] == ""/wp"":\n                    sMessage = Commands[1]\n                    sMessage += "":""\n                    sMessage += Commands[3]\n                else:\n                    sMessage = Commands[1]\n                sMessage += "":""\n                sMessage += Commands[2]\n                bMessage = ""You whisper to ""\n                bMessage += sMessage\n                sMessage = Message + sMessage\n                formmsg = cTimeSStr() + sMessage\n                self.printer.emit(formmsg)\n                if MakeHistory:\n                    try:\n                        with open(\'ChatHistory.txt\',\'a\') as text_file:\n                            text_file.write(cTimeSStr()+sMessage+\'\\n\')\n                    except:\n                        pass\n                Message += ""you:""\n                Message += Commands[2]\n                if Commands[0] == ""/w"":\n                    self.SendToName(Commands[1],Message)\n                elif len(Commands[0]) >= 3 and Commands[0] == ""/wp"":\n                    self.SendToIPPort(Commands[1],Commands[3],Message)\n                elif len(Commands[0]) >= 3 and Commands[0] == ""/wi"":\n                    self.SendToIP(Commands[1],Message)\n                elif len(Commands[0]) >= 3 and Commands[0] == ""/wd"":\n                    self.SendToID(int(Commands[1]),Message)\n                self.SendToID(ID,bMessage)\n            except Exception as inst:\n                try:\n                    Message = str(inst.args)\n                    self.SendToID(ID,Message)\n                except Exception:\n                    formmsg = cTimeSStr() + \'user logged off after request\'\n                    self.printer.emit(formmsg)\n            \n            \n        elif Commands[0]==""l"":\n            Message = ""All logged in Clients are \\n""\n            i=0\n            while i < len(self) :\n                if self[i].IsLoggedIn:\n                    Message += str(self[i].IP)\n                    Message += "":""\n                    Message += str(self[i].Port)\n                    Message += "" as ""\n                    Message += self[i].Username\n                    Message += "" with ID ""\n                    Message += str(self[i].MyID)\n                    Message += ""\\n""\n                i+=1\n            formmsg = cTimeSStr() + self[ID].Username\n            formmsg += "" has requested the list of all clients""\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+self[ID].Username+"" has requested the list of all clients\\n"")\n                except:\n                    pass\n            try:\n                self.SendToID(ID,Message)\n            except Exception:\n                formmsg = cTimeSStr() + \'user logged off after request\'\n                self.printer.emit(formmsg)\n            \n        elif Commands[0]==""n"":\n            try:\n                NewName = Connections.CheckUsername(Commands[1])\n                Message = self[ID].Username\n                Message += "" has changed their username to ""\n                Message += NewName\n                self[ID].Username = NewName\n                formmsg = cTimeSStr() + Message\n                self.printer.emit(formmsg)\n                if MakeHistory:\n                    try:\n                        with open(\'ChatHistory.txt\',\'a\') as text_file:\n                            text_file.write(cTimeSStr()+Message+\'\\n\')\n                    except:\n                        pass\n                self.SendToAll(Message)\n                self.SendToAll_Updated_Client_List()\n            except NameTaken as inst:\n                try:\n                    self.SendToID(ID,inst.Message)\n                except Exception:\n                    formmsg = cTimeSStr() + \'user logged off after request\'\n                    self.printer.emit(formmsg)\n            \n        elif Commands[0]==""d"":\n            self[ID].IsLoggedIn = False\n            self[ID].client_socket.close()\n        \n        \n            \n        elif Commands[0]==""f"":\n            self.SendFileToAllButOne(ID,Commands[2])\n            \n        elif Commands[0] == ""panic"":\n            Message = ""<b>DON\'T PANIC </b>"" \n            Message += self[ID].Username\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            self.SendToAll(Message)\n            \n        elif Commands[0] == ""scream"":\n            Message = ""<i>"" \n            Message += self[ID].Username\n            Message += "" runs around in circles, screaming!</i>""\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            self.SendToAll(Message)\n            \n        elif Commands[0] == ""me"":\n            Message = ""<i>"" \n            Message += self[ID].Username\n            Message += Commands[2]\n            Message += ""</i>""\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            self.SendToAll(Message)\n            \n            \n        else: # elif Commands[0]==""?"":\n            Message = ServerVersionAuthor\n            Message += ""\\n          Commands are: \\n""\n            Message += ""            /w \\""<username>\\"" <Message> to whisper to a user \\n""\n            Message += ""            /wp \\""<IP:Port>\\"" <Message> to whisper to a user \\n""\n            Message += ""            /wi \\""<IP>\\"" <Message> to whisper to a user \\n""\n            Message += ""            /wd \\""<ID>\\"" <Message> to whisper to a user \\n""\n            Message += ""            /l to display all currently logged in Clients \\n""\n            Message += ""            /n <username> change the username \\n""\n            Message += ""            /d to disconnect \\n""\n            Message += ""            /me \\n""\n            Message += ""            /panic to show your panic \\n""\n            Message += ""            /scream - the most reasonable answer to everything \\n""\n            Message += ""            /? to display this message\\n""\n            formmsg = cTimeSStr() + self[ID].Username\n            formmsg += "" has requested the list of commands""\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+self[ID].Username+""has requested the list of commands\\n"")\n                except:\n                    pass\n            try:\n                self.SendToID(ID,Message)\n            except Exception:\n                formmsg = cTimeSStr() + \'user logged off after request\'\n                self.printer.emit(formmsg)\n            \n        \ndef LookForCommands(Message):\n    if len(Message)>=2 and Message[0] == ""/"":\n        if Message[1] == ""u"":\n            return (""none"",""none"",Message[2:],""none"")\n        elif len(Message) > 4:\n            # /w{p|i|d} ""<username|IP:Port|IP|ID>"" <Message> to whisper to a user\n            if Message[1] == ""w"" and Message.count(\'""\')>=2:\n                c , Recipient , Message = Message.split(\'""\',2)\n                if c[2]==""p"":\n                    if Recipient.count(\':\')==1:\n                        RIP , RPort = Recipient.split(\':\')\n                        return (c[:3],RIP, Message,RPort)\n                elif c[2]==""i"" or c[2]==""d"":\n                    return (c[:3],Recipient, Message,""none"")\n                else:\n                    return (c[:2],Recipient, Message,""none"")\n            # /n <username> change the username\n            elif Message[1] == ""n"":\n                Message = Message[3:]\n                return (""n"",Message,""none"",""none"")\n            elif Message[1] == ""f"":\n                return (""f"",""none"",Message,""none"")\n            elif Message[1] == ""m"" and Message[2] == ""e"":\n                return (""me"",""none"", Message[3:],""none"")\n            elif Message == ""/panic"":\n                return (""panic"",""none"",""none"",""none"")\n            elif Message == ""/scream"":\n                return (""scream"",""none"",""none"",""none"")\n            # no command\n            else:\n                return (""none"",""none"",Message,""none"")\n        # /l to display all currently logged in Clients\n        elif(Message == ""/l""):\n            return (""l"",""none"",""none"",""none"")\n        # /d to disconnect\n        elif(Message == ""/d""):\n            return (""d"",""none"",""none"",""none"")\n        # /? to get a list of Commands\n        elif(Message == ""/?""):\n            return (""?"",""none"",""none"",""none"")\n        # no command\n        else:\n            return (""none"",""none"",Message,""none"")\n    # no command\n    else:\n        return (""none"",""none"",Message,""none"")\n        \n\n\nclass ConnectionObject(QtCore.QThread):\n    printer = QtCore.pyqtSignal(str)\n    global Connections\n    def __init__(self,i):\n        QtCore.QThread.__init__(self)\n        self.exiting = False\n        global sock\n        self.MyID = i\n        try:\n            self.client_socket, self.addr = sock.accept()\n        except Exception as inst:\n            self.printer.emit(""Exception in ConnctionObject Constructor"")\n            self.printer.emit(str(inst.args))\n            self.printer.emit(""If the Server was just closed this exception is absolutely normal and even expected."")\n            raise ExcBanned("""")\n        self.IP = self.client_socket.getpeername()[0]\n        self.Port = self.client_socket.getpeername()[1]\n        if self.IP in Connections.Banned:\n            raise ExcBanned(""Banned IP tried to connect"")\n        # TODO Maybe check if IP:Port pair is already logged in (First check if this is even possible)\n        self.IsLoggedIn = False\n        self.Muted = False\n        self.CommandRights = False\n        self.Username = ""/Username Not Set Yet""\n\n\n    def __call__(self):\n        if self.Muted:\n            MyInfo = ""(M) ""\n            MyInfo += str(self.IP)\n        elif not self.CommandRights:\n            MyInfo = ""(D) ""\n            MyInfo += str(self.IP)\n        else:\n            MyInfo = str(self.IP)\n        MyInfo += "":""\n        MyInfo += str(self.Port)\n        MyInfo += "" as ""\n        MyInfo += self.Username\n        MyInfo += "" with ID ""\n        MyInfo += str(self.MyID)\n        return MyInfo\n        \n    def SetUsername(self):\n        while True:\n            try:\n                self.client_socket.send((""Please Choose your username: "").encode(""utf8""))\n                Username = self.client_socket.recv(32767).decode(""utf8"")\n                if len(Username) == 0:\n                    raise socket.error\n                requHist = False\n                if Username == ""requHist"":\n                    requHist = True\n                    Username = self.client_socket.recv(32767).decode(""utf8"")\n                    if len(Username) == 0:\n                        raise socket.error\n                    \n                Username = Username[1:]\n                if len(Username) == 2 and Username[0]==""/"" and Username[1]==""d"":\n                    raise socket.error\n                if len(Username) >= 2 and Username[0]==""/"" and Username[1]==""f"":\n                    self.client_socket.send((""Please do NOT use files as your Username "").encode(""utf8""))\n                    continue\n                self.Username = Connections.CheckUsername(Username)\n                if requHist:\n                    if MakeHistory:\n                        try:\n                            with open(\'ClientChatHistory.txt\', \'r\') as content_file:\n                                ClientChatHistory = ""\\n\\nChatHistory:\\n\\n""\n                                ClientChatHistory += content_file.read()\n                        except:\n                            ClientChatHistory = ""No Chat History""\n                    else:\n                        ClientChatHistory = ""Chat History is disabled by the Server""\n                    self.client_socket.send(ClientChatHistory.encode(""utf8""))\n                break\n            except NameTaken as inst:\n                self.client_socket.send((inst.Message).encode(""utf8""))\n        Message = str(self.IP)\n        Message += "":""\n        Message += str(self.Port)\n        Message += "" has joined as \\""""\n        Message += self.Username\n        Message += ""\\"" with ID ""\n        Message += str(self.MyID)\n        formmsg = cTimeSStr() + Message\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(cTimeSStr()+Message+\'\\n\')\n            except:\n                pass\n        self.IsLoggedIn = True\n        self.CommandRights = True\n        Connections.SendToAll(Message)\n        Connections.SendToAll_Updated_Client_List()\n            \n    def send(self,Message):\n        Message = cTimeStr() + Message\n        Message = Message.encode(""utf8"")\n        self.client_socket.send(Message)\n        \n    def ListenForMessage(self):\n        global Connections\n        Message = self.client_socket.recv(32767).decode(""utf8"")\n        if len(Message) == 0:\n            raise socket.error()\n        Message = Message[1:]\n        if not self.Muted:\n            Connections.HandleMessage(self.MyID,Message)\n\n    def Kick(self):\n        self.IsLoggedIn = False\n        self.client_socket.close()\n        msg = self.Username + "" has been Kicked""\n        formmsg = cTimeSStr() + msg\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(formmsg+\'\\n\')\n            except:\n                pass\n        Connections.SendToAll(msg)\n\n    def Mute(self):\n        self.Muted = not self.Muted\n        if self.Muted:\n            msg = self.Username + "" has been Muted""\n        else:\n            msg = self.Username + "" is no longer Muted""\n        formmsg = cTimeSStr() + msg\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(formmsg+\'\\n\')\n            except:\n                pass\n        Connections.SendToAll(msg)\n        Connections.SendToAll_Updated_Client_List()\n\n    def Ban(self):\n        Connections.Banned.append(self.IP)\n        self.IsLoggedIn = False\n        self.client_socket.close()\n        msg = ""The IP ""+self.IP\n        msg += "" has been Banned""\n        formmsg = cTimeSStr() + msg\n        self.printer.emit(formmsg)\n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\',\'a\') as text_file:\n                    text_file.write(formmsg+\'\\n\')\n            except:\n                pass\n        Connections.SendToAll(msg)\n\n\n\nclass handle_client(QtCore.QThread):\n    printer = QtCore.pyqtSignal(str)\n    def __init__(self,MyID):\n        QtCore.QThread.__init__(self)\n        self.exiting = False\n        self.MyID = MyID\n\n    def run(self):\n        global Connections\n        try:\n            formmsg = cTimeSStr() + ""New Connection:""\n            formmsg += str(Connections[self.MyID].client_socket)\n            self.printer.emit(formmsg)\n            Connections[self.MyID].SetUsername()\n            while True:\n                Connections[self.MyID].ListenForMessage()\n        except socket.error:\n            Connections[self.MyID].IsLoggedIn = False\n            Message = Connections[self.MyID].Username\n            Message += "" has disconnected""\n            formmsg = cTimeSStr() + Message\n            self.printer.emit(formmsg)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(cTimeSStr()+Message+\'\\n\')\n                except:\n                    pass\n            if Connections[self.MyID].Username != ""/Username Not Set Yet"":\n                Connections.SendToAllButOne(self.MyID,Message)\n                Connections.SendToAll_Updated_Client_List()\n        finally:\n            try:\n                Connections[self.MyID].client_socket.close()\n            except Exception:\n                pass\n    \n    def print(self,msg):\n        self.printer.emit(msg)\n\n\nclass Server(QtCore.QThread):\n    receiver = QtCore.pyqtSignal(str)\n    ConnectCheckBoxUnset = QtCore.pyqtSignal()\n    ServerUserListUpdater = QtCore.pyqtSignal()\n    fail = QtCore.pyqtSignal(str)\n    def __init__(self,IP,Port):\n        QtCore.QThread.__init__(self)\n        self.exiting = False\n        self.IP = IP\n        self.Port = Port\n\n    def run(self):\n        global Connections\n        global sock\n        global threadList\n        \n        try:\n            Connections = ConnectionList()\n            Connections.printer.connect(self.printer)\n            Connections.ServerUserListUpdater.connect(self.ServerUserListUpdater)\n            sock = socket.socket()\n            sock.bind((self.IP,self.Port))  # Set the Number to 0 to get a random free Port\n        except Exception as inst:\n            self.fail.emit(str(inst.args))\n            sock.close()\n            self.exiting = True\n            self.exit()\n            #raise Exception(""The Server has stopped"")\n        else:\n        \n            Message = \'\\n\'\n            Message += ServerVersionAuthor\n            Message += \'\\n\'\n            Message += str(datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S\'))\n            Message += "": Server started with IP and Port: \\\'""\n            Message += str(self.IP)\n            Message += ""\\\',""\n            Message += str(self.Port)\n            if MakeHistory:\n                try:\n                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(Message+\'\\n\')\n                except:\n                    pass\n                try:\n                    with open(\'ClientChatHistory.txt\',\'a\') as text_file:\n                        text_file.write(Message+""\\n"")\n                except:\n                    pass\n            self.receiver.emit(Message)\n            threadList = []\n            sock.listen() #maybe add a fixed number but a ""reasonable value"" is chosen automatically\n            \n            i = 0\n            \n            while not self.exiting: \n                try:\n                    Connections.append(ConnectionObject(i))\n                except ExcBanned:\n                    continue\n                threadList.append(handle_client(i))\n                threadList[i].printer.connect(self.printer)\n                Connections[i].printer.connect(self.printer)\n                threadList[i].start()\n                i+=1\n\n    def printer(self,msg):\n        self.receiver.emit(msg)\n\n    \n#--------------------------------------------------------------------------------------------------------------------------\n\n\n\nclass MainWindow(QtWidgets.QMainWindow, Ui_ServerInterface): \n    global bConnected\n    global Connections\n    global sock\n\n    def __init__(self, parent = None):\n        super(MainWindow, self).__init__(parent)\n        self.setupUi(self)\n        \n        \n        #self.retranslateUi(self)\n        global bConnected\n        \n        \n        \n        self.PortField.setText(""32005"")\n        try:\n            myIP = str(socket.gethostbyname(socket.gethostname()))\n            \n            if platform.system() == \'Linux\':\n                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n                s.connect((""8.8.8.8"", 80))\n                myIP =  str(s.getsockname()[0])\n                del s\n        except:\n            pass\n            \n        #if platform.system() == \'Linux\':\n        self.IPField.setText(myIP)\n            \n        self.ConnectCheckBox.clicked.connect(self.on_ConnectBoxChanged) \n        self.SendButton.clicked.connect(self.on_sendButtonClicked)\n        self.MuteButton.clicked.connect(self.Mute)\n        self.BanButton.clicked.connect(self.Ban)\n        self.KickButton.clicked.connect(self.Kick)\n        self.InputField.returnPressed.connect(self.on_sendButtonClicked)\n        #self.FontSizeBox.valueChanged.connect(self.ChangeFontSize) #TODO\n        self.FontSizeBox.setVisible(False)\n        self.FontText.setVisible(False)\n        \n        if MakeHistory:\n            try:\n                with open(\'ChatHistory.txt\', \'r\') as content_file:\n                    History = ""\\n\\nChatHistory:\\n\\n""\n                    History += content_file.read()\n            except:\n                History = ""No Chat History""\n        else:\n            History = ""Chat History is disabled by the Server""\n        self.print_message(History)\n        \n\n    def on_sendButtonClicked(self):\n        msg = self.InputField.text()\n        self.InputField.clear()\n        if self.ConnectCheckBox.isChecked():\n            if len(msg) >= 2 and msg[0] == ""/"":\n                if msg[1] == ""n"" and msg.count(\'""\')>=2:\n                    c , ID , NewUsername = msg.split(\'""\',2) # pylint: disable=unused-variable\n                    try:\n                        ID = int(ID)\n                    except Exception:\n                        self.print_message(""ID must be an integer"")\n                    else:\n                        try:\n                            NewUsername = Connections.CheckUsername(NewUsername)\n                        except NameTaken as inst:\n                            self.print_message(inst.Message)\n                        else:\n                            if len(Connections) > ID and ID >= 0 and Connections[ID].IsLoggedIn:\n                                Connections[ID].Username = NewUsername\n                                Connections.SendToAll_Updated_Client_List()\n                            else:\n                                self.print_message(""Invalid ID"")\n                elif msg[1] == ""r"" and len(msg) > 3:\n                    ID = msg[2:]\n                    try:\n                        ID = int(ID)\n                    except Exception:\n                        self.print_message(""ID must be an integer"")\n                    else:\n                        if len(Connections) > ID and ID >= 0 and Connections[ID].IsLoggedIn:\n                            if Connections[ID].CommandRights:\n                                Connections[ID].CommandRights = False\n                                msg = "" can no longer use commands""\n                            else:\n                                Connections[ID].CommandRights = True\n                                msg = "" can use commands again""\n                            msg = Connections[ID].Username + msg\n                            formmsg = cTimeSStr() + msg\n                            self.print_message(formmsg)\n                            if MakeHistory:\n                                try:\n                                    with open(\'ChatHistory.txt\',\'a\') as text_file:\n                                        text_file.write(cTimeSStr()+msg+\'\\n\')\n                                except:\n                                    pass\n                            Connections.SendToAll_Updated_Client_List()\n                            Connections.SendToAll(msg)\n                        else:\n                            self.print_message(""Invalid ID"")\n                elif msg == ""/?"":\n                    sCommands  = ""/n \\""<ID>\\"" <Name>   to Rename a User\\n""\n                    sCommands += ""/r <ID>   revoke a users right to use commands or regrant rights\\n""\n                    sCommands += ""/? to display this message""\n                    self.print_message(sCommands)\n                else:\n                    msg = ""   SERVER   : "" + msg\n                    formmsg = cTimeSStr() + msg\n                    self.print_message(formmsg)\n                    if MakeHistory:\n                        try:\n                            with open(\'ChatHistory.txt\',\'a\') as text_file:\n                                text_file.write(cTimeSStr()+msg+\'\\n\')\n                        except:\n                            pass\n                    Connections.SendToAll(msg)\n            else:\n                msg = ""   SERVER   : "" + msg\n                formmsg = cTimeSStr() + msg\n                self.print_message(formmsg)\n                if MakeHistory:\n                    try:\n                        with open(\'ChatHistory.txt\',\'a\') as text_file:\n                            text_file.write(cTimeSStr()+msg+\'\\n\')\n                    except:\n                        pass\n                Connections.SendToAll(msg)\n        else:\n            msg = ""   SERVER   : "" + msg\n            msg = cTimeSStr() + msg\n            self.print_message(msg)\n\n\n    \n    \n    def on_ConnectBoxChanged(self):\n        global bConnected\n        global sock\n        if self.ConnectCheckBox.isChecked() :\n            self.print_message(""Trying to deploy..."")\n            IP = self.IPField.text()\n            Port = int(self.PortField.text())\n            try:\n                self.NewServer = Server(IP,Port)\n                self.NewServer.start()\n                self.NewServer.receiver.connect(self.print_message)\n                self.NewServer.ConnectCheckBoxUnset.connect(self.ConnectCheckBoxUnset)\n                self.NewServer.ServerUserListUpdater.connect(self.UpdateUserList)\n                self.NewServer.fail.connect(self.FailInServer)\n                self.print_message(""... Deployed ..."")\n            except Exception as inst:\n                self.print_message(""Could not deploy Sever"")\n                self.print_message(str(inst.args))\n                self.NewServer.exiting = True\n                self.OnlineList.clear()\n                Connections.CloseAll()\n                sock.close()\n                del sock\n                self.NewServer.exit()\n                self.ConnectCheckBox.setChecked(False)\n            finally:\n                bConnected = self.ConnectCheckBox.isChecked()\n        else:\n            self.ConnectCheckBoxUnset()\n\n\n    def ConnectCheckBoxUnset(self):\n        global bConnected\n        global threadList\n        global sock\n        e = 0\n        self.print_message(""... Closing Server ...\\n"")\n        try:\n            sock.close()\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        del sock\n        i=0\n        try:\n            while i < len(threadList):\n                try:\n                    threadList[i].exiting = True\n                except Exception as inst:\n                    self.print_message(inst.args)\n                    e += 1\n                i+=1\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        try:\n            self.NewServer.exiting = True\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        self.OnlineList.clear()\n        try:\n            Connections.CloseAll()\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        i=0\n        try:\n            while i < len(threadList):\n                try:\n                    threadList[i].exit()\n                except Exception as inst:\n                    self.print_message(inst.args)\n                    e += 1\n                i+=1\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        try:\n            self.NewServer.exit()\n        except Exception as inst:\n            self.print_message(inst.args)\n            e += 1\n        self.ConnectCheckBox.setChecked(False)\n        bConnected = self.ConnectCheckBox.isChecked()\n        if e>0:\n            msg = str(e)\n            msg += "" Exceptions occured during the Termination of all Server/Client Threads""\n            self.print_message(msg)\n        self.print_message(""Sever Closed\\n\\n"")\n            \n    def FailInServer(self,msg):\n        self.ConnectCheckBoxUnset()\n        self.print_message(""An Exception occured in the Server Thread"")\n        self.print_message(msg)\n\n    def print_message(self,msg):\n        if type(msg) != str:\n            msg = str(msg)\n        self.ChatDisplay.append(msg)\n        \n    def retranslateUi(self, ClientInterface):\n        global WindowTitle\n        _translate = QtCore.QCoreApplication.translate\n        ClientInterface.setWindowTitle(_translate(""ClientInterface"", WindowTitle))\n        self.PortField.setPlaceholderText(_translate(""ServerInterface"", ""Port""))\n        self.MuteButton.setText(_translate(""ServerInterface"", ""Mute""))\n        self.IPField.setPlaceholderText(_translate(""ServerInterface"", ""IP""))\n        self.FontText.setText(_translate(""ServerInterface"", ""Set Font Size""))\n        self.SendButton.setText(_translate(""ServerInterface"", ""Send""))\n        self.ConnectCheckBox.setText(_translate(""ServerInterface"", ""SetUp""))\n        self.BanButton.setText(_translate(""ServerInterface"", ""Ban""))\n        self.KickButton.setText(_translate(""ServerInterface"", ""Kick""))\n        self.InputField.setPlaceholderText(_translate(""ServerInterface"", ""Message""))\n        \n    def UpdateUserList(self):\n        self.OnlineList.clear()\n        i=0\n        while i < len(Connections) :\n            if Connections[i].IsLoggedIn:\n                item = QtWidgets.QListWidgetItem()\n                item.setData(0 , Connections[i]())\n                item.setData(1 , Connections[i].MyID)\n                item.setText(Connections[i]())\n                self.OnlineList.addItem(item)\n            i+=1\n        \n    def Mute(self):\n        if self.ConnectCheckBox.isChecked():\n            try:\n                Connections[self.OnlineList.currentItem().data(1)].Mute()\n            except:\n                pass\n\n    def Kick(self):\n        if self.ConnectCheckBox.isChecked():\n            try:\n                Connections[self.OnlineList.currentItem().data(1)].Kick()\n            except:\n                pass\n\n    def Ban(self):\n        if self.ConnectCheckBox.isChecked():\n            try:\n                Connections[self.OnlineList.currentItem().data(1)].Ban()\n            except:\n                pass\n        \n    #def ChangeFontSize(self): #TODO\n    #    Size = self.FontSizeBox.value()\n    #    newFont = QtGui.QFont()\n    #    newFont.setFamily(self.FontFamily)\n    #    newFont.setPointSize(Size)\n    #    self.setFont(newFont)\n    #    self.centralwidget.setFont(newFont)\n\n\n\n#def main():\n#    global bConnected\n#    bConnected = False\n#    app = QtWidgets.QApplication(sys.argv)\n#    app.setStyle(""fusion"")\n#\n#    form = MainWindow()\n#    form.show()\n#    sys.exit(app.exec_())\n# \n#if __name__==""__main__"":\n#    main()'"
AMaDiA_Files/AstusChat_Server_UI.py,0,"b'# -*- coding: utf-8 -*-\n\n# Form implementation generated from reading ui file \'AstusChat_Server_UI.ui\'\n#\n# Created by: PyQt5 UI code generator 5.9.2\n#\n# WARNING! All changes made in this file will be lost!\n\nfrom PyQt5 import QtCore, QtGui, QtWidgets\n\nclass Ui_ServerInterface(object):\n    def setupUi(self, ServerInterface):\n        ServerInterface.setObjectName(""ServerInterface"")\n        ServerInterface.resize(983, 668)\n        self.centralwidget = QtWidgets.QWidget(ServerInterface)\n        self.centralwidget.setObjectName(""centralwidget"")\n        self.gridLayout = QtWidgets.QGridLayout(self.centralwidget)\n        self.gridLayout.setObjectName(""gridLayout"")\n        self.ChatDisplay = QtWidgets.QTextBrowser(self.centralwidget)\n        self.ChatDisplay.setObjectName(""ChatDisplay"")\n        self.gridLayout.addWidget(self.ChatDisplay, 2, 6, 1, 12)\n        self.OnlineList = QtWidgets.QListWidget(self.centralwidget)\n        self.OnlineList.setAutoScroll(False)\n        self.OnlineList.setObjectName(""OnlineList"")\n        self.gridLayout.addWidget(self.OnlineList, 1, 0, 2, 5)\n        self.PortField = QtWidgets.QLineEdit(self.centralwidget)\n        self.PortField.setAutoFillBackground(True)\n        self.PortField.setInputMask("""")\n        self.PortField.setObjectName(""PortField"")\n        self.gridLayout.addWidget(self.PortField, 1, 8, 1, 1, QtCore.Qt.AlignLeft)\n        self.FontSizeBox = QtWidgets.QSpinBox(self.centralwidget)\n        self.FontSizeBox.setMinimum(6)\n        self.FontSizeBox.setMaximum(18)\n        self.FontSizeBox.setProperty(""value"", 9)\n        self.FontSizeBox.setObjectName(""FontSizeBox"")\n        self.gridLayout.addWidget(self.FontSizeBox, 1, 13, 1, 1)\n        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem, 1, 10, 1, 1)\n        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem1, 1, 6, 1, 1)\n        self.MuteButton = QtWidgets.QPushButton(self.centralwidget)\n        self.MuteButton.setObjectName(""MuteButton"")\n        self.gridLayout.addWidget(self.MuteButton, 3, 3, 1, 1)\n        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem2, 1, 14, 1, 1)\n        spacerItem3 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)\n        self.gridLayout.addItem(spacerItem3, 1, 15, 1, 2)\n        self.IPField = QtWidgets.QLineEdit(self.centralwidget)\n        self.IPField.setAutoFillBackground(True)\n        self.IPField.setInputMask("""")\n        self.IPField.setText("""")\n        self.IPField.setObjectName(""IPField"")\n        self.gridLayout.addWidget(self.IPField, 1, 7, 1, 1)\n        self.FontText = QtWidgets.QLabel(self.centralwidget)\n        self.FontText.setObjectName(""FontText"")\n        self.gridLayout.addWidget(self.FontText, 1, 11, 1, 1)\n        self.SendButton = QtWidgets.QPushButton(self.centralwidget)\n        self.SendButton.setObjectName(""SendButton"")\n        self.gridLayout.addWidget(self.SendButton, 3, 17, 1, 1)\n        self.ConnectCheckBox = QtWidgets.QCheckBox(self.centralwidget)\n        self.ConnectCheckBox.setObjectName(""ConnectCheckBox"")\n        self.gridLayout.addWidget(self.ConnectCheckBox, 1, 9, 1, 1)\n        self.BanButton = QtWidgets.QPushButton(self.centralwidget)\n        self.BanButton.setObjectName(""BanButton"")\n        self.gridLayout.addWidget(self.BanButton, 3, 1, 1, 1)\n        self.KickButton = QtWidgets.QPushButton(self.centralwidget)\n        self.KickButton.setObjectName(""KickButton"")\n        self.gridLayout.addWidget(self.KickButton, 3, 2, 1, 1)\n        self.InputField = QtWidgets.QLineEdit(self.centralwidget)\n        self.InputField.setAutoFillBackground(True)\n        self.InputField.setObjectName(""InputField"")\n        self.gridLayout.addWidget(self.InputField, 3, 6, 1, 11)\n        ServerInterface.setCentralWidget(self.centralwidget)\n        self.menubar = QtWidgets.QMenuBar(ServerInterface)\n        self.menubar.setGeometry(QtCore.QRect(0, 0, 983, 21))\n        self.menubar.setObjectName(""menubar"")\n        ServerInterface.setMenuBar(self.menubar)\n        self.statusbar = QtWidgets.QStatusBar(ServerInterface)\n        self.statusbar.setObjectName(""statusbar"")\n        ServerInterface.setStatusBar(self.statusbar)\n\n        self.retranslateUi(ServerInterface)\n        QtCore.QMetaObject.connectSlotsByName(ServerInterface)\n\n    def retranslateUi(self, ServerInterface):\n        _translate = QtCore.QCoreApplication.translate\n        ServerInterface.setWindowTitle(_translate(""ServerInterface"", ""Chat Server by Astus""))\n        self.PortField.setPlaceholderText(_translate(""ServerInterface"", ""Port""))\n        self.MuteButton.setText(_translate(""ServerInterface"", ""Mute""))\n        self.IPField.setPlaceholderText(_translate(""ServerInterface"", ""IP""))\n        self.FontText.setText(_translate(""ServerInterface"", ""Set Font Size""))\n        self.SendButton.setText(_translate(""ServerInterface"", ""Send""))\n        self.ConnectCheckBox.setText(_translate(""ServerInterface"", ""SetUp""))\n        self.BanButton.setText(_translate(""ServerInterface"", ""Ban""))\n        self.KickButton.setText(_translate(""ServerInterface"", ""Kick""))\n        self.InputField.setPlaceholderText(_translate(""ServerInterface"", ""Message""))\n\n'"
AMaDiA_Files/NoEvalParse.py,0,"b'# -*- coding: utf-8 -*-\nimport sys\nfrom codecs import decode\n\nimport re\nimport sympy\nfrom sympy.parsing.sympy_parser import parse_expr\nfrom sympy import Matrix, linsolve\ncommon_exceptions = (TypeError , SyntaxError , sympy.SympifyError , sympy.parsing.sympy_parser.TokenError , re.error ,  AttributeError , ValueError , NotImplementedError , Exception , RuntimeError , ImportError)\n\nif __name__ ==""__main__"":\n    sympy.init_printing()\n    if len(sys.argv) == 2:\n        my_str_o = decode(sys.argv[1], \'unicode_escape\')\n        try:\n            with sympy.evaluate(False):\n                my_str = parse_expr(my_str_o,evaluate=False)\n                my_str = sympy.latex(my_str)\n        except common_exceptions:\n            # The following may look weird but it totally is!!! It does not work in any other way...\n            with sympy.evaluate(True):\n                my_str = parse_expr(my_str_o,evaluate=True)\n                my_str = sympy.latex(my_str)\n            my_str = parse_expr(my_str_o,evaluate=False)\n            try:\n                my_str = sympy.latex(my_str)\n            except common_exceptions:\n                with sympy.evaluate(True):\n                    my_str = parse_expr(my_str_o,evaluate=False)\n                    my_str = sympy.latex(my_str)\n        # alternatively you transform it to a bytes obj and\n        # then call decode with:\n        # my_str = bytes(sys.argv[1], \'utf-8\').decode(\'unicode_escape\')\n    elif len(sys.argv) == 3:\n        my_str_o = decode(sys.argv[1], \'unicode_escape\')\n        local_dict = decode(sys.argv[2], \'unicode_escape\')\n        local_dict = eval(local_dict)\n        try:\n            with sympy.evaluate(False):\n                my_str = parse_expr(my_str_o,evaluate=False,local_dict=local_dict)\n                my_str = sympy.latex(my_str)\n        except common_exceptions:\n            with sympy.evaluate(True):\n                my_str = parse_expr(my_str_o,evaluate=True,local_dict=local_dict)\n                my_str = sympy.latex(my_str)\n    else :\n        my_str = \'Error\'\n    sympy.evaluate(True)\n    print(my_str,end="""")'"
AMaDiA_Files/Test_Input.py,0,"b'Test_Input =[""\xe2\x88\xab{(0)(\xcf\x80/2)} \xe2\x88\x9a(sin(x))/(\xe2\x88\x9a(sin(x))+\xe2\x88\x9a(cos(x))) dx"",\n""int {(0)(3)}int {(0)(x)}a^2da+x dx + int {(0)(3)}x^2*dx"",\n""((3)(\xe2\x88\xab d(x\xc2\xb2)/dx+x dx)(2))/6"",\n""d(y(t))/dt=-\xce\xbb\xc2\xb7y(t)"",\n""x\'(t) *x(t)^2 = sin(0.2 + t)"",\n""\xe2\x88\xabx\xc2\xb2 dx - \xe2\x88\xabsin(t+0.2)dt"",\n""\xe2\x88\xab1dy+\xe2\x88\xab7x dx=0"",\n""y\'\'(x) = 0 , y(4)=1 , y\'(1)=2"",\n""d(x(t))/dt = 5x(t)-3 , x(2)=1"",\n""y(x)\xc2\xb7(2x^4+y(x))\xc2\xb7y\'(x)=(1-4\xc2\xb7x\xc2\xb7(y(x))^2)\xc2\xb7x^2"",\n""Sum(1/(k-3),(k,4,8)) = 137/60"",\n""z**6 = 1"",\n""z**3 = -2+2*I"",\n""1 if 4 in [1,2,3,5,6]+[4,8] else 0"",\n""1 if 4 in [1,2,3,4,5,6] and 4 not in [4,8] else 0"",\n""2*2 if 2>3 else 2*3""\n]\n'"
External_Libraries/keyboard_master/make_release.py,0,"b'""""""\nThis little guy streamliens the release process of Python packages.\n\nBy running `python3 make_release.py` it\'ll do the following tasks automatically:\n\n- Update README by calling `make_readme.sh` if this file exists.\n- Check PyPI RST long_description syntax.\n- Show the latest version from CHANGES.md and ask for a new version number.\n- Open vim to allow you to edit the list of changes for this new version, showing a list of commits since the last version.\n- Prepend your list of changes to CHANGES.md (and ask if you want to commit it now).\n- Add a git tag to the current commit.\n- Push tag to GitHub.\n- Publish a new release to GitHub, asking for the authentication token (optional).\n- Publish a new release on PyPI.\n\nSuggested way to organize your project for a smooth process:\n\n- Use Markdown everywhere.\n- Keep a description of your project in the package\'s docstring.\n- Generate your README from the package docstring plus API docs.\n- Convert your package docstring to RST in setup.py and use that as long_description.\n- Use raw semantic versioning for CHANGES.md and PyPI (e.g. 2.3.1), and prepend \'v\' for git tags and releases (e.g. v2.3.1).\n\n""""""\nimport re\nimport sys\nimport os\nfrom subprocess import run, check_output\nimport atexit\nimport requests\nimport keyboard\n\nrun([\'make\', \'clean\', \'build\'], check=True)\n\nassert re.fullmatch(r\'\\d+\\.\\d+\\.\\d+\', keyboard.version)\nlast_version = check_output([\'git\', \'describe\', \'--abbrev=0\'], universal_newlines=True).strip(\'v\\n\')\nassert keyboard.version != last_version, \'Must update keyboard.version first.\'\n\ncommits = check_output([\'git\', \'log\', \'v{}..HEAD\'.format(last_version), \'--oneline\'], universal_newlines=True)\nwith open(\'message.txt\', \'w\') as message_file:\n    atexit.register(lambda: os.remove(\'message.txt\'))\n\n    message_file.write(\'\\n\\n\\n\')\n    message_file.write(\'# Enter changes one per line like this:\\n\')\n    message_file.write(\'# - Added `foobar`.\\n\\n\\n\')\n    message_file.write(\'# As a reminder, here\\\'s the last commits since version {}:\\n\\n\'.format(last_version))\n    for line in commits.strip().split(\'\\n\'):\n        message_file.write(\'# {}\\n\'.format(line))\n\nrun([\'vim\', \'message.txt\'])\nwith open(\'message.txt\') as message_file:\n    lines = [line for line in message_file.readlines() if not line.startswith(\'#\')]\nmessage = \'\'.join(lines).strip()\nif not message:\n    print(\'Aborting release due to empty message.\')\n    exit()\nwith open(\'message.txt\', \'w\') as message_file:\n    message_file.write(message)\n\nwith open(\'CHANGES.md\') as changes_file:\n    old_changes = changes_file.read()\nwith open(\'CHANGES.md\', \'w\') as changes_file:\n    changes_file.write(\'# {}\\n\\n{}\\n\\n\\n{}\'.format(keyboard.version, message, old_changes))\n\n\ntag_name = \'v\' + keyboard.version\nif input(\'Commit README.md and CHANGES.md files? \').lower().startswith(\'y\'):\n    run([\'git\', \'add\', \'CHANGES.md\', \'README.md\'])\n    run([\'git\', \'commit\', \'-m\', \'Update changes for {}\'.format(tag_name)])\n    run([\'git\', \'push\'])\nrun([\'git\', \'tag\', \'-a\', tag_name, \'--file\', \'message.txt\'], check=True)\nrun([\'git\', \'push\', \'origin\', tag_name], check=True)\n\ntoken = input(\'To make a release enter your GitHub repo authorization token: \').strip()\nif token:\n    git_remotes = check_output([\'git\', \'remote\', \'-v\']).decode(\'utf-8\')\n    repo_path = re.search(r\'github.com[:/](.+?)(?:\\.git)? \\(push\\)\', git_remotes).group(1)\n    releases_url = \'https://api.github.com/repos/{}/releases\'.format(repo_path)\n    print(releases_url)\n    release = {\n        ""tag_name"": tag_name,\n        ""target_commitish"": ""master"",\n        ""name"": tag_name,\n        ""body"": message,\n        ""draft"": False,\n        ""prerelease"": False,\n    }\n    response = requests.post(releases_url, json=release, headers={\'Authorization\': \'token \' + token})\n    print(response.status_code, response.text)\n\nrun([\'twine\', \'upload\', \'dist/*\'], check=True, shell=True)\n'"
External_Libraries/keyboard_master/setup.py,0,"b'""""""\nUsage instructions:\n\n- If you are installing: `python setup.py install`\n- If you are developing: `python setup.py sdist --format=zip bdist_wheel --universal bdist_wininst && twine check dist/*`\n""""""\nimport keyboard\n\nfrom setuptools import setup\nsetup(\n    name=\'keyboard\',\n    version=keyboard.version,\n    author=\'BoppreH\',\n    author_email=\'boppreh@gmail.com\',\n    packages=[\'keyboard\'],\n    package_data={\'keyboard\': [\'*.md\']},\n    url=\'https://github.com/boppreh/keyboard\',\n    license=\'MIT\',\n    description=\'Hook and simulate keyboard events on Windows and Linux\',\n    keywords = \'keyboard hook simulate hotkey\',\n\n    # Wheel creation breaks with Windows newlines.\n    # https://github.com/pypa/setuptools/issues/1126\n    long_description=keyboard.__doc__.replace(\'\\r\\n\', \'\\n\'),\n    long_description_content_type=\'text/markdown\',\n\n    install_requires=[""pyobjc; sys_platform==\'darwin\'""], # OSX-specific dependency\n    classifiers=[\n        \'Development Status :: 4 - Beta\',\n        \'License :: OSI Approved :: MIT License\',\n        \'Operating System :: Microsoft :: Windows\',\n        \'Operating System :: Unix\',\n        \'Operating System :: MacOS :: MacOS X\',\n        \'Programming Language :: Python :: 2\',\n        \'Programming Language :: Python :: 3\',\n        \'Topic :: Software Development :: Libraries :: Python Modules\',\n        \'Topic :: Utilities\',\n    ],\n)\n'"
External_Libraries/python_control_master/make_version.py,0,"b'# make_version.py - generate version information\n#\n# Author: Clancy Rowley\n# Date: 2 Apr 2015\n# Modified: Richard M. Murray, 28 Dec 2017\n#\n# This script is used to create the version information for the python-\n# control package.  The version information is now generated directly from\n# tags in the git repository.  Now, *before* running setup.py, one runs\n#\n#   python make_version.py\n#\n# and this generates a file with the version information.  This is copied\n# from binstar (https://github.com/Binstar/binstar) and seems to work well.\n#\n# The original version of this script also created version information for\n# conda, but this stopped working when conda v3 was released.  Instead, we\n# now use jinja templates in conda-recipe to create the conda information.\n# The current version information is used in setup.py, control/__init__.py,\n# and doc/conf.py (for sphinx).\n\nfrom subprocess import check_output\nimport os\n\ndef main():\n    cmd = \'git describe --always --long\'\n    # describe --long usually outputs ""tag-numberofcommits-commitname""\n    output = check_output(cmd.split()).decode(\'utf-8\').strip().rsplit(\'-\',2)\n    if len(output) == 3:\n        version, build, commit = output\n    else:\n        # If the clone is shallow, describe\'s output won\'t have tag and\n        # number of commits.  This is a particular issue on Travis-CI,\n        # which by default clones with a depth of 50.\n        # This behaviour isn\'t well documented in git-describe docs,\n        # but see, e.g., https://stackoverflow.com/a/36389573/1008142\n        # and https://github.com/travis-ci/travis-ci/issues/3412\n        version = \'unknown\'\n        build = \'unknown\'\n        # we don\'t ever expect just one dash from describe --long, but\n        # just in case:\n        commit = \'-\'.join(output)\n\n    print(""Version: %s"" % version)\n    print(""Build: %s"" % build)\n    print(""Commit: %s\\n"" % commit)\n\n    filename = ""control/_version.py""\n    print(""Writing %s"" % filename)\n    with open(filename, \'w\') as fd:\n        if build == \'0\':\n            fd.write(\'__version__ = ""%s""\\n\' % (version))\n        else:\n            fd.write(\'__version__ = ""%s.post%s""\\n\' % (version, build))\n        fd.write(\'__commit__ = ""%s""\\n\' % (commit))\n\nif __name__ == \'__main__\':\n    main()\n'"
External_Libraries/python_control_master/runtests.py,0,"b'#!/usr/bin/env python\n""""""\nruntests.py [OPTIONS] [-- ARGS]\n\nRun tests, building the project first.\n\nExamples::\n\n    $ python runtests.py\n    $ python runtests.py -s {SAMPLE_SUBMODULE}\n    $ python runtests.py -t {SAMPLE_TEST}\n    $ python runtests.py --ipython\n    $ python runtests.py --python somescript.py\n\nRun a debugger:\n\n    $ gdb --args python runtests.py [...other args...]\n\nGenerate C code coverage listing under build/lcov/:\n(requires http://ltp.sourceforge.net/coverage/lcov.php)\n\n    $ python runtests.py --gcov [...other args...]\n    $ python runtests.py --lcov-html\n\n""""""\n\n#\n# This is a generic test runner script for projects using Numpy\'s test\n# framework. Change the following values to adapt to your project:\n#\n\nPROJECT_MODULE = ""control""\nPROJECT_ROOT_FILES = [\'control\', \'setup.py\']\nSAMPLE_TEST = """"\nSAMPLE_SUBMODULE = """"\n\nEXTRA_PATH = [\'/usr/lib/ccache\', \'/usr/lib/f90cache\',\n              \'/usr/local/lib/ccache\', \'/usr/local/lib/f90cache\']\n\n# ---------------------------------------------------------------------\n\n\nif __doc__ is None:\n    __doc__ = ""Run without -OO if you want usage info""\nelse:\n    __doc__ = __doc__.format(**globals())\n\n\nimport sys\nimport os\nimport traceback\nimport warnings\n\n#warnings.simplefilter(""ignore"", DeprecationWarning)\n\ndef warn_with_traceback(message, category, filename, lineno, file=None, line=None):\n    traceback.print_stack()\n    log = file if hasattr(file, \'write\') else sys.stderr\n    log.write(warnings.formatwarning(message, category, filename, lineno, line))\n\nwarnings.showwarnings = warn_with_traceback\n\n# In case we are run from the source directory, we don\'t want to import the\n# project from there:\nsys.path.pop(0)\n\nimport shutil\nimport subprocess\nimport time\nimport imp\nfrom argparse import ArgumentParser, REMAINDER\n\nROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__)))\n\ndef main(argv):\n    parser = ArgumentParser(usage=__doc__.lstrip())\n    parser.add_argument(""--verbose"", ""-v"", action=""count"", default=1,\n                        help=""more verbosity"")\n    parser.add_argument(""--no-build"", ""-n"", action=""store_true"", default=False,\n                        help=""do not build the project (use system installed version)"")\n    parser.add_argument(""--build-only"", ""-b"", action=""store_true"", default=False,\n                        help=""just build, do not run any tests"")\n    parser.add_argument(""--doctests"", action=""store_true"", default=False,\n                        help=""Run doctests in module"")\n    parser.add_argument(""--coverage_html"", action=""store_true"", default=False,\n                        help=(""report coverage of project code. HTML output goes ""\n                              ""under build/coverage""))\n    parser.add_argument(""--coverage"", action=""store_true"", default=False,\n                        help=(""report coverage of project code.""))\n    parser.add_argument(""--gcov"", action=""store_true"", default=False,\n                        help=(""enable C code coverage via gcov (requires GCC). ""\n                              ""gcov output goes to build/**/*.gc*""))\n    parser.add_argument(""--lcov-html"", action=""store_true"", default=False,\n                        help=(""produce HTML for C code coverage information ""\n                              ""from a previous run with --gcov. ""\n                              ""HTML output goes to build/lcov/""))\n    parser.add_argument(""--mode"", ""-m"", default=""fast"",\n                        help=""\'fast\', \'full\', or something that could be ""\n                             ""passed to nosetests -A [default: fast]"")\n    parser.add_argument(""--submodule"", ""-s"", default=None,\n                        help=""Submodule whose tests to run (cluster, constants, ...)"")\n    parser.add_argument(""--pythonpath"", ""-p"", default=None,\n                        help=""Paths to prepend to PYTHONPATH"")\n    parser.add_argument(""--tests"", ""-t"", action=\'append\',\n                        help=""Specify tests to run"")\n    parser.add_argument(""--python"", action=""store_true"",\n                        help=""Start a Python shell with PYTHONPATH set"")\n    parser.add_argument(""--ipython"", ""-i"", action=""store_true"",\n                        help=""Start IPython shell with PYTHONPATH set"")\n    parser.add_argument(""--shell"", action=""store_true"",\n                        help=""Start Unix shell with PYTHONPATH set"")\n    parser.add_argument(""--debug"", ""-g"", action=""store_true"",\n                        help=""Debug build"")\n    parser.add_argument(""--show-build-log"", action=""store_true"",\n                        help=""Show build output rather than using a log file"")\n    parser.add_argument(""args"", metavar=""ARGS"", default=[], nargs=REMAINDER,\n                        help=""Arguments to pass to Nose, Python or shell"")\n    args = parser.parse_args(argv)\n\n    if args.lcov_html:\n        # generate C code coverage output\n        lcov_generate()\n        sys.exit(0)\n\n    if args.pythonpath:\n        for p in reversed(args.pythonpath.split(os.pathsep)):\n            sys.path.insert(0, p)\n\n    if args.gcov:\n        gcov_reset_counters()\n\n    if not args.no_build:\n        site_dir = build_project(args)\n        sys.path.insert(0, site_dir)\n        os.environ[\'PYTHONPATH\'] = site_dir\n\n    extra_argv = args.args[:]\n    if extra_argv and extra_argv[0] == \'--\':\n        extra_argv = extra_argv[1:]\n\n    if args.python:\n        if extra_argv:\n            # Don\'t use subprocess, since we don\'t want to include the\n            # current path in PYTHONPATH.\n            sys.argv = extra_argv\n            with open(extra_argv[0], \'r\') as f:\n                script = f.read()\n            sys.modules[\'__main__\'] = imp.new_module(\'__main__\')\n            ns = dict(__name__=\'__main__\',\n                      __file__=extra_argv[0])\n            exec_(script, ns)\n            sys.exit(0)\n        else:\n            import code\n            code.interact()\n            sys.exit(0)\n\n    if args.ipython:\n        import IPython\n        IPython.embed(user_ns={})\n        sys.exit(0)\n\n    if args.shell:\n        shell = os.environ.get(\'SHELL\', \'sh\')\n        print(""Spawning a Unix shell..."")\n        os.execv(shell, [shell] + extra_argv)\n        sys.exit(1)\n\n    if args.coverage_html:\n        dst_dir = os.path.join(ROOT_DIR, \'build\', \'coverage\')\n        fn = os.path.join(dst_dir, \'coverage_html.js\')\n        if os.path.isdir(dst_dir) and os.path.isfile(fn):\n            shutil.rmtree(dst_dir)\n        extra_argv += [\'--cover-html\',\n                       \'--cover-html-dir=\'+dst_dir]\n\n    if args.coverage:\n        extra_argv += [\'--cover-erase\', \'--with-coverage\',\n                       \'--cover-package=control\']\n\n    test_dir = os.path.join(ROOT_DIR, \'build\', \'test\')\n\n    if args.build_only:\n        sys.exit(0)\n    elif args.submodule:\n        modname = PROJECT_MODULE + \'.\' + args.submodule\n        try:\n            __import__(modname)\n            test = sys.modules[modname].test\n        except (ImportError, KeyError, AttributeError):\n            print(""Cannot run tests for %s"" % modname)\n            sys.exit(2)\n    elif args.tests:\n        def fix_test_path(x):\n            # fix up test path\n            p = x.split(\':\')\n            p[0] = os.path.relpath(os.path.abspath(p[0]),\n                                   test_dir)\n            return \':\'.join(p)\n\n        tests = [fix_test_path(x) for x in args.tests]\n\n        def test(*a, **kw):\n            extra_argv = kw.pop(\'extra_argv\', ())\n            extra_argv = extra_argv + tests[1:]\n            kw[\'extra_argv\'] = extra_argv\n            from numpy.testing import Tester\n            return Tester(tests[0]).test(*a, **kw)\n    else:\n        __import__(PROJECT_MODULE)\n        test = sys.modules[PROJECT_MODULE].test\n\n    # Run the tests under build/test\n    try:\n        shutil.rmtree(test_dir)\n    except OSError:\n        pass\n    try:\n        os.makedirs(test_dir)\n    except OSError:\n        pass\n\n    cwd = os.getcwd()\n    try:\n        os.chdir(test_dir)\n        result = test(args.mode,\n                      verbose=args.verbose,\n                      extra_argv=extra_argv,\n                      doctests=args.doctests,\n                      coverage=args.coverage)\n    finally:\n        os.chdir(cwd)\n\n    if result.wasSuccessful():\n        sys.exit(0)\n    else:\n        sys.exit(1)\n\n\ndef build_project(args):\n    """"""\n    Build a dev version of the project.\n\n    Returns\n    -------\n    site_dir\n        site-packages directory where it was installed\n\n    """"""\n\n    root_ok = [os.path.exists(os.path.join(ROOT_DIR, fn))\n               for fn in PROJECT_ROOT_FILES]\n    if not all(root_ok):\n        print(""To build the project, run runtests.py in ""\n              ""git checkout or unpacked source"")\n        sys.exit(1)\n\n    dst_dir = os.path.join(ROOT_DIR, \'build\', \'testenv\')\n\n    env = dict(os.environ)\n    cmd = [sys.executable, \'setup.py\']\n\n    # Always use ccache, if installed\n    env[\'PATH\'] = os.pathsep.join(EXTRA_PATH + env.get(\'PATH\', \'\').split(os.pathsep))\n\n    if args.debug or args.gcov:\n        # assume everyone uses gcc/gfortran\n        env[\'OPT\'] = \'-O0 -ggdb\'\n        env[\'FOPT\'] = \'-O0 -ggdb\'\n        if args.gcov:\n            import distutils.sysconfig\n            cvars = distutils.sysconfig.get_config_vars()\n            env[\'OPT\'] = \'-O0 -ggdb\'\n            env[\'FOPT\'] = \'-O0 -ggdb\'\n            env[\'CC\'] = cvars[\'CC\'] + \' --coverage\'\n            env[\'CXX\'] = cvars[\'CXX\'] + \' --coverage\'\n            env[\'F77\'] = \'gfortran --coverage \'\n            env[\'F90\'] = \'gfortran --coverage \'\n            env[\'LDSHARED\'] = cvars[\'LDSHARED\'] + \' --coverage\'\n            env[\'LDFLAGS\'] = "" "".join(cvars[\'LDSHARED\'].split()[1:]) + \' --coverage\'\n        cmd += [""build""]\n\n    cmd += [\'install\', \'--prefix=\' + dst_dir]\n\n    log_filename = os.path.join(ROOT_DIR, \'build.log\')\n\n    if args.show_build_log:\n        ret = subprocess.call(cmd, env=env, cwd=ROOT_DIR)\n    else:\n        log_filename = os.path.join(ROOT_DIR, \'build.log\')\n        print(""Building, see build.log..."")\n        with open(log_filename, \'w\') as log:\n            p = subprocess.Popen(cmd, env=env, stdout=log, stderr=log,\n                                 cwd=ROOT_DIR)\n\n        # Wait for it to finish, and print something to indicate the\n        # process is alive, but only if the log file has grown (to\n        # allow continuous integration environments kill a hanging\n        # process accurately if it produces no output)\n        last_blip = time.time()\n        last_log_size = os.stat(log_filename).st_size\n        while p.poll() is None:\n            time.sleep(0.5)\n            if time.time() - last_blip > 60:\n                log_size = os.stat(log_filename).st_size\n                if log_size > last_log_size:\n                    print(""    ... build in progress"")\n                    last_blip = time.time()\n                    last_log_size = log_size\n\n        ret = p.wait()\n\n    if ret == 0:\n        print(""Build OK"")\n    else:\n        if not args.show_build_log:\n            with open(log_filename, \'r\') as f:\n                print(f.read())\n            print(""Build failed!"")\n        sys.exit(1)\n\n    from distutils.sysconfig import get_python_lib\n    site_dir = get_python_lib(prefix=dst_dir, plat_specific=True)\n\n    return site_dir\n\n\n#\n# GCOV support\n#\ndef gcov_reset_counters():\n    print(""Removing previous GCOV .gcda files..."")\n    build_dir = os.path.join(ROOT_DIR, \'build\')\n    for dirpath, dirnames, filenames in os.walk(build_dir):\n        for fn in filenames:\n            if fn.endswith(\'.gcda\') or fn.endswith(\'.da\'):\n                pth = os.path.join(dirpath, fn)\n                os.unlink(pth)\n\n#\n# LCOV support\n#\n\nLCOV_OUTPUT_FILE = os.path.join(ROOT_DIR, \'build\', \'lcov.out\')\nLCOV_HTML_DIR = os.path.join(ROOT_DIR, \'build\', \'lcov\')\n\ndef lcov_generate():\n    try: os.unlink(LCOV_OUTPUT_FILE)\n    except OSError: pass\n    try: shutil.rmtree(LCOV_HTML_DIR)\n    except OSError: pass\n\n    print(""Capturing lcov info..."")\n    subprocess.call([\'lcov\', \'-q\', \'-c\',\n                     \'-d\', os.path.join(ROOT_DIR, \'build\'),\n                     \'-b\', ROOT_DIR,\n                     \'--output-file\', LCOV_OUTPUT_FILE])\n\n    print(""Generating lcov HTML output..."")\n    ret = subprocess.call([\'genhtml\', \'-q\', LCOV_OUTPUT_FILE,\n                           \'--output-directory\', LCOV_HTML_DIR,\n                           \'--legend\', \'--highlight\'])\n    if ret != 0:\n        print(""genhtml failed!"")\n    else:\n        print(""HTML output generated under build/lcov/"")\n\n\n#\n# Python 3 support\n#\n\nif sys.version_info[0] >= 3:\n    import builtins\n    exec_ = getattr(builtins, ""exec"")\nelse:\n    def exec_(code, globs=None, locs=None):\n        """"""Execute code in a namespace.""""""\n        if globs is None:\n            frame = sys._getframe(1)\n            globs = frame.f_globals\n            if locs is None:\n                locs = frame.f_locals\n            del frame\n        elif locs is None:\n            locs = globs\n        exec(""""""exec code in globs, locs"""""")\n\nif __name__ == ""__main__"":\n    main(argv=sys.argv[1:])\n'"
External_Libraries/python_control_master/setup.py,0,"b'from setuptools import setup, find_packages\n\nver = {}\ntry:\n    with open(\'control/_version.py\') as fd:\n        exec(fd.read(), ver)\n    version = ver.get(\'__version__\', \'dev\')\nexcept IOError:\n    version = \'dev\'\n\nwith open(\'README.rst\') as fp:\n    long_description = fp.read()\n\nCLASSIFIERS = """"""\nDevelopment Status :: 3 - Alpha\nIntended Audience :: Science/Research\nIntended Audience :: Developers\nLicense :: OSI Approved :: BSD License\nProgramming Language :: Python :: 2\nProgramming Language :: Python :: 2.7\nProgramming Language :: Python :: 3\nProgramming Language :: Python :: 3.5\nProgramming Language :: Python :: 3.6\nTopic :: Software Development\nTopic :: Scientific/Engineering\nOperating System :: Microsoft :: Windows\nOperating System :: POSIX\nOperating System :: Unix\nOperating System :: MacOS\n""""""\n\nsetup(\n    name=\'control\',\n    version=version,\n    author=\'Richard Murray\',\n    author_email=\'murray@cds.caltech.edu\',\n    url=\'http://python-control.sourceforge.net\',\n    description=\'Python control systems library\',\n    long_description=long_description,\n    packages=find_packages(),\n    classifiers=[f for f in CLASSIFIERS.split(\'\\n\') if f],\n    install_requires=[\'numpy\',\n                      \'scipy\',\n                      \'matplotlib\'],\n    tests_require=[\'scipy\',\n                   \'matplotlib\',\n                   \'nose\'],\n    test_suite = \'nose.collector\',\n)\n'"
External_Libraries/keyboard_master/examples/10_second_macro.py,0,b'import keyboard\nimport time\n\nkeyboard.start_recording()\ntime.sleep(10)\nevents = keyboard.stop_recording()\nkeyboard.replay(events)\n'
External_Libraries/keyboard_master/examples/customizable_hotkey.py,0,"b'import keyboard\n\nprint(\'Press and release your desired shortcut: \')\nshortcut = keyboard.read_hotkey()\nprint(\'Shortcut selected:\', shortcut)\n\ndef on_triggered():\n\tprint(""Triggered!"")\nkeyboard.add_hotkey(shortcut, on_triggered)\n\nprint(""Press ESC to stop."")\nkeyboard.wait(\'esc\')\n'"
External_Libraries/keyboard_master/examples/pressed_keys.py,0,"b'""""""\nPrints the scan code of all currently pressed keys.\nUpdates on every keyboard event.\n""""""\nimport sys\nsys.path.append(\'..\')\nimport keyboard\n\ndef print_pressed_keys(e):\n\tline = \', \'.join(str(code) for code in keyboard._pressed_events)\n\t# \'\\r\' and end=\'\' overwrites the previous line.\n\t# \' \'*40 prints 40 spaces at the end to ensure the previous line is cleared.\n\tprint(\'\\r\' + line + \' \'*40, end=\'\')\n\t\nkeyboard.hook(print_pressed_keys)\nkeyboard.wait()'"
External_Libraries/keyboard_master/examples/push_to_talk_ubuntu.py,0,"b'#quick and dirty push-to-talk example for Ubuntu 16.04, by Abd Azrad \n\nimport keyboard\nimport subprocess\n\nis_muted = False\n\ndef unmute():\n\tglobal is_muted\n\tif not is_muted: # if mic is already enabled\n\t\treturn # do nothing\n\tis_muted = False\n\tsubprocess.call(\'amixer set Capture cap\', shell=True) # unmute mic\n\ndef mute():\n\tglobal is_muted\n\tis_muted = True\n\tsubprocess.call(\'amixer set Capture nocap\', shell=True) # mute mic\n\nif __name__ == ""__main__"":\n\tis_muted = True\n\tmute() # mute on startup\n\n\tkeyboard.add_hotkey(\'win\', unmute) # unmute on keydown\n\tkeyboard.add_hotkey(\'win\', mute, trigger_on_release=True) # mute on keyup\n\n\tkeyboard.wait() # wait forever'"
External_Libraries/keyboard_master/examples/segmented_macro.py,0,"b'""""""\nThis script allows you to record keyboard events in segments, then replay them\nback with pauses between the segments.\n\nIt\'s useful for presentations, to ensure typing accuracy while still giving you\ntime to speak between segments.\n""""""\nimport sys\nsys.path.append(\'../\')\nimport keyboard\nimport pickle\nimport os\n\nif len(sys.argv) == 1:\n    filename = input(\'Enter filename to save/load events: \')\nelse:\n    filename = sys.argv[1]\n\nif os.path.exists(filename):\n    segments = pickle.load(open(filename, \'rb\'))\n    for i, segment in enumerate(segments):\n        print(\'Press F1 to play segment {}/{}\'.format(i+1, len(segments)))\n        print(\'Duration: {:.02} seconds\'.format(segment[-1].time - segment[0].time))\n        keyboard.wait(\'F1\')\n        keyboard.play(segment)\n\nelse:\n    print(\'Press F1 to save this fragment. Press F2 to discard it. Press F3 to stop recording.\')\n\n    segments = []\n    segment = []\n\n    def handle_event(event):\n        global segment\n\n        if keyboard.matches(event, \'F1\'):\n            if event.event_type == keyboard.KEY_DOWN:\n                if segment:\n                    segments.append(segment)\n                segment = []\n                print(\'Saved\', len(segments))\n        elif keyboard.matches(event, \'F2\'):\n            if event.event_type == keyboard.KEY_DOWN:\n                segment = []\n                print(\'Discarded\')\n        else:\n            segment.append(event)\n\n    keyboard.hook(handle_event)\n    keyboard.wait(\'F3\')\n    keyboard.hook(handle_event)\n\n    pickle.dump(segments, open(filename, \'wb\'))\n    print(\'Saved {} segments to {}\'.format(len(segments), filename))'"
External_Libraries/keyboard_master/examples/simulate_held_down.py,0,"b'import keyboard\nimport time\n\n# Sends 20 ""key down"" events in 0.1 second intervals, followed by a single\n# ""key up"" event.\nfor i in range(20):\n    keyboard.press(\'a\')\n    time.sleep(0.1)\nkeyboard.release(\'a\')\n'"
External_Libraries/keyboard_master/examples/stdin_stdout_events.py,0,"b'""""""\nPrints lines with JSON object for each keyboard event, and reads similar events\nfrom stdin to simulate events. Example:\n\n\t{""event_type"": ""down"", ""name"": ""a"", ""scan_code"": 30, ""time"": 1491442622.6348252}\n\t{""event_type"": ""down"", ""name"": ""s"", ""scan_code"": 31, ""time"": 1491442622.664881}\n\t{""event_type"": ""down"", ""name"": ""d"", ""scan_code"": 32, ""time"": 1491442622.7148278}\n\t{""event_type"": ""down"", ""name"": ""f"", ""scan_code"": 33, ""time"": 1491442622.7544951}\n\t{""event_type"": ""up"", ""name"": ""a"", ""scan_code"": 30, ""time"": 1491442622.7748237}\n\t{""event_type"": ""up"", ""name"": ""s"", ""scan_code"": 31, ""time"": 1491442622.825077}\n\t{""event_type"": ""up"", ""name"": ""d"", ""scan_code"": 32, ""time"": 1491442622.8644736}\n\t{""event_type"": ""up"", ""name"": ""f"", ""scan_code"": 33, ""time"": 1491442622.9056144}\n""""""\nimport sys\nsys.path.append(\'..\')\n\n# Also available as just `python -m keyboard`.\nfrom keyboard import __main__'"
External_Libraries/keyboard_master/examples/write.py,0,"b'""""""\nGiven text files or text from stdin, simulates keyboard events that type the\ntext character-by-character.\n""""""\nimport sys\nsys.path.append(\'../\')\nimport keyboard\nimport fileinput\n\nfor line in fileinput.input():\n\tkeyboard.write(line)'"
External_Libraries/keyboard_master/keyboard/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nkeyboard\n========\n\nTake full control of your keyboard with this small Python library. Hook global events, register hotkeys, simulate key presses and much more.\n\n## Features\n\n- **Global event hook** on all keyboards (captures keys regardless of focus).\n- **Listen** and **send** keyboard events.\n- Works with **Windows** and **Linux** (requires sudo), with experimental **OS X** support (thanks @glitchassassin!).\n- **Pure Python**, no C modules to be compiled.\n- **Zero dependencies**. Trivial to install and deploy, just copy the files.\n- **Python 2 and 3**.\n- Complex hotkey support (e.g. `ctrl+shift+m, ctrl+space`) with controllable timeout.\n- Includes **high level API** (e.g. [record](#keyboard.record) and [play](#keyboard.play), [add_abbreviation](#keyboard.add_abbreviation)).\n- Maps keys as they actually are in your layout, with **full internationalization support** (e.g. `Ctrl+\xc3\xa7`).\n- Events automatically captured in separate thread, doesn\'t block main program.\n- Tested and documented.\n- Doesn\'t break accented dead keys (I\'m looking at you, pyHook).\n- Mouse support available via project [mouse](https://github.com/boppreh/mouse) (`pip install mouse`).\n\n## Usage\n\nInstall the [PyPI package](https://pypi.python.org/pypi/keyboard/):\n\n    pip install keyboard\n\nor clone the repository (no installation required, source files are sufficient):\n\n    git clone https://github.com/boppreh/keyboard\n\nor [download and extract the zip](https://github.com/boppreh/keyboard/archive/master.zip) into your project folder.\n\nThen check the [API docs below](https://github.com/boppreh/keyboard#api) to see what features are available.\n\n\n## Example\n\n\n```py\nimport keyboard\n\nkeyboard.press_and_release(\'shift+s, space\')\n\nkeyboard.write(\'The quick brown fox jumps over the lazy dog.\')\n\nkeyboard.add_hotkey(\'ctrl+shift+a\', print, args=(\'triggered\', \'hotkey\'))\n\n# Press PAGE UP then PAGE DOWN to type ""foobar"".\nkeyboard.add_hotkey(\'page up, page down\', lambda: keyboard.write(\'foobar\'))\n\n# Blocks until you press esc.\nkeyboard.wait(\'esc\')\n\n# Record events until \'esc\' is pressed.\nrecorded = keyboard.record(until=\'esc\')\n# Then replay back at three times the speed.\nkeyboard.play(recorded, speed_factor=3)\n\n# Type @@ then press space to replace with abbreviation.\nkeyboard.add_abbreviation(\'@@\', \'my.long.email@example.com\')\n\n# Block forever, like `while True`.\nkeyboard.wait()\n```\n\n## Known limitations:\n\n- Events generated under Windows don\'t report device id (`event.device == None`). [#21](https://github.com/boppreh/keyboard/issues/21)\n- Media keys on Linux may appear nameless (scan-code only) or not at all. [#20](https://github.com/boppreh/keyboard/issues/20)\n- Key suppression/blocking only available on Windows. [#22](https://github.com/boppreh/keyboard/issues/22)\n- To avoid depending on X, the Linux parts reads raw device files (`/dev/input/input*`)\nbut this requires root.\n- Other applications, such as some games, may register hooks that swallow all \nkey events. In this case `keyboard` will be unable to report events.\n- This program makes no attempt to hide itself, so don\'t use it for keyloggers or online gaming bots. Be responsible.\n""""""\nfrom __future__ import print_function as _print_function\n\nversion = \'0.13.4\'\n\nimport re as _re\nimport itertools as _itertools\nimport collections as _collections\nfrom threading import Thread as _Thread, Lock as _Lock\nimport time as _time\n# Python2... Buggy on time changes and leap seconds, but no other good option (https://stackoverflow.com/questions/1205722/how-do-i-get-monotonic-time-durations-in-python).\n_time.monotonic = getattr(_time, \'monotonic\', None) or _time.time\n\ntry:\n    # Python2\n    long, basestring\n    _is_str = lambda x: isinstance(x, basestring)\n    _is_number = lambda x: isinstance(x, (int, long))\n    import Queue as _queue\n    # threading.Event is a function in Python2 wrappin _Event (?!).\n    from threading import _Event as _UninterruptibleEvent\nexcept NameError:\n    # Python3\n    _is_str = lambda x: isinstance(x, str)\n    _is_number = lambda x: isinstance(x, int)\n    import queue as _queue\n    from threading import Event as _UninterruptibleEvent\n_is_list = lambda x: isinstance(x, (list, tuple))\n\n# Just a dynamic object to store attributes for the closures.\nclass _State(object): pass\n\n# The ""Event"" class from `threading` ignores signals when waiting and is\n# impossible to interrupt with Ctrl+C. So we rewrite `wait` to wait in small,\n# interruptible intervals.\nclass _Event(_UninterruptibleEvent):\n    def wait(self):\n        while True:\n            if _UninterruptibleEvent.wait(self, 0.5):\n                break\n\nimport platform as _platform\nif _platform.system() == \'Windows\':\n    from. import _winkeyboard as _os_keyboard\nelif _platform.system() == \'Linux\':\n    from. import _nixkeyboard as _os_keyboard\nelif _platform.system() == \'Darwin\':\n    from. import _darwinkeyboard as _os_keyboard\nelse:\n    raise OSError(""Unsupported platform \'{}\'"".format(_platform.system()))\n\nfrom ._keyboard_event import KEY_DOWN, KEY_UP, KeyboardEvent\nfrom ._generic import GenericListener as _GenericListener\nfrom ._canonical_names import all_modifiers, sided_modifiers, normalize_name\n\n_modifier_scan_codes = set()\ndef is_modifier(key):\n    """"""\n    Returns True if `key` is a scan code or name of a modifier key.\n    """"""\n    if _is_str(key):\n        return key in all_modifiers\n    else:\n        if not _modifier_scan_codes:\n            scan_codes = (key_to_scan_codes(name, False) for name in all_modifiers) \n            _modifier_scan_codes.update(*scan_codes)\n        return key in _modifier_scan_codes\n\n_pressed_events_lock = _Lock()\n_pressed_events = {}\n_physically_pressed_keys = _pressed_events\n_logically_pressed_keys = {}\nclass _KeyboardListener(_GenericListener):\n    transition_table = {\n        #Current state of the modifier, per `modifier_states`.\n        #|\n        #|             Type of event that triggered this modifier update.\n        #|             |\n        #|             |         Type of key that triggered this modiier update.\n        #|             |         |\n        #|             |         |            Should we send a fake key press?\n        #|             |         |            |\n        #|             |         |     =>     |       Accept the event?\n        #|             |         |            |       |\n        #|             |         |            |       |      Next state.\n        #v             v         v            v       v      v\n        (\'free\',       KEY_UP,   \'modifier\'): (False, True,  \'free\'),\n        (\'free\',       KEY_DOWN, \'modifier\'): (False, False, \'pending\'),\n        (\'pending\',    KEY_UP,   \'modifier\'): (True,  True,  \'free\'),\n        (\'pending\',    KEY_DOWN, \'modifier\'): (False, True,  \'allowed\'),\n        (\'suppressed\', KEY_UP,   \'modifier\'): (False, False, \'free\'),\n        (\'suppressed\', KEY_DOWN, \'modifier\'): (False, False, \'suppressed\'),\n        (\'allowed\',    KEY_UP,   \'modifier\'): (False, True,  \'free\'),\n        (\'allowed\',    KEY_DOWN, \'modifier\'): (False, True,  \'allowed\'),\n\n        (\'free\',       KEY_UP,   \'hotkey\'):   (False, None,  \'free\'),\n        (\'free\',       KEY_DOWN, \'hotkey\'):   (False, None,  \'free\'),\n        (\'pending\',    KEY_UP,   \'hotkey\'):   (False, None,  \'suppressed\'),\n        (\'pending\',    KEY_DOWN, \'hotkey\'):   (False, None,  \'suppressed\'),\n        (\'suppressed\', KEY_UP,   \'hotkey\'):   (False, None,  \'suppressed\'),\n        (\'suppressed\', KEY_DOWN, \'hotkey\'):   (False, None,  \'suppressed\'),\n        (\'allowed\',    KEY_UP,   \'hotkey\'):   (False, None,  \'allowed\'),\n        (\'allowed\',    KEY_DOWN, \'hotkey\'):   (False, None,  \'allowed\'),\n\n        (\'free\',       KEY_UP,   \'other\'):    (False, True,  \'free\'),\n        (\'free\',       KEY_DOWN, \'other\'):    (False, True,  \'free\'),\n        (\'pending\',    KEY_UP,   \'other\'):    (True,  True,  \'allowed\'),\n        (\'pending\',    KEY_DOWN, \'other\'):    (True,  True,  \'allowed\'),\n        # Necessary when hotkeys are removed after beign triggered, such as\n        # TestKeyboard.test_add_hotkey_multistep_suppress_modifier.\n        (\'suppressed\', KEY_UP,   \'other\'):    (False, False, \'allowed\'),\n        (\'suppressed\', KEY_DOWN, \'other\'):    (True,  True,  \'allowed\'),\n        (\'allowed\',    KEY_UP,   \'other\'):    (False, True,  \'allowed\'),\n        (\'allowed\',    KEY_DOWN, \'other\'):    (False, True,  \'allowed\'),\n    }\n\n    def init(self):\n        _os_keyboard.init()\n\n        self.active_modifiers = set()\n        self.blocking_hooks = []\n        self.blocking_keys = _collections.defaultdict(list)\n        self.nonblocking_keys = _collections.defaultdict(list)\n        self.blocking_hotkeys = _collections.defaultdict(list)\n        self.nonblocking_hotkeys = _collections.defaultdict(list)\n        self.filtered_modifiers = _collections.Counter()\n        self.is_replaying = False\n\n        # Supporting hotkey suppression is harder than it looks. See\n        # https://github.com/boppreh/keyboard/issues/22\n        self.modifier_states = {} # ""alt"" -> ""allowed""\n\n    def pre_process_event(self, event):\n        for key_hook in self.nonblocking_keys[event.scan_code]:\n            key_hook(event)\n\n        with _pressed_events_lock:\n            hotkey = tuple(sorted(_pressed_events))\n        for callback in self.nonblocking_hotkeys[hotkey]:\n            callback(event)\n\n        return event.scan_code or (event.name and event.name != \'unknown\')\n\n    def direct_callback(self, event):\n        """"""\n        This function is called for every OS keyboard event and decides if the\n        event should be blocked or not, and passes a copy of the event to\n        other, non-blocking, listeners.\n\n        There are two ways to block events: remapped keys, which translate\n        events by suppressing and re-emitting; and blocked hotkeys, which\n        suppress specific hotkeys.\n        """"""\n        # Pass through all fake key events, don\'t even report to other handlers.\n        if self.is_replaying:\n            return True\n\n        if not all(hook(event) for hook in self.blocking_hooks):\n            return False\n\n        event_type = event.event_type\n        scan_code = event.scan_code\n\n        # Update tables of currently pressed keys and modifiers.\n        with _pressed_events_lock:\n            if event_type == KEY_DOWN:\n                if is_modifier(scan_code): self.active_modifiers.add(scan_code)\n                _pressed_events[scan_code] = event\n            hotkey = tuple(sorted(_pressed_events))\n            if event_type == KEY_UP:\n                self.active_modifiers.discard(scan_code)\n                if scan_code in _pressed_events: del _pressed_events[scan_code]\n\n        # Mappings based on individual keys instead of hotkeys.\n        for key_hook in self.blocking_keys[scan_code]:\n            if not key_hook(event):\n                return False\n\n        # Default accept.\n        accept = True\n\n        if self.blocking_hotkeys:\n            if self.filtered_modifiers[scan_code]:\n                origin = \'modifier\'\n                modifiers_to_update = set([scan_code])\n            else:\n                modifiers_to_update = self.active_modifiers\n                if is_modifier(scan_code):\n                    modifiers_to_update = modifiers_to_update | {scan_code}\n                callback_results = [callback(event) for callback in self.blocking_hotkeys[hotkey]]\n                if callback_results:\n                    accept = all(callback_results)\n                    origin = \'hotkey\'\n                else:\n                    origin = \'other\'\n\n            for key in sorted(modifiers_to_update):\n                transition_tuple = (self.modifier_states.get(key, \'free\'), event_type, origin)\n                should_press, new_accept, new_state = self.transition_table[transition_tuple]\n                if should_press: press(key)\n                if new_accept is not None: accept = new_accept\n                self.modifier_states[key] = new_state\n\n        if accept:\n            if event_type == KEY_DOWN:\n                _logically_pressed_keys[scan_code] = event\n            elif event_type == KEY_UP and scan_code in _logically_pressed_keys:\n                del _logically_pressed_keys[scan_code]\n\n        # Queue for handlers that won\'t block the event.\n        self.queue.put(event)\n\n        return accept\n\n    def listen(self):\n        _os_keyboard.listen(self.direct_callback)\n\n_listener = _KeyboardListener()\n\ndef key_to_scan_codes(key, error_if_missing=True):\n    """"""\n    Returns a list of scan codes associated with this key (name or scan code).\n    """"""\n    if _is_number(key):\n        return (key,)\n    elif _is_list(key):\n        return sum((key_to_scan_codes(i) for i in key), ())\n    elif not _is_str(key):\n        raise ValueError(\'Unexpected key type \' + str(type(key)) + \', value (\' + repr(key) + \')\')\n\n    normalized = normalize_name(key)\n    if normalized in sided_modifiers:\n        left_scan_codes = key_to_scan_codes(\'left \' + normalized, False)\n        right_scan_codes = key_to_scan_codes(\'right \' + normalized, False)\n        return left_scan_codes + tuple(c for c in right_scan_codes if c not in left_scan_codes)\n\n    try:\n        # Put items in ordered dict to remove duplicates.\n        t = tuple(_collections.OrderedDict((scan_code, True) for scan_code, modifier in _os_keyboard.map_name(normalized)))\n        e = None\n    except (KeyError, ValueError) as exception:\n        t = ()\n        e = exception\n\n    if not t and error_if_missing:\n        raise ValueError(\'Key {} is not mapped to any known key.\'.format(repr(key)), e)\n    else:\n        return t\n\ndef parse_hotkey(hotkey):\n    """"""\n    Parses a user-provided hotkey into nested tuples representing the\n    parsed structure, with the bottom values being lists of scan codes.\n    Also accepts raw scan codes, which are then wrapped in the required\n    number of nestings.\n\n    Example:\n\n        parse_hotkey(""alt+shift+a, alt+b, c"")\n        #    Keys:    ^~^ ^~~~^ ^  ^~^ ^  ^\n        #    Steps:   ^~~~~~~~~~^  ^~~~^  ^\n\n        # ((alt_codes, shift_codes, a_codes), (alt_codes, b_codes), (c_codes,))\n    """"""\n    if _is_number(hotkey) or len(hotkey) == 1:\n        scan_codes = key_to_scan_codes(hotkey)\n        step = (scan_codes,)\n        steps = (step,)\n        return steps\n    elif _is_list(hotkey):\n        if not any(map(_is_list, hotkey)):\n            step = tuple(key_to_scan_codes(k) for k in hotkey)\n            steps = (step,)\n            return steps\n        return hotkey\n\n    steps = []\n    for step in _re.split(r\',\\s?\', hotkey):\n        keys = _re.split(r\'\\s?\\+\\s?\', step)\n        steps.append(tuple(key_to_scan_codes(key) for key in keys))\n    return tuple(steps)\n\ndef send(hotkey, do_press=True, do_release=True):\n    """"""\n    Sends OS events that perform the given *hotkey* hotkey.\n\n    - `hotkey` can be either a scan code (e.g. 57 for space), single key\n    (e.g. \'space\') or multi-key, multi-step hotkey (e.g. \'alt+F4, enter\').\n    - `do_press` if true then press events are sent. Defaults to True.\n    - `do_release` if true then release events are sent. Defaults to True.\n\n        send(57)\n        send(\'ctrl+alt+del\')\n        send(\'alt+F4, enter\')\n        send(\'shift+s\')\n\n    Note: keys are released in the opposite order they were pressed.\n    """"""\n    _listener.is_replaying = True\n\n    parsed = parse_hotkey(hotkey)\n    for step in parsed:\n        if do_press:\n            for scan_codes in step:\n                _os_keyboard.press(scan_codes[0])\n\n        if do_release:\n            for scan_codes in reversed(step):\n                _os_keyboard.release(scan_codes[0])\n\n    _listener.is_replaying = False\n\n# Alias.\npress_and_release = send\n\ndef press(hotkey):\n    """""" Presses and holds down a hotkey (see `send`). """"""\n    send(hotkey, True, False)\n\ndef release(hotkey):\n    """""" Releases a hotkey (see `send`). """"""\n    send(hotkey, False, True)\n\ndef is_pressed(hotkey):\n    """"""\n    Returns True if the key is pressed.\n\n        is_pressed(57) #-> True\n        is_pressed(\'space\') #-> True\n        is_pressed(\'ctrl+space\') #-> True\n    """"""\n    _listener.start_if_necessary()\n\n    if _is_number(hotkey):\n        # Shortcut.\n        with _pressed_events_lock:\n            return hotkey in _pressed_events\n\n    steps = parse_hotkey(hotkey)\n    if len(steps) > 1:\n        raise ValueError(""Impossible to check if multi-step hotkeys are pressed (`a+b` is ok, `a, b` isn\'t)."")\n\n    # Convert _pressed_events into a set \n    with _pressed_events_lock:\n        pressed_scan_codes = set(_pressed_events)\n    for scan_codes in steps[0]:\n        if not any(scan_code in pressed_scan_codes for scan_code in scan_codes):\n            return False\n    return True\n\ndef call_later(fn, args=(), delay=0.001):\n    """"""\n    Calls the provided function in a new thread after waiting some time.\n    Useful for giving the system some time to process an event, without blocking\n    the current execution flow.\n    """"""\n    thread = _Thread(target=lambda: (_time.sleep(delay), fn(*args)))\n    thread.start()\n\n_hooks = {}\ndef hook(callback, suppress=False, on_remove=lambda: None):\n    """"""\n    Installs a global listener on all available keyboards, invoking `callback`\n    each time a key is pressed or released.\n    \n    The event passed to the callback is of type `keyboard.KeyboardEvent`,\n    with the following attributes:\n\n    - `name`: an Unicode representation of the character (e.g. ""&"") or\n    description (e.g.  ""space""). The name is always lower-case.\n    - `scan_code`: number representing the physical key, e.g. 55.\n    - `time`: timestamp of the time the event occurred, with as much precision\n    as given by the OS.\n\n    Returns the given callback for easier development.\n    """"""\n    if suppress:\n        _listener.start_if_necessary()\n        append, remove = _listener.blocking_hooks.append, _listener.blocking_hooks.remove\n    else:\n        append, remove = _listener.add_handler, _listener.remove_handler\n\n    append(callback)\n    def remove_():\n        del _hooks[callback]\n        del _hooks[remove_]\n        remove(callback)\n        on_remove()\n    _hooks[callback] = _hooks[remove_] = remove_\n    return remove_\n\ndef on_press(callback, suppress=False):\n    """"""\n    Invokes `callback` for every KEY_DOWN event. For details see `hook`.\n    """"""\n    return hook(lambda e: e.event_type == KEY_UP or callback(e), suppress=suppress)\n\ndef on_release(callback, suppress=False):\n    """"""\n    Invokes `callback` for every KEY_UP event. For details see `hook`.\n    """"""\n    return hook(lambda e: e.event_type == KEY_DOWN or callback(e), suppress=suppress)\n\ndef hook_key(key, callback, suppress=False):\n    """"""\n    Hooks key up and key down events for a single key. Returns the event handler\n    created. To remove a hooked key use `unhook_key(key)` or\n    `unhook_key(handler)`.\n\n    Note: this function shares state with hotkeys, so `clear_all_hotkeys`\n    affects it aswell.\n    """"""\n    _listener.start_if_necessary()\n    store = _listener.blocking_keys if suppress else _listener.nonblocking_keys\n    scan_codes = key_to_scan_codes(key)\n    for scan_code in scan_codes:\n        store[scan_code].append(callback)\n\n    def remove_():\n        del _hooks[callback]\n        del _hooks[key]\n        del _hooks[remove_]\n        for scan_code in scan_codes:\n            store[scan_code].remove(callback)\n    _hooks[callback] = _hooks[key] = _hooks[remove_] = remove_\n    return remove_\n\ndef on_press_key(key, callback, suppress=False):\n    """"""\n    Invokes `callback` for KEY_DOWN event related to the given key. For details see `hook`.\n    """"""\n    return hook_key(key, lambda e: e.event_type == KEY_UP or callback(e), suppress=suppress)\n\ndef on_release_key(key, callback, suppress=False):\n    """"""\n    Invokes `callback` for KEY_UP event related to the given key. For details see `hook`.\n    """"""\n    return hook_key(key, lambda e: e.event_type == KEY_DOWN or callback(e), suppress=suppress)\n\ndef unhook(remove):\n    """"""\n    Removes a previously added hook, either by callback or by the return value\n    of `hook`.\n    """"""\n    _hooks[remove]()\nunhook_key = unhook\n\ndef unhook_all():\n    """"""\n    Removes all keyboard hooks in use, including hotkeys, abbreviations, word\n    listeners, `record`ers and `wait`s.\n    """"""\n    _listener.start_if_necessary()\n    _listener.blocking_keys.clear()\n    _listener.nonblocking_keys.clear()\n    del _listener.blocking_hooks[:]\n    del _listener.handlers[:]\n    unhook_all_hotkeys()\n\ndef block_key(key):\n    """"""\n    Suppresses all key events of the given key, regardless of modifiers.\n    """"""\n    return hook_key(key, lambda e: False, suppress=True)\nunblock_key = unhook_key\n\ndef remap_key(src, dst):\n    """"""\n    Whenever the key `src` is pressed or released, regardless of modifiers,\n    press or release the hotkey `dst` instead.\n    """"""\n    def handler(event):\n        if event.event_type == KEY_DOWN:\n            press(dst)\n        else:\n            release(dst)\n        return False\n    return hook_key(src, handler, suppress=True)\nunremap_key = unhook_key\n\ndef parse_hotkey_combinations(hotkey):\n    """"""\n    Parses a user-provided hotkey. Differently from `parse_hotkey`,\n    instead of each step being a list of the different scan codes for each key,\n    each step is a list of all possible combinations of those scan codes.\n    """"""\n    def combine_step(step):\n        # A single step may be composed of many keys, and each key can have\n        # multiple scan codes. To speed up hotkey matching and avoid introducing\n        # event delays, we list all possible combinations of scan codes for these\n        # keys. Hotkeys are usually small, and there are not many combinations, so\n        # this is not as insane as it sounds.\n        return (tuple(sorted(scan_codes)) for scan_codes in _itertools.product(*step))\n\n    return tuple(tuple(combine_step(step)) for step in parse_hotkey(hotkey))\n\ndef _add_hotkey_step(handler, combinations, suppress):\n    """"""\n    Hooks a single-step hotkey (e.g. \'shift+a\').\n    """"""\n    container = _listener.blocking_hotkeys if suppress else _listener.nonblocking_hotkeys\n\n    # Register the scan codes of every possible combination of\n    # modfiier + main key. Modifiers have to be registered in \n    # filtered_modifiers too, so suppression and replaying can work.\n    for scan_codes in combinations:\n        for scan_code in scan_codes:\n            if is_modifier(scan_code):\n                _listener.filtered_modifiers[scan_code] += 1\n        container[scan_codes].append(handler)\n\n    def remove():\n        for scan_codes in combinations:\n            for scan_code in scan_codes:\n                if is_modifier(scan_code):\n                    _listener.filtered_modifiers[scan_code] -= 1\n            container[scan_codes].remove(handler)\n    return remove\n\n_hotkeys = {}\ndef add_hotkey(hotkey, callback, args=(), suppress=False, timeout=1, trigger_on_release=False):\n    """"""\n    Invokes a callback every time a hotkey is pressed. The hotkey must\n    be in the format `ctrl+shift+a, s`. This would trigger when the user holds\n    ctrl, shift and ""a"" at once, releases, and then presses ""s"". To represent\n    literal commas, pluses, and spaces, use their names (\'comma\', \'plus\',\n    \'space\').\n\n    - `args` is an optional list of arguments to passed to the callback during\n    each invocation.\n    - `suppress` defines if successful triggers should block the keys from being\n    sent to other programs.\n    - `timeout` is the amount of seconds allowed to pass between key presses.\n    - `trigger_on_release` if true, the callback is invoked on key release instead\n    of key press.\n\n    The event handler function is returned. To remove a hotkey call\n    `remove_hotkey(hotkey)` or `remove_hotkey(handler)`.\n    before the hotkey state is reset.\n\n    Note: hotkeys are activated when the last key is *pressed*, not released.\n    Note: the callback is executed in a separate thread, asynchronously. For an\n    example of how to use a callback synchronously, see `wait`.\n\n    Examples:\n\n        # Different but equivalent ways to listen for a spacebar key press.\n        add_hotkey(\' \', print, args=[\'space was pressed\'])\n        add_hotkey(\'space\', print, args=[\'space was pressed\'])\n        add_hotkey(\'Space\', print, args=[\'space was pressed\'])\n        # Here 57 represents the keyboard code for spacebar; so you will be\n        # pressing \'spacebar\', not \'57\' to activate the print function.\n        add_hotkey(57, print, args=[\'space was pressed\'])\n\n        add_hotkey(\'ctrl+q\', quit)\n        add_hotkey(\'ctrl+alt+enter, space\', some_callback)\n    """"""\n    if args:\n        callback = lambda callback=callback: callback(*args)\n\n    _listener.start_if_necessary()\n\n    steps = parse_hotkey_combinations(hotkey)\n\n    event_type = KEY_UP if trigger_on_release else KEY_DOWN\n    if len(steps) == 1:\n        # Deciding when to allow a KEY_UP event is far harder than I thought,\n        # and any mistake will make that key ""sticky"". Therefore just let all\n        # KEY_UP events go through as long as that\'s not what we are listening\n        # for.\n        handler = lambda e: (event_type == KEY_DOWN and e.event_type == KEY_UP and e.scan_code in _logically_pressed_keys) or (event_type == e.event_type and callback())\n        remove_step = _add_hotkey_step(handler, steps[0], suppress)\n        def remove_():\n            remove_step()\n            del _hotkeys[hotkey]\n            del _hotkeys[remove_]\n            del _hotkeys[callback]\n        # TODO: allow multiple callbacks for each hotkey without overwriting the\n        # remover.\n        _hotkeys[hotkey] = _hotkeys[remove_] = _hotkeys[callback] = remove_\n        return remove_\n\n    state = _State()\n    state.remove_catch_misses = None\n    state.remove_last_step = None\n    state.suppressed_events = []\n    state.last_update = float(\'-inf\')\n    \n    def catch_misses(event, force_fail=False):\n        if (\n                event.event_type == event_type\n                and state.index\n                and event.scan_code not in allowed_keys_by_step[state.index]\n            ) or (\n                timeout\n                and _time.monotonic() - state.last_update >= timeout\n            ) or force_fail: # Weird formatting to ensure short-circuit.\n\n            state.remove_last_step()\n\n            for event in state.suppressed_events:\n                if event.event_type == KEY_DOWN:\n                    press(event.scan_code)\n                else:\n                    release(event.scan_code)\n            del state.suppressed_events[:]\n\n            index = 0\n            set_index(0)\n        return True\n\n    def set_index(new_index):\n        state.index = new_index\n\n        if new_index == 0:\n            # This is done for performance reasons, avoiding a global key hook\n            # that is always on.\n            state.remove_catch_misses = lambda: None\n        elif new_index == 1:\n            state.remove_catch_misses()\n            # Must be `suppress=True` to ensure `send` has priority.\n            state.remove_catch_misses = hook(catch_misses, suppress=True)\n\n        if new_index == len(steps) - 1:\n            def handler(event):\n                if event.event_type == KEY_UP:\n                    remove()\n                    set_index(0)\n                accept = event.event_type == event_type and callback() \n                if accept:\n                    return catch_misses(event, force_fail=True)\n                else:\n                    state.suppressed_events[:] = [event]\n                    return False\n            remove = _add_hotkey_step(handler, steps[state.index], suppress)\n        else:\n            # Fix value of next_index.\n            def handler(event, new_index=state.index+1):\n                if event.event_type == KEY_UP:\n                    remove()\n                    set_index(new_index)\n                state.suppressed_events.append(event)\n                return False\n            remove = _add_hotkey_step(handler, steps[state.index], suppress)\n        state.remove_last_step = remove\n        state.last_update = _time.monotonic()\n        return False\n    set_index(0)\n\n    allowed_keys_by_step = [\n        set().union(*step)\n        for step in steps\n    ]\n\n    def remove_():\n        state.remove_catch_misses()\n        state.remove_last_step()\n        del _hotkeys[hotkey]\n        del _hotkeys[remove_]\n        del _hotkeys[callback]\n    # TODO: allow multiple callbacks for each hotkey without overwriting the\n    # remover.\n    _hotkeys[hotkey] = _hotkeys[remove_] = _hotkeys[callback] = remove_\n    return remove_\nregister_hotkey = add_hotkey\n\ndef remove_hotkey(hotkey_or_callback):\n    """"""\n    Removes a previously hooked hotkey. Must be called wtih the value returned\n    by `add_hotkey`.\n    """"""\n    _hotkeys[hotkey_or_callback]()\nunregister_hotkey = clear_hotkey = remove_hotkey\n\ndef unhook_all_hotkeys():\n    """"""\n    Removes all keyboard hotkeys in use, including abbreviations, word listeners,\n    `record`ers and `wait`s.\n    """"""\n    # Because of ""alises"" some hooks may have more than one entry, all of which\n    # are removed together.\n    _listener.blocking_hotkeys.clear()\n    _listener.nonblocking_hotkeys.clear()\nunregister_all_hotkeys = remove_all_hotkeys = clear_all_hotkeys = unhook_all_hotkeys\n\ndef remap_hotkey(src, dst, suppress=True, trigger_on_release=False):\n    """"""\n    Whenever the hotkey `src` is pressed, suppress it and send\n    `dst` instead.\n\n    Example:\n\n        remap(\'alt+w\', \'ctrl+up\')\n    """"""\n    def handler():\n        active_modifiers = sorted(modifier for modifier, state in _listener.modifier_states.items() if state == \'allowed\')\n        for modifier in active_modifiers:\n            release(modifier)\n        send(dst)\n        for modifier in reversed(active_modifiers):\n            press(modifier)\n        return False\n    return add_hotkey(src, handler, suppress=suppress, trigger_on_release=trigger_on_release)\nunremap_hotkey = remove_hotkey\n\ndef stash_state():\n    """"""\n    Builds a list of all currently pressed scan codes, releases them and returns\n    the list. Pairs well with `restore_state` and `restore_modifiers`.\n    """"""\n    # TODO: stash caps lock / numlock /scrollock state.\n    with _pressed_events_lock:\n        state = sorted(_pressed_events)\n    for scan_code in state:\n        _os_keyboard.release(scan_code)\n    return state\n\ndef restore_state(scan_codes):\n    """"""\n    Given a list of scan_codes ensures these keys, and only these keys, are\n    pressed. Pairs well with `stash_state`, alternative to `restore_modifiers`.\n    """"""\n    _listener.is_replaying = True\n\n    with _pressed_events_lock:\n        current = set(_pressed_events)\n    target = set(scan_codes)\n    for scan_code in current - target:\n        _os_keyboard.release(scan_code)\n    for scan_code in target - current:\n        _os_keyboard.press(scan_code)\n\n    _listener.is_replaying = False\n\ndef restore_modifiers(scan_codes):\n    """"""\n    Like `restore_state`, but only restores modifier keys.\n    """"""\n    restore_state((scan_code for scan_code in scan_codes if is_modifier(scan_code)))\n\ndef write(text, delay=0, restore_state_after=True, exact=None):\n    """"""\n    Sends artificial keyboard events to the OS, simulating the typing of a given\n    text. Characters not available on the keyboard are typed as explicit unicode\n    characters using OS-specific functionality, such as alt+codepoint.\n\n    To ensure text integrity, all currently pressed keys are released before\n    the text is typed, and modifiers are restored afterwards.\n\n    - `delay` is the number of seconds to wait between keypresses, defaults to\n    no delay.\n    - `restore_state_after` can be used to restore the state of pressed keys\n    after the text is typed, i.e. presses the keys that were released at the\n    beginning. Defaults to True.\n    - `exact` forces typing all characters as explicit unicode (e.g.\n    alt+codepoint or special events). If None, uses platform-specific suggested\n    value.\n    """"""\n    if exact is None:\n        exact = _platform.system() == \'Windows\'\n\n    state = stash_state()\n    \n    # Window\'s typing of unicode characters is quite efficient and should be preferred.\n    if exact:\n        for letter in text:\n            if letter in \'\\n\\b\':\n                send(letter)\n            else:\n                _os_keyboard.type_unicode(letter)\n            if delay: _time.sleep(delay)\n    else:\n        for letter in text:\n            try:\n                entries = _os_keyboard.map_name(normalize_name(letter))\n                scan_code, modifiers = next(iter(entries))\n            except (KeyError, ValueError):\n                _os_keyboard.type_unicode(letter)\n                continue\n            \n            for modifier in modifiers:\n                press(modifier)\n\n            _os_keyboard.press(scan_code)\n            _os_keyboard.release(scan_code)\n\n            for modifier in modifiers:\n                release(modifier)\n\n            if delay:\n                _time.sleep(delay)\n\n    if restore_state_after:\n        restore_modifiers(state)\n\ndef wait(hotkey=None, suppress=False, trigger_on_release=False):\n    """"""\n    Blocks the program execution until the given hotkey is pressed or,\n    if given no parameters, blocks forever.\n    """"""\n    if hotkey:\n        lock = _Event()\n        remove = add_hotkey(hotkey, lambda: lock.set(), suppress=suppress, trigger_on_release=trigger_on_release)\n        lock.wait()\n        remove_hotkey(remove)\n    else:\n        while True:\n            _time.sleep(1e6)\n\ndef get_hotkey_name(names=None):\n    """"""\n    Returns a string representation of hotkey from the given key names, or\n    the currently pressed keys if not given.  This function:\n\n    - normalizes names;\n    - removes ""left"" and ""right"" prefixes;\n    - replaces the ""+"" key name with ""plus"" to avoid ambiguity;\n    - puts modifier keys first, in a standardized order;\n    - sort remaining keys;\n    - finally, joins everything with ""+"".\n\n    Example:\n\n        get_hotkey_name([\'+\', \'left ctrl\', \'shift\'])\n        # ""ctrl+shift+plus""\n    """"""\n    if names is None:\n        _listener.start_if_necessary()\n        with _pressed_events_lock:\n            names = [e.name for e in _pressed_events.values()]\n    else:\n        names = [normalize_name(name) for name in names]\n    clean_names = set(e.replace(\'left \', \'\').replace(\'right \', \'\').replace(\'+\', \'plus\') for e in names)\n    # https://developer.apple.com/macos/human-interface-guidelines/input-and-output/keyboard/\n    # > List modifier keys in the correct order. If you use more than one modifier key in a\n    # > hotkey, always list them in this order: Control, Option, Shift, Command.\n    modifiers = [\'ctrl\', \'alt\', \'shift\', \'windows\']\n    sorting_key = lambda k: (modifiers.index(k) if k in modifiers else 5, str(k))\n    return \'+\'.join(sorted(clean_names, key=sorting_key))\n\ndef read_event(suppress=False):\n    """"""\n    Blocks until a keyboard event happens, then returns that event.\n    """"""\n    queue = _queue.Queue(maxsize=1)\n    hooked = hook(queue.put, suppress=suppress)\n    while True:\n        event = queue.get()\n        unhook(hooked)\n        return event\n\ndef read_key(suppress=False):\n    """"""\n    Blocks until a keyboard event happens, then returns that event\'s name or,\n    if missing, its scan code.\n    """"""\n    event = read_event(suppress)\n    return event.name or event.scan_code\n\ndef read_hotkey(suppress=True):\n    """"""\n    Similar to `read_key()`, but blocks until the user presses and releases a\n    hotkey (or single key), then returns a string representing the hotkey\n    pressed.\n\n    Example:\n\n        read_hotkey()\n        # ""ctrl+shift+p""\n    """"""\n    queue = _queue.Queue()\n    fn = lambda e: queue.put(e) or e.event_type == KEY_DOWN\n    hooked = hook(fn, suppress=suppress)\n    while True:\n        event = queue.get()\n        if event.event_type == KEY_UP:\n            unhook(hooked)\n            with _pressed_events_lock:\n                names = [e.name for e in _pressed_events.values()] + [event.name]\n            return get_hotkey_name(names)\n\ndef get_typed_strings(events, allow_backspace=True):\n    """"""\n    Given a sequence of events, tries to deduce what strings were typed.\n    Strings are separated when a non-textual key is pressed (such as tab or\n    enter). Characters are converted to uppercase according to shift and\n    capslock status. If `allow_backspace` is True, backspaces remove the last\n    character typed.\n\n    This function is a generator, so you can pass an infinite stream of events\n    and convert them to strings in real time.\n\n    Note this functions is merely an heuristic. Windows for example keeps per-\n    process keyboard state such as keyboard layout, and this information is not\n    available for our hooks.\n\n        get_type_strings(record()) #-> [\'This is what\', \'I recorded\', \'\']\n    """"""\n    backspace_name = \'delete\' if _platform.system() == \'Darwin\' else \'backspace\'\n\n    shift_pressed = False\n    capslock_pressed = False\n    string = \'\'\n    for event in events:\n        name = event.name\n\n        # Space is the only key that we _parse_hotkey to the spelled out name\n        # because of legibility. Now we have to undo that.\n        if event.name == \'space\':\n            name = \' \'\n\n        if \'shift\' in event.name:\n            shift_pressed = event.event_type == \'down\'\n        elif event.name == \'caps lock\' and event.event_type == \'down\':\n            capslock_pressed = not capslock_pressed\n        elif allow_backspace and event.name == backspace_name and event.event_type == \'down\':\n            string = string[:-1]\n        elif event.event_type == \'down\':\n            if len(name) == 1:\n                if shift_pressed ^ capslock_pressed:\n                    name = name.upper()\n                string = string + name\n            else:\n                yield string\n                string = \'\'\n    yield string\n\n_recording = None\ndef start_recording(recorded_events_queue=None):\n    """"""\n    Starts recording all keyboard events into a global variable, or the given\n    queue if any. Returns the queue of events and the hooked function.\n\n    Use `stop_recording()` or `unhook(hooked_function)` to stop.\n    """"""\n    recorded_events_queue = recorded_events_queue or _queue.Queue()\n    global _recording\n    _recording = (recorded_events_queue, hook(recorded_events_queue.put))\n    return _recording\n\ndef stop_recording():\n    """"""\n    Stops the global recording of events and returns a list of the events\n    captured.\n    """"""\n    global _recording\n    if not _recording:\n        raise ValueError(\'Must call ""start_recording"" before.\')\n    recorded_events_queue, hooked = _recording\n    unhook(hooked)\n    return list(recorded_events_queue.queue)\n\ndef record(until=\'escape\', suppress=False, trigger_on_release=False):\n    """"""\n    Records all keyboard events from all keyboards until the user presses the\n    given hotkey. Then returns the list of events recorded, of type\n    `keyboard.KeyboardEvent`. Pairs well with\n    `play(events)`.\n\n    Note: this is a blocking function.\n    Note: for more details on the keyboard hook and events see `hook`.\n    """"""\n    start_recording()\n    wait(until, suppress=suppress, trigger_on_release=trigger_on_release)\n    return stop_recording()\n\ndef play(events, speed_factor=1.0):\n    """"""\n    Plays a sequence of recorded events, maintaining the relative time\n    intervals. If speed_factor is <= 0 then the actions are replayed as fast\n    as the OS allows. Pairs well with `record()`.\n\n    Note: the current keyboard state is cleared at the beginning and restored at\n    the end of the function.\n    """"""\n    state = stash_state()\n\n    last_time = None\n    for event in events:\n        if speed_factor > 0 and last_time is not None:\n            _time.sleep((event.time - last_time) / speed_factor)\n        last_time = event.time\n\n        key = event.scan_code or event.name\n        press(key) if event.event_type == KEY_DOWN else release(key)\n\n    restore_modifiers(state)\nreplay = play\n\n_word_listeners = {}\ndef add_word_listener(word, callback, triggers=[\'space\'], match_suffix=False, timeout=2):\n    """"""\n    Invokes a callback every time a sequence of characters is typed (e.g. \'pet\')\n    and followed by a trigger key (e.g. space). Modifiers (e.g. alt, ctrl,\n    shift) are ignored.\n\n    - `word` the typed text to be matched. E.g. \'pet\'.\n    - `callback` is an argument-less function to be invoked each time the word\n    is typed.\n    - `triggers` is the list of keys that will cause a match to be checked. If\n    the user presses some key that is not a character (len>1) and not in\n    triggers, the characters so far will be discarded. By default the trigger\n    is only `space`.\n    - `match_suffix` defines if endings of words should also be checked instead\n    of only whole words. E.g. if true, typing \'carpet\'+space will trigger the\n    listener for \'pet\'. Defaults to false, only whole words are checked.\n    - `timeout` is the maximum number of seconds between typed characters before\n    the current word is discarded. Defaults to 2 seconds.\n\n    Returns the event handler created. To remove a word listener use\n    `remove_word_listener(word)` or `remove_word_listener(handler)`.\n\n    Note: all actions are performed on key down. Key up events are ignored.\n    Note: word mathes are **case sensitive**.\n    """"""\n    state = _State()\n    state.current = \'\'\n    state.time = -1\n\n    def handler(event):\n        name = event.name\n        if event.event_type == KEY_UP or name in all_modifiers: return\n\n        if timeout and event.time - state.time > timeout:\n            state.current = \'\'\n        state.time = event.time\n\n        matched = state.current == word or (match_suffix and state.current.endswith(word))\n        if name in triggers and matched:\n            callback()\n            state.current = \'\'\n        elif len(name) > 1:\n            state.current = \'\'\n        else:\n            state.current += name\n\n    hooked = hook(handler)\n    def remove():\n        hooked()\n        del _word_listeners[word]\n        del _word_listeners[handler]\n        del _word_listeners[remove]\n    _word_listeners[word] = _word_listeners[handler] = _word_listeners[remove] = remove\n    # TODO: allow multiple word listeners and removing them correctly.\n    return remove\n\ndef remove_word_listener(word_or_handler):\n    """"""\n    Removes a previously registered word listener. Accepts either the word used\n    during registration (exact string) or the event handler returned by the\n    `add_word_listener` or `add_abbreviation` functions.\n    """"""\n    _word_listeners[word_or_handler]()\n\ndef add_abbreviation(source_text, replacement_text, match_suffix=False, timeout=2):\n    """"""\n    Registers a hotkey that replaces one typed text with another. For example\n\n        add_abbreviation(\'tm\', u\'\xe2\x84\xa2\')\n\n    Replaces every ""tm"" followed by a space with a \xe2\x84\xa2 symbol (and no space). The\n    replacement is done by sending backspace events.\n\n    - `match_suffix` defines if endings of words should also be checked instead\n    of only whole words. E.g. if true, typing \'carpet\'+space will trigger the\n    listener for \'pet\'. Defaults to false, only whole words are checked.\n    - `timeout` is the maximum number of seconds between typed characters before\n    the current word is discarded. Defaults to 2 seconds.\n    \n    For more details see `add_word_listener`.\n    """"""\n    replacement = \'\\b\'*(len(source_text)+1) + replacement_text\n    callback = lambda: write(replacement)\n    return add_word_listener(source_text, callback, match_suffix=match_suffix, timeout=timeout)\n\n# Aliases.\nregister_word_listener = add_word_listener\nregister_abbreviation = add_abbreviation\nremove_abbreviation = remove_word_listener'"
External_Libraries/keyboard_master/keyboard/__main__.py,0,"b""# -*- coding: utf-8 -*-\nimport keyboard\nimport fileinput\nimport json\nimport sys\n\ndef print_event_json(event):\n    print(event.to_json(ensure_ascii=sys.stdout.encoding != 'utf-8'))\n    sys.stdout.flush()\nkeyboard.hook(print_event_json)\n\nparse_event_json = lambda line: keyboard.KeyboardEvent(**json.loads(line))\nkeyboard.play(parse_event_json(line) for line in fileinput.input())"""
External_Libraries/keyboard_master/keyboard/_canonical_names.py,0,"b'# -*- coding: utf-8 -*-\nfrom __future__ import unicode_literals\n\ntry:\n    basestring\nexcept NameError:\n    basestring = str\n\nimport platform\n\n# Defaults to Windows canonical names (platform-specific overrides below)\ncanonical_names = {\n    \'escape\': \'esc\',\n    \'return\': \'enter\',\n    \'del\': \'delete\',\n    \'control\': \'ctrl\',\n\n    \'left arrow\': \'left\',\n    \'up arrow\': \'up\',\n    \'down arrow\': \'down\',\n    \'right arrow\': \'right\',\n\n    \' \': \'space\', # Prefer to spell out keys that would be hard to read.\n    \'\\x1b\': \'esc\',\n    \'\\x08\': \'backspace\',\n    \'\\n\': \'enter\',\n    \'\\t\': \'tab\',\n    \'\\r\': \'enter\',\n\n    \'scrlk\': \'scroll lock\',\n    \'prtscn\': \'print screen\',\n    \'prnt scrn\': \'print screen\',\n    \'snapshot\': \'print screen\',\n    \'ins\': \'insert\',\n    \'pause break\': \'pause\',\n    \'ctrll lock\': \'caps lock\',\n    \'capslock\': \'caps lock\',\n    \'number lock\': \'num lock\',\n    \'numlock\': \'num lock\',\n    \'space bar\': \'space\',\n    \'spacebar\': \'space\',\n    \'linefeed\': \'enter\',\n    \'win\': \'windows\',\n\n    # Mac keys\n    \'command\': \'windows\',\n    \'cmd\': \'windows\',\n    \'control\': \'ctrl\',\n    \'option\': \'alt\',\n\n    \'app\': \'menu\',\n    \'apps\': \'menu\',\n    \'application\': \'menu\',\n    \'applications\': \'menu\',\n\n    \'pagedown\': \'page down\',\n    \'pageup\': \'page up\',\n    \'pgdown\': \'page down\',\n    \'pgup\': \'page up\',\n\n    \'play/pause\': \'play/pause media\',\n\n    \'num multiply\': \'*\',\n    \'num divide\': \'/\',\n    \'num add\': \'+\',\n    \'num plus\': \'+\',\n    \'num minus\': \'-\',\n    \'num sub\': \'-\',\n    \'num enter\': \'enter\',\n    \'num 0\': \'0\',\n    \'num 1\': \'1\',\n    \'num 2\': \'2\',\n    \'num 3\': \'3\',\n    \'num 4\': \'4\',\n    \'num 5\': \'5\',\n    \'num 6\': \'6\',\n    \'num 7\': \'7\',\n    \'num 8\': \'8\',\n    \'num 9\': \'9\',\n\n    \'left win\': \'left windows\',\n    \'right win\': \'right windows\',\n    \'left control\': \'left ctrl\',\n    \'right control\': \'right ctrl\',\n    \'left menu\': \'left alt\', # Windows...\n    \'altgr\': \'alt gr\',\n\n    # https://www.x.org/releases/X11R7.6/doc/libX11/Compose/en_US.UTF-8.html\n    # https://svn.apache.org/repos/asf/xmlgraphics/commons/tags/commons-1_0/src/java/org/apache/xmlgraphics/fonts/Glyphs.java\n    # Note this list has plenty of uppercase letters that are not being used\n    # at the moment, as normalization forces names to be lowercase.\n    ""Aacute"": ""\xc3\x81"",\n    ""aacute"": ""\xc3\xa1"",\n    ""Aacutesmall"": ""\xef\x9f\xa1"",\n    ""abovedot"": ""\xcb\x99"",\n    ""Abreve"": ""\xc4\x82"",\n    ""abreve"": ""\xc4\x83"",\n    ""Abreveacute"": ""\xe1\xba\xae"",\n    ""abreveacute"": ""\xe1\xba\xaf"",\n    ""Abrevebelowdot"": ""\xe1\xba\xb6"",\n    ""abrevebelowdot"": ""\xe1\xba\xb7"",\n    ""Abrevegrave"": ""\xe1\xba\xb0"",\n    ""abrevegrave"": ""\xe1\xba\xb1"",\n    ""Abrevehook"": ""\xe1\xba\xb2"",\n    ""abrevehook"": ""\xe1\xba\xb3"",\n    ""Abrevetilde"": ""\xe1\xba\xb4"",\n    ""abrevetilde"": ""\xe1\xba\xb5"",\n    ""Acircumflex"": ""\xc3\x82"",\n    ""acircumflex"": ""\xc3\xa2"",\n    ""Acircumflexacute"": ""\xe1\xba\xa4"",\n    ""acircumflexacute"": ""\xe1\xba\xa5"",\n    ""Acircumflexbelowdot"": ""\xe1\xba\xac"",\n    ""acircumflexbelowdot"": ""\xe1\xba\xad"",\n    ""Acircumflexgrave"": ""\xe1\xba\xa6"",\n    ""acircumflexgrave"": ""\xe1\xba\xa7"",\n    ""Acircumflexhook"": ""\xe1\xba\xa8"",\n    ""acircumflexhook"": ""\xe1\xba\xa9"",\n    ""Acircumflexsmall"": ""\xef\x9f\xa2"",\n    ""Acircumflextilde"": ""\xe1\xba\xaa"",\n    ""acircumflextilde"": ""\xe1\xba\xab"",\n    ""acute"": ""\xc2\xb4"",\n    ""Acute"": ""\xef\x9b\x89"",\n    ""acutecomb"": ""\xcc\x81"",\n    ""Acutesmall"": ""\xef\x9e\xb4"",\n    ""add"": ""+"",\n    ""Adiaeresis"": ""\xc3\x84"",\n    ""adiaeresis"": ""\xc3\xa4"",\n    ""Adieresis"": ""\xc3\x84"",\n    ""adieresis"": ""\xc3\xa4"",\n    ""Adieresissmall"": ""\xef\x9f\xa4"",\n    ""ae"": ""\xc3\xa6"",\n    ""AE"": ""\xc3\x86"",\n    ""AEacute"": ""\xc7\xbc"",\n    ""aeacute"": ""\xc7\xbd"",\n    ""AEsmall"": ""\xef\x9f\xa6"",\n    ""afii00208"": ""\xe2\x80\x95"",\n    ""afii10017"": ""\xd0\x90"",\n    ""afii10018"": ""\xd0\x91"",\n    ""afii10019"": ""\xd0\x92"",\n    ""afii10020"": ""\xd0\x93"",\n    ""afii10021"": ""\xd0\x94"",\n    ""afii10022"": ""\xd0\x95"",\n    ""afii10023"": ""\xd0\x81"",\n    ""afii10024"": ""\xd0\x96"",\n    ""afii10025"": ""\xd0\x97"",\n    ""afii10026"": ""\xd0\x98"",\n    ""afii10027"": ""\xd0\x99"",\n    ""afii10028"": ""\xd0\x9a"",\n    ""afii10029"": ""\xd0\x9b"",\n    ""afii10030"": ""\xd0\x9c"",\n    ""afii10031"": ""\xd0\x9d"",\n    ""afii10032"": ""\xd0\x9e"",\n    ""afii10033"": ""\xd0\x9f"",\n    ""afii10034"": ""\xd0\xa0"",\n    ""afii10035"": ""\xd0\xa1"",\n    ""afii10036"": ""\xd0\xa2"",\n    ""afii10037"": ""\xd0\xa3"",\n    ""afii10038"": ""\xd0\xa4"",\n    ""afii10039"": ""\xd0\xa5"",\n    ""afii10040"": ""\xd0\xa6"",\n    ""afii10041"": ""\xd0\xa7"",\n    ""afii10042"": ""\xd0\xa8"",\n    ""afii10043"": ""\xd0\xa9"",\n    ""afii10044"": ""\xd0\xaa"",\n    ""afii10045"": ""\xd0\xab"",\n    ""afii10046"": ""\xd0\xac"",\n    ""afii10047"": ""\xd0\xad"",\n    ""afii10048"": ""\xd0\xae"",\n    ""afii10049"": ""\xd0\xaf"",\n    ""afii10050"": ""\xd2\x90"",\n    ""afii10051"": ""\xd0\x82"",\n    ""afii10052"": ""\xd0\x83"",\n    ""afii10053"": ""\xd0\x84"",\n    ""afii10054"": ""\xd0\x85"",\n    ""afii10055"": ""\xd0\x86"",\n    ""afii10056"": ""\xd0\x87"",\n    ""afii10057"": ""\xd0\x88"",\n    ""afii10058"": ""\xd0\x89"",\n    ""afii10059"": ""\xd0\x8a"",\n    ""afii10060"": ""\xd0\x8b"",\n    ""afii10061"": ""\xd0\x8c"",\n    ""afii10062"": ""\xd0\x8e"",\n    ""afii10063"": ""\xef\x9b\x84"",\n    ""afii10064"": ""\xef\x9b\x85"",\n    ""afii10065"": ""\xd0\xb0"",\n    ""afii10066"": ""\xd0\xb1"",\n    ""afii10067"": ""\xd0\xb2"",\n    ""afii10068"": ""\xd0\xb3"",\n    ""afii10069"": ""\xd0\xb4"",\n    ""afii10070"": ""\xd0\xb5"",\n    ""afii10071"": ""\xd1\x91"",\n    ""afii10072"": ""\xd0\xb6"",\n    ""afii10073"": ""\xd0\xb7"",\n    ""afii10074"": ""\xd0\xb8"",\n    ""afii10075"": ""\xd0\xb9"",\n    ""afii10076"": ""\xd0\xba"",\n    ""afii10077"": ""\xd0\xbb"",\n    ""afii10078"": ""\xd0\xbc"",\n    ""afii10079"": ""\xd0\xbd"",\n    ""afii10080"": ""\xd0\xbe"",\n    ""afii10081"": ""\xd0\xbf"",\n    ""afii10082"": ""\xd1\x80"",\n    ""afii10083"": ""\xd1\x81"",\n    ""afii10084"": ""\xd1\x82"",\n    ""afii10085"": ""\xd1\x83"",\n    ""afii10086"": ""\xd1\x84"",\n    ""afii10087"": ""\xd1\x85"",\n    ""afii10088"": ""\xd1\x86"",\n    ""afii10089"": ""\xd1\x87"",\n    ""afii10090"": ""\xd1\x88"",\n    ""afii10091"": ""\xd1\x89"",\n    ""afii10092"": ""\xd1\x8a"",\n    ""afii10093"": ""\xd1\x8b"",\n    ""afii10094"": ""\xd1\x8c"",\n    ""afii10095"": ""\xd1\x8d"",\n    ""afii10096"": ""\xd1\x8e"",\n    ""afii10097"": ""\xd1\x8f"",\n    ""afii10098"": ""\xd2\x91"",\n    ""afii10099"": ""\xd1\x92"",\n    ""afii10100"": ""\xd1\x93"",\n    ""afii10101"": ""\xd1\x94"",\n    ""afii10102"": ""\xd1\x95"",\n    ""afii10103"": ""\xd1\x96"",\n    ""afii10104"": ""\xd1\x97"",\n    ""afii10105"": ""\xd1\x98"",\n    ""afii10106"": ""\xd1\x99"",\n    ""afii10107"": ""\xd1\x9a"",\n    ""afii10108"": ""\xd1\x9b"",\n    ""afii10109"": ""\xd1\x9c"",\n    ""afii10110"": ""\xd1\x9e"",\n    ""afii10145"": ""\xd0\x8f"",\n    ""afii10146"": ""\xd1\xa2"",\n    ""afii10147"": ""\xd1\xb2"",\n    ""afii10148"": ""\xd1\xb4"",\n    ""afii10192"": ""\xef\x9b\x86"",\n    ""afii10193"": ""\xd1\x9f"",\n    ""afii10194"": ""\xd1\xa3"",\n    ""afii10195"": ""\xd1\xb3"",\n    ""afii10196"": ""\xd1\xb5"",\n    ""afii10831"": ""\xef\x9b\x87"",\n    ""afii10832"": ""\xef\x9b\x88"",\n    ""afii10846"": ""\xd3\x99"",\n    ""afii299"": ""\xe2\x80\x8e"",\n    ""afii300"": ""\xe2\x80\x8f"",\n    ""afii301"": ""\xe2\x80\x8d"",\n    ""afii57381"": ""\xd9\xaa"",\n    ""afii57388"": ""\xd8\x8c"",\n    ""afii57392"": ""\xd9\xa0"",\n    ""afii57393"": ""\xd9\xa1"",\n    ""afii57394"": ""\xd9\xa2"",\n    ""afii57395"": ""\xd9\xa3"",\n    ""afii57396"": ""\xd9\xa4"",\n    ""afii57397"": ""\xd9\xa5"",\n    ""afii57398"": ""\xd9\xa6"",\n    ""afii57399"": ""\xd9\xa7"",\n    ""afii57400"": ""\xd9\xa8"",\n    ""afii57401"": ""\xd9\xa9"",\n    ""afii57403"": ""\xd8\x9b"",\n    ""afii57407"": ""\xd8\x9f"",\n    ""afii57409"": ""\xd8\xa1"",\n    ""afii57410"": ""\xd8\xa2"",\n    ""afii57411"": ""\xd8\xa3"",\n    ""afii57412"": ""\xd8\xa4"",\n    ""afii57413"": ""\xd8\xa5"",\n    ""afii57414"": ""\xd8\xa6"",\n    ""afii57415"": ""\xd8\xa7"",\n    ""afii57416"": ""\xd8\xa8"",\n    ""afii57417"": ""\xd8\xa9"",\n    ""afii57418"": ""\xd8\xaa"",\n    ""afii57419"": ""\xd8\xab"",\n    ""afii57420"": ""\xd8\xac"",\n    ""afii57421"": ""\xd8\xad"",\n    ""afii57422"": ""\xd8\xae"",\n    ""afii57423"": ""\xd8\xaf"",\n    ""afii57424"": ""\xd8\xb0"",\n    ""afii57425"": ""\xd8\xb1"",\n    ""afii57426"": ""\xd8\xb2"",\n    ""afii57427"": ""\xd8\xb3"",\n    ""afii57428"": ""\xd8\xb4"",\n    ""afii57429"": ""\xd8\xb5"",\n    ""afii57430"": ""\xd8\xb6"",\n    ""afii57431"": ""\xd8\xb7"",\n    ""afii57432"": ""\xd8\xb8"",\n    ""afii57433"": ""\xd8\xb9"",\n    ""afii57434"": ""\xd8\xba"",\n    ""afii57440"": ""\xd9\x80"",\n    ""afii57441"": ""\xd9\x81"",\n    ""afii57442"": ""\xd9\x82"",\n    ""afii57443"": ""\xd9\x83"",\n    ""afii57444"": ""\xd9\x84"",\n    ""afii57445"": ""\xd9\x85"",\n    ""afii57446"": ""\xd9\x86"",\n    ""afii57448"": ""\xd9\x88"",\n    ""afii57449"": ""\xd9\x89"",\n    ""afii57450"": ""\xd9\x8a"",\n    ""afii57451"": ""\xd9\x8b"",\n    ""afii57452"": ""\xd9\x8c"",\n    ""afii57453"": ""\xd9\x8d"",\n    ""afii57454"": ""\xd9\x8e"",\n    ""afii57455"": ""\xd9\x8f"",\n    ""afii57456"": ""\xd9\x90"",\n    ""afii57457"": ""\xd9\x91"",\n    ""afii57458"": ""\xd9\x92"",\n    ""afii57470"": ""\xd9\x87"",\n    ""afii57505"": ""\xda\xa4"",\n    ""afii57506"": ""\xd9\xbe"",\n    ""afii57507"": ""\xda\x86"",\n    ""afii57508"": ""\xda\x98"",\n    ""afii57509"": ""\xda\xaf"",\n    ""afii57511"": ""\xd9\xb9"",\n    ""afii57512"": ""\xda\x88"",\n    ""afii57513"": ""\xda\x91"",\n    ""afii57514"": ""\xda\xba"",\n    ""afii57519"": ""\xdb\x92"",\n    ""afii57534"": ""\xdb\x95"",\n    ""afii57636"": ""\xe2\x82\xaa"",\n    ""afii57645"": ""\xd6\xbe"",\n    ""afii57658"": ""\xd7\x83"",\n    ""afii57664"": ""\xd7\x90"",\n    ""afii57665"": ""\xd7\x91"",\n    ""afii57666"": ""\xd7\x92"",\n    ""afii57667"": ""\xd7\x93"",\n    ""afii57668"": ""\xd7\x94"",\n    ""afii57669"": ""\xd7\x95"",\n    ""afii57670"": ""\xd7\x96"",\n    ""afii57671"": ""\xd7\x97"",\n    ""afii57672"": ""\xd7\x98"",\n    ""afii57673"": ""\xd7\x99"",\n    ""afii57674"": ""\xd7\x9a"",\n    ""afii57675"": ""\xd7\x9b"",\n    ""afii57676"": ""\xd7\x9c"",\n    ""afii57677"": ""\xd7\x9d"",\n    ""afii57678"": ""\xd7\x9e"",\n    ""afii57679"": ""\xd7\x9f"",\n    ""afii57680"": ""\xd7\xa0"",\n    ""afii57681"": ""\xd7\xa1"",\n    ""afii57682"": ""\xd7\xa2"",\n    ""afii57683"": ""\xd7\xa3"",\n    ""afii57684"": ""\xd7\xa4"",\n    ""afii57685"": ""\xd7\xa5"",\n    ""afii57686"": ""\xd7\xa6"",\n    ""afii57687"": ""\xd7\xa7"",\n    ""afii57688"": ""\xd7\xa8"",\n    ""afii57689"": ""\xd7\xa9"",\n    ""afii57690"": ""\xd7\xaa"",\n    ""afii57694"": ""\xef\xac\xaa"",\n    ""afii57695"": ""\xef\xac\xab"",\n    ""afii57700"": ""\xef\xad\x8b"",\n    ""afii57705"": ""\xef\xac\x9f"",\n    ""afii57716"": ""\xd7\xb0"",\n    ""afii57717"": ""\xd7\xb1"",\n    ""afii57718"": ""\xd7\xb2"",\n    ""afii57723"": ""\xef\xac\xb5"",\n    ""afii57793"": ""\xd6\xb4"",\n    ""afii57794"": ""\xd6\xb5"",\n    ""afii57795"": ""\xd6\xb6"",\n    ""afii57796"": ""\xd6\xbb"",\n    ""afii57797"": ""\xd6\xb8"",\n    ""afii57798"": ""\xd6\xb7"",\n    ""afii57799"": ""\xd6\xb0"",\n    ""afii57800"": ""\xd6\xb2"",\n    ""afii57801"": ""\xd6\xb1"",\n    ""afii57802"": ""\xd6\xb3"",\n    ""afii57803"": ""\xd7\x82"",\n    ""afii57804"": ""\xd7\x81"",\n    ""afii57806"": ""\xd6\xb9"",\n    ""afii57807"": ""\xd6\xbc"",\n    ""afii57839"": ""\xd6\xbd"",\n    ""afii57841"": ""\xd6\xbf"",\n    ""afii57842"": ""\xd7\x80"",\n    ""afii57929"": ""\xca\xbc"",\n    ""afii61248"": ""\xe2\x84\x85"",\n    ""afii61289"": ""\xe2\x84\x93"",\n    ""afii61352"": ""\xe2\x84\x96"",\n    ""afii61573"": ""\xe2\x80\xac"",\n    ""afii61574"": ""\xe2\x80\xad"",\n    ""afii61575"": ""\xe2\x80\xae"",\n    ""afii61664"": ""\xe2\x80\x8c"",\n    ""afii63167"": ""\xd9\xad"",\n    ""afii64937"": ""\xca\xbd"",\n    ""Agrave"": ""\xc3\x80"",\n    ""agrave"": ""\xc3\xa0"",\n    ""Agravesmall"": ""\xef\x9f\xa0"",\n    ""agudo"": ""\xc2\xb4"",\n    ""aleph"": ""\xe2\x84\xb5"",\n    ""Alpha"": ""\xce\x91"",\n    ""alpha"": ""\xce\xb1"",\n    ""Alphatonos"": ""\xce\x86"",\n    ""alphatonos"": ""\xce\xac"",\n    ""Amacron"": ""\xc4\x80"",\n    ""amacron"": ""\xc4\x81"",\n    ""ampersand"": ""&"",\n    ""ampersandsmall"": ""\xef\x9c\xa6"",\n    ""angle"": ""\xe2\x88\xa0"",\n    ""angleleft"": ""\xe2\x8c\xa9"",\n    ""angleright"": ""\xe2\x8c\xaa"",\n    ""anoteleia"": ""\xce\x87"",\n    ""Aogonek"": ""\xc4\x84"",\n    ""aogonek"": ""\xc4\x85"",\n    ""apostrophe"": ""\'"",\n    ""approxequal"": ""\xe2\x89\x88"",\n    ""Aring"": ""\xc3\x85"",\n    ""aring"": ""\xc3\xa5"",\n    ""Aringacute"": ""\xc7\xba"",\n    ""aringacute"": ""\xc7\xbb"",\n    ""Aringsmall"": ""\xef\x9f\xa5"",\n    ""arrowboth"": ""\xe2\x86\x94"",\n    ""arrowdblboth"": ""\xe2\x87\x94"",\n    ""arrowdbldown"": ""\xe2\x87\x93"",\n    ""arrowdblleft"": ""\xe2\x87\x90"",\n    ""arrowdblright"": ""\xe2\x87\x92"",\n    ""arrowdblup"": ""\xe2\x87\x91"",\n    ""arrowdown"": ""\xe2\x86\x93"",\n    ""arrowhorizex"": ""\xef\xa3\xa7"",\n    ""arrowleft"": ""\xe2\x86\x90"",\n    ""arrowright"": ""\xe2\x86\x92"",\n    ""arrowup"": ""\xe2\x86\x91"",\n    ""arrowupdn"": ""\xe2\x86\x95"",\n    ""arrowupdnbse"": ""\xe2\x86\xa8"",\n    ""arrowvertex"": ""\xef\xa3\xa6"",\n    ""asciicircum"": ""^"",\n    ""asciitilde"": ""~"",\n    ""Asmall"": ""\xef\x9d\xa1"",\n    ""asterisk"": ""*"",\n    ""asteriskmath"": ""\xe2\x88\x97"",\n    ""asuperior"": ""\xef\x9b\xa9"",\n    ""at"": ""@"",\n    ""Atilde"": ""\xc3\x83"",\n    ""atilde"": ""\xc3\xa3"",\n    ""Atildesmall"": ""\xef\x9f\xa3"",\n    ""backslash"": ""\\\\"",\n    ""bar"": ""|"",\n    ""Beta"": ""\xce\x92"",\n    ""beta"": ""\xce\xb2"",\n    ""block"": ""\xe2\x96\x88"",\n    ""braceex"": ""\xef\xa3\xb4"",\n    ""braceleft"": ""{"",\n    ""braceleftbt"": ""\xef\xa3\xb3"",\n    ""braceleftmid"": ""\xef\xa3\xb2"",\n    ""bracelefttp"": ""\xef\xa3\xb1"",\n    ""braceright"": ""}"",\n    ""bracerightbt"": ""\xef\xa3\xbe"",\n    ""bracerightmid"": ""\xef\xa3\xbd"",\n    ""bracerighttp"": ""\xef\xa3\xbc"",\n    ""bracketleft"": ""["",\n    ""bracketleftbt"": ""\xef\xa3\xb0"",\n    ""bracketleftex"": ""\xef\xa3\xaf"",\n    ""bracketlefttp"": ""\xef\xa3\xae"",\n    ""bracketright"": ""]"",\n    ""bracketrightbt"": ""\xef\xa3\xbb"",\n    ""bracketrightex"": ""\xef\xa3\xba"",\n    ""bracketrighttp"": ""\xef\xa3\xb9"",\n    ""breve"": ""\xcb\x98"",\n    ""Brevesmall"": ""\xef\x9b\xb4"",\n    ""brokenbar"": ""\xc2\xa6"",\n    ""Bsmall"": ""\xef\x9d\xa2"",\n    ""bsuperior"": ""\xef\x9b\xaa"",\n    ""bullet"": ""\xe2\x80\xa2"",\n    ""Cacute"": ""\xc4\x86"",\n    ""cacute"": ""\xc4\x87"",\n    ""caron"": ""\xcb\x87"",\n    ""Caron"": ""\xef\x9b\x8a"",\n    ""Caronsmall"": ""\xef\x9b\xb5"",\n    ""carriagereturn"": ""\xe2\x86\xb5"",\n    ""Ccaron"": ""\xc4\x8c"",\n    ""ccaron"": ""\xc4\x8d"",\n    ""Ccedilla"": ""\xc3\x87"",\n    ""ccedilla"": ""\xc3\xa7"",\n    ""Ccedillasmall"": ""\xef\x9f\xa7"",\n    ""Ccircumflex"": ""\xc4\x88"",\n    ""ccircumflex"": ""\xc4\x89"",\n    ""Cdotaccent"": ""\xc4\x8a"",\n    ""cdotaccent"": ""\xc4\x8b"",\n    ""cedilla"": ""\xc2\xb8"",\n    ""Cedillasmall"": ""\xef\x9e\xb8"",\n    ""cent"": ""\xc2\xa2"",\n    ""centinferior"": ""\xef\x9b\x9f"",\n    ""centoldstyle"": ""\xef\x9e\xa2"",\n    ""centsuperior"": ""\xef\x9b\xa0"",\n    ""Chi"": ""\xce\xa7"",\n    ""chi"": ""\xcf\x87"",\n    ""circle"": ""\xe2\x97\x8b"",\n    ""circlemultiply"": ""\xe2\x8a\x97"",\n    ""circleplus"": ""\xe2\x8a\x95"",\n    ""circumflex"": ""^"",\n    ""circumflex"": ""\xcb\x86"",\n    ""Circumflexsmall"": ""\xef\x9b\xb6"",\n    ""club"": ""\xe2\x99\xa3"",\n    ""colon"": "":"",\n    ""colonmonetary"": ""\xe2\x82\xa1"",\n    ""ColonSign"": ""\xe2\x82\xa1"",\n    ""comma"": "","",\n    ""commaaccent"": ""\xef\x9b\x83"",\n    ""commainferior"": ""\xef\x9b\xa1"",\n    ""commasuperior"": ""\xef\x9b\xa2"",\n    ""congruent"": ""\xe2\x89\x85"",\n    ""copyright"": ""\xc2\xa9"",\n    ""copyrightsans"": ""\xef\xa3\xa9"",\n    ""copyrightserif"": ""\xef\x9b\x99"",\n    ""CruzeiroSign"": ""\xe2\x82\xa2"",\n    ""Csmall"": ""\xef\x9d\xa3"",\n    ""currency"": ""\xc2\xa4"",\n    ""cyrBreve"": ""\xef\x9b\x91"",\n    ""cyrbreve"": ""\xef\x9b\x94"",\n    ""cyrFlex"": ""\xef\x9b\x92"",\n    ""cyrflex"": ""\xef\x9b\x95"",\n    ""dagger"": ""\xe2\x80\xa0"",\n    ""daggerdbl"": ""\xe2\x80\xa1"",\n    ""dblGrave"": ""\xef\x9b\x93"",\n    ""dblgrave"": ""\xef\x9b\x96"",\n    ""Dcaron"": ""\xc4\x8e"",\n    ""dcaron"": ""\xc4\x8f"",\n    ""Dcroat"": ""\xc4\x90"",\n    ""dcroat"": ""\xc4\x91"",\n    ""degree"": ""\xc2\xb0"",\n    ""Delta"": ""\xce\x94"",\n    ""delta"": ""\xce\xb4"",\n    ""diaeresis"": ""\xc2\xa8"",\n    ""diamond"": ""\xe2\x99\xa6"",\n    ""dieresis"": ""\xc2\xa8"",\n    ""Dieresis"": ""\xef\x9b\x8b"",\n    ""DieresisAcute"": ""\xef\x9b\x8c"",\n    ""dieresisacute"": ""\xef\x9b\x97"",\n    ""DieresisGrave"": ""\xef\x9b\x8d"",\n    ""dieresisgrave"": ""\xef\x9b\x98"",\n    ""Dieresissmall"": ""\xef\x9e\xa8"",\n    ""dieresistonos"": ""\xce\x85"",\n    ""divide"": ""/"",\n    ""divide"": ""\xc3\xb7"",\n    ""division"": ""\xc3\xb7"",\n    ""dkshade"": ""\xe2\x96\x93"",\n    ""dnblock"": ""\xe2\x96\x84"",\n    ""dollar"": ""$"",\n    ""dollarinferior"": ""\xef\x9b\xa3"",\n    ""dollaroldstyle"": ""\xef\x9c\xa4"",\n    ""dollarsuperior"": ""\xef\x9b\xa4"",\n    ""dong"": ""\xe2\x82\xab"",\n    ""DongSign"": ""\xe2\x82\xab"",\n    ""dot"": ""."",\n    ""dotaccent"": ""\xcb\x99"",\n    ""Dotaccentsmall"": ""\xef\x9b\xb7"",\n    ""dotbelowcomb"": ""\xcc\xa3"",\n    ""dotlessi"": ""\xc4\xb1"",\n    ""dotlessj"": ""\xef\x9a\xbe"",\n    ""dotmath"": ""\xe2\x8b\x85"",\n    ""Dsmall"": ""\xef\x9d\xa4"",\n    ""dstroke"": ""\xc4\x91"",\n    ""Dstroke"": ""\xc4\x90"",\n    ""dsuperior"": ""\xef\x9b\xab"",\n    ""Eacute"": ""\xc3\x89"",\n    ""eacute"": ""\xc3\xa9"",\n    ""Eacutesmall"": ""\xef\x9f\xa9"",\n    ""Ebreve"": ""\xc4\x94"",\n    ""ebreve"": ""\xc4\x95"",\n    ""Ecaron"": ""\xc4\x9a"",\n    ""ecaron"": ""\xc4\x9b"",\n    ""Ecircumflex"": ""\xc3\x8a"",\n    ""ecircumflex"": ""\xc3\xaa"",\n    ""Ecircumflexacute"": ""\xe1\xba\xbe"",\n    ""ecircumflexacute"": ""\xe1\xba\xbf"",\n    ""Ecircumflexbelowdot"": ""\xe1\xbb\x86"",\n    ""ecircumflexbelowdot"": ""\xe1\xbb\x87"",\n    ""Ecircumflexgrave"": ""\xe1\xbb\x80"",\n    ""ecircumflexgrave"": ""\xe1\xbb\x81"",\n    ""Ecircumflexhook"": ""\xe1\xbb\x82"",\n    ""ecircumflexhook"": ""\xe1\xbb\x83"",\n    ""Ecircumflexsmall"": ""\xef\x9f\xaa"",\n    ""Ecircumflextilde"": ""\xe1\xbb\x84"",\n    ""ecircumflextilde"": ""\xe1\xbb\x85"",\n    ""EcuSign"": ""\xe2\x82\xa0"",\n    ""Ediaeresis"": ""\xc3\x8b"",\n    ""ediaeresis"": ""\xc3\xab"",\n    ""Edieresis"": ""\xc3\x8b"",\n    ""edieresis"": ""\xc3\xab"",\n    ""Edieresissmall"": ""\xef\x9f\xab"",\n    ""Edotaccent"": ""\xc4\x96"",\n    ""edotaccent"": ""\xc4\x97"",\n    ""Egrave"": ""\xc3\x88"",\n    ""egrave"": ""\xc3\xa8"",\n    ""Egravesmall"": ""\xef\x9f\xa8"",\n    ""eight"": ""8"",\n    ""eightinferior"": ""\xe2\x82\x88"",\n    ""eightoldstyle"": ""\xef\x9c\xb8"",\n    ""eightsubscript"": ""\xe2\x82\x88"",\n    ""eightsuperior"": ""\xe2\x81\xb8"",\n    ""element"": ""\xe2\x88\x88"",\n    ""ellipsis"": ""\xe2\x80\xa6"",\n    ""Emacron"": ""\xc4\x92"",\n    ""emacron"": ""\xc4\x93"",\n    ""emdash"": ""\xe2\x80\x94"",\n    ""emptyset"": ""\xe2\x88\x85"",\n    ""endash"": ""\xe2\x80\x93"",\n    ""enfilledcircbullet"": ""\xe2\x80\xa2"",\n    ""Eng"": ""\xc5\x8a"",\n    ""eng"": ""\xc5\x8b"",\n    ""Eogonek"": ""\xc4\x98"",\n    ""eogonek"": ""\xc4\x99"",\n    ""Epsilon"": ""\xce\x95"",\n    ""epsilon"": ""\xce\xb5"",\n    ""Epsilontonos"": ""\xce\x88"",\n    ""epsilontonos"": ""\xce\xad"",\n    ""equal"": ""="",\n    ""equivalence"": ""\xe2\x89\xa1"",\n    ""Esmall"": ""\xef\x9d\xa5"",\n    ""estimated"": ""\xe2\x84\xae"",\n    ""esuperior"": ""\xef\x9b\xac"",\n    ""Eta"": ""\xce\x97"",\n    ""eta"": ""\xce\xb7"",\n    ""Etatonos"": ""\xce\x89"",\n    ""etatonos"": ""\xce\xae"",\n    ""ETH"": ""\xc3\x90"",\n    ""eth"": ""\xc3\xb0"",\n    ""Eth"": ""\xc3\x90"",\n    ""Ethsmall"": ""\xef\x9f\xb0"",\n    ""euro"": ""\xe2\x82\xac"",\n    ""Euro"": ""\xe2\x82\xac"",\n    ""EuroSign"": ""\xe2\x82\xac"",\n    ""exclam"": ""!"",\n    ""exclamdbl"": ""\xe2\x80\xbc"",\n    ""exclamdown"": ""\xc2\xa1"",\n    ""exclamdownsmall"": ""\xef\x9e\xa1"",\n    ""exclamsmall"": ""\xef\x9c\xa1"",\n    ""existential"": ""\xe2\x88\x83"",\n    ""female"": ""\xe2\x99\x80"",\n    ""ff"": ""\xef\xac\x80"",\n    ""ffi"": ""\xef\xac\x83"",\n    ""ffl"": ""\xef\xac\x84"",\n    ""FFrancSign"": ""\xe2\x82\xa3"",\n    ""fi"": ""\xef\xac\x81"",\n    ""figuredash"": ""\xe2\x80\x92"",\n    ""filledbox"": ""\xe2\x96\xa0"",\n    ""filledrect"": ""\xe2\x96\xac"",\n    ""five"": ""5"",\n    ""fiveeighths"": ""\xe2\x85\x9d"",\n    ""fiveinferior"": ""\xe2\x82\x85"",\n    ""fiveoldstyle"": ""\xef\x9c\xb5"",\n    ""fivesubscript"": ""\xe2\x82\x85"",\n    ""fivesuperior"": ""\xe2\x81\xb5"",\n    ""fl"": ""\xef\xac\x82"",\n    ""florin"": ""\xc6\x92"",\n    ""four"": ""4"",\n    ""fourinferior"": ""\xe2\x82\x84"",\n    ""fouroldstyle"": ""\xef\x9c\xb4"",\n    ""foursubscript"": ""\xe2\x82\x84"",\n    ""foursuperior"": ""\xe2\x81\xb4"",\n    ""fraction"": ""\xe2\x88\x95"",\n    ""franc"": ""\xe2\x82\xa3"",\n    ""Fsmall"": ""\xef\x9d\xa6"",\n    ""function"": ""\xc6\x92"",\n    ""Gamma"": ""\xce\x93"",\n    ""gamma"": ""\xce\xb3"",\n    ""Gbreve"": ""\xc4\x9e"",\n    ""gbreve"": ""\xc4\x9f"",\n    ""Gcaron"": ""\xc7\xa6"",\n    ""gcaron"": ""\xc7\xa7"",\n    ""Gcircumflex"": ""\xc4\x9c"",\n    ""gcircumflex"": ""\xc4\x9d"",\n    ""Gcommaaccent"": ""\xc4\xa2"",\n    ""gcommaaccent"": ""\xc4\xa3"",\n    ""Gdotaccent"": ""\xc4\xa0"",\n    ""gdotaccent"": ""\xc4\xa1"",\n    ""germandbls"": ""\xc3\x9f"",\n    ""gradient"": ""\xe2\x88\x87"",\n    ""grave"": ""`"",\n    ""Grave"": ""\xef\x9b\x8e"",\n    ""gravecomb"": ""\xcc\x80"",\n    ""Gravesmall"": ""\xef\x9d\xa0"",\n    ""greater"": "">"",\n    ""greaterequal"": ""\xe2\x89\xa5"",\n    ""Gsmall"": ""\xef\x9d\xa7"",\n    ""guillemotleft"": ""\xc2\xab"",\n    ""guillemotright"": ""\xc2\xbb"",\n    ""guilsinglleft"": ""\xe2\x80\xb9"",\n    ""guilsinglright"": ""\xe2\x80\xba"",\n    ""H18533"": ""\xe2\x97\x8f"",\n    ""H18543"": ""\xe2\x96\xaa"",\n    ""H18551"": ""\xe2\x96\xab"",\n    ""H22073"": ""\xe2\x96\xa1"",\n    ""hash"": ""#"",\n    ""hashtag"": ""#"",\n    ""Hbar"": ""\xc4\xa6"",\n    ""hbar"": ""\xc4\xa7"",\n    ""Hcircumflex"": ""\xc4\xa4"",\n    ""hcircumflex"": ""\xc4\xa5"",\n    ""heart"": ""\xe2\x99\xa5"",\n    ""hookabovecomb"": ""\xcc\x89"",\n    ""house"": ""\xe2\x8c\x82"",\n    ""Hsmall"": ""\xef\x9d\xa8"",\n    ""hungarumlaut"": ""\xcb\x9d"",\n    ""Hungarumlaut"": ""\xef\x9b\x8f"",\n    ""Hungarumlautsmall"": ""\xef\x9b\xb8"",\n    ""hyphen"": ""\xc2\xad"",\n    ""hypheninferior"": ""\xef\x9b\xa5"",\n    ""hyphensuperior"": ""\xef\x9b\xa6"",\n    ""Iacute"": ""\xc3\x8d"",\n    ""iacute"": ""\xc3\xad"",\n    ""Iacutesmall"": ""\xef\x9f\xad"",\n    ""Ibreve"": ""\xc4\xac"",\n    ""ibreve"": ""\xc4\xad"",\n    ""Icircumflex"": ""\xc3\x8e"",\n    ""icircumflex"": ""\xc3\xae"",\n    ""Icircumflexsmall"": ""\xef\x9f\xae"",\n    ""Idiaeresis"": ""\xc3\x8f"",\n    ""idiaeresis"": ""\xc3\xaf"",\n    ""Idieresis"": ""\xc3\x8f"",\n    ""idieresis"": ""\xc3\xaf"",\n    ""Idieresissmall"": ""\xef\x9f\xaf"",\n    ""Idotaccent"": ""\xc4\xb0"",\n    ""Ifraktur"": ""\xe2\x84\x91"",\n    ""Igrave"": ""\xc3\x8c"",\n    ""igrave"": ""\xc3\xac"",\n    ""Igravesmall"": ""\xef\x9f\xac"",\n    ""IJ"": ""\xc4\xb2"",\n    ""ij"": ""\xc4\xb3"",\n    ""Imacron"": ""\xc4\xaa"",\n    ""imacron"": ""\xc4\xab"",\n    ""infinity"": ""\xe2\x88\x9e"",\n    ""integral"": ""\xe2\x88\xab"",\n    ""integralbt"": ""\xe2\x8c\xa1"",\n    ""integralex"": ""\xef\xa3\xb5"",\n    ""integraltp"": ""\xe2\x8c\xa0"",\n    ""intersection"": ""\xe2\x88\xa9"",\n    ""invbullet"": ""\xe2\x97\x98"",\n    ""invcircle"": ""\xe2\x97\x99"",\n    ""invsmileface"": ""\xe2\x98\xbb"",\n    ""Iogonek"": ""\xc4\xae"",\n    ""iogonek"": ""\xc4\xaf"",\n    ""Iota"": ""\xce\x99"",\n    ""iota"": ""\xce\xb9"",\n    ""Iotadieresis"": ""\xce\xaa"",\n    ""iotadieresis"": ""\xcf\x8a"",\n    ""iotadieresistonos"": ""\xce\x90"",\n    ""Iotatonos"": ""\xce\x8a"",\n    ""iotatonos"": ""\xce\xaf"",\n    ""Ismall"": ""\xef\x9d\xa9"",\n    ""isuperior"": ""\xef\x9b\xad"",\n    ""Itilde"": ""\xc4\xa8"",\n    ""itilde"": ""\xc4\xa9"",\n    ""Jcircumflex"": ""\xc4\xb4"",\n    ""jcircumflex"": ""\xc4\xb5"",\n    ""Jsmall"": ""\xef\x9d\xaa"",\n    ""Kappa"": ""\xce\x9a"",\n    ""kappa"": ""\xce\xba"",\n    ""Kcommaaccent"": ""\xc4\xb6"",\n    ""kcommaaccent"": ""\xc4\xb7"",\n    ""kgreenlandic"": ""\xc4\xb8"",\n    ""Ksmall"": ""\xef\x9d\xab"",\n    ""Lacute"": ""\xc4\xb9"",\n    ""lacute"": ""\xc4\xba"",\n    ""Lambda"": ""\xce\x9b"",\n    ""lambda"": ""\xce\xbb"",\n    ""Lcaron"": ""\xc4\xbd"",\n    ""lcaron"": ""\xc4\xbe"",\n    ""Lcommaaccent"": ""\xc4\xbb"",\n    ""lcommaaccent"": ""\xc4\xbc"",\n    ""Ldot"": ""\xc4\xbf"",\n    ""ldot"": ""\xc5\x80"",\n    ""less"": ""<"",\n    ""lessequal"": ""\xe2\x89\xa4"",\n    ""lfblock"": ""\xe2\x96\x8c"",\n    ""lira"": ""\xe2\x82\xa4"",\n    ""LiraSign"": ""\xe2\x82\xa4"",\n    ""LL"": ""\xef\x9a\xbf"",\n    ""ll"": ""\xef\x9b\x80"",\n    ""logicaland"": ""\xe2\x88\xa7"",\n    ""logicalnot"": ""\xc2\xac"",\n    ""logicalor"": ""\xe2\x88\xa8"",\n    ""longs"": ""\xc5\xbf"",\n    ""lozenge"": ""\xe2\x97\x8a"",\n    ""Lslash"": ""\xc5\x81"",\n    ""lslash"": ""\xc5\x82"",\n    ""Lslashsmall"": ""\xef\x9b\xb9"",\n    ""Lsmall"": ""\xef\x9d\xac"",\n    ""lsuperior"": ""\xef\x9b\xae"",\n    ""ltshade"": ""\xe2\x96\x91"",\n    ""macron"": ""\xc2\xaf"",\n    ""macron"": ""\xcb\x89"",\n    ""Macron"": ""\xef\x9b\x90"",\n    ""Macronsmall"": ""\xef\x9e\xaf"",\n    ""male"": ""\xe2\x99\x82"",\n    ""masculine"": ""\xc2\xba"",\n    ""MillSign"": ""\xe2\x82\xa5"",\n    ""minplus"": ""+"",\n    ""minus"": ""-"",\n    ""minus"": ""\xe2\x88\x92"",\n    ""minute"": ""\xe2\x80\xb2"",\n    ""Msmall"": ""\xef\x9d\xad"",\n    ""msuperior"": ""\xef\x9b\xaf"",\n    ""mu"": ""\xc2\xb5"",\n    ""Mu"": ""\xce\x9c"",\n    ""mu"": ""\xce\xbc"",\n    ""multiply"": ""*"",\n    ""multiply"": ""\xc3\x97"",\n    ""musicalnote"": ""\xe2\x99\xaa"",\n    ""musicalnotedbl"": ""\xe2\x99\xab"",\n    ""Nacute"": ""\xc5\x83"",\n    ""nacute"": ""\xc5\x84"",\n    ""NairaSign"": ""\xe2\x82\xa6"",\n    ""napostrophe"": ""\xc5\x89"",\n    ""Ncaron"": ""\xc5\x87"",\n    ""ncaron"": ""\xc5\x88"",\n    ""Ncommaaccent"": ""\xc5\x85"",\n    ""ncommaaccent"": ""\xc5\x86"",\n    ""NewSheqelSign"": ""\xe2\x82\xaa"",\n    ""nine"": ""9"",\n    ""nineinferior"": ""\xe2\x82\x89"",\n    ""nineoldstyle"": ""\xef\x9c\xb9"",\n    ""ninesubscript"": ""\xe2\x82\x89"",\n    ""ninesuperior"": ""\xe2\x81\xb9"",\n    ""nobreakspace"": "" "",\n    ""notelement"": ""\xe2\x88\x89"",\n    ""notequal"": ""\xe2\x89\xa0"",\n    ""notsign"": ""\xc2\xac"",\n    ""notsubset"": ""\xe2\x8a\x84"",\n    ""Nsmall"": ""\xef\x9d\xae"",\n    ""nsuperior"": ""\xe2\x81\xbf"",\n    ""Ntilde"": ""\xc3\x91"",\n    ""ntilde"": ""\xc3\xb1"",\n    ""Ntildesmall"": ""\xef\x9f\xb1"",\n    ""Nu"": ""\xce\x9d"",\n    ""nu"": ""\xce\xbd"",\n    ""numbersign"": ""#"",\n    ""numerosign"": ""\xe2\x84\x96"",\n    ""Oacute"": ""\xc3\x93"",\n    ""oacute"": ""\xc3\xb3"",\n    ""Oacutesmall"": ""\xef\x9f\xb3"",\n    ""Obreve"": ""\xc5\x8e"",\n    ""obreve"": ""\xc5\x8f"",\n    ""Ocircumflex"": ""\xc3\x94"",\n    ""ocircumflex"": ""\xc3\xb4"",\n    ""Ocircumflexacute"": ""\xe1\xbb\x90"",\n    ""ocircumflexacute"": ""\xe1\xbb\x91"",\n    ""Ocircumflexbelowdot"": ""\xe1\xbb\x98"",\n    ""ocircumflexbelowdot"": ""\xe1\xbb\x99"",\n    ""Ocircumflexgrave"": ""\xe1\xbb\x92"",\n    ""ocircumflexgrave"": ""\xe1\xbb\x93"",\n    ""Ocircumflexhook"": ""\xe1\xbb\x94"",\n    ""ocircumflexhook"": ""\xe1\xbb\x95"",\n    ""Ocircumflexsmall"": ""\xef\x9f\xb4"",\n    ""Ocircumflextilde"": ""\xe1\xbb\x96"",\n    ""ocircumflextilde"": ""\xe1\xbb\x97"",\n    ""Odiaeresis"": ""\xc3\x96"",\n    ""odiaeresis"": ""\xc3\xb6"",\n    ""Odieresis"": ""\xc3\x96"",\n    ""odieresis"": ""\xc3\xb6"",\n    ""Odieresissmall"": ""\xef\x9f\xb6"",\n    ""oe"": ""\xc5\x93"",\n    ""OE"": ""\xc5\x92"",\n    ""OEsmall"": ""\xef\x9b\xba"",\n    ""ogonek"": ""\xcb\x9b"",\n    ""Ogoneksmall"": ""\xef\x9b\xbb"",\n    ""Ograve"": ""\xc3\x92"",\n    ""ograve"": ""\xc3\xb2"",\n    ""Ogravesmall"": ""\xef\x9f\xb2"",\n    ""Ohorn"": ""\xc6\xa0"",\n    ""ohorn"": ""\xc6\xa1"",\n    ""Ohornacute"": ""\xe1\xbb\x9a"",\n    ""ohornacute"": ""\xe1\xbb\x9b"",\n    ""Ohornbelowdot"": ""\xe1\xbb\xa2"",\n    ""ohornbelowdot"": ""\xe1\xbb\xa3"",\n    ""Ohorngrave"": ""\xe1\xbb\x9c"",\n    ""ohorngrave"": ""\xe1\xbb\x9d"",\n    ""Ohornhook"": ""\xe1\xbb\x9e"",\n    ""ohornhook"": ""\xe1\xbb\x9f"",\n    ""Ohorntilde"": ""\xe1\xbb\xa0"",\n    ""ohorntilde"": ""\xe1\xbb\xa1"",\n    ""Ohungarumlaut"": ""\xc5\x90"",\n    ""ohungarumlaut"": ""\xc5\x91"",\n    ""Omacron"": ""\xc5\x8c"",\n    ""omacron"": ""\xc5\x8d"",\n    ""Omega"": ""\xce\xa9"",\n    ""omega"": ""\xcf\x89"",\n    ""omega1"": ""\xcf\x96"",\n    ""Omegatonos"": ""\xce\x8f"",\n    ""omegatonos"": ""\xcf\x8e"",\n    ""Omicron"": ""\xce\x9f"",\n    ""omicron"": ""\xce\xbf"",\n    ""Omicrontonos"": ""\xce\x8c"",\n    ""omicrontonos"": ""\xcf\x8c"",\n    ""one"": ""1"",\n    ""onedotenleader"": ""\xe2\x80\xa4"",\n    ""oneeighth"": ""\xe2\x85\x9b"",\n    ""onefitted"": ""\xef\x9b\x9c"",\n    ""onehalf"": ""\xc2\xbd"",\n    ""oneinferior"": ""\xe2\x82\x81"",\n    ""oneoldstyle"": ""\xef\x9c\xb1"",\n    ""onequarter"": ""\xc2\xbc"",\n    ""onesubscript"": ""\xe2\x82\x81"",\n    ""onesuperior"": ""\xc2\xb9"",\n    ""onethird"": ""\xe2\x85\x93"",\n    ""openbullet"": ""\xe2\x97\xa6"",\n    ""ordfeminine"": ""\xc2\xaa"",\n    ""ordmasculine"": ""\xc2\xba"",\n    ""orthogonal"": ""\xe2\x88\x9f"",\n    ""Oslash"": ""\xc3\x98"",\n    ""oslash"": ""\xc3\xb8"",\n    ""Oslashacute"": ""\xc7\xbe"",\n    ""oslashacute"": ""\xc7\xbf"",\n    ""Oslashsmall"": ""\xef\x9f\xb8"",\n    ""Osmall"": ""\xef\x9d\xaf"",\n    ""osuperior"": ""\xef\x9b\xb0"",\n    ""Otilde"": ""\xc3\x95"",\n    ""otilde"": ""\xc3\xb5"",\n    ""Otildesmall"": ""\xef\x9f\xb5"",\n    ""paragraph"": ""\xc2\xb6"",\n    ""parenleft"": ""("",\n    ""parenleftbt"": ""\xef\xa3\xad"",\n    ""parenleftex"": ""\xef\xa3\xac"",\n    ""parenleftinferior"": ""\xe2\x82\x8d"",\n    ""parenleftsuperior"": ""\xe2\x81\xbd"",\n    ""parenlefttp"": ""\xef\xa3\xab"",\n    ""parenright"": "")"",\n    ""parenrightbt"": ""\xef\xa3\xb8"",\n    ""parenrightex"": ""\xef\xa3\xb7"",\n    ""parenrightinferior"": ""\xe2\x82\x8e"",\n    ""parenrightsuperior"": ""\xe2\x81\xbe"",\n    ""parenrighttp"": ""\xef\xa3\xb6"",\n    ""partialdiff"": ""\xe2\x88\x82"",\n    ""percent"": ""%"",\n    ""period"": ""."",\n    ""periodcentered"": ""\xc2\xb7"",\n    ""periodcentered"": ""\xe2\x88\x99"",\n    ""periodinferior"": ""\xef\x9b\xa7"",\n    ""periodsuperior"": ""\xef\x9b\xa8"",\n    ""perpendicular"": ""\xe2\x8a\xa5"",\n    ""perthousand"": ""\xe2\x80\xb0"",\n    ""peseta"": ""\xe2\x82\xa7"",\n    ""PesetaSign"": ""\xe2\x82\xa7"",\n    ""Phi"": ""\xce\xa6"",\n    ""phi"": ""\xcf\x86"",\n    ""phi1"": ""\xcf\x95"",\n    ""Pi"": ""\xce\xa0"",\n    ""pi"": ""\xcf\x80"",\n    ""plus"": ""+"",\n    ""plusminus"": ""\xc2\xb1"",\n    ""pound"": ""\xc2\xa3"",\n    ""prescription"": ""\xe2\x84\x9e"",\n    ""product"": ""\xe2\x88\x8f"",\n    ""propersubset"": ""\xe2\x8a\x82"",\n    ""propersuperset"": ""\xe2\x8a\x83"",\n    ""proportional"": ""\xe2\x88\x9d"",\n    ""Psi"": ""\xce\xa8"",\n    ""psi"": ""\xcf\x88"",\n    ""Psmall"": ""\xef\x9d\xb0"",\n    ""Qsmall"": ""\xef\x9d\xb1"",\n    ""question"": ""?"",\n    ""questiondown"": ""\xc2\xbf"",\n    ""questiondownsmall"": ""\xef\x9e\xbf"",\n    ""questionsmall"": ""\xef\x9c\xbf"",\n    ""quotedbl"": ""\\"""",\n    ""quotedblbase"": ""\xe2\x80\x9e"",\n    ""quotedblleft"": ""\xe2\x80\x9c"",\n    ""quotedblright"": ""\xe2\x80\x9d"",\n    ""quoteleft"": ""\xe2\x80\x98"",\n    ""quotereversed"": ""\xe2\x80\x9b"",\n    ""quoteright"": ""\xe2\x80\x99"",\n    ""quotesinglbase"": ""\xe2\x80\x9a"",\n    ""quotesingle"": ""\'"",\n    ""Racute"": ""\xc5\x94"",\n    ""racute"": ""\xc5\x95"",\n    ""radical"": ""\xe2\x88\x9a"",\n    ""radicalex"": ""\xef\xa3\xa5"",\n    ""Rcaron"": ""\xc5\x98"",\n    ""rcaron"": ""\xc5\x99"",\n    ""Rcommaaccent"": ""\xc5\x96"",\n    ""rcommaaccent"": ""\xc5\x97"",\n    ""reflexsubset"": ""\xe2\x8a\x86"",\n    ""reflexsuperset"": ""\xe2\x8a\x87"",\n    ""registered"": ""\xc2\xae"",\n    ""registersans"": ""\xef\xa3\xa8"",\n    ""registerserif"": ""\xef\x9b\x9a"",\n    ""revlogicalnot"": ""\xe2\x8c\x90"",\n    ""Rfraktur"": ""\xe2\x84\x9c"",\n    ""Rho"": ""\xce\xa1"",\n    ""rho"": ""\xcf\x81"",\n    ""ring"": ""\xcb\x9a"",\n    ""Ringsmall"": ""\xef\x9b\xbc"",\n    ""Rsmall"": ""\xef\x9d\xb2"",\n    ""rsuperior"": ""\xef\x9b\xb1"",\n    ""rtblock"": ""\xe2\x96\x90"",\n    ""RupeeSign"": ""\xe2\x82\xa8"",\n    ""rupiah"": ""\xef\x9b\x9d"",\n    ""Sacute"": ""\xc5\x9a"",\n    ""sacute"": ""\xc5\x9b"",\n    ""Scaron"": ""\xc5\xa0"",\n    ""scaron"": ""\xc5\xa1"",\n    ""Scaronsmall"": ""\xef\x9b\xbd"",\n    ""Scedilla"": ""\xef\x9b\x81"",\n    ""scedilla"": ""\xef\x9b\x82"",\n    ""Scircumflex"": ""\xc5\x9c"",\n    ""scircumflex"": ""\xc5\x9d"",\n    ""Scommaaccent"": ""\xc8\x98"",\n    ""scommaaccent"": ""\xc8\x99"",\n    ""second"": ""\xe2\x80\xb3"",\n    ""section"": ""\xc2\xa7"",\n    ""semicolon"": "";"",\n    ""seven"": ""7"",\n    ""seveneighths"": ""\xe2\x85\x9e"",\n    ""seveninferior"": ""\xe2\x82\x87"",\n    ""sevenoldstyle"": ""\xef\x9c\xb7"",\n    ""sevensubscript"": ""\xe2\x82\x87"",\n    ""sevensuperior"": ""\xe2\x81\xb7"",\n    ""SF010000"": ""\xe2\x94\x8c"",\n    ""SF020000"": ""\xe2\x94\x94"",\n    ""SF030000"": ""\xe2\x94\x90"",\n    ""SF040000"": ""\xe2\x94\x98"",\n    ""SF050000"": ""\xe2\x94\xbc"",\n    ""SF060000"": ""\xe2\x94\xac"",\n    ""SF070000"": ""\xe2\x94\xb4"",\n    ""SF080000"": ""\xe2\x94\x9c"",\n    ""SF090000"": ""\xe2\x94\xa4"",\n    ""SF100000"": ""\xe2\x94\x80"",\n    ""SF110000"": ""\xe2\x94\x82"",\n    ""SF190000"": ""\xe2\x95\xa1"",\n    ""SF200000"": ""\xe2\x95\xa2"",\n    ""SF210000"": ""\xe2\x95\x96"",\n    ""SF220000"": ""\xe2\x95\x95"",\n    ""SF230000"": ""\xe2\x95\xa3"",\n    ""SF240000"": ""\xe2\x95\x91"",\n    ""SF250000"": ""\xe2\x95\x97"",\n    ""SF260000"": ""\xe2\x95\x9d"",\n    ""SF270000"": ""\xe2\x95\x9c"",\n    ""SF280000"": ""\xe2\x95\x9b"",\n    ""SF360000"": ""\xe2\x95\x9e"",\n    ""SF370000"": ""\xe2\x95\x9f"",\n    ""SF380000"": ""\xe2\x95\x9a"",\n    ""SF390000"": ""\xe2\x95\x94"",\n    ""SF400000"": ""\xe2\x95\xa9"",\n    ""SF410000"": ""\xe2\x95\xa6"",\n    ""SF420000"": ""\xe2\x95\xa0"",\n    ""SF430000"": ""\xe2\x95\x90"",\n    ""SF440000"": ""\xe2\x95\xac"",\n    ""SF450000"": ""\xe2\x95\xa7"",\n    ""SF460000"": ""\xe2\x95\xa8"",\n    ""SF470000"": ""\xe2\x95\xa4"",\n    ""SF480000"": ""\xe2\x95\xa5"",\n    ""SF490000"": ""\xe2\x95\x99"",\n    ""SF500000"": ""\xe2\x95\x98"",\n    ""SF510000"": ""\xe2\x95\x92"",\n    ""SF520000"": ""\xe2\x95\x93"",\n    ""SF530000"": ""\xe2\x95\xab"",\n    ""SF540000"": ""\xe2\x95\xaa"",\n    ""shade"": ""\xe2\x96\x92"",\n    ""Sigma"": ""\xce\xa3"",\n    ""sigma"": ""\xcf\x83"",\n    ""sigma1"": ""\xcf\x82"",\n    ""similar"": ""\xe2\x88\xbc"",\n    ""similarequal"": ""\xe2\x89\x83"",\n    ""six"": ""6"",\n    ""sixinferior"": ""\xe2\x82\x86"",\n    ""sixoldstyle"": ""\xef\x9c\xb6"",\n    ""sixsubscript"": ""\xe2\x82\x86"",\n    ""sixsuperior"": ""\xe2\x81\xb6"",\n    ""slash"": ""/"",\n    ""smileface"": ""\xe2\x98\xba"",\n    ""spade"": ""\xe2\x99\xa0"",\n    ""ssharp"": ""\xc2\xa7"",\n    ""ssharp"": ""\xc3\x9f"",\n    ""Ssharp"": ""\xe1\xba\x9e"",\n    ""Ssmall"": ""\xef\x9d\xb3"",\n    ""ssuperior"": ""\xef\x9b\xb2"",\n    ""sterling"": ""\xc2\xa3"",\n    ""subtract"": ""-"",\n    ""suchthat"": ""\xe2\x88\x8b"",\n    ""summation"": ""\xe2\x88\x91"",\n    ""sun"": ""\xe2\x98\xbc"",\n    ""Tau"": ""\xce\xa4"",\n    ""tau"": ""\xcf\x84"",\n    ""Tbar"": ""\xc5\xa6"",\n    ""tbar"": ""\xc5\xa7"",\n    ""Tcaron"": ""\xc5\xa4"",\n    ""tcaron"": ""\xc5\xa5"",\n    ""Tcommaaccent"": ""\xc8\x9a"",\n    ""tcommaaccent"": ""\xc8\x9b"",\n    ""Thai_baht"": ""\xe0\xb8\xbf"",\n    ""therefore"": ""\xe2\x88\xb4"",\n    ""Theta"": ""\xce\x98"",\n    ""theta"": ""\xce\xb8"",\n    ""theta1"": ""\xcf\x91"",\n    ""THORN"": ""\xc3\x9e"",\n    ""thorn"": ""\xc3\xbe"",\n    ""Thorn"": ""\xc3\x9e"",\n    ""Thornsmall"": ""\xef\x9f\xbe"",\n    ""three"": ""3"",\n    ""threeeighths"": ""\xe2\x85\x9c"",\n    ""threeinferior"": ""\xe2\x82\x83"",\n    ""threeoldstyle"": ""\xef\x9c\xb3"",\n    ""threequarters"": ""\xc2\xbe"",\n    ""threequartersemdash"": ""\xef\x9b\x9e"",\n    ""threesubscript"": ""\xe2\x82\x83"",\n    ""threesuperior"": ""\xc2\xb3"",\n    ""til"": ""~"",\n    ""tilde"": ""~"",\n    ""tilde"": ""\xcb\x9c"",\n    ""tildecomb"": ""\xcc\x83"",\n    ""Tildesmall"": ""\xef\x9b\xbe"",\n    ""tonos"": ""\xce\x84"",\n    ""trademark"": ""\xe2\x84\xa2"",\n    ""trademarksans"": ""\xef\xa3\xaa"",\n    ""trademarkserif"": ""\xef\x9b\x9b"",\n    ""triagdn"": ""\xe2\x96\xbc"",\n    ""triaglf"": ""\xe2\x97\x84"",\n    ""triagrt"": ""\xe2\x96\xba"",\n    ""triagup"": ""\xe2\x96\xb2"",\n    ""Tsmall"": ""\xef\x9d\xb4"",\n    ""tsuperior"": ""\xef\x9b\xb3"",\n    ""two"": ""2"",\n    ""twodotenleader"": ""\xe2\x80\xa5"",\n    ""twoinferior"": ""\xe2\x82\x82"",\n    ""twooldstyle"": ""\xef\x9c\xb2"",\n    ""twosubscript"": ""\xe2\x82\x82"",\n    ""twosuperior"": ""\xc2\xb2"",\n    ""twothirds"": ""\xe2\x85\x94"",\n    ""Uacute"": ""\xc3\x9a"",\n    ""uacute"": ""\xc3\xba"",\n    ""Uacutesmall"": ""\xef\x9f\xba"",\n    ""Ubreve"": ""\xc5\xac"",\n    ""ubreve"": ""\xc5\xad"",\n    ""Ucircumflex"": ""\xc3\x9b"",\n    ""ucircumflex"": ""\xc3\xbb"",\n    ""Ucircumflexsmall"": ""\xef\x9f\xbb"",\n    ""Udiaeresis"": ""\xc3\x9c"",\n    ""udiaeresis"": ""\xc3\xbc"",\n    ""Udieresis"": ""\xc3\x9c"",\n    ""udieresis"": ""\xc3\xbc"",\n    ""Udieresissmall"": ""\xef\x9f\xbc"",\n    ""Ugrave"": ""\xc3\x99"",\n    ""ugrave"": ""\xc3\xb9"",\n    ""Ugravesmall"": ""\xef\x9f\xb9"",\n    ""Uhorn"": ""\xc6\xaf"",\n    ""uhorn"": ""\xc6\xb0"",\n    ""Uhornacute"": ""\xe1\xbb\xa8"",\n    ""uhornacute"": ""\xe1\xbb\xa9"",\n    ""Uhornbelowdot"": ""\xe1\xbb\xb0"",\n    ""uhornbelowdot"": ""\xe1\xbb\xb1"",\n    ""Uhorngrave"": ""\xe1\xbb\xaa"",\n    ""uhorngrave"": ""\xe1\xbb\xab"",\n    ""Uhornhook"": ""\xe1\xbb\xac"",\n    ""uhornhook"": ""\xe1\xbb\xad"",\n    ""Uhorntilde"": ""\xe1\xbb\xae"",\n    ""uhorntilde"": ""\xe1\xbb\xaf"",\n    ""Uhungarumlaut"": ""\xc5\xb0"",\n    ""uhungarumlaut"": ""\xc5\xb1"",\n    ""Umacron"": ""\xc5\xaa"",\n    ""umacron"": ""\xc5\xab"",\n    ""underscore"": ""_"",\n    ""underscoredbl"": ""\xe2\x80\x97"",\n    ""union"": ""\xe2\x88\xaa"",\n    ""universal"": ""\xe2\x88\x80"",\n    ""Uogonek"": ""\xc5\xb2"",\n    ""uogonek"": ""\xc5\xb3"",\n    ""upblock"": ""\xe2\x96\x80"",\n    ""Upsilon"": ""\xce\xa5"",\n    ""upsilon"": ""\xcf\x85"",\n    ""Upsilon1"": ""\xcf\x92"",\n    ""Upsilondieresis"": ""\xce\xab"",\n    ""upsilondieresis"": ""\xcf\x8b"",\n    ""upsilondieresistonos"": ""\xce\xb0"",\n    ""Upsilontonos"": ""\xce\x8e"",\n    ""upsilontonos"": ""\xcf\x8d"",\n    ""Uring"": ""\xc5\xae"",\n    ""uring"": ""\xc5\xaf"",\n    ""Usmall"": ""\xef\x9d\xb5"",\n    ""Utilde"": ""\xc5\xa8"",\n    ""utilde"": ""\xc5\xa9"",\n    ""Vsmall"": ""\xef\x9d\xb6"",\n    ""Wacute"": ""\xe1\xba\x82"",\n    ""wacute"": ""\xe1\xba\x83"",\n    ""Wcircumflex"": ""\xc5\xb4"",\n    ""wcircumflex"": ""\xc5\xb5"",\n    ""Wdieresis"": ""\xe1\xba\x84"",\n    ""wdieresis"": ""\xe1\xba\x85"",\n    ""weierstrass"": ""\xe2\x84\x98"",\n    ""Wgrave"": ""\xe1\xba\x80"",\n    ""wgrave"": ""\xe1\xba\x81"",\n    ""WonSign"": ""\xe2\x82\xa9"",\n    ""Wsmall"": ""\xef\x9d\xb7"",\n    ""Xi"": ""\xce\x9e"",\n    ""xi"": ""\xce\xbe"",\n    ""Xsmall"": ""\xef\x9d\xb8"",\n    ""Yacute"": ""\xc3\x9d"",\n    ""yacute"": ""\xc3\xbd"",\n    ""Yacutesmall"": ""\xef\x9f\xbd"",\n    ""Ycircumflex"": ""\xc5\xb6"",\n    ""ycircumflex"": ""\xc5\xb7"",\n    ""ydiaeresis"": ""\xc3\xbf"",\n    ""Ydieresis"": ""\xc5\xb8"",\n    ""ydieresis"": ""\xc3\xbf"",\n    ""Ydieresissmall"": ""\xef\x9f\xbf"",\n    ""yen"": ""\xc2\xa5"",\n    ""Ygrave"": ""\xe1\xbb\xb2"",\n    ""ygrave"": ""\xe1\xbb\xb3"",\n    ""Ysmall"": ""\xef\x9d\xb9"",\n    ""Zacute"": ""\xc5\xb9"",\n    ""zacute"": ""\xc5\xba"",\n    ""Zcaron"": ""\xc5\xbd"",\n    ""zcaron"": ""\xc5\xbe"",\n    ""Zcaronsmall"": ""\xef\x9b\xbf"",\n    ""Zdotaccent"": ""\xc5\xbb"",\n    ""zdotaccent"": ""\xc5\xbc"",\n    ""zero"": ""0"",\n    ""zeroinferior"": ""\xe2\x82\x80"",\n    ""zerooldstyle"": ""\xef\x9c\xb0"",\n    ""zerosubscript"": ""\xe2\x82\x80"",\n    ""zerosuperior"": ""\xe2\x81\xb0"",\n    ""zeta"": ""\xce\xb6"",\n    ""Zeta"": ""\xce\x96"",\n    ""Zsmall"": ""\xef\x9d\xba"",\n}\nsided_modifiers = {\'ctrl\', \'alt\', \'shift\', \'windows\'}\nall_modifiers = {\'alt\', \'alt gr\', \'ctrl\', \'shift\', \'windows\'} | set(\'left \' + n for n in sided_modifiers) | set(\'right \' + n for n in sided_modifiers)\n\n# Platform-specific canonical overrides\n\nif platform.system() == \'Darwin\':\n    canonical_names.update({\n        ""command"": ""command"",\n        ""windows"": ""command"",\n        ""cmd"": ""command"",\n        ""win"": ""command"",\n        ""backspace"": ""delete"",\n        \'alt gr\': \'alt\' # Issue #117\n    })\n    all_modifiers = {\'alt\', \'ctrl\', \'shift\', \'windows\'}\nif platform.system() == \'Linux\':\n    canonical_names.update({\n        ""select"": ""end"",\n        ""find"": ""home"",\n        \'next\': \'page down\',\n        \'prior\': \'page up\',\n    })\n\ndef normalize_name(name):\n    """"""\n    Given a key name (e.g. ""LEFT CONTROL""), clean up the string and convert to\n    the canonical representation (e.g. ""left ctrl"") if one is known.\n    """"""\n    if not name or not isinstance(name, basestring):\n        raise ValueError(\'Can only normalize non-empty string names. Unexpected \'+ repr(name))\n\n    if len(name) > 1:\n        name = name.lower()\n    if name != \'_\' and \'_\' in name:\n        name = name.replace(\'_\', \' \')\n\n    return canonical_names.get(name, name)\n'"
External_Libraries/keyboard_master/keyboard/_darwinkeyboard.py,0,"b'import ctypes\nimport ctypes.util\nimport Quartz\nimport time\nimport os\nimport threading\nfrom AppKit import NSEvent\nfrom ._keyboard_event import KeyboardEvent, KEY_DOWN, KEY_UP\nfrom ._canonical_names import normalize_name\n\ntry: # Python 2/3 compatibility\n    unichr\nexcept NameError:\n    unichr = chr\n\nCarbon = ctypes.cdll.LoadLibrary(ctypes.util.find_library(\'Carbon\'))\n\nclass KeyMap(object):\n    non_layout_keys = dict((vk, normalize_name(name)) for vk, name in {\n        # Layout specific keys from https://stackoverflow.com/a/16125341/252218\n        # Unfortunately no source for layout-independent keys was found.\n        0x24: \'return\',\n        0x30: \'tab\',\n        0x31: \'space\',\n        0x33: \'delete\',\n        0x35: \'escape\',\n        0x37: \'command\',\n        0x38: \'shift\',\n        0x39: \'capslock\',\n        0x3a: \'option\',\n        0x3b: \'control\',\n        0x3c: \'right shift\',\n        0x3d: \'right option\',\n        0x3e: \'right control\',\n        0x3f: \'function\',\n        0x40: \'f17\',\n        0x48: \'volume up\',\n        0x49: \'volume down\',\n        0x4a: \'mute\',\n        0x4f: \'f18\',\n        0x50: \'f19\',\n        0x5a: \'f20\',\n        0x60: \'f5\',\n        0x61: \'f6\',\n        0x62: \'f7\',\n        0x63: \'f3\',\n        0x64: \'f8\',\n        0x65: \'f9\',\n        0x67: \'f11\',\n        0x69: \'f13\',\n        0x6a: \'f16\',\n        0x6b: \'f14\',\n        0x6d: \'f10\',\n        0x6f: \'f12\',\n        0x71: \'f15\',\n        0x72: \'help\',\n        0x73: \'home\',\n        0x74: \'page up\',\n        0x75: \'forward delete\',\n        0x76: \'f4\',\n        0x77: \'end\',\n        0x78: \'f2\',\n        0x79: \'page down\',\n        0x7a: \'f1\',\n        0x7b: \'left\',\n        0x7c: \'right\',\n        0x7d: \'down\',\n        0x7e: \'up\',\n    }.items())\n    layout_specific_keys = {}\n    def __init__(self):\n        # Virtual key codes are usually the same for any given key, unless you have a different\n        # keyboard layout. The only way I\'ve found to determine the layout relies on (supposedly\n        # deprecated) Carbon APIs. If there\'s a more modern way to do this, please update this\n        # section.\n\n        # Set up data types and exported values:\n\n        CFTypeRef = ctypes.c_void_p\n        CFDataRef = ctypes.c_void_p\n        CFIndex = ctypes.c_uint64\n        OptionBits = ctypes.c_uint32\n        UniCharCount = ctypes.c_uint8\n        UniChar = ctypes.c_uint16\n        UniChar4 = UniChar * 4\n\n        class CFRange(ctypes.Structure):\n            _fields_ = [(\'loc\', CFIndex),\n                        (\'len\', CFIndex)]\n\n        kTISPropertyUnicodeKeyLayoutData = ctypes.c_void_p.in_dll(Carbon, \'kTISPropertyUnicodeKeyLayoutData\')\n        shiftKey = 0x0200\n        alphaKey = 0x0400\n        optionKey = 0x0800\n        controlKey = 0x1000\n        kUCKeyActionDisplay = 3\n        kUCKeyTranslateNoDeadKeysBit = 0\n\n        # Set up function calls:\n        Carbon.CFDataGetBytes.argtypes = [CFDataRef] #, CFRange, UInt8\n        Carbon.CFDataGetBytes.restype = None\n        Carbon.CFDataGetLength.argtypes = [CFDataRef]\n        Carbon.CFDataGetLength.restype = CFIndex\n        Carbon.CFRelease.argtypes = [CFTypeRef]\n        Carbon.CFRelease.restype = None\n        Carbon.LMGetKbdType.argtypes = []\n        Carbon.LMGetKbdType.restype = ctypes.c_uint32\n        Carbon.TISCopyCurrentKeyboardInputSource.argtypes = []\n        Carbon.TISCopyCurrentKeyboardInputSource.restype = ctypes.c_void_p\n        Carbon.TISCopyCurrentASCIICapableKeyboardLayoutInputSource.argtypes = []\n        Carbon.TISCopyCurrentASCIICapableKeyboardLayoutInputSource.restype = ctypes.c_void_p\n        Carbon.TISGetInputSourceProperty.argtypes = [ctypes.c_void_p, ctypes.c_void_p]\n        Carbon.TISGetInputSourceProperty.restype = ctypes.c_void_p\n        Carbon.UCKeyTranslate.argtypes = [ctypes.c_void_p,\n                                          ctypes.c_uint16,\n                                          ctypes.c_uint16,\n                                          ctypes.c_uint32,\n                                          ctypes.c_uint32,\n                                          OptionBits,      # keyTranslateOptions\n                                          ctypes.POINTER(ctypes.c_uint32), # deadKeyState\n                                          UniCharCount,    # maxStringLength\n                                          ctypes.POINTER(UniCharCount), # actualStringLength\n                                          UniChar4]\n        Carbon.UCKeyTranslate.restype = ctypes.c_uint32\n\n        # Get keyboard layout\n        klis = Carbon.TISCopyCurrentKeyboardInputSource()\n        k_layout = Carbon.TISGetInputSourceProperty(klis, kTISPropertyUnicodeKeyLayoutData)\n        if k_layout is None:\n            klis = Carbon.TISCopyCurrentASCIICapableKeyboardLayoutInputSource()\n            k_layout = Carbon.TISGetInputSourceProperty(klis, kTISPropertyUnicodeKeyLayoutData)\n        k_layout_size = Carbon.CFDataGetLength(k_layout)\n        k_layout_buffer = ctypes.create_string_buffer(k_layout_size) # TODO - Verify this works instead of initializing with empty string\n        Carbon.CFDataGetBytes(k_layout, CFRange(0, k_layout_size), ctypes.byref(k_layout_buffer))\n\n        # Generate character representations of key codes\n        for key_code in range(0, 128):\n            # TODO - Possibly add alt modifier to key map\n            non_shifted_char = UniChar4()\n            shifted_char = UniChar4()\n            keys_down = ctypes.c_uint32()\n            char_count = UniCharCount()\n\n            retval = Carbon.UCKeyTranslate(k_layout_buffer,\n                                           key_code,\n                                           kUCKeyActionDisplay,\n                                           0, # No modifier\n                                           Carbon.LMGetKbdType(),\n                                           kUCKeyTranslateNoDeadKeysBit,\n                                           ctypes.byref(keys_down),\n                                           4,\n                                           ctypes.byref(char_count),\n                                           non_shifted_char)\n\n            non_shifted_key = u\'\'.join(unichr(non_shifted_char[i]) for i in range(char_count.value))\n\n            retval = Carbon.UCKeyTranslate(k_layout_buffer,\n                                           key_code,\n                                           kUCKeyActionDisplay,\n                                           shiftKey >> 8, # Shift\n                                           Carbon.LMGetKbdType(),\n                                           kUCKeyTranslateNoDeadKeysBit,\n                                           ctypes.byref(keys_down),\n                                           4,\n                                           ctypes.byref(char_count),\n                                           shifted_char)\n\n            shifted_key = u\'\'.join(unichr(shifted_char[i]) for i in range(char_count.value))\n\n            self.layout_specific_keys[key_code] = (non_shifted_key, shifted_key)\n        # Cleanup\n        Carbon.CFRelease(klis)\n\n    def character_to_vk(self, character):\n        """""" Returns a tuple of (scan_code, modifiers) where ``scan_code`` is a numeric scan code\n        and ``modifiers`` is an array of string modifier names (like \'shift\') """"""\n        for vk in self.non_layout_keys:\n            if self.non_layout_keys[vk] == character.lower():\n                return (vk, [])\n        for vk in self.layout_specific_keys:\n            if self.layout_specific_keys[vk][0] == character:\n                return (vk, [])\n            elif self.layout_specific_keys[vk][1] == character:\n                return (vk, [\'shift\'])\n        raise ValueError(""Unrecognized character: {}"".format(character))\n\n    def vk_to_character(self, vk, modifiers=[]):\n        """""" Returns a character corresponding to the specified scan code (with given\n        modifiers applied) """"""\n        if vk in self.non_layout_keys:\n            # Not a character\n            return self.non_layout_keys[vk]\n        elif vk in self.layout_specific_keys:\n            if \'shift\' in modifiers:\n                return self.layout_specific_keys[vk][1]\n            return self.layout_specific_keys[vk][0]\n        else:\n            # Invalid vk\n            raise ValueError(""Invalid scan code: {}"".format(vk))\n\n\nclass KeyController(object):\n    def __init__(self):\n        self.key_map = KeyMap()\n        self.current_modifiers = {\n            ""shift"": False,\n            ""caps"": False,\n            ""alt"": False,\n            ""ctrl"": False,\n            ""cmd"": False,\n        }\n        self.media_keys = {\n            \'KEYTYPE_SOUND_UP\': 0,\n            \'KEYTYPE_SOUND_DOWN\': 1,\n            \'KEYTYPE_BRIGHTNESS_UP\': 2,\n            \'KEYTYPE_BRIGHTNESS_DOWN\': 3,\n            \'KEYTYPE_CAPS_LOCK\': 4,\n            \'KEYTYPE_HELP\': 5,\n            \'POWER_KEY\': 6,\n            \'KEYTYPE_MUTE\': 7,\n            \'UP_ARROW_KEY\': 8,\n            \'DOWN_ARROW_KEY\': 9,\n            \'KEYTYPE_NUM_LOCK\': 10,\n            \'KEYTYPE_CONTRAST_UP\': 11,\n            \'KEYTYPE_CONTRAST_DOWN\': 12,\n            \'KEYTYPE_LAUNCH_PANEL\': 13,\n            \'KEYTYPE_EJECT\': 14,\n            \'KEYTYPE_VIDMIRROR\': 15,\n            \'KEYTYPE_PLAY\': 16,\n            \'KEYTYPE_NEXT\': 17,\n            \'KEYTYPE_PREVIOUS\': 18,\n            \'KEYTYPE_FAST\': 19,\n            \'KEYTYPE_REWIND\': 20,\n            \'KEYTYPE_ILLUMINATION_UP\': 21,\n            \'KEYTYPE_ILLUMINATION_DOWN\': 22,\n            \'KEYTYPE_ILLUMINATION_TOGGLE\': 23\n        }\n    \n    def press(self, key_code):\n        """""" Sends a \'down\' event for the specified scan code """"""\n        if key_code >= 128:\n            # Media key\n            ev = NSEvent.otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2_(\n                14, # type\n                (0, 0), # location\n                0xa00, # flags\n                0, # timestamp\n                0, # window\n                0, # ctx\n                8, # subtype\n                ((key_code-128) << 16) | (0xa << 8), # data1\n                -1 # data2\n            )\n            Quartz.CGEventPost(0, ev.CGEvent())\n        else:\n            # Regular key\n            # Apply modifiers if necessary\n            event_flags = 0\n            if self.current_modifiers[""shift""]:\n                event_flags += Quartz.kCGEventFlagMaskShift\n            if self.current_modifiers[""caps""]:\n                event_flags += Quartz.kCGEventFlagMaskAlphaShift\n            if self.current_modifiers[""alt""]:\n                event_flags += Quartz.kCGEventFlagMaskAlternate\n            if self.current_modifiers[""ctrl""]:\n                event_flags += Quartz.kCGEventFlagMaskControl\n            if self.current_modifiers[""cmd""]:\n                event_flags += Quartz.kCGEventFlagMaskCommand\n            \n            # Update modifiers if necessary\n            if key_code == 0x37: # cmd\n                self.current_modifiers[""cmd""] = True\n            elif key_code == 0x38 or key_code == 0x3C: # shift or right shift\n                self.current_modifiers[""shift""] = True\n            elif key_code == 0x39: # caps lock\n                self.current_modifiers[""caps""] = True\n            elif key_code == 0x3A: # alt\n                self.current_modifiers[""alt""] = True\n            elif key_code == 0x3B: # ctrl\n                self.current_modifiers[""ctrl""] = True\n            event = Quartz.CGEventCreateKeyboardEvent(None, key_code, True)\n            Quartz.CGEventSetFlags(event, event_flags)\n            Quartz.CGEventPost(Quartz.kCGHIDEventTap, event)\n            time.sleep(0.01)\n\n    def release(self, key_code):\n        """""" Sends an \'up\' event for the specified scan code """"""\n        if key_code >= 128:\n            # Media key\n            ev = NSEvent.otherEventWithType_location_modifierFlags_timestamp_windowNumber_context_subtype_data1_data2_(\n                14, # type\n                (0, 0), # location\n                0xb00, # flags\n                0, # timestamp\n                0, # window\n                0, # ctx\n                8, # subtype\n                ((key_code-128) << 16) | (0xb << 8), # data1\n                -1 # data2\n            )\n            Quartz.CGEventPost(0, ev.CGEvent())\n        else:\n            # Regular key\n            # Update modifiers if necessary\n            if key_code == 0x37: # cmd\n                self.current_modifiers[""cmd""] = False\n            elif key_code == 0x38 or key_code == 0x3C: # shift or right shift\n                self.current_modifiers[""shift""] = False\n            elif key_code == 0x39: # caps lock\n                self.current_modifiers[""caps""] = False\n            elif key_code == 0x3A: # alt\n                self.current_modifiers[""alt""] = False\n            elif key_code == 0x3B: # ctrl\n                self.current_modifiers[""ctrl""] = False\n\n            # Apply modifiers if necessary\n            event_flags = 0\n            if self.current_modifiers[""shift""]:\n                event_flags += Quartz.kCGEventFlagMaskShift\n            if self.current_modifiers[""caps""]:\n                event_flags += Quartz.kCGEventFlagMaskAlphaShift\n            if self.current_modifiers[""alt""]:\n                event_flags += Quartz.kCGEventFlagMaskAlternate\n            if self.current_modifiers[""ctrl""]:\n                event_flags += Quartz.kCGEventFlagMaskControl\n            if self.current_modifiers[""cmd""]:\n                event_flags += Quartz.kCGEventFlagMaskCommand\n            event = Quartz.CGEventCreateKeyboardEvent(None, key_code, False)\n            Quartz.CGEventSetFlags(event, event_flags)\n            Quartz.CGEventPost(Quartz.kCGHIDEventTap, event)\n            time.sleep(0.01)\n\n    def map_char(self, character):\n        if character in self.media_keys:\n            return (128+self.media_keys[character],[])\n        else:\n            return self.key_map.character_to_vk(character)\n    def map_scan_code(self, scan_code):\n        if scan_code >= 128:\n            character = [k for k, v in enumerate(self.media_keys) if v == scan_code-128]\n            if len(character):\n                return character[0]\n            return None\n        else:\n            return self.key_map.vk_to_character(scan_code)\n\nclass KeyEventListener(object):\n    def __init__(self, callback, blocking=False):\n        self.blocking = blocking\n        self.callback = callback\n        self.listening = True\n        self.tap = None\n\n    def run(self):\n        """""" Creates a listener and loops while waiting for an event. Intended to run as\n        a background thread. """"""\n        self.tap = Quartz.CGEventTapCreate(\n            Quartz.kCGSessionEventTap,\n            Quartz.kCGHeadInsertEventTap,\n            Quartz.kCGEventTapOptionDefault,\n            Quartz.CGEventMaskBit(Quartz.kCGEventKeyDown) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventKeyUp) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventFlagsChanged),\n            self.handler,\n            None)\n        loopsource = Quartz.CFMachPortCreateRunLoopSource(None, self.tap, 0)\n        loop = Quartz.CFRunLoopGetCurrent()\n        Quartz.CFRunLoopAddSource(loop, loopsource, Quartz.kCFRunLoopDefaultMode)\n        Quartz.CGEventTapEnable(self.tap, True)\n\n        while self.listening:\n            Quartz.CFRunLoopRunInMode(Quartz.kCFRunLoopDefaultMode, 5, False)\n\n    def handler(self, proxy, e_type, event, refcon):\n        scan_code = Quartz.CGEventGetIntegerValueField(event, Quartz.kCGKeyboardEventKeycode)\n        key_name = name_from_scancode(scan_code)\n        flags = Quartz.CGEventGetFlags(event)\n        event_type = """"\n        is_keypad = (flags & Quartz.kCGEventFlagMaskNumericPad)\n        if e_type == Quartz.kCGEventKeyDown:\n            event_type = ""down""\n        elif e_type == Quartz.kCGEventKeyUp:\n            event_type = ""up""\n        elif e_type == Quartz.kCGEventFlagsChanged:\n            if key_name.endswith(""shift"") and (flags & Quartz.kCGEventFlagMaskShift):\n                event_type = ""down""\n            elif key_name == ""caps lock"" and (flags & Quartz.kCGEventFlagMaskAlphaShift):\n                event_type = ""down""\n            elif (key_name.endswith(""option"") or key_name.endswith(""alt"")) and (flags & Quartz.kCGEventFlagMaskAlternate):\n                event_type = ""down""\n            elif key_name == ""ctrl"" and (flags & Quartz.kCGEventFlagMaskControl):\n                event_type = ""down""\n            elif key_name == ""command"" and (flags & Quartz.kCGEventFlagMaskCommand):\n                event_type = ""down""\n            else:\n                event_type = ""up""\n\n        if self.blocking:\n            return None\n\n        self.callback(KeyboardEvent(event_type, scan_code, name=key_name, is_keypad=is_keypad))\n        return event\n\nkey_controller = KeyController()\n\n"""""" Exported functions below """"""\n\ndef init():\n    key_controller = KeyController()\n\ndef press(scan_code):\n    """""" Sends a \'down\' event for the specified scan code """"""\n    key_controller.press(scan_code)\n\ndef release(scan_code):\n    """""" Sends an \'up\' event for the specified scan code """"""\n    key_controller.release(scan_code)\n\ndef map_name(name):\n    """""" Returns a tuple of (scan_code, modifiers) where ``scan_code`` is a numeric scan code \n    and ``modifiers`` is an array of string modifier names (like \'shift\') """"""\n    yield key_controller.map_char(name)\n\ndef name_from_scancode(scan_code):\n    """""" Returns the name or character associated with the specified key code """"""\n    return key_controller.map_scan_code(scan_code)\n\ndef listen(callback):\n    if not os.geteuid() == 0:\n        raise OSError(""Error 13 - Must be run as administrator"")\n    KeyEventListener(callback).run()\n\ndef type_unicode(character):\n    OUTPUT_SOURCE = Quartz.CGEventSourceCreate(Quartz.kCGEventSourceStateHIDSystemState)\n    # Key down\n    event = Quartz.CGEventCreateKeyboardEvent(OUTPUT_SOURCE, 0, True)\n    Quartz.CGEventKeyboardSetUnicodeString(event, len(character.encode(\'utf-16-le\')) // 2, character)\n    Quartz.CGEventPost(Quartz.kCGSessionEventTap, event)\n    # Key up\n    event = Quartz.CGEventCreateKeyboardEvent(OUTPUT_SOURCE, 0, False)\n    Quartz.CGEventKeyboardSetUnicodeString(event, len(character.encode(\'utf-16-le\')) // 2, character)\n    Quartz.CGEventPost(Quartz.kCGSessionEventTap, event)'"
External_Libraries/keyboard_master/keyboard/_darwinmouse.py,0,"b'import os\nimport datetime\nimport threading\nimport Quartz\nfrom ._mouse_event import ButtonEvent, WheelEvent, MoveEvent, LEFT, RIGHT, MIDDLE, X, X2, UP, DOWN\n\n_button_mapping = {\n    LEFT: (Quartz.kCGMouseButtonLeft, Quartz.kCGEventLeftMouseDown, Quartz.kCGEventLeftMouseUp, Quartz.kCGEventLeftMouseDragged),\n    RIGHT: (Quartz.kCGMouseButtonRight, Quartz.kCGEventRightMouseDown, Quartz.kCGEventRightMouseUp, Quartz.kCGEventRightMouseDragged),\n    MIDDLE: (Quartz.kCGMouseButtonCenter, Quartz.kCGEventOtherMouseDown, Quartz.kCGEventOtherMouseUp, Quartz.kCGEventOtherMouseDragged)\n}\n_button_state = {\n    LEFT: False,\n    RIGHT: False,\n    MIDDLE: False\n}\n_last_click = {\n    ""time"": None,\n    ""button"": None,\n    ""position"": None,\n    ""click_count"": 0\n}\n\nclass MouseEventListener(object):\n    def __init__(self, callback, blocking=False):\n        self.blocking = blocking\n        self.callback = callback\n        self.listening = True\n\n    def run(self):\n        """""" Creates a listener and loops while waiting for an event. Intended to run as\n        a background thread. """"""\n        self.tap = Quartz.CGEventTapCreate(\n            Quartz.kCGSessionEventTap,\n            Quartz.kCGHeadInsertEventTap,\n            Quartz.kCGEventTapOptionDefault,\n            Quartz.CGEventMaskBit(Quartz.kCGEventLeftMouseDown) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventLeftMouseUp) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventRightMouseDown) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventRightMouseUp) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventOtherMouseDown) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventOtherMouseUp) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventMouseMoved) |\n            Quartz.CGEventMaskBit(Quartz.kCGEventScrollWheel),\n            self.handler,\n            None)\n        loopsource = Quartz.CFMachPortCreateRunLoopSource(None, self.tap, 0)\n        loop = Quartz.CFRunLoopGetCurrent()\n        Quartz.CFRunLoopAddSource(loop, loopsource, Quartz.kCFRunLoopDefaultMode)\n        Quartz.CGEventTapEnable(self.tap, True)\n\n        while self.listening:\n            Quartz.CFRunLoopRunInMode(Quartz.kCFRunLoopDefaultMode, 5, False)\n\n    def handler(self, proxy, e_type, event, refcon):\n        # TODO Separate event types by button/wheel/move\n        scan_code = Quartz.CGEventGetIntegerValueField(event, Quartz.kCGKeyboardEventKeycode)\n        key_name = name_from_scancode(scan_code)\n        flags = Quartz.CGEventGetFlags(event)\n        event_type = """"\n        is_keypad = (flags & Quartz.kCGEventFlagMaskNumericPad)\n        if e_type == Quartz.kCGEventKeyDown:\n            event_type = ""down""\n        elif e_type == Quartz.kCGEventKeyUp:\n            event_type = ""up""\n\n        if self.blocking:\n            return None\n\n        self.callback(KeyboardEvent(event_type, scan_code, name=key_name, is_keypad=is_keypad))\n        return event\n\n# Exports\n\ndef init():\n    """""" Initializes mouse state """"""\n    pass\n\ndef listen(queue):\n    """""" Appends events to the queue (ButtonEvent, WheelEvent, and MoveEvent). """"""\n    if not os.geteuid() == 0:\n        raise OSError(""Error 13 - Must be run as administrator"")\n    listener = MouseEventListener(lambda e: queue.put(e) or is_allowed(e.name, e.event_type == KEY_UP))\n    t = threading.Thread(target=listener.run, args=())\n    t.daemon = True\n    t.start()\n\ndef press(button=LEFT):\n    """""" Sends a down event for the specified button, using the provided constants """"""\n    location = get_position()\n    button_code, button_down, _, _ = _button_mapping[button]\n    e = Quartz.CGEventCreateMouseEvent(\n        None,\n        button_down,\n        location,\n        button_code)\n\n    # Check if this is a double-click (same location within the last 300ms)\n    if _last_click[""time""] is not None and datetime.datetime.now() - _last_click[""time""] < datetime.timedelta(seconds=0.3) and _last_click[""button""] == button and _last_click[""position""] == location:\n        # Repeated Click\n        _last_click[""click_count""] = min(3, _last_click[""click_count""]+1)\n    else:\n        # Not a double-click - Reset last click\n        _last_click[""click_count""] = 1\n    Quartz.CGEventSetIntegerValueField(\n        e,\n        Quartz.kCGMouseEventClickState,\n        _last_click[""click_count""])\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e)\n    _button_state[button] = True\n    _last_click[""time""] = datetime.datetime.now()\n    _last_click[""button""] = button\n    _last_click[""position""] = location\n\ndef release(button=LEFT):\n    """""" Sends an up event for the specified button, using the provided constants """"""\n    location = get_position()\n    button_code, _, button_up, _ = _button_mapping[button]\n    e = Quartz.CGEventCreateMouseEvent(\n        None,\n        button_up,\n        location,\n        button_code)\n\n    if _last_click[""time""] is not None and _last_click[""time""] > datetime.datetime.now() - datetime.timedelta(microseconds=300000) and _last_click[""button""] == button and _last_click[""position""] == location:\n        # Repeated Click\n        Quartz.CGEventSetIntegerValueField(\n            e,\n            Quartz.kCGMouseEventClickState,\n            _last_click[""click_count""])\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e)\n    _button_state[button] = False\n\ndef wheel(delta=1):\n    """""" Sends a wheel event for the provided number of clicks. May be negative to reverse\n    direction. """"""\n    location = get_position()\n    e = Quartz.CGEventCreateMouseEvent(\n        None,\n        Quartz.kCGEventScrollWheel,\n        location,\n        Quartz.kCGMouseButtonLeft)\n    e2 = Quartz.CGEventCreateScrollWheelEvent(\n        None,\n        Quartz.kCGScrollEventUnitLine,\n        1,\n        delta)\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e)\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e2)\n\ndef move_to(x, y):\n    """""" Sets the mouse\'s location to the specified coordinates. """"""\n    for b in _button_state:\n        if _button_state[b]:\n            e = Quartz.CGEventCreateMouseEvent(\n                None,\n                _button_mapping[b][3], # Drag Event\n                (x, y),\n                _button_mapping[b][0])\n            break\n    else:\n        e = Quartz.CGEventCreateMouseEvent(\n            None,\n            Quartz.kCGEventMouseMoved,\n            (x, y),\n            Quartz.kCGMouseButtonLeft)\n    Quartz.CGEventPost(Quartz.kCGHIDEventTap, e)\n\ndef get_position():\n    """""" Returns the mouse\'s location as a tuple of (x, y). """"""\n    e = Quartz.CGEventCreate(None)\n    point = Quartz.CGEventGetLocation(e)\n    return (point.x, point.y)'"
External_Libraries/keyboard_master/keyboard/_generic.py,0,"b'# -*- coding: utf-8 -*-\nfrom threading import Thread, Lock\nimport traceback\nimport functools\n\ntry:\n    from queue import Queue\nexcept ImportError:\n    from Queue import Queue\n\nclass GenericListener(object):\n    lock = Lock()\n\n    def __init__(self):\n        self.handlers = []\n        self.listening = False\n        self.queue = Queue()\n\n    def invoke_handlers(self, event):\n        for handler in self.handlers:\n            try:\n                if handler(event):\n                    # Stop processing this hotkey.\n                    return 1\n            except Exception as e:\n                traceback.print_exc()\n\n    def start_if_necessary(self):\n        """"""\n        Starts the listening thread if it wans\'t already.\n        """"""\n        self.lock.acquire()\n        try:\n            if not self.listening:\n                self.init()\n\n                self.listening = True\n                self.listening_thread = Thread(target=self.listen)\n                self.listening_thread.daemon = True\n                self.listening_thread.start()\n\n                self.processing_thread = Thread(target=self.process)\n                self.processing_thread.daemon = True\n                self.processing_thread.start()\n        finally:\n            self.lock.release()\n\n    def pre_process_event(self, event):\n        raise NotImplementedError(\'This method should be implemented in the child class.\')\n\n    def process(self):\n        """"""\n        Loops over the underlying queue of events and processes them in order.\n        """"""\n        assert self.queue is not None\n        while True:\n            event = self.queue.get()\n            if self.pre_process_event(event):\n                self.invoke_handlers(event)\n            self.queue.task_done()\n            \n    def add_handler(self, handler):\n        """"""\n        Adds a function to receive each event captured, starting the capturing\n        process if necessary.\n        """"""\n        self.start_if_necessary()\n        self.handlers.append(handler)\n\n    def remove_handler(self, handler):\n        """""" Removes a previously added event handler. """"""\n        while handler in self.handlers:\n            self.handlers.remove(handler)\n'"
External_Libraries/keyboard_master/keyboard/_keyboard_event.py,0,"b""# -*- coding: utf-8 -*-\n\nfrom time import time as now\nimport json\nfrom ._canonical_names import canonical_names, normalize_name\n\ntry:\n    basestring\nexcept NameError:\n    basestring = str\n\nKEY_DOWN = 'down'\nKEY_UP = 'up'\n\nclass KeyboardEvent(object):\n    event_type = None\n    scan_code = None\n    name = None\n    time = None\n    device = None\n    modifiers = None\n    is_keypad = None\n\n    def __init__(self, event_type, scan_code, name=None, time=None, device=None, modifiers=None, is_keypad=None):\n        self.event_type = event_type\n        self.scan_code = scan_code\n        self.time = now() if time is None else time\n        self.device = device\n        self.is_keypad = is_keypad\n        self.modifiers = modifiers\n        if name:\n            self.name = normalize_name(name)\n\n    def to_json(self, ensure_ascii=False):\n        attrs = dict(\n            (attr, getattr(self, attr)) for attr in ['event_type', 'scan_code', 'name', 'time', 'device', 'is_keypad']\n            if not attr.startswith('_') and getattr(self, attr) is not None\n        )\n        return json.dumps(attrs, ensure_ascii=ensure_ascii)\n\n    def __repr__(self):\n        return 'KeyboardEvent({} {})'.format(self.name or 'Unknown {}'.format(self.scan_code), self.event_type)\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, KeyboardEvent)\n            and self.event_type == other.event_type\n            and (\n                not self.scan_code or not other.scan_code or self.scan_code == other.scan_code\n            ) and (\n                not self.name or not other.name or self.name == other.name\n            )\n        )\n"""
External_Libraries/keyboard_master/keyboard/_keyboard_tests.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nSide effects are avoided using two techniques:\n\n- Low level OS requests (keyboard._os_keyboard) are mocked out by rewriting\nthe functions at that namespace. This includes a list of dummy keys.\n- Events are pumped manually by the main test class, and accepted events\nare tested against expected values.\n\nFake user events are appended to `input_events`, passed through\nkeyboard,_listener.direct_callback, then, if accepted, appended to\n`output_events`. Fake OS events (keyboard.press) are processed\nand added to `output_events` immediately, mimicking real functionality.\n""""""\nfrom __future__ import print_function\n\nimport unittest\nimport time\n\nimport keyboard\nfrom ._keyboard_event import KeyboardEvent, KEY_DOWN, KEY_UP\n\ndummy_keys = {\n    \'space\': [(0, [])],\n\n    \'a\': [(1, [])],\n    \'b\': [(2, [])],\n    \'c\': [(3, [])],\n    \'A\': [(1, [\'shift\']), (-1, [])],\n    \'B\': [(2, [\'shift\']), (-2, [])],\n    \'C\': [(3, [\'shift\']), (-3, [])],\n\n    \'alt\': [(4, [])],\n    \'left alt\': [(4, [])],\n\n    \'left shift\': [(5, [])],\n    \'right shift\': [(6, [])],\n\n    \'left ctrl\': [(7, [])],\n\n    \'backspace\': [(8, [])],\n    \'caps lock\': [(9, [])],\n\n    \'+\': [(10, [])],\n    \',\': [(11, [])],\n    \'_\': [(12, [])],\n\n    \'none\': [],\n    \'duplicated\': [(20, []), (20, [])],\n}\n\ndef make_event(event_type, name, scan_code=None, time=0):\n    return KeyboardEvent(event_type=event_type, scan_code=scan_code or dummy_keys[name][0][0], name=name, time=time)\n\n# Used when manually pumping events.\ninput_events = []\noutput_events = []\n\ndef send_instant_event(event):\n    if keyboard._listener.direct_callback(event):\n        output_events.append(event)\n\n# Mock out side effects.\nkeyboard._os_keyboard.init = lambda: None\nkeyboard._os_keyboard.listen = lambda callback: None\nkeyboard._os_keyboard.map_name = dummy_keys.__getitem__\nkeyboard._os_keyboard.press = lambda scan_code: send_instant_event(make_event(KEY_DOWN, None, scan_code))\nkeyboard._os_keyboard.release = lambda scan_code: send_instant_event(make_event(KEY_UP, None, scan_code))\nkeyboard._os_keyboard.type_unicode = lambda char: output_events.append(KeyboardEvent(event_type=KEY_DOWN, scan_code=999, name=char))\n\n# Shortcuts for defining test inputs and expected outputs.\n# Usage: d_shift + d_a + u_a + u_shift\nd_a = [make_event(KEY_DOWN, \'a\')]\nu_a = [make_event(KEY_UP, \'a\')]\ndu_a = d_a+u_a\nd_b = [make_event(KEY_DOWN, \'b\')]\nu_b = [make_event(KEY_UP, \'b\')]\ndu_b = d_b+u_b\nd_c = [make_event(KEY_DOWN, \'c\')]\nu_c = [make_event(KEY_UP, \'c\')]\ndu_c = d_c+u_c\nd_ctrl = [make_event(KEY_DOWN, \'left ctrl\')]\nu_ctrl = [make_event(KEY_UP, \'left ctrl\')]\ndu_ctrl = d_ctrl+u_ctrl\nd_shift = [make_event(KEY_DOWN, \'left shift\')]\nu_shift = [make_event(KEY_UP, \'left shift\')]\ndu_shift = d_shift+u_shift\nd_alt = [make_event(KEY_DOWN, \'alt\')]\nu_alt = [make_event(KEY_UP, \'alt\')]\ndu_alt = d_alt+u_alt\ndu_backspace = [make_event(KEY_DOWN, \'backspace\'), make_event(KEY_UP, \'backspace\')]\ndu_capslock = [make_event(KEY_DOWN, \'caps lock\'), make_event(KEY_UP, \'caps lock\')]\nd_space = [make_event(KEY_DOWN, \'space\')]\nu_space = [make_event(KEY_UP, \'space\')]\ndu_space = [make_event(KEY_DOWN, \'space\'), make_event(KEY_UP, \'space\')]\n\ntrigger = lambda e=None: keyboard.press(999)\ntriggered_event = [KeyboardEvent(KEY_DOWN, scan_code=999)]\n\nclass TestKeyboard(unittest.TestCase):\n    def tearDown(self):\n        keyboard.unhook_all()\n        #self.assertEquals(keyboard._hooks, {})\n        #self.assertEquals(keyboard._hotkeys, {})\n\n    def setUp(self):\n        #keyboard._hooks.clear()\n        #keyboard._hotkeys.clear()\n        del input_events[:]\n        del output_events[:]\n        keyboard._recording = None\n        keyboard._pressed_events.clear()\n        keyboard._physically_pressed_keys.clear()\n        keyboard._logically_pressed_keys.clear()\n        keyboard._hotkeys.clear()\n        keyboard._listener.init()\n        keyboard._word_listeners = {} \n\n    def do(self, manual_events, expected=None):\n        input_events.extend(manual_events)\n        while input_events:\n            event = input_events.pop(0)\n            if keyboard._listener.direct_callback(event):\n                output_events.append(event)\n        if expected is not None:\n            to_names = lambda es: \'+\'.join((\'d\' if e.event_type == KEY_DOWN else \'u\') + \'_\' + str(e.scan_code) for e in es)\n            self.assertEqual(to_names(output_events), to_names(expected))\n        del output_events[:]\n\n        keyboard._listener.queue.join()\n\n    def test_event_json(self):\n        event = make_event(KEY_DOWN, u\'\xc3\xa1 \\\'""\', 999)\n        import json\n        self.assertEqual(event, KeyboardEvent(**json.loads(event.to_json())))\n\n    def test_is_modifier_name(self):\n        for name in keyboard.all_modifiers:\n            self.assertTrue(keyboard.is_modifier(name))\n    def test_is_modifier_scan_code(self):\n        for i in range(10):\n            self.assertEqual(keyboard.is_modifier(i), i in [4, 5, 6, 7])\n\n    def test_key_to_scan_codes_brute(self):\n        for name, entries in dummy_keys.items():\n            if name in [\'none\', \'duplicated\']: continue\n            expected = tuple(scan_code for scan_code, modifiers in entries)\n            self.assertEqual(keyboard.key_to_scan_codes(name), expected)\n    def test_key_to_scan_code_from_scan_code(self):\n        for i in range(10):\n            self.assertEqual(keyboard.key_to_scan_codes(i), (i,))\n    def test_key_to_scan_code_from_letter(self):\n        self.assertEqual(keyboard.key_to_scan_codes(\'a\'), (1,))\n        self.assertEqual(keyboard.key_to_scan_codes(\'A\'), (1,-1))\n    def test_key_to_scan_code_from_normalized(self):\n        self.assertEqual(keyboard.key_to_scan_codes(\'shift\'), (5,6))\n        self.assertEqual(keyboard.key_to_scan_codes(\'SHIFT\'), (5,6))\n        self.assertEqual(keyboard.key_to_scan_codes(\'ctrl\'), keyboard.key_to_scan_codes(\'CONTROL\'))\n    def test_key_to_scan_code_from_sided_modifier(self):\n        self.assertEqual(keyboard.key_to_scan_codes(\'left shift\'), (5,))\n        self.assertEqual(keyboard.key_to_scan_codes(\'right shift\'), (6,))\n    def test_key_to_scan_code_underscores(self):\n        self.assertEqual(keyboard.key_to_scan_codes(\'_\'), (12,))\n        self.assertEqual(keyboard.key_to_scan_codes(\'right_shift\'), (6,))\n    def test_key_to_scan_code_error_none(self):\n        with self.assertRaises(ValueError):\n            keyboard.key_to_scan_codes(None)\n    def test_key_to_scan_code_error_empty(self):\n        with self.assertRaises(ValueError):\n            keyboard.key_to_scan_codes(\'\')\n    def test_key_to_scan_code_error_other(self):\n        with self.assertRaises(ValueError):\n            keyboard.key_to_scan_codes({})\n    def test_key_to_scan_code_list(self):\n        self.assertEqual(keyboard.key_to_scan_codes([10, 5, \'a\']), (10, 5, 1))\n    def test_key_to_scan_code_empty(self):\n        with self.assertRaises(ValueError):\n            keyboard.key_to_scan_codes(\'none\')\n    def test_key_to_scan_code_duplicated(self):\n        self.assertEqual(keyboard.key_to_scan_codes(\'duplicated\'), (20,))\n\n    def test_parse_hotkey_simple(self):\n        self.assertEqual(keyboard.parse_hotkey(\'a\'), (((1,),),))\n        self.assertEqual(keyboard.parse_hotkey(\'A\'), (((1,-1),),))\n    def test_parse_hotkey_separators(self):\n        self.assertEqual(keyboard.parse_hotkey(\'+\'), keyboard.parse_hotkey(\'plus\'))\n        self.assertEqual(keyboard.parse_hotkey(\',\'), keyboard.parse_hotkey(\'comma\'))\n    def test_parse_hotkey_keys(self):\n        self.assertEqual(keyboard.parse_hotkey(\'left shift + a\'), (((5,), (1,),),))\n        self.assertEqual(keyboard.parse_hotkey(\'left shift+a\'), (((5,), (1,),),))\n    def test_parse_hotkey_simple_steps(self):\n        self.assertEqual(keyboard.parse_hotkey(\'a,b\'), (((1,),),((2,),)))\n        self.assertEqual(keyboard.parse_hotkey(\'a, b\'), (((1,),),((2,),)))\n    def test_parse_hotkey_steps(self):\n        self.assertEqual(keyboard.parse_hotkey(\'a+b, b+c\'), (((1,),(2,)),((2,),(3,))))\n    def test_parse_hotkey_example(self):\n        alt_codes = keyboard.key_to_scan_codes(\'alt\')\n        shift_codes = keyboard.key_to_scan_codes(\'shift\')\n        a_codes = keyboard.key_to_scan_codes(\'a\')\n        b_codes = keyboard.key_to_scan_codes(\'b\')\n        c_codes = keyboard.key_to_scan_codes(\'c\')\n        self.assertEqual(keyboard.parse_hotkey(""alt+shift+a, alt+b, c""), ((alt_codes, shift_codes, a_codes), (alt_codes, b_codes), (c_codes,)))\n    def test_parse_hotkey_list_scan_codes(self):\n        self.assertEqual(keyboard.parse_hotkey([1, 2, 3]), (((1,), (2,), (3,)),))\n    def test_parse_hotkey_deep_list_scan_codes(self):\n        result = keyboard.parse_hotkey(\'a\')\n        self.assertEqual(keyboard.parse_hotkey(result), (((1,),),))\n    def test_parse_hotkey_list_names(self):\n        self.assertEqual(keyboard.parse_hotkey([\'a\', \'b\', \'c\']), (((1,), (2,), (3,)),))\n\n    def test_is_pressed_none(self):\n        self.assertFalse(keyboard.is_pressed(\'a\'))\n    def test_is_pressed_true(self):\n        self.do(d_a)\n        self.assertTrue(keyboard.is_pressed(\'a\'))\n    def test_is_pressed_true_scan_code_true(self):\n        self.do(d_a)\n        self.assertTrue(keyboard.is_pressed(1))\n    def test_is_pressed_true_scan_code_false(self):\n        self.do(d_a)\n        self.assertFalse(keyboard.is_pressed(2))\n    def test_is_pressed_true_scan_code_invalid(self):\n        self.do(d_a)\n        self.assertFalse(keyboard.is_pressed(-1))\n    def test_is_pressed_false(self):\n        self.do(d_a+u_a+d_b)\n        self.assertFalse(keyboard.is_pressed(\'a\'))\n        self.assertTrue(keyboard.is_pressed(\'b\'))\n    def test_is_pressed_hotkey_true(self):\n        self.do(d_shift+d_a)\n        self.assertTrue(keyboard.is_pressed(\'shift+a\'))\n    def test_is_pressed_hotkey_false(self):\n        self.do(d_shift+d_a+u_a)\n        self.assertFalse(keyboard.is_pressed(\'shift+a\'))\n    def test_is_pressed_multi_step_fail(self):\n        self.do(u_a+d_a)\n        with self.assertRaises(ValueError):\n            keyboard.is_pressed(\'a, b\')\n\n    def test_send_single_press_release(self):\n        keyboard.send(\'a\', do_press=True, do_release=True)\n        self.do([], d_a+u_a)\n    def test_send_single_press(self):\n        keyboard.send(\'a\', do_press=True, do_release=False)\n        self.do([], d_a)\n    def test_send_single_release(self):\n        keyboard.send(\'a\', do_press=False, do_release=True)\n        self.do([], u_a)\n    def test_send_single_none(self):\n        keyboard.send(\'a\', do_press=False, do_release=False)\n        self.do([], [])\n    def test_press(self):\n        keyboard.press(\'a\')\n        self.do([], d_a)\n    def test_release(self):\n        keyboard.release(\'a\')\n        self.do([], u_a)\n    def test_press_and_release(self):\n        keyboard.press_and_release(\'a\')\n        self.do([], d_a+u_a)\n\n    def test_send_modifier_press_release(self):\n        keyboard.send(\'ctrl+a\', do_press=True, do_release=True)\n        self.do([], d_ctrl+d_a+u_a+u_ctrl)\n    def test_send_modifiers_release(self):\n        keyboard.send(\'ctrl+shift+a\', do_press=False, do_release=True)\n        self.do([], u_a+u_shift+u_ctrl)\n\n    def test_call_later(self):\n        triggered = []\n        def fn(arg1, arg2):\n            assert arg1 == 1 and arg2 == 2\n            triggered.append(True)\n        keyboard.call_later(fn, (1, 2), 0.01)\n        self.assertFalse(triggered)\n        time.sleep(0.05)\n        self.assertTrue(triggered)\n\n    def test_hook_nonblocking(self):\n        self.i = 0\n        def count(e):\n            self.assertEqual(e.name, \'a\')\n            self.i += 1\n        hook = keyboard.hook(count, suppress=False)\n        self.do(d_a+u_a, d_a+u_a)\n        self.assertEqual(self.i, 2)\n        keyboard.unhook(hook)\n        self.do(d_a+u_a, d_a+u_a)\n        self.assertEqual(self.i, 2)\n        keyboard.hook(count, suppress=False)\n        self.do(d_a+u_a, d_a+u_a)\n        self.assertEqual(self.i, 4)\n        keyboard.unhook_all()\n        self.do(d_a+u_a, d_a+u_a)\n        self.assertEqual(self.i, 4)\n    def test_hook_blocking(self):\n        self.i = 0\n        def count(e):\n            self.assertIn(e.name, [\'a\', \'b\'])\n            self.i += 1\n            return e.name == \'b\'\n        hook = keyboard.hook(count, suppress=True)\n        self.do(d_a+d_b, d_b)\n        self.assertEqual(self.i, 2)\n        keyboard.unhook(hook)\n        self.do(d_a+d_b, d_a+d_b)\n        self.assertEqual(self.i, 2)\n        keyboard.hook(count, suppress=True)\n        self.do(d_a+d_b, d_b)\n        self.assertEqual(self.i, 4)\n        keyboard.unhook_all()\n        self.do(d_a+d_b, d_a+d_b)\n        self.assertEqual(self.i, 4)\n    def test_on_press_nonblocking(self):\n        keyboard.on_press(lambda e: self.assertEqual(e.name, \'a\') and self.assertEqual(e.event_type, KEY_DOWN))\n        self.do(d_a+u_a)\n    def test_on_press_blocking(self):\n        keyboard.on_press(lambda e: e.scan_code == 1, suppress=True)\n        self.do([make_event(KEY_DOWN, \'A\', -1)] + d_a, d_a)\n    def test_on_release(self):\n        keyboard.on_release(lambda e: self.assertEqual(e.name, \'a\') and self.assertEqual(e.event_type, KEY_UP))\n        self.do(d_a+u_a)\n\n    def test_hook_key_invalid(self):\n        with self.assertRaises(ValueError):\n            keyboard.hook_key(\'invalid\', lambda e: None)\n    def test_hook_key_nonblocking(self):\n        self.i = 0\n        def count(event):\n            self.i += 1\n        hook = keyboard.hook_key(\'A\', count)\n        self.do(d_a)\n        self.assertEqual(self.i, 1)\n        self.do(u_a+d_b)\n        self.assertEqual(self.i, 2)\n        self.do([make_event(KEY_DOWN, \'A\', -1)])\n        self.assertEqual(self.i, 3)\n        keyboard.unhook_key(hook)\n        self.do(d_a)\n        self.assertEqual(self.i, 3)\n    def test_hook_key_blocking(self):\n        self.i = 0\n        def count(event):\n            self.i += 1\n            return event.scan_code == 1\n        hook = keyboard.hook_key(\'A\', count, suppress=True)\n        self.do(d_a, d_a)\n        self.assertEqual(self.i, 1)\n        self.do(u_a+d_b, u_a+d_b)\n        self.assertEqual(self.i, 2)\n        self.do([make_event(KEY_DOWN, \'A\', -1)], [])\n        self.assertEqual(self.i, 3)\n        keyboard.unhook_key(hook)\n        self.do([make_event(KEY_DOWN, \'A\', -1)], [make_event(KEY_DOWN, \'A\', -1)])\n        self.assertEqual(self.i, 3)\n    def test_on_press_key_nonblocking(self):\n        keyboard.on_press_key(\'A\', lambda e: self.assertEqual(e.name, \'a\') and self.assertEqual(e.event_type, KEY_DOWN))\n        self.do(d_a+u_a+d_b+u_b)\n    def test_on_press_key_blocking(self):\n        keyboard.on_press_key(\'A\', lambda e: e.scan_code == 1, suppress=True)\n        self.do([make_event(KEY_DOWN, \'A\', -1)] + d_a, d_a)\n    def test_on_release_key(self):\n        keyboard.on_release_key(\'a\', lambda e: self.assertEqual(e.name, \'a\') and self.assertEqual(e.event_type, KEY_UP))\n        self.do(d_a+u_a)\n\n    def test_block_key(self):\n        blocked = keyboard.block_key(\'a\')\n        self.do(d_a+d_b, d_b)\n        self.do([make_event(KEY_DOWN, \'A\', -1)], [make_event(KEY_DOWN, \'A\', -1)])\n        keyboard.unblock_key(blocked)\n        self.do(d_a+d_b, d_a+d_b)\n    def test_block_key_ambiguous(self):\n        keyboard.block_key(\'A\')\n        self.do(d_a+d_b, d_b)\n        self.do([make_event(KEY_DOWN, \'A\', -1)], [])\n\n    def test_remap_key_simple(self):\n        mapped = keyboard.remap_key(\'a\', \'b\')\n        self.do(d_a+d_c+u_a, d_b+d_c+u_b)\n        keyboard.unremap_key(mapped)\n        self.do(d_a+d_c+u_a, d_a+d_c+u_a)\n    def test_remap_key_ambiguous(self):\n        keyboard.remap_key(\'A\', \'b\')\n        self.do(d_a+d_b, d_b+d_b)\n        self.do([make_event(KEY_DOWN, \'A\', -1)], d_b)\n    def test_remap_key_multiple(self):\n        mapped = keyboard.remap_key(\'a\', \'shift+b\')\n        self.do(d_a+d_c+u_a, d_shift+d_b+d_c+u_b+u_shift)\n        keyboard.unremap_key(mapped)\n        self.do(d_a+d_c+u_a, d_a+d_c+u_a)\n\n    def test_stash_state(self):\n        self.do(d_a+d_shift)\n        self.assertEqual(sorted(keyboard.stash_state()), [1, 5])\n        self.do([], u_a+u_shift)\n    def test_restore_state(self):\n        self.do(d_b)\n        keyboard.restore_state([1, 5])\n        self.do([], u_b+d_a+d_shift)\n    def test_restore_modifieres(self):\n        self.do(d_b)\n        keyboard.restore_modifiers([1, 5])\n        self.do([], u_b+d_shift)\n\n    def test_write_simple(self):\n        keyboard.write(\'a\', exact=False)\n        self.do([], d_a+u_a)\n    def test_write_multiple(self):\n        keyboard.write(\'ab\', exact=False)\n        self.do([], d_a+u_a+d_b+u_b)\n    def test_write_modifiers(self):\n        keyboard.write(\'Ab\', exact=False)\n        self.do([], d_shift+d_a+u_a+u_shift+d_b+u_b)\n    # restore_state_after has been removed after the introduction of `restore_modifiers`.\n    #def test_write_stash_not_restore(self):\n    #    self.do(d_shift)\n    #    keyboard.write(\'a\', restore_state_after=False, exact=False)\n    #    self.do([], u_shift+d_a+u_a)\n    def test_write_stash_restore(self):\n        self.do(d_shift)\n        keyboard.write(\'a\', exact=False)\n        self.do([], u_shift+d_a+u_a+d_shift)\n    def test_write_multiple(self):\n        last_time = time.time()\n        keyboard.write(\'ab\', delay=0.01, exact=False)\n        self.do([], d_a+u_a+d_b+u_b)\n        self.assertGreater(time.time() - last_time, 0.015)\n    def test_write_unicode_explicit(self):\n        keyboard.write(\'ab\', exact=True)\n        self.do([], [KeyboardEvent(event_type=KEY_DOWN, scan_code=999, name=\'a\'), KeyboardEvent(event_type=KEY_DOWN, scan_code=999, name=\'b\')])\n    def test_write_unicode_fallback(self):\n        keyboard.write(u\'\xc3\xa1b\', exact=False)\n        self.do([], [KeyboardEvent(event_type=KEY_DOWN, scan_code=999, name=u\'\xc3\xa1\')]+d_b+u_b)\n\n    def test_start_stop_recording(self):\n        keyboard.start_recording()\n        self.do(d_a+u_a)\n        self.assertEqual(keyboard.stop_recording(), d_a+u_a)\n    def test_stop_recording_error(self):\n        with self.assertRaises(ValueError):\n            keyboard.stop_recording()\n\n    def test_record(self):\n        queue = keyboard._queue.Queue()\n        def process():\n            queue.put(keyboard.record(\'space\', suppress=True))\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True\n        t.start()\n        # 0.01s sleep failed once already. Better solutions?\n        time.sleep(0.01)\n        self.do(du_a+du_b+du_space, du_a+du_b)\n        self.assertEqual(queue.get(timeout=0.5), du_a+du_b+du_space)\n\n    def test_play_nodelay(self):\n        keyboard.play(d_a+u_a, 0)\n        self.do([], d_a+u_a)\n    def test_play_stash(self):\n        self.do(d_ctrl)\n        keyboard.play(d_a+u_a, 0)\n        self.do([], u_ctrl+d_a+u_a+d_ctrl)\n    def test_play_delay(self):\n        last_time = time.time()\n        events = [make_event(KEY_DOWN, \'a\', 1, 100), make_event(KEY_UP, \'a\', 1, 100.01)]\n        keyboard.play(events, 1)\n        self.do([], d_a+u_a)\n        self.assertGreater(time.time() - last_time, 0.005)\n\n    def test_get_typed_strings_simple(self):\n        events = du_a+du_b+du_backspace+d_shift+du_a+u_shift+du_space+du_ctrl+du_a\n        self.assertEqual(list(keyboard.get_typed_strings(events)), [\'aA \', \'a\'])\n    def test_get_typed_strings_backspace(self):\n        events = du_a+du_b+du_backspace\n        self.assertEqual(list(keyboard.get_typed_strings(events)), [\'a\'])\n        events = du_backspace+du_a+du_b\n        self.assertEqual(list(keyboard.get_typed_strings(events)), [\'ab\'])\n    def test_get_typed_strings_shift(self):\n        events = d_shift+du_a+du_b+u_shift+du_space+du_ctrl+du_a\n        self.assertEqual(list(keyboard.get_typed_strings(events)), [\'AB \', \'a\'])\n    def test_get_typed_strings_all(self):\n        events = du_a+du_b+du_backspace+d_shift+du_a+du_capslock+du_b+u_shift+du_space+du_ctrl+du_a\n        self.assertEqual(list(keyboard.get_typed_strings(events)), [\'aAb \', \'A\'])\n\n    def test_get_hotkey_name_simple(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'a\']), \'a\')\n    def test_get_hotkey_name_modifiers(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'a\', \'shift\', \'ctrl\']), \'ctrl+shift+a\')\n    def test_get_hotkey_name_normalize(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'SHIFT\', \'left ctrl\']), \'ctrl+shift\')\n    def test_get_hotkey_name_plus(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'+\']), \'plus\')\n    def test_get_hotkey_name_duplicated(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'+\', \'plus\']), \'plus\')\n    def test_get_hotkey_name_full(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'+\', \'left ctrl\', \'shift\', \'WIN\', \'right alt\']), \'ctrl+alt+shift+windows+plus\')\n    def test_get_hotkey_name_multiple(self):\n        self.assertEqual(keyboard.get_hotkey_name([\'ctrl\', \'b\', \'!\', \'a\']), \'ctrl+!+a+b\')\n    def test_get_hotkey_name_from_pressed(self):\n        self.do(du_c+d_ctrl+d_a+d_b)\n        self.assertEqual(keyboard.get_hotkey_name(), \'ctrl+a+b\')\n\n    def test_read_hotkey(self):\n        queue = keyboard._queue.Queue()\n        def process():\n            queue.put(keyboard.read_hotkey())\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True\n        t.start()\n        time.sleep(0.01)\n        self.do(d_ctrl+d_a+d_b+u_ctrl)\n        self.assertEqual(queue.get(timeout=0.5), \'ctrl+a+b\')\n\n    def test_read_event(self):\n        queue = keyboard._queue.Queue()\n        def process():\n            queue.put(keyboard.read_event(suppress=True))\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True\n        t.start()\n        time.sleep(0.01)\n        self.do(d_a, [])\n        self.assertEqual(queue.get(timeout=0.5), d_a[0])\n\n    def test_read_key(self):\n        queue = keyboard._queue.Queue()\n        def process():\n            queue.put(keyboard.read_key(suppress=True))\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True\n        t.start()\n        time.sleep(0.01)\n        self.do(d_a, [])\n        self.assertEqual(queue.get(timeout=0.5), \'a\')\n\n    def test_wait_infinite(self):\n        self.triggered = False\n        def process():\n            keyboard.wait()\n            self.triggered = True\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True # Yep, we are letting this thread loose.\n        t.start()\n        time.sleep(0.01)\n        self.assertFalse(self.triggered)\n\n    def test_wait_until_success(self):\n        queue = keyboard._queue.Queue()\n        def process():\n            queue.put(keyboard.wait(queue.get(timeout=0.5), suppress=True) or True)\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True\n        t.start()\n        queue.put(\'a\')\n        time.sleep(0.01)\n        self.do(d_a, [])\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_wait_until_fail(self):\n        def process():\n            keyboard.wait(\'a\', suppress=True)\n            self.fail()\n        from threading import Thread\n        t = Thread(target=process)\n        t.daemon = True # Yep, we are letting this thread loose.\n        t.start()\n        time.sleep(0.01)\n        self.do(d_b)\n\n    def test_add_hotkey_single_step_suppress_allow(self):\n        keyboard.add_hotkey(\'a\', lambda: trigger() or True, suppress=True)\n        self.do(d_a, triggered_event+d_a)\n    def test_add_hotkey_single_step_suppress_args_allow(self):\n        arg = object()\n        keyboard.add_hotkey(\'a\', lambda a: self.assertIs(a, arg) or trigger() or True, args=(arg,), suppress=True)\n        self.do(d_a, triggered_event+d_a)\n    def test_add_hotkey_single_step_suppress_single(self):\n        keyboard.add_hotkey(\'a\', trigger, suppress=True)\n        self.do(d_a, triggered_event)\n    def test_add_hotkey_single_step_suppress_removed(self):\n        keyboard.remove_hotkey(keyboard.add_hotkey(\'a\', trigger, suppress=True))\n        self.do(d_a, d_a)\n    def test_add_hotkey_single_step_suppress_removed(self):\n        keyboard.remove_hotkey(keyboard.add_hotkey(\'ctrl+a\', trigger, suppress=True))\n        self.do(d_ctrl+d_a, d_ctrl+d_a)\n        self.assertEqual(keyboard._listener.filtered_modifiers[dummy_keys[\'left ctrl\'][0][0]], 0)\n    def test_remove_hotkey_internal(self):\n        remove = keyboard.add_hotkey(\'shift+a\', trigger, suppress=True)\n        self.assertTrue(all(keyboard._listener.blocking_hotkeys.values()))\n        self.assertTrue(all(keyboard._listener.filtered_modifiers.values()))\n        self.assertNotEqual(keyboard._hotkeys, {})\n        remove()\n        self.assertTrue(not any(keyboard._listener.filtered_modifiers.values()))\n        self.assertTrue(not any(keyboard._listener.blocking_hotkeys.values()))\n        self.assertEqual(keyboard._hotkeys, {})\n    def test_remove_hotkey_internal_multistep_start(self):\n        remove = keyboard.add_hotkey(\'shift+a, b\', trigger, suppress=True)\n        self.assertTrue(all(keyboard._listener.blocking_hotkeys.values()))\n        self.assertTrue(all(keyboard._listener.filtered_modifiers.values()))\n        self.assertNotEqual(keyboard._hotkeys, {})\n        remove()\n        self.assertTrue(not any(keyboard._listener.filtered_modifiers.values()))\n        self.assertTrue(not any(keyboard._listener.blocking_hotkeys.values()))\n        self.assertEqual(keyboard._hotkeys, {})\n    def test_remove_hotkey_internal_multistep_end(self):\n        remove = keyboard.add_hotkey(\'shift+a, b\', trigger, suppress=True)\n        self.do(d_shift+du_a+u_shift)\n        self.assertTrue(any(keyboard._listener.blocking_hotkeys.values()))\n        self.assertTrue(not any(keyboard._listener.filtered_modifiers.values()))\n        self.assertNotEqual(keyboard._hotkeys, {})\n        remove()\n        self.assertTrue(not any(keyboard._listener.filtered_modifiers.values()))\n        self.assertTrue(not any(keyboard._listener.blocking_hotkeys.values()))\n        self.assertEqual(keyboard._hotkeys, {})\n    def test_add_hotkey_single_step_suppress_with_modifiers(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+d_a, triggered_event)\n    def test_add_hotkey_single_step_suppress_with_modifiers_fail_unrelated_modifier(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+u_shift+d_a, d_shift+u_shift+d_ctrl+d_a)\n    def test_add_hotkey_single_step_suppress_with_modifiers_fail_unrelated_key(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+du_b, d_shift+d_ctrl+du_b)\n    def test_add_hotkey_single_step_suppress_with_modifiers_unrelated_key(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+du_b+d_a, d_shift+d_ctrl+du_b+triggered_event)\n    def test_add_hotkey_single_step_suppress_with_modifiers_release(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+du_b+d_a+u_ctrl+u_shift, d_shift+d_ctrl+du_b+triggered_event+u_ctrl+u_shift)\n    def test_add_hotkey_single_step_suppress_with_modifiers_out_of_order(self):\n        keyboard.add_hotkey(\'ctrl+shift+a\', trigger, suppress=True)\n        self.do(d_shift+d_ctrl+d_a, triggered_event)\n    def test_add_hotkey_single_step_suppress_with_modifiers_repeated(self):\n        keyboard.add_hotkey(\'ctrl+a\', trigger, suppress=True)\n        self.do(d_ctrl+du_a+du_b+du_a, triggered_event+d_ctrl+du_b+triggered_event)\n    def test_add_hotkey_single_step_suppress_with_modifiers_release(self):\n        keyboard.add_hotkey(\'ctrl+a\', trigger, suppress=True, trigger_on_release=True)\n        self.do(d_ctrl+du_a+du_b+du_a, triggered_event+d_ctrl+du_b+triggered_event)\n    def test_add_hotkey_single_step_suppress_with_modifier_superset_release(self):\n        keyboard.add_hotkey(\'ctrl+a\', trigger, suppress=True, trigger_on_release=True)\n        self.do(d_ctrl+d_shift+du_a+u_shift+u_ctrl, d_ctrl+d_shift+du_a+u_shift+u_ctrl)\n    def test_add_hotkey_single_step_suppress_with_modifier_superset(self):\n        keyboard.add_hotkey(\'ctrl+a\', trigger, suppress=True)\n        self.do(d_ctrl+d_shift+du_a+u_shift+u_ctrl, d_ctrl+d_shift+du_a+u_shift+u_ctrl)\n    def test_add_hotkey_single_step_timeout(self):\n        keyboard.add_hotkey(\'a\', trigger, timeout=1, suppress=True)\n        self.do(du_a, triggered_event)\n    def test_add_hotkey_multi_step_first_timeout(self):\n        keyboard.add_hotkey(\'a, b\', trigger, timeout=0.01, suppress=True)\n        time.sleep(0.03)\n        self.do(du_a+du_b, triggered_event)\n    def test_add_hotkey_multi_step_last_timeout(self):\n        keyboard.add_hotkey(\'a, b\', trigger, timeout=0.01, suppress=True)\n        self.do(du_a, [])\n        time.sleep(0.05)\n        self.do(du_b, du_a+du_b)\n    def test_add_hotkey_multi_step_success_timeout(self):\n        keyboard.add_hotkey(\'a, b\', trigger, timeout=0.05, suppress=True)\n        self.do(du_a, [])\n        time.sleep(0.01)\n        self.do(du_b, triggered_event)\n    def test_add_hotkey_multi_step_suffix_timeout(self):\n        keyboard.add_hotkey(\'a, b, a\', trigger, timeout=0.01, suppress=True)\n        self.do(du_a+du_b, [])\n        time.sleep(0.05)\n        self.do(du_a, du_a+du_b)\n        self.do(du_b+du_a, triggered_event)\n    def test_add_hotkey_multi_step_allow(self):\n        keyboard.add_hotkey(\'a, b\', lambda: trigger() or True, suppress=True)\n        self.do(du_a+du_b, triggered_event+du_a+du_b)\n\n    def test_add_hotkey_single_step_nonsuppress(self):\n        queue = keyboard._queue.Queue()\n        keyboard.add_hotkey(\'ctrl+shift+a+b\', lambda: queue.put(True), suppress=False)\n        self.do(d_shift+d_ctrl+d_a+d_b)\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_add_hotkey_single_step_nonsuppress_repeated(self):\n        queue = keyboard._queue.Queue()\n        keyboard.add_hotkey(\'ctrl+shift+a+b\', lambda: queue.put(True), suppress=False)\n        self.do(d_shift+d_ctrl+d_a+d_b)\n        self.do(d_shift+d_ctrl+d_a+d_b)\n        self.assertTrue(queue.get(timeout=0.5))\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_add_hotkey_single_step_nosuppress_with_modifiers_out_of_order(self):\n        queue = keyboard._queue.Queue()\n        keyboard.add_hotkey(\'ctrl+shift+a\', lambda: queue.put(True), suppress=False)\n        self.do(d_shift+d_ctrl+d_a)\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_add_hotkey_single_step_suppress_regression_1(self):\n        keyboard.add_hotkey(\'a\', trigger, suppress=True)\n        self.do(d_c+d_a+u_c+u_a, d_c+d_a+u_c+u_a)\n\n    def test_remap_hotkey_single(self):\n        keyboard.remap_hotkey(\'a\', \'b\')\n        self.do(d_a+u_a, d_b+u_b)\n    def test_remap_hotkey_complex_dst(self):\n        keyboard.remap_hotkey(\'a\', \'ctrl+b, c\')\n        self.do(d_a+u_a, d_ctrl+du_b+u_ctrl+du_c)\n    def test_remap_hotkey_modifiers(self):\n        keyboard.remap_hotkey(\'ctrl+shift+a\', \'b\')\n        self.do(d_ctrl+d_shift+d_a+u_a, du_b)\n    def test_remap_hotkey_modifiers_repeat(self):\n        keyboard.remap_hotkey(\'ctrl+shift+a\', \'b\')\n        self.do(d_ctrl+d_shift+du_a+du_a, du_b+du_b)\n    def test_remap_hotkey_modifiers_state(self):\n        keyboard.remap_hotkey(\'ctrl+shift+a\', \'b\')\n        self.do(d_ctrl+d_shift+du_c+du_a+du_a, d_shift+d_ctrl+du_c+u_shift+u_ctrl+du_b+d_ctrl+d_shift+u_shift+u_ctrl+du_b+d_ctrl+d_shift)\n    def test_remap_hotkey_release_incomplete(self):\n        keyboard.remap_hotkey(\'a\', \'b\', trigger_on_release=True)\n        self.do(d_a, [])\n    def test_remap_hotkey_release_complete(self):\n        keyboard.remap_hotkey(\'a\', \'b\', trigger_on_release=True)\n        self.do(du_a, du_b)\n\n    def test_parse_hotkey_combinations_scan_code(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(30), (((30,),),))\n    def test_parse_hotkey_combinations_single(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(\'a\'), (((1,),),))\n    def test_parse_hotkey_combinations_single_modifier(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(\'shift+a\'), (((1, 5), (1, 6)),))\n    def test_parse_hotkey_combinations_single_modifiers(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(\'shift+ctrl+a\'), (((1, 5, 7), (1, 6, 7)),))\n    def test_parse_hotkey_combinations_multi(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(\'a, b\'), (((1,),), ((2,),)))\n    def test_parse_hotkey_combinations_multi_modifier(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(\'shift+a, b\'), (((1, 5), (1, 6)), ((2,),)))\n    def test_parse_hotkey_combinations_list_list(self):\n        self.assertEqual(keyboard.parse_hotkey_combinations(keyboard.parse_hotkey_combinations(\'a, b\')), keyboard.parse_hotkey_combinations(\'a, b\'))\n    def test_parse_hotkey_combinations_fail_empty(self):\n        with self.assertRaises(ValueError):\n            keyboard.parse_hotkey_combinations(\'\')\n\n\n    def test_add_hotkey_multistep_suppress_incomplete(self):\n        keyboard.add_hotkey(\'a, b\', trigger, suppress=True)\n        self.do(du_a, [])\n        self.assertEqual(keyboard._listener.blocking_hotkeys[(1,)], [])\n        self.assertEqual(len(keyboard._listener.blocking_hotkeys[(2,)]), 1)\n    def test_add_hotkey_multistep_suppress_incomplete(self):\n        keyboard.add_hotkey(\'a, b\', trigger, suppress=True)\n        self.do(du_a+du_b, triggered_event)\n    def test_add_hotkey_multistep_suppress_modifier(self):\n        keyboard.add_hotkey(\'shift+a, b\', trigger, suppress=True)\n        self.do(d_shift+du_a+u_shift+du_b, triggered_event)\n    def test_add_hotkey_multistep_suppress_fail(self):\n        keyboard.add_hotkey(\'a, b\', trigger, suppress=True)\n        self.do(du_a+du_c, du_a+du_c)\n    def test_add_hotkey_multistep_suppress_three_steps(self):\n        keyboard.add_hotkey(\'a, b, c\', trigger, suppress=True)\n        self.do(du_a+du_b+du_c, triggered_event)\n    def test_add_hotkey_multistep_suppress_repeated_prefix(self):\n        keyboard.add_hotkey(\'a, a, c\', trigger, suppress=True, trigger_on_release=True)\n        self.do(du_a+du_a+du_c, triggered_event)\n    def test_add_hotkey_multistep_suppress_repeated_key(self):\n        keyboard.add_hotkey(\'a, b\', trigger, suppress=True)\n        self.do(du_a+du_a+du_b, du_a+triggered_event)\n        self.assertEqual(keyboard._listener.blocking_hotkeys[(2,)], [])\n        self.assertEqual(len(keyboard._listener.blocking_hotkeys[(1,)]), 1)\n    def test_add_hotkey_multi_step_suppress_regression_1(self):\n        keyboard.add_hotkey(\'a, b\', trigger, suppress=True)\n        self.do(d_c+d_a+u_c+u_a+du_c, d_c+d_a+u_c+u_a+du_c)\n    def test_add_hotkey_multi_step_suppress_replays(self):\n        keyboard.add_hotkey(\'a, b, c\', trigger, suppress=True)\n        self.do(du_a+du_b+du_a+du_b+du_space, du_a+du_b+du_a+du_b+du_space)\n\n    def test_add_word_listener_success(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free)\n        self.do(du_a+du_b+du_c+du_space)\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_add_word_listener_no_trigger_fail(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free)\n        self.do(du_a+du_b+du_c)\n        with self.assertRaises(keyboard._queue.Empty):\n            queue.get(timeout=0.01)\n    def test_add_word_listener_timeout_fail(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free, timeout=1)\n        self.do(du_a+du_b+du_c+[make_event(KEY_DOWN, name=\'space\', time=2)])\n        with self.assertRaises(keyboard._queue.Empty):\n            queue.get(timeout=0.01)\n    def test_duplicated_word_listener(self):\n        keyboard.add_word_listener(\'abc\', trigger)\n        keyboard.add_word_listener(\'abc\', trigger)\n    def test_add_word_listener_remove(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free)\n        keyboard.remove_word_listener(\'abc\')\n        self.do(du_a+du_b+du_c+du_space)\n        with self.assertRaises(keyboard._queue.Empty):\n            queue.get(timeout=0.01)\n    def test_add_word_listener_suffix_success(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free, match_suffix=True)\n        self.do(du_a+du_a+du_b+du_c+du_space)\n        self.assertTrue(queue.get(timeout=0.5))\n    def test_add_word_listener_suffix_fail(self):\n        queue = keyboard._queue.Queue()\n        def free():\n            queue.put(1)\n        keyboard.add_word_listener(\'abc\', free)\n        self.do(du_a+du_a+du_b+du_c)\n        with self.assertRaises(keyboard._queue.Empty):\n            queue.get(timeout=0.01)\n\n    #def test_add_abbreviation(self):\n    #    keyboard.add_abbreviation(\'abc\', \'aaa\')\n    #    self.do(du_a+du_b+du_c+du_space, [])\n\n\nif __name__ == \'__main__\':\n    unittest.main()'"
External_Libraries/keyboard_master/keyboard/_mouse_event.py,0,"b""# -*- coding: utf-8 -*-\nfrom collections import namedtuple\n\nLEFT = 'left'\nRIGHT = 'right'\nMIDDLE = 'middle'\nWHEEL = 'wheel'\nX = 'x'\nX2 = 'x2'\n\nUP = 'up'\nDOWN = 'down'\nDOUBLE = 'double'\nVERTICAL = 'vertical'\nHORIZONTAL = 'horizontal'\n\n\nButtonEvent = namedtuple('ButtonEvent', ['event_type', 'button', 'time'])\nWheelEvent = namedtuple('WheelEvent', ['delta', 'time'])\nMoveEvent = namedtuple('MoveEvent', ['x', 'y', 'time'])\n"""
External_Libraries/keyboard_master/keyboard/_mouse_tests.py,0,"b""# -*- coding: utf-8 -*-\nimport unittest\nimport time\n\nfrom ._mouse_event import MoveEvent, ButtonEvent, WheelEvent, LEFT, RIGHT, MIDDLE, X, X2, UP, DOWN, DOUBLE\nfrom keyboard import mouse\n\nclass FakeOsMouse(object):\n    def __init__(self):\n        self.append = None\n        self.position = (0, 0)\n        self.queue = None\n        self.init = lambda: None\n\n    def listen(self, queue):\n        self.listening = True\n        self.queue = queue\n\n    def press(self, button):\n        self.append((DOWN, button))\n\n    def release(self, button):\n        self.append((UP, button))\n\n    def get_position(self):\n        return self.position\n\n    def move_to(self, x, y):\n        self.append(('move', (x, y)))\n        self.position = (x, y)\n\n    def wheel(self, delta):\n        self.append(('wheel', delta))\n\n    def move_relative(self, x, y):\n        self.position = (self.position[0] + x, self.position[1] + y)\n\nclass TestMouse(unittest.TestCase):\n    @staticmethod\n    def setUpClass():\n        mouse._os_mouse= FakeOsMouse()\n        mouse._listener.start_if_necessary()\n        assert mouse._os_mouse.listening\n\n    def setUp(self):\n        self.events = []\n        mouse._pressed_events.clear()\n        mouse._os_mouse.append = self.events.append\n\n    def tearDown(self):\n        mouse.unhook_all()\n        # Make sure there's no spill over between tests.\n        self.wait_for_events_queue()\n\n    def wait_for_events_queue(self):\n        mouse._listener.queue.join()\n\n    def flush_events(self):\n        self.wait_for_events_queue()\n        events = list(self.events)\n        # Ugly, but requried to work in Python2. Python3 has list.clear\n        del self.events[:]\n        return events\n\n    def press(self, button=LEFT):\n        mouse._os_mouse.queue.put(ButtonEvent(DOWN, button, time.time()))\n        self.wait_for_events_queue()\n\n    def release(self, button=LEFT):\n        mouse._os_mouse.queue.put(ButtonEvent(UP, button, time.time()))\n        self.wait_for_events_queue()\n\n    def double_click(self, button=LEFT):\n        mouse._os_mouse.queue.put(ButtonEvent(DOUBLE, button, time.time()))\n        self.wait_for_events_queue()\n\n    def click(self, button=LEFT):\n        self.press(button)\n        self.release(button)\n\n    def wheel(self, delta=1):\n        mouse._os_mouse.queue.put(WheelEvent(delta, time.time()))\n        self.wait_for_events_queue()\n\n    def move(self, x=0, y=0):\n        mouse._os_mouse.queue.put(MoveEvent(x, y, time.time()))\n        self.wait_for_events_queue()\n\n    def test_hook(self):\n        events = []\n        self.press()\n        mouse.hook(events.append)\n        self.press()\n        mouse.unhook(events.append)\n        self.press()\n        self.assertEqual(len(events), 1)\n\n    def test_is_pressed(self):\n        self.assertFalse(mouse.is_pressed())\n        self.press()\n        self.assertTrue(mouse.is_pressed())\n        self.release()\n        self.press(X2)\n        self.assertFalse(mouse.is_pressed())\n\n        self.assertTrue(mouse.is_pressed(X2))\n        self.press(X2)\n        self.assertTrue(mouse.is_pressed(X2))\n        self.release(X2)\n        self.release(X2)\n        self.assertFalse(mouse.is_pressed(X2))\n\n    def test_buttons(self):\n        mouse.press()\n        self.assertEqual(self.flush_events(), [(DOWN, LEFT)])\n        mouse.release()\n        self.assertEqual(self.flush_events(), [(UP, LEFT)])\n        mouse.click()\n        self.assertEqual(self.flush_events(), [(DOWN, LEFT), (UP, LEFT)])\n        mouse.double_click()\n        self.assertEqual(self.flush_events(), [(DOWN, LEFT), (UP, LEFT), (DOWN, LEFT), (UP, LEFT)])\n        mouse.right_click()\n        self.assertEqual(self.flush_events(), [(DOWN, RIGHT), (UP, RIGHT)])\n        mouse.click(RIGHT)\n        self.assertEqual(self.flush_events(), [(DOWN, RIGHT), (UP, RIGHT)])\n        mouse.press(X2)\n        self.assertEqual(self.flush_events(), [(DOWN, X2)])\n\n    def test_position(self):\n        self.assertEqual(mouse.get_position(), mouse._os_mouse.get_position())\n\n    def test_move(self):\n        mouse.move(0, 0)\n        self.assertEqual(mouse._os_mouse.get_position(), (0, 0))\n        mouse.move(100, 500)\n        self.assertEqual(mouse._os_mouse.get_position(), (100, 500))\n        mouse.move(1, 2, False)\n        self.assertEqual(mouse._os_mouse.get_position(), (101, 502))\n\n        mouse.move(0, 0)\n        mouse.move(100, 499, True, duration=0.01)\n        self.assertEqual(mouse._os_mouse.get_position(), (100, 499))\n        mouse.move(100, 1, False, duration=0.01)\n        self.assertEqual(mouse._os_mouse.get_position(), (200, 500))\n        mouse.move(0, 0, False, duration=0.01)\n        self.assertEqual(mouse._os_mouse.get_position(), (200, 500))\n\n    def triggers(self, fn, events, **kwargs):\n        self.triggered = False\n        def callback():\n            self.triggered = True\n        handler = fn(callback, **kwargs)\n\n        for event_type, arg in events:\n            if event_type == DOWN:\n                self.press(arg)\n            elif event_type == UP:\n                self.release(arg)\n            elif event_type == DOUBLE:\n                self.double_click(arg)\n            elif event_type == 'WHEEL':\n                self.wheel()\n\n        mouse._listener.remove_handler(handler)\n        return self.triggered\n\n    def test_on_button(self):\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, LEFT)]))\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, RIGHT)]))\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, X)]))\n\n        self.assertFalse(self.triggers(mouse.on_button, [('WHEEL', '')]))\n\n        self.assertFalse(self.triggers(mouse.on_button, [(DOWN, X)], buttons=MIDDLE))\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, MIDDLE)], buttons=MIDDLE))\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, MIDDLE)], buttons=MIDDLE))\n        self.assertFalse(self.triggers(mouse.on_button, [(DOWN, MIDDLE)], buttons=MIDDLE, types=UP))\n        self.assertTrue(self.triggers(mouse.on_button, [(UP, MIDDLE)], buttons=MIDDLE, types=UP))\n\n        self.assertTrue(self.triggers(mouse.on_button, [(UP, MIDDLE)], buttons=[MIDDLE, LEFT], types=[UP, DOWN]))\n        self.assertTrue(self.triggers(mouse.on_button, [(DOWN, LEFT)], buttons=[MIDDLE, LEFT], types=[UP, DOWN]))\n        self.assertFalse(self.triggers(mouse.on_button, [(UP, X)], buttons=[MIDDLE, LEFT], types=[UP, DOWN]))\n\n    def test_ons(self):\n        self.assertTrue(self.triggers(mouse.on_click, [(UP, LEFT)]))\n        self.assertFalse(self.triggers(mouse.on_click, [(UP, RIGHT)]))\n        self.assertFalse(self.triggers(mouse.on_click, [(DOWN, LEFT)]))\n        self.assertFalse(self.triggers(mouse.on_click, [(DOWN, RIGHT)]))\n\n        self.assertTrue(self.triggers(mouse.on_double_click, [(DOUBLE, LEFT)]))\n        self.assertFalse(self.triggers(mouse.on_double_click, [(DOUBLE, RIGHT)]))\n        self.assertFalse(self.triggers(mouse.on_double_click, [(DOWN, RIGHT)]))\n\n        self.assertTrue(self.triggers(mouse.on_right_click, [(UP, RIGHT)]))\n        self.assertTrue(self.triggers(mouse.on_middle_click, [(UP, MIDDLE)]))\n\n    def test_wait(self):\n        # If this fails it blocks. Unfortunately, but I see no other way of testing.\n        from threading import Thread, Lock\n        lock = Lock()\n        lock.acquire()\n        def t():\n            mouse.wait()\n            lock.release()\n        Thread(target=t).start()\n        self.press()\n        lock.acquire()\n\n    def test_record_play(self):\n        from threading import Thread, Lock\n        lock = Lock()\n        lock.acquire()\n        def t():\n            self.recorded = mouse.record(RIGHT)\n            lock.release()\n        Thread(target=t).start()\n        self.click()\n        self.wheel(5)\n        self.move(100, 50)\n        self.press(RIGHT)\n        lock.acquire()\n\n        self.assertEqual(len(self.recorded), 5)\n        self.assertEqual(self.recorded[0]._replace(time=None), ButtonEvent(DOWN, LEFT, None))\n        self.assertEqual(self.recorded[1]._replace(time=None), ButtonEvent(UP, LEFT, None))\n        self.assertEqual(self.recorded[2]._replace(time=None), WheelEvent(5, None))\n        self.assertEqual(self.recorded[3]._replace(time=None), MoveEvent(100, 50, None))\n        self.assertEqual(self.recorded[4]._replace(time=None), ButtonEvent(DOWN, RIGHT, None))\n\n        mouse.play(self.recorded, speed_factor=0)\n        events = self.flush_events()\n        self.assertEqual(len(events), 5)\n        self.assertEqual(events[0], (DOWN, LEFT))\n        self.assertEqual(events[1], (UP, LEFT))\n        self.assertEqual(events[2], ('wheel', 5))\n        self.assertEqual(events[3], ('move', (100, 50)))\n        self.assertEqual(events[4], (DOWN, RIGHT))\n\n        mouse.play(self.recorded)\n        events = self.flush_events()\n        self.assertEqual(len(events), 5)\n        self.assertEqual(events[0], (DOWN, LEFT))\n        self.assertEqual(events[1], (UP, LEFT))\n        self.assertEqual(events[2], ('wheel', 5))\n        self.assertEqual(events[3], ('move', (100, 50)))\n        self.assertEqual(events[4], (DOWN, RIGHT))\n\n        mouse.play(self.recorded, include_clicks=False)\n        events = self.flush_events()\n        self.assertEqual(len(events), 2)\n        self.assertEqual(events[0], ('wheel', 5))\n        self.assertEqual(events[1], ('move', (100, 50)))\n\n        mouse.play(self.recorded, include_moves=False)\n        events = self.flush_events()\n        self.assertEqual(len(events), 4)\n        self.assertEqual(events[0], (DOWN, LEFT))\n        self.assertEqual(events[1], (UP, LEFT))\n        self.assertEqual(events[2], ('wheel', 5))\n        self.assertEqual(events[3], (DOWN, RIGHT))\n\n        mouse.play(self.recorded, include_wheel=False)\n        events = self.flush_events()\n        self.assertEqual(len(events), 4)\n        self.assertEqual(events[0], (DOWN, LEFT))\n        self.assertEqual(events[1], (UP, LEFT))\n        self.assertEqual(events[2], ('move', (100, 50)))\n        self.assertEqual(events[3], (DOWN, RIGHT))\n\nif __name__ == '__main__':\n    unittest.main()\n"""
External_Libraries/keyboard_master/keyboard/_nixcommon.py,0,"b'# -*- coding: utf-8 -*-\nimport struct\nimport os\nimport atexit\nfrom time import time as now\nfrom threading import Thread\nfrom glob import glob\ntry:\n    from queue import Queue\nexcept ImportError:\n    from Queue import Queue\n\nevent_bin_format = \'llHHI\'\n\n# Taken from include/linux/input.h\n# https://www.kernel.org/doc/Documentation/input/event-codes.txt\nEV_SYN = 0x00\nEV_KEY = 0x01\nEV_REL = 0x02\nEV_ABS = 0x03\nEV_MSC = 0x04\n\ndef make_uinput():\n    if not os.path.exists(\'/dev/uinput\'):\n        raise IOError(\'No uinput module found.\')\n\n    import fcntl, struct\n\n    # Requires uinput driver, but it\'s usually available.\n    uinput = open(""/dev/uinput"", \'wb\')\n    UI_SET_EVBIT = 0x40045564\n    fcntl.ioctl(uinput, UI_SET_EVBIT, EV_KEY)\n\n    UI_SET_KEYBIT = 0x40045565\n    for i in range(256):\n        fcntl.ioctl(uinput, UI_SET_KEYBIT, i)\n\n    BUS_USB = 0x03\n    uinput_user_dev = ""80sHHHHi64i64i64i64i""\n    axis = [0] * 64 * 4\n    uinput.write(struct.pack(uinput_user_dev, b""Virtual Keyboard"", BUS_USB, 1, 1, 1, 0, *axis))\n    uinput.flush() # Without this you may get Errno 22: Invalid argument.\n\n    UI_DEV_CREATE = 0x5501\n    fcntl.ioctl(uinput, UI_DEV_CREATE)\n    UI_DEV_DESTROY = 0x5502\n    #fcntl.ioctl(uinput, UI_DEV_DESTROY)\n\n    return uinput\n\nclass EventDevice(object):\n    def __init__(self, path):\n        self.path = path\n        self._input_file = None\n        self._output_file = None\n\n    @property\n    def input_file(self):\n        if self._input_file is None:\n            try:\n                self._input_file = open(self.path, \'rb\')\n            except IOError as e:\n                if e.strerror == \'Permission denied\':\n                    print(\'Permission denied ({}). You must be sudo to access global events.\'.format(self.path))\n                    exit()\n\n            def try_close():\n                try:\n                    self._input_file.close\n                except:\n                    pass\n            atexit.register(try_close)\n        return self._input_file\n\n    @property\n    def output_file(self):\n        if self._output_file is None:\n            self._output_file = open(self.path, \'wb\')\n            atexit.register(self._output_file.close)\n        return self._output_file\n\n    def read_event(self):\n        data = self.input_file.read(struct.calcsize(event_bin_format))\n        seconds, microseconds, type, code, value = struct.unpack(event_bin_format, data)\n        return seconds + microseconds / 1e6, type, code, value, self.path\n\n    def write_event(self, type, code, value):\n        integer, fraction = divmod(now(), 1)\n        seconds = int(integer)\n        microseconds = int(fraction * 1e6)\n        data_event = struct.pack(event_bin_format, seconds, microseconds, type, code, value)\n\n        # Send a sync event to ensure other programs update.\n        sync_event = struct.pack(event_bin_format, seconds, microseconds, EV_SYN, 0, 0)\n\n        self.output_file.write(data_event + sync_event)\n        self.output_file.flush()\n\nclass AggregatedEventDevice(object):\n    def __init__(self, devices, output=None):\n        self.event_queue = Queue()\n        self.devices = devices\n        self.output = output or self.devices[0]\n        def start_reading(device):\n            while True:\n                self.event_queue.put(device.read_event())\n        for device in self.devices:\n            thread = Thread(target=start_reading, args=[device])\n            thread.setDaemon(True)\n            thread.start()\n\n    def read_event(self):\n        return self.event_queue.get(block=True)\n\n    def write_event(self, type, code, value):\n        self.output.write_event(type, code, value)\n\nimport re\nfrom collections import namedtuple\nDeviceDescription = namedtuple(\'DeviceDescription\', \'event_file is_mouse is_keyboard\')\ndevice_pattern = r""""""N: Name=""([^""]+?)"".+?H: Handlers=([^\\n]+)""""""\ndef list_devices_from_proc(type_name):\n    try:\n        with open(\'/proc/bus/input/devices\') as f:\n            description = f.read()\n    except FileNotFoundError:\n        return\n\n    devices = {}\n    for name, handlers in re.findall(device_pattern, description, re.DOTALL):\n        path = \'/dev/input/event\' + re.search(r\'event(\\d+)\', handlers).group(1)\n        if type_name in handlers:\n            yield EventDevice(path)\n\ndef list_devices_from_by_id(name_suffix, by_id=True):\n    for path in glob(\'/dev/input/{}/*-event-{}\'.format(\'by-id\' if by_id else \'by-path\', name_suffix)):\n        yield EventDevice(path)\n\ndef aggregate_devices(type_name):\n    # Some systems have multiple keyboards with different range of allowed keys\n    # on each one, like a notebook with a ""keyboard"" device exclusive for the\n    # power button. Instead of figuring out which keyboard allows which key to\n    # send events, we create a fake device and send all events through there.\n    try:\n        uinput = make_uinput()\n        fake_device = EventDevice(\'uinput Fake Device\')\n        fake_device._input_file = uinput\n        fake_device._output_file = uinput\n    except IOError as e:\n        import warnings\n        warnings.warn(\'Failed to create a device file using `uinput` module. Sending of events may be limited or unavailable depending on plugged-in devices.\', stacklevel=2)\n        fake_device = None\n\n    # We don\'t aggregate devices from different sources to avoid\n    # duplicates.\n\n    devices_from_proc = list(list_devices_from_proc(type_name))\n    if devices_from_proc:\n        return AggregatedEventDevice(devices_from_proc, output=fake_device)\n\n    # breaks on mouse for virtualbox\n    # was getting /dev/input/by-id/usb-VirtualBox_USB_Tablet-event-mouse\n    devices_from_by_id = list(list_devices_from_by_id(type_name)) or list(list_devices_from_by_id(type_name, by_id=False))\n    if devices_from_by_id:\n        return AggregatedEventDevice(devices_from_by_id, output=fake_device)\n\n    # If no keyboards were found we can only use the fake device to send keys.\n    assert fake_device\n    return fake_device\n\n\ndef ensure_root():\n    if os.geteuid() != 0:\n        raise ImportError(\'You must be root to use this library on linux.\')\n'"
External_Libraries/keyboard_master/keyboard/_nixkeyboard.py,0,"b'# -*- coding: utf-8 -*-\nimport struct\nimport traceback\nfrom time import time as now\nfrom collections import namedtuple\nfrom ._keyboard_event import KeyboardEvent, KEY_DOWN, KEY_UP\nfrom ._canonical_names import all_modifiers, normalize_name\nfrom ._nixcommon import EV_KEY, aggregate_devices, ensure_root\n\n# TODO: start by reading current keyboard state, as to not missing any already pressed keys.\n# See: http://stackoverflow.com/questions/3649874/how-to-get-keyboard-state-in-linux\n\ndef cleanup_key(name):\n    """""" Formats a dumpkeys format to our standard. """"""\n    name = name.lstrip(\'+\')\n    is_keypad = name.startswith(\'KP_\')\n    for mod in (\'Meta_\', \'Control_\', \'dead_\', \'KP_\'):\n        if name.startswith(mod):\n            name = name[len(mod):]\n\n    # Dumpkeys is weird like that.\n    if name == \'Remove\':\n        name = \'Delete\'\n    elif name == \'Delete\':\n        name = \'Backspace\'\n\n    if name.endswith(\'_r\'):\n        name = \'right \' + name[:-2]\n    if name.endswith(\'_l\'):\n        name = \'left \' + name[:-2]\n\n\n    return normalize_name(name), is_keypad\n\ndef cleanup_modifier(modifier):\n    modifier = normalize_name(modifier)\n    if modifier in all_modifiers:\n        return modifier\n    if modifier[:-1] in all_modifiers:\n        return modifier[:-1]\n    raise ValueError(\'Unknown modifier {}\'.format(modifier))\n\n""""""\nUse `dumpkeys --keys-only` to list all scan codes and their names. We\nthen parse the output and built a table. For each scan code and modifiers we\nhave a list of names and vice-versa.\n""""""\nfrom subprocess import check_output\nfrom collections import defaultdict\nimport re\n\nto_name = defaultdict(list)\nfrom_name = defaultdict(list)\nkeypad_scan_codes = set()\n\ndef register_key(key_and_modifiers, name):\n    if name not in to_name[key_and_modifiers]:\n        to_name[key_and_modifiers].append(name)\n    if key_and_modifiers not in from_name[name]:\n        from_name[name].append(key_and_modifiers)\n\ndef build_tables():\n    if to_name and from_name: return\n    ensure_root()\n\n    modifiers_bits = {\n        \'shift\': 1,\n        \'alt gr\': 2,\n        \'ctrl\': 4,\n        \'alt\': 8,\n    }\n    keycode_template = r\'^keycode\\s+(\\d+)\\s+=(.*?)$\'\n    dump = check_output([\'dumpkeys\', \'--keys-only\'], universal_newlines=True)\n    for str_scan_code, str_names in re.findall(keycode_template, dump, re.MULTILINE):\n        scan_code = int(str_scan_code)\n        for i, str_name in enumerate(str_names.strip().split()):\n            modifiers = tuple(sorted(modifier for modifier, bit in modifiers_bits.items() if i & bit))\n            name, is_keypad = cleanup_key(str_name)\n            register_key((scan_code, modifiers), name)\n            if is_keypad:\n                keypad_scan_codes.add(scan_code)\n                register_key((scan_code, modifiers), \'keypad \' + name)\n\n    # dumpkeys consistently misreports the Windows key, sometimes\n    # skipping it completely or reporting as \'alt. 125 = left win,\n    # 126 = right win.\n    if (125, ()) not in to_name or to_name[(125, ())] == \'alt\':\n        register_key((125, ()), \'windows\')\n    if (126, ()) not in to_name or to_name[(126, ())] == \'alt\':\n        register_key((126, ()), \'windows\')\n\n    # The menu key is usually skipped altogether, so we also add it manually.\n    if (127, ()) not in to_name:\n        register_key((127, ()), \'menu\')\n\n    synonyms_template = r\'^(\\S+)\\s+for (.+)$\'\n    dump = check_output([\'dumpkeys\', \'--long-info\'], universal_newlines=True)\n    for synonym_str, original_str in re.findall(synonyms_template, dump, re.MULTILINE):\n        synonym, _ = cleanup_key(synonym_str)\n        original, _ = cleanup_key(original_str)\n        if synonym != original:\n            from_name[original].extend(from_name[synonym])\n            from_name[synonym].extend(from_name[original])\n\ndevice = None\ndef build_device():\n    global device\n    if device: return\n    ensure_root()\n    device = aggregate_devices(\'kbd\')\n\ndef init():\n    build_device()\n    build_tables()\n\npressed_modifiers = set()\n\ndef listen(callback):\n    build_device()\n    build_tables()\n\n    while True:\n        time, type, code, value, device_id = device.read_event()\n        if type != EV_KEY:\n            continue\n\n        scan_code = code\n        event_type = KEY_DOWN if value else KEY_UP # 0 = UP, 1 = DOWN, 2 = HOLD\n\n        pressed_modifiers_tuple = tuple(sorted(pressed_modifiers))\n        names = to_name[(scan_code, pressed_modifiers_tuple)] or to_name[(scan_code, ())] or [\'unknown\']\n        name = names[0]\n            \n        if name in all_modifiers:\n            if event_type == KEY_DOWN:\n                pressed_modifiers.add(name)\n            else:\n                pressed_modifiers.discard(name)\n\n        is_keypad = scan_code in keypad_scan_codes\n        callback(KeyboardEvent(event_type=event_type, scan_code=scan_code, name=name, time=time, device=device_id, is_keypad=is_keypad, modifiers=pressed_modifiers_tuple))\n\ndef write_event(scan_code, is_down):\n    build_device()\n    device.write_event(EV_KEY, scan_code, int(is_down))\n\ndef map_name(name):\n    build_tables()\n    for entry in from_name[name]:\n        yield entry\n\n    parts = name.split(\' \', 1)\n    if len(parts) > 1 and parts[0] in (\'left\', \'right\'):\n        for entry in from_name[parts[1]]:\n            yield entry\n\ndef press(scan_code):\n    write_event(scan_code, True)\n\ndef release(scan_code):\n    write_event(scan_code, False)\n\ndef type_unicode(character):\n    codepoint = ord(character)\n    hexadecimal = hex(codepoint)[len(\'0x\'):]\n\n    for key in [\'ctrl\', \'shift\', \'u\']:\n        scan_code, _ = next(map_name(key))\n        press(scan_code)\n\n    for key in hexadecimal:\n        scan_code, _ = next(map_name(key))\n        press(scan_code)\n        release(scan_code)\n\n    for key in [\'ctrl\', \'shift\', \'u\']:\n        scan_code, _ = next(map_name(key))\n        release(scan_code)\n\nif __name__ == \'__main__\':\n    def p(e):\n        print(e)\n    listen(p)\n'"
External_Libraries/keyboard_master/keyboard/_nixmouse.py,0,"b'# -*- coding: utf-8 -*-\nimport struct\nfrom subprocess import check_output\nimport re\nfrom ._nixcommon import EV_KEY, EV_REL, EV_MSC, EV_SYN, EV_ABS, aggregate_devices, ensure_root\nfrom ._mouse_event import ButtonEvent, WheelEvent, MoveEvent, LEFT, RIGHT, MIDDLE, X, X2, UP, DOWN\n\nimport ctypes\nimport ctypes.util\nfrom ctypes import c_uint32, c_uint, c_int, byref\n\ndisplay = None\nwindow = None\nx11 = None\ndef build_display():\n    global display, window, x11\n    if display and window and x11: return\n    x11 = ctypes.cdll.LoadLibrary(ctypes.util.find_library(\'X11\'))\n    # Required because we will have multiple threads calling x11,\n    # such as the listener thread and then main using ""move_to"".\n    x11.XInitThreads()\n    display = x11.XOpenDisplay(None)\n    # Known to cause segfault in Fedora 23 64bits, no known workarounds.\n    # http://stackoverflow.com/questions/35137007/get-mouse-position-on-linux-pure-python\n    window = x11.XDefaultRootWindow(display)\n\ndef get_position():\n    build_display()\n    root_id, child_id = c_uint32(), c_uint32()\n    root_x, root_y, win_x, win_y = c_int(), c_int(), c_int(), c_int()\n    mask = c_uint()\n    ret = x11.XQueryPointer(display, c_uint32(window), byref(root_id), byref(child_id),\n                            byref(root_x), byref(root_y),\n                            byref(win_x), byref(win_y), byref(mask))\n    return root_x.value, root_y.value\n\ndef move_to(x, y):\n    build_display()\n    x11.XWarpPointer(display, None, window, 0, 0, 0, 0, x, y)\n    x11.XFlush(display)\n\nREL_X = 0x00\nREL_Y = 0x01\nREL_Z = 0x02\nREL_HWHEEL = 0x06\nREL_WHEEL = 0x08\n\nABS_X = 0x00\nABS_Y = 0x01\n\nBTN_MOUSE = 0x110\nBTN_LEFT = 0x110\nBTN_RIGHT = 0x111\nBTN_MIDDLE = 0x112\nBTN_SIDE = 0x113\nBTN_EXTRA = 0x114\n\nbutton_by_code = {\n    BTN_LEFT: LEFT,\n    BTN_RIGHT: RIGHT,\n    BTN_MIDDLE: MIDDLE,\n    BTN_SIDE: X,\n    BTN_EXTRA: X2,\n}\ncode_by_button = {button: code for code, button in button_by_code.items()}\n\ndevice = None\ndef build_device():\n    global device\n    if device: return\n    ensure_root()\n    device = aggregate_devices(\'mouse\')\ninit = build_device\n\ndef listen(queue):\n    build_device()\n\n    while True:\n        time, type, code, value, device_id = device.read_event()\n        if type == EV_SYN or type == EV_MSC:\n            continue\n\n        event = None\n        arg = None\n\n        if type == EV_KEY:\n            event = ButtonEvent(DOWN if value else UP, button_by_code.get(code, \'?\'), time)\n        elif type == EV_REL:\n            value, = struct.unpack(\'i\', struct.pack(\'I\', value))\n\n            if code == REL_WHEEL:\n                event = WheelEvent(value, time)\n            elif code in (REL_X, REL_Y):\n                x, y = get_position()\n                event = MoveEvent(x, y, time)\n\n        if event is None:\n            # Unknown event type.\n            continue\n\n        queue.put(event)\n\ndef press(button=LEFT):\n    build_device()\n    device.write_event(EV_KEY, code_by_button[button], 0x01)\n\ndef release(button=LEFT):\n    build_device()\n    device.write_event(EV_KEY, code_by_button[button], 0x00)\n\ndef move_relative(x, y):\n    build_device()\n    # Note relative events are not in terms of pixels, but millimeters.\n    if x < 0:\n        x += 2**32\n    if y < 0:\n        y += 2**32\n    device.write_event(EV_REL, REL_X, x)\n    device.write_event(EV_REL, REL_Y, y)\n\ndef wheel(delta=1):\n    build_device()\n    if delta < 0:\n        delta += 2**32\n    device.write_event(EV_REL, REL_WHEEL, delta)\n\n\nif __name__ == \'__main__\':\n    #listen(print)\n    move_to(100, 200)\n'"
External_Libraries/keyboard_master/keyboard/_winkeyboard.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nThis is the Windows backend for keyboard events, and is implemented by\ninvoking the Win32 API through the ctypes module. This is error prone\nand can introduce very unpythonic failure modes, such as segfaults and\nlow level memory leaks. But it is also dependency-free, very performant\nwell documented on Microsoft\'s website and scattered examples.\n\n# TODO:\n- Keypad numbers still print as numbers even when numlock is off.\n- No way to specify if user wants a keypad key or not in `map_char`.\n""""""\nfrom __future__ import unicode_literals\nimport re\nimport atexit\nimport traceback\nfrom threading import Lock\nfrom collections import defaultdict\n\nfrom ._keyboard_event import KeyboardEvent, KEY_DOWN, KEY_UP\nfrom ._canonical_names import normalize_name\ntry:\n    # Force Python2 to convert to unicode and not to str.\n    chr = unichr\nexcept NameError:\n    pass\n\n# This part is just declaring Win32 API structures using ctypes. In C\n# this would be simply #include ""windows.h"".\n\nimport ctypes\nfrom ctypes import c_short, c_char, c_uint8, c_int32, c_int, c_uint, c_uint32, c_long, Structure, CFUNCTYPE, POINTER\nfrom ctypes.wintypes import WORD, DWORD, BOOL, HHOOK, MSG, LPWSTR, WCHAR, WPARAM, LPARAM, LONG, HMODULE, LPCWSTR, HINSTANCE, HWND\nLPMSG = POINTER(MSG)\nULONG_PTR = POINTER(DWORD)\n\nkernel32 = ctypes.WinDLL(\'kernel32\', use_last_error=True)\nGetModuleHandleW = kernel32.GetModuleHandleW\nGetModuleHandleW.restype = HMODULE\nGetModuleHandleW.argtypes = [LPCWSTR]\n\n#https://github.com/boppreh/mouse/issues/1\n#user32 = ctypes.windll.user32\nuser32 = ctypes.WinDLL(\'user32\', use_last_error = True)\n\nVK_PACKET = 0xE7\n\nINPUT_MOUSE = 0\nINPUT_KEYBOARD = 1\nINPUT_HARDWARE = 2\n\nKEYEVENTF_KEYUP = 0x02\nKEYEVENTF_UNICODE = 0x04\n\nclass KBDLLHOOKSTRUCT(Structure):\n    _fields_ = [(""vk_code"", DWORD),\n                (""scan_code"", DWORD),\n                (""flags"", DWORD),\n                (""time"", c_int),\n                (""dwExtraInfo"", ULONG_PTR)]\n\n# Included for completeness.\nclass MOUSEINPUT(ctypes.Structure):\n    _fields_ = ((\'dx\', LONG),\n                (\'dy\', LONG),\n                (\'mouseData\', DWORD),\n                (\'dwFlags\', DWORD),\n                (\'time\', DWORD),\n                (\'dwExtraInfo\', ULONG_PTR))\n\nclass KEYBDINPUT(ctypes.Structure):\n    _fields_ = ((\'wVk\', WORD),\n                (\'wScan\', WORD),\n                (\'dwFlags\', DWORD),\n                (\'time\', DWORD),\n                (\'dwExtraInfo\', ULONG_PTR))\n\nclass HARDWAREINPUT(ctypes.Structure):\n    _fields_ = ((\'uMsg\', DWORD),\n                (\'wParamL\', WORD),\n                (\'wParamH\', WORD))\n\nclass _INPUTunion(ctypes.Union):\n    _fields_ = ((\'mi\', MOUSEINPUT),\n                (\'ki\', KEYBDINPUT),\n                (\'hi\', HARDWAREINPUT))\n\nclass INPUT(ctypes.Structure):\n    _fields_ = ((\'type\', DWORD),\n                (\'union\', _INPUTunion))\n\nLowLevelKeyboardProc = CFUNCTYPE(c_int, WPARAM, LPARAM, POINTER(KBDLLHOOKSTRUCT))\n\nSetWindowsHookEx = user32.SetWindowsHookExW\nSetWindowsHookEx.argtypes = [c_int, LowLevelKeyboardProc, HINSTANCE , DWORD]\nSetWindowsHookEx.restype = HHOOK\n\nCallNextHookEx = user32.CallNextHookEx\n#CallNextHookEx.argtypes = [c_int , c_int, c_int, POINTER(KBDLLHOOKSTRUCT)]\nCallNextHookEx.restype = c_int\n\nUnhookWindowsHookEx = user32.UnhookWindowsHookEx\nUnhookWindowsHookEx.argtypes = [HHOOK]\nUnhookWindowsHookEx.restype = BOOL\n\nGetMessage = user32.GetMessageW\nGetMessage.argtypes = [LPMSG, HWND, c_uint, c_uint]\nGetMessage.restype = BOOL\n\nTranslateMessage = user32.TranslateMessage\nTranslateMessage.argtypes = [LPMSG]\nTranslateMessage.restype = BOOL\n\nDispatchMessage = user32.DispatchMessageA\nDispatchMessage.argtypes = [LPMSG]\n\n\nkeyboard_state_type = c_uint8 * 256\n\nGetKeyboardState = user32.GetKeyboardState\nGetKeyboardState.argtypes = [keyboard_state_type]\nGetKeyboardState.restype = BOOL\n\nGetKeyNameText = user32.GetKeyNameTextW\nGetKeyNameText.argtypes = [c_long, LPWSTR, c_int]\nGetKeyNameText.restype = c_int\n\nMapVirtualKey = user32.MapVirtualKeyW\nMapVirtualKey.argtypes = [c_uint, c_uint]\nMapVirtualKey.restype = c_uint\n\nToUnicode = user32.ToUnicode\nToUnicode.argtypes = [c_uint, c_uint, keyboard_state_type, LPWSTR, c_int, c_uint]\nToUnicode.restype = c_int\n\nSendInput = user32.SendInput\nSendInput.argtypes = [c_uint, POINTER(INPUT), c_int]\nSendInput.restype = c_uint\n\n# https://msdn.microsoft.com/en-us/library/windows/desktop/ms646307(v=vs.85).aspx\nMAPVK_VK_TO_CHAR = 2\nMAPVK_VK_TO_VSC = 0\nMAPVK_VSC_TO_VK = 1\nMAPVK_VK_TO_VSC_EX = 4\nMAPVK_VSC_TO_VK_EX = 3 \n\nVkKeyScan = user32.VkKeyScanW\nVkKeyScan.argtypes = [WCHAR]\nVkKeyScan.restype = c_short\n\nLLKHF_INJECTED = 0x00000010\n\nWM_KEYDOWN = 0x0100\nWM_KEYUP = 0x0101\nWM_SYSKEYDOWN = 0x104 # Used for ALT key\nWM_SYSKEYUP = 0x105\n\n\n# This marks the end of Win32 API declarations. The rest is ours.\n\nkeyboard_event_types = {\n    WM_KEYDOWN: KEY_DOWN,\n    WM_KEYUP: KEY_UP,\n    WM_SYSKEYDOWN: KEY_DOWN,\n    WM_SYSKEYUP: KEY_UP,\n}\n\n# List taken from the official documentation, but stripped of the OEM-specific keys.\n# Keys are virtual key codes, values are pairs (name, is_keypad).\nofficial_virtual_keys = {\n    0x03: (\'control-break processing\', False),\n    0x08: (\'backspace\', False),\n    0x09: (\'tab\', False),\n    0x0c: (\'clear\', False),\n    0x0d: (\'enter\', False),\n    0x10: (\'shift\', False),\n    0x11: (\'ctrl\', False),\n    0x12: (\'alt\', False),\n    0x13: (\'pause\', False),\n    0x14: (\'caps lock\', False),\n    0x15: (\'ime kana mode\', False),\n    0x15: (\'ime hanguel mode\', False),\n    0x15: (\'ime hangul mode\', False),\n    0x17: (\'ime junja mode\', False),\n    0x18: (\'ime final mode\', False),\n    0x19: (\'ime hanja mode\', False),\n    0x19: (\'ime kanji mode\', False),\n    0x1b: (\'esc\', False),\n    0x1c: (\'ime convert\', False),\n    0x1d: (\'ime nonconvert\', False),\n    0x1e: (\'ime accept\', False),\n    0x1f: (\'ime mode change request\', False),\n    0x20: (\'spacebar\', False),\n    0x21: (\'page up\', False),\n    0x22: (\'page down\', False),\n    0x23: (\'end\', False),\n    0x24: (\'home\', False),\n    0x25: (\'left\', False),\n    0x26: (\'up\', False),\n    0x27: (\'right\', False),\n    0x28: (\'down\', False),\n    0x29: (\'select\', False),\n    0x2a: (\'print\', False),\n    0x2b: (\'execute\', False),\n    0x2c: (\'print screen\', False),\n    0x2d: (\'insert\', False),\n    0x2e: (\'delete\', False),\n    0x2f: (\'help\', False),\n    0x30: (\'0\', False),\n    0x31: (\'1\', False),\n    0x32: (\'2\', False),\n    0x33: (\'3\', False),\n    0x34: (\'4\', False),\n    0x35: (\'5\', False),\n    0x36: (\'6\', False),\n    0x37: (\'7\', False),\n    0x38: (\'8\', False),\n    0x39: (\'9\', False),\n    0x41: (\'a\', False),\n    0x42: (\'b\', False),\n    0x43: (\'c\', False),\n    0x44: (\'d\', False),\n    0x45: (\'e\', False),\n    0x46: (\'f\', False),\n    0x47: (\'g\', False),\n    0x48: (\'h\', False),\n    0x49: (\'i\', False),\n    0x4a: (\'j\', False),\n    0x4b: (\'k\', False),\n    0x4c: (\'l\', False),\n    0x4d: (\'m\', False),\n    0x4e: (\'n\', False),\n    0x4f: (\'o\', False),\n    0x50: (\'p\', False),\n    0x51: (\'q\', False),\n    0x52: (\'r\', False),\n    0x53: (\'s\', False),\n    0x54: (\'t\', False),\n    0x55: (\'u\', False),\n    0x56: (\'v\', False),\n    0x57: (\'w\', False),\n    0x58: (\'x\', False),\n    0x59: (\'y\', False),\n    0x5a: (\'z\', False),\n    0x5b: (\'left windows\', False),\n    0x5c: (\'right windows\', False),\n    0x5d: (\'applications\', False),\n    0x5f: (\'sleep\', False),\n    0x60: (\'0\', True),\n    0x61: (\'1\', True),\n    0x62: (\'2\', True),\n    0x63: (\'3\', True),\n    0x64: (\'4\', True),\n    0x65: (\'5\', True),\n    0x66: (\'6\', True),\n    0x67: (\'7\', True),\n    0x68: (\'8\', True),\n    0x69: (\'9\', True),\n    0x6a: (\'*\', True),\n    0x6b: (\'+\', True),\n    0x6c: (\'separator\', True),\n    0x6d: (\'-\', True),\n    0x6e: (\'decimal\', True),\n    0x6f: (\'/\', True),\n    0x70: (\'f1\', False),\n    0x71: (\'f2\', False),\n    0x72: (\'f3\', False),\n    0x73: (\'f4\', False),\n    0x74: (\'f5\', False),\n    0x75: (\'f6\', False),\n    0x76: (\'f7\', False),\n    0x77: (\'f8\', False),\n    0x78: (\'f9\', False),\n    0x79: (\'f10\', False),\n    0x7a: (\'f11\', False),\n    0x7b: (\'f12\', False),\n    0x7c: (\'f13\', False),\n    0x7d: (\'f14\', False),\n    0x7e: (\'f15\', False),\n    0x7f: (\'f16\', False),\n    0x80: (\'f17\', False),\n    0x81: (\'f18\', False),\n    0x82: (\'f19\', False),\n    0x83: (\'f20\', False),\n    0x84: (\'f21\', False),\n    0x85: (\'f22\', False),\n    0x86: (\'f23\', False),\n    0x87: (\'f24\', False),\n    0x90: (\'num lock\', False),\n    0x91: (\'scroll lock\', False),\n    0xa0: (\'left shift\', False),\n    0xa1: (\'right shift\', False),\n    0xa2: (\'left ctrl\', False),\n    0xa3: (\'right ctrl\', False),\n    0xa4: (\'left menu\', False),\n    0xa5: (\'right menu\', False),\n    0xa6: (\'browser back\', False),\n    0xa7: (\'browser forward\', False),\n    0xa8: (\'browser refresh\', False),\n    0xa9: (\'browser stop\', False),\n    0xaa: (\'browser search key\', False),\n    0xab: (\'browser favorites\', False),\n    0xac: (\'browser start and home\', False),\n    0xad: (\'volume mute\', False),\n    0xae: (\'volume down\', False),\n    0xaf: (\'volume up\', False),\n    0xb0: (\'next track\', False),\n    0xb1: (\'previous track\', False),\n    0xb2: (\'stop media\', False),\n    0xb3: (\'play/pause media\', False),\n    0xb4: (\'start mail\', False),\n    0xb5: (\'select media\', False),\n    0xb6: (\'start application 1\', False),\n    0xb7: (\'start application 2\', False),\n    0xbb: (\'+\', False),\n    0xbc: (\',\', False),\n    0xbd: (\'-\', False),\n    0xbe: (\'.\', False),\n    #0xbe:(\'/\', False), # Used for miscellaneous characters; it can vary by keyboard. For the US standard keyboard, the \'/?.\n    0xe5: (\'ime process\', False),\n    0xf6: (\'attn\', False),\n    0xf7: (\'crsel\', False),\n    0xf8: (\'exsel\', False),\n    0xf9: (\'erase eof\', False),\n    0xfa: (\'play\', False),\n    0xfb: (\'zoom\', False),\n    0xfc: (\'reserved \', False),\n    0xfd: (\'pa1\', False),\n    0xfe: (\'clear\', False),\n}\n\ntables_lock = Lock()\nto_name = defaultdict(list)\nfrom_name = defaultdict(list)\nscan_code_to_vk = {}\n\ndistinct_modifiers = [\n    (),\n    (\'shift\',),\n    (\'alt gr\',),\n    (\'num lock\',),\n    (\'shift\', \'num lock\'),\n    (\'caps lock\',),\n    (\'shift\', \'caps lock\'),\n    (\'alt gr\', \'num lock\'),\n]\n\nname_buffer = ctypes.create_unicode_buffer(32)\nunicode_buffer = ctypes.create_unicode_buffer(32)\nkeyboard_state = keyboard_state_type()\ndef get_event_names(scan_code, vk, is_extended, modifiers):\n    is_keypad = (scan_code, vk, is_extended) in keypad_keys\n    is_official = vk in official_virtual_keys\n    if is_keypad and is_official:\n        yield official_virtual_keys[vk][0]\n\n    keyboard_state[0x10] = 0x80 * (\'shift\' in modifiers)\n    keyboard_state[0x11] = 0x80 * (\'alt gr\' in modifiers)\n    keyboard_state[0x12] = 0x80 * (\'alt gr\' in modifiers)\n    keyboard_state[0x14] = 0x01 * (\'caps lock\' in modifiers)\n    keyboard_state[0x90] = 0x01 * (\'num lock\' in modifiers)\n    keyboard_state[0x91] = 0x01 * (\'scroll lock\' in modifiers)\n    unicode_ret = ToUnicode(vk, scan_code, keyboard_state, unicode_buffer, len(unicode_buffer), 0)\n    if unicode_ret and unicode_buffer.value:\n        yield unicode_buffer.value\n        # unicode_ret == -1 -> is dead key\n        # ToUnicode has the side effect of setting global flags for dead keys.\n        # Therefore we need to call it twice to clear those flags.\n        # If your 6 and 7 keys are named ""^6"" and ""^7"", this is the reason.\n        ToUnicode(vk, scan_code, keyboard_state, unicode_buffer, len(unicode_buffer), 0)\n\n    name_ret = GetKeyNameText(scan_code << 16 | is_extended << 24, name_buffer, 1024)\n    if name_ret and name_buffer.value:\n        yield name_buffer.value\n\n    char = user32.MapVirtualKeyW(vk, MAPVK_VK_TO_CHAR) & 0xFF\n    if char != 0:\n        yield chr(char)\n\n    if not is_keypad and is_official:\n        yield official_virtual_keys[vk][0]\n\ndef _setup_name_tables():\n    """"""\n    Ensures the scan code/virtual key code/name translation tables are\n    filled.\n    """"""\n    with tables_lock:\n        if to_name: return\n\n        # Go through every possible scan code, and map them to virtual key codes.\n        # Then vice-versa.\n        all_scan_codes = [(sc, user32.MapVirtualKeyExW(sc, MAPVK_VSC_TO_VK_EX, 0)) for sc in range(0x100)]\n        all_vks =        [(user32.MapVirtualKeyExW(vk, MAPVK_VK_TO_VSC_EX, 0), vk) for vk in range(0x100)]\n        for scan_code, vk in all_scan_codes + all_vks:\n            # `to_name` and `from_name` entries will be a tuple (scan_code, vk, extended, shift_state).\n            if (scan_code, vk, 0, 0, 0) in to_name:\n                continue\n\n            if scan_code not in scan_code_to_vk:\n                scan_code_to_vk[scan_code] = vk\n\n            # Brute force all combinations to find all possible names.\n            for extended in [0, 1]:\n                for modifiers in distinct_modifiers:\n                    entry = (scan_code, vk, extended, modifiers)\n                    # Get key names from ToUnicode, GetKeyNameText, MapVirtualKeyW and official virtual keys.\n                    names = list(get_event_names(*entry))\n                    if names:\n                        # Also map lowercased key names, but only after the properly cased ones.\n                        lowercase_names = [name.lower() for name in names]\n                        to_name[entry] = names + lowercase_names\n                        # Remember the ""id"" of the name, as the first techniques\n                        # have better results and therefore priority.\n                        for i, name in enumerate(map(normalize_name, names + lowercase_names)):\n                            from_name[name].append((i, entry))\n\n        # TODO: single quotes on US INTL is returning the dead key (?), and therefore\n        # not typing properly.\n\n        # Alt gr is way outside the usual range of keys (0..127) and on my\n        # computer is named as \'ctrl\'. Therefore we add it manually and hope\n        # Windows is consistent in its inconsistency.\n        for extended in [0, 1]:\n            for modifiers in distinct_modifiers:\n                to_name[(541, 162, extended, modifiers)] = [\'alt gr\']\n                from_name[\'alt gr\'].append((1, (541, 162, extended, modifiers)))\n\n    modifiers_preference = defaultdict(lambda: 10)\n    modifiers_preference.update({(): 0, (\'shift\',): 1, (\'alt gr\',): 2, (\'ctrl\',): 3, (\'alt\',): 4})\n    def order_key(line):\n        i, entry = line\n        scan_code, vk, extended, modifiers = entry\n        return modifiers_preference[modifiers], i, extended, vk, scan_code\n    for name, entries in list(from_name.items()):\n        from_name[name] = sorted(set(entries), key=order_key)\n\n# Called by keyboard/__init__.py\ninit = _setup_name_tables\n\n# List created manually.\nkeypad_keys = [\n    # (scan_code, virtual_key_code, is_extended)\n    (126, 194, 0),\n    (126, 194, 0),\n    (28, 13, 1),\n    (28, 13, 1),\n    (53, 111, 1),\n    (53, 111, 1),\n    (55, 106, 0),\n    (55, 106, 0),\n    (69, 144, 1),\n    (69, 144, 1),\n    (71, 103, 0),\n    (71, 36, 0),\n    (72, 104, 0),\n    (72, 38, 0),\n    (73, 105, 0),\n    (73, 33, 0),\n    (74, 109, 0),\n    (74, 109, 0),\n    (75, 100, 0),\n    (75, 37, 0),\n    (76, 101, 0),\n    (76, 12, 0),\n    (77, 102, 0),\n    (77, 39, 0),\n    (78, 107, 0),\n    (78, 107, 0),\n    (79, 35, 0),\n    (79, 97, 0),\n    (80, 40, 0),\n    (80, 98, 0),\n    (81, 34, 0),\n    (81, 99, 0),\n    (82, 45, 0),\n    (82, 96, 0),\n    (83, 110, 0),\n    (83, 46, 0),\n]\n\nshift_is_pressed = False\naltgr_is_pressed = False\nignore_next_right_alt = False\nshift_vks = set([0x10, 0xa0, 0xa1])\ndef prepare_intercept(callback):\n    """"""\n    Registers a Windows low level keyboard hook. The provided callback will\n    be invoked for each high-level keyboard event, and is expected to return\n    True if the key event should be passed to the next program, or False if\n    the event is to be blocked.\n\n    No event is processed until the Windows messages are pumped (see\n    start_intercept).\n    """"""\n    _setup_name_tables()\n    \n    def process_key(event_type, vk, scan_code, is_extended):\n        global shift_is_pressed, altgr_is_pressed, ignore_next_right_alt\n        #print(event_type, vk, scan_code, is_extended)\n\n        # Pressing alt-gr also generates an extra ""right alt"" event\n        if vk == 0xA5 and ignore_next_right_alt:\n            ignore_next_right_alt = False\n            return True\n\n        modifiers = (\n            (\'shift\',) * shift_is_pressed +\n            (\'alt gr\',) * altgr_is_pressed +\n            (\'num lock\',) * (user32.GetKeyState(0x90) & 1) +\n            (\'caps lock\',) * (user32.GetKeyState(0x14) & 1) +\n            (\'scroll lock\',) * (user32.GetKeyState(0x91) & 1)\n        )\n        entry = (scan_code, vk, is_extended, modifiers)\n        if entry not in to_name:\n            to_name[entry] = list(get_event_names(*entry))\n\n        names = to_name[entry]\n        name = names[0] if names else None\n\n        # TODO: inaccurate when holding multiple different shifts.\n        if vk in shift_vks:\n            shift_is_pressed = event_type == KEY_DOWN\n        if scan_code == 541 and vk == 162:\n            ignore_next_right_alt = True\n            altgr_is_pressed = event_type == KEY_DOWN\n\n        is_keypad = (scan_code, vk, is_extended) in keypad_keys\n        return callback(KeyboardEvent(event_type=event_type, scan_code=scan_code or -vk, name=name, is_keypad=is_keypad))\n\n    def low_level_keyboard_handler(nCode, wParam, lParam):\n        try:\n            vk = lParam.contents.vk_code\n            # Ignore the second `alt` DOWN observed in some cases.\n            fake_alt = (LLKHF_INJECTED | 0x20)\n            # Ignore events generated by SendInput with Unicode.\n            if vk != VK_PACKET and lParam.contents.flags & fake_alt != fake_alt:\n                event_type = keyboard_event_types[wParam]\n                is_extended = lParam.contents.flags & 1\n                scan_code = lParam.contents.scan_code\n                should_continue = process_key(event_type, vk, scan_code, is_extended)\n                if not should_continue:\n                    return -1\n        except Exception as e:\n            print(\'Error in keyboard hook:\')\n            traceback.print_exc()\n\n        return CallNextHookEx(None, nCode, wParam, lParam)\n\n    WH_KEYBOARD_LL = c_int(13)\n    keyboard_callback = LowLevelKeyboardProc(low_level_keyboard_handler)\n    handle =  GetModuleHandleW(None)\n    thread_id = DWORD(0)\n    keyboard_hook = SetWindowsHookEx(WH_KEYBOARD_LL, keyboard_callback, handle, thread_id)\n\n    # Register to remove the hook when the interpreter exits. Unfortunately a\n    # try/finally block doesn\'t seem to work here.\n    atexit.register(UnhookWindowsHookEx, keyboard_callback)\n\ndef listen(callback):\n    prepare_intercept(callback)\n    msg = LPMSG()\n    while not GetMessage(msg, 0, 0, 0):\n        TranslateMessage(msg)\n        DispatchMessage(msg)\n\ndef map_name(name):\n    _setup_name_tables()\n\n    entries = from_name.get(name)\n    if not entries:\n        raise ValueError(\'Key name {} is not mapped to any known key.\'.format(repr(name)))\n    for i, entry in entries:\n        scan_code, vk, is_extended, modifiers = entry\n        yield scan_code or -vk, modifiers\n\ndef _send_event(code, event_type):\n    if code == 541:\n        # Alt-gr is made of ctrl+alt. Just sending even 541 doesn\'t do anything.\n        user32.keybd_event(0x11, code, event_type, 0)\n        user32.keybd_event(0x12, code, event_type, 0)\n    elif code > 0:\n        vk = scan_code_to_vk.get(code, 0)\n        user32.keybd_event(vk, code, event_type, 0)\n    else:\n        # Negative scan code is a way to indicate we don\'t have a scan code,\n        # and the value actually contains the Virtual key code.\n        user32.keybd_event(-code, 0, event_type, 0)\n\ndef press(code):\n    _send_event(code, 0)\n\ndef release(code):\n    _send_event(code, 2)\n\ndef type_unicode(character):\n    # This code and related structures are based on\n    # http://stackoverflow.com/a/11910555/252218\n    surrogates = bytearray(character.encode(\'utf-16le\'))\n    presses = []\n    releases = []\n    for i in range(0, len(surrogates), 2):\n        higher, lower = surrogates[i:i+2]\n        structure = KEYBDINPUT(0, (lower << 8) + higher, KEYEVENTF_UNICODE, 0, None)\n        presses.append(INPUT(INPUT_KEYBOARD, _INPUTunion(ki=structure)))\n        structure = KEYBDINPUT(0, (lower << 8) + higher, KEYEVENTF_UNICODE | KEYEVENTF_KEYUP, 0, None)\n        releases.append(INPUT(INPUT_KEYBOARD, _INPUTunion(ki=structure)))\n    inputs = presses + releases\n    nInputs = len(inputs)\n    LPINPUT = INPUT * nInputs\n    pInputs = LPINPUT(*inputs)\n    cbSize = c_int(ctypes.sizeof(INPUT))\n    SendInput(nInputs, pInputs, cbSize)\n\nif __name__ == \'__main__\':\n    _setup_name_tables()\n    import pprint\n    pprint.pprint(to_name)\n    pprint.pprint(from_name)\n    #listen(lambda e: print(e.to_json()) or True)\n'"
External_Libraries/keyboard_master/keyboard/_winmouse.py,0,"b'# -*- coding: utf-8 -*-\nimport ctypes\nimport time\nfrom ctypes import c_short, c_char, c_uint8, c_int32, c_int, c_uint, c_uint32, c_long, byref, Structure, CFUNCTYPE, POINTER\nfrom ctypes.wintypes import DWORD, BOOL, HHOOK, MSG, LPWSTR, WCHAR, WPARAM, LPARAM\nLPMSG = POINTER(MSG)\n\nimport atexit\n\nfrom ._mouse_event import ButtonEvent, WheelEvent, MoveEvent, LEFT, RIGHT, MIDDLE, X, X2, UP, DOWN, DOUBLE, WHEEL, HORIZONTAL, VERTICAL\n\n#https://github.com/boppreh/mouse/issues/1\n#user32 = ctypes.windll.user32\nuser32 = ctypes.WinDLL(\'user32\', use_last_error = True)\n\nclass MSLLHOOKSTRUCT(Structure):\n    _fields_ = [(""x"", c_long),\n                (""y"", c_long),\n                (\'data\', c_int32),\n                (\'reserved\', c_int32),\n                (""flags"", DWORD),\n                (""time"", c_int),\n                ]\n\nLowLevelMouseProc = CFUNCTYPE(c_int, WPARAM, LPARAM, POINTER(MSLLHOOKSTRUCT))\n\nSetWindowsHookEx = user32.SetWindowsHookExA\n#SetWindowsHookEx.argtypes = [c_int, LowLevelMouseProc, c_int, c_int]\nSetWindowsHookEx.restype = HHOOK\n\nCallNextHookEx = user32.CallNextHookEx\n#CallNextHookEx.argtypes = [c_int , c_int, c_int, POINTER(MSLLHOOKSTRUCT)]\nCallNextHookEx.restype = c_int\n\nUnhookWindowsHookEx = user32.UnhookWindowsHookEx\nUnhookWindowsHookEx.argtypes = [HHOOK]\nUnhookWindowsHookEx.restype = BOOL\n\nGetMessage = user32.GetMessageW\nGetMessage.argtypes = [LPMSG, c_int, c_int, c_int]\nGetMessage.restype = BOOL\n\nTranslateMessage = user32.TranslateMessage\nTranslateMessage.argtypes = [LPMSG]\nTranslateMessage.restype = BOOL\n\nDispatchMessage = user32.DispatchMessageA\nDispatchMessage.argtypes = [LPMSG]\n\n# Beware, as of 2016-01-30 the official docs have a very incomplete list.\n# This one was compiled from experience and may be incomplete.\nWM_MOUSEMOVE = 0x200\nWM_LBUTTONDOWN = 0x201\nWM_LBUTTONUP = 0x202\nWM_LBUTTONDBLCLK = 0x203\nWM_RBUTTONDOWN = 0x204\nWM_RBUTTONUP = 0x205\nWM_RBUTTONDBLCLK = 0x206\nWM_MBUTTONDOWN = 0x207\nWM_MBUTTONUP = 0x208\nWM_MBUTTONDBLCLK = 0x209\nWM_MOUSEWHEEL = 0x20A\nWM_XBUTTONDOWN = 0x20B\nWM_XBUTTONUP = 0x20C\nWM_XBUTTONDBLCLK = 0x20D\nWM_NCXBUTTONDOWN = 0x00AB\nWM_NCXBUTTONUP = 0x00AC\nWM_NCXBUTTONDBLCLK = 0x00AD\nWM_MOUSEHWHEEL = 0x20E\nWM_LBUTTONDOWN = 0x0201\nWM_LBUTTONUP = 0x0202\nWM_MOUSEMOVE = 0x0200\nWM_MOUSEWHEEL = 0x020A\nWM_MOUSEHWHEEL = 0x020E\nWM_RBUTTONDOWN = 0x0204\nWM_RBUTTONUP = 0x0205\n\nbuttons_by_wm_code = {\n    WM_LBUTTONDOWN: (DOWN, LEFT),\n    WM_LBUTTONUP: (UP, LEFT),\n    WM_LBUTTONDBLCLK: (DOUBLE, LEFT),\n\n    WM_RBUTTONDOWN: (DOWN, RIGHT),\n    WM_RBUTTONUP: (UP, RIGHT),\n    WM_RBUTTONDBLCLK: (DOUBLE, RIGHT),\n\n    WM_MBUTTONDOWN: (DOWN, MIDDLE),\n    WM_MBUTTONUP: (UP, MIDDLE),\n    WM_MBUTTONDBLCLK: (DOUBLE, MIDDLE),\n\n    WM_XBUTTONDOWN: (DOWN, X),\n    WM_XBUTTONUP: (UP, X),\n    WM_XBUTTONDBLCLK: (DOUBLE, X),\n}\n\nMOUSEEVENTF_ABSOLUTE = 0x8000\nMOUSEEVENTF_MOVE = 0x1\nMOUSEEVENTF_WHEEL = 0x800\nMOUSEEVENTF_HWHEEL = 0x1000\nMOUSEEVENTF_LEFTDOWN = 0x2\nMOUSEEVENTF_LEFTUP = 0x4\nMOUSEEVENTF_RIGHTDOWN = 0x8\nMOUSEEVENTF_RIGHTUP = 0x10\nMOUSEEVENTF_MIDDLEDOWN = 0x20\nMOUSEEVENTF_MIDDLEUP = 0x40\nMOUSEEVENTF_XDOWN = 0x0080\nMOUSEEVENTF_XUP = 0x0100\n\nsimulated_mouse_codes = {\n    (WHEEL, HORIZONTAL): MOUSEEVENTF_HWHEEL,\n    (WHEEL, VERTICAL): MOUSEEVENTF_WHEEL,\n\n    (DOWN, LEFT): MOUSEEVENTF_LEFTDOWN,\n    (UP, LEFT): MOUSEEVENTF_LEFTUP,\n\n    (DOWN, RIGHT): MOUSEEVENTF_RIGHTDOWN,\n    (UP, RIGHT): MOUSEEVENTF_RIGHTUP,\n\n    (DOWN, MIDDLE): MOUSEEVENTF_MIDDLEDOWN,\n    (UP, MIDDLE): MOUSEEVENTF_MIDDLEUP,\n\n    (DOWN, X): MOUSEEVENTF_XDOWN,\n    (UP, X): MOUSEEVENTF_XUP,\n}\n\nNULL = c_int(0)\n\nWHEEL_DELTA = 120\n\ninit = lambda: None\n\ndef listen(queue):\n    def low_level_mouse_handler(nCode, wParam, lParam):\n        struct = lParam.contents\n        # Can\'t use struct.time because it\'s usually zero.\n        t = time.time()\n\n        if wParam == WM_MOUSEMOVE:\n            event = MoveEvent(struct.x, struct.y, t)\n        elif wParam == WM_MOUSEWHEEL:\n            event = WheelEvent(struct.data / (WHEEL_DELTA * (2<<15)), t)\n        elif wParam in buttons_by_wm_code:\n            type, button = buttons_by_wm_code.get(wParam, (\'?\', \'?\'))\n            if wParam >= WM_XBUTTONDOWN:\n                button = {0x10000: X, 0x20000: X2}[struct.data]\n            event = ButtonEvent(type, button, t)\n\n        queue.put(event)\n        return CallNextHookEx(NULL, nCode, wParam, lParam)\n\n    WH_MOUSE_LL = c_int(14)\n    mouse_callback = LowLevelMouseProc(low_level_mouse_handler)\n    mouse_hook = SetWindowsHookEx(WH_MOUSE_LL, mouse_callback, NULL, NULL)\n\n    # Register to remove the hook when the interpreter exits. Unfortunately a\n    # try/finally block doesn\'t seem to work here.\n    atexit.register(UnhookWindowsHookEx, mouse_hook)\n\n    msg = LPMSG()\n    while not GetMessage(msg, NULL, NULL, NULL):\n        TranslateMessage(msg)\n        DispatchMessage(msg)\n\ndef _translate_button(button):\n    if button == X or button == X2:\n        return X, {X: 0x10000, X2: 0x20000}[button]\n    else:\n        return button, 0\n\ndef press(button=LEFT):\n    button, data = _translate_button(button)\n    code = simulated_mouse_codes[(DOWN, button)]\n    user32.mouse_event(code, 0, 0, data, 0)\n\ndef release(button=LEFT):\n    button, data = _translate_button(button)\n    code = simulated_mouse_codes[(UP, button)]\n    user32.mouse_event(code, 0, 0, data, 0)\n\ndef wheel(delta=1):\n    code = simulated_mouse_codes[(WHEEL, VERTICAL)]\n    user32.mouse_event(code, 0, 0, int(delta * WHEEL_DELTA), 0)\n\ndef move_to(x, y):\n    user32.SetCursorPos(int(x), int(y))\n\ndef move_relative(x, y):\n    user32.mouse_event(MOUSEEVENTF_MOVE, int(x), int(y), 0, 0)\n\nclass POINT(Structure):\n    _fields_ = [(""x"", c_long), (""y"", c_long)]\n\ndef get_position():\n    point = POINT()\n    user32.GetCursorPos(byref(point))\n    return (point.x, point.y)\n\nif __name__ == \'__main__\':\n    def p(e):\n        print(e)\n    listen(p)\n'"
External_Libraries/keyboard_master/keyboard/mouse.py,0,"b'# -*- coding: utf-8 -*-\nimport warnings\nwarnings.simplefilter(\'always\', DeprecationWarning)\nwarnings.warn(\'The mouse sub-library is deprecated and will be removed in future versions. Please use the standalone package `mouse`.\', DeprecationWarning, stacklevel=2)\n\nimport time as _time\n\nimport platform as _platform\nif _platform.system() == \'Windows\':\n    from. import _winmouse as _os_mouse\nelif _platform.system() == \'Linux\':\n    from. import _nixmouse as _os_mouse\nelif _platform.system() == \'Darwin\':\n    from. import _darwinmouse as _os_mouse\nelse:\n    raise OSError(""Unsupported platform \'{}\'"".format(_platform.system()))\n\nfrom ._mouse_event import ButtonEvent, MoveEvent, WheelEvent, LEFT, RIGHT, MIDDLE, X, X2, UP, DOWN, DOUBLE\nfrom ._generic import GenericListener as _GenericListener\n\n_pressed_events = set()\nclass _MouseListener(_GenericListener):\n    def init(self):\n        _os_mouse.init()\n    def pre_process_event(self, event):\n        if isinstance(event, ButtonEvent):\n            if event.event_type in (UP, DOUBLE):\n                _pressed_events.discard(event.button)\n            else:\n                _pressed_events.add(event.button)\n        return True\n\n    def listen(self):\n        _os_mouse.listen(self.queue)\n\n_listener = _MouseListener()\n\ndef is_pressed(button=LEFT):\n    """""" Returns True if the given button is currently pressed. """"""\n    _listener.start_if_necessary()\n    return button in _pressed_events\n\ndef press(button=LEFT):\n    """""" Presses the given button (but doesn\'t release). """"""\n    _os_mouse.press(button)\n\ndef release(button=LEFT):\n    """""" Releases the given button. """"""\n    _os_mouse.release(button)\n\ndef click(button=LEFT):\n    """""" Sends a click with the given button. """"""\n    _os_mouse.press(button)\n    _os_mouse.release(button)\n\ndef double_click(button=LEFT):\n    """""" Sends a double click with the given button. """"""\n    click(button)\n    click(button)\n\ndef right_click():\n    """""" Sends a right click with the given button. """"""\n    click(RIGHT)\n\ndef wheel(delta=1):\n    """""" Scrolls the wheel `delta` clicks. Sign indicates direction. """"""\n    _os_mouse.wheel(delta)\n\ndef move(x, y, absolute=True, duration=0):\n    """"""\n    Moves the mouse. If `absolute`, to position (x, y), otherwise move relative\n    to the current position. If `duration` is non-zero, animates the movement.\n    """"""\n    x = int(x)\n    y = int(y)\n\n    # Requires an extra system call on Linux, but `move_relative` is measured\n    # in millimiters so we would lose precision.\n    position_x, position_y = get_position()\n\n    if not absolute:\n        x = position_x + x\n        y = position_y + y\n\n    if duration:\n        start_x = position_x\n        start_y = position_y\n        dx = x - start_x\n        dy = y - start_y\n\n        if dx == 0 and dy == 0:\n            _time.sleep(duration)\n        else:\n            # 120 movements per second.\n            # Round and keep float to ensure float division in Python 2\n            steps = max(1.0, float(int(duration * 120.0)))\n            for i in range(int(steps)+1):\n                move(start_x + dx*i/steps, start_y + dy*i/steps)\n                _time.sleep(duration/steps)\n    else:\n        _os_mouse.move_to(x, y)\n\ndef drag(start_x, start_y, end_x, end_y, absolute=True, duration=0):\n    """"""\n    Holds the left mouse button, moving from start to end position, then\n    releases. `absolute` and `duration` are parameters regarding the mouse\n    movement.\n    """"""\n    if is_pressed():\n        release()\n    move(start_x, start_y, absolute, 0)\n    press()\n    move(end_x, end_y, absolute, duration)\n    release()\n\ndef on_button(callback, args=(), buttons=(LEFT, MIDDLE, RIGHT, X, X2), types=(UP, DOWN, DOUBLE)):\n    """""" Invokes `callback` with `args` when the specified event happens. """"""\n    if not isinstance(buttons, (tuple, list)):\n        buttons = (buttons,)\n    if not isinstance(types, (tuple, list)):\n        types = (types,)\n\n    def handler(event):\n        if isinstance(event, ButtonEvent):\n            if event.event_type in types and event.button in buttons:\n                callback(*args)\n    _listener.add_handler(handler)\n    return handler\n\ndef on_click(callback, args=()):\n    """""" Invokes `callback` with `args` when the left button is clicked. """"""\n    return on_button(callback, args, [LEFT], [UP])\n\ndef on_double_click(callback, args=()):\n    """"""\n    Invokes `callback` with `args` when the left button is double clicked.\n    """"""\n    return on_button(callback, args, [LEFT], [DOUBLE])\n\ndef on_right_click(callback, args=()):\n    """""" Invokes `callback` with `args` when the right button is clicked. """"""\n    return on_button(callback, args, [RIGHT], [UP])\n\ndef on_middle_click(callback, args=()):\n    """""" Invokes `callback` with `args` when the middle button is clicked. """"""\n    return on_button(callback, args, [MIDDLE], [UP])\n\ndef wait(button=LEFT, target_types=(UP, DOWN, DOUBLE)):\n    """"""\n    Blocks program execution until the given button performs an event.\n    """"""\n    from threading import Lock\n    lock = Lock()\n    lock.acquire()\n    handler = on_button(lock.release, (), [button], target_types)\n    lock.acquire()\n    _listener.remove_handler(handler)\n\ndef get_position():\n    """""" Returns the (x, y) mouse position. """"""\n    return _os_mouse.get_position()\n\ndef hook(callback):\n    """"""\n    Installs a global listener on all available mouses, invoking `callback`\n    each time it is moved, a key status changes or the wheel is spun. A mouse\n    event is passed as argument, with type either `mouse.ButtonEvent`,\n    `mouse.WheelEvent` or `mouse.MoveEvent`.\n    \n    Returns the given callback for easier development.\n    """"""\n    _listener.add_handler(callback)\n    return callback\n\ndef unhook(callback):\n    """"""\n    Removes a previously installed hook.\n    """"""\n    _listener.remove_handler(callback)\n\ndef unhook_all():\n    """"""\n    Removes all hooks registered by this application. Note this may include\n    hooks installed by high level functions, such as `record`.\n    """"""\n    del _listener.handlers[:]\n\ndef record(button=RIGHT, target_types=(DOWN,)):\n    """"""\n    Records all mouse events until the user presses the given button.\n    Then returns the list of events recorded. Pairs well with `play(events)`.\n\n    Note: this is a blocking function.\n    Note: for more details on the mouse hook and events see `hook`.\n    """"""\n    recorded = []\n    hook(recorded.append)\n    wait(button=button, target_types=target_types)\n    unhook(recorded.append)\n    return recorded\n\ndef play(events, speed_factor=1.0, include_clicks=True, include_moves=True, include_wheel=True):\n    """"""\n    Plays a sequence of recorded events, maintaining the relative time\n    intervals. If speed_factor is <= 0 then the actions are replayed as fast\n    as the OS allows. Pairs well with `record()`.\n\n    The parameters `include_*` define if events of that type should be inluded\n    in the replay or ignored.\n    """"""\n    last_time = None\n    for event in events:\n        if speed_factor > 0 and last_time is not None:\n            _time.sleep((event.time - last_time) / speed_factor)\n        last_time = event.time\n\n        if isinstance(event, ButtonEvent) and include_clicks:\n            if event.event_type == UP:\n                _os_mouse.release(event.button)\n            else:\n                _os_mouse.press(event.button)\n        elif isinstance(event, MoveEvent) and include_moves:\n            _os_mouse.move_to(event.x, event.y)\n        elif isinstance(event, WheelEvent) and include_wheel:\n            _os_mouse.wheel(event.delta)\n\nreplay = play\nhold = press\n\nif __name__ == \'__main__\':\n    print(\'Recording... Double click to stop and replay.\')\n    play(record())\n'"
External_Libraries/python_control_master/control/__init__.py,0,"b'# __init__.py - initialization for control systems toolbox\n#\n# Author: Richard M. Murray\n# Date: 24 May 09\n#\n# This file contains the initialization information from the control package.\n#\n# Copyright (c) 2009 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\n""""""\nThe Python Control Systems Library :mod:`control` provides common functions\nfor analyzing and designing feedback control systems.\n""""""\n\n# Import functions from within the control system library\n# Note: the functions we use are specified as __all__ variables in the modules\nfrom .bdalg import *\nfrom .delay import *\nfrom .dtime import *\nfrom .freqplot import *\nfrom .lti import *\nfrom .margins import *\nfrom .mateqn import *\nfrom .modelsimp import *\nfrom .nichols import *\nfrom .phaseplot import *\nfrom .pzmap import *\nfrom .rlocus import *\nfrom .statefbk import *\nfrom .statesp import *\nfrom .timeresp import *\nfrom .xferfcn import *\nfrom .ctrlutil import *\nfrom .frdata import *\nfrom .canonical import *\nfrom .robust import *\nfrom .config import *\nfrom .sisotool import *\nfrom .iosys import *\n\n# Exceptions\nfrom .exception import *\n\n# Version information\ntry:\n    from ._version import __version__, __commit__\nexcept ImportError:\n    __version__ = ""dev""\n\n# The following is to use Numpy\'s testing framework\n# Tests go under directory tests/, benchmarks under directory benchmarks/\nfrom numpy.testing import Tester\ntest = Tester().test\nbench = Tester().bench\n\n# Initialize default parameter values\nreset_defaults()\n'"
External_Libraries/python_control_master/control/bdalg.py,8,"b'""""""bdalg.py\n\nThis file contains some standard block diagram algebra.\n\nRoutines in this module:\n\nappend\nseries\nparallel\nnegate\nfeedback\nconnect\n\n""""""\n\n""""""Copyright (c) 2010 by California Institute of Technology\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 24 May 09\nRevised: Kevin K. Chen, Dec 10\n\n$Id$\n\n""""""\n\nimport numpy as np\nfrom . import xferfcn as tf\nfrom . import statesp as ss\nfrom . import frdata as frd\n\n__all__ = [\'series\', \'parallel\', \'negate\', \'feedback\', \'append\', \'connect\']\n\n\ndef series(sys1, *sysn):\n    """"""Return the series connection (... \\* sys3 \\*) sys2 \\* sys1\n\n    Parameters\n    ----------\n    sys1 : scalar, StateSpace, TransferFunction, or FRD\n    sysn : other scalars, StateSpaces, TransferFunctions, or FRDs\n\n    Returns\n    -------\n    out : scalar, StateSpace, or TransferFunction\n\n    Raises\n    ------\n    ValueError\n        if `sys2.inputs` does not equal `sys1.outputs`\n        if `sys1.dt` is not compatible with `sys2.dt`\n\n    See Also\n    --------\n    parallel\n    feedback\n\n    Notes\n    -----\n    This function is a wrapper for the __mul__ function in the StateSpace and\n    TransferFunction classes.  The output type is usually the type of `sys2`.\n    If `sys2` is a scalar, then the output type is the type of `sys1`.\n\n    If both systems have a defined timebase (dt = 0 for continuous time,\n    dt > 0 for discrete time), then the timebase for both systems must\n    match.  If only one of the system has a timebase, the return\n    timebase will be set to match it.\n\n    Examples\n    --------\n    >>> sys3 = series(sys1, sys2) # Same as sys3 = sys2 * sys1\n\n    >>> sys5 = series(sys1, sys2, sys3, sys4) # More systems\n\n    """"""\n    from functools import reduce\n    return reduce(lambda x, y:y*x, sysn, sys1)\n\n\ndef parallel(sys1, *sysn):\n    """"""\n    Return the parallel connection sys1 + sys2 (+ sys3 + ...)\n\n    Parameters\n    ----------\n    sys1 : scalar, StateSpace, TransferFunction, or FRD\n    *sysn : other scalars, StateSpaces, TransferFunctions, or FRDs\n\n    Returns\n    -------\n    out : scalar, StateSpace, or TransferFunction\n\n    Raises\n    ------\n    ValueError\n        if `sys1` and `sys2` do not have the same numbers of inputs and outputs\n\n    See Also\n    --------\n    series\n    feedback\n\n    Notes\n    -----\n    This function is a wrapper for the __add__ function in the\n    StateSpace and TransferFunction classes.  The output type is usually\n    the type of `sys1`.  If `sys1` is a scalar, then the output type is\n    the type of `sys2`.\n\n    If both systems have a defined timebase (dt = 0 for continuous time,\n    dt > 0 for discrete time), then the timebase for both systems must\n    match.  If only one of the system has a timebase, the return\n    timebase will be set to match it.\n\n    Examples\n    --------\n    >>> sys3 = parallel(sys1, sys2) # Same as sys3 = sys1 + sys2\n\n    >>> sys5 = parallel(sys1, sys2, sys3, sys4) # More systems\n\n    """"""\n    from functools import reduce\n    return reduce(lambda x, y:x+y, sysn, sys1)\n\n\ndef negate(sys):\n    """"""\n    Return the negative of a system.\n\n    Parameters\n    ----------\n    sys : StateSpace, TransferFunction or FRD\n\n    Returns\n    -------\n    out : StateSpace or TransferFunction\n\n    Notes\n    -----\n    This function is a wrapper for the __neg__ function in the StateSpace and\n    TransferFunction classes.  The output type is the same as the input type.\n\n    Examples\n    --------\n    >>> sys2 = negate(sys1) # Same as sys2 = -sys1.\n\n    """"""\n    return -sys;\n\n#! TODO: expand to allow sys2 default to work in MIMO case?\ndef feedback(sys1, sys2=1, sign=-1):\n    """"""\n    Feedback interconnection between two I/O systems.\n\n    Parameters\n    ----------\n    sys1 : scalar, StateSpace, TransferFunction, FRD\n        The primary process.\n    sys2 : scalar, StateSpace, TransferFunction, FRD\n        The feedback process (often a feedback controller).\n    sign: scalar\n        The sign of feedback.  `sign` = -1 indicates negative feedback, and\n        `sign` = 1 indicates positive feedback.  `sign` is an optional\n        argument; it assumes a value of -1 if not specified.\n\n    Returns\n    -------\n    out : StateSpace or TransferFunction\n\n    Raises\n    ------\n    ValueError\n        if `sys1` does not have as many inputs as `sys2` has outputs, or if\n        `sys2` does not have as many inputs as `sys1` has outputs\n    NotImplementedError\n        if an attempt is made to perform a feedback on a MIMO TransferFunction\n        object\n\n    See Also\n    --------\n    series\n    parallel\n\n    Notes\n    -----\n    This function is a wrapper for the feedback function in the StateSpace and\n    TransferFunction classes.  It calls TransferFunction.feedback if `sys1` is a\n    TransferFunction object, and StateSpace.feedback if `sys1` is a StateSpace\n    object.  If `sys1` is a scalar, then it is converted to `sys2`\'s type, and\n    the corresponding feedback function is used.  If `sys1` and `sys2` are both\n    scalars, then TransferFunction.feedback is used.\n\n    """"""\n    # Allow anything with a feedback function to call that function\n    try:\n        return sys1.feedback(sys2, sign)\n    except AttributeError:\n        pass\n\n    # Check for correct input types.\n    if not isinstance(sys1, (int, float, complex, np.number,\n                             tf.TransferFunction, ss.StateSpace, frd.FRD)):\n        raise TypeError(""sys1 must be a TransferFunction, StateSpace "" +\n                        ""or FRD object, or a scalar."")\n    if not isinstance(sys2, (int, float, complex, np.number,\n                             tf.TransferFunction, ss.StateSpace, frd.FRD)):\n        raise TypeError(""sys2 must be a TransferFunction, StateSpace "" +\n                        ""or FRD object, or a scalar."")\n\n    # If sys1 is a scalar, convert it to the appropriate LTI type so that we can\n    # its feedback member function.\n    if isinstance(sys1, (int, float, complex, np.number)):\n        if isinstance(sys2, tf.TransferFunction):\n            sys1 = tf._convert_to_transfer_function(sys1)\n        elif isinstance(sys2, ss.StateSpace):\n            sys1 = ss._convertToStateSpace(sys1)\n        elif isinstance(sys2, frd.FRD):\n            sys1 = frd._convertToFRD(sys1, sys2.omega)\n        else: # sys2 is a scalar.\n            sys1 = tf._convert_to_transfer_function(sys1)\n            sys2 = tf._convert_to_transfer_function(sys2)\n\n    return sys1.feedback(sys2, sign)\n\ndef append(*sys):\n    """"""append(sys1, sys2, ..., sysn)\n\n    Group models by appending their inputs and outputs\n\n    Forms an augmented system model, and appends the inputs and\n    outputs together. The system type will be the type of the first\n    system given; if you mix state-space systems and gain matrices,\n    make sure the gain matrices are not first.\n\n    Parameters\n    ----------\n    sys1, sys2, ... sysn: StateSpace or Transferfunction\n        LTI systems to combine\n\n\n    Returns\n    -------\n    sys: LTI system\n        Combined LTI system, with input/output vectors consisting of all\n        input/output vectors appended\n\n    Examples\n    --------\n    >>> sys1 = ss([[1., -2], [3., -4]], [[5.], [7]]"", [[6., 8]], [[9.]])\n    >>> sys2 = ss([[-1.]], [[1.]], [[1.]], [[0.]])\n    >>> sys = append(sys1, sys2)\n\n    """"""\n    s1 = sys[0]\n    for s in sys[1:]:\n        s1 = s1.append(s)\n    return s1\n\ndef connect(sys, Q, inputv, outputv):\n    """"""Index-based interconnection of an LTI system.\n\n    The system `sys` is a system typically constructed with `append`, with\n    multiple inputs and outputs.  The inputs and outputs are connected\n    according to the interconnection matrix `Q`, and then the final inputs and\n    outputs are trimmed according to the inputs and outputs listed in `inputv`\n    and `outputv`.\n\n    NOTE: Inputs and outputs are indexed starting at 1 and negative values\n    correspond to a negative feedback interconnection.\n\n    Parameters\n    ----------\n    sys : StateSpace Transferfunction\n        System to be connected\n    Q : 2D array\n        Interconnection matrix. First column gives the input to be connected\n        second column gives the output to be fed into this input.  Negative\n        values for the second column mean the feedback is negative, 0 means\n        no connection is made.  Inputs and outputs are indexed starting at 1.\n    inputv : 1D array\n        list of final external inputs\n    outputv : 1D array\n        list of final external outputs\n\n    Returns\n    -------\n    sys: LTI system\n        Connected and trimmed LTI system\n\n    Examples\n    --------\n    >>> sys1 = ss([[1., -2], [3., -4]], [[5.], [7]], [[6, 8]], [[9.]])\n    >>> sys2 = ss([[-1.]], [[1.]], [[1.]], [[0.]])\n    >>> sys = append(sys1, sys2)\n    >>> Q = [[1, 2], [2, -1]]  # negative feedback interconnection\n    >>> sysc = connect(sys, Q, [2], [1, 2])\n\n    """"""\n    # first connect\n    K = np.zeros((sys.inputs, sys.outputs))\n    for r in np.array(Q).astype(int):\n        inp = r[0]-1\n        for outp in r[1:]:\n            if outp > 0 and outp <= sys.outputs:\n                K[inp,outp-1] = 1.\n            elif outp < 0 and -outp >= -sys.outputs:\n                K[inp,-outp-1] = -1.\n    sys = sys.feedback(np.array(K), sign=1)\n\n    # now trim\n    Ytrim = np.zeros((len(outputv), sys.outputs))\n    Utrim = np.zeros((sys.inputs, len(inputv)))\n    for i,u in enumerate(inputv):\n        Utrim[u-1,i] = 1.\n    for i,y in enumerate(outputv):\n        Ytrim[i,y-1] = 1.\n\n    return Ytrim * sys * Utrim\n'"
External_Libraries/python_control_master/control/canonical.py,0,"b'# canonical.py - functions for converting systems to canonical forms\n# RMM, 10 Nov 2012\n\nfrom .exception import ControlNotImplemented\nfrom .lti import issiso\nfrom .statesp import StateSpace\nfrom .statefbk import ctrb, obsv\n\nfrom numpy import zeros, shape, poly, iscomplex, hstack, dot, transpose\nfrom numpy.linalg import solve, matrix_rank, eig\n\n__all__ = [\'canonical_form\', \'reachable_form\', \'observable_form\', \'modal_form\',\n           \'similarity_transform\']\n\ndef canonical_form(xsys, form=\'reachable\'):\n    """"""Convert a system into canonical form\n\n    Parameters\n    ----------\n    xsys : StateSpace object\n        System to be transformed, with state \'x\'\n    form : String\n        Canonical form for transformation.  Chosen from:\n          * \'reachable\' - reachable canonical form\n          * \'observable\' - observable canonical form\n          * \'modal\' - modal canonical form\n\n    Returns\n    -------\n    zsys : StateSpace object\n        System in desired canonical form, with state \'z\'\n    T : matrix\n        Coordinate transformation matrix, z = T * x\n    """"""\n\n    # Call the appropriate tranformation function\n    if form == \'reachable\':\n        return reachable_form(xsys)\n    elif form == \'observable\':\n        return observable_form(xsys)\n    elif form == \'modal\':\n        return modal_form(xsys)\n    else:\n        raise ControlNotImplemented(\n            ""Canonical form \'%s\' not yet implemented"" % form)\n\n\n# Reachable canonical form\ndef reachable_form(xsys):\n    """"""Convert a system into reachable canonical form\n\n    Parameters\n    ----------\n    xsys : StateSpace object\n        System to be transformed, with state `x`\n\n    Returns\n    -------\n    zsys : StateSpace object\n        System in reachable canonical form, with state `z`\n    T : matrix\n        Coordinate transformation: z = T * x\n    """"""\n    # Check to make sure we have a SISO system\n    if not issiso(xsys):\n        raise ControlNotImplemented(\n            ""Canonical forms for MIMO systems not yet supported"")\n\n    # Create a new system, starting with a copy of the old one\n    zsys = StateSpace(xsys)\n\n    # Generate the system matrices for the desired canonical form\n    zsys.B = zeros(shape(xsys.B))\n    zsys.B[0, 0] = 1.0\n    zsys.A = zeros(shape(xsys.A))\n    Apoly = poly(xsys.A)                # characteristic polynomial\n    for i in range(0, xsys.states):\n        zsys.A[0, i] = -Apoly[i+1] / Apoly[0]\n        if (i+1 < xsys.states):\n            zsys.A[i+1, i] = 1.0\n\n    # Compute the reachability matrices for each set of states\n    Wrx = ctrb(xsys.A, xsys.B)\n    Wrz = ctrb(zsys.A, zsys.B)\n\n    if matrix_rank(Wrx) != xsys.states:\n        raise ValueError(""System not controllable to working precision."")\n\n    # Transformation from one form to another\n    Tzx = solve(Wrx.T, Wrz.T).T  # matrix right division, Tzx = Wrz * inv(Wrx)\n\n    # Check to make sure inversion was OK.  Note that since we are inverting\n    # Wrx and we already checked its rank, this exception should never occur\n    if matrix_rank(Tzx) != xsys.states:         # pragma: no cover\n        raise ValueError(""Transformation matrix singular to working precision."")\n\n    # Finally, compute the output matrix\n    zsys.C = solve(Tzx.T, xsys.C.T).T  # matrix right division, zsys.C = xsys.C * inv(Tzx)\n\n    return zsys, Tzx\n\n\ndef observable_form(xsys):\n    """"""Convert a system into observable canonical form\n\n    Parameters\n    ----------\n    xsys : StateSpace object\n        System to be transformed, with state `x`\n\n    Returns\n    -------\n    zsys : StateSpace object\n        System in observable canonical form, with state `z`\n    T : matrix\n        Coordinate transformation: z = T * x\n    """"""\n    # Check to make sure we have a SISO system\n    if not issiso(xsys):\n        raise ControlNotImplemented(\n            ""Canonical forms for MIMO systems not yet supported"")\n\n    # Create a new system, starting with a copy of the old one\n    zsys = StateSpace(xsys)\n\n    # Generate the system matrices for the desired canonical form\n    zsys.C = zeros(shape(xsys.C))\n    zsys.C[0, 0] = 1\n    zsys.A = zeros(shape(xsys.A))\n    Apoly = poly(xsys.A)                # characteristic polynomial\n    for i in range(0, xsys.states):\n        zsys.A[i, 0] = -Apoly[i+1] / Apoly[0]\n        if (i+1 < xsys.states):\n            zsys.A[i, i+1] = 1\n\n    # Compute the observability matrices for each set of states\n    Wrx = obsv(xsys.A, xsys.C)\n    Wrz = obsv(zsys.A, zsys.C)\n\n    # Transformation from one form to another\n    Tzx = solve(Wrz, Wrx)  # matrix left division, Tzx = inv(Wrz) * Wrx\n\n    if matrix_rank(Tzx) != xsys.states:\n        raise ValueError(""Transformation matrix singular to working precision."")\n\n    # Finally, compute the output matrix\n    zsys.B = Tzx * xsys.B\n\n    return zsys, Tzx\n\ndef modal_form(xsys):\n    """"""Convert a system into modal canonical form\n\n    Parameters\n    ----------\n    xsys : StateSpace object\n        System to be transformed, with state `x`\n\n    Returns\n    -------\n    zsys : StateSpace object\n        System in modal canonical form, with state `z`\n    T : matrix\n        Coordinate transformation: z = T * x\n    """"""\n    # Check to make sure we have a SISO system\n    if not issiso(xsys):\n        raise ControlNotImplemented(\n            ""Canonical forms for MIMO systems not yet supported"")\n\n    # Create a new system, starting with a copy of the old one\n    zsys = StateSpace(xsys)\n\n    # Calculate eigenvalues and matrix of eigenvectors Tzx,\n    eigval, eigvec = eig(xsys.A)\n\n    # Eigenvalues and according eigenvectors are not sorted,\n    # thus modal transformation is ambiguous\n    # Sorting eigenvalues and respective vectors by largest to smallest eigenvalue\n    idx = eigval.argsort()[::-1]\n    eigval = eigval[idx]\n    eigvec = eigvec[:,idx]\n\n    # If all eigenvalues are real, the matrix of eigenvectors is Tzx directly\n    if not iscomplex(eigval).any():\n        Tzx = eigvec\n    else:\n        # A is an arbitrary semisimple matrix\n\n        # Keep track of complex conjugates (need only one)\n        lst_conjugates = []\n        Tzx = None\n        for val, vec in zip(eigval, eigvec.T):\n            if iscomplex(val):\n                if val not in lst_conjugates:\n                    lst_conjugates.append(val.conjugate())\n                    if Tzx is not None:\n                        Tzx = hstack((Tzx, hstack((vec.real.T, vec.imag.T))))\n                    else:\n                        Tzx = hstack((vec.real.T, vec.imag.T))\n                else:\n                    # if conjugate has already been seen, skip this eigenvalue\n                    lst_conjugates.remove(val)\n            else:\n                if Tzx is not None:\n                    Tzx = hstack((Tzx, vec.real.T))\n                else:\n                    Tzx = vec.real.T\n\n    # Generate the system matrices for the desired canonical form\n    zsys.A = solve(Tzx, xsys.A).dot(Tzx)\n    zsys.B = solve(Tzx, xsys.B)\n    zsys.C = xsys.C.dot(Tzx)\n\n    return zsys, Tzx\n\n\ndef similarity_transform(xsys, T, timescale=1):\n    """"""Perform a similarity transformation, with option time rescaling.\n\n    Transform a linear state space system to a new state space representation\n    z = T x, where T is an invertible matrix.\n\n    Parameters\n    ----------\n    T : 2D invertible array\n        The matrix `T` defines the new set of coordinates z = T x.\n    timescale : float\n        If present, also rescale the time unit to tau = timescale * t\n\n    Returns\n    -------\n    zsys : StateSpace object\n        System in transformed coordinates, with state \'z\'\n\n    """"""\n    # Create a new system, starting with a copy of the old one\n    zsys = StateSpace(xsys)\n\n    # Define a function to compute the right inverse (solve x M = y)\n    def rsolve(M, y):\n        return transpose(solve(transpose(M), transpose(y)))\n\n    # Update the system matrices\n    zsys.A = rsolve(T, dot(T, zsys.A)) / timescale\n    zsys.B = dot(T, zsys.B) / timescale\n    zsys.C = rsolve(T, zsys.C)\n\n    return zsys\n'"
External_Libraries/python_control_master/control/config.py,0,"b'# config.py - package defaults\n# RMM, 4 Nov 2012\n#\n# This file contains default values and utility functions for setting\n# variables that control the behavior of the control package.\n# Eventually it will be possible to read and write configuration\n# files.  For now, you can just choose between MATLAB and FBS default\n# values + tweak a few other things.\n\nimport warnings\n\n__all__ = [\'defaults\', \'set_defaults\', \'reset_defaults\',\n           \'use_matlab_defaults\', \'use_fbs_defaults\',\n           \'use_numpy_matrix\']\n\n# Package level default values\n_control_defaults = {\n    # No package level defaults (yet)\n}\ndefaults = dict(_control_defaults)\n\n\ndef set_defaults(module, **keywords):\n    """"""Set default values of parameters for a module.\n\n    The set_defaults() function can be used to modify multiple parameter\n    values for a module at the same time, using keyword arguments:\n\n        control.set_defaults(\'module\', param1=val, param2=val)\n\n    """"""\n    if not isinstance(module, str):\n        raise ValueError(""module must be a string"")\n    for key, val in keywords.items():\n        defaults[module + \'.\' + key] = val\n\n\ndef reset_defaults():\n    """"""Reset configuration values to their default (initial) values.""""""\n    # System level defaults\n    defaults.update(_control_defaults)\n\n    from .freqplot import _bode_defaults, _freqplot_defaults\n    defaults.update(_bode_defaults)\n    defaults.update(_freqplot_defaults)\n\n    from .nichols import _nichols_defaults\n    defaults.update(_nichols_defaults)\n\n    from .pzmap import _pzmap_defaults\n    defaults.update(_pzmap_defaults)\n\n    from .rlocus import _rlocus_defaults\n    defaults.update(_rlocus_defaults)\n\n    from .statesp import _statesp_defaults\n    defaults.update(_statesp_defaults)\n\n\ndef _get_param(module, param, argval=None, defval=None, pop=False):\n    """"""Return the default value for a configuration option.\n\n    The _get_param() function is a utility function used to get the value of a\n    parameter for a module based on the default parameter settings and any\n    arguments passed to the function.  The precedence order for parameters is\n    the value passed to the function (as a keyword), the value from the\n    config.defaults dictionary, and the default value `defval`.\n\n    Parameters\n    ----------\n    module : str\n        Name of the module whose parameters are being requested.\n    param : str\n        Name of the parameter value to be determeind.\n    argval : object or dict\n        Value of the parameter as passed to the function.  This can either be\n        an object or a dictionary (i.e. the keyword list from the function\n        call).  Defaults to None.\n    defval : object\n        Default value of the parameter to use, if it is not located in the\n        `config.defaults` dictionary.  If a dictionary is provided, then\n        `module.param` is used to determine the default value.  Defaults to\n        None.\n    pop : bool\n        If True and if argval is a dict, then pop the remove the parameter\n        entry from the argval dict after retreiving it.  This allows the use\n        of a keyword argument list to be passed through to other functions\n        internal to the function being called.\n\n    """"""\n\n    # Make sure that we were passed sensible arguments\n    if not isinstance(module, str) or not isinstance(param, str):\n        raise ValueError(""module and param must be strings"")\n\n    # Construction the name of the key, for later use\n    key = module + \'.\' + param\n\n    # If we were passed a dict for the argval, get the param value from there\n    if isinstance(argval, dict):\n        argval = argval.pop(param, None) if pop else argval.get(param, None)\n\n    # If we were passed a dict for the defval, get the param value from there\n    if isinstance(defval, dict):\n        defval = defval.get(key, None)\n\n    # Return the parameter value to use (argval > defaults > defval)\n    return argval if argval is not None else defaults.get(key, defval)\n\n\n# Set defaults to match MATLAB\ndef use_matlab_defaults():\n    """"""Use MATLAB compatible configuration settings.\n\n    The following conventions are used:\n        * Bode plots plot gain in dB, phase in degrees, frequency in\n          Hertz, with grids\n        * State space class and functions use Numpy matrix objects\n\n    """"""\n    set_defaults(\'bode\', dB=True, deg=True, Hz=True, grid=True)\n    set_defaults(\'statesp\', use_numpy_matrix=True)\n\n\n# Set defaults to match FBS (Astrom and Murray)\ndef use_fbs_defaults():\n    """"""Use `Feedback Systems <http://fbsbook.org>`_ (FBS) compatible settings.\n\n    The following conventions are used:\n        * Bode plots plot gain in powers of ten, phase in degrees,\n          frequency in Hertz, no grid\n\n    """"""\n    set_defaults(\'bode\', dB=False, deg=True, Hz=False, grid=False)\n\n\n# Decide whether to use numpy.matrix for state space operations\ndef use_numpy_matrix(flag=True, warn=True):\n    """"""Turn on/off use of Numpy `matrix` class for state space operations.\n\n    Parameters\n    ----------\n    flag : bool\n        If flag is `True` (default), use the Numpy (soon to be deprecated)\n        `matrix` class to represent matrices in the `~control.StateSpace`\n        class and functions.  If flat is `False`, then matrices are\n        represented by a 2D `ndarray` object.\n\n    warn : bool\n        If flag is `True` (default), issue a warning when turning on the use\n        of the Numpy `matrix` class.  Set `warn` to false to omit display of\n        the warning message.\n\n    """"""\n    if flag and warn:\n        warnings.warn(""Return type numpy.matrix is soon to be deprecated."",\n                      stacklevel=2)\n    set_defaults(\'statesp\', use_numpy_matrix=flag)\n'"
External_Libraries/python_control_master/control/ctrlutil.py,4,"b'# ctrlutil.py - control system utility functions\n#\n# Author: Richard M. Murray\n# Date: 24 May 09\n#\n# These are some basic utility functions that are used in the control\n# systems library and that didn\'t naturally fit anyplace else.\n#\n# Copyright (c) 2009 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\n# Packages that we need access to\nfrom . import lti\nimport numpy as np\nimport math\n\n__all__ = [\'unwrap\', \'issys\', \'db2mag\', \'mag2db\']\n\n# Utility function to unwrap an angle measurement\ndef unwrap(angle, period=2*math.pi):\n    """"""Unwrap a phase angle to give a continuous curve\n\n    Parameters\n    ----------\n    angle : array_like\n        Array of angles to be unwrapped\n    period : float, optional\n        Period (defaults to `2*pi`)\n\n    Returns\n    -------\n    angle_out : array_like\n        Output array, with jumps of period/2 eliminated\n\n    Examples\n    --------\n    >>> import numpy as np\n    >>> theta = [5.74, 5.97, 6.19, 0.13, 0.35, 0.57]\n    >>> unwrap(theta, period=2 * np.pi)\n    [5.74, 5.97, 6.19, 6.413185307179586, 6.633185307179586, 6.8531853071795865]\n\n    """"""\n    dangle = np.diff(angle)\n    dangle_desired = (dangle + period/2.) % period - period/2.\n    correction = np.cumsum(dangle_desired - dangle)\n    angle[1:] += correction\n    return angle\n\ndef issys(obj):\n    """"""Return True if an object is a system, otherwise False""""""\n    return isinstance(obj, lti.LTI)\n\ndef db2mag(db):\n    """"""Convert a gain in decibels (dB) to a magnitude\n\n    If A is magnitude,\n\n        db = 20 * log10(A)\n\n    Parameters\n    ----------\n    db : float or ndarray\n        input value or array of values, given in decibels\n\n    Returns\n    -------\n    mag : float or ndarray\n        corresponding magnitudes\n\n    """"""\n    return 10. ** (db / 20.)\n\ndef mag2db(mag):\n    """"""Convert a magnitude to decibels (dB)\n\n    If A is magnitude,\n\n        db = 20 * log10(A)\n\n    Parameters\n    ----------\n    mag : float or ndarray\n        input magnitude or array of magnitudes\n\n    Returns\n    -------\n    db : float or ndarray\n        corresponding values in decibels\n\n    """"""\n    return 20. * np.log10(mag)\n'"
External_Libraries/python_control_master/control/delay.py,0,"b'# -*-coding: utf-8-*-\n#! TODO: add module docstring\n# delay.py - functions involving time delays\n#\n# Author: Sawyer Fuller\n# Date: 26 Aug 2010\n#\n# This file contains functions for implementing time delays (currently\n# only the pade() function).\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\nfrom __future__ import division\n\n__all__ = [\'pade\']\n\ndef pade(T, n=1, numdeg=None):\n    """"""\n    Create a linear system that approximates a delay.\n\n    Return the numerator and denominator coefficients of the Pade approximation.\n\n    Parameters\n    ----------\n    T : number\n        time delay\n    n : positive integer\n        degree of denominator of approximation\n    numdeg: integer, or None (the default)\n            If None, numerator degree equals denominator degree\n            If >= 0, specifies degree of numerator\n            If < 0, numerator degree is n+numdeg\n\n    Returns\n    -------\n    num, den : array\n        Polynomial coefficients of the delay model, in descending powers of s.\n\n    Notes\n    -----\n    Based on:\n      1. Algorithm 11.3.1 in Golub and van Loan, ""Matrix Computation"" 3rd.\n         Ed. pp. 572-574\n      2. M. Vajta, ""Some remarks on Pad\xc3\xa9-approximations"",\n         3rd TEMPUS-INTCOM Symposium\n    """"""\n    if numdeg is None:\n        numdeg = n\n    elif numdeg < 0:\n        numdeg += n\n\n    if not T >= 0:\n        raise ValueError(""require T >= 0"")\n    if not n >= 0:\n        raise ValueError(""require n >= 0"")\n    if not (0 <= numdeg <= n):\n        raise ValueError(""require 0 <= numdeg <= n"")\n\n    if T == 0:\n        num = [1,]\n        den = [1,]\n    else:\n        num = [0. for i in range(numdeg+1)]\n        num[-1] = 1.\n        cn = 1.\n        for k in range(1, numdeg+1):\n            # derived from Gloub and van Loan eq. for Dpq(z) on p. 572\n            # this accumulative style follows Alg 11.3.1\n            cn *= -T * (numdeg - k + 1)/(numdeg + n - k + 1)/k\n            num[numdeg-k] = cn\n\n        den = [0. for i in range(n+1)]\n        den[-1] = 1.\n        cd = 1.\n        for k in range(1, n+1):\n            # see cn above\n            cd *= T * (n - k + 1)/(numdeg + n - k + 1)/k\n            den[n-k] = cd\n\n        num = [coeff/den[0] for coeff in num]\n        den = [coeff/den[0] for coeff in den]\n    return num, den\n'"
External_Libraries/python_control_master/control/dtime.py,0,"b'""""""dtime.py\n\nFunctions for manipulating discrete time systems.\n\nRoutines in this module:\n\nsample_system()\n""""""\n\n""""""Copyright (c) 2012 by California Institute of Technology\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 6 October 2012\n\n$Id: dtime.py 185 2012-08-30 05:44:32Z murrayrm $\n\n""""""\n\nfrom .lti import isctime\nfrom .statesp import StateSpace, _convertToStateSpace\n\n__all__ = [\'sample_system\', \'c2d\']\n\n# Sample a continuous time system\ndef sample_system(sysc, Ts, method=\'zoh\', alpha=None):\n    """"""Convert a continuous time system to discrete time\n\n    Creates a discrete time system from a continuous time system by\n    sampling.  Multiple methods of conversion are supported.\n\n    Parameters\n    ----------\n    sysc : linsys\n        Continuous time system to be converted\n    Ts : real\n        Sampling period\n    method : string\n        Method to use for conversion: \'matched\', \'tustin\', \'zoh\' (default)\n\n    Returns\n    -------\n    sysd : linsys\n        Discrete time system, with sampling rate Ts\n\n    Notes\n    -----\n    See `TransferFunction.sample` and `StateSpace.sample` for\n    further details.\n\n    Examples\n    --------\n    >>> sysc = TransferFunction([1], [1, 2, 1])\n    >>> sysd = sample_system(sysc, 1, method=\'matched\')\n    """"""\n\n    # Make sure we have a continuous time system\n    if not isctime(sysc):\n        raise ValueError(""First argument must be continuous time system"")\n\n    return sysc.sample(Ts, method, alpha)\n\n\ndef c2d(sysc, Ts, method=\'zoh\'):\n    \'\'\'\n    Return a discrete-time system\n\n    Parameters\n    ----------\n    sysc: LTI (StateSpace or TransferFunction), continuous\n        System to be converted\n\n    Ts: number\n        Sample time for the conversion\n\n    method: string, optional\n        Method to be applied,\n        \'zoh\'        Zero-order hold on the inputs (default)\n        \'foh\'        First-order hold, currently not implemented\n        \'impulse\'    Impulse-invariant discretization, currently not implemented\n        \'tustin\'     Bilinear (Tustin) approximation, only SISO\n        \'matched\'    Matched pole-zero method, only SISO\n    \'\'\'\n    #  Call the sample_system() function to do the work\n    sysd = sample_system(sysc, Ts, method)\n\n    # TODO: is this check needed?  If sysc is  StateSpace, sysd is too?\n    if isinstance(sysc, StateSpace) and not isinstance(sysd, StateSpace):\n        return _convertToStateSpace(sysd)       # pragma: no cover\n\n    return sysd\n'"
External_Libraries/python_control_master/control/exception.py,0,"b'# exception.py - exception definitions for the control package\n#\n# Author: Richard M. Murray\n# Date: 31 May 2010\n#\n# This file contains definitions of standard exceptions for the control package\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\nclass ControlSlycot(ImportError):\n    """"""Exception for Slycot import.  Used when we can\'t import a function\n    from the slycot package""""""\n    pass\n\nclass ControlDimension(ValueError):\n    """"""Raised when dimensions of system objects are not correct""""""\n    pass\n\nclass ControlArgument(TypeError):\n    """"""Raised when arguments to a function are not correct""""""\n    pass\n\nclass ControlMIMONotImplemented(NotImplementedError):\n    """"""Function is not currently implemented for MIMO systems""""""\n    pass\n\nclass ControlNotImplemented(NotImplementedError):\n    """"""Functionality is not yet implemented""""""\n    pass\n\n# Utility function to see if slycot is installed\ndef slycot_check():\n    try:\n        import slycot\n    except:\n        return False\n    else:\n        return True\n'"
External_Libraries/python_control_master/control/frdata.py,7,"b'# Copyright (c) 2010 by California Institute of Technology\n# Copyright (c) 2012 by Delft University of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the names of the California Institute of Technology nor\n#    the Delft University of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# Author: M.M. (Rene) van Paassen (using xferfcn.py as basis)\n# Date: 02 Oct 12\n\nfrom __future__ import division\n\n""""""\nFrequency response data representation and functions.\n\nThis module contains the FRD class and also functions that operate on\nFRD data.\n""""""\n\n# External function declarations\nfrom warnings import warn\nimport numpy as np\nfrom numpy import angle, array, empty, ones, \\\n    real, imag, absolute, eye, linalg, where, dot\nfrom scipy.interpolate import splprep, splev\nfrom .lti import LTI\n\n__all__ = [\'FrequencyResponseData\', \'FRD\', \'frd\']\n\n\nclass FrequencyResponseData(LTI):\n    """"""FrequencyResponseData(d, w)\n\n    A class for models defined by frequency response data (FRD)\n\n    The FrequencyResponseData (FRD) class is used to represent systems in\n    frequency response data form.\n\n    The main data members are \'omega\' and \'fresp\', where `omega` is a 1D array\n    with the frequency points of the response, and `fresp` is a 3D array, with\n    the first dimension corresponding to the output index of the FRD, the\n    second dimension corresponding to the input index, and the 3rd dimension\n    corresponding to the frequency points in omega.  For example,\n\n    >>> frdata[2,5,:] = numpy.array([1., 0.8-0.2j, 0.2-0.8j])\n\n    means that the frequency response from the 6th input to the 3rd\n    output at the frequencies defined in omega is set to the array\n    above, i.e. the rows represent the outputs and the columns\n    represent the inputs.\n\n    """"""\n\n    # Allow NDarray * StateSpace to give StateSpace._rmul_() priority\n    # https://docs.scipy.org/doc/numpy/reference/arrays.classes.html\n    __array_priority__ = 11     # override ndarray and matrix types\n\n    epsw = 1e-8\n\n    def __init__(self, *args, **kwargs):\n        """"""Construct an FRD object.\n\n        The default constructor is FRD(d, w), where w is an iterable of\n        frequency points, and d is the matching frequency data.\n\n        If d is a single list, 1d array, or tuple, a SISO system description\n        is assumed. d can also be\n\n        To call the copy constructor, call FRD(sys), where sys is a\n        FRD object.\n\n        To construct frequency response data for an existing LTI\n        object, other than an FRD, call FRD(sys, omega)\n\n        """"""\n        smooth = kwargs.get(\'smooth\', False)\n\n        if len(args) == 2:\n            if not isinstance(args[0], FRD) and isinstance(args[0], LTI):\n                # not an FRD, but still a system, second argument should be\n                # the frequency range\n                otherlti = args[0]\n                self.omega = array(args[1], dtype=float)\n                self.omega.sort()\n                numfreq = len(self.omega)\n\n                # calculate frequency response at my points\n                self.fresp = empty(\n                    (otherlti.outputs, otherlti.inputs, numfreq),\n                    dtype=complex)\n                for k, w in enumerate(self.omega):\n                    self.fresp[:, :, k] = otherlti._evalfr(w)\n\n            else:\n                # The user provided a response and a freq vector\n                self.fresp = array(args[0], dtype=complex)\n                if len(self.fresp.shape) == 1:\n                    self.fresp = self.fresp.reshape(1, 1, len(args[0]))\n                self.omega = array(args[1], dtype=float)\n                if len(self.fresp.shape) != 3 or \\\n                        self.fresp.shape[-1] != self.omega.shape[-1] or \\\n                        len(self.omega.shape) != 1:\n                    raise TypeError(\n                        ""The frequency data constructor needs a 1-d or 3-d""\n                        "" response data array and a matching frequency vector""\n                        "" size"")\n\n        elif len(args) == 1:\n            # Use the copy constructor.\n            if not isinstance(args[0], FRD):\n                raise TypeError(\n                    ""The one-argument constructor can only take in""\n                    "" an FRD object.  Received %s."" % type(args[0]))\n            self.omega = args[0].omega\n            self.fresp = args[0].fresp\n        else:\n            raise ValueError(""Needs 1 or 2 arguments; receivd %i."" % len(args))\n\n        # create interpolation functions\n        if smooth:\n            self.ifunc = empty((self.fresp.shape[0], self.fresp.shape[1]),\n                               dtype=tuple)\n            for i in range(self.fresp.shape[0]):\n                for j in range(self.fresp.shape[1]):\n                    self.ifunc[i, j], u = splprep(\n                        u=self.omega, x=[real(self.fresp[i, j, :]),\n                                         imag(self.fresp[i, j, :])],\n                        w=1.0/(absolute(self.fresp[i, j, :]) + 0.001), s=0.0)\n        else:\n            self.ifunc = None\n        LTI.__init__(self, self.fresp.shape[1], self.fresp.shape[0])\n\n    def __str__(self):\n        """"""String representation of the transfer function.""""""\n\n        mimo = self.inputs > 1 or self.outputs > 1\n        outstr = [\'frequency response data \']\n\n        mt, pt, wt = self.freqresp(self.omega)\n        for i in range(self.inputs):\n            for j in range(self.outputs):\n                if mimo:\n                    outstr.append(""Input %i to output %i:"" % (i + 1, j + 1))\n                outstr.append(\'Freq [rad/s]  Response   \')\n                outstr.append(\'------------  ---------------------\')\n                outstr.extend(\n                    [\'%12.3f  %10.4g%+10.4gj\' % (w, m, p)\n                     for m, p, w in zip(real(self.fresp[j, i, :]),\n                                        imag(self.fresp[j, i, :]), wt)])\n\n        return \'\\n\'.join(outstr)\n\n    def __neg__(self):\n        """"""Negate a transfer function.""""""\n\n        return FRD(-self.fresp, self.omega)\n\n    def __add__(self, other):\n        """"""Add two LTI objects (parallel connection).""""""\n\n        if isinstance(other, FRD):\n            # verify that the frequencies match\n            if len(other.omega) != len(self.omega) or \\\n               (other.omega != self.omega).any():\n                warn(""Frequency points do not match; expect ""\n                     ""truncation and interpolation."")\n\n        # Convert the second argument to a frequency response function.\n        # or re-base the frd to the current omega (if needed)\n        other = _convertToFRD(other, omega=self.omega)\n\n        # Check that the input-output sizes are consistent.\n        if self.inputs != other.inputs:\n            raise ValueError(""The first summand has %i input(s), but the \\\nsecond has %i."" % (self.inputs, other.inputs))\n        if self.outputs != other.outputs:\n            raise ValueError(""The first summand has %i output(s), but the \\\nsecond has %i."" % (self.outputs, other.outputs))\n\n        return FRD(self.fresp + other.fresp, other.omega)\n\n    def __radd__(self, other):\n        """"""Right add two LTI objects (parallel connection).""""""\n\n        return self + other\n\n    def __sub__(self, other):\n        """"""Subtract two LTI objects.""""""\n\n        return self + (-other)\n\n    def __rsub__(self, other):\n        """"""Right subtract two LTI objects.""""""\n\n        return other + (-self)\n\n    def __mul__(self, other):\n        """"""Multiply two LTI objects (serial connection).""""""\n\n        # Convert the second argument to a transfer function.\n        if isinstance(other, (int, float, complex, np.number)):\n            return FRD(self.fresp * other, self.omega,\n                       smooth=(self.ifunc is not None))\n        else:\n            other = _convertToFRD(other, omega=self.omega)\n\n        # Check that the input-output sizes are consistent.\n        if self.inputs != other.outputs:\n            raise ValueError(\n                ""H = G1*G2: input-output size mismatch: ""\n                ""G1 has %i input(s), G2 has %i output(s)."" %\n                (self.inputs, other.outputs))\n\n        inputs = other.inputs\n        outputs = self.outputs\n        fresp = empty((outputs, inputs, len(self.omega)),\n                      dtype=self.fresp.dtype)\n        for i in range(len(self.omega)):\n            fresp[:, :, i] = dot(self.fresp[:, :, i], other.fresp[:, :, i])\n        return FRD(fresp, self.omega,\n                   smooth=(self.ifunc is not None) and\n                          (other.ifunc is not None))\n\n    def __rmul__(self, other):\n        """"""Right Multiply two LTI objects (serial connection).""""""\n\n        # Convert the second argument to an frd function.\n        if isinstance(other, (int, float, complex, np.number)):\n            return FRD(self.fresp * other, self.omega,\n                       smooth=(self.ifunc is not None))\n        else:\n            other = _convertToFRD(other, omega=self.omega)\n\n        # Check that the input-output sizes are consistent.\n        if self.outputs != other.inputs:\n            raise ValueError(\n                ""H = G1*G2: input-output size mismatch: ""\n                ""G1 has %i input(s), G2 has %i output(s)."" %\n                (other.inputs, self.outputs))\n\n        inputs = self.inputs\n        outputs = other.outputs\n\n        fresp = empty((outputs, inputs, len(self.omega)),\n                      dtype=self.fresp.dtype)\n        for i in range(len(self.omega)):\n            fresp[:, :, i] = dot(other.fresp[:, :, i], self.fresp[:, :, i])\n        return FRD(fresp, self.omega,\n                   smooth=(self.ifunc is not None) and\n                          (other.ifunc is not None))\n\n    # TODO: Division of MIMO transfer function objects is not written yet.\n    def __truediv__(self, other):\n        """"""Divide two LTI objects.""""""\n\n        if isinstance(other, (int, float, complex, np.number)):\n            return FRD(self.fresp * (1/other), self.omega,\n                       smooth=(self.ifunc is not None))\n        else:\n            other = _convertToFRD(other, omega=self.omega)\n\n        if (self.inputs > 1 or self.outputs > 1 or\n            other.inputs > 1 or other.outputs > 1):\n            raise NotImplementedError(\n                ""FRD.__truediv__ is currently only implemented for SISO ""\n                ""systems."")\n\n        return FRD(self.fresp/other.fresp, self.omega,\n                   smooth=(self.ifunc is not None) and\n                          (other.ifunc is not None))\n\n    # TODO: Remove when transition to python3 complete\n    def __div__(self, other):\n        return self.__truediv__(other)\n\n    # TODO: Division of MIMO transfer function objects is not written yet.\n    def __rtruediv__(self, other):\n        """"""Right divide two LTI objects.""""""\n        if isinstance(other, (int, float, complex, np.number)):\n            return FRD(other / self.fresp, self.omega,\n                       smooth=(self.ifunc is not None))\n        else:\n            other = _convertToFRD(other, omega=self.omega)\n\n        if (self.inputs > 1 or self.outputs > 1 or\n            other.inputs > 1 or other.outputs > 1):\n            raise NotImplementedError(\n                ""FRD.__rtruediv__ is currently only implemented for ""\n                ""SISO systems."")\n\n        return other / self\n\n    # TODO: Remove when transition to python3 complete\n    def __rdiv__(self, other):\n        return self.__rtruediv__(other)\n\n    def __pow__(self, other):\n        if not type(other) == int:\n            raise ValueError(""Exponent must be an integer"")\n        if other == 0:\n            return FRD(ones(self.fresp.shape), self.omega,\n                       smooth=(self.ifunc is not None))  # unity\n        if other > 0:\n            return self * (self**(other-1))\n        if other < 0:\n            return (FRD(ones(self.fresp.shape), self.omega) / self) * \\\n                (self**(other+1))\n\n    def evalfr(self, omega):\n        """"""Evaluate a transfer function at a single angular frequency.\n\n        self._evalfr(omega) returns the value of the frequency response\n        at frequency omega.\n\n        Note that a ""normal"" FRD only returns values for which there is an\n        entry in the omega vector. An interpolating FRD can return\n        intermediate values.\n\n        """"""\n        warn(""FRD.evalfr(omega) will be deprecated in a future release ""\n             ""of python-control; use sys.eval(omega) instead"",\n             PendingDeprecationWarning)         # pragma: no coverage\n        return self._evalfr(omega)\n\n    # Define the `eval` function to evaluate an FRD at a given (real)\n    # frequency.  Note that we choose to use `eval` instead of `evalfr` to\n    # avoid confusion with :func:`evalfr`, which takes a complex number as its\n    # argument.  Similarly, we don\'t use `__call__` to avoid confusion between\n    # G(s) for a transfer function and G(omega) for an FRD object.\n    def eval(self, omega):\n        """"""Evaluate a transfer function at a single angular frequency.\n\n        self.evalfr(omega) returns the value of the frequency response\n        at frequency omega.\n\n        Note that a ""normal"" FRD only returns values for which there is an\n        entry in the omega vector. An interpolating FRD can return\n        intermediate values.\n\n        """"""\n        return self._evalfr(omega)\n\n    # Internal function to evaluate the frequency responses\n    def _evalfr(self, omega):\n        """"""Evaluate a transfer function at a single angular frequency.""""""\n        # Preallocate the output.\n        if getattr(omega, \'__iter__\', False):\n            out = empty((self.outputs, self.inputs, len(omega)), dtype=complex)\n        else:\n            out = empty((self.outputs, self.inputs), dtype=complex)\n\n        if self.ifunc is None:\n            try:\n                out = self.fresp[:, :, where(self.omega == omega)[0][0]]\n            except Exception:\n                raise ValueError(\n                    ""Frequency %f not in frequency list, try an interpolating""\n                    "" FRD if you want additional points"" % omega)\n        else:\n            if getattr(omega, \'__iter__\', False):\n                for i in range(self.outputs):\n                    for j in range(self.inputs):\n                        for k, w in enumerate(omega):\n                            frraw = splev(w, self.ifunc[i, j], der=0)\n                            out[i, j, k] = frraw[0] + 1.0j * frraw[1]\n            else:\n                for i in range(self.outputs):\n                    for j in range(self.inputs):\n                        frraw = splev(omega, self.ifunc[i, j], der=0)\n                        out[i, j] = frraw[0] + 1.0j * frraw[1]\n\n        return out\n\n    # Method for generating the frequency response of the system\n    def freqresp(self, omega):\n        """"""Evaluate a transfer function at a list of angular frequencies.\n\n        mag, phase, omega = self.freqresp(omega)\n\n        reports the value of the magnitude, phase, and angular frequency of\n        the transfer function matrix evaluated at s = i * omega, where omega\n        is a list of angular frequencies, and is a sorted version of the input\n        omega.\n\n        """"""\n\n        # Preallocate outputs.\n        numfreq = len(omega)\n        mag = empty((self.outputs, self.inputs, numfreq))\n        phase = empty((self.outputs, self.inputs, numfreq))\n\n        omega.sort()\n\n        for k, w in enumerate(omega):\n            fresp = self._evalfr(w)\n            mag[:, :, k] = abs(fresp)\n            phase[:, :, k] = angle(fresp)\n\n        return mag, phase, omega\n\n    def feedback(self, other=1, sign=-1):\n        """"""Feedback interconnection between two FRD objects.""""""\n\n        other = _convertToFRD(other, omega=self.omega)\n\n        if (self.outputs != other.inputs or self.inputs != other.outputs):\n            raise ValueError(\n                ""FRD.feedback, inputs/outputs mismatch"")\n        fresp = empty((self.outputs, self.inputs, len(other.omega)),\n                      dtype=complex)\n        # TODO: vectorize this\n        # TODO: handle omega re-mapping\n        # TODO: is there a reason to use linalg.solve instead of linalg.inv?\n        # https://github.com/python-control/python-control/pull/314#discussion_r294075154\n        for k, w in enumerate(other.omega):\n            fresp[:, :, k] = np.dot(\n                self.fresp[:, :, k],\n                linalg.solve(\n                    eye(self.inputs)\n                    + np.dot(other.fresp[:, :, k], self.fresp[:, :, k]),\n                    eye(self.inputs))\n            )\n\n        return FRD(fresp, other.omega, smooth=(self.ifunc is not None))\n\n#\n# Allow FRD as an alias for the FrequencyResponseData class\n#\n# Note: This class was initially given the name ""FRD"", but this caused\n# problems with documentation on MacOS platforms, since files were generated\n# for control.frd and control.FRD, which are not differentiated on most MacOS\n# filesystems, which are case insensitive.  Renaming the FRD class to be\n# FrequenceResponseData and then assigning FRD to point to the same object\n# fixes this problem.\n#\n\nFRD = FrequencyResponseData\n\n\ndef _convertToFRD(sys, omega, inputs=1, outputs=1):\n    """"""Convert a system to frequency response data form (if needed).\n\n    If sys is already an frd, and its frequency range matches or\n    overlaps the range given in omega then it is returned.  If sys is\n    another LTI object or a transfer function, then it is converted to\n    a frequency response data at the specified omega. If sys is a\n    scalar, then the number of inputs and outputs can be specified\n    manually, as in:\n\n    >>> frd = _convertToFRD(3., omega) # Assumes inputs = outputs = 1\n    >>> frd = _convertToFRD(1., omegs, inputs=3, outputs=2)\n\n    In the latter example, sys\'s matrix transfer function is [[1., 1., 1.]\n                                                              [1., 1., 1.]].\n\n    """"""\n\n    if isinstance(sys, FRD):\n        omega.sort()\n        if len(omega) == len(sys.omega) and \\\n           (abs(omega - sys.omega) < FRD.epsw).all():\n            # frequencies match, and system was already frd; simply use\n            return sys\n\n        raise NotImplementedError(\n            ""Frequency ranges of FRD do not match, conversion not implemented"")\n\n    elif isinstance(sys, LTI):\n        omega.sort()\n        fresp = empty((sys.outputs, sys.inputs, len(omega)), dtype=complex)\n        for k, w in enumerate(omega):\n            fresp[:, :, k] = sys._evalfr(w)\n\n        return FRD(fresp, omega, smooth=True)\n\n    elif isinstance(sys, (int, float, complex, np.number)):\n        fresp = ones((outputs, inputs, len(omega)), dtype=float)*sys\n        return FRD(fresp, omega, smooth=True)\n\n    # try converting constant matrices\n    try:\n        sys = array(sys)\n        outputs, inputs = sys.shape\n        fresp = empty((outputs, inputs, len(omega)), dtype=float)\n        for i in range(outputs):\n            for j in range(inputs):\n                fresp[i, j, :] = sys[i, j]\n        return FRD(fresp, omega, smooth=True)\n    except Exception:\n        pass\n\n    raise TypeError(\'\'\'Can\'t convert given type ""%s"" to FRD system.\'\'\' %\n                    sys.__class__)\n\n\ndef frd(*args):\n    """"""frd(d, w)\n\n    Construct a frequency response data model\n\n    frd models store the (measured) frequency response of a system.\n\n    This function can be called in different ways:\n\n    ``frd(response, freqs)``\n        Create an frd model with the given response data, in the form of\n        complex response vector, at matching frequency freqs [in rad/s]\n\n    ``frd(sys, freqs)``\n        Convert an LTI system into an frd model with data at frequencies\n        freqs.\n\n    Parameters\n    ----------\n    response: array_like, or list\n        complex vector with the system response\n    freq: array_lik or lis\n        vector with frequencies\n    sys: LTI (StateSpace or TransferFunction)\n        A linear system\n\n    Returns\n    -------\n    sys: FRD\n        New frequency response system\n\n    See Also\n    --------\n    FRD, ss, tf\n    """"""\n    return FRD(*args)\n'"
External_Libraries/python_control_master/control/freqplot.py,49,"b'# freqplot.py - frequency domain plots for control systems\n#\n# Author: Richard M. Murray\n# Date: 24 May 09\n#\n# This file contains some standard control system plots: Bode plots,\n# Nyquist plots and pole-zero diagrams.  The code for Nichols charts\n# is in nichols.py.\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport scipy as sp\nimport numpy as np\nimport math\nfrom .ctrlutil import unwrap\nfrom .bdalg import feedback\nfrom .margins import stability_margins\nfrom . import config\n\n__all__ = [\'bode_plot\', \'nyquist_plot\', \'gangof4_plot\',\n           \'bode\', \'nyquist\', \'gangof4\']\n\n# Default values for module parameter variables\n_freqplot_defaults = {\n    \'freqplot.feature_periphery_decades\': 1,\n    \'freqplot.number_of_samples\': None,\n}\n\n#\n# Main plotting functions\n#\n# This section of the code contains the functions for generating\n# frequency domain plots\n#\n\n#\n# Bode plot\n#\n\n# Default values for Bode plot configuration variables\n_bode_defaults = {\n    \'bode.dB\': False,           # Plot gain in dB\n    \'bode.deg\': True,           # Plot phase in degrees\n    \'bode.Hz\': False,           # Plot frequency in Hertz\n    \'bode.grid\': True,          # Turn on grid for gain and phase\n}\n\n\ndef bode_plot(syslist, omega=None,\n              Plot=True, omega_limits=None, omega_num=None,\n              margins=None, Dense_Phase_Major_Ticks=False, App=None, *args, **kwargs):\n    """"""\n    Bode plot for a system\n\n    Plots a Bode plot for the system over a (optional) frequency range.\n\n    Parameters\n    ----------\n    syslist : linsys\n        List of linear input/output systems (single system is OK)\n    omega : list\n        List of frequencies in rad/sec to be used for frequency response\n    dB : bool\n        If True, plot result in dB.  Default is false.\n    Hz : bool\n        If True, plot frequency in Hz (omega must be provided in rad/sec).\n        Default value (False) set by config.defaults[\'bode.Hz\']\n    deg : bool\n        If True, plot phase in degrees (else radians).  Default value (True)\n        config.defaults[\'bode.deg\']\n    Plot : bool\n        If True, plot magnitude and phase\n    omega_limits: tuple, list, ... of two values\n        Limits of the to generate frequency vector.\n        If Hz=True the limits are in Hz otherwise in rad/s.\n    omega_num: int\n        Number of samples to plot.  Defaults to\n        config.defaults[\'freqplot.number_of_samples\'].\n    margins : bool\n        If True, plot gain and phase margin.\n    \\*args, \\**kwargs:\n        Additional options to matplotlib (color, linestyle, etc)\n\n    Returns\n    -------\n    mag : array (list if len(syslist) > 1)\n        magnitude\n    phase : array (list if len(syslist) > 1)\n        phase in radians\n    omega : array (list if len(syslist) > 1)\n        frequency in rad/sec\n\n    Other Parameters\n    ----------------\n    grid : bool\n        If True, plot grid lines on gain and phase plots.  Default is set by\n        config.defaults[\'bode.grid\'].\n\n    The default values for Bode plot configuration parameters can be reset\n    using the `config.defaults` dictionary, with module name \'bode\'.\n\n    Notes\n    -----\n    1. Alternatively, you may use the lower-level method (mag, phase, freq)\n    = sys.freqresp(freq) to generate the frequency response for a system,\n    but it returns a MIMO response.\n\n    2. If a discrete time model is given, the frequency response is plotted\n    along the upper branch of the unit circle, using the mapping z = exp(j\n    \\omega dt) where omega ranges from 0 to pi/dt and dt is the discrete\n    timebase.  If not timebase is specified (dt = True), dt is set to 1.\n\n    Examples\n    --------\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> mag, phase, omega = bode(sys)\n\n    """"""\n    # Make a copy of the kwargs dictonary since we will modify it\n    kwargs = dict(kwargs)\n\n    # Get values for params (and pop from list to allow keyword use in plot)\n    dB = config._get_param(\'bode\', \'dB\', kwargs, _bode_defaults, pop=True)\n    deg = config._get_param(\'bode\', \'deg\', kwargs, _bode_defaults, pop=True)\n    Hz = config._get_param(\'bode\', \'Hz\', kwargs, _bode_defaults, pop=True)\n    grid = config._get_param(\'bode\', \'grid\', kwargs, _bode_defaults, pop=True)\n    Plot = config._get_param(\'bode\', \'grid\', Plot, True)\n    margins = config._get_param(\'bode\', \'margins\', margins, False)\n\n    # If argument was a singleton, turn it into a list\n    if not getattr(syslist, \'__iter__\', False):\n        syslist = (syslist,)\n\n    if omega is None:\n        if omega_limits is None:\n            # Select a default range if none is provided\n            omega = default_frequency_range(syslist, Hz=Hz,\n                                            number_of_samples=omega_num)\n        else:\n            omega_limits = np.array(omega_limits)\n            if Hz:\n                omega_limits *= 2. * math.pi\n            if omega_num:\n                omega = sp.logspace(np.log10(omega_limits[0]),\n                                    np.log10(omega_limits[1]),\n                                    num=omega_num,\n                                    endpoint=True)\n            else:\n                omega = sp.logspace(np.log10(omega_limits[0]),\n                                    np.log10(omega_limits[1]),\n                                    endpoint=True)\n\n    mags, phases, omegas, nyquistfrqs = [], [], [], []\n    for sys in syslist:\n        if sys.inputs > 1 or sys.outputs > 1:\n            # TODO: Add MIMO bode plots.\n            raise NotImplementedError(\n                ""Bode is currently only implemented for SISO systems."")\n        else:\n            omega_sys = np.array(omega)\n            if sys.isdtime(True):\n                nyquistfrq = 2. * math.pi * 1. / sys.dt / 2.\n                omega_sys = omega_sys[omega_sys < nyquistfrq]\n                # TODO: What distance to the Nyquist frequency is appropriate?\n            else:\n                nyquistfrq = None\n            # Get the magnitude and phase of the system\n            mag_tmp, phase_tmp, omega_sys = sys.freqresp(omega_sys)\n            mag = np.atleast_1d(np.squeeze(mag_tmp))\n            phase = np.atleast_1d(np.squeeze(phase_tmp))\n            phase = unwrap(phase)\n\n            mags.append(mag)\n            phases.append(phase)\n            omegas.append(omega_sys)\n            nyquistfrqs.append(nyquistfrq)\n            # Get the dimensions of the current axis, which we will divide up\n            # TODO: Not current implemented; just use subplot for now\n\n            if Plot:\n                nyquistfrq_plot = None\n                if Hz:\n                    omega_plot = omega_sys / (2. * math.pi)\n                    if nyquistfrq:\n                        nyquistfrq_plot = nyquistfrq / (2. * math.pi)\n                else:\n                    omega_plot = omega_sys\n                    if nyquistfrq:\n                        nyquistfrq_plot = nyquistfrq\n\n                # Set up the axes with labels so that multiple calls to\n                # bode_plot will superimpose the data.  This was implicit\n                # before matplotlib 2.1, but changed after that (See\n                # https://github.com/matplotlib/matplotlib/issues/9024).\n                # The code below should work on all cases.\n\n                # Get the current figure\n\n                if \'sisotool\' in kwargs:\n                    fig = kwargs[\'fig\']\n                    ax_mag = fig.axes[0]\n                    ax_phase = fig.axes[2]\n                    sisotool = kwargs[\'sisotool\']\n                    del kwargs[\'fig\']\n                    del kwargs[\'sisotool\']\n                else:\n                    fig = plt.gcf()\n                    ax_mag = None\n                    ax_phase = None\n                    sisotool = False\n\n                    # Get the current axes if they already exist\n                    for ax in fig.axes:\n                        if ax.get_label() == \'control-bode-magnitude\':\n                            ax_mag = ax\n                        elif ax.get_label() == \'control-bode-phase\':\n                            ax_phase = ax\n\n                    # If no axes present, create them from scratch\n                    if ax_mag is None or ax_phase is None:\n                        plt.clf()\n                        ax_mag = plt.subplot(211,\n                                             label=\'control-bode-magnitude\')\n                        ax_phase = plt.subplot(212,\n                                               label=\'control-bode-phase\',\n                                               sharex=ax_mag)\n\n                # Magnitude plot\n                if dB:\n                    pltline = ax_mag.semilogx(omega_plot, 20 * np.log10(mag), color=\'blue\' if App == None else App.PenColours[""Light Blue""].color().name(0),\n                                              *args, **kwargs)\n                else:\n                    pltline = ax_mag.loglog(omega_plot, mag, color=\'blue\' if App == None else App.PenColours[""Light Blue""].color().name(0), *args, **kwargs)\n\n                if nyquistfrq_plot:\n                    ax_mag.axvline(nyquistfrq_plot,\n                                   color=pltline[0].get_color())\n\n                # Add a grid to the plot + labelling\n                ax_mag.grid(grid and not margins, which=\'both\')\n                ax_mag.set_ylabel(""Magnitude (dB)"" if dB else ""Magnitude"",color=pltline[0].get_color())\n\n                # Phase plot\n                if deg:\n                    phase_plot = phase * 180. / math.pi\n                else:\n                    phase_plot = phase\n                ax_phase.semilogx(omega_plot, phase_plot, color=\'orange\' if App == None else App.PenColours[""Orange""].color().name(0), *args, **kwargs)\n\n                # Show the phase and gain margins in the plot\n                if margins:\n                    gm_color = \'c\' if App == None else App.PenColours[""Cyan""].color().name(0)\n                    pm_color = \'r\' if App == None else App.PenColours[""Red""].color().name(0)\n                    margin = stability_margins(sys)\n                    gm, pm, Wcg, Wcp = \\\n                        margin[0], margin[1], margin[3], margin[4]\n                    # TODO: add some documentation describing why this is here\n                    phase_at_cp = phases[0][(np.abs(omegas[0] - Wcp)).argmin()]\n                    if phase_at_cp >= 0.:\n                        phase_limit = 180.\n                    else:\n                        phase_limit = -180.\n\n                    if Hz:\n                        Wcg, Wcp = Wcg/(2*math.pi), Wcp/(2*math.pi)\n\n                    ax_mag.axhline(y=0 if dB else 1, color=pm_color, linestyle=\':\',\n                                   zorder=-20)\n                    ax_phase.axhline(y=phase_limit if deg else\n                                     math.radians(phase_limit),\n                                     color=gm_color, linestyle=\':\', zorder=-20)\n                    mag_ylim = ax_mag.get_ylim()\n                    phase_ylim = ax_phase.get_ylim()\n\n                    if pm != float(\'inf\') and Wcp != float(\'nan\'):\n                        if dB:\n                            ax_mag.semilogx(\n                                [Wcp, Wcp], [0., -1e5],\n                                color=pm_color, linestyle=(0, (4, 4)),linewidth=0.5, zorder=-20)\n                        else:\n                            ax_mag.loglog(\n                                [Wcp, Wcp], [1., 1e-8],\n                                color=pm_color, linestyle=(0, (4, 4)),linewidth=0.5, zorder=-20)\n\n                        if deg:\n                            ax_phase.semilogx(\n                                [Wcp, Wcp], [1e5, phase_limit+pm],\n                                color=pm_color, linestyle=(0, (2, 6)),linewidth=0.5, zorder=-20)\n                            ax_phase.semilogx(\n                                [Wcp, Wcp], [phase_limit + pm, phase_limit],\n                                color=pm_color, linewidth=2, zorder=-20)\n                        else:\n                            ax_phase.semilogx(\n                                [Wcp, Wcp], [1e5, math.radians(phase_limit) +\n                                             math.radians(pm)],\n                                color=pm_color, linestyle=(0, (2, 6)),linewidth=0.5, zorder=-20)\n                            ax_phase.semilogx(\n                                [Wcp, Wcp], [math.radians(phase_limit) +\n                                             math.radians(pm),\n                                             math.radians(phase_limit)],\n                                color=pm_color, linewidth=2, zorder=-20)\n\n                    if gm != float(\'inf\') and Wcg != float(\'nan\'):\n                        if dB:\n                            ax_mag.semilogx(\n                                [Wcg, Wcg], [-20.*np.log10(gm), -1e5],\n                                color=gm_color, linestyle=(0, (4, 4)),linewidth=0.5, zorder=-20)\n                            ax_mag.semilogx(\n                                [Wcg, Wcg], [0, -20*np.log10(gm)],\n                                color=gm_color, linewidth=2, zorder=-20)\n                        else:\n                            ax_mag.loglog(\n                                [Wcg, Wcg], [1./gm, 1e-8], color=gm_color,\n                                linestyle=(0, (4, 4)),linewidth=0.5, zorder=-20)\n                            ax_mag.loglog(\n                                [Wcg, Wcg], [1., 1./gm], color=gm_color, linewidth=2, zorder=-20)\n\n                        if deg:\n                            ax_phase.semilogx(\n                                [Wcg, Wcg], [1e-8, phase_limit],\n                                color=gm_color, linestyle=(0, (2, 6)),linewidth=0.5, zorder=-20)\n                        else:\n                            ax_phase.semilogx(\n                                [Wcg, Wcg], [1e-8, math.radians(phase_limit)],\n                                color=gm_color, linestyle=(0, (2, 6)),linewidth=0.5, zorder=-20)\n\n                    ax_mag.set_ylim(mag_ylim)\n                    ax_phase.set_ylim(phase_ylim)\n\n                    if sisotool:\n                        ax_mag.text(\n                            0.04, 0.06,\n                            \'Gain Margin: %.2f %s\\nFreq: %.2f %s\' %\n                            (20*np.log10(gm) if dB else gm,\n                             \'dB \' if dB else \'\',\n                             Wcg, \'Hz\' if Hz else \'rad/s\'),\n                            horizontalalignment=\'left\',\n                            verticalalignment=\'bottom\',\n                            transform=ax_mag.transAxes,\n                            color=gm_color,\n                            fontsize=8 if int(mpl.__version__[0]) == 1 else 6)\n                        ax_phase.text(\n                            0.04, 0.06,\n                            \'Phase Margin: %.2f %s\\nFreq: %.2f %s\' %\n                            (pm if deg else math.radians(pm),\n                             \'deg\' if deg else \'rad\',\n                             Wcp, \'Hz\' if Hz else \'rad/s\'),\n                            horizontalalignment=\'left\',\n                            verticalalignment=\'bottom\',\n                            transform=ax_phase.transAxes,\n                            color=pm_color,\n                            fontsize=8 if int(mpl.__version__[0]) == 1 else 6)\n                    else:\n                        #plt.suptitle(\n                        #    ""Gain Margin (blue) = %.2f %s(at %.2f %s), ""\n                        #    ""Phase Margin (red) = %.2f %s (at %.2f %s)"" %\n                        #    (20*np.log10(gm) if dB else gm,\n                        #     \'dB \' if dB else \'\\b\',\n                        #     Wcg, \'Hz\' if Hz else \'rad/s\',\n                        #     pm if deg else math.radians(pm),\n                        #     \'deg\' if deg else \'rad\',\n                        #     Wcp, \'Hz\' if Hz else \'rad/s\'),\n                        #    color = ""orange"")\n                        ax_mag.text(\n                            0.04, 1,\n                            \' Gain Margin: %.2f %s\\n  Frequency: %.2f %s\' %\n                            (20*np.log10(gm) if dB else gm,\n                             \'dB \' if dB else \'\',\n                             Wcg, \'Hz\' if Hz else \'rad/s\'),\n                            horizontalalignment=\'left\',\n                            verticalalignment=\'bottom\',\n                            transform=ax_phase.transAxes,\n                            color=gm_color)\n                        ax_phase.text(\n                            0.96, 1,\n                            \'Phase Margin: %.2f %s\\n  Frequency: %.2f %s\' %\n                            (pm if deg else math.radians(pm),\n                             \'deg\' if deg else \'rad\',\n                             Wcp, \'Hz\' if Hz else \'rad/s\'),\n                            horizontalalignment=\'right\',\n                            verticalalignment=\'bottom\',\n                            transform=ax_phase.transAxes,\n                            color=pm_color)\n\n                if nyquistfrq_plot:\n                    ax_phase.axvline(\n                        nyquistfrq_plot, color=""orange"")\n\n                # Add a grid to the plot + labeling\n                ax_phase.set_ylabel(""Phase (deg)"" if deg else ""Phase (rad)"",color=""orange"")\n\n                def gen_zero_centered_series(val_min, val_max, period):\n                    v1 = np.ceil(val_min / period - 0.2)\n                    v2 = np.floor(val_max / period + 0.2)\n                    return np.arange(v1, v2 + 1) * period\n                if deg:\n                    ylim = ax_phase.get_ylim()\n                    if Dense_Phase_Major_Ticks:\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], 15.))\n                    else:\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], 45.))\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], 15.), minor=True)\n                else:\n                    ylim = ax_phase.get_ylim()\n                    if Dense_Phase_Major_Ticks:\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], math.pi / 12.))\n                    else:\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], math.pi / 4.))\n                        ax_phase.set_yticks(gen_zero_centered_series(\n                            ylim[0], ylim[1], math.pi / 12.), minor=True)\n                #ax_phase.grid(grid and not margins, which=\'both\')\n                # ax_mag.grid(which=\'minor\', alpha=0.3)\n                # ax_mag.grid(which=\'major\', alpha=0.9)\n                # ax_phase.grid(which=\'minor\', alpha=0.3)\n                # ax_phase.grid(which=\'major\', alpha=0.9)\n\n                # Label the frequency axis\n                ax_phase.set_xlabel(""Frequency (Hz)"" if Hz\n                                    else ""Frequency (rad/sec)"")\n\n    if len(syslist) == 1:\n        return mags[0], phases[0], omegas[0]\n    else:\n        return mags, phases, omegas\n\n#\n# Nyquist plot\n#\n\ndef nyquist_plot(syslist, omega=None, Plot=True, color=None,\n                 labelFreq=0, number_of_samples=50,App=None, *args, **kwargs):\n    """"""\n    Nyquist plot for a system\n\n    Plots a Nyquist plot for the system over a (optional) frequency range.\n\n    Parameters\n    ----------\n    syslist : list of LTI\n        List of linear input/output systems (single system is OK)\n    omega : freq_range\n        Range of frequencies (list or bounds) in rad/sec\n    Plot : boolean\n        If True, plot magnitude\n    color : string\n        Used to specify the color of the plot\n    labelFreq : int\n        Label every nth frequency on the plot\n    \\*args, \\**kwargs:\n        Additional options to matplotlib (color, linestyle, etc)\n\n    Returns\n    -------\n    real : array\n        real part of the frequency response array\n    imag : array\n        imaginary part of the frequency response array\n    freq : array\n        frequencies\n\n    Examples\n    --------\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> real, imag, freq = nyquist_plot(sys)\n\n    """"""\n    # If argument was a singleton, turn it into a list\n    if not getattr(syslist, \'__iter__\', False):\n        syslist = (syslist,)\n\n    # Select a default range if none is provided\n    if omega is None:\n        omega = default_frequency_range(syslist,number_of_samples=number_of_samples)\n\n    # Interpolate between wmin and wmax if a tuple or list are provided\n    elif isinstance(omega, list) or isinstance(omega, tuple):\n        # Only accept tuple or list of length 2\n        if len(omega) != 2:\n            raise ValueError(""Supported frequency arguments are (wmin,wmax)""\n                             ""tuple or list, or frequency vector. "")\n        omega = np.logspace(np.log10(omega[0]), np.log10(omega[1]),\n                            num=50, endpoint=True, base=10.0)\n\n    for sys in syslist:\n        if sys.inputs > 1 or sys.outputs > 1:\n            # TODO: Add MIMO nyquist plots.\n            raise NotImplementedError(\n                ""Nyquist is currently only implemented for SISO systems."")\n        else:\n            # Get the magnitude and phase of the system\n            mag_tmp, phase_tmp, omega = sys.freqresp(omega)\n            mag = np.squeeze(mag_tmp)\n            phase = np.squeeze(phase_tmp)\n\n            # Compute the primary curve\n            x = sp.multiply(mag, sp.cos(phase))\n            y = sp.multiply(mag, sp.sin(phase))\n\n            if Plot:\n                # Plot the primary curve and mirror image\n                p = plt.plot(x, y, \'-\',label=""Primary"", color=""c"" if App == None else App.PenColours[""Light Blue""].color().name(0) , *args, **kwargs)\n                c = p[0].get_color()\n                ax = plt.gca()\n                # Plot arrow to indicate Nyquist encirclement orientation\n                ax.arrow(x[0], y[0], (x[1]-x[0])/2, (y[1]-y[0])/2, fc=c, ec=c,\n                         head_width=0.2, head_length=0.2)\n\n                p2 = plt.plot(x, -y, \'-\', color=""orange"" if App == None else App.PenColours[""Orange""].color().name(0), label=""Mirror"", *args, **kwargs)\n                c = p2[0].get_color()\n                ax.arrow(\n                    x[-1], -y[-1], (x[-1]-x[-2])/2, (y[-1]-y[-2])/2,\n                    fc=c, ec=c, head_width=0.2, head_length=0.2)\n\n                # Mark the -1 point\n                plt.plot([-1], [0], \'r+\')\n\n            # Label the frequencies of the points\n            if labelFreq:\n                ind = slice(None, None, labelFreq)\n                for xpt, ypt, omegapt in zip(x[ind], y[ind], omega[ind]):\n                    # Convert to Hz\n                    f = omegapt / (2 * sp.pi)\n\n                    # Factor out multiples of 1000 and limit the\n                    # result to the range [-8, 8].\n                    pow1000 = max(min(get_pow1000(f), 8), -8)\n\n                    # Get the SI prefix.\n                    prefix = gen_prefix(pow1000)\n\n                    # Apply the text. (Use a space before the text to\n                    # prevent overlap with the data.)\n                    #\n                    # np.round() is used because 0.99... appears\n                    # instead of 1.0, and this would otherwise be\n                    # truncated to 0.\n                    plt.text(xpt, ypt, \' \' +\n                             str(int(np.round(f / 1000 ** pow1000, 0))) + \' \' +\n                             prefix + \'Hz\')\n\n    if Plot:\n        ax = plt.gca()\n        ax.set_xlabel(""Real axis"")\n        ax.set_ylabel(""Imaginary axis"")\n        ax.grid(color=App.MiscColours[""Broken""].color().name(0))\n\n    return x, y, omega\n\n#\n# Gang of Four plot\n#\n\n# TODO: think about how (and whether) to handle lists of systems\ndef gangof4_plot(P, C, omega=None):\n    """"""Plot the ""Gang of 4"" transfer functions for a system\n\n    Generates a 2x2 plot showing the ""Gang of 4"" sensitivity functions\n    [T, PS; CS, S]\n\n    Parameters\n    ----------\n    P, C : LTI\n        Linear input/output systems (process and control)\n    omega : array\n        Range of frequencies (list or bounds) in rad/sec\n\n    Returns\n    -------\n    None\n    """"""\n    if P.inputs > 1 or P.outputs > 1 or C.inputs > 1 or C.outputs > 1:\n        # TODO: Add MIMO go4 plots.\n        raise NotImplementedError(\n            ""Gang of four is currently only implemented for SISO systems."")\n    else:\n\n        # Select a default range if none is provided\n        # TODO: This needs to be made more intelligent\n        if omega is None:\n            omega = default_frequency_range((P, C))\n\n        # Compute the senstivity functions\n        L = P * C\n        S = feedback(1, L)\n        T = L * S\n\n        # Set up the axes with labels so that multiple calls to\n        # gangof4_plot will superimpose the data.  See details in bode_plot.\n        plot_axes = {\'t\': None, \'s\': None, \'ps\': None, \'cs\': None}\n        for ax in plt.gcf().axes:\n            label = ax.get_label()\n            if label.startswith(\'control-gangof4-\'):\n                key = label[len(\'control-gangof4-\'):]\n                if key not in plot_axes:\n                    raise RuntimeError(\n                        ""unknown gangof4 axis type \'{}\'"".format(label))\n                plot_axes[key] = ax\n\n        # if any of the axes are missing, start from scratch\n        if any((ax is None for ax in plot_axes.values())):\n            plt.clf()\n            plot_axes = {\'t\': plt.subplot(221, label=\'control-gangof4-t\'),\n                         \'ps\': plt.subplot(222, label=\'control-gangof4-ps\'),\n                         \'cs\': plt.subplot(223, label=\'control-gangof4-cs\'),\n                         \'s\': plt.subplot(224, label=\'control-gangof4-s\')}\n\n        #\n        # Plot the four sensitivity functions\n        #\n\n        # TODO: Need to add in the mag = 1 lines\n        mag_tmp, phase_tmp, omega = T.freqresp(omega)\n        mag = np.squeeze(mag_tmp)\n        plot_axes[\'t\'].loglog(omega, mag)\n\n        mag_tmp, phase_tmp, omega = (P * S).freqresp(omega)\n        mag = np.squeeze(mag_tmp)\n        plot_axes[\'ps\'].loglog(omega, mag)\n\n        mag_tmp, phase_tmp, omega = (C * S).freqresp(omega)\n        mag = np.squeeze(mag_tmp)\n        plot_axes[\'cs\'].loglog(omega, mag)\n\n        mag_tmp, phase_tmp, omega = S.freqresp(omega)\n        mag = np.squeeze(mag_tmp)\n        plot_axes[\'s\'].loglog(omega, mag)\n\n#\n# Utility functions\n#\n# This section of the code contains some utility functions for\n# generating frequency domain plots\n#\n\n# Compute reasonable defaults for axes\ndef default_frequency_range(syslist, Hz=None, number_of_samples=None,\n                            feature_periphery_decades=None):\n    """"""Compute a reasonable default frequency range for frequency\n    domain plots.\n\n    Finds a reasonable default frequency range by examining the features\n    (poles and zeros) of the systems in syslist.\n\n    Parameters\n    ----------\n    syslist : list of LTI\n        List of linear input/output systems (single system is OK)\n    Hz : bool\n        If True, the limits (first and last value) of the frequencies\n        are set to full decades in Hz so it fits plotting with logarithmic\n        scale in Hz otherwise in rad/s. Omega is always returned in rad/sec.\n    number_of_samples : int, optional\n        Number of samples to generate.  The default value is read from\n        ``config.defaults[\'freqplot.number_of_samples\'].  If None, then the\n        default from `numpy.logspace` is used.\n    feature_periphery_decades : float, optional\n        Defines how many decades shall be included in the frequency range on\n        both sides of features (poles, zeros).  The default value is read from\n        ``config.defaults[\'freqplot.feature_periphery_decades\']``.\n\n    Returns\n    -------\n    omega : array\n        Range of frequencies in rad/sec\n\n    Examples\n    --------\n    >>> from matlab import ss\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> omega = default_frequency_range(sys)\n\n    """"""\n    # This code looks at the poles and zeros of all of the systems that\n    # we are plotting and sets the frequency range to be one decade above\n    # and below the min and max feature frequencies, rounded to the nearest\n    # integer.  It excludes poles and zeros at the origin.  If no features\n    # are found, it turns logspace(-1, 1)\n\n    # Set default values for options\n    number_of_samples = config._get_param(\n        \'freqplot\', \'number_of_samples\', number_of_samples)\n    feature_periphery_decades = config._get_param(\n        \'freqplot\', \'feature_periphery_decades\', feature_periphery_decades, 1)\n\n    # Find the list of all poles and zeros in the systems\n    features = np.array(())\n    freq_interesting = []\n\n    # detect if single sys passed by checking if it is sequence-like\n    if not getattr(syslist, \'__iter__\', False):\n        syslist = (syslist,)\n\n    for sys in syslist:\n        try:\n            # Add new features to the list\n            if sys.isctime():\n                features_ = np.concatenate((np.abs(sys.pole()),\n                                            np.abs(sys.zero())))\n                # Get rid of poles and zeros at the origin\n                features_ = features_[features_ != 0.0]\n                features = np.concatenate((features, features_))\n            elif sys.isdtime(strict=True):\n                fn = math.pi * 1. / sys.dt\n                # TODO: What distance to the Nyquist frequency is appropriate?\n                freq_interesting.append(fn * 0.9)\n\n                features_ = np.concatenate((sys.pole(),\n                                            sys.zero()))\n                # Get rid of poles and zeros\n                # * at the origin and real <= 0 & imag==0: log!\n                # * at 1.: would result in omega=0. (logaritmic plot!)\n                features_ = features_[\n                    (features_.imag != 0.0) | (features_.real > 0.)]\n                features_ = features_[\n                    np.bitwise_not((features_.imag == 0.0) &\n                                   (np.abs(features_.real - 1.0) < 1.e-10))]\n                # TODO: improve\n                features__ = np.abs(np.log(features_) / (1.j * sys.dt))\n                features = np.concatenate((features, features__))\n            else:\n                # TODO\n                raise NotImplementedError(\n                    ""type of system in not implemented now"")\n        except:\n            pass\n\n    # Make sure there is at least one point in the range\n    if features.shape[0] == 0:\n        features = np.array([1.])\n\n    if Hz:\n        features /= 2. * math.pi\n        features = np.log10(features)\n        lsp_min = np.floor(np.min(features) - feature_periphery_decades)\n        lsp_max = np.ceil(np.max(features) + feature_periphery_decades)\n        lsp_min += np.log10(2. * math.pi)\n        lsp_max += np.log10(2. * math.pi)\n    else:\n        features = np.log10(features)\n        lsp_min = np.floor(np.min(features) - feature_periphery_decades)\n        lsp_max = np.ceil(np.max(features) + feature_periphery_decades)\n    if freq_interesting:\n        lsp_min = min(lsp_min, np.log10(min(freq_interesting)))\n        lsp_max = max(lsp_max, np.log10(max(freq_interesting)))\n\n    # TODO: Add a check in discrete case to make sure we don\'t get aliasing\n    # (Attention: there is a list of system but only one omega vector)\n\n    # Set the range to be an order of magnitude beyond any features\n    if number_of_samples:\n        omega = sp.logspace(\n            lsp_min, lsp_max, num=number_of_samples, endpoint=True)\n    else:\n        omega = sp.logspace(lsp_min, lsp_max, endpoint=True)\n    return omega\n\n#\n# KLD 5/23/11: Two functions to create nice looking labels\n#\n\ndef get_pow1000(num):\n    """"""Determine exponent for which significand of a number is within the\n    range [1, 1000).\n    """"""\n    # Based on algorithm from http://www.mail-archive.com/matplotlib-users@lists.sourceforge.net/msg14433.html, accessed 2010/11/7\n    # by Jason Heeris 2009/11/18\n    from decimal import Decimal\n    from math import floor\n    dnum = Decimal(str(num))\n    if dnum == 0:\n        return 0\n    elif dnum < 0:\n        dnum = -dnum\n    return int(floor(dnum.log10() / 3))\n\n\ndef gen_prefix(pow1000):\n    """"""Return the SI prefix for a power of 1000.\n    """"""\n    # Prefixes according to Table 5 of [BIPM 2006] (excluding hecto,\n    # deca, deci, and centi).\n    if pow1000 < -8 or pow1000 > 8:\n        raise ValueError(\n            ""Value is out of the range covered by the SI prefixes."")\n    return [\'Y\',  # yotta (10^24)\n            \'Z\',  # zetta (10^21)\n            \'E\',  # exa (10^18)\n            \'P\',  # peta (10^15)\n            \'T\',  # tera (10^12)\n            \'G\',  # giga (10^9)\n            \'M\',  # mega (10^6)\n            \'k\',  # kilo (10^3)\n            \'\',  # (10^0)\n            \'m\',  # milli (10^-3)\n            r\'$\\mu$\',  # micro (10^-6)\n            \'n\',  # nano (10^-9)\n            \'p\',  # pico (10^-12)\n            \'f\',  # femto (10^-15)\n            \'a\',  # atto (10^-18)\n            \'z\',  # zepto (10^-21)\n            \'y\'][8 - pow1000]  # yocto (10^-24)\n\n\ndef find_nearest_omega(omega_list, omega):\n    omega_list = np.asarray(omega_list)\n    return omega_list[(np.abs(omega_list - omega)).argmin()]\n\n\n# Function aliases\nbode = bode_plot\nnyquist = nyquist_plot\ngangof4 = gangof4_plot\n'"
External_Libraries/python_control_master/control/grid.py,11,"b'import numpy as np\nfrom numpy import cos, sin, sqrt, linspace, pi, exp\nimport matplotlib.pyplot as plt\nfrom mpl_toolkits.axisartist import SubplotHost\nfrom mpl_toolkits.axisartist.grid_helper_curvelinear import GridHelperCurveLinear\nimport mpl_toolkits.axisartist.angle_helper as angle_helper\nfrom matplotlib.projections import PolarAxes\nfrom matplotlib.transforms import Affine2D\n\nclass FormatterDMS(object):\n    \'\'\'Transforms angle ticks to damping ratios\'\'\'\n    def __call__(self,direction,factor,values):\n        angles_deg = values/factor\n        damping_ratios = np.cos((180-angles_deg)*np.pi/180)\n        ret = [""%.2f""%val for val in damping_ratios]\n        return ret\n\nclass ModifiedExtremeFinderCycle(angle_helper.ExtremeFinderCycle):\n    \'\'\'Changed to allow only left hand-side polar grid\'\'\'\n    def __call__(self, transform_xy, x1, y1, x2, y2):\n        x_, y_ = np.linspace(x1, x2, self.nx), np.linspace(y1, y2, self.ny)\n        x, y = np.meshgrid(x_, y_)\n        lon, lat = transform_xy(np.ravel(x), np.ravel(y))\n\n        with np.errstate(invalid=\'ignore\'):\n            if self.lon_cycle is not None:\n                lon0 = np.nanmin(lon)\n                lon -= 360. * ((lon - lon0) > 360.) # Changed from 180 to 360 to be able to span only 90-270 (left hand side)\n            if self.lat_cycle is not None:\n                lat0 = np.nanmin(lat)\n                lat -= 360. * ((lat - lat0) > 360.) # Changed from 180 to 360 to be able to span only 90-270 (left hand side)\n\n        lon_min, lon_max = np.nanmin(lon), np.nanmax(lon)\n        lat_min, lat_max = np.nanmin(lat), np.nanmax(lat)\n\n        lon_min, lon_max, lat_min, lat_max = \\\n            self._adjust_extremes(lon_min, lon_max, lat_min, lat_max)\n\n        return lon_min, lon_max, lat_min, lat_max\n\ndef sgrid():\n    # From matplotlib demos:\n    # https://matplotlib.org/gallery/axisartist/demo_curvelinear_grid.html\n    # https://matplotlib.org/gallery/axisartist/demo_floating_axis.html\n\n    # PolarAxes.PolarTransform takes radian. However, we want our coordinate\n    # system in degree\n    tr = Affine2D().scale(np.pi/180., 1.) + PolarAxes.PolarTransform()\n    # polar projection, which involves cycle, and also has limits in\n    # its coordinates, needs a special method to find the extremes\n    # (min, max of the coordinate within the view).\n\n    # 20, 20 : number of sampling points along x, y direction\n    sampling_points = 20\n    extreme_finder = ModifiedExtremeFinderCycle(sampling_points, sampling_points,\n                                                     lon_cycle=360,\n                                                     lat_cycle=None,\n                                                     lon_minmax=(90,270),\n                                                     lat_minmax=(0, np.inf),)\n\n    grid_locator1 = angle_helper.LocatorDMS(15)\n    tick_formatter1 = FormatterDMS()\n    grid_helper = GridHelperCurveLinear(tr,\n                                        extreme_finder=extreme_finder,\n                                        grid_locator1=grid_locator1,\n                                        tick_formatter1=tick_formatter1\n                                        )\n\n    fig = plt.figure()\n    ax = SubplotHost(fig, 1, 1, 1, grid_helper=grid_helper)\n\n    # make ticklabels of right invisible, and top axis visible.\n    visible = True\n    ax.axis[:].major_ticklabels.set_visible(visible)\n    ax.axis[:].major_ticks.set_visible(False)\n    ax.axis[:].invert_ticklabel_direction()\n\n    ax.axis[""wnxneg""] = axis = ax.new_floating_axis(0, 180)\n    axis.set_ticklabel_direction(""-"")\n    axis.label.set_visible(False)\n    ax.axis[""wnxpos""] = axis = ax.new_floating_axis(0, 0)\n    axis.label.set_visible(False)\n    ax.axis[""wnypos""] = axis = ax.new_floating_axis(0, 90)\n    axis.label.set_visible(False)\n    axis.set_axis_direction(""left"")\n    ax.axis[""wnyneg""] = axis = ax.new_floating_axis(0, 270)\n    axis.label.set_visible(False)\n    axis.set_axis_direction(""left"")\n    axis.invert_ticklabel_direction()\n    axis.set_ticklabel_direction(""-"")\n\n    # let left axis shows ticklabels for 1st coordinate (angle)\n    ax.axis[""left""].get_helper().nth_coord_ticks = 0\n    ax.axis[""right""].get_helper().nth_coord_ticks = 0\n    ax.axis[""left""].get_helper().nth_coord_ticks = 0\n    ax.axis[""bottom""].get_helper().nth_coord_ticks = 0\n\n    fig.add_subplot(ax)\n\n    ### RECTANGULAR X Y AXES WITH SCALE\n    #par2 = ax.twiny()\n    #par2.axis[""top""].toggle(all=False)\n    #par2.axis[""right""].toggle(all=False)\n    #new_fixed_axis = par2.get_grid_helper().new_fixed_axis\n    #par2.axis[""left""] = new_fixed_axis(loc=""left"",\n    #                                   axes=par2,\n    #                                   offset=(0, 0))\n    #par2.axis[""bottom""] = new_fixed_axis(loc=""bottom"",\n    #                                     axes=par2,\n    #                                     offset=(0, 0))\n    ### FINISH RECTANGULAR\n\n    ax.grid(True, zorder=0,linestyle=\'dotted\')\n\n    _final_setup(ax)\n    return ax, fig\n\ndef _final_setup(ax):\n    ax.set_xlabel(\'Real\')\n    ax.set_ylabel(\'Imaginary\')\n    ax.axhline(y=0, color=\'black\', lw=1)\n    ax.axvline(x=0, color=\'black\', lw=1)\n    plt.axis(\'equal\')\n\ndef nogrid():\n    f = plt.figure()\n    ax = plt.axes()\n\n    _final_setup(ax)\n    return ax, f\n\ndef zgrid(zetas=None, wns=None):\n    \'\'\'Draws discrete damping and frequency grid\'\'\'\n\n    fig = plt.figure()\n    ax = fig.gca()\n\n    # Constant damping lines\n    if zetas is None:\n        zetas = linspace(0, 0.9, 10)\n    for zeta in zetas:\n        # Calculate in polar coordinates\n        factor = zeta/sqrt(1-zeta**2)\n        x = linspace(0, sqrt(1-zeta**2),200)\n        ang = pi*x\n        mag = exp(-pi*factor*x)\n        # Draw upper part in retangular coordinates\n        xret = mag*cos(ang)\n        yret = mag*sin(ang)\n        ax.plot(xret,yret, \'k:\', lw=1)\n        # Draw lower part in retangular coordinates\n        xret = mag*cos(-ang)\n        yret = mag*sin(-ang)\n        ax.plot(xret,yret,\'k:\', lw=1)\n        # Annotation\n        an_i = int(len(xret)/2.5)\n        an_x = xret[an_i]\n        an_y = yret[an_i]\n        ax.annotate(str(round(zeta,2)), xy=(an_x, an_y), xytext=(an_x, an_y), size=7)\n\n    # Constant natural frequency lines\n    if wns is None:\n        wns = linspace(0, 1, 10)\n    for a in wns:\n        # Calculate in polar coordinates\n        x = linspace(-pi/2,pi/2,200)\n        ang = pi*a*sin(x)\n        mag = exp(-pi*a*cos(x))\n        # Draw in retangular coordinates\n        xret = mag*cos(ang)\n        yret = mag*sin(ang)\n        ax.plot(xret,yret,\'k:\', lw=1)\n        # Annotation\n        an_i = -1\n        an_x = xret[an_i]\n        an_y = yret[an_i]\n        num = \'{:1.1f}\'.format(a)\n        ax.annotate(""$\\\\frac{""+num+""\\pi}{T}$"", xy=(an_x, an_y), xytext=(an_x, an_y), size=9)\n\n    _final_setup(ax)\n    return ax, fig\n\n'"
External_Libraries/python_control_master/control/iosys.py,84,"b'# iosys.py - input/output system module\n#\n# RMM, 28 April 2019\n#\n# Additional features to add\n#   * Improve support for signal names, specially in operator overloads\n#       - Figure out how to handle ""nested"" names (icsys.sys[1].x[1])\n#       - Use this to implement signal names for operators?\n#   * Allow constant inputs for MIMO input_output_response (w/out ones)\n#   * Add support for constants/matrices as part of operators (1 + P)\n#   * Add unit tests (and example?) for time-varying systems\n#   * Allow time vector for discrete time simulations to be multiples of dt\n#   * Check the way initial outputs for discrete time systems are handled\n#   * Rename \'connections\' as \'conlist\' to match \'inplist\' and \'outlist\'?\n#   * Allow signal summation in InterconnectedSystem diagrams (via new output?)\n#\n\n""""""The :mod:`~control.iosys` module contains the\n:class:`~control.InputOutputSystem` class that represents (possibly nonlinear)\ninput/output systems.  The :class:`~control.InputOutputSystem` class is a\ngeneral class that defines any continuous or discrete time dynamical system.\nInput/output systems can be simulated and also used to compute equilibrium\npoints and linearizations.\n\nAn input/output system is defined as a dynamical system that has a system\nstate as well as inputs and outputs (either inputs or states can be empty).\nThe dynamics of the system can be in continuous or discrete time.  To simulate\nan input/output system, use the :func:`~control.input_output_response`\nfunction::\n\n  t, y = input_output_response(io_sys, T, U, X0, params)\n\nAn input/output system can be linearized around an equilibrium point to obtain\na :class:`~control.StateSpace` linear system.  Use the\n:func:`~control.find_eqpts` function to obtain an equilibrium point and the\n:func:`~control.linearize` function to linearize about that equilibrium point::\n\n  xeq, ueq = find_eqpt(io_sys, X0, U0)\n  ss_sys = linearize(io_sys, xeq, ueq)\n\nInput/output systems can be created from state space LTI systems by using the\n:class:`~control.LinearIOSystem` class`::\n\n  io_sys = LinearIOSystem(ss_sys)\n\nNonlinear input/output systems can be created using the\n:class:`~control.NonlinearIoSystem` class, which requires the definition of an\nupdate function (for the right hand side of the differential or different\nequation) and and output function (computes the outputs from the state)::\n\n  io_sys = NonlinearIOSystem(updfcn, outfcn, inputs=M, outputs=P, states=N)\n\nMore complex input/output systems can be constructed by using the\n:class:`~control.InterconnectedSystem` class, which allows a collection of\ninput/output subsystems to be combined with internal connections between the\nsubsystems and a set of overall system inputs and outputs that link to the\nsubsystems::\n\n    steering = ct.InterconnectedSystem(\n        (plant, controller), name=\'system\',\n        connections=((\'controller.e\', \'-plant.y\')),\n        inplist=(\'controller.e\'), inputs=\'r\',\n        outlist=(\'plant.y\'), outputs=\'y\')\n\nInterconnected systems can also be created using block diagram manipulations\nsuch as the :func:`~control.series`, :func:`~control.parallel`, and\n:func:`~control.feedback` functions.  The :class:`~control.InputOutputSystem`\nclass also supports various algebraic operations such as `*` (series\ninterconnection) and `+` (parallel interconnection).\n\n""""""\n\n__author__ = ""Richard Murray""\n__copyright__ = ""Copyright 2019, California Institute of Technology""\n__credits__ = [""Richard Murray""]\n__license__ = ""BSD""\n__maintainer__ = ""Richard Murray""\n__email__ = ""murray@cds.caltech.edu""\n\nimport numpy as np\nimport scipy as sp\nimport copy\nfrom warnings import warn\n\nfrom .statesp import StateSpace, tf2ss\nfrom .timeresp import _check_convert_array\nfrom .lti import isctime, isdtime, _find_timebase\n\n__all__ = [\'InputOutputSystem\', \'LinearIOSystem\', \'NonlinearIOSystem\',\n           \'InterconnectedSystem\', \'input_output_response\', \'find_eqpt\',\n           \'linearize\', \'ss2io\', \'tf2io\']\n\n\nclass InputOutputSystem(object):\n    """"""A class for representing input/output systems.\n\n    The InputOutputSystem class allows (possibly nonlinear) input/output\n    systems to be represented in Python.  It is intended as a parent\n    class for a set of subclasses that are used to implement specific\n    structures and operations for different types of input/output\n    dynamical systems.\n\n    Parameters\n    ----------\n    inputs : int, list of str, or None\n        Description of the system inputs.  This can be given as an integer\n        count or as a list of strings that name the individual signals.  If an\n        integer count is specified, the names of the signal will be of the\n        form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If this parameter\n        is not given or given as `None`, the relevant quantity will be\n        determined when possible based on other information provided to\n        functions using the system.\n    outputs : int, list of str, or None\n        Description of the system outputs.  Same format as `inputs`.\n    states : int, list of str, or None\n        Description of the system states.  Same format as `inputs`.\n    dt : None, True or float, optional\n        System timebase.  None (default) indicates continuous time, True\n        indicates discrete time with undefined sampling time, positive number\n        is discrete time with specified sampling time.\n    params : dict, optional\n        Parameter values for the systems.  Passed to the evaluation functions\n        for the system as default values, overriding internal defaults.\n    name : string, optional\n        System name (used for specifying signals)\n\n    Attributes\n    ----------\n    ninputs, noutputs, nstates : int\n        Number of input, output and state variables\n    input_index, output_index, state_index : dict\n        Dictionary of signal names for the inputs, outputs and states and the\n        index of the corresponding array\n    dt : None, True or float\n        System timebase.  None (default) indicates continuous time, True\n        indicates discrete time with undefined sampling time, positive number\n        is discrete time with specified sampling time.\n    params : dict, optional\n        Parameter values for the systems.  Passed to the evaluation functions\n        for the system as default values, overriding internal defaults.\n    name : string, optional\n        System name (used for specifying signals)\n\n    Notes\n    -----\n    The `InputOuputSystem` class (and its subclasses) makes use of two special\n    methods for implementing much of the work of the class:\n\n    * _rhs(t, x, u): compute the right hand side of the differential or\n      difference equation for the system.  This must be specified by the\n      subclass for the system.\n\n    * _out(t, x, u): compute the output for the current state of the system.\n      The default is to return the entire system state.\n\n    """"""\n    def __init__(self, inputs=None, outputs=None, states=None, params={},\n                 dt=None, name=None):\n        """"""Create an input/output system.\n\n        The InputOutputSystem contructor is used to create an input/output\n        object with the core information required for all input/output\n        systems.  Instances of this class are normally created by one of the\n        input/output subclasses: :class:`~control.LinearIOSystem`,\n        :class:`~control.NonlinearIOSystem`,\n        :class:`~control.InterconnectedSystem`.\n\n        Parameters\n        ----------\n        inputs : int, list of str, or None\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If\n            this parameter is not given or given as `None`, the relevant\n            quantity will be determined when possible based on other\n            information provided to functions using the system.\n        outputs : int, list of str, or None\n            Description of the system outputs.  Same format as `inputs`.\n        states : int, list of str, or None\n            Description of the system states.  Same format as `inputs`.\n        dt : None, True or float, optional\n            System timebase.  None (default) indicates continuous\n            time, True indicates discrete time with undefined sampling\n            time, positive number is discrete time with specified\n            sampling time.\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n        name : string, optional\n            System name (used for specifying signals)\n\n        Returns\n        -------\n        InputOutputSystem\n            Input/output system object\n\n        """"""\n        # Store the input arguments\n        self.params = params.copy()     # default parameters\n        self.dt = dt                    # timebase\n        self.name = name                # system name\n\n        # Parse and store the number of inputs, outputs, and states\n        self.set_inputs(inputs)\n        self.set_outputs(outputs)\n        self.set_states(states)\n\n    def __repr__(self):\n        return self.name if self.name is not None else str(type(self))\n\n    def __str__(self):\n        """"""String representation of an input/output system""""""\n        str = ""System: "" + (self.name if self.name else ""(none)"") + ""\\n""\n        str += ""Inputs (%d): "" % self.ninputs\n        for key in self.input_index: str += key + "", ""\n        str += ""\\nOutputs (%d): "" % self.noutputs\n        for key in self.output_index: str += key + "", ""\n        str += ""\\nStates (%d): "" % self.nstates\n        for key in self.state_index: str += key + "", ""\n        return str\n\n    def __mul__(sys2, sys1):\n        """"""Multiply two input/output systems (series interconnection)""""""\n\n        if isinstance(sys1, (int, float, np.number)):\n            # TODO: Scale the output\n            raise NotImplemented(""Scalar multiplication not yet implemented"")\n        elif isinstance(sys1, np.ndarray):\n            # TODO: Post-multiply by a matrix\n            raise NotImplemented(""Matrix multiplication not yet implemented"")\n        elif isinstance(sys1, StateSpace) and isinstance(sys2, StateSpace):\n            # Special case: maintain linear systems structure\n            new_ss_sys = StateSpace.__mul__(sys2, sys1)\n            # TODO: set input and output names\n            new_io_sys = LinearIOSystem(new_ss_sys)\n\n            return new_io_sys\n        elif not isinstance(sys1, InputOutputSystem):\n            raise ValueError(""Unknown I/O system object "", sys1)\n\n        # Make sure systems can be interconnected\n        if sys1.noutputs != sys2.ninputs:\n            raise ValueError(""Can\'t multiply systems with incompatible ""\n                             ""inputs and outputs"")\n\n        # Make sure timebase are compatible\n        dt = _find_timebase(sys1, sys2)\n        if dt is False:\n            raise ValueError(""System timebases are not compabile"")\n\n        # Return the series interconnection between the systems\n        newsys = InterconnectedSystem((sys1, sys2))\n\n        #  Set up the connecton map\n        newsys.set_connect_map(np.block(\n            [[np.zeros((sys1.ninputs, sys1.noutputs)),\n              np.zeros((sys1.ninputs, sys2.noutputs))],\n             [np.eye(sys2.ninputs, sys1.noutputs),\n              np.zeros((sys2.ninputs, sys2.noutputs))]]\n        ))\n\n        # Set up the input map\n        newsys.set_input_map(np.concatenate(\n            (np.eye(sys1.ninputs), np.zeros((sys2.ninputs, sys1.ninputs))),\n            axis=0))\n        # TODO: set up input names\n\n        # Set up the output map\n        newsys.set_output_map(np.concatenate(\n            (np.zeros((sys2.noutputs, sys1.noutputs)), np.eye(sys2.noutputs)),\n            axis=1))\n        # TODO: set up output names\n\n        # Return the newly created system\n        return newsys\n\n    def __rmul__(sys1, sys2):\n        """"""Pre-multiply an input/output systems by a scalar/matrix""""""\n        if isinstance(sys2, (int, float, np.number)):\n            # TODO: Scale the output\n            raise NotImplemented(""Scalar multiplication not yet implemented"")\n        elif isinstance(sys2, np.ndarray):\n            # TODO: Post-multiply by a matrix\n            raise NotImplemented(""Matrix multiplication not yet implemented"")\n        elif isinstance(sys1, StateSpace) and isinstance(sys2, StateSpace):\n            # Special case: maintain linear systems structure\n            new_ss_sys = StateSpace.__rmul__(sys1, sys2)\n            # TODO: set input and output names\n            new_io_sys = LinearIOSystem(new_ss_sys)\n\n            return new_io_sys\n        elif not isinstance(sys2, InputOutputSystem):\n            raise ValueError(""Unknown I/O system object "", sys1)\n        else:\n            # Both systetms are InputOutputSystems => use __mul__\n            return InputOutputSystem.__mul__(sys2, sys1)\n\n    def __add__(sys1, sys2):\n        """"""Add two input/output systems (parallel interconnection)""""""\n        # TODO: Allow addition of scalars and matrices\n        if not isinstance(sys2, InputOutputSystem):\n            raise ValueError(""Unknown I/O system object "", sys2)\n        elif isinstance(sys1, StateSpace) and isinstance(sys2, StateSpace):\n            # Special case: maintain linear systems structure\n            new_ss_sys = StateSpace.__add__(sys1, sys2)\n            # TODO: set input and output names\n            new_io_sys = LinearIOSystem(new_ss_sys)\n\n            return new_io_sys\n\n        # Make sure number of input and outputs match\n        if sys1.ninputs != sys2.ninputs or sys1.noutputs != sys2.noutputs:\n            raise ValueError(""Can\'t add systems with different numbers of ""\n                             ""inputs or outputs."")\n        ninputs = sys1.ninputs\n        noutputs = sys1.noutputs\n\n        # Make sure timebase are compatible\n        dt = _find_timebase(sys1, sys2)\n        if dt is False:\n            raise ValueError(""System timebases are not compabile"")\n\n        # Create a new system to handle the composition\n        newsys = InterconnectedSystem((sys1, sys2), dt=dt)\n\n        # Set up the input map\n        newsys.set_input_map(np.concatenate(\n            (np.eye(ninputs), np.eye(ninputs)), axis=0))\n        # TODO: set up input names\n\n        # Set up the output map\n        newsys.set_output_map(np.concatenate(\n            (np.eye(noutputs), np.eye(noutputs)), axis=1))\n        # TODO: set up output names\n\n        # Return the newly created system\n        return newsys\n\n    # TODO: add __radd__ to allow postaddition by scalars and matrices\n\n    def __neg__(sys):\n        """"""Negate an input/output systems (rescale)""""""\n        if isinstance(sys, StateSpace):\n            # Special case: maintain linear systems structure\n            new_ss_sys = StateSpace.__neg__(sys)\n            # TODO: set input and output names\n            new_io_sys = LinearIOSystem(new_ss_sys)\n\n            return new_io_sys\n        if sys.ninputs is None or sys.noutputs is None:\n            raise ValueError(""Can\'t determine number of inputs or outputs"")\n\n        # Create a new system to hold the negation\n        newsys = InterconnectedSystem((sys,), dt=sys.dt)\n\n        # Set up the input map (identity)\n        newsys.set_input_map(np.eye(sys.ninputs))\n        # TODO: set up input names\n\n        # Set up the output map (negate the output)\n        newsys.set_output_map(-np.eye(sys.noutputs))\n        # TODO: set up output names\n\n        # Return the newly created system\n        return newsys\n\n    # Utility function to parse a list of signals\n    def _process_signal_list(self, signals, prefix=\'s\'):\n        if signals is None:\n            # No information provided; try and make it up later\n            return None, {}\n\n        elif isinstance(signals, int):\n            # Number of signals given; make up the names\n            return signals, {\'%s[%d]\' % (prefix, i): i for i in range(signals)}\n\n        elif isinstance(signals, str):\n            # Single string given => single signal with given name\n            return 1, {signals: 0}\n\n        elif all(isinstance(s, str) for s in signals):\n            # Use the list of strings as the signal names\n            return len(signals), {signals[i]: i for i in range(len(signals))}\n\n        else:\n            raise TypeError(""Can\'t parse signal list %s"" % str(signals))\n\n    # Find a signal by name\n    def _find_signal(self, name, sigdict): return sigdict.get(name, None)\n\n    # Update parameters used for _rhs, _out (used by subclasses)\n    def _update_params(self, params, warning=False):\n        if (warning):\n            warn(""Parameters passed to InputOutputSystem ignored."")\n\n    def _rhs(self, t, x, u):\n        """"""Evaluate right hand side of a differential or difference equation.\n\n        Private function used to compute the right hand side of an\n        input/output system model.\n\n        """"""\n        NotImplemented(""Evaluation not implemented for system of type "",\n                       type(self))\n\n    def _out(self, t, x, u, params={}):\n        """"""Evaluate the output of a system at a given state, input, and time\n\n        Private function used to compute the output of of an input/output\n        system model given the state, input, parameters, and time.\n\n        """"""\n        # If no output function was defined in subclass, return state\n        return x\n\n    def set_inputs(self, inputs, prefix=\'u\'):\n        """"""Set the number/names of the system inputs.\n\n        Parameters\n        ----------\n        inputs : int, list of str, or None\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `u[i]` (where the prefix `u` can be changed using the\n            optional prefix parameter).\n        prefix : string, optional\n            If `inputs` is an integer, create the names of the states using\n            the given prefix (default = \'u\').  The names of the input will be\n            of the form `prefix[i]`.\n\n        """"""\n        self.ninputs, self.input_index = \\\n            self._process_signal_list(inputs, prefix=prefix)\n\n    def set_outputs(self, outputs, prefix=\'y\'):\n        """"""Set the number/names of the system outputs.\n\n        Parameters\n        ----------\n        outputs : int, list of str, or None\n            Description of the system outputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `u[i]` (where the prefix `u` can be changed using the\n            optional prefix parameter).\n        prefix : string, optional\n            If `outputs` is an integer, create the names of the states using\n            the given prefix (default = \'y\').  The names of the input will be\n            of the form `prefix[i]`.\n\n        """"""\n        self.noutputs, self.output_index = \\\n            self._process_signal_list(outputs, prefix=prefix)\n\n    def set_states(self, states, prefix=\'x\'):\n        """"""Set the number/names of the system states.\n\n        Parameters\n        ----------\n        states : int, list of str, or None\n            Description of the system states.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `u[i]` (where the prefix `u` can be changed using the\n            optional prefix parameter).\n        prefix : string, optional\n            If `states` is an integer, create the names of the states using\n            the given prefix (default = \'x\').  The names of the input will be\n            of the form `prefix[i]`.\n\n        """"""\n        self.nstates, self.state_index = \\\n            self._process_signal_list(states, prefix=prefix)\n\n    def find_input(self, name):\n        """"""Find the index for an input given its name (`None` if not found)""""""\n        return self.input_index.get(name, None)\n\n    def find_output(self, name):\n        """"""Find the index for an output given its name (`None` if not found)""""""\n        return self.output_index.get(name, None)\n\n    def find_state(self, name):\n        """"""Find the index for a state given its name (`None` if not found)""""""\n        return self.state_index.get(name, None)\n\n    def feedback(self, other=1, sign=-1, params={}):\n        """"""Feedback interconnection between two input/output systems\n\n        Parameters\n        ----------\n        sys1: InputOutputSystem\n            The primary process.\n        sys2: InputOutputSystem\n            The feedback process (often a feedback controller).\n        sign: scalar, optional\n            The sign of feedback.  `sign` = -1 indicates negative feedback,\n            and `sign` = 1 indicates positive feedback.  `sign` is an optional\n            argument; it assumes a value of -1 if not specified.\n\n        Returns\n        -------\n        out: InputOutputSystem\n\n        Raises\n        ------\n        ValueError\n            if the inputs, outputs, or timebases of the systems are\n            incompatible.\n\n        """"""\n        # TODO: add conversion to I/O system when needed\n        if not isinstance(other, InputOutputSystem):\n            raise TypeError(""Feedback around I/O system must be I/O system."")\n        elif isinstance(self, StateSpace) and isinstance(other, StateSpace):\n            # Special case: maintain linear systems structure\n            new_ss_sys = StateSpace.feedback(self, other, sign=sign)\n            # TODO: set input and output names\n            new_io_sys = LinearIOSystem(new_ss_sys)\n\n            return new_io_sys\n\n        # Make sure systems can be interconnected\n        if self.noutputs != other.ninputs or other.noutputs != self.ninputs:\n            raise ValueError(""Can\'t connect systems with incompatible ""\n                             ""inputs and outputs"")\n\n        # Make sure timebases are compatible\n        dt = _find_timebase(self, other)\n        if dt is False:\n            raise ValueError(""System timebases are not compabile"")\n\n        # Return the series interconnection between the systems\n        newsys = InterconnectedSystem((self, other), params=params, dt=dt)\n\n        #  Set up the connecton map\n        newsys.set_connect_map(np.block(\n            [[np.zeros((self.ninputs, self.noutputs)),\n              sign * np.eye(self.ninputs, other.noutputs)],\n             [np.eye(other.ninputs, self.noutputs),\n              np.zeros((other.ninputs, other.noutputs))]]\n        ))\n\n        # Set up the input map\n        newsys.set_input_map(np.concatenate(\n            (np.eye(self.ninputs), np.zeros((other.ninputs, self.ninputs))),\n            axis=0))\n        # TODO: set up input names\n\n        # Set up the output map\n        newsys.set_output_map(np.concatenate(\n            (np.eye(self.noutputs), np.zeros((self.noutputs, other.noutputs))),\n            axis=1))\n        # TODO: set up output names\n\n        # Return the newly created system\n        return newsys\n\n    def linearize(self, x0, u0, t=0, params={}, eps=1e-6):\n        """"""Linearize an input/output system at a given state and input.\n\n        Return the linearization of an input/output system at a given state\n        and input value as a StateSpace system.  See\n        :func:`~control.linearize` for complete documentation.\n\n        """"""\n        #\n        # If the linearization is not defined by the subclass, perform a\n        # numerical linearization use the `_rhs()` and `_out()` member\n        # functions.\n        #\n\n        # Figure out dimensions if they were not specified.\n        nstates = _find_size(self.nstates, x0)\n        ninputs = _find_size(self.ninputs, u0)\n\n        # Convert x0, u0 to arrays, if needed\n        if np.isscalar(x0): x0 = np.ones((nstates,)) * x0\n        if np.isscalar(u0): u0 = np.ones((ninputs,)) * u0\n\n        # Compute number of outputs by evaluating the output function\n        noutputs = _find_size(self.noutputs, self._out(t, x0, u0))\n\n        # Update the current parameters\n        self._update_params(params)\n\n        # Compute the nominal value of the update law and output\n        F0 = self._rhs(t, x0, u0)\n        H0 = self._out(t, x0, u0)\n\n        # Create empty matrices that we can fill up with linearizations\n        A = np.zeros((nstates, nstates))        # Dynamics matrix\n        B = np.zeros((nstates, ninputs))        # Input matrix\n        C = np.zeros((noutputs, nstates))       # Output matrix\n        D = np.zeros((noutputs, ninputs))       # Direct term\n\n        # Perturb each of the state variables and compute linearization\n        for i in range(nstates):\n            dx = np.zeros((nstates,))\n            dx[i] = eps\n            A[:, i] = (self._rhs(t, x0 + dx, u0) - F0) / eps\n            C[:, i] = (self._out(t, x0 + dx, u0) - H0) / eps\n\n            # Perturb each of the input variables and compute linearization\n        for i in range(ninputs):\n            du = np.zeros((ninputs,))\n            du[i] = eps\n            B[:, i] = (self._rhs(t, x0, u0 + du) - F0) / eps\n            D[:, i] = (self._out(t, x0, u0 + du) - H0) / eps\n\n        # Create the state space system\n        linsys = StateSpace(A, B, C, D, self.dt, remove_useless=False)\n        return LinearIOSystem(linsys)\n\n    def copy(self):\n        """"""Make a copy of an input/output system.""""""\n        return copy.copy(self)\n\n\nclass LinearIOSystem(InputOutputSystem, StateSpace):\n    """"""Input/output representation of a linear (state space) system.\n\n    This class is used to implementat a system that is a linear state\n    space system (defined by the StateSpace system object).\n\n    """"""\n    def __init__(self, linsys, inputs=None, outputs=None, states=None,\n                 name=None):\n        """"""Create an I/O system from a state space linear system.\n\n        Converts a :class:`~control.StateSpace` system into an\n        :class:`~control.InputOutputSystem` with the same inputs, outputs, and\n        states.  The new system can be a continuous or discrete time system\n\n        Parameters\n        ----------\n        linsys : StateSpace\n            LTI StateSpace system to be converted\n        inputs : int, list of str or None, optional\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If\n            this parameter is not given or given as `None`, the relevant\n            quantity will be determined when possible based on other\n            information provided to functions using the system.\n        outputs : int, list of str or None, optional\n            Description of the system outputs.  Same format as `inputs`.\n        states : int, list of str, or None, optional\n            Description of the system states.  Same format as `inputs`.\n        dt : None, True or float, optional\n            System timebase.  None (default) indicates continuous\n            time, True indicates discrete time with undefined sampling\n            time, positive number is discrete time with specified\n            sampling time.\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n        name : string, optional\n            System name (used for specifying signals)\n\n        Returns\n        -------\n        iosys : LinearIOSystem\n            Linear system represented as an input/output system\n\n        """"""\n        if not isinstance(linsys, StateSpace):\n            raise TypeError(""Linear I/O system must be a state space object"")\n\n        # Create the I/O system object\n        super(LinearIOSystem, self).__init__(\n            inputs=linsys.inputs, outputs=linsys.outputs,\n            states=linsys.states, params={}, dt=linsys.dt, name=name)\n\n        # Initalize additional state space variables\n        StateSpace.__init__(self, linsys, remove_useless=False)\n\n        # Process input, output, state lists, if given\n        # Make sure they match the size of the linear system\n        ninputs, self.input_index = self._process_signal_list(\n            inputs if inputs is not None else linsys.inputs, prefix=\'u\')\n        if ninputs is not None and linsys.inputs != ninputs:\n            raise ValueError(""Wrong number/type of inputs given."")\n        noutputs, self.output_index = self._process_signal_list(\n            outputs if outputs is not None else linsys.outputs, prefix=\'y\')\n        if noutputs is not None and linsys.outputs != noutputs:\n            raise ValueError(""Wrong number/type of outputs given."")\n        nstates, self.state_index = self._process_signal_list(\n            states if states is not None else linsys.states, prefix=\'x\')\n        if nstates is not None and linsys.states != nstates:\n            raise ValueError(""Wrong number/type of states given."")\n\n    def _update_params(self, params={}, warning=True):\n        # Parameters not supported; issue a warning\n        if params and warning:\n            warn(""Parameters passed to LinearIOSystems are ignored."")\n\n    def _rhs(self, t, x, u):\n        # Convert input to column vector and then change output to 1D array\n        xdot = np.dot(self.A, np.reshape(x, (-1, 1))) \\\n            + np.dot(self.B, np.reshape(u, (-1, 1)))\n        return np.array(xdot).reshape((-1,))\n\n    def _out(self, t, x, u):\n        y = self.C * np.reshape(x, (-1, 1)) + self.D * np.reshape(u, (-1, 1))\n        return np.array(y).reshape((self.noutputs,))\n\n\nclass NonlinearIOSystem(InputOutputSystem):\n    """"""Nonlinear I/O system.\n\n    This class is used to implement a system that is a nonlinear state\n    space system (defined by and update function and an output function).\n\n    """"""\n    def __init__(self, updfcn, outfcn=None, inputs=None, outputs=None,\n                 states=None, params={}, dt=None, name=None):\n        """"""Create a nonlinear I/O system given update and output functions.\n\n        Creates an `InputOutputSystem` for a nonlinear system by specifying a\n        state update function and an output function.  The new system can be a\n        continuous or discrete time system (Note: discrete-time systems not\n        yet supported by most function.)\n\n        Parameters\n        ----------\n        updfcn : callable\n            Function returning the state update function\n\n                `updfcn(t, x, u[, param]) -> array`\n\n            where `x` is a 1-D array with shape (nstates,), `u` is a 1-D array\n            with shape (ninputs,), `t` is a float representing the currrent\n            time, and `param` is an optional dict containing the values of\n            parameters used by the function.\n\n        outfcn : callable\n            Function returning the output at the given state\n\n                `outfcn(t, x, u[, param]) -> array`\n\n            where the arguments are the same as for `upfcn`.\n\n        inputs : int, list of str or None, optional\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If\n            this parameter is not given or given as `None`, the relevant\n            quantity will be determined when possible based on other\n            information provided to functions using the system.\n\n        outputs : int, list of str or None, optional\n            Description of the system outputs.  Same format as `inputs`.\n\n        states : int, list of str, or None, optional\n            Description of the system states.  Same format as `inputs`.\n\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n\n        dt : timebase, optional\n            The timebase for the system, used to specify whether the system is\n            operating in continuous or discrete time.  It can have the\n            following values:\n\n            * dt = None       No timebase specified\n            * dt = 0          Continuous time system\n            * dt > 0          Discrete time system with sampling time dt\n            * dt = True       Discrete time with unspecified sampling time\n\n        name : string, optional\n            System name (used for specifying signals).\n\n        Returns\n        -------\n        iosys : NonlinearIOSystem\n            Nonlinear system represented as an input/output system.\n\n        """"""\n        # Store the update and output functions\n        self.updfcn = updfcn\n        self.outfcn = outfcn\n\n        # Initialize the rest of the structure\n        super(NonlinearIOSystem, self).__init__(\n            inputs=inputs, outputs=outputs, states=states,\n            params=params, dt=dt, name=name\n        )\n\n        # Check to make sure arguments are consistent\n        if updfcn is None:\n            if self.nstates is None:\n                self.nstates = 0\n            else:\n                raise ValueError(""States specified but no update function ""\n                                 ""given."")\n        if outfcn is None:\n            # No output function specified => outputs = states\n            if self.noutputs is None and self.nstates is not None:\n                self.noutputs = self.nstates\n            elif self.noutputs is not None and self.noutputs == self.nstates:\n                # Number of outputs = number of states => all is OK\n                pass\n            elif self.noutputs is not None and self.noutputs != 0:\n                raise ValueError(""Outputs specified but no output function ""\n                                 ""(and nstates not known)."")\n\n        # Initialize current parameters to default parameters\n        self._current_params = params.copy()\n\n    def _update_params(self, params, warning=False):\n        # Update the current parameter values\n        self._current_params = self.params.copy()\n        self._current_params.update(params)\n\n    def _rhs(self, t, x, u):\n        xdot = self.updfcn(t, x, u, self._current_params) \\\n            if self.updfcn is not None else []\n        return np.array(xdot).reshape((-1,))\n\n    def _out(self, t, x, u):\n        y = self.outfcn(t, x, u, self._current_params) \\\n            if self.outfcn is not None else x\n        return np.array(y).reshape((-1,))\n\n\nclass InterconnectedSystem(InputOutputSystem):\n    """"""Interconnection of a set of input/output systems.\n\n    This class is used to implement a system that is an interconnection of\n    input/output systems.  The sys consists of a collection of subsystems\n    whose inputs and outputs are connected via a connection map.  The overall\n    system inputs and outputs are subsets of the subsystem inputs and outputs.\n\n    """"""\n    def __init__(self, syslist, connections=[], inplist=[], outlist=[],\n                 inputs=None, outputs=None, states=None,\n                 params={}, dt=None, name=None):\n        """"""Create an I/O system from a list of systems + connection info.\n\n        The InterconnectedSystem class is used to represent an input/output\n        system that consists of an interconnection between a set of subystems.\n        The outputs of each subsystem can be summed together to to provide\n        inputs to other subsystems.  The overall system inputs and outputs can\n        be any subset of subsystem inputs and outputs.\n\n        Parameters\n        ----------\n        syslist : array_like of InputOutputSystems\n            The list of input/output systems to be connected\n\n        connections : tuple of connection specifications, optional\n            Description of the internal connections between the subsystems.\n            Each element of the tuple describes an input to one of the\n            subsystems.  The entries are are of the form:\n\n                (input-spec, output-spec1, output-spec2, ...)\n\n            The input-spec should be a tuple of the form `(subsys_i, inp_j)`\n            where `subsys_i` is the index into `syslist` and `inp_j` is the\n            index into the input vector for the subsystem.  If `subsys_i` has\n            a single input, then the subsystem index `subsys_i` can be listed\n            as the input-spec.  If systems and signals are given names, then\n            the form \'sys.sig\' or (\'sys\', \'sig\') are also recognized.\n\n            Each output-spec should be a tuple of the form `(subsys_i, out_j,\n            gain)`.  The input will be constructed by summing the listed\n            outputs after multiplying by the gain term.  If the gain term is\n            omitted, it is assumed to be 1.  If the system has a single\n            output, then the subsystem index `subsys_i` can be listed as the\n            input-spec.  If systems and signals are given names, then the form\n            \'sys.sig\', (\'sys\', \'sig\') or (\'sys\', \'sig\', gain) are also\n            recognized, and the special form \'-sys.sig\' can be used to specify\n            a signal with gain -1.\n\n            If omitted, the connection map (matrix) can be specified using the\n            :func:`~control.InterconnectedSystem.set_connect_map` method.\n\n        inplist : tuple of input specifications, optional\n            List of specifications for how the inputs for the overall system\n            are mapped to the subsystem inputs.  The input specification is\n            the same as the form defined in the connection specification.\n            Each system input is added to the input for the listed subsystem.\n\n            If omitted, the input map can be specified using the\n            `set_input_map` method.\n\n        outlist : tuple of output specifications, optional\n            List of specifications for how the outputs for the subsystems are\n            mapped to overall system outputs.  The output specification is the\n            same as the form defined in the connection specification\n            (including the optional gain term).  Numbered outputs must be\n            chosen from the list of subsystem outputs, but named outputs can\n            also be contained in the list of subsystem inputs.\n\n            If omitted, the output map can be specified using the\n            `set_output_map` method.\n\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n\n        dt : timebase, optional\n            The timebase for the system, used to specify whether the system is\n            operating in continuous or discrete time.  It can have the\n            following values:\n\n            * dt = None       No timebase specified\n            * dt = 0          Continuous time system\n            * dt > 0          Discrete time system with sampling time dt\n            * dt = True       Discrete time with unspecified sampling time\n\n        name : string, optional\n            System name (used for specifying signals).\n\n        """"""\n        # Convert input and output names to lists if they aren\'t already\n        if not isinstance(inplist, (list, tuple)): inplist = [inplist]\n        if not isinstance(outlist, (list, tuple)): outlist = [outlist]\n\n        # Check to make sure all systems are consistent\n        self.syslist = syslist\n        self.syslist_index = {}\n        dt = None\n        nstates = 0; self.state_offset = []\n        ninputs = 0; self.input_offset = []\n        noutputs = 0; self.output_offset = []\n        system_count = 0\n        for sys in syslist:\n            # Make sure time bases are consistent\n            if dt is None and sys.dt is not None:\n                # Timebase was not specified; set to match this system\n                dt = sys.dt\n            elif dt != sys.dt:\n                raise TypeError(""System timebases are not compatible"")\n\n            # Make sure number of inputs, outputs, states is given\n            if sys.ninputs is None or sys.noutputs is None or \\\n               sys.nstates is None:\n                raise TypeError(""System \'%s\' must define number of inputs, ""\n                                ""outputs, states in order to be connected"" %\n                                sys)\n\n            # Keep track of the offsets into the states, inputs, outputs\n            self.input_offset.append(ninputs)\n            self.output_offset.append(noutputs)\n            self.state_offset.append(nstates)\n\n            # Keep track of the total number of states, inputs, outputs\n            nstates += sys.nstates\n            ninputs += sys.ninputs\n            noutputs += sys.noutputs\n\n            # Store the index to the system for later retrieval\n            # TODO: look for duplicated system names\n            self.syslist_index[sys.name] = system_count\n            system_count += 1\n\n        # Check for duplicate systems or duplicate names\n        sysobj_list = []\n        sysname_list = []\n        for sys in syslist:\n            if sys in sysobj_list:\n                warn(""Duplicate object found in system list: %s"" % str(sys))\n            elif sys.name is not None and sys.name in sysname_list:\n                warn(""Duplicate name found in system list: %s"" % sys.name)\n            sysobj_list.append(sys)\n            sysname_list.append(sys.name)\n\n        # Create the I/O system\n        super(InterconnectedSystem, self).__init__(\n            inputs=len(inplist), outputs=len(outlist),\n            states=nstates, params=params, dt=dt)\n\n        # If input or output list was specified, update it\n        nsignals, self.input_index = \\\n            self._process_signal_list(inputs, prefix=\'u\')\n        if nsignals is not None and len(inplist) != nsignals:\n            raise ValueError(""Wrong number/type of inputs given."")\n        nsignals, self.output_index = \\\n            self._process_signal_list(outputs, prefix=\'y\')\n        if nsignals is not None and len(outlist) != nsignals:\n            raise ValueError(""Wrong number/type of outputs given."")\n\n        # Convert the list of interconnections to a connection map (matrix)\n        self.connect_map = np.zeros((ninputs, noutputs))\n        for connection in connections:\n            input_index = self._parse_input_spec(connection[0])\n            for output_spec in connection[1:]:\n                output_index, gain = self._parse_output_spec(output_spec)\n                self.connect_map[input_index, output_index] = gain\n\n        # Convert the input list to a matrix: maps system to subsystems\n        self.input_map = np.zeros((ninputs, self.ninputs))\n        for index, inpspec in enumerate(inplist):\n            if isinstance(inpspec, (int, str, tuple)): inpspec = [inpspec]\n            for spec in inpspec:\n                self.input_map[self._parse_input_spec(spec), index] = 1\n\n        # Convert the output list to a matrix: maps subsystems to system\n        self.output_map = np.zeros((self.noutputs, noutputs + ninputs))\n        for index in range(len(outlist)):\n            ylist_index, gain = self._parse_output_spec(outlist[index])\n            self.output_map[index, ylist_index] = gain\n\n        # Save the parameters for the system\n        self.params = params.copy()\n\n    def __add__(self, sys):\n        # TODO: implement special processing to maintain flat structure\n        return super(InterconnectedSystem, self).__add__(sys)\n\n    def __radd__(self, sys):\n        # TODO: implement special processing to maintain flat structure\n        return super(InterconnectedSystem, self).__radd__(sys)\n\n    def __mul__(self, sys):\n        # TODO: implement special processing to maintain flat structure\n        return super(InterconnectedSystem, self).__mul__(sys)\n\n    def __rmul__(self, sys):\n        # TODO: implement special processing to maintain flat structure\n        return super(InterconnectedSystem, self).__rmul__(sys)\n\n    def __neg__(self):\n        # TODO: implement special processing to maintain flat structure\n        return super(InterconnectedSystem, self).__neg__()\n\n    def _update_params(self, params, warning=False):\n        for sys in self.syslist:\n            local = sys.params.copy()   # start with system parameters\n            local.update(self.params)   # update with global params\n            local.update(params)        # update with locally passed parameters\n            sys._update_params(local, warning=warning)\n\n    def _rhs(self, t, x, u):\n        # Make sure state and input are vectors\n        x = np.array(x, ndmin=1)\n        u = np.array(u, ndmin=1)\n\n        # Compute the input and output vectors\n        ulist, ylist = self._compute_static_io(t, x, u)\n\n        # Go through each system and update the right hand side for that system\n        xdot = np.zeros((self.nstates,))        # Array to hold results\n        state_index = 0; input_index = 0        # Start at the beginning\n        for sys in self.syslist:\n            # Update the right hand side for this subsystem\n            if sys.nstates != 0:\n                xdot[state_index:state_index + sys.nstates] = sys._rhs(\n                    t, x[state_index:state_index + sys.nstates],\n                    ulist[input_index:input_index + sys.ninputs])\n\n            # Update the state and input index counters\n            state_index += sys.nstates\n            input_index += sys.ninputs\n\n        return xdot\n\n    def _out(self, t, x, u):\n        # Make sure state and input are vectors\n        x = np.array(x, ndmin=1)\n        u = np.array(u, ndmin=1)\n\n        # Compute the input and output vectors\n        ulist, ylist = self._compute_static_io(t, x, u)\n\n        # Make the full set of subsystem outputs to system output\n        return np.dot(self.output_map, ylist)\n\n    def _compute_static_io(self, t, x, u):\n        # Figure out the total number of inputs and outputs\n        (ninputs, noutputs) = self.connect_map.shape\n\n        #\n        # Get the outputs and inputs at the current system state\n        #\n\n        # Initialize the lists used to keep track of internal signals\n        ulist = np.dot(self.input_map, u)\n        ylist = np.zeros((noutputs + ninputs,))\n\n        # To allow for feedthrough terms, iterate multiple times to allow\n        # feedthrough elements to propagate.  For n systems, we could need to\n        # cycle through n+1 times before reaching steady state\n        # TODO (later): see if there is a more efficient way to compute\n        cycle_count = len(self.syslist) + 1\n        while cycle_count > 0:\n            state_index = 0; input_index = 0; output_index = 0\n            for sys in self.syslist:\n                # Compute outputs for each system from current state\n                ysys = sys._out(\n                    t, x[state_index:state_index + sys.nstates],\n                    ulist[input_index:input_index + sys.ninputs])\n\n                # Store the outputs at the start of ylist\n                ylist[output_index:output_index + sys.noutputs] = \\\n                    ysys.reshape((-1,))\n\n                # Store the input in the second part of ylist\n                ylist[noutputs + input_index:\n                    noutputs + input_index + sys.ninputs] = \\\n                    ulist[input_index:input_index + sys.ninputs]\n\n                # Increment the index pointers\n                state_index += sys.nstates\n                input_index += sys.ninputs\n                output_index += sys.noutputs\n\n            # Compute inputs based on connection map\n            new_ulist = np.dot(self.connect_map, ylist[:noutputs]) \\\n                + np.dot(self.input_map, u)\n\n            # Check to see if any of the inputs changed\n            if (ulist == new_ulist).all():\n                break\n            else:\n                ulist = new_ulist\n\n            # Decrease the cycle counter\n            cycle_count -= 1\n\n        # Make sure that we stopped before detecting an algebraic loop\n        if cycle_count == 0:\n            raise RuntimeError(""Algebraic loop detected."")\n\n        return ulist, ylist\n\n    def _parse_input_spec(self, spec):\n        """"""Parse an input specification and returns the index\n\n        This function parses a specification of an input of an interconnected\n        system component and returns the index of that input in the internal\n        input vector.  Input specifications are of one of the following forms:\n\n            i               first input for the ith system\n            (i,)            first input for the ith system\n            (i, j)          jth input for the ith system\n            \'sys.sig\'       signal \'sig\' in subsys \'sys\'\n            (\'sys\', \'sig\')  signal \'sig\' in subsys \'sys\'\n\n        The function returns an index into the input vector array and\n        the gain to use for that input.\n\n        """"""\n        # Parse the signal that we received\n        subsys_index, input_index = self._parse_signal(spec, \'input\')\n\n        # Return the index into the input vector list (ylist)\n        return self.input_offset[subsys_index] + input_index\n\n    def _parse_output_spec(self, spec):\n        """"""Parse an output specification and returns the index and gain\n\n        This function parses a specification of an output of an\n        interconnected system component and returns the index of that\n        output in the internal output vector (ylist).  Output specifications\n        are of one of the following forms:\n\n            i                       first output for the ith system\n            (i,)                    first output for the ith system\n            (i, j)                  jth output for the ith system\n            (i, j, gain)            jth output for the ith system with gain\n            \'sys.sig\'               signal \'sig\' in subsys \'sys\'\n            \'-sys.sig\'              signal \'sig\' in subsys \'sys\' with gain -1\n            (\'sys\', \'sig\', gain)    signal \'sig\' in subsys \'sys\' with gain\n\n        If the gain is not specified, it is taken to be 1.  Numbered outputs\n        must be chosen from the list of subsystem outputs, but named outputs\n        can also be contained in the list of subsystem inputs.\n\n        The function returns an index into the output vector array and\n        the gain to use for that output.\n\n        """"""\n        gain = 1                # Default gain\n\n        # Check for special forms of the input\n        if isinstance(spec, tuple) and len(spec) == 3:\n            gain = spec[2]\n            spec = spec[:2]\n        elif isinstance(spec, str) and spec[0] == \'-\':\n            gain = -1\n            spec = spec[1:]\n\n        # Parse the rest of the spec with standard signal parsing routine\n        try:\n            # Start by looking in the set of subsystem outputs\n            subsys_index, output_index = self._parse_signal(spec, \'output\')\n\n            # Return the index into the input vector list (ylist)\n            return self.output_offset[subsys_index] + output_index, gain\n\n        except ValueError:\n            # Try looking in the set of subsystem *inputs*\n            subsys_index, input_index = self._parse_signal(\n                spec, \'input or output\', dictname=\'input_index\')\n\n            # Return the index into the input vector list (ylist)\n            noutputs = sum(sys.noutputs for sys in self.syslist)\n            return noutputs + \\\n                self.input_offset[subsys_index] + input_index, gain\n\n    def _parse_signal(self, spec, signame=\'input\', dictname=None):\n        """"""Parse a signal specification, returning system and signal index.\n\n        Signal specifications are of one of the following forms:\n\n            i               system_index = i, signal_index = 0\n            (i,)            system_index = i, signal_index = 0\n            (i, j)          system_index = i, signal_index = j\n            \'sys.sig\'       signal \'sig\' in subsys \'sys\'\n            (\'sys\', \'sig\')  signal \'sig\' in subsys \'sys\'\n            (\'sys\', j)      signal_index j in subsys \'sys\'\n\n        The function returns an index into the input vector array and\n        the gain to use for that input.\n        """"""\n        import re\n\n        # Process cases where we are given indices as integers\n        if isinstance(spec, int):\n            return spec, 0\n\n        elif isinstance(spec, tuple) and len(spec) == 1 \\\n             and isinstance(spec[0], int):\n            return spec[0], 0\n\n        elif isinstance(spec, tuple) and len(spec) == 2 \\\n             and all([isinstance(index, int) for index in spec]):\n            return spec\n\n        # Figure out the name of the dictionary to use\n        if dictname is None: dictname = signame + \'_index\'\n\n        if isinstance(spec, str):\n            # If we got a dotted string, break up into pieces\n            namelist = re.split(\'\\.\', spec)\n\n            # For now, only allow signal level of system name\n            # TODO: expand to allow nested signal names\n            if len(namelist) != 2:\n                raise ValueError(""Couldn\'t parse %s signal reference \'%s\'.""\n                                 % (signame, spec))\n\n            system_index = self._find_system(namelist[0])\n            if system_index is None:\n                raise ValueError(""Couldn\'t find system \'%s\'."" % namelist[0])\n\n            signal_index = self.syslist[system_index]._find_signal(\n                namelist[1], getattr(self.syslist[system_index], dictname))\n            if signal_index is None:\n                raise ValueError(""Couldn\'t find %s signal \'%s.%s\'."" %\n                                 (signame, namelist[0], namelist[1]))\n\n            return system_index, signal_index\n\n        # Handle the (\'sys\', \'sig\'), (i, j), and mixed cases\n        elif isinstance(spec, tuple) and len(spec) == 2 and \\\n             isinstance(spec[0], (str, int)) and \\\n             isinstance(spec[1], (str, int)):\n            if isinstance(spec[0], int):\n                system_index = spec[0]\n                if system_index < 0 or system_index > len(self.syslist):\n                    system_index = None\n            else:\n                system_index = self._find_system(spec[0])\n            if system_index is None:\n                raise ValueError(""Couldn\'t find system %s."" % spec[0])\n\n            if isinstance(spec[1], int):\n                signal_index = spec[1]\n                # TODO (later): check against max length of appropriate list?\n                if signal_index < 0:\n                    system_index = None\n            else:\n                signal_index = self.syslist[system_index]._find_signal(\n                    spec[1], getattr(self.syslist[system_index], dictname))\n            if signal_index is None:\n                raise ValueError(""Couldn\'t find signal %s.%s."" % tuple(spec))\n\n            return system_index, signal_index\n\n        else:\n            raise ValueError(""Couldn\'t parse signal reference %s."" % str(spec))\n\n    def _find_system(self, name):\n        return self.syslist_index.get(name, None)\n\n    def set_connect_map(self, connect_map):\n        """"""Set the connection map for an interconnected I/O system.\n\n        Parameters\n        ----------\n        connect_map : 2D array\n             Specify the matrix that will be used to multiply the vector of\n             subsystem outputs to obtain the vector of subsystem inputs.\n\n        """"""\n        # Make sure the connection map is the right size\n        if connect_map.shape != self.connect_map.shape:\n            ValueError(""Connection map is not the right shape"")\n        self.connect_map = connect_map\n\n    def set_input_map(self, input_map):\n        """"""Set the input map for an interconnected I/O system.\n\n        Parameters\n        ----------\n        input_map : 2D array\n             Specify the matrix that will be used to multiply the vector of\n             system inputs to obtain the vector of subsystem inputs.  These\n             values are added to the inputs specified in the connection map.\n\n        """"""\n        # Figure out the number of internal inputs\n        ninputs = sum(sys.ninputs for sys in self.syslist)\n\n        # Make sure the input map is the right size\n        if input_map.shape[0] != ninputs:\n            ValueError(""Input map is not the right shape"")\n        self.input_map = input_map\n        self.ninputs = input_map.shape[1]\n\n    def set_output_map(self, output_map):\n        """"""Set the output map for an interconnected I/O system.\n\n        Parameters\n        ----------\n        output_map : 2D array\n             Specify the matrix that will be used to multiply the vector of\n             subsystem outputs to obtain the vector of system outputs.\n        """"""\n        # Figure out the number of internal inputs and outputs\n        ninputs = sum(sys.ninputs for sys in self.syslist)\n        noutputs = sum(sys.noutputs for sys in self.syslist)\n\n        # Make sure the output map is the right size\n        if output_map.shape[1] == noutputs:\n            # For backward compatibility, add zeros to the end of the array\n            output_map = np.concatenate(\n                (output_map,\n                 np.zeros((output_map.shape[0], ninputs))),\n                axis=1)\n\n        if output_map.shape[1] != noutputs + ninputs:\n            ValueError(""Output map is not the right shape"")\n        self.output_map = output_map\n        self.noutputs = output_map.shape[0]\n\n\ndef input_output_response(sys, T, U=0., X0=0, params={}, method=\'RK45\',\n                          return_x=False, squeeze=True):\n\n    """"""Compute the output response of a system to a given input.\n\n    Simulate a dynamical system with a given input and return its output\n    and state values.\n\n    Parameters\n    ----------\n    sys: InputOutputSystem\n        Input/output system to simulate.\n    T: array-like\n        Time steps at which the input is defined; values must be evenly spaced.\n    U: array-like or number, optional\n        Input array giving input at each time `T` (default = 0).\n    X0: array-like or number, optional\n        Initial condition (default = 0).\n    return_x : bool, optional\n        If True, return the values of the state at each time (default = False).\n    squeeze : bool, optional\n        If True (default), squeeze unused dimensions out of the output\n        response.  In particular, for a single output system, return a\n        vector of shape (nsteps) instead of (nsteps, 1).\n\n    Returns\n    -------\n    T : array\n        Time values of the output.\n    yout : array\n        Response of the system.\n    xout : array\n        Time evolution of the state vector (if return_x=True)\n\n    Raises\n    ------\n    TypeError\n        If the system is not an input/output system.\n    ValueError\n        If time step does not match sampling time (for discrete time systems)\n\n    """"""\n    # Sanity checking on the input\n    if not isinstance(sys, InputOutputSystem):\n        raise TypeError(""System of type "", type(sys), "" not valid"")\n\n    # Compute the time interval and number of steps\n    T0, Tf = T[0], T[-1]\n    n_steps = len(T)\n\n    # Check and convert the input, if needed\n    # TODO: improve MIMO ninputs check (choose from U)\n    if sys.ninputs is None or sys.ninputs == 1:\n        legal_shapes = [(n_steps,), (1, n_steps)]\n    else:\n        legal_shapes = [(sys.ninputs, n_steps)]\n    U = _check_convert_array(U, legal_shapes,\n                             \'Parameter ``U``: \', squeeze=False)\n\n    # Check to make sure this is not a static function\n    nstates = _find_size(sys.nstates, X0)\n    if nstates == 0:\n        # No states => map input to output\n        u = U[0] if len(U.shape) == 1 else U[:, 0]\n        y = np.zeros((np.shape(sys._out(T[0], X0, u))[0], len(T)))\n        for i in range(len(T)):\n            u = U[i] if len(U.shape) == 1 else U[:, i]\n            y[:, i] = sys._out(T[i], [], u)\n        if (squeeze): y = np.squeeze(y)\n        if return_x:\n            return T, y, []\n        else:\n            return T, y\n\n    # create X0 if not given, test if X0 has correct shape\n    X0 = _check_convert_array(X0, [(nstates,), (nstates, 1)],\n                              \'Parameter ``X0``: \', squeeze=True)\n\n    # Update the parameter values\n    sys._update_params(params)\n\n    # Create a lambda function for the right hand side\n    u = sp.interpolate.interp1d(T, U, fill_value=""extrapolate"")\n    def ivp_rhs(t, x): return sys._rhs(t, x, u(t))\n\n    # Perform the simulation\n    if isctime(sys):\n        if not hasattr(sp.integrate, \'solve_ivp\'):\n            raise NameError(""scipy.integrate.solve_ivp not found; ""\n                            ""use SciPy 1.0 or greater"")\n        soln = sp.integrate.solve_ivp(ivp_rhs, (T0, Tf), X0, t_eval=T,\n                                      method=method, vectorized=False)\n\n        # Compute the output associated with the state (and use sys.out to\n        # figure out the number of outputs just in case it wasn\'t specified)\n        u = U[0] if len(U.shape) == 1 else U[:, 0]\n        y = np.zeros((np.shape(sys._out(T[0], X0, u))[0], len(T)))\n        for i in range(len(T)):\n            u = U[i] if len(U.shape) == 1 else U[:, i]\n            y[:, i] = sys._out(T[i], soln.y[:, i], u)\n\n    elif isdtime(sys):\n        # Make sure the time vector is uniformly spaced\n        dt = T[1] - T[0]\n        if not np.allclose(T[1:] - T[:-1], dt):\n            raise ValueError(""Parameter ``T``: time values must be ""\n                             ""equally spaced."")\n\n        # Make sure the sample time matches the given time\n        if (sys.dt is not True):\n            # Make sure that the time increment is a multiple of sampling time\n\n            # TODO: add back functionality for undersampling\n            # TODO: this test is brittle if dt =  sys.dt\n            # First make sure that time increment is bigger than sampling time\n            # if dt < sys.dt:\n            #     raise ValueError(""Time steps ``T`` must match sampling time"")\n\n            # Check to make sure sampling time matches time increments\n            if not np.isclose(dt, sys.dt):\n                raise ValueError(""Time steps ``T`` must be equal to ""\n                                 ""sampling time"")\n\n        # Compute the solution\n        soln = sp.optimize.OptimizeResult()\n        soln.t = T                      # Store the time vector directly\n        x = [float(x0) for x0 in X0]    # State vector (store as floats)\n        soln.y = []                     # Solution, following scipy convention\n        y = []                          # System output\n        for i in range(len(T)):\n            # Store the current state and output\n            soln.y.append(x)\n            y.append(sys._out(T[i], x, u(T[i])))\n\n            # Update the state for the next iteration\n            x = sys._rhs(T[i], x, u(T[i]))\n\n        # Convert output to numpy arrays\n        soln.y = np.transpose(np.array(soln.y))\n        y = np.transpose(np.array(y))\n\n        # Mark solution as successful\n        soln.success = True     # No way to fail\n\n    else:                       # Neither ctime or dtime??\n        raise TypeError(""Can\'t determine system type"")\n\n    # Get rid of extra dimensions in the output, of desired\n    if (squeeze): y = np.squeeze(y)\n\n    if return_x:\n        return soln.t, y, soln.y\n    else:\n        return soln.t, y\n\n\ndef find_eqpt(sys, x0, u0=[], y0=None, t=0, params={},\n              iu=None, iy=None, ix=None, idx=None, dx0=None,\n              return_y=False, return_result=False, **kw):\n    """"""Find the equilibrium point for an input/output system.\n\n    Returns the value of an equlibrium point given the initial state and\n    either input value or desired output value for the equilibrium point.\n\n    Parameters\n    ----------\n    x0 : list of initial state values\n        Initial guess for the value of the state near the equilibrium point.\n    u0 : list of input values, optional\n        If `y0` is not specified, sets the equilibrium value of the input.  If\n        `y0` is given, provides an initial guess for the value of the input.\n        Can be omitted if the system does not have any inputs.\n    y0 : list of output values, optional\n        If specified, sets the desired values of the outputs at the\n        equilibrium point.\n    t : float, optional\n        Evaluation time, for time-varying systems\n    params : dict, optional\n        Parameter values for the system.  Passed to the evaluation functions\n        for the system as default values, overriding internal defaults.\n    iu : list of input indices, optional\n        If specified, only the inputs with the given indices will be fixed at\n        the specified values in solving for an equilibrium point.  All other\n        inputs will be varied.  Input indices can be listed in any order.\n    iy : list of output indices, optional\n        If specified, only the outputs with the given indices will be fixed at\n        the specified values in solving for an equilibrium point.  All other\n        outputs will be varied.  Output indices can be listed in any order.\n    ix : list of state indices, optional\n        If specified, states with the given indices will be fixed at the\n        specified values in solving for an equilibrium point.  All other\n        states will be varied.  State indices can be listed in any order.\n    dx0 : list of update values, optional\n        If specified, the value of update map must match the listed value\n        instead of the default value of 0.\n    idx : list of state indices, optional\n        If specified, state updates with the given indices will have their\n        update maps fixed at the values given in `dx0`.  All other update\n        values will be ignored in solving for an equilibrium point.  State\n        indices can be listed in any order.  By default, all updates will be\n        fixed at `dx0` in searching for an equilibrium point.\n    return_y : bool, optional\n        If True, return the value of output at the equilibrium point.\n    return_result : bool, optional\n        If True, return the `result` option from the scipy root function used\n        to compute the equilibrium point.\n\n    Returns\n    -------\n    xeq : array of states\n        Value of the states at the equilibrium point, or `None` if no\n        equilibrium point was found and `return_result` was False.\n    ueq : array of input values\n        Value of the inputs at the equilibrium point, or `None` if no\n        equilibrium point was found and `return_result` was False.\n    yeq : array of output values, optional\n        If `return_y` is True, returns the value of the outputs at the\n        equilibrium point, or `None` if no equilibrium point was found and\n        `return_result` was False.\n    result : scipy root() result object, optional\n        If `return_result` is True, returns the `result` from the scipy root\n        function.\n\n    """"""\n    from scipy.optimize import root\n\n    # Figure out the number of states, inputs, and outputs\n    nstates = _find_size(sys.nstates, x0)\n    ninputs = _find_size(sys.ninputs, u0)\n    noutputs = _find_size(sys.noutputs, y0)\n\n    # Discrete-time not yet supported\n    if isdtime(sys, strict=True):\n        raise NotImplementedError(\n            ""Discrete time systems are not yet supported."")\n\n    # Make sure the input arguments match the sizes of the system\n    if len(x0) != nstates or \\\n       (u0 is not None and len(u0) != ninputs) or \\\n       (y0 is not None and len(y0) != noutputs) or \\\n       (dx0 is not None and len(dx0) != nstates):\n        raise ValueError(""Length of input arguments does not match system."")\n\n    # Update the parameter values\n    sys._update_params(params)\n\n    # Decide what variables to minimize\n    if all([x is None for x in (iu, iy, ix, idx)]):\n        # Special cases: either inputs or outputs are constrained\n        if y0 is None:\n            # Take u0 as fixed and minimize over x\n            # TODO: update to allow discrete time systems\n            def ode_rhs(z): return sys._rhs(t, z, u0)\n            result = root(ode_rhs, x0, **kw)\n            z = (result.x, u0, sys._out(t, result.x, u0))\n        else:\n            # Take y0 as fixed and minimize over x and u\n            def rootfun(z):\n                # Split z into x and u\n                x, u = np.split(z, [nstates])\n                # TODO: update to allow discrete time systems\n                return np.concatenate(\n                    (sys._rhs(t, x, u), sys._out(t, x, u) - y0), axis=0)\n            z0 = np.concatenate((x0, u0), axis=0)   # Put variables together\n            result = root(rootfun, z0, **kw)        # Find the eq point\n            x, u = np.split(result.x, [nstates])    # Split result back in two\n            z = (x, u, sys._out(t, x, u))\n\n    else:\n        # General case: figure out what variables to constrain\n        # Verify the indices we are using are all in range\n        if iu is not None:\n            iu = np.unique(iu)\n            if any([not isinstance(x, int) for x in iu]) or \\\n               (len(iu) > 0 and (min(iu) < 0 or max(iu) >= ninputs)):\n                assert ValueError(""One or more input indices is invalid"")\n        else:\n            iu = []\n\n        if iy is not None:\n            iy = np.unique(iy)\n            if any([not isinstance(x, int) for x in iy]) or \\\n               min(iy) < 0 or max(iy) >= noutputs:\n                assert ValueError(""One or more output indices is invalid"")\n        else:\n            iy = list(range(noutputs))\n\n        if ix is not None:\n            ix = np.unique(ix)\n            if any([not isinstance(x, int) for x in ix]) or \\\n               min(ix) < 0 or max(ix) >= nstates:\n                assert ValueError(""One or more state indices is invalid"")\n        else:\n            ix = []\n\n        if idx is not None:\n            idx = np.unique(idx)\n            if any([not isinstance(x, int) for x in idx]) or \\\n               min(idx) < 0 or max(idx) >= nstates:\n                assert ValueError(""One or more deriv indices is invalid"")\n        else:\n            idx = list(range(nstates))\n\n        # Construct the index lists for mapping variables and constraints\n        #\n        # The mechanism by which we implement the root finding function is to\n        # map the subset of variables we are searching over into the inputs\n        # and states, and then return a function that represents the equations\n        # we are trying to solve.\n        #\n        # To do this, we need to carry out the following operations:\n        #\n        # 1. Given the current values of the free variables (z), map them into\n        #    the portions of the state and input vectors that are not fixed.\n        #\n        # 2. Compute the update and output maps for the input/output system\n        #    and extract the subset of equations that should be equal to zero.\n        #\n        # We perform these functions by computing four sets of index lists:\n        #\n        # * state_vars: indices of states that are allowed to vary\n        # * input_vars: indices of inputs that are allowed to vary\n        # * deriv_vars: indices of derivatives that must be constrained\n        # * output_vars: indices of outputs that must be constrained\n        #\n        # This index lists can all be precomputed based on the `iu`, `iy`,\n        # `ix`, and `idx` lists that were passed as arguments to `find_eqpts`\n        # and were processed above.\n\n        # Get the states and inputs that were not listed as fixed\n        state_vars = np.delete(np.array(range(nstates)), ix)\n        input_vars = np.delete(np.array(range(ninputs)), iu)\n\n        # Set the outputs and derivs that will serve as constraints\n        output_vars = np.array(iy)\n        deriv_vars = np.array(idx)\n\n        # Verify that the number of degrees of freedom all add up correctly\n        num_freedoms = len(state_vars) + len(input_vars)\n        num_constraints = len(output_vars) + len(deriv_vars)\n        if num_constraints != num_freedoms:\n            warn(""Number of constraints (%d) does not match number of degrees ""\n                 ""of freedom (%d).  Results may be meaningless."" %\n                 (num_constraints, num_freedoms))\n\n        # Make copies of the state and input variables to avoid overwriting\n        # and convert to floats (in case ints were used for initial conditions)\n        x = np.array(x0, dtype=float)\n        u = np.array(u0, dtype=float)\n        dx0 = np.array(dx0, dtype=float) if dx0 is not None \\\n            else np.zeros(x.shape)\n\n        # Keep track of the number of states in the set of free variables\n        nstate_vars = len(state_vars)\n        dtime = isdtime(sys, strict=True)\n\n        def rootfun(z):\n            # Map the vector of values into the states and inputs\n            x[state_vars] = z[:nstate_vars]\n            u[input_vars] = z[nstate_vars:]\n\n            # Compute the update and output maps\n            dx = sys._rhs(t, x, u) - dx0\n            if dtime: dx -= x           # TODO: check\n            dy = sys._out(t, x, u) - y0\n\n            # Map the results into the constrained variables\n            return np.concatenate((dx[deriv_vars], dy[output_vars]), axis=0)\n\n        # Set the initial condition for the root finding algorithm\n        z0 = np.concatenate((x[state_vars], u[input_vars]), axis=0)\n\n        # Finally, call the root finding function\n        result = root(rootfun, z0, **kw)\n\n        # Extract out the results and insert into x and u\n        x[state_vars] = result.x[:nstate_vars]\n        u[input_vars] = result.x[nstate_vars:]\n        z = (x, u, sys._out(t, x, u))\n\n    # Return the result based on what the user wants and what we found\n    if not return_y: z = z[0:2]     # Strip y from result if not desired\n    if return_result:\n        # Return whatever we got, along with the result dictionary\n        return z + (result,)\n    elif result.success:\n        # Return the result of the optimization\n        return z\n    else:\n        # Something went wrong, don\'t return anything\n        return (None, None, None) if return_y else (None, None)\n\n\n# Linearize an input/output system\ndef linearize(sys, xeq, ueq=[], t=0, params={}, **kw):\n    """"""Linearize an input/output system at a given state and input.\n\n    This function computes the linearization of an input/output system at a\n    given state and input value and returns a :class:`control.StateSpace`\n    object.  The eavaluation point need not be an equilibrium point.\n\n    Parameters\n    ----------\n    sys : InputOutputSystem\n        The system to be linearized\n    xeq : array\n        The state at which the linearization will be evaluated (does not need\n        to be an equlibrium state).\n    ueq : array\n        The input at which the linearization will be evaluated (does not need\n        to correspond to an equlibrium state).\n    t : float, optional\n        The time at which the linearization will be computed (for time-varying\n        systems).\n    params : dict, optional\n        Parameter values for the systems.  Passed to the evaluation functions\n        for the system as default values, overriding internal defaults.\n\n    Returns\n    -------\n    ss_sys : LinearIOSystem\n        The linearization of the system, as a :class:`~control.LinearIOSystem`\n        object (which is also a :class:`~control.StateSpace` object.\n\n    """"""\n    if not isinstance(sys, InputOutputSystem):\n        raise TypeError(""Can only linearize InputOutputSystem types"")\n    return sys.linearize(xeq, ueq, t=t, params=params, **kw)\n\n\n# Utility function to find the size of a system parameter\ndef _find_size(sysval, vecval):\n    if sysval is not None:\n        return sysval\n    elif hasattr(vecval, \'__len__\'):\n        return len(vecval)\n    elif vecval is None:\n        return 0\n    else:\n        raise ValueError(""Can\'t determine size of system component."")\n\n\n# Convert a state space system into an input/output system (wrapper)\ndef ss2io(*args, **kw): return LinearIOSystem(*args, **kw)\nss2io.__doc__ = LinearIOSystem.__init__.__doc__\n\n\n# Convert a transfer function into an input/output system (wrapper)\ndef tf2io(*args, **kw):\n    """"""Convert a transfer function into an I/O system""""""\n    # TODO: add remaining documentation\n    # Convert the system to a state space system\n    linsys = tf2ss(*args)\n\n    # Now convert the state space system to an I/O system\n    return LinearIOSystem(linsys, **kw)\n'"
External_Libraries/python_control_master/control/lti.py,6,"b'""""""lti.py\n\nThe lti module contains the LTI parent class to the child classes StateSpace\nand TransferFunction.  It is designed for use in the python-control library.\n\nRoutines in this module:\n\nLTI.__init__\nisdtime()\nisctime()\ntimebase()\ntimebaseEqual()\n""""""\n\nimport numpy as np\nfrom numpy import absolute, real\n\n__all__ = [\'issiso\', \'timebase\', \'timebaseEqual\', \'isdtime\', \'isctime\',\n           \'pole\', \'zero\', \'damp\', \'evalfr\', \'freqresp\', \'dcgain\']\n\nclass LTI:\n    """"""LTI is a parent class to linear time-invariant (LTI) system objects.\n\n    LTI is the parent to the StateSpace and TransferFunction child\n    classes. It contains the number of inputs and outputs, and the\n    timebase (dt) for the system.\n\n    The timebase for the system, dt, is used to specify whether the\n    system is operating in continuous or discrete time.  It can have\n    the following values:\n\n      * dt = None       No timebase specified\n      * dt = 0          Continuous time system\n      * dt > 0          Discrete time system with sampling time dt\n      * dt = True       Discrete time system with unspecified sampling time\n\n    When two LTI systems are combined, their timebases much match.  A system\n    with timebase None can be combined with a system having a specified\n    timebase, and the result will have the timebase of the latter system.\n\n    """"""\n\n    def __init__(self, inputs=1, outputs=1, dt=None):\n        """"""Assign the LTI object\'s numbers of inputs and ouputs.""""""\n\n        # Data members common to StateSpace and TransferFunction.\n        self.inputs = inputs\n        self.outputs = outputs\n        self.dt = dt\n\n    def isdtime(self, strict=False):\n        """"""\n        Check to see if a system is a discrete-time system\n\n        Parameters\n        ----------\n        strict: bool, optional\n            If strict is True, make sure that timebase is not None.  Default \n            is False. \n        """"""\n\n        # If no timebase is given, answer depends on strict flag\n        if self.dt == None:\n            return True if not strict else False\n\n        # Look for dt > 0 (also works if dt = True)\n        return self.dt > 0\n\n    def isctime(self, strict=False):\n        """"""\n        Check to see if a system is a continuous-time system\n\n        Parameters\n        ----------\n        sys : LTI system\n            System to be checked\n        strict: bool, optional\n            If strict is True, make sure that timebase is not None.  Default \n            is False. \n        """"""\n        # If no timebase is given, answer depends on strict flag\n        if self.dt is None:\n            return True if not strict else False\n        return self.dt == 0\n\n    def issiso(self):\n        \'\'\'Check to see if a system is single input, single output\'\'\'\n        return self.inputs == 1 and self.outputs == 1\n\n    def damp(self):\n        \'\'\'Natural frequency, damping ratio of system poles\n\n        Returns\n        -------\n        wn : array\n            Natural frequencies for each system pole\n        zeta : array\n            Damping ratio for each system pole\n        poles : array\n            Array of system poles\n        \'\'\'\n        poles = self.pole()\n\n        if isdtime(self, strict=True):\n            splane_poles = np.log(poles)/self.dt\n        else:\n            splane_poles = poles\n        wn = absolute(splane_poles)\n        Z = -real(splane_poles)/wn\n        return wn, Z, poles\n\n    def dcgain(self):\n        """"""Return the zero-frequency gain""""""\n        raise NotImplementedError(""dcgain not implemented for %s objects"" %\n                                  str(self.__class__))\n\n# Test to see if a system is SISO\ndef issiso(sys, strict=False):\n    """"""\n    Check to see if a system is single input, single output\n\n    Parameters\n    ----------\n    sys : LTI system\n        System to be checked\n    strict: bool (default = False)\n        If strict is True, do not treat scalars as SISO\n    """"""\n    if isinstance(sys, (int, float, complex, np.number)) and not strict:\n        return True\n    elif not isinstance(sys, LTI):\n        raise ValueError(""Object is not an LTI system"")\n\n    # Done with the tricky stuff...\n    return sys.issiso()\n\n# Return the timebase (with conversion if unspecified)\ndef timebase(sys, strict=True):\n    """"""Return the timebase for an LTI system\n\n    dt = timebase(sys)\n\n    returns the timebase for a system \'sys\'.  If the strict option is\n    set to False, dt = True will be returned as 1.\n    """"""\n    # System needs to be either a constant or an LTI system\n    if isinstance(sys, (int, float, complex, np.number)):\n        return None\n    elif not isinstance(sys, LTI):\n        raise ValueError(""Timebase not defined"")\n\n    # Return the sample time, with converstion to float if strict is false\n    if (sys.dt == None):\n        return None\n    elif (strict):\n        return float(sys.dt)\n\n    return sys.dt\n\n# Check to see if two timebases are equal\ndef timebaseEqual(sys1, sys2):\n    """"""Check to see if two systems have the same timebase\n\n    timebaseEqual(sys1, sys2)\n\n    returns True if the timebases for the two systems are compatible.  By\n    default, systems with timebase \'None\' are compatible with either\n    discrete or continuous timebase systems.  If two systems have a discrete\n    timebase (dt > 0) then their timebases must be equal.\n    """"""\n\n    if (type(sys1.dt) == bool or type(sys2.dt) == bool):\n        # Make sure both are unspecified discrete timebases\n        return type(sys1.dt) == type(sys2.dt) and sys1.dt == sys2.dt\n    elif (sys1.dt is None or sys2.dt is None):\n        # One or the other is unspecified => the other can be anything\n        return True\n    else:\n        return sys1.dt == sys2.dt\n\n# Find a common timebase between two or more systems\ndef _find_timebase(sys1, *sysn):\n    """"""Find the common timebase between systems, otherwise return False""""""\n\n    # Create a list of systems to check\n    syslist = [sys1]\n    syslist.append(*sysn)\n\n    # Look for a common timebase\n    dt = None\n\n    for sys in syslist:\n        # Make sure time bases are consistent\n        if (dt is None and sys.dt is not None) or \\\n           (dt is True and isdiscrete(sys)):\n            # Timebase was not specified; set to match this system\n            dt = sys.dt\n        elif dt != sys.dt:\n            return False\n    return dt\n\n\n# Check to see if a system is a discrete time system\ndef isdtime(sys, strict=False):\n    """"""\n    Check to see if a system is a discrete time system\n\n    Parameters\n    ----------\n    sys : LTI system\n        System to be checked\n    strict: bool (default = False)\n        If strict is True, make sure that timebase is not None\n    """"""\n\n    # Check to see if this is a constant\n    if isinstance(sys, (int, float, complex, np.number)):\n        # OK as long as strict checking is off\n        return True if not strict else False\n\n    # Check for a transfer function or state-space object\n    if isinstance(sys, LTI):\n        return sys.isdtime(strict)\n\n    # Check to see if object has a dt object\n    if hasattr(sys, \'dt\'):\n        # If no timebase is given, answer depends on strict flag\n        if sys.dt == None:\n            return True if not strict else False\n\n        # Look for dt > 0 (also works if dt = True)\n        return sys.dt > 0\n\n    # Got passed something we don\'t recognize\n    return False\n\n# Check to see if a system is a continuous time system\ndef isctime(sys, strict=False):\n    """"""\n    Check to see if a system is a continuous-time system\n\n    Parameters\n    ----------\n    sys : LTI system\n        System to be checked\n    strict: bool (default = False)\n        If strict is True, make sure that timebase is not None\n    """"""\n\n    # Check to see if this is a constant\n    if isinstance(sys, (int, float, complex, np.number)):\n        # OK as long as strict checking is off\n        return True if not strict else False\n\n    # Check for a transfer function or state space object\n    if isinstance(sys, LTI):\n        return sys.isctime(strict)\n\n    # Check to see if object has a dt object\n    if hasattr(sys, \'dt\'):\n        # If no timebase is given, answer depends on strict flag\n        if sys.dt is None:\n            return True if not strict else False\n        return sys.dt == 0\n\n    # Got passed something we don\'t recognize\n    return False\n\ndef pole(sys):\n    """"""\n    Compute system poles.\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        Linear system\n\n    Returns\n    -------\n    poles: ndarray\n        Array that contains the system\'s poles.\n\n    Raises\n    ------\n    NotImplementedError\n        when called on a TransferFunction object\n\n    See Also\n    --------\n    zero\n    TransferFunction.pole\n    StateSpace.pole\n\n    """"""\n\n    return sys.pole()\n\n\ndef zero(sys):\n    """"""\n    Compute system zeros.\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        Linear system\n\n    Returns\n    -------\n    zeros: ndarray\n        Array that contains the system\'s zeros.\n\n    Raises\n    ------\n    NotImplementedError\n        when called on a MIMO system\n\n    See Also\n    --------\n    pole\n    StateSpace.zero\n    TransferFunction.zero\n\n    """"""\n\n    return sys.zero()\n\ndef damp(sys, doprint=True):\n    """"""\n    Compute natural frequency, damping ratio, and poles of a system\n\n    The function takes 1 or 2 parameters\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace or TransferFunction)\n        A linear system object\n    doprint:\n        if true, print table with values\n\n    Returns\n    -------\n    wn: array\n        Natural frequencies of the poles\n    damping: array\n        Damping values\n    poles: array\n        Pole locations\n\n    Algorithm\n    ---------\n    If the system is continuous,\n        wn = abs(poles)\n        Z  = -real(poles)/poles.\n\n    If the system is discrete, the discrete poles are mapped to their\n    equivalent location in the s-plane via\n\n        s = log10(poles)/dt\n\n    and\n\n        wn = abs(s)\n        Z = -real(s)/wn.\n\n    See Also\n    --------\n    pole\n    """"""\n    wn, damping, poles = sys.damp()\n    if doprint:\n        print(\'_____Eigenvalue______ Damping___ Frequency_\')\n        for p, d, w in zip(poles, damping, wn) :\n            if abs(p.imag) < 1e-12:\n                print(""%10.4g            %10.4g %10.4g"" %\n                      (p.real, 1.0, -p.real))\n            else:\n                print(""%10.4g%+10.4gj %10.4g %10.4g"" %\n                      (p.real, p.imag, d, w))\n    return wn, damping, poles\n\ndef evalfr(sys, x):\n    """"""\n    Evaluate the transfer function of an LTI system for a single complex\n    number x.\n\n    To evaluate at a frequency, enter x = omega*j, where omega is the\n    frequency in radians\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        Linear system\n    x: scalar\n        Complex number\n\n    Returns\n    -------\n    fresp: ndarray\n\n    See Also\n    --------\n    freqresp\n    bode\n\n    Notes\n    -----\n    This function is a wrapper for StateSpace.evalfr and\n    TransferFunction.evalfr.\n\n    Examples\n    --------\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> evalfr(sys, 1j)\n    array([[ 44.8-21.4j]])\n    >>> # This is the transfer function matrix evaluated at s = i.\n\n    .. todo:: Add example with MIMO system\n    """"""\n    if issiso(sys):\n        return sys.horner(x)[0][0]\n    return sys.horner(x)\n\ndef freqresp(sys, omega):\n    """"""\n    Frequency response of an LTI system at multiple angular frequencies.\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        Linear system\n    omega: array_like\n        List of frequencies\n\n    Returns\n    -------\n    mag: ndarray\n    phase: ndarray\n    omega: list, tuple, or ndarray\n\n    See Also\n    --------\n    evalfr\n    bode\n\n    Notes\n    -----\n    This function is a wrapper for StateSpace.freqresp and\n    TransferFunction.freqresp.  The output omega is a sorted version of the\n    input omega.\n\n    Examples\n    --------\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> mag, phase, omega = freqresp(sys, [0.1, 1., 10.])\n    >>> mag\n    array([[[ 58.8576682 ,  49.64876635,  13.40825927]]])\n    >>> phase\n    array([[[-0.05408304, -0.44563154, -0.66837155]]])\n\n    .. todo::\n        Add example with MIMO system\n\n        #>>> sys = rss(3, 2, 2)\n        #>>> mag, phase, omega = freqresp(sys, [0.1, 1., 10.])\n        #>>> mag[0, 1, :]\n        #array([ 55.43747231,  42.47766549,   1.97225895])\n        #>>> phase[1, 0, :]\n        #array([-0.12611087, -1.14294316,  2.5764547 ])\n        #>>> # This is the magnitude of the frequency response from the 2nd\n        #>>> # input to the 1st output, and the phase (in radians) of the\n        #>>> # frequency response from the 1st input to the 2nd output, for\n        #>>> # s = 0.1i, i, 10i.\n    """"""\n\n    return sys.freqresp(omega)\n\ndef dcgain(sys):\n    """"""Return the zero-frequency (or DC) gain of the given system\n\n    Returns\n    -------\n    gain : ndarray\n        The zero-frequency gain, or np.nan if the system has a pole\n        at the origin\n    """"""\n    return sys.dcgain()\n'"
External_Libraries/python_control_master/control/margins.py,54,"b'""""""margin.py\n\nFunctions for computing stability margins and related functions.\n\nRoutines in this module:\n\nmargin.stability_margins\nmargin.phase_crossover_frequencies\nmargin.margin\n""""""\n\n# Python 3 compatibility (needs to go here)\nfrom __future__ import print_function\n\n""""""Copyright (c) 2011 by California Institute of Technology\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 14 July 2011\n\n$Id$\n""""""\n\nimport math\nimport numpy as np\nimport scipy as sp\nfrom . import xferfcn\nfrom .lti import issiso\nfrom . import frdata\n\n__all__ = [\'stability_margins\', \'phase_crossover_frequencies\', \'margin\']\n\n# helper functions for stability_margins\ndef _polyimsplit(pol):\n    """"""split a polynomial with (iw) applied into a real and an\n    imaginary part with w applied""""""\n    rpencil = np.zeros_like(pol)\n    ipencil = np.zeros_like(pol)\n    rpencil[-1::-4] = 1.\n    rpencil[-3::-4] = -1.\n    ipencil[-2::-4] = 1.\n    ipencil[-4::-4] = -1.\n    return pol * rpencil, pol*ipencil\n\ndef _polysqr(pol):\n    """"""return a polynomial squared""""""\n    return np.polymul(pol, pol)\n\n# Took the framework for the old function by\n# Sawyer B. Fuller <minster@caltech.edu>, removed a lot of the innards\n# and replaced with analytical polynomial functions for LTI systems.\n#\n# idea for the frequency data solution copied/adapted from\n# https://github.com/alchemyst/Skogestad-Python/blob/master/BODE.py\n# Rene van Paassen <rene.vanpaassen@gmail.com>\n#\n# RvP, July 8, 2014, corrected to exclude phase=0 crossing for the gain\n#                    margin polynomial\n# RvP, July 8, 2015, augmented to calculate all phase/gain crossings with\n#                    frd data. Correct to return smallest phase\n#                    margin, smallest gain margin and their frequencies\n# RvP, Jun 10, 2017, modified the inclusion of roots found for phase\n#                    crossing to include all >= 0, made subsequent calc\n#                    insensitive to div by 0\n#                    also changed the selection of which crossings to\n#                    return on basis of ""A note on the Gain and Phase\n#                    Margin Concepts"" Journal of Control and Systems\n#                    Engineering, Yazdan Bavafi-Toosi, Dec 2015, vol 3\n#                    issue 1, pp 51-59, closer to Matlab behavior, but\n#                    not completely identical in edge cases, which don\'t\n#                    cross but touch gain=1\ndef stability_margins(sysdata, returnall=False, epsw=0.0):\n    """"""Calculate stability margins and associated crossover frequencies.\n\n    Parameters\n    ----------\n    sysdata: LTI system or (mag, phase, omega) sequence\n        sys : LTI system\n            Linear SISO system\n        mag, phase, omega : sequence of array_like\n            Arrays of magnitudes (absolute values, not dB), phases (degrees),\n            and corresponding frequencies. Crossover frequencies returned are\n            in the same units as those in `omega` (e.g., rad/sec or Hz).\n    returnall: bool, optional\n        If true, return all margins found. If False (default), return only the\n        minimum stability margins. For frequency data or FRD systems, only\n        margins in the given frequency region can be found and returned.\n    epsw: float, optional\n        Frequencies below this value (default 0.0) are considered static gain,\n        and not returned as margin.\n\n    Returns\n    -------\n    gm: float or array_like\n        Gain margin\n    pm: float or array_loke\n        Phase margin\n    sm: float or array_like\n        Stability margin, the minimum distance from the Nyquist plot to -1\n    wg: float or array_like\n        Frequency for gain margin (at phase crossover, phase = -180 degrees)\n    wp: float or array_like\n        Frequency for phase margin (at gain crossover, gain = 1)\n    ws: float or array_like\n        Frequency for stability margin (complex gain closest to -1)\n    """"""\n\n    try:\n        if isinstance(sysdata, frdata.FRD):\n            sys = frdata.FRD(sysdata, smooth=True)\n        elif isinstance(sysdata, xferfcn.TransferFunction):\n            sys = sysdata\n        elif getattr(sysdata, \'__iter__\', False) and len(sysdata) == 3:\n            mag, phase, omega = sysdata\n            sys = frdata.FRD(mag * np.exp(1j * phase * math.pi/180),\n                             omega, smooth=True)\n        else:\n            sys = xferfcn._convert_to_transfer_function(sysdata)\n    except Exception as e:\n        print (e)\n        raise ValueError(""Margin sysdata must be either a linear system or ""\n                         ""a 3-sequence of mag, phase, omega."")\n\n    # calculate gain of system\n    if isinstance(sys, xferfcn.TransferFunction):\n\n        # check for siso\n        if not issiso(sys):\n            raise ValueError(""Can only do margins for SISO system"")\n\n        # real and imaginary part polynomials in omega:\n        rnum, inum = _polyimsplit(sys.num[0][0])\n        rden, iden = _polyimsplit(sys.den[0][0])\n\n        # test (imaginary part of tf) == 0, for phase crossover/gain margins\n        test_w_180 = np.polyadd(np.polymul(inum, rden), np.polymul(rnum, -iden))\n        w_180 = np.roots(test_w_180)\n\n        # first remove imaginary and negative frequencies, epsw removes the\n        # ""0"" frequency for type-2 systems\n        w_180 = np.real(w_180[(np.imag(w_180) == 0) * (w_180 >= epsw)])\n\n        # evaluate response at remaining frequencies, to test for phase 180 vs 0\n        with np.errstate(all=\'ignore\'):\n            resp_w_180 = np.real(\n                    np.polyval(sys.num[0][0], 1.j*w_180) /\n                    np.polyval(sys.den[0][0], 1.j*w_180))\n\n        # only keep frequencies where the negative real axis is crossed\n        w_180 = w_180[np.real(resp_w_180) <= 0.0]\n\n        # and sort\n        w_180.sort()\n\n        # test magnitude is 1 for gain crossover/phase margins\n        test_wc = np.polysub(np.polyadd(_polysqr(rnum), _polysqr(inum)),\n                             np.polyadd(_polysqr(rden), _polysqr(iden)))\n        wc = np.roots(test_wc)\n        wc = np.real(wc[(np.imag(wc) == 0) * (wc > epsw)])\n        wc.sort()\n\n        # stability margin was a bitch to elaborate, relies on magnitude to\n        # point -1, then take the derivative. Second derivative needs to be >0\n        # to have a minimum\n        test_wstabd = np.polyadd(_polysqr(rden), _polysqr(iden))\n        test_wstabn = np.polyadd(_polysqr(np.polyadd(rnum,rden)),\n                                 _polysqr(np.polyadd(inum,iden)))\n        test_wstab = np.polysub(\n            np.polymul(np.polyder(test_wstabn),test_wstabd),\n            np.polymul(np.polyder(test_wstabd),test_wstabn))\n\n        # find the solutions, for positive omega, and only real ones\n        wstab = np.roots(test_wstab)\n        wstab = np.real(wstab[(np.imag(wstab) == 0) *\n                        (np.real(wstab) >= 0)])\n\n        # and find the value of the 2nd derivative there, needs to be positive\n        wstabplus = np.polyval(np.polyder(test_wstab), wstab)\n        wstab = np.real(wstab[(np.imag(wstab) == 0) * (wstab > epsw) *\n                              (wstabplus > 0.)])\n        wstab.sort()\n\n    else:\n        # a bit coarse, have the interpolated frd evaluated again\n        def mod(w):\n            """"""to give the function to calculate |G(jw)| = 1""""""\n            return np.abs(sys._evalfr(w)[0][0]) - 1\n\n        def arg(w):\n            """"""function to calculate the phase angle at -180 deg""""""\n            return np.angle(-sys._evalfr(w)[0][0])\n\n        def dstab(w):\n            """"""function to calculate the distance from -1 point""""""\n            return np.abs(sys._evalfr(w)[0][0] + 1.)\n\n        # Find all crossings, note that this depends on omega having\n        # a correct range\n        widx = np.where(np.diff(np.sign(mod(sys.omega))))[0]\n        wc = np.array(\n            [ sp.optimize.brentq(mod, sys.omega[i], sys.omega[i+1])\n              for i in widx if i+1 < len(sys.omega)])\n\n        # find the phase crossings ang(H(jw) == -180\n        widx = np.where(np.diff(np.sign(arg(sys.omega))))[0]\n        widx = widx[np.real(sys._evalfr(sys.omega[widx])[0][0]) <= 0]\n        w_180 = np.array(\n            [ sp.optimize.brentq(arg, sys.omega[i], sys.omega[i+1])\n              for i in widx if i+1 < len(sys.omega) ])\n\n        # find all stab margins?\n        widx = np.where(np.diff(np.sign(np.diff(dstab(sys.omega)))))[0]\n        wstab = np.array([ sp.optimize.minimize_scalar(\n                  dstab, bracket=(sys.omega[i], sys.omega[i+1])).x\n              for i in widx if i+1 < len(sys.omega) and\n              np.diff(np.diff(dstab(sys.omega[i-1:i+2])))[0] > 0 ])\n        wstab = wstab[(wstab >= sys.omega[0]) *\n                      (wstab <= sys.omega[-1])]\n\n\n    # margins, as iterables, converted frdata and xferfcn calculations to\n    # vector for this\n    with np.errstate(all=\'ignore\'):\n        gain_w_180 = np.abs(sys._evalfr(w_180)[0][0])\n        GM = 1.0/gain_w_180\n    SM = np.abs(sys._evalfr(wstab)[0][0]+1)\n    PM = np.remainder(np.angle(sys._evalfr(wc)[0][0], deg=True), 360.0) - 180.0\n    \n    if returnall:\n        return GM, PM, SM, w_180, wc, wstab\n    else:\n        if GM.shape[0] and not np.isinf(GM).all():\n            with np.errstate(all=\'ignore\'):\n                gmidx = np.where(np.abs(np.log(GM)) == \n                                 np.min(np.abs(np.log(GM))))\n        else:\n            gmidx = -1\n        if PM.shape[0]:\n            pmidx = np.where(np.abs(PM) == np.amin(np.abs(PM)))[0]\n        return (\n            (not gmidx != -1 and float(\'inf\')) or GM[gmidx][0],\n            (not PM.shape[0] and float(\'inf\')) or PM[pmidx][0],\n            (not SM.shape[0] and float(\'inf\')) or np.amin(SM),\n            (not gmidx != -1 and float(\'nan\')) or w_180[gmidx][0],\n            (not wc.shape[0] and float(\'nan\')) or wc[pmidx][0],\n            (not wstab.shape[0] and float(\'nan\')) or wstab[SM==np.amin(SM)][0])\n\n\n# Contributed by Steffen Waldherr <waldherr@ist.uni-stuttgart.de>\n#! TODO - need to add test functions\ndef phase_crossover_frequencies(sys):\n    """"""Compute frequencies and gains at intersections with real axis\n    in Nyquist plot.\n\n    Call as:\n        omega, gain = phase_crossover_frequencies()\n\n    Returns\n    -------\n    omega: 1d array of (non-negative) frequencies where Nyquist plot\n    intersects the real axis\n\n    gain: 1d array of corresponding gains\n\n    Examples\n    --------\n    >>> tf = TransferFunction([1], [1, 2, 3, 4])\n    >>> PhaseCrossoverFrequenies(tf)\n    (array([ 1.73205081,  0.        ]), array([-0.5 ,  0.25]))\n    """"""\n\n    # Convert to a transfer function\n    tf = xferfcn._convert_to_transfer_function(sys)\n\n    # if not siso, fall back to (0,0) element\n    #! TODO: should add a check and warning here\n    num = tf.num[0][0]\n    den = tf.den[0][0]\n\n    # Compute frequencies that we cross over the real axis\n    numj = (1.j)**np.arange(len(num)-1,-1,-1)*num\n    denj = (-1.j)**np.arange(len(den)-1,-1,-1)*den\n    allfreq = np.roots(np.imag(np.polymul(numj,denj)))\n    realfreq = np.real(allfreq[np.isreal(allfreq)])\n    realposfreq = realfreq[realfreq >= 0.]\n\n    # using real() to avoid rounding errors and results like 1+0j\n    # it would be nice to have a vectorized version of self.evalfr here\n    gain = np.real(np.asarray([tf._evalfr(f)[0][0] for f in realposfreq]))\n\n    return realposfreq, gain\n\n\ndef margin(*args):\n    """"""margin(sysdata)\n\n    Calculate gain and phase margins and associated crossover frequencies\n\n    Parameters\n    ----------\n    sysdata : LTI system or (mag, phase, omega) sequence\n        sys : StateSpace or TransferFunction\n            Linear SISO system\n        mag, phase, omega : sequence of array_like\n            Input magnitude, phase (in deg.), and frequencies (rad/sec) from\n            bode frequency response data\n\n    Returns\n    -------\n    gm : float\n        Gain margin\n    pm : float\n        Phase margin (in degrees)\n    wg: float\n        Frequency for gain margin (at phase crossover, phase = -180 degrees)\n    wp: float\n        Frequency for phase margin (at gain crossover, gain = 1)\n\n    Margins are calculated for a SISO open-loop system.\n\n    If there is more than one gain crossover, the one at the smallest\n    margin (deviation from gain = 1), in absolute sense, is\n    returned. Likewise the smallest phase margin (in absolute sense)\n    is returned.\n\n    Examples\n    --------\n    >>> sys = tf(1, [1, 2, 1, 0])\n    >>> gm, pm, wg, wp = margin(sys)\n\n    """"""\n    if len(args) == 1:\n        sys = args[0]\n        margin = stability_margins(sys)\n    elif len(args) == 3:\n        margin = stability_margins(args)\n    else:\n        raise ValueError(""Margin needs 1 or 3 arguments; received %i.""\n            % len(args))\n\n    return margin[0], margin[1], margin[3], margin[4]\n'"
External_Libraries/python_control_master/control/mateqn.py,0,"b'"""""" mateqn.py\n\nMatrix equation solvers (Lyapunov, Riccati)\n\nImplementation of the functions lyap, dlyap, care and dare\nfor solution of Lyapunov and Riccati equations. """"""\n\n# Python 3 compatibility (needs to go here)\nfrom __future__ import print_function\n\n""""""Copyright (c) 2011, All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the project author nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Bjorn Olofsson\n""""""\n\nfrom numpy import shape, size, array, asarray, copy, zeros, eye, dot\nfrom scipy.linalg import eigvals, solve_discrete_are, solve\nfrom .exception import ControlSlycot, ControlArgument\nfrom .statesp import _ssmatrix\n\n__all__ = [\'lyap\', \'dlyap\', \'dare\', \'care\']\n\n#### Lyapunov equation solvers lyap and dlyap\n\ndef lyap(A, Q, C=None, E=None):\n    """"""X = lyap(A, Q) solves the continuous-time Lyapunov equation\n\n        :math:`A X + X A^T + Q = 0`\n\n    where A and Q are square matrices of the same dimension.\n    Further, Q must be symmetric.\n\n    X = lyap(A,Q,C) solves the Sylvester equation\n\n        :math:`A X + X Q + C = 0`\n\n    where A and Q are square matrices.\n\n    X = lyap(A,Q,None,E) solves the generalized continuous-time\n    Lyapunov equation\n\n        :math:`A X E^T + E X A^T + Q = 0`\n\n    where Q is a symmetric matrix and A, Q and E are square matrices\n    of the same dimension.\n\n    """"""\n\n    # Make sure we have access to the right slycot routines\n    try:\n        from slycot import sb03md\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb03md\'"")\n\n    try:\n        from slycot import sb04md\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb04md\'"")\n\n    # Reshape 1-d arrays\n    if len(shape(A)) == 1:\n        A = A.reshape(1, A.size)\n\n    if len(shape(Q)) == 1:\n        Q = Q.reshape(1, Q.size)\n\n    if C is not None and len(shape(C)) == 1:\n        C = C.reshape(1, C.size)\n\n    if E is not None and len(shape(E)) == 1:\n        E = E.reshape(1, E.size)\n\n    # Determine main dimensions\n    if size(A) == 1:\n        n = 1\n    else:\n        n = size(A, 0)\n\n    if size(Q) == 1:\n        m = 1\n    else:\n        m = size(Q, 0)\n\n    # Solve standard Lyapunov equation\n    if C is None and E is None:\n        # Check input data for consistency\n        if shape(A) != shape(Q):\n            raise ControlArgument(""A and Q must be matrices of identical \\\n                                sizes."")\n\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if size(Q) > 1 and shape(Q)[0] != shape(Q)[1]:\n            raise ControlArgument(""Q must be a quadratic matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        # Solve the Lyapunov equation by calling Slycot function sb03md\n        try:\n            X,scale,sep,ferr,w = sb03md(n,-Q,A,eye(n,n),\'C\',trana=\'T\')\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == n+1:\n                e = ValueError(""The matrix A and -A have common or very \\\n                    close eigenvalues."")\n                e.info = ve.info\n            else:\n                e = ValueError(""The QR algorithm failed to compute all \\\n                    the eigenvalues (see LAPACK Library routine DGEES)."")\n                e.info = ve.info\n            raise e\n\n    # Solve the Sylvester equation\n    elif C is not None and E is None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if size(Q) > 1 and shape(Q)[0] != shape(Q)[1]:\n            raise ControlArgument(""Q must be a quadratic matrix."")\n\n        if (size(C) > 1 and shape(C)[0] != n) or \\\n            (size(C) > 1 and shape(C)[1] != m) or \\\n            (size(C) == 1 and size(A) != 1) or (size(C) == 1 and size(Q) != 1):\n            raise ControlArgument(""C matrix has incompatible dimensions."")\n\n        # Solve the Sylvester equation by calling the Slycot function sb04md\n        try:\n            X = sb04md(n,m,A,Q,-C)\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info > m:\n                e = ValueError(""A singular matrix was encountered whilst \\\n                    solving for the %i-th column of matrix X."" % ve.info-m)\n                e.info = ve.info\n            else:\n                e = ValueError(""The QR algorithm failed to compute all the \\\n                    eigenvalues (see LAPACK Library routine DGEES)."")\n                e.info = ve.info\n            raise e\n\n    # Solve the generalized Lyapunov equation\n    elif C is None and E is not None:\n        # Check input data for consistency\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            (size(Q) == 1 and n > 1):\n            raise ControlArgument(""Q must be a square matrix with the same \\\n                dimension as A."")\n\n        if (size(E) > 1 and shape(E)[0] != shape(E)[1]) or \\\n            (size(E) > 1 and shape(E)[0] != n) or \\\n            (size(E) == 1 and n > 1):\n            raise ControlArgument(""E must be a square matrix with the same \\\n                dimension as A."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        # Make sure we have access to the write slicot routine\n        try:\n            from slycot import sg03ad\n        except ImportError:\n            raise ControlSlycot(""can\'t find slycot module \'sg03ad\'"")\n\n        # Solve the generalized Lyapunov equation by calling Slycot\n        # function sg03ad\n        try:\n            A,E,Q,Z,X,scale,sep,ferr,alphar,alphai,beta = \\\n                sg03ad(\'C\',\'B\',\'N\',\'T\',\'L\',n,A,E,eye(n,n),eye(n,n),-Q)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 4:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The matrix contained in the upper \\\n                                Hessenberg part of the array A is not in \\\n                                upper quasitriangular form"")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The pencil A - lambda * E cannot be \\\n                                reduced to generalized Schur form: LAPACK \\\n                                routine DGEGS has failed to converge"")\n                e.info = ve.info\n            elif ve.info == 4:\n                e = ValueError(""The pencil A - lambda * E has a \\\n                                degenerate pair of eigenvalues. That is, \\\n                                lambda_i = lambda_j for some i and j, where \\\n                                lambda_i and lambda_j are eigenvalues of \\\n                                A - lambda * E. Hence, the equation is \\\n                                singular;  perturbed values were \\\n                                used to solve the equation (but the matrices \\\n                                A and E are unchanged)"")\n                e.info = ve.info\n            raise e\n    # Invalid set of input parameters\n    else:\n        raise ControlArgument(""Invalid set of input parameters"")\n\n    return _ssmatrix(X)\n\n\ndef dlyap(A,Q,C=None,E=None):\n    """""" dlyap(A,Q) solves the discrete-time Lyapunov equation\n\n        :math:`A X A^T - X + Q = 0`\n\n    where A and Q are square matrices of the same dimension. Further\n    Q must be symmetric.\n\n    dlyap(A,Q,C) solves the Sylvester equation\n\n        :math:`A X Q^T - X + C = 0`\n\n    where A and Q are square matrices.\n\n    dlyap(A,Q,None,E) solves the generalized discrete-time Lyapunov\n    equation\n\n        :math:`A X A^T - E X E^T + Q = 0`\n\n    where Q is a symmetric matrix and A, Q and E are square matrices\n    of the same dimension. """"""\n\n    # Make sure we have access to the right slycot routines\n    try:\n        from slycot import sb03md\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb03md\'"")\n\n    try:\n        from slycot import sb04qd\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb04qd\'"")\n\n    try:\n        from slycot import sg03ad\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sg03ad\'"")\n\n    # Reshape 1-d arrays\n    if len(shape(A)) == 1:\n        A = A.reshape(1,A.size)\n\n    if len(shape(Q)) == 1:\n        Q = Q.reshape(1,Q.size)\n\n    if C is not None and len(shape(C)) == 1:\n        C = C.reshape(1,C.size)\n\n    if E is not None and len(shape(E)) == 1:\n        E = E.reshape(1,E.size)\n\n    # Determine main dimensions\n    if size(A) == 1:\n        n = 1\n    else:\n        n = size(A,0)\n\n    if size(Q) == 1:\n        m = 1\n    else:\n        m = size(Q,0)\n\n    # Solve standard Lyapunov equation\n    if C is None and E is None:\n        # Check input data for consistency\n        if shape(A) != shape(Q):\n            raise ControlArgument(""A and Q must be matrices of identical \\\n                                 sizes."")\n\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if size(Q) > 1 and shape(Q)[0] != shape(Q)[1]:\n            raise ControlArgument(""Q must be a quadratic matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        # Solve the Lyapunov equation by calling the Slycot function sb03md\n        try:\n            X,scale,sep,ferr,w = sb03md(n,-Q,A,eye(n,n),\'D\',trana=\'T\')\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            else:\n                e = ValueError(""The QR algorithm failed to compute all the \\\n                    eigenvalues (see LAPACK Library routine DGEES)."")\n                e.info = ve.info\n            raise e\n\n    # Solve the Sylvester equation\n    elif C is not None and E is None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix"")\n\n        if size(Q) > 1 and shape(Q)[0] != shape(Q)[1]:\n            raise ControlArgument(""Q must be a quadratic matrix"")\n\n        if (size(C) > 1 and shape(C)[0] != n) or \\\n            (size(C) > 1 and shape(C)[1] != m) or \\\n            (size(C) == 1 and size(A) != 1) or (size(C) == 1 and size(Q) != 1):\n            raise ControlArgument(""C matrix has incompatible dimensions"")\n\n        # Solve the Sylvester equation by calling Slycot function sb04qd\n        try:\n            X = sb04qd(n,m,-A,asarray(Q).T,C)\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info > m:\n                e = ValueError(""A singular matrix was encountered whilst \\\n                    solving for the %i-th column of matrix X."" % ve.info-m)\n                e.info = ve.info\n            else:\n                e = ValueError(""The QR algorithm failed to compute all the \\\n                    eigenvalues (see LAPACK Library routine DGEES)"")\n                e.info = ve.info\n            raise e\n\n    # Solve the generalized Lyapunov equation\n    elif C is None and E is not None:\n        # Check input data for consistency\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            (size(Q) == 1 and n > 1):\n            raise ControlArgument(""Q must be a square matrix with the same \\\n                dimension as A."")\n\n        if (size(E) > 1 and shape(E)[0] != shape(E)[1]) or \\\n            (size(E) > 1 and shape(E)[0] != n) or \\\n            (size(E) == 1 and n > 1):\n            raise ControlArgument(""E must be a square matrix with the same \\\n                dimension as A."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        # Solve the generalized Lyapunov equation by calling Slycot\n        # function sg03ad\n        try:\n            A,E,Q,Z,X,scale,sep,ferr,alphar,alphai,beta = \\\n                sg03ad(\'D\',\'B\',\'N\',\'T\',\'L\',n,A,E,eye(n,n),eye(n,n),-Q)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 4:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The matrix contained in the upper \\\n                                Hessenberg part of the array A is not in \\\n                                upper quasitriangular form"")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The pencil A - lambda * E cannot be \\\n                                reduced to generalized Schur form: LAPACK \\\n                                routine DGEGS has failed to converge"")\n                e.info = ve.info\n            elif ve.info == 3:\n                e = ValueError(""The pencil A - lambda * E has a \\\n                                pair of reciprocal eigenvalues. That is, \\\n                                lambda_i = 1/lambda_j for some i and j, \\\n                                where  lambda_i and lambda_j are eigenvalues \\\n                                of A - lambda * E. Hence, the equation is \\\n                                singular;  perturbed values were \\\n                                used to solve the equation (but the \\\n                                matrices A and E are unchanged)"")\n                e.info = ve.info\n            raise e\n    # Invalid set of input parameters\n    else:\n        raise ControlArgument(""Invalid set of input parameters"")\n\n    return _ssmatrix(X)\n\n\n#### Riccati equation solvers care and dare\ndef care(A, B, Q, R=None, S=None, E=None, stabilizing=True):\n    """""" (X,L,G) = care(A,B,Q,R=None) solves the continuous-time algebraic Riccati\n    equation\n\n        :math:`A^T X + X A - X B R^{-1} B^T X + Q = 0`\n\n    where A and Q are square matrices of the same dimension. Further,\n    Q and R are a symmetric matrices. If R is None, it is set to the\n    identity matrix. The function returns the solution X, the gain\n    matrix G = B^T X and the closed loop eigenvalues L, i.e., the\n    eigenvalues of A - B G.\n\n    (X,L,G) = care(A,B,Q,R,S,E) solves the generalized continuous-time\n    algebraic Riccati equation\n\n        :math:`A^T X E + E^T X A - (E^T X B + S) R^{-1} (B^T X E + S^T) + Q = 0`\n\n    where A, Q and E are square matrices of the same\n    dimension. Further, Q and R are symmetric matrices. If R is None,\n    it is set to the identity matrix. The function returns the\n    solution X, the gain matrix G = R^-1 (B^T X E + S^T) and the\n    closed loop eigenvalues L, i.e., the eigenvalues of A - B G , E.""""""\n\n    # Make sure we can import required slycot routine\n    try:\n        from slycot import sb02md\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb02md\'"")\n\n    try:\n        from slycot import sb02mt\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb02mt\'"")\n\n    # Make sure we can find the required slycot routine\n    try:\n        from slycot import sg02ad\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sg02ad\'"")\n\n    # Reshape 1-d arrays\n    if len(shape(A)) == 1:\n        A = A.reshape(1,A.size)\n\n    if len(shape(B)) == 1:\n        B = B.reshape(1,B.size)\n\n    if len(shape(Q)) == 1:\n        Q = Q.reshape(1,Q.size)\n\n    if R is not None and len(shape(R)) == 1:\n        R = R.reshape(1,R.size)\n\n    if S is not None and len(shape(S)) == 1:\n        S = S.reshape(1,S.size)\n\n    if E is not None and len(shape(E)) == 1:\n        E = E.reshape(1,E.size)\n\n    # Determine main dimensions\n    if size(A) == 1:\n        n = 1\n    else:\n        n = size(A,0)\n\n    if size(B) == 1:\n        m = 1\n    else:\n        m = size(B,1)\n    if R is None:\n        R = eye(m,m)\n\n    # Solve the standard algebraic Riccati equation\n    if S is None and E is None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            size(Q) == 1 and n > 1:\n            raise ControlArgument(""Q must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(B) > 1 and shape(B)[0] != n) or \\\n            size(B) == 1 and n > 1:\n            raise ControlArgument(""Incompatible dimensions of B matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        if not (asarray(R) == asarray(R).T).all():\n            raise ControlArgument(""R must be a symmetric matrix."")\n\n        # Create back-up of arrays needed for later computations\n        R_ba = copy(R)\n        B_ba = copy(B)\n\n        # Solve the standard algebraic Riccati equation by calling Slycot\n        # functions sb02mt and sb02md\n        try:\n            A_b,B_b,Q_b,R_b,L_b,ipiv,oufact,G = sb02mt(n,m,B,R)\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == m+1:\n                e = ValueError(""The matrix R is numerically singular."")\n                e.info = ve.info\n            else:\n                e = ValueError(""The %i-th element of d in the UdU (LdL) \\\n                    factorization is zero."" % ve.info)\n                e.info = ve.info\n            raise e\n\n        try:\n            if stabilizing:\n                sort = \'S\'\n            else:\n                sort = \'U\'\n            X, rcond, w, S_o, U, A_inv = sb02md(n, A, G, Q, \'C\', sort=sort)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 5:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The matrix A is (numerically) singular in \\\n                    continuous-time case."")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The Hamiltonian or symplectic matrix H cannot \\\n                    be reduced to real Schur form."")\n                e.info = ve.info\n            elif ve.info == 3:\n                e = ValueError(""The real Schur form of the Hamiltonian or \\\n                    symplectic matrix H cannot be appropriately ordered."")\n                e.info = ve.info\n            elif ve.info == 4:\n                e = ValueError(""The Hamiltonian or symplectic matrix H has \\\n                    less than n stable eigenvalues."")\n                e.info = ve.info\n            elif ve.info == 5:\n                e = ValueError(""The N-th order system of linear algebraic \\\n                         equations is singular to working precision."")\n                e.info = ve.info\n            raise e\n\n        # Calculate the gain matrix G\n        if size(R_b) == 1:\n            G = dot(dot(1/(R_ba), asarray(B_ba).T), X)\n        else:\n            G = dot(solve(R_ba, asarray(B_ba).T), X)\n\n        # Return the solution X, the closed-loop eigenvalues L and\n        # the gain matrix G\n        return (_ssmatrix(X) , w[:n] , _ssmatrix(G))\n\n    # Solve the generalized algebraic Riccati equation\n    elif S is not None and E is not None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            size(Q) == 1 and n > 1:\n            raise ControlArgument(""Q must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(B) > 1 and shape(B)[0] != n) or \\\n            size(B) == 1 and n > 1:\n            raise ControlArgument(""Incompatible dimensions of B matrix."")\n\n        if (size(E) > 1 and shape(E)[0] != shape(E)[1]) or \\\n            (size(E) > 1 and shape(E)[0] != n) or \\\n            size(E) == 1 and n > 1:\n            raise ControlArgument(""E must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(R) > 1 and shape(R)[0] != shape(R)[1]) or \\\n            (size(R) > 1 and shape(R)[0] != m) or \\\n            size(R) == 1 and m > 1:\n            raise ControlArgument(""R must be a quadratic matrix of the same \\\n                dimension as the number of columns in the B matrix."")\n\n        if (size(S) > 1 and shape(S)[0] != n) or \\\n            (size(S) > 1 and shape(S)[1] != m) or \\\n            size(S) == 1 and n > 1 or \\\n            size(S) == 1 and m > 1:\n            raise ControlArgument(""Incompatible dimensions of S matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        if not (asarray(R) == asarray(R).T).all():\n            raise ControlArgument(""R must be a symmetric matrix."")\n\n        # Create back-up of arrays needed for later computations\n        R_b = copy(R)\n        B_b = copy(B)\n        E_b = copy(E)\n        S_b = copy(S)\n\n        # Solve the generalized algebraic Riccati equation by calling the\n        # Slycot function sg02ad\n        try:\n            if stabilizing:\n                sort = \'S\'\n            else:\n                sort = \'U\'\n            rcondu, X, alfar, alfai, beta, S_o, T, U, iwarn = \\\n                sg02ad(\'C\', \'B\', \'N\', \'U\', \'N\', \'N\', sort, \'R\', n, m, 0, A, E, B, Q, R, S)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 7:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The computed extended matrix pencil is \\\n                            singular, possibly due to rounding errors."")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The QZ algorithm failed."")\n                e.info = ve.info\n            elif ve.info == 3:\n                e = ValueError(""Reordering of the generalized eigenvalues \\\n                    failed."")\n                e.info = ve.info\n            elif ve.info == 4:\n                e = ValueError(""After reordering, roundoff changed values of \\\n                            some complex eigenvalues so that leading \\\n                            eigenvalues in the generalized Schur form no \\\n                            longer satisfy the stability condition; this \\\n                            could also be caused due to scaling."")\n                e.info = ve.info\n            elif ve.info == 5:\n                e = ValueError(""The computed dimension of the solution does \\\n                            not equal N."")\n                e.info = ve.info\n            elif ve.info == 6:\n                e = ValueError(""The spectrum is too close to the boundary of \\\n                            the stability domain."")\n                e.info = ve.info\n            elif ve.info == 7:\n                e = ValueError(""A singular matrix was encountered during the \\\n                            computation of the solution matrix X."")\n                e.info = ve.info\n            raise e\n\n        # Calculate the closed-loop eigenvalues L\n        L = zeros((n,1))\n        L.dtype = \'complex64\'\n        for i in range(n):\n            L[i] = (alfar[i] + alfai[i]*1j)/beta[i]\n\n        # Calculate the gain matrix G\n        if size(R_b) == 1:\n            G = dot(1/(R_b), dot(asarray(B_b).T, dot(X,E_b)) + asarray(S_b).T)\n        else:\n            G = solve(R_b, dot(asarray(B_b).T, dot(X, E_b)) + asarray(S_b).T)\n\n        # Return the solution X, the closed-loop eigenvalues L and\n        # the gain matrix G\n        return (_ssmatrix(X), L, _ssmatrix(G))\n\n    # Invalid set of input parameters\n    else:\n        raise ControlArgument(""Invalid set of input parameters."")\n\ndef dare(A, B, Q, R, S=None, E=None, stabilizing=True):\n    """""" (X,L,G) = dare(A,B,Q,R) solves the discrete-time algebraic Riccati\n    equation\n\n        :math:`A^T X A - X - A^T X B (B^T X B + R)^{-1} B^T X A + Q = 0`\n\n    where A and Q are square matrices of the same dimension. Further, Q\n    is a symmetric matrix. The function returns the solution X, the gain\n    matrix G = (B^T X B + R)^-1 B^T X A and the closed loop eigenvalues L,\n    i.e., the eigenvalues of A - B G.\n\n    (X,L,G) = dare(A,B,Q,R,S,E) solves the generalized discrete-time algebraic\n    Riccati equation\n\n        :math:`A^T X A - E^T X E - (A^T X B + S) (B^T X B + R)^{-1} (B^T X A + S^T) + Q = 0`\n\n    where A, Q and E are square matrices of the same dimension. Further, Q and\n    R are symmetric matrices. The function returns the solution X, the gain\n    matrix :math:`G = (B^T X B + R)^{-1} (B^T X A + S^T)` and the closed loop\n    eigenvalues L, i.e., the eigenvalues of A - B G , E.\n    """"""\n    if S is not None or E is not None or not stabilizing:\n        return dare_old(A, B, Q, R, S, E, stabilizing)\n    else:\n        Rmat = _ssmatrix(R)\n        Qmat = _ssmatrix(Q)\n        X = solve_discrete_are(A, B, Qmat, Rmat)\n        G = solve(B.T.dot(X).dot(B) + Rmat, B.T.dot(X).dot(A))\n        L = eigvals(A - B.dot(G))\n        return _ssmatrix(X), L, _ssmatrix(G)\n\ndef dare_old(A, B, Q, R, S=None, E=None, stabilizing=True):\n    # Make sure we can import required slycot routine\n    try:\n        from slycot import sb02md\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb02md\'"")\n\n    try:\n        from slycot import sb02mt\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb02mt\'"")\n\n    # Make sure we can find the required slycot routine\n    try:\n        from slycot import sg02ad\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sg02ad\'"")\n\n    # Reshape 1-d arrays\n    if len(shape(A)) == 1:\n        A = A.reshape(1,A.size)\n\n    if len(shape(B)) == 1:\n        B = B.reshape(1,B.size)\n\n    if len(shape(Q)) == 1:\n        Q = Q.reshape(1,Q.size)\n\n    if R is not None and len(shape(R)) == 1:\n        R = R.reshape(1,R.size)\n\n    if S is not None and len(shape(S)) == 1:\n        S = S.reshape(1,S.size)\n\n    if E is not None and len(shape(E)) == 1:\n        E = E.reshape(1,E.size)\n\n    # Determine main dimensions\n    if size(A) == 1:\n        n = 1\n    else:\n        n = size(A,0)\n\n    if size(B) == 1:\n        m = 1\n    else:\n        m = size(B,1)\n\n    # Solve the standard algebraic Riccati equation\n    if S is None and E is None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            size(Q) == 1 and n > 1:\n            raise ControlArgument(""Q must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(B) > 1 and shape(B)[0] != n) or \\\n            size(B) == 1 and n > 1:\n            raise ControlArgument(""Incompatible dimensions of B matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        if not (asarray(R) == asarray(R).T).all():\n            raise ControlArgument(""R must be a symmetric matrix."")\n\n        # Create back-up of arrays needed for later computations\n        A_ba = copy(A)\n        R_ba = copy(R)\n        B_ba = copy(B)\n\n        # Solve the standard algebraic Riccati equation by calling Slycot\n        # functions sb02mt and sb02md\n        try:\n            A_b,B_b,Q_b,R_b,L_b,ipiv,oufact,G = sb02mt(n,m,B,R)\n        except ValueError as ve:\n            if ve.info < 0:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == m+1:\n                e = ValueError(""The matrix R is numerically singular."")\n                e.info = ve.info\n            else:\n                e = ValueError(""The %i-th element of d in the UdU (LdL) \\\n                     factorization is zero."" % ve.info)\n                e.info = ve.info\n            raise e\n\n        try:\n            if stabilizing:\n                sort = \'S\'\n            else:\n                sort = \'U\'\n\n            X, rcond, w, S, U, A_inv = sb02md(n, A, G, Q, \'D\', sort=sort)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 5:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The matrix A is (numerically) singular in \\\n                    discrete-time case."")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The Hamiltonian or symplectic matrix H cannot \\\n                    be reduced to real Schur form."")\n                e.info = ve.info\n            elif ve.info == 3:\n                e = ValueError(""The real Schur form of the Hamiltonian or \\\n                     symplectic matrix H cannot be appropriately ordered."")\n                e.info = ve.info\n            elif ve.info == 4:\n                e = ValueError(""The Hamiltonian or symplectic matrix H has \\\n                     less than n stable eigenvalues."")\n                e.info = ve.info\n            elif ve.info == 5:\n                e = ValueError(""The N-th order system of linear algebraic \\\n                     equations is singular to working precision."")\n                e.info = ve.info\n            raise e\n\n        # Calculate the gain matrix G\n        if size(R_b) == 1:\n            G = dot(1/(dot(asarray(B_ba).T, dot(X, B_ba)) + R_ba), \\\n                dot(asarray(B_ba).T, dot(X, A_ba)))\n        else:\n            G = solve(dot(asarray(B_ba).T, dot(X, B_ba)) + R_ba, \\\n                dot(asarray(B_ba).T, dot(X, A_ba)))\n\n        # Return the solution X, the closed-loop eigenvalues L and\n        # the gain matrix G\n        return (_ssmatrix(X) , w[:n], _ssmatrix(G))\n\n    # Solve the generalized algebraic Riccati equation\n    elif S is not None and E is not None:\n        # Check input data for consistency\n        if size(A) > 1 and shape(A)[0] != shape(A)[1]:\n            raise ControlArgument(""A must be a quadratic matrix."")\n\n        if (size(Q) > 1 and shape(Q)[0] != shape(Q)[1]) or \\\n            (size(Q) > 1 and shape(Q)[0] != n) or \\\n            size(Q) == 1 and n > 1:\n            raise ControlArgument(""Q must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(B) > 1 and shape(B)[0] != n) or \\\n            size(B) == 1 and n > 1:\n            raise ControlArgument(""Incompatible dimensions of B matrix."")\n\n        if (size(E) > 1 and shape(E)[0] != shape(E)[1]) or \\\n            (size(E) > 1 and shape(E)[0] != n) or \\\n            size(E) == 1 and n > 1:\n            raise ControlArgument(""E must be a quadratic matrix of the same \\\n                dimension as A."")\n\n        if (size(R) > 1 and shape(R)[0] != shape(R)[1]) or \\\n            (size(R) > 1 and shape(R)[0] != m) or \\\n            size(R) == 1 and m > 1:\n            raise ControlArgument(""R must be a quadratic matrix of the same \\\n                dimension as the number of columns in the B matrix."")\n\n        if (size(S) > 1 and shape(S)[0] != n) or \\\n            (size(S) > 1 and shape(S)[1] != m) or \\\n            size(S) == 1 and n > 1 or \\\n            size(S) == 1 and m > 1:\n            raise ControlArgument(""Incompatible dimensions of S matrix."")\n\n        if not (asarray(Q) == asarray(Q).T).all():\n            raise ControlArgument(""Q must be a symmetric matrix."")\n\n        if not (asarray(R) == asarray(R).T).all():\n            raise ControlArgument(""R must be a symmetric matrix."")\n\n        # Create back-up of arrays needed for later computations\n        A_b = copy(A)\n        R_b = copy(R)\n        B_b = copy(B)\n        E_b = copy(E)\n        S_b = copy(S)\n\n        # Solve the generalized algebraic Riccati equation by calling the\n        # Slycot function sg02ad\n        try:\n            if stabilizing:\n                sort = \'S\'\n            else:\n                sort = \'U\'\n            rcondu, X, alfar, alfai, beta, S_o, T, U, iwarn = \\\n                sg02ad(\'D\', \'B\', \'N\', \'U\', \'N\', \'N\', sort, \'R\', n, m, 0, A, E, B, Q, R, S)\n        except ValueError as ve:\n            if ve.info < 0 or ve.info > 7:\n                e = ValueError(ve.message)\n                e.info = ve.info\n            elif ve.info == 1:\n                e = ValueError(""The computed extended matrix pencil is \\\n                            singular, possibly due to rounding errors."")\n                e.info = ve.info\n            elif ve.info == 2:\n                e = ValueError(""The QZ algorithm failed."")\n                e.info = ve.info\n            elif ve.info == 3:\n                e = ValueError(""Reordering of the generalized eigenvalues \\\n                     failed."")\n                e.info = ve.info\n            elif ve.info == 4:\n                e = ValueError(""After reordering, roundoff changed values of \\\n                            some complex eigenvalues so that leading \\\n                            eigenvalues in the generalized Schur form no \\\n                            longer satisfy the stability condition; this \\\n                            could also be caused due to scaling."")\n                e.info = ve.info\n            elif ve.info == 5:\n                e = ValueError(""The computed dimension of the solution does \\\n                            not equal N."")\n                e.info = ve.info\n            elif ve.info == 6:\n                e = ValueError(""The spectrum is too close to the boundary of \\\n                            the stability domain."")\n                e.info = ve.info\n            elif ve.info == 7:\n                e = ValueError(""A singular matrix was encountered during the \\\n                            computation of the solution matrix X."")\n                e.info = ve.info\n            raise e\n\n        L = zeros((n,1))\n        L.dtype = \'complex64\'\n        for i in range(n):\n            L[i] = (alfar[i] + alfai[i]*1j)/beta[i]\n\n        # Calculate the gain matrix G\n        if size(R_b) == 1:\n            G = dot(1/(dot(asarray(B_b).T, dot(X,B_b)) + R_b), \\\n                dot(asarray(B_b).T, dot(X,A_b)) + asarray(S_b).T)\n        else:\n            G = solve(dot(asarray(B_b).T, dot(X,B_b)) + R_b, \\\n                dot(asarray(B_b).T, dot(X,A_b)) + asarray(S_b).T)\n\n        # Return the solution X, the closed-loop eigenvalues L and\n        # the gain matrix G\n        return (_ssmatrix(X), L, _ssmatrix(G))\n\n    # Invalid set of input parameters\n    else:\n        raise ControlArgument(""Invalid set of input parameters."")\n'"
External_Libraries/python_control_master/control/modelsimp.py,28,"b'#! TODO: add module docstring\n# modelsimp.py - tools for model simplification\n#\n# Author: Steve Brunton, Kevin Chen, Lauren Padilla\n# Date: 30 Nov 2010\n#\n# This file contains routines for obtaining reduced order models\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\n# Python 3 compatibility\nfrom __future__ import print_function\n\n# External packages and modules\nimport numpy as np\nfrom .exception import ControlSlycot\nfrom .lti import isdtime, isctime\nfrom .statesp import StateSpace\nfrom .statefbk import gram\n\n__all__ = [\'hsvd\', \'balred\', \'modred\', \'era\', \'markov\', \'minreal\']\n\n# Hankel Singular Value Decomposition\n#   The following returns the Hankel singular values, which are singular values\n#of the matrix formed by multiplying the controllability and observability\n#grammians\ndef hsvd(sys):\n    """"""Calculate the Hankel singular values.\n\n    Parameters\n    ----------\n    sys : StateSpace\n        A state space system\n\n    Returns\n    -------\n    H : array\n        A list of Hankel singular values\n\n    See Also\n    --------\n    gram\n\n    Notes\n    -----\n    The Hankel singular values are the singular values of the Hankel operator.\n    In practice, we compute the square root of the eigenvalues of the matrix\n    formed by taking the product of the observability and controllability\n    gramians.  There are other (more efficient) methods based on solving the\n    Lyapunov equation in a particular way (more details soon).\n\n    Examples\n    --------\n    >>> H = hsvd(sys)\n\n    """"""\n    # TODO: implement for discrete time systems\n    if (isdtime(sys, strict=True)):\n        raise NotImplementedError(""Function not implemented in discrete time"")\n\n    Wc = gram(sys,\'c\')\n    Wo = gram(sys,\'o\')\n    WoWc = np.dot(Wo, Wc)\n    w, v = np.linalg.eig(WoWc)\n\n    hsv = np.sqrt(w)\n    hsv = np.array(hsv)\n    hsv = np.sort(hsv)\n    # Return the Hankel singular values, high to low\n    return hsv[::-1]\n\ndef modred(sys, ELIM, method=\'matchdc\'):\n    """"""\n    Model reduction of `sys` by eliminating the states in `ELIM` using a given\n    method.\n\n    Parameters\n    ----------\n    sys: StateSpace\n        Original system to reduce\n    ELIM: array\n        Vector of states to eliminate\n    method: string\n        Method of removing states in `ELIM`: either ``\'truncate\'`` or\n        ``\'matchdc\'``.\n\n    Returns\n    -------\n    rsys: StateSpace\n        A reduced order model\n\n    Raises\n    ------\n    ValueError\n        Raised under the following conditions:\n\n            * if `method` is not either ``\'matchdc\'`` or ``\'truncate\'``\n\n            * if eigenvalues of `sys.A` are not all in left half plane\n              (`sys` must be stable)\n\n    Examples\n    --------\n    >>> rsys = modred(sys, ELIM, method=\'truncate\')\n    """"""\n\n    #Check for ss system object, need a utility for this?\n\n    #TODO: Check for continous or discrete, only continuous supported right now\n        # if isCont():\n        #    dico = \'C\'\n        # elif isDisc():\n        #    dico = \'D\'\n        # else:\n    if (isctime(sys)):\n        dico = \'C\'\n    else:\n        raise NotImplementedError(""Function not implemented in discrete time"")\n\n\n    #Check system is stable\n    if np.any(np.linalg.eigvals(sys.A).real >= 0.0):\n        raise ValueError(""Oops, the system is unstable!"")\n\n    ELIM = np.sort(ELIM)\n    # Create list of elements not to eliminate (NELIM)\n    NELIM = [i for i in range(len(sys.A)) if i not in ELIM]\n    # A1 is a matrix of all columns of sys.A not to eliminate\n    A1 = sys.A[:, NELIM[0]].reshape(-1, 1)\n    for i in NELIM[1:]:\n        A1 = np.hstack((A1, sys.A[:,i].reshape(-1, 1)))\n    A11 = A1[NELIM,:]\n    A21 = A1[ELIM,:]\n    # A2 is a matrix of all columns of sys.A to eliminate\n    A2 = sys.A[:, ELIM[0]].reshape(-1, 1)\n    for i in ELIM[1:]:\n        A2 = np.hstack((A2, sys.A[:,i].reshape(-1, 1)))\n    A12 = A2[NELIM,:]\n    A22 = A2[ELIM,:]\n\n    C1 = sys.C[:,NELIM]\n    C2 = sys.C[:,ELIM]\n    B1 = sys.B[NELIM,:]\n    B2 = sys.B[ELIM,:]\n\n    if method==\'matchdc\':\n        # if matchdc, residualize\n\n        # Check if the matrix A22 is invertible\n        if np.linalg.matrix_rank(A22) != len(ELIM):\n            raise ValueError(""Matrix A22 is singular to working precision."")\n\n        # Now precompute A22\\A21 and A22\\B2 (A22I = inv(A22))\n        # We can solve two linear systems in one pass, since the\n        # coefficients matrix A22 is the same. Thus, we perform the LU\n        # decomposition (cubic runtime complexity) of A22 only once!\n        # The remaining back substitutions are only quadratic in runtime.\n        A22I_A21_B2 = np.linalg.solve(A22, np.concatenate((A21, B2), axis=1))\n        A22I_A21 = A22I_A21_B2[:, :A21.shape[1]]\n        A22I_B2 = A22I_A21_B2[:, A21.shape[1]:]\n\n        Ar = A11 - np.dot(A12, A22I_A21)\n        Br = B1 - np.dot(A12, A22I_B2)\n        Cr = C1 - np.dot(C2, A22I_A21)\n        Dr = sys.D - np.dot(C2, A22I_B2)\n    elif method==\'truncate\':\n        # if truncate, simply discard state x2\n        Ar = A11\n        Br = B1\n        Cr = C1\n        Dr = sys.D\n    else:\n        raise ValueError(""Oops, method is not supported!"")\n\n    rsys = StateSpace(Ar,Br,Cr,Dr)\n    return rsys\n\ndef balred(sys, orders, method=\'truncate\', alpha=None):\n    """"""\n    Balanced reduced order model of sys of a given order.\n    States are eliminated based on Hankel singular value.\n    If sys has unstable modes, they are removed, the\n    balanced realization is done on the stable part, then\n    reinserted in accordance with the reference below.\n\n    Reference: Hsu,C.S., and Hou,D., 1991,\n    Reducing unstable linear control systems via real Schur transformation.\n    Electronics Letters, 27, 984-986.\n\n    Parameters\n    ----------\n    sys: StateSpace\n        Original system to reduce\n    orders: integer or array of integer\n        Desired order of reduced order model (if a vector, returns a vector\n        of systems)\n    method: string\n        Method of removing states, either ``\'truncate\'`` or ``\'matchdc\'``.\n    alpha: float\n        Redefines the stability boundary for eigenvalues of the system matrix A.\n        By default for continuous-time systems, alpha <= 0 defines the stability\n        boundary for the real part of A\'s eigenvalues and for discrete-time\n        systems, 0 <= alpha <= 1 defines the stability boundary for the modulus\n        of A\'s eigenvalues. See SLICOT routines AB09MD and AB09ND for more\n        information.\n\n    Returns\n    -------\n    rsys: StateSpace\n        A reduced order model or a list of reduced order models if orders is a list\n\n    Raises\n    ------\n    ValueError\n        * if `method` is not ``\'truncate\'`` or ``\'matchdc\'``\n    ImportError\n        if slycot routine ab09ad, ab09md, or ab09nd is not found\n\n    ValueError\n        if there are more unstable modes than any value in orders\n\n    Examples\n    --------\n    >>> rsys = balred(sys, orders, method=\'truncate\')\n\n    """"""\n    if method!=\'truncate\' and method!=\'matchdc\':\n        raise ValueError(""supported methods are \'truncate\' or \'matchdc\'"")\n    elif method==\'truncate\':\n        try:\n            from slycot import ab09md, ab09ad\n        except ImportError:\n            raise ControlSlycot(""can\'t find slycot subroutine ab09md or ab09ad"")\n    elif method==\'matchdc\':\n        try:\n            from slycot import ab09nd\n        except ImportError:\n            raise ControlSlycot(""can\'t find slycot subroutine ab09nd"")\n\n    #Check for ss system object, need a utility for this?\n\n    #TODO: Check for continous or discrete, only continuous supported right now\n        # if isCont():\n        #    dico = \'C\'\n        # elif isDisc():\n        #    dico = \'D\'\n        # else:\n    dico = \'C\'\n\n    job = \'B\' # balanced (B) or not (N)\n    equil = \'N\'  # scale (S) or not (N)\n    if alpha is None:\n        if dico == \'C\':\n            alpha = 0.\n        elif dico == \'D\':\n            alpha = 1.\n\n    rsys = [] #empty list for reduced systems\n\n    #check if orders is a list or a scalar\n    try:\n        order = iter(orders)\n    except TypeError: #if orders is a scalar\n        orders = [orders]\n\n    for i in orders:\n        n = np.size(sys.A,0)\n        m = np.size(sys.B,1)\n        p = np.size(sys.C,0)\n        if method == \'truncate\':\n            #check system stability\n            if np.any(np.linalg.eigvals(sys.A).real >= 0.0):\n                #unstable branch\n                Nr, Ar, Br, Cr, Ns, hsv = ab09md(dico,job,equil,n,m,p,sys.A,sys.B,sys.C,alpha=alpha,nr=i,tol=0.0)\n            else:\n                #stable branch\n                Nr, Ar, Br, Cr, hsv = ab09ad(dico,job,equil,n,m,p,sys.A,sys.B,sys.C,nr=i,tol=0.0)\n            rsys.append(StateSpace(Ar, Br, Cr, sys.D))\n\n        elif method == \'matchdc\':\n            Nr, Ar, Br, Cr, Dr, Ns, hsv = ab09nd(dico,job,equil,n,m,p,sys.A,sys.B,sys.C,sys.D,alpha=alpha,nr=i,tol1=0.0,tol2=0.0)\n            rsys.append(StateSpace(Ar, Br, Cr, Dr))\n\n    #if orders was a scalar, just return the single reduced model, not a list\n    if len(orders) == 1:\n        return rsys[0]\n    #if orders was a list/vector, return a list/vector of systems\n    else:\n        return rsys\n\ndef minreal(sys, tol=None, verbose=True):\n    \'\'\'\n    Eliminates uncontrollable or unobservable states in state-space\n    models or cancelling pole-zero pairs in transfer functions. The\n    output sysr has minimal order and the same response\n    characteristics as the original model sys.\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        Original system\n    tol: real\n        Tolerance\n    verbose: bool\n        Print results if True\n\n    Returns\n    -------\n    rsys: StateSpace or TransferFunction\n        Cleaned model\n    \'\'\'\n    sysr = sys.minreal(tol)\n    if verbose:\n        print(""{nstates} states have been removed from the model"".format(\n                nstates=len(sys.pole()) - len(sysr.pole())))\n    return sysr\n\ndef era(YY, m, n, nin, nout, r):\n    """"""\n    Calculate an ERA model of order `r` based on the impulse-response data `YY`.\n\n    .. note:: This function is not implemented yet.\n\n    Parameters\n    ----------\n    YY: array\n        `nout` x `nin` dimensional impulse-response data\n    m: integer\n        Number of rows in Hankel matrix\n    n: integer\n        Number of columns in Hankel matrix\n    nin: integer\n        Number of input variables\n    nout: integer\n        Number of output variables\n    r: integer\n        Order of model\n\n    Returns\n    -------\n    sys: StateSpace\n        A reduced order model sys=ss(Ar,Br,Cr,Dr)\n\n    Examples\n    --------\n    >>> rsys = era(YY, m, n, nin, nout, r)\n    """"""\n    raise NotImplementedError(\'This function is not implemented yet.\')\n\ndef markov(Y, U, m):\n    """"""\n    Calculate the first `M` Markov parameters [D CB CAB ...]\n    from input `U`, output `Y`.\n\n    Parameters\n    ----------\n    Y: array_like\n        Output data\n    U: array_like\n        Input data\n    m: int\n        Number of Markov parameters to output\n\n    Returns\n    -------\n    H: ndarray\n        First m Markov parameters\n\n    Notes\n    -----\n    Currently only works for SISO\n\n    Examples\n    --------\n    >>> H = markov(Y, U, m)\n    """"""\n\n    # Convert input parameters to matrices (if they aren\'t already)\n    Ymat = np.array(Y)\n    Umat = np.array(U)\n    n = np.size(U)\n\n    # Construct a matrix of control inputs to invert\n    UU = Umat\n    for i in range(1, m-1):\n        # TODO: second index on UU doesn\'t seem right; could be neg or pos??\n        newCol = np.vstack((0, np.reshape(UU[0:n-1, i-2], (-1, 1))))\n        UU = np.hstack((UU, newCol))\n    Ulast = np.vstack((0, np.reshape(UU[0:n-1, m-2], (-1, 1))))\n    for i in range(n-1, 0, -1):\n        Ulast[i] = np.sum(Ulast[0:i-1])\n    UU = np.hstack((UU, Ulast))\n\n    # Invert and solve for Markov parameters\n    H = np.linalg.lstsq(UU, Y)[0]\n\n    return H\n'"
External_Libraries/python_control_master/control/nichols.py,20,"b'""""""nichols.py\n\nFunctions for plotting Black-Nichols charts.\n\nRoutines in this module:\n\nnichols.nichols_plot aliased as nichols.nichols\nnichols.nichols_grid\n""""""\n\n# nichols.py - Nichols plot\n#\n# Contributed by Allan McInnes <Allan.McInnes@canterbury.ac.nz>\n#\n# This file contains some standard control system plots: Bode plots,\n# Nyquist plots, Nichols plots and pole-zero diagrams\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id: freqplot.py 139 2011-03-30 16:19:59Z murrayrm $\n\nimport scipy as sp\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom .ctrlutil import unwrap\nfrom .freqplot import default_frequency_range\nfrom . import config\n\n__all__ = [\'nichols_plot\', \'nichols\', \'nichols_grid\']\n\n# Default parameters values for the nichols module\n_nichols_defaults = {\n    \'nichols.grid\':True,\n}\n\n\ndef nichols_plot(sys_list, omega=None, grid=None, number_of_samples=100):\n    """"""Nichols plot for a system\n\n    Plots a Nichols plot for the system over a (optional) frequency range.\n\n    Parameters\n    ----------\n    sys_list : list of LTI, or LTI\n        List of linear input/output systems (single system is OK)\n    omega : array_like\n        Range of frequencies (list or bounds) in rad/sec\n    grid : boolean, optional\n        True if the plot should include a Nichols-chart grid. Default is True.\n\n    Returns\n    -------\n    None\n    """"""\n    # Get parameter values\n    grid = config._get_param(\'nichols\', \'grid\', grid, True)\n\n\n    # If argument was a singleton, turn it into a list\n    if not getattr(sys_list, \'__iter__\', False):\n        sys_list = (sys_list,)\n\n    # Select a default range if none is provided\n    if omega is None:\n        omega = default_frequency_range(sys_list, number_of_samples=number_of_samples)\n\n    for sys in sys_list:\n        # Get the magnitude and phase of the system\n        mag_tmp, phase_tmp, omega = sys.freqresp(omega)\n        mag = np.squeeze(mag_tmp)\n        phase = np.squeeze(phase_tmp)\n\n        # Convert to Nichols-plot format (phase in degrees,\n        # and magnitude in dB)\n        x = unwrap(sp.degrees(phase), 360)\n        y = 20*sp.log10(mag)\n\n        # Generate the plot\n        plt.plot(x, y)\n\n    plt.xlabel(\'Phase (deg)\')\n    plt.ylabel(\'Magnitude (dB)\')\n    plt.title(\'Nichols Plot\')\n\n    # Mark the -180 point\n    plt.plot([-180], [0], \'r+\')\n\n    # Add grid\n    if grid:\n        nichols_grid()\n\n\ndef nichols_grid(cl_mags=None, cl_phases=None, line_style=\'dotted\'):\n    """"""Nichols chart grid\n\n    Plots a Nichols chart grid on the current axis, or creates a new chart\n    if no plot already exists.\n\n    Parameters\n    ----------\n    cl_mags : array-like (dB), optional\n        Array of closed-loop magnitudes defining the iso-gain lines on a\n        custom Nichols chart.\n    cl_phases : array-like (degrees), optional\n        Array of closed-loop phases defining the iso-phase lines on a custom\n        Nichols chart. Must be in the range -360 < cl_phases < 0\n    line_style : string, optional\n        .. seealso:: https://matplotlib.org/gallery/lines_bars_and_markers/linestyles.html\n\n    Returns\n    -------\n    None\n    """"""\n    # Default chart size\n    ol_phase_min = -359.99\n    ol_phase_max = 0.0\n    ol_mag_min = -40.0\n    ol_mag_max = default_ol_mag_max = 50.0\n\n    # Find bounds of the current dataset, if there is one.\n    if plt.gcf().gca().has_data():\n        ol_phase_min, ol_phase_max, ol_mag_min, ol_mag_max = plt.axis()\n\n    # M-circle magnitudes.\n    if cl_mags is None:\n        # Default chart magnitudes\n        # The key set of magnitudes are always generated, since this\n        # guarantees a recognizable Nichols chart grid.\n        key_cl_mags = np.array([-40.0, -20.0, -12.0, -6.0, -3.0, -1.0, -0.5, 0.0,\n                                0.25, 0.5, 1.0, 3.0, 6.0, 12.0])\n        # Extend the range of magnitudes if necessary. The extended arange\n        # will end up empty if no extension is required. Assumes that closed-loop\n        # magnitudes are approximately aligned with open-loop magnitudes beyond\n        # the value of np.min(key_cl_mags)\n        cl_mag_step = -20.0  # dB\n        extended_cl_mags = np.arange(np.min(key_cl_mags),\n                                     ol_mag_min + cl_mag_step, cl_mag_step)\n        cl_mags = np.concatenate((extended_cl_mags, key_cl_mags))\n\n    # N-circle phases (should be in the range -360 to 0)\n    if cl_phases is None:\n        # Choose a reasonable set of default phases (denser if the open-loop\n        # data is restricted to a relatively small range of phases).\n        key_cl_phases = np.array([-0.25, -45.0, -90.0, -180.0, -270.0, -325.0, -359.75])\n        if np.abs(ol_phase_max - ol_phase_min) < 90.0:\n            other_cl_phases = np.arange(-10.0, -360.0, -10.0)\n        else:\n            other_cl_phases = np.arange(-10.0, -360.0, -20.0)\n        cl_phases = np.concatenate((key_cl_phases, other_cl_phases))\n    else:\n        assert ((-360.0 < np.min(cl_phases)) and (np.max(cl_phases) < 0.0))\n\n    # Find the M-contours\n    m = m_circles(cl_mags, phase_min=np.min(cl_phases), phase_max=np.max(cl_phases))\n    m_mag = 20*sp.log10(np.abs(m))\n    m_phase = sp.mod(sp.degrees(sp.angle(m)), -360.0)  # Unwrap\n\n    # Find the N-contours\n    n = n_circles(cl_phases, mag_min=np.min(cl_mags), mag_max=np.max(cl_mags))\n    n_mag = 20*sp.log10(np.abs(n))\n    n_phase = sp.mod(sp.degrees(sp.angle(n)), -360.0)  # Unwrap\n\n    # Plot the contours behind other plot elements.\n    # The ""phase offset"" is used to produce copies of the chart that cover\n    # the entire range of the plotted data, starting from a base chart computed\n    # over the range -360 < phase < 0. Given the range\n    # the base chart is computed over, the phase offset should be 0\n    # for -360 < ol_phase_min < 0.\n    phase_offset_min = 360.0*np.ceil(ol_phase_min/360.0)\n    phase_offset_max = 360.0*np.ceil(ol_phase_max/360.0) + 360.0\n    phase_offsets = np.arange(phase_offset_min, phase_offset_max, 360.0)\n\n    for phase_offset in phase_offsets:\n        # Draw M and N contours\n        plt.plot(m_phase + phase_offset, m_mag, color=\'lightgray\',\n                 linestyle=line_style, zorder=0)\n        plt.plot(n_phase + phase_offset, n_mag, color=\'lightgray\',\n                 linestyle=line_style, zorder=0)\n\n        # Add magnitude labels\n        for x, y, m in zip(m_phase[:][-1] + phase_offset, m_mag[:][-1], cl_mags):\n            align = \'right\' if m < 0.0 else \'left\'\n            plt.text(x, y, str(m) + \' dB\', size=\'small\', ha=align, color=\'gray\')\n\n    # Fit axes to generated chart\n    plt.axis([phase_offset_min - 360.0, phase_offset_max - 360.0,\n              np.min(cl_mags), np.max([ol_mag_max, default_ol_mag_max])])\n\n#\n# Utility functions\n#\n# This section of the code contains some utility functions for\n# generating Nichols plots\n#\n\n\ndef closed_loop_contours(Gcl_mags, Gcl_phases):\n    """"""Contours of the function Gcl = Gol/(1+Gol), where\n    Gol is an open-loop transfer function, and Gcl is a corresponding\n    closed-loop transfer function.\n\n    Parameters\n    ----------\n    Gcl_mags : array-like\n        Array of magnitudes of the contours\n    Gcl_phases : array-like\n        Array of phases in radians of the contours\n\n    Returns\n    -------\n    contours : complex array\n        Array of complex numbers corresponding to the contours.\n    """"""\n    # Compute the contours in Gcl-space. Since we\'re given closed-loop\n    # magnitudes and phases, this is just a case of converting them into\n    # a complex number.\n    Gcl = Gcl_mags*sp.exp(1.j*Gcl_phases)\n\n    # Invert Gcl = Gol/(1+Gol) to map the contours into the open-loop space\n    return Gcl/(1.0 - Gcl)\n\n\ndef m_circles(mags, phase_min=-359.75, phase_max=-0.25):\n    """"""Constant-magnitude contours of the function Gcl = Gol/(1+Gol), where\n    Gol is an open-loop transfer function, and Gcl is a corresponding\n    closed-loop transfer function.\n\n    Parameters\n    ----------\n    mags : array-like\n        Array of magnitudes in dB of the M-circles\n    phase_min : degrees\n        Minimum phase in degrees of the N-circles\n    phase_max : degrees\n        Maximum phase in degrees of the N-circles\n\n    Returns\n    -------\n    contours : complex array\n        Array of complex numbers corresponding to the contours.\n    """"""\n    # Convert magnitudes and phase range into a grid suitable for\n    # building contours\n    phases = sp.radians(sp.linspace(phase_min, phase_max, 2000))\n    Gcl_mags, Gcl_phases = sp.meshgrid(10.0**(mags/20.0), phases)\n    return closed_loop_contours(Gcl_mags, Gcl_phases)\n\n\ndef n_circles(phases, mag_min=-40.0, mag_max=12.0):\n    """"""Constant-phase contours of the function Gcl = Gol/(1+Gol), where\n    Gol is an open-loop transfer function, and Gcl is a corresponding\n    closed-loop transfer function.\n\n    Parameters\n    ----------\n    phases : array-like\n        Array of phases in degrees of the N-circles\n    mag_min : dB\n        Minimum magnitude in dB of the N-circles\n    mag_max : dB\n        Maximum magnitude in dB of the N-circles\n\n    Returns\n    -------\n    contours : complex array\n        Array of complex numbers corresponding to the contours.\n    """"""\n    # Convert phases and magnitude range into a grid suitable for\n    # building contours\n    mags = sp.linspace(10**(mag_min/20.0), 10**(mag_max/20.0), 2000)\n    Gcl_phases, Gcl_mags = sp.meshgrid(sp.radians(phases), mags)\n    return closed_loop_contours(Gcl_mags, Gcl_phases)\n\n\n# Function aliases\nnichols = nichols_plot\n'"
External_Libraries/python_control_master/control/phaseplot.py,22,"b'#! TODO: add module docstring\n# phaseplot.py - generate 2D phase portraits\n#\n# Author: Richard M. Murray\n# Date: 24 July 2011, converted from MATLAB version (2002); based on\n# a version by Kristi Morgansen\n#\n# Copyright (c) 2011 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#   1. Redistributions of source code must retain the above copyright\n#      notice, this list of conditions and the following disclaimer.\n#\n#   2. Redistributions in binary form must reproduce the above copyright\n#      notice, this list of conditions and the following disclaimer in the\n#      documentation and/or other materials provided with the distribution.\n#\n#   3. The name of the author may not be used to endorse or promote products\n#      derived from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS\'\' AND ANY EXPRESS OR\n# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n# DISCLAIMED. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,\n# INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,\n# STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n# Python 3 compatibility\nfrom __future__ import print_function\n\nimport numpy as np\nimport matplotlib.pyplot as mpl\n\nfrom scipy.integrate import odeint\nfrom .exception import ControlNotImplemented\n\n__all__ = [\'phase_plot\', \'box_grid\']\n\n\ndef _find(condition):\n    """"""Returns indices where ravel(a) is true.\n    Private implementation of deprecated matplotlib.mlab.find\n    """"""\n    return np.nonzero(np.ravel(condition))[0]\n\n\ndef phase_plot(odefun, X=None, Y=None, scale=1, X0=None, T=None,\n              lingrid=None, lintime=None, logtime=None, timepts=None,\n              parms=(), verbose=True):\n    """"""\n    Phase plot for 2D dynamical systems\n\n    Produces a vector field or stream line plot for a planar system.\n\n    Call signatures:\n      phase_plot(func, X, Y, ...) - display vector field on meshgrid\n      phase_plot(func, X, Y, scale, ...) - scale arrows\n      phase_plot(func. X0=(...), T=Tmax, ...) - display stream lines\n      phase_plot(func, X, Y, X0=[...], T=Tmax, ...) - plot both\n      phase_plot(func, X0=[...], T=Tmax, lingrid=N, ...) - plot both\n      phase_plot(func, X0=[...], lintime=N, ...) - stream lines with arrows\n\n    Parameters\n    ----------\n    func : callable(x, t, ...)\n        Computes the time derivative of y (compatible with odeint).\n        The function should be the same for as used for\n        scipy.integrate.  Namely, it should be a function of the form\n        dxdt = F(x, t) that accepts a state x of dimension 2 and\n        returns a derivative dx/dt of dimension 2.\n\n    X, Y: 3-element sequences, optional, as [start, stop, npts]\n        Two 3-element sequences specifying x and y coordinates of a\n        grid.  These arguments are passed to linspace and meshgrid to\n        generate the points at which the vector field is plotted.  If\n        absent (or None), the vector field is not plotted.\n\n    scale: float, optional\n        Scale size of arrows; default = 1\n\n    X0: ndarray of initial conditions, optional\n        List of initial conditions from which streamlines are plotted.\n        Each initial condition should be a pair of numbers.\n\n    T: array-like or number, optional\n        Length of time to run simulations that generate streamlines.\n        If a single number, the same simulation time is used for all\n        initial conditions.  Otherwise, should be a list of length\n        len(X0) that gives the simulation time for each initial\n        condition.  Default value = 50.\n\n    lingrid = N or (N, M): integer or 2-tuple of integers, optional\n        If X0 is given and X, Y are missing, a grid of arrows is\n        produced using the limits of the initial conditions, with N\n        grid points in each dimension or N grid points in x and M grid\n        points in y.\n\n    lintime = N: integer, optional\n        Draw N arrows using equally space time points\n\n    logtime = (N, lambda): (integer, float), optional\n        Draw N arrows using exponential time constant lambda\n\n    timepts = [t1, t2, ...]: array-like, optional\n        Draw arrows at the given list times\n\n    parms: tuple, optional\n        List of parameters to pass to vector field: `func(x, t, *parms)`\n\n    See also\n    --------\n    box_grid : construct box-shaped grid of initial conditions\n\n    Examples\n    --------\n    """"""\n\n    #\n    # Figure out ranges for phase plot (argument processing)\n    #\n    #! TODO: need to add error checking to arguments\n    #! TODO: think through proper action if multiple options are given\n    #\n    autoFlag = False; logtimeFlag = False; timeptsFlag = False; Narrows = 0;\n\n    if lingrid is not None:\n        autoFlag = True;\n        Narrows = lingrid;\n        if (verbose):\n            print(\'Using auto arrows\\n\')\n\n    elif logtime is not None:\n        logtimeFlag = True;\n        Narrows = logtime[0];\n        timefactor = logtime[1];\n        if (verbose):\n            print(\'Using logtime arrows\\n\')\n\n    elif timepts is not None:\n        timeptsFlag = True;\n        Narrows = len(timepts);\n\n    # Figure out the set of points for the quiver plot\n    #! TODO: Add sanity checks\n    elif (X is not None and Y is not None):\n        (x1, x2) = np.meshgrid(\n            np.linspace(X[0], X[1], X[2]),\n            np.linspace(Y[0], Y[1], Y[2]))\n        Narrows = len(x1)\n\n    else:\n        # If we weren\'t given any grid points, don\'t plot arrows\n        Narrows = 0;\n\n    if ((not autoFlag) and (not logtimeFlag) and (not timeptsFlag)\n        and (Narrows > 0)):\n        # Now calculate the vector field at those points\n        (nr,nc) = x1.shape;\n        dx = np.empty((nr, nc, 2))\n        for i in range(nr):\n            for j in range(nc):\n                dx[i, j, :] = np.squeeze(odefun((x1[i,j], x2[i,j]), 0, *parms))\n\n        # Plot the quiver plot\n        #! TODO: figure out arguments to make arrows show up correctly\n        if scale is None:\n            mpl.quiver(x1, x2, dx[:,:,1], dx[:,:,2], angles=\'xy\')\n        elif (scale != 0):\n            #! TODO: optimize parameters for arrows\n            #! TODO: figure out arguments to make arrows show up correctly\n            xy = mpl.quiver(x1, x2, dx[:,:,0]*np.abs(scale),\n                            dx[:,:,1]*np.abs(scale), angles=\'xy\')\n            # set(xy, \'LineWidth\', PP_arrow_linewidth, \'Color\', \'b\');\n\n        #! TODO: Tweak the shape of the plot\n        # a=gca; set(a,\'DataAspectRatio\',[1,1,1]);\n        # set(a,\'XLim\',X(1:2)); set(a,\'YLim\',Y(1:2));\n        mpl.xlabel(\'x1\'); mpl.ylabel(\'x2\');\n\n    # See if we should also generate the streamlines\n    if X0 is None or len(X0) == 0:\n        return\n\n    # Convert initial conditions to a numpy array\n    X0 = np.array(X0);\n    (nr, nc) = np.shape(X0);\n\n    # Generate some empty matrices to keep arrow information\n    x1 = np.empty((nr, Narrows)); x2 = np.empty((nr, Narrows));\n    dx = np.empty((nr, Narrows, 2))\n\n    # See if we were passed a simulation time\n    if T is None:\n        T = 50\n\n    # Parse the time we were passed\n    TSPAN = T;\n    if (isinstance(T, (int, float))):\n        TSPAN = np.linspace(0, T, 100);\n\n    # Figure out the limits for the plot\n    if scale is None:\n        # Assume that the current axis are set as we want them\n        alim = mpl.axis();\n        xmin = alim[0]; xmax = alim[1];\n        ymin = alim[2]; ymax = alim[3];\n    else:\n        # Use the maximum extent of all trajectories\n        xmin = np.min(X0[:,0]); xmax = np.max(X0[:,0]);\n        ymin = np.min(X0[:,1]); ymax = np.max(X0[:,1]);\n\n    # Generate the streamlines for each initial condition\n    for i in range(nr):\n        state = odeint(odefun, X0[i], TSPAN, args=parms);\n        time = TSPAN\n\n        mpl.plot(state[:,0], state[:,1])\n        #! TODO: add back in colors for stream lines\n        # PP_stream_color(np.mod(i-1, len(PP_stream_color))+1));\n        # set(h[i], \'LineWidth\', PP_stream_linewidth);\n\n        # Plot arrows if quiver parameters were \'auto\'\n        if (autoFlag or logtimeFlag or timeptsFlag):\n            # Compute the locations of the arrows\n            #! TODO: check this logic to make sure it works in python\n            for j in range(Narrows):\n\n                # Figure out starting index; headless arrows start at 0\n                k = -1 if scale is None else 0;\n\n                # Figure out what time index to use for the next point\n                if (autoFlag):\n                    # Use a linear scaling based on ODE time vector\n                    tind = np.floor((len(time)/Narrows) * (j-k)) + k;\n                elif (logtimeFlag):\n                    # Use an exponential time vector\n                    # MATLAB: tind = find(time < (j-k) / lambda, 1, \'last\');\n                    tarr = _find(time < (j-k) / timefactor);\n                    tind = tarr[-1] if len(tarr) else 0;\n                elif (timeptsFlag):\n                    # Use specified time points\n                    # MATLAB: tind = find(time < Y[j], 1, \'last\');\n                    tarr = _find(time < timepts[j]);\n                    tind = tarr[-1] if len(tarr) else 0;\n\n                # For tailless arrows, skip the first point\n                if tind == 0 and scale is None:\n                    continue;\n\n                # Figure out the arrow at this point on the curve\n                x1[i,j] = state[tind, 0];\n                x2[i,j] = state[tind, 1];\n\n                # Skip arrows outside of initial condition box\n                if (scale is not None or\n                     (x1[i,j] <= xmax and x1[i,j] >= xmin and\n                      x2[i,j] <= ymax and x2[i,j] >= ymin)):\n                    v = odefun((x1[i,j], x2[i,j]), 0, *parms)\n                    dx[i, j, 0] = v[0]; dx[i, j, 1] = v[1];\n                else:\n                    dx[i, j, 0] = 0; dx[i, j, 1] = 0;\n\n    # Set the plot shape before plotting arrows to avoid warping\n    # a=gca;\n    # if (scale != None):\n    #     set(a,\'DataAspectRatio\', [1,1,1]);\n    # if (xmin != xmax and ymin != ymax):\n    #     mpl.axis([xmin, xmax, ymin, ymax]);\n    # set(a, \'Box\', \'on\');\n\n    # Plot arrows on the streamlines\n    if scale is None and Narrows > 0:\n        # Use a tailless arrow\n        #! TODO: figure out arguments to make arrows show up correctly\n        mpl.quiver(x1, x2, dx[:,:,0], dx[:,:,1], angles=\'xy\')\n    elif (scale != 0 and Narrows > 0):\n        #! TODO: figure out arguments to make arrows show up correctly\n        xy = mpl.quiver(x1, x2, dx[:,:,0]*abs(scale), dx[:,:,1]*abs(scale),\n                        angles=\'xy\')\n        # set(xy, \'LineWidth\', PP_arrow_linewidth);\n        # set(xy, \'AutoScale\', \'off\');\n        # set(xy, \'AutoScaleFactor\', 0);\n\n    if (scale < 0):\n        bp = mpl.plot(x1, x2, \'b.\');\t\t# add dots at base\n        # set(bp, \'MarkerSize\', PP_arrow_markersize);\n\n    return;\n\n# Utility function for generating initial conditions around a box\ndef box_grid(xlimp, ylimp):\n    """"""box_grid   generate list of points on edge of box\n\n    list = box_grid([xmin xmax xnum], [ymin ymax ynum]) generates a\n    list of points that correspond to a uniform grid at the end of the\n    box defined by the corners [xmin ymin] and [xmax ymax].\n    """"""\n\n    sx10 = np.linspace(xlimp[0], xlimp[1], xlimp[2])\n    sy10 = np.linspace(ylimp[0], ylimp[1], ylimp[2])\n\n    sx1 = np.hstack((0, sx10, 0*sy10+sx10[0], sx10, 0*sy10+sx10[-1]))\n    sx2 = np.hstack((0, 0*sx10+sy10[0], sy10, 0*sx10+sy10[-1], sy10))\n\n    return np.transpose( np.vstack((sx1, sx2)) )\n'"
External_Libraries/python_control_master/control/pzmap.py,0,"b'# pzmap.py - computations involving poles and zeros\n#\n# Author: Richard M. Murray\n# Date: 7 Sep 09\n#\n# This file contains functions that compute poles, zeros and related\n# quantities for a linear system.\n#\n# Copyright (c) 2009 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id:pzmap.py 819 2009-05-29 21:28:07Z murray $\n\nfrom numpy import real, imag, linspace, exp, cos, sin, sqrt\nfrom math import pi\nfrom .lti import LTI, isdtime, isctime\nfrom .grid import sgrid, zgrid, nogrid\nfrom . import config\n\n__all__ = [\'pzmap\']\n\n\n# Define default parameter values for this module\n_pzmap_defaults = {\n    \'pzmap.grid\':False,         # Plot omega-damping grid\n    \'pzmap.Plot\':True,          # Generate plot using Matplotlib\n}\n\n\n# TODO: Implement more elegant cross-style axes. See:\n#    http://matplotlib.sourceforge.net/examples/axes_grid/demo_axisline_style.html\n#    http://matplotlib.sourceforge.net/examples/axes_grid/demo_curvelinear_grid.html\ndef pzmap(sys, Plot=True, grid=False, title=\'Pole Zero Map\'):\n    """"""\n    Plot a pole/zero map for a linear system.\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace or TransferFunction)\n        Linear system for which poles and zeros are computed.\n    Plot: bool\n        If ``True`` a graph is generated with Matplotlib,\n        otherwise the poles and zeros are only computed and returned.\n    grid: boolean (default = False)\n        If True plot omega-damping grid.\n\n    Returns\n    -------\n    pole: array\n        The systems poles\n    zeros: array\n        The system\'s zeros.\n    """"""\n    # Get parameter values\n    Plot = config._get_param(\'rlocus\', \'Plot\', Plot, True)\n    grid = config._get_param(\'rlocus\', \'grid\', grid, False)\n    \n    if not isinstance(sys, LTI):\n        raise TypeError(\'Argument ``sys``: must be a linear system.\')\n\n    poles = sys.pole()\n    zeros = sys.zero()\n\n    if (Plot):\n        import matplotlib.pyplot as plt\n\n        if grid:\n            if isdtime(sys, strict=True):\n                ax, fig = zgrid()\n            else:\n                ax, fig = sgrid()\n        else:\n            ax, fig = nogrid()\n\n        # Plot the locations of the poles and zeros\n        if len(poles) > 0:\n            ax.scatter(real(poles), imag(poles), s=50, marker=\'x\', facecolors=\'k\')\n        if len(zeros) > 0:\n            ax.scatter(real(zeros), imag(zeros), s=50, marker=\'o\',\n                        facecolors=\'none\', edgecolors=\'k\')\n\n\n        plt.title(title)\n\n    # Return locations of poles and zeros as a tuple\n    return poles, zeros\n'"
External_Libraries/python_control_master/control/rlocus.py,77,"b'# rlocus.py - code for computing a root locus plot\n# Code contributed by Ryan Krauss, 2010\n#\n# Copyright (c) 2010 by Ryan Krauss\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# RMM, 17 June 2010: modified to be a standalone piece of code\n#   * Added BSD copyright info to file (per Ryan)\n#   * Added code to convert (num, den) to poly1d\'s if they aren\'t already.\n#     This allows Ryan\'s code to run on a standard signal.ltisys object\n#     or a control.TransferFunction object.\n#   * Added some comments to make sure I understand the code\n#\n# RMM, 2 April 2011: modified to work with new LTI structure (see ChangeLog)\n#   * Not tested: should still work on signal.ltisys objects\n#\n# $Id$\n\n# Packages used by this module\nfrom functools import partial\nimport numpy as np\nimport matplotlib\nimport matplotlib.pyplot as plt\nfrom scipy import array, poly1d, row_stack, zeros_like, real, imag\nimport scipy.signal             # signal processing toolbox\nimport pylab                    # plotting routines\nfrom .xferfcn import _convert_to_transfer_function\nfrom .exception import ControlMIMONotImplemented\nfrom .sisotool import _SisotoolUpdate\nfrom . import config\n\n__all__ = [\'root_locus\', \'rlocus\',\'root_locus_AMaDiA\']\n\n# Default values for module parameters\n_rlocus_defaults = {\n    \'rlocus.grid\':True,\n    \'rlocus.plotstr\':\'b\' if int(matplotlib.__version__[0]) == 1 else \'C0\',\n    \'rlocus.PrintGain\':True,\n    \'rlocus.Plot\':True\n}\n\n\n# Main function: compute a root locus diagram\ndef root_locus(sys, kvect=None, xlim=None, ylim=None,\n               plotstr=None, Plot=True, PrintGain=None, grid=None, **kwargs):\n\n    """"""Root locus plot\n\n    Calculate the root locus by finding the roots of 1+k*TF(s)\n    where TF is self.num(s)/self.den(s) and each k is an element\n    of kvect.\n\n    Parameters\n    ----------\n    sys : LTI object\n        Linear input/output systems (SISO only, for now).\n    kvect : list or ndarray, optional\n        List of gains to use in computing diagram.\n    xlim : tuple or list, optional\n        Set limits of x axis, normally with tuple (see matplotlib.axes).\n    ylim : tuple or list, optional\n        Set limits of y axis, normally with tuple (see matplotlib.axes).\n    Plot : boolean, optional\n        If True (default), plot root locus diagram.\n    PrintGain : bool\n        If True (default), report mouse clicks when close to the root locus\n        branches, calculate gain, damping and print.\n    grid : bool\n        If True plot omega-damping grid.  Default is False.\n\n    Returns\n    -------\n    rlist : ndarray\n        Computed root locations, given as a 2D array\n    klist : ndarray or list\n        Gains used.  Same as klist keyword argument if provided.\n    """"""\n    # Get parameter values\n    plotstr = config._get_param(\'rlocus\', \'plotstr\', plotstr, _rlocus_defaults)\n    grid = config._get_param(\'rlocus\', \'grid\', grid, _rlocus_defaults)\n    PrintGain = config._get_param(\n        \'rlocus\', \'PrintGain\', PrintGain, _rlocus_defaults)\n\n    # Convert numerator and denominator to polynomials if they aren\'t\n    (nump, denp) = _systopoly1d(sys)\n\n    if kvect is None:\n        start_mat = _RLFindRoots(nump, denp, [1])\n        kvect, mymat, xlim, ylim = _default_gains(nump, denp, xlim, ylim)\n    else:\n        start_mat = _RLFindRoots(nump, denp, [kvect[0]])\n        mymat = _RLFindRoots(nump, denp, kvect)\n        mymat = _RLSortRoots(mymat)\n\n    # Check for sisotool mode\n    sisotool = False if \'sisotool\' not in kwargs else True\n\n    # Create the Plot\n    if Plot:\n        if sisotool:\n            f = kwargs[\'fig\']\n            ax = f.axes[1]\n\n        else:\n            figure_number = pylab.get_fignums()\n            figure_title = [\n                pylab.figure(numb).canvas.get_window_title()\n                for numb in figure_number]\n            new_figure_name = ""Root Locus""\n            rloc_num = 1\n            while new_figure_name in figure_title:\n                new_figure_name = ""Root Locus "" + str(rloc_num)\n                rloc_num += 1\n            f = pylab.figure(new_figure_name)\n            ax = pylab.axes()\n\n        if PrintGain and not sisotool:\n            f.canvas.mpl_connect(\n                \'button_release_event\',\n                partial(_RLClickDispatcher, sys=sys, fig=f,\n                        ax_rlocus=f.axes[0], plotstr=plotstr))\n\n        elif sisotool:\n            f.axes[1].plot(\n                [root.real for root in start_mat],\n                [root.imag for root in start_mat],\n                \'m.\', marker=\'s\', markersize=8, zorder=20, label=\'gain_point\')\n            f.suptitle(\n                ""Clicked at: %10.4g%+10.4gj  gain: %10.4g  damp: %10.4g"" %\n                (start_mat[0][0].real, start_mat[0][0].imag,\n                 1, -1 * start_mat[0][0].real / abs(start_mat[0][0])),\n                fontsize=12 if int(matplotlib.__version__[0]) == 1 else 10)\n            f.canvas.mpl_connect(\n                \'button_release_event\',\n                partial(_RLClickDispatcher, sys=sys, fig=f,\n                        ax_rlocus=f.axes[1], plotstr=plotstr,\n                        sisotool=sisotool,\n                        bode_plot_params=kwargs[\'bode_plot_params\'],\n                        tvect=kwargs[\'tvect\']))\n\n        # zoom update on xlim/ylim changed, only then data on new limits\n        # is available, i.e., cannot combine with _RLClickDispatcher\n        dpfun = partial(\n            _RLZoomDispatcher, sys=sys, ax_rlocus=ax, plotstr=plotstr)\n        # TODO: the next too lines seem to take a long time to execute\n        # TODO: is there a way to speed them up?  (RMM, 6 Jun 2019)\n        ax.callbacks.connect(\'xlim_changed\', dpfun)\n        ax.callbacks.connect(\'ylim_changed\', dpfun)\n\n        # plot open loop poles\n        poles = array(denp.r)\n        ax.plot(real(poles), imag(poles), \'x\')\n\n        # plot open loop zeros\n        zeros = array(nump.r)\n        if zeros.size > 0:\n            ax.plot(real(zeros), imag(zeros), \'o\')\n\n        # Now plot the loci\n        for index, col in enumerate(mymat.T):\n            ax.plot(real(col), imag(col), plotstr, label=\'rootlocus\')\n\n        # Set up plot axes and labels\n        if xlim:\n            ax.set_xlim(xlim)\n        if ylim:\n            ax.set_ylim(ylim)\n\n        ax.set_xlabel(\'Real\')\n        ax.set_ylabel(\'Imaginary\')\n        if grid and sisotool:\n            _sgrid_func(f)\n        elif grid:\n            _sgrid_func()\n        else:\n            ax.axhline(0., linestyle=\':\', color=\'k\', zorder=-20)\n            ax.axvline(0., linestyle=\':\', color=\'k\')\n        \n\n    return mymat, kvect\n\n\n# Main function: compute a root locus diagram\ndef root_locus_AMaDiA(sys, ax, kvect=None, xlim=None, ylim=None,\n               plotstr=None, Plot=True, PrintGain=None, grid=None, App=None, **kwargs):\n\n    """"""Root locus plot\n\n    Calculate the root locus by finding the roots of 1+k*TF(s)\n    where TF is self.num(s)/self.den(s) and each k is an element\n    of kvect.\n\n    Parameters\n    ----------\n    sys : LTI object\n        Linear input/output systems (SISO only, for now).\n    kvect : list or ndarray, optional\n        List of gains to use in computing diagram.\n    xlim : tuple or list, optional\n        Set limits of x axis, normally with tuple (see matplotlib.axes).\n    ylim : tuple or list, optional\n        Set limits of y axis, normally with tuple (see matplotlib.axes).\n    Plot : boolean, optional\n        If True (default), plot root locus diagram.\n    PrintGain : bool\n        If True (default), report mouse clicks when close to the root locus\n        branches, calculate gain, damping and print.\n    grid : bool\n        If True plot omega-damping grid.  Default is False.\n\n    Returns\n    -------\n    rlist : ndarray\n        Computed root locations, given as a 2D array\n    klist : ndarray or list\n        Gains used.  Same as klist keyword argument if provided.\n    """"""\n    # Get parameter values\n    plotstr = config._get_param(\'rlocus\', \'plotstr\', plotstr, _rlocus_defaults)\n    grid = config._get_param(\'rlocus\', \'grid\', grid, _rlocus_defaults)\n    PrintGain = config._get_param(\n        \'rlocus\', \'PrintGain\', PrintGain, _rlocus_defaults)\n\n    xlim_b, ylim_b = xlim, ylim\n    kvect_b = kvect\n    # Convert numerator and denominator to polynomials if they aren\'t\n    try:\n        (nump, denp) = _systopoly1d(sys)\n\n        if kvect is None:\n            start_mat = _RLFindRoots(nump, denp, [1])\n            kvect, mymat, xlim, ylim = _default_gains(nump, denp, xlim, ylim)\n        else:\n            start_mat = _RLFindRoots(nump, denp, [kvect[0]])\n            mymat = _RLFindRoots(nump, denp, kvect)\n            mymat = _RLSortRoots(mymat)\n\n        # Check for sisotool mode\n        sisotool = False if \'sisotool\' not in kwargs else True\n\n        # Create the Plot\n        if Plot:\n            figure_number = pylab.get_fignums()\n            figure_title = [\n                pylab.figure(numb).canvas.get_window_title()\n                for numb in figure_number]\n            new_figure_name = ""Root Locus""\n            rloc_num = 1\n            while new_figure_name in figure_title:\n                new_figure_name = ""Root Locus "" + str(rloc_num)\n                rloc_num += 1\n            f = pylab.figure(new_figure_name)\n\n            # zoom update on xlim/ylim changed, only then data on new limits\n            # is available, i.e., cannot combine with _RLClickDispatcher\n            dpfun = partial(\n                _RLZoomDispatcher, sys=sys, ax_rlocus=ax, plotstr=plotstr)\n            # TODO: the next too lines seem to take a long time to execute\n            # TODO: is there a way to speed them up?  (RMM, 6 Jun 2019)\n            #ax.callbacks.connect(\'xlim_changed\', dpfun)\n            #ax.callbacks.connect(\'ylim_changed\', dpfun)\n\n            # plot open loop poles\n            poles = array(denp.r)\n            ax.plot(real(poles), imag(poles), \'x\', c=""red"" if App == None else App.PenColours[""Red""].color().name(0))\n\n            # plot open loop zeros\n            zeros = array(nump.r)\n            if zeros.size > 0:\n                ax.plot(real(zeros), imag(zeros), \'o\', c=""orange"" if App == None else App.PenColours[""Orange""].color().name(0))\n\n            # Now plot the loci\n            setLabel = True\n            for index, col in enumerate(mymat.T):\n                if setLabel:\n                    ax.plot(real(col), imag(col), plotstr, label=\'V>0\', c=""m"" if App == None else App.PenColours[""Magenta""].color().name(0))\n                    setLabel = False\n                else:\n                    ax.plot(real(col), imag(col), plotstr, c=""m"" if App == None else App.PenColours[""Magenta""].color().name(0))\n\n            # Set up plot axes and labels\n            if xlim:\n                ax.set_xlim(xlim)\n            if ylim:\n                ax.set_ylim(ylim)\n\n            ax.set_xlabel(\'Real\')\n            ax.set_ylabel(\'Imaginary\')\n            if grid and sisotool:\n                _sgrid_func(f)\n            elif grid:\n                _sgrid_func()\n            else:\n                ax.axhline(0., linestyle=\':\', color=\'k\' if App == None else App.PenColours[""Black""].color().name(0), zorder=-20)\n                ax.axvline(0., linestyle=\':\', color=\'k\' if App == None else App.PenColours[""Black""].color().name(0))\n        r_mymat, r_kvect = mymat, kvect\n    except:\n        r_mymat, r_kvect = None, None\n    #---------------------- INVERSE ----------------------\n    try:\n        sys = -1*sys\n        # Convert numerator and denominator to polynomials if they aren\'t\n        (nump, denp) = _systopoly1d(sys)\n\n        if kvect_b is None:\n            start_mat = _RLFindRoots(nump, denp, [1])\n            kvect, mymat, xlim_n, ylim_n = _default_gains(nump, denp, xlim_b, ylim_b)\n            if xlim_n[0]<xlim[0]: xlim[0] = xlim_n[0]\n            if xlim_n[1]>xlim[1]: xlim[1] = xlim_n[1]\n            if ylim_n[0]<ylim[0]: ylim[0] = ylim_n[0]\n            if ylim_n[1]>ylim[1]: ylim[1] = ylim_n[1]\n        else:\n            start_mat = _RLFindRoots(nump, denp, [kvect[0]])\n            mymat = _RLFindRoots(nump, denp, kvect)\n            mymat = _RLSortRoots(mymat)\n\n        # Check for sisotool mode\n        sisotool = False if \'sisotool\' not in kwargs else True\n\n        # Create the Plot\n        if Plot:\n            figure_number = pylab.get_fignums()\n            figure_title = [\n                pylab.figure(numb).canvas.get_window_title()\n                for numb in figure_number]\n            new_figure_name = ""Root Locus""\n            rloc_num = 1\n            while new_figure_name in figure_title:\n                new_figure_name = ""Root Locus "" + str(rloc_num)\n                rloc_num += 1\n            f = pylab.figure(new_figure_name)\n\n            # zoom update on xlim/ylim changed, only then data on new limits\n            # is available, i.e., cannot combine with _RLClickDispatcher\n            dpfun = partial(\n                _RLZoomDispatcher, sys=sys, ax_rlocus=ax, plotstr=plotstr)\n            # TODO: the next too lines seem to take a long time to execute\n            # TODO: is there a way to speed them up?  (RMM, 6 Jun 2019)\n            #ax.callbacks.connect(\'xlim_changed\', dpfun)\n            #ax.callbacks.connect(\'ylim_changed\', dpfun)\n\n            ## plot open loop poles\n            #poles = array(denp.r)\n            #ax.plot(real(poles), imag(poles), \'x\', c=""red"")\n            #\n            ## plot open loop zeros\n            #zeros = array(nump.r)\n            #if zeros.size > 0:\n            #    ax.plot(real(zeros), imag(zeros), \'o\', c=""orange"")\n\n            # Now plot the loci\n            setLabel = True\n            for index, col in enumerate(mymat.T):\n                if setLabel:\n                    ax.plot(real(col), imag(col), plotstr, label=\'V<0\', c=""g"" if App == None else App.PenColours[""Green""].color().name(0))\n                    setLabel = False\n                else:\n                    ax.plot(real(col), imag(col), plotstr, c=""g"" if App == None else App.PenColours[""Green""].color().name(0))\n\n\n            ax.set_xlabel(\'Real\')\n            ax.set_ylabel(\'Imaginary\')\n            if grid and sisotool:\n                _sgrid_func(f)\n            elif grid:\n                _sgrid_func()\n            else:\n                ax.axhline(0., linestyle=\':\', color=\'k\' if App == None else App.PenColours[""Black""].color().name(0), zorder=-20)\n                ax.axvline(0., linestyle=\':\', color=\'k\' if App == None else App.PenColours[""Black""].color().name(0))\n    except:\n        pass\n    if Plot:\n        # Set up plot axes and labels\n        if xlim:\n            ax.set_xlim(xlim)\n        if ylim:\n            ax.set_ylim(ylim)\n        \n\n    return r_mymat, r_kvect\n\n\ndef _default_gains(num, den, xlim, ylim, zoom_xlim=None, zoom_ylim=None):\n    """"""Unsupervised gains calculation for root locus plot.\n\n    References\n    ----------\n    Ogata, K. (2002). Modern control engineering (4th ed.). Upper\n    Saddle River, NJ : New Delhi: Prentice Hall..\n\n    """"""\n    k_break, real_break = _break_points(num, den)\n    kmax = _k_max(num, den, real_break, k_break)\n    kvect = np.hstack((np.linspace(0, kmax, 50), np.real(k_break)))\n    kvect.sort()\n\n    mymat = _RLFindRoots(num, den, kvect)\n    mymat = _RLSortRoots(mymat)\n    open_loop_poles = den.roots\n    open_loop_zeros = num.roots\n\n    if open_loop_zeros.size != 0 and \\\n       open_loop_zeros.size < open_loop_poles.size:\n        open_loop_zeros_xl = np.append(\n            open_loop_zeros,\n            np.ones(open_loop_poles.size - open_loop_zeros.size)\n            * open_loop_zeros[-1])\n        mymat_xl = np.append(mymat, open_loop_zeros_xl)\n    else:\n        mymat_xl = mymat\n    singular_points = np.concatenate((num.roots, den.roots), axis=0)\n    important_points = np.concatenate((singular_points, real_break), axis=0)\n    important_points = np.concatenate((important_points, np.zeros(2)), axis=0)\n    mymat_xl = np.append(mymat_xl, important_points)\n\n    false_gain = float(den.coeffs[0]) / float(num.coeffs[0])\n    if false_gain < 0 and not den.order > num.order:\n        # TODO: make error message more understandable\n        raise ValueError(""Not implemented support for 0 degrees root locus ""\n                         ""with equal order of numerator and denominator."")\n\n    if xlim is None and false_gain > 0:\n        x_tolerance = 0.05 * (np.max(np.real(mymat_xl))\n                              - np.min(np.real(mymat_xl)))\n        xlim = _ax_lim(mymat_xl)\n    elif xlim is None and false_gain < 0:\n        axmin = np.min(np.real(important_points)) \\\n            - (np.max(np.real(important_points))\n               - np.min(np.real(important_points)))\n        axmin = np.min(np.array([axmin, np.min(np.real(mymat_xl))]))\n        axmax = np.max(np.real(important_points)) \\\n            + np.max(np.real(important_points)) \\\n            - np.min(np.real(important_points))\n        axmax = np.max(np.array([axmax, np.max(np.real(mymat_xl))]))\n        xlim = [axmin, axmax]\n        x_tolerance = 0.05 * (axmax - axmin)\n    else:\n        x_tolerance = 0.05 * (xlim[1] - xlim[0])\n\n    if ylim is None:\n        y_tolerance = 0.05 * (np.max(np.imag(mymat_xl))\n                              - np.min(np.imag(mymat_xl)))\n        ylim = _ax_lim(mymat_xl * 1j)\n    else:\n        y_tolerance = 0.05 * (ylim[1] - ylim[0])\n\n    # Figure out which points are spaced too far apart\n    if x_tolerance == 0:\n        # Root locus is on imaginary axis (rare), use just y distance\n        tolerance = y_tolerance\n    elif y_tolerance == 0:\n        # Root locus is on imaginary axis (common), use just x distance\n        tolerance = x_tolerance\n    else:\n        tolerance = np.min([x_tolerance, y_tolerance])\n    indexes_too_far = _indexes_filt(mymat, tolerance, zoom_xlim, zoom_ylim)\n\n    # Add more points into the root locus for points that are too far apart\n    while len(indexes_too_far) > 0 and kvect.size < 5000:\n        for counter, index in enumerate(indexes_too_far):\n            index = index + counter*3\n            new_gains = np.linspace(kvect[index], kvect[index + 1], 5)\n            new_points = _RLFindRoots(num, den, new_gains[1:4])\n            kvect = np.insert(kvect, index + 1, new_gains[1:4])\n            mymat = np.insert(mymat, index + 1, new_points, axis=0)\n\n        mymat = _RLSortRoots(mymat)\n        indexes_too_far = _indexes_filt(mymat, tolerance, zoom_xlim, zoom_ylim)\n\n    new_gains = kvect[-1] * np.hstack((np.logspace(0, 3, 4)))\n    new_points = _RLFindRoots(num, den, new_gains[1:4])\n    kvect = np.append(kvect, new_gains[1:4])\n    mymat = np.concatenate((mymat, new_points), axis=0)\n    mymat = _RLSortRoots(mymat)\n    return kvect, mymat, xlim, ylim\n\n\ndef _indexes_filt(mymat, tolerance, zoom_xlim=None, zoom_ylim=None):\n    """"""Calculate the distance between points and return the indexes.\n\n    Filter the indexes so only the resolution of points within the xlim and\n    ylim is improved when zoom is used.\n\n    """"""\n    distance_points = np.abs(np.diff(mymat, axis=0))\n    indexes_too_far = list(np.unique(np.where(distance_points > tolerance)[0]))\n\n    if zoom_xlim is not None and zoom_ylim is not None:\n        x_tolerance_zoom = 0.05 * (zoom_xlim[1] - zoom_xlim[0])\n        y_tolerance_zoom = 0.05 * (zoom_ylim[1] - zoom_ylim[0])\n        tolerance_zoom = np.min([x_tolerance_zoom, y_tolerance_zoom])\n        indexes_too_far_zoom = list(\n            np.unique(np.where(distance_points > tolerance_zoom)[0]))\n        indexes_too_far_filtered = []\n\n        for index in indexes_too_far_zoom:\n            for point in mymat[index]:\n                if (zoom_xlim[0] <= point.real <= zoom_xlim[1]) and \\\n                   (zoom_ylim[0] <= point.imag <= zoom_ylim[1]):\n                    indexes_too_far_filtered.append(index)\n                    break\n\n        # Check if zoom box is not overshot & insert points where neccessary\n        if len(indexes_too_far_filtered) == 0 and len(mymat) < 500:\n            limits = [zoom_xlim[0], zoom_xlim[1], zoom_ylim[0], zoom_ylim[1]]\n            for index, limit in enumerate(limits):\n                if index <= 1:\n                    asign = np.sign(real(mymat)-limit)\n                else:\n                    asign = np.sign(imag(mymat) - limit)\n                signchange = ((np.roll(asign, 1, axis=0)\n                               - asign) != 0).astype(int)\n                signchange[0] = np.zeros((len(mymat[0])))\n                if len(np.where(signchange == 1)[0]) > 0:\n                    indexes_too_far_filtered.append(\n                        np.where(signchange == 1)[0][0]-1)\n\n        if len(indexes_too_far_filtered) > 0:\n            if indexes_too_far_filtered[0] != 0:\n                indexes_too_far_filtered.insert(\n                    0, indexes_too_far_filtered[0]-1)\n            if not indexes_too_far_filtered[-1] + 1 >= len(mymat) - 2:\n                indexes_too_far_filtered.append(\n                    indexes_too_far_filtered[-1] + 1)\n\n        indexes_too_far.extend(indexes_too_far_filtered)\n\n    indexes_too_far = list(np.unique(indexes_too_far))\n    indexes_too_far.sort()\n    return indexes_too_far\n\n\ndef _break_points(num, den):\n    # type: (np.poly1d, np.poly1d) -> (np.array, np.array)\n    """"""Extract break points over real axis and gains given these locations""""""\n    dnum = num.deriv(m=1)\n    dden = den.deriv(m=1)\n    polynom = den * dnum - num * dden\n    real_break_pts = polynom.r\n    # don\'t care about infinite break points\n    real_break_pts = real_break_pts[num(real_break_pts) != 0]\n    k_break = -den(real_break_pts) / num(real_break_pts)\n    idx = k_break >= 0   # only positives gains\n    k_break = k_break[idx]\n    real_break_pts = real_break_pts[idx]\n    if len(k_break) == 0:\n        k_break = [0]\n        real_break_pts = den.roots\n    return k_break, real_break_pts\n\n\ndef _ax_lim(mymat):\n    """"""Utility to get the axis limits""""""\n    axmin = np.min(np.real(mymat))\n    axmax = np.max(np.real(mymat))\n    if axmax != axmin:\n        deltax = (axmax - axmin) * 0.02\n    else:\n        deltax = np.max([1., axmax / 2])\n    axlim = [axmin - deltax, axmax + deltax]\n    return axlim\n\n\ndef _k_max(num, den, real_break_points, k_break_points):\n    """"""""Calculate the maximum gain for the root locus shown in the figure.""""""\n    asymp_number = den.order - num.order\n    singular_points = np.concatenate((num.roots, den.roots), axis=0)\n    important_points = np.concatenate(\n        (singular_points, real_break_points), axis=0)\n    false_gain = den.coeffs[0] / num.coeffs[0]\n\n    if asymp_number > 0:\n        asymp_center = (np.sum(den.roots) - np.sum(num.roots))/asymp_number\n        distance_max = 4 * np.max(np.abs(important_points - asymp_center))\n        asymp_angles = (2 * np.arange(0, asymp_number) - 1) \\\n            * np.pi / asymp_number\n        if false_gain > 0:\n            # farthest points over asymptotes\n            farthest_points = asymp_center \\\n                + distance_max * np.exp(asymp_angles * 1j)\n        else:\n            asymp_angles = asymp_angles + np.pi\n            # farthest points over asymptotes\n            farthest_points = asymp_center \\\n                + distance_max * np.exp(asymp_angles * 1j)\n        kmax_asymp = np.real(np.abs(den(farthest_points)\n                                    / num(farthest_points)))\n    else:\n        kmax_asymp = np.abs([np.abs(den.coeffs[0])\n                             / np.abs(num.coeffs[0]) * 3])\n\n    kmax = np.max(np.concatenate((np.real(kmax_asymp),\n                                  np.real(k_break_points)), axis=0))\n    if np.abs(false_gain) > kmax:\n        kmax = np.abs(false_gain)\n    return kmax\n\n\ndef _systopoly1d(sys):\n    """"""Extract numerator and denominator polynomails for a system""""""\n    # Allow inputs from the signal processing toolbox\n    if (isinstance(sys, scipy.signal.lti)):\n        nump = sys.num\n        denp = sys.den\n\n    else:\n        # Convert to a transfer function, if needed\n        sys = _convert_to_transfer_function(sys)\n\n        # Make sure we have a SISO system\n        if (sys.inputs > 1 or sys.outputs > 1):\n            raise ControlMIMONotImplemented()\n\n        # Start by extracting the numerator and denominator from system object\n        nump = sys.num[0][0]\n        denp = sys.den[0][0]\n\n    # Check to see if num, den are already polynomials; otherwise convert\n    if (not isinstance(nump, poly1d)):\n        nump = poly1d(nump)\n\n    if (not isinstance(denp, poly1d)):\n        denp = poly1d(denp)\n\n    return (nump, denp)\n\n\ndef _RLFindRoots(nump, denp, kvect):\n    """"""Find the roots for the root locus.""""""\n    # Convert numerator and denominator to polynomials if they aren\'t\n    roots = []\n    for k in kvect:\n        curpoly = denp + k * nump\n        curroots = curpoly.r\n        if len(curroots) < denp.order:\n            # if I have fewer poles than open loop, it is because i have\n            # one at infinity\n            curroots = np.insert(curroots, len(curroots), np.inf)\n\n        curroots.sort()\n        roots.append(curroots)\n\n    mymat = row_stack(roots)\n    return mymat\n\n\ndef _RLSortRoots(mymat):\n    """"""Sort the roots from sys._RLFindRoots, so that the root\n    locus doesn\'t show weird pseudo-branches as roots jump from\n    one branch to another.""""""\n\n    sorted = zeros_like(mymat)\n    for n, row in enumerate(mymat):\n        if n == 0:\n            sorted[n, :] = row\n        else:\n            # sort the current row by finding the element with the\n            # smallest absolute distance to each root in the\n            # previous row\n            available = list(range(len(prevrow)))\n            for elem in row:\n                evect = elem-prevrow[available]\n                ind1 = abs(evect).argmin()\n                ind = available.pop(ind1)\n                sorted[n, ind] = elem\n        prevrow = sorted[n, :]\n    return sorted\n\n\ndef _RLZoomDispatcher(event, sys, ax_rlocus, plotstr):\n    """"""Rootlocus plot zoom dispatcher""""""\n\n    nump, denp = _systopoly1d(sys)\n    xlim, ylim = ax_rlocus.get_xlim(), ax_rlocus.get_ylim()\n\n    kvect, mymat, xlim, ylim = _default_gains(\n        nump, denp, xlim=None, ylim=None, zoom_xlim=xlim, zoom_ylim=ylim)\n    _removeLine(\'rootlocus\', ax_rlocus)\n\n    for i, col in enumerate(mymat.T):\n        ax_rlocus.plot(real(col), imag(col), plotstr, label=\'rootlocus\',\n                       scalex=False, scaley=False)\n\n\ndef _RLClickDispatcher(event, sys, fig, ax_rlocus, plotstr, sisotool=False,\n                       bode_plot_params=None, tvect=None):\n    """"""Rootlocus plot click dispatcher""""""\n\n    # Zoom is handled by specialized callback above, only do gain plot\n    if event.inaxes == ax_rlocus.axes and \\\n       plt.get_current_fig_manager().toolbar.mode not in \\\n       {\'zoom rect\', \'pan/zoom\'}:\n\n        # if a point is clicked on the rootlocus plot visually emphasize it\n        K = _RLFeedbackClicksPoint(event, sys, fig, ax_rlocus, sisotool)\n        if sisotool and K is not None:\n            _SisotoolUpdate(sys, fig, K, bode_plot_params, tvect)\n\n    # Update the canvas\n    fig.canvas.draw()\n\n\ndef _RLFeedbackClicksPoint(event, sys, fig, ax_rlocus, sisotool=False):\n    """"""Display root-locus gain feedback point for clicks on root-locus plot""""""\n    (nump, denp) = _systopoly1d(sys)\n\n    xlim = ax_rlocus.get_xlim()\n    ylim = ax_rlocus.get_ylim()\n    x_tolerance = 0.05 * abs((xlim[1] - xlim[0]))\n    y_tolerance = 0.05 * abs((ylim[1] - ylim[0]))\n    gain_tolerance = np.mean([x_tolerance, y_tolerance])*0.1\n\n    # Catch type error when event click is in the figure but not in an axis\n    try:\n        s = complex(event.xdata, event.ydata)\n        K = -1. / sys.horner(s)\n        K_xlim = -1. / sys.horner(\n            complex(event.xdata + 0.05 * abs(xlim[1] - xlim[0]), event.ydata))\n        K_ylim = -1. / sys.horner(\n            complex(event.xdata, event.ydata + 0.05 * abs(ylim[1] - ylim[0])))\n\n    except TypeError:\n        K = float(\'inf\')\n        K_xlim = float(\'inf\')\n        K_ylim = float(\'inf\')\n\n    gain_tolerance += 0.1 * max([abs(K_ylim.imag/K_ylim.real),\n                                 abs(K_xlim.imag/K_xlim.real)])\n\n    if abs(K.real) > 1e-8 and abs(K.imag / K.real) < gain_tolerance and \\\n       event.inaxes == ax_rlocus.axes and K.real > 0.:\n\n        # Display the parameters in the output window and figure\n        print(""Clicked at %10.4g%+10.4gj gain %10.4g damp %10.4g"" %\n              (s.real, s.imag, K.real, -1 * s.real / abs(s)))\n        fig.suptitle(\n            ""Clicked at: %10.4g%+10.4gj  gain: %10.4g  damp: %10.4g"" %\n            (s.real, s.imag, K.real, -1 * s.real / abs(s)),\n            fontsize=12 if int(matplotlib.__version__[0]) == 1 else 10)\n\n        # Remove the previous line\n        _removeLine(label=\'gain_point\', ax=ax_rlocus)\n\n        # Visualise clicked point, display all roots for sisotool mode\n        if sisotool:\n            mymat = _RLFindRoots(nump, denp, K.real)\n            ax_rlocus.plot(\n                [root.real for root in mymat],\n                [root.imag for root in mymat],\n                \'m.\', marker=\'s\', markersize=8, zorder=20, label=\'gain_point\')\n        else:\n            ax_rlocus.plot(s.real, s.imag, \'k.\', marker=\'s\', markersize=8,\n                           zorder=20, label=\'gain_point\')\n\n        return K.real[0][0]\n\n\ndef _removeLine(label, ax):\n    """"""Remove a line from the ax when a label is specified""""""\n    for line in reversed(ax.lines):\n        if line.get_label() == label:\n            line.remove()\n            del line\n\n\ndef _sgrid_func(fig=None, zeta=None, wn=None):\n    if fig is None:\n        fig = pylab.gcf()\n        ax = fig.gca()\n    else:\n        ax = fig.axes[1]\n    xlocator = ax.get_xaxis().get_major_locator()\n\n    ylim = ax.get_ylim()\n    ytext_pos_lim = ylim[1] - (ylim[1] - ylim[0]) * 0.03\n    xlim = ax.get_xlim()\n    xtext_pos_lim = xlim[0] + (xlim[1] - xlim[0]) * 0.0\n\n    if zeta is None:\n        zeta = _default_zetas(xlim, ylim)\n\n    angules = []\n    for z in zeta:\n        if (z >= 1e-4) and (z <= 1):\n            angules.append(np.pi/2 + np.arcsin(z))\n        else:\n            zeta.remove(z)\n    y_over_x = np.tan(angules)\n\n    # zeta-constant lines\n\n    index = 0\n\n    for yp in y_over_x:\n        ax.plot([0, xlocator()[0]], [0, yp*xlocator()[0]], color=\'gray\',\n                linestyle=\'dashed\', linewidth=0.5)\n        ax.plot([0, xlocator()[0]], [0, -yp * xlocator()[0]], color=\'gray\',\n                linestyle=\'dashed\', linewidth=0.5)\n        an = ""%.2f"" % zeta[index]\n        if yp < 0:\n            xtext_pos = 1/yp * ylim[1]\n            ytext_pos = yp * xtext_pos_lim\n            if np.abs(xtext_pos) > np.abs(xtext_pos_lim):\n                xtext_pos = xtext_pos_lim\n            else:\n                ytext_pos = ytext_pos_lim\n            ax.annotate(an, textcoords=\'data\', xy=[xtext_pos, ytext_pos],\n                        fontsize=8)\n        index += 1\n    ax.plot([0, 0], [ylim[0], ylim[1]],\n            color=\'gray\', linestyle=\'dashed\', linewidth=0.5)\n\n    angules = np.linspace(-90, 90, 20)*np.pi/180\n    if wn is None:\n        wn = _default_wn(xlocator(), ylim)\n\n    for om in wn:\n        if om < 0:\n            yp = np.sin(angules)*np.abs(om)\n            xp = -np.cos(angules)*np.abs(om)\n            ax.plot(xp, yp, color=\'gray\',\n                    linestyle=\'dashed\', linewidth=0.5)\n            an = ""%.2f"" % -om\n            ax.annotate(an, textcoords=\'data\', xy=[om, 0], fontsize=8)\n\n\ndef _default_zetas(xlim, ylim):\n    """"""Return default list of dumps coefficients""""""\n    sep1 = -xlim[0]/4\n    ang1 = [np.arctan((sep1*i)/ylim[1]) for i in np.arange(1, 4, 1)]\n    sep2 = ylim[1] / 3\n    ang2 = [np.arctan(-xlim[0]/(ylim[1]-sep2*i)) for i in np.arange(1, 3, 1)]\n\n    angules = np.concatenate((ang1, ang2))\n    angules = np.insert(angules, len(angules), np.pi/2)\n    zeta = np.sin(angules)\n    return zeta.tolist()\n\n\ndef _default_wn(xloc, ylim):\n    """"""Return default wn for root locus plot""""""\n\n    wn = xloc\n    sep = xloc[1]-xloc[0]\n    while np.abs(wn[0]) < ylim[1]:\n        wn = np.insert(wn, 0, wn[0]-sep)\n\n    while len(wn) > 7:\n        wn = wn[0:-1:2]\n\n    return wn\n\n\nrlocus = root_locus\n'"
External_Libraries/python_control_master/control/robust.py,18,"b'# robust.py - tools for robust control\n#\n# Author: Steve Brunton, Kevin Chen, Lauren Padilla\n# Date: 24 Dec 2010\n#\n# This file contains routines for obtaining reduced order models\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\n# External packages and modules\nimport numpy as np\nfrom .exception import *\nfrom .statesp import StateSpace\nfrom .statefbk import *\n\n\ndef h2syn(P, nmeas, ncon):\n    """"""H_2 control synthesis for plant P.\n\n    Parameters\n    ----------\n    P: partitioned lti plant (State-space sys)\n    nmeas: number of measurements (input to controller)\n    ncon: number of control inputs (output from controller)\n\n    Returns\n    -------\n    K: controller to stabilize P (State-space sys)\n\n    Raises\n    ------\n    ImportError\n        if slycot routine sb10hd is not loaded\n\n    See Also\n    --------\n    StateSpace\n\n    Examples\n    --------\n    >>> K = h2syn(P,nmeas,ncon)\n\n    """"""\n    # Check for ss system object, need a utility for this?\n\n    # TODO: Check for continous or discrete, only continuous supported right now\n    # if isCont():\n    #    dico = \'C\'\n    # elif isDisc():\n    #    dico = \'D\'\n    # else:\n    dico = \'C\'\n\n    try:\n        from slycot import sb10hd\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot subroutine sb10hd"")\n\n    n = np.size(P.A, 0)\n    m = np.size(P.B, 1)\n    np_ = np.size(P.C, 0)\n    out = sb10hd(n, m, np_, ncon, nmeas, P.A, P.B, P.C, P.D)\n    Ak = out[0]\n    Bk = out[1]\n    Ck = out[2]\n    Dk = out[3]\n\n    K = StateSpace(Ak, Bk, Ck, Dk)\n\n    return K\n\n\ndef hinfsyn(P, nmeas, ncon):\n    """"""H_{inf} control synthesis for plant P.\n\n    Parameters\n    ----------\n    P: partitioned lti plant\n    nmeas: number of measurements (input to controller)\n    ncon: number of control inputs (output from controller)\n\n    Returns\n    -------\n    K: controller to stabilize P (State-space sys)\n    CL: closed loop system (State-space sys)\n    gam: infinity norm of closed loop system\n    rcond: 4-vector, reciprocal condition estimates of:\n        1: control transformation matrix\n        2: measurement transformation matrix\n        3: X-Ricatti equation\n        4: Y-Ricatti equation\n    TODO: document significance of rcond\n\n    Raises\n    ------\n    ImportError\n        if slycot routine sb10ad is not loaded\n\n    See Also\n    --------\n    StateSpace\n\n    Examples\n    --------\n    >>> K, CL, gam, rcond = hinfsyn(P,nmeas,ncon)\n\n    """"""\n\n    # Check for ss system object, need a utility for this?\n\n    # TODO: Check for continous or discrete, only continuous supported right now\n    # if isCont():\n    #    dico = \'C\'\n    # elif isDisc():\n    #    dico = \'D\'\n    # else:\n    dico = \'C\'\n\n    try:\n        from slycot import sb10ad\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot subroutine sb10ad"")\n\n    n = np.size(P.A, 0)\n    m = np.size(P.B, 1)\n    np_ = np.size(P.C, 0)\n    gamma = 1.e100\n    out = sb10ad(n, m, np_, ncon, nmeas, gamma, P.A, P.B, P.C, P.D)\n    gam = out[0]\n    Ak = out[1]\n    Bk = out[2]\n    Ck = out[3]\n    Dk = out[4]\n    Ac = out[5]\n    Bc = out[6]\n    Cc = out[7]\n    Dc = out[8]\n    rcond = out[9]\n\n    K = StateSpace(Ak, Bk, Ck, Dk)\n    CL = StateSpace(Ac, Bc, Cc, Dc)\n\n    return K, CL, gam, rcond\n\n\ndef _size_as_needed(w, wname, n):\n    """"""Convert LTI object to appropriately sized StateSpace object.\n\n    Intended for use in .robust only\n\n    Parameters\n    ----------\n    w: None, 1x1 LTI object, or mxn LTI object\n    wname: name of w, for error message\n    n: number of inputs to w\n\n    Returns\n    -------\n    w_: processed weighting function, a StateSpace object:\n        - if w is None, empty StateSpace object\n        - if w is scalar, w_ will be w * eye(n)\n        - otherwise, w as StateSpace object\n\n    Raises\n    ------\n    ValueError\n        - if w is not None or scalar, and doesn\'t have n inputs\n\n    See Also\n    --------\n    augw\n    """"""\n    from . import append, ss\n    if w is not None:\n        if not isinstance(w, StateSpace):\n            w = ss(w)\n        if 1 == w.inputs and 1 == w.outputs:\n            w = append(*(w,) * n)\n        else:\n            if w.inputs != n:\n                msg = (""{}: weighting function has {} inputs, expected {}"".\n                       format(wname, w.inputs, n))\n                raise ValueError(msg)\n    else:\n        w = ss([], [], [], [])\n    return w\n\n\ndef augw(g, w1=None, w2=None, w3=None):\n    """"""Augment plant for mixed sensitivity problem.\n\n    Parameters\n    ----------\n    g: LTI object, ny-by-nu\n    w1: weighting on S; None, scalar, or k1-by-ny LTI object\n    w2: weighting on KS; None, scalar, or k2-by-nu LTI object\n    w3: weighting on T; None, scalar, or k3-by-ny LTI object\n    p: augmented plant; StateSpace object\n\n    If a weighting is None, no augmentation is done for it.  At least\n    one weighting must not be None.\n\n    If a weighting w is scalar, it will be replaced by I*w, where I is\n    ny-by-ny for w1 and w3, and nu-by-nu for w2.\n\n    Returns\n    -------\n    p: plant augmented with weightings, suitable for submission to hinfsyn or h2syn.\n\n    Raises\n    ------\n    ValueError\n        - if all weightings are None\n\n    See Also\n    --------\n    h2syn, hinfsyn, mixsyn\n    """"""\n\n    from . import append, ss, connect\n\n    if w1 is None and w2 is None and w3 is None:\n        raise ValueError(""At least one weighting must not be None"")\n    ny = g.outputs\n    nu = g.inputs\n\n    w1, w2, w3 = [_size_as_needed(w, wname, n)\n                  for w, wname, n in zip((w1, w2, w3),\n                                         (\'w1\', \'w2\', \'w3\'),\n                                         (ny, nu, ny))]\n\n    if not isinstance(g, StateSpace):\n        g = ss(g)\n\n    #       w         u\n    #  z1 [ w1   |   -w1*g  ]\n    #  z2 [ 0    |    w2    ]\n    #  z3 [ 0    |    w3*g  ]\n    #     [------+--------- ]\n    #  v  [ I    |    -g    ]\n\n    # error summer: inputs are -y and r=w\n    Ie = ss([], [], [], np.eye(ny))\n    # control: needed to ""distribute"" control input\n    Iu = ss([], [], [], np.eye(nu))\n\n    sysall = append(w1, w2, w3, Ie, g, Iu)\n\n    niw1 = w1.inputs\n    niw2 = w2.inputs\n    niw3 = w3.inputs\n\n    now1 = w1.outputs\n    now2 = w2.outputs\n    now3 = w3.outputs\n\n    q = np.zeros((niw1 + niw2 + niw3 + ny + nu, 2))\n    q[:, 0] = np.arange(1, q.shape[0] + 1)\n\n    # Ie -> w1\n    q[:niw1, 1] = np.arange(1 + now1 + now2 + now3,\n                            1 + now1 + now2 + now3 + niw1)\n\n    # Iu -> w2\n    q[niw1:niw1 + niw2, 1] = np.arange(1 + now1 + now2 + now3 + 2 * ny,\n                                       1 + now1 + now2 + now3 + 2 * ny + niw2)\n\n    # y -> w3\n    q[niw1 + niw2:niw1 + niw2 + niw3, 1] = np.arange(1 + now1 + now2 + now3 + ny,\n                                                     1 + now1 + now2 + now3 + ny + niw3)\n\n    # -y -> Iy; note the leading -\n    q[niw1 + niw2 + niw3:niw1 + niw2 + niw3 + ny, 1] = -np.arange(1 + now1 + now2 + now3 + ny,\n                                                                  1 + now1 + now2 + now3 + 2 * ny)\n\n    # Iu -> G\n    q[niw1 + niw2 + niw3 + ny:niw1 + niw2 + niw3 + ny + nu, 1] = np.arange(\n        1 + now1 + now2 + now3 + 2 * ny,\n        1 + now1 + now2 + now3 + 2 * ny + nu)\n\n    # input indices: to Ie and Iu\n    ii = np.hstack((np.arange(1 + now1 + now2 + now3,\n                              1 + now1 + now2 + now3 + ny),\n                    np.arange(1 + now1 + now2 + now3 + ny + nu,\n                              1 + now1 + now2 + now3 + ny + nu + nu)))\n\n    # output indices\n    oi = np.arange(1, 1 + now1 + now2 + now3 + ny)\n\n    p = connect(sysall, q, ii, oi)\n\n    return p\n\n\ndef mixsyn(g, w1=None, w2=None, w3=None):\n    """"""Mixed-sensitivity H-infinity synthesis.\n\n    mixsyn(g,w1,w2,w3) -> k,cl,info\n\n    Parameters\n    ----------\n    g: LTI; the plant for which controller must be synthesized\n    w1: weighting on s = (1+g*k)**-1; None, or scalar or k1-by-ny LTI\n    w2: weighting on k*s; None, or scalar or k2-by-nu LTI\n    w3: weighting on t = g*k*(1+g*k)**-1; None, or scalar or k3-by-ny LTI\n    At least one of w1, w2, and w3 must not be None.\n\n    Returns\n    -------\n    k: synthesized controller; StateSpace object\n    cl: closed system mapping evaluation inputs to evaluation outputs; if \n    p is the augmented plant, with\n        [z] = [p11 p12] [w], \n        [y]   [p21   g] [u]\n    then cl is the system from w->z with u=-k*y.  StateSpace object.\n\n    info: tuple with entries, in order,\n        - gamma: scalar; H-infinity norm of cl\n        - rcond: array; estimates of reciprocal condition numbers\n          computed during synthesis.  See hinfsyn for details\n\n    If a weighting w is scalar, it will be replaced by I*w, where I is\n    ny-by-ny for w1 and w3, and nu-by-nu for w2.\n\n    See Also\n    --------\n    hinfsyn, augw\n    """"""\n    nmeas = g.outputs\n    ncon = g.inputs\n    p = augw(g, w1, w2, w3)\n\n    k, cl, gamma, rcond = hinfsyn(p, nmeas, ncon)\n    info = gamma, rcond\n    return k, cl, info\n'"
External_Libraries/python_control_master/control/setup.py,0,"b""def configuration(parent_package='', top_path=None):\n    from numpy.distutils.misc_util import Configuration\n    config = Configuration('control', parent_package, top_path)\n    config.add_subpackage('tests')\n    return config\n"""
External_Libraries/python_control_master/control/sisotool.py,0,"b'__all__ = [\'sisotool\']\n\nfrom .freqplot import bode_plot\nfrom .timeresp import step_response\nfrom .lti import issiso\nimport matplotlib\nimport matplotlib.pyplot as plt\nimport warnings\n\ndef sisotool(sys, kvect = None, xlim_rlocus = None, ylim_rlocus = None,\n             plotstr_rlocus = \'b\' if int(matplotlib.__version__[0]) == 1 else \'C0\',\n             rlocus_grid = False, omega = None, dB = None, Hz = None,\n             deg = None, omega_limits = None, omega_num = None,\n             margins_bode = True, tvect=None):\n    """"""\n    Sisotool style collection of plots inspired by MATLAB\'s sisotool.\n    The left two plots contain the bode magnitude and phase diagrams.\n    The top right plot is a clickable root locus plot, clicking on the\n    root locus will change the gain of the system. The bottom left plot\n    shows a closed loop time response.\n\n    Parameters\n    ----------\n    sys : LTI object\n        Linear input/output systems (SISO only)\n    kvect : list or ndarray, optional\n        List of gains to use for plotting root locus\n    xlim_rlocus : tuple or list, optional\n        control of x-axis range, normally with tuple (see matplotlib.axes)\n    ylim_rlocus : tuple or list, optional\n        control of y-axis range\n    plotstr_rlocus : Additional options to matplotlib\n        plotting style for the root locus plot(color, linestyle, etc)\n    rlocus_grid: boolean (default = False)\n        If True plot s-plane grid.\n    omega : freq_range\n        Range of frequencies in rad/sec for the bode plot\n    dB : boolean\n        If True, plot result in dB for the bode plot\n    Hz : boolean\n        If True, plot frequency in Hz for the bode plot (omega must be provided in rad/sec)\n    deg : boolean\n        If True, plot phase in degrees for the bode plot (else radians)\n    omega_limits: tuple, list, ... of two values\n        Limits of the to generate frequency vector.\n        If Hz=True the limits are in Hz otherwise in rad/s.\n    omega_num: int\n        number of samples\n    margins_bode : boolean\n        If True, plot gain and phase margin in the bode plot\n    tvect : list or ndarray, optional\n        List of timesteps to use for closed loop step response\n\n    Examples\n    --------\n    >>> sys = tf([1000], [1,25,100,0])\n    >>> sisotool(sys)\n\n    """"""\n    from .rlocus import root_locus\n\n    # Check if it is a single SISO system\n    issiso(sys,strict=True)\n\n    # Setup sisotool figure or superimpose if one is already present\n    fig = plt.gcf()\n    if fig.canvas.get_window_title() != \'Sisotool\':\n        plt.close(fig)\n        fig,axes = plt.subplots(2, 2)\n        fig.canvas.set_window_title(\'Sisotool\')\n\n    # Extract bode plot parameters\n    bode_plot_params = {\n        \'omega\': omega,\n        \'dB\': dB,\n        \'Hz\': Hz,\n        \'deg\': deg,\n        \'omega_limits\': omega_limits,\n        \'omega_num\' : omega_num,\n        \'sisotool\': True,\n        \'fig\': fig,\n        \'margins\': margins_bode\n    }\n\n    # First time call to setup the bode and step response plots\n    _SisotoolUpdate(sys, fig,1 if kvect is None else kvect[0],bode_plot_params)\n\n    # Setup the root-locus plot window\n    root_locus(sys,kvect=kvect,xlim=xlim_rlocus,ylim = ylim_rlocus,plotstr=plotstr_rlocus,grid = rlocus_grid,fig=fig,bode_plot_params=bode_plot_params,tvect=tvect,sisotool=True)\n\ndef _SisotoolUpdate(sys,fig,K,bode_plot_params,tvect=None):\n\n    if int(matplotlib.__version__[0]) == 1:\n        title_font_size = 12\n        label_font_size = 10\n    else:\n        title_font_size = 10\n        label_font_size = 8\n\n    # Get the subaxes and clear them\n    ax_mag,ax_rlocus,ax_phase,ax_step = fig.axes[0],fig.axes[1],fig.axes[2],fig.axes[3]\n\n    # Catch matplotlib 2.1.x and higher userwarnings when clearing a log axis\n    with warnings.catch_warnings():\n        warnings.simplefilter(""ignore"")\n        ax_step.clear(), ax_mag.clear(), ax_phase.clear()\n\n    # Update the bodeplot\n    bode_plot_params[\'syslist\'] = sys*K.real\n    bode_plot(**bode_plot_params)\n\n    # Set the titles and labels\n    ax_mag.set_title(\'Bode magnitude\',fontsize = title_font_size)\n    ax_mag.set_ylabel(ax_mag.get_ylabel(), fontsize=label_font_size)\n\n    ax_phase.set_title(\'Bode phase\',fontsize=title_font_size)\n    ax_phase.set_xlabel(ax_phase.get_xlabel(),fontsize=label_font_size)\n    ax_phase.set_ylabel(ax_phase.get_ylabel(),fontsize=label_font_size)\n    ax_phase.get_xaxis().set_label_coords(0.5, -0.15)\n    ax_phase.get_shared_x_axes().join(ax_phase, ax_mag)\n\n    ax_step.set_title(\'Step response\',fontsize = title_font_size)\n    ax_step.set_xlabel(\'Time (seconds)\',fontsize=label_font_size)\n    ax_step.set_ylabel(\'Amplitude\',fontsize=label_font_size)\n    ax_step.get_xaxis().set_label_coords(0.5, -0.15)\n    ax_step.get_yaxis().set_label_coords(-0.15, 0.5)\n\n    ax_rlocus.set_title(\'Root locus\',fontsize = title_font_size)\n    ax_rlocus.set_ylabel(\'Imag\', fontsize=label_font_size)\n    ax_rlocus.set_xlabel(\'Real\', fontsize=label_font_size)\n    ax_rlocus.get_xaxis().set_label_coords(0.5, -0.15)\n    ax_rlocus.get_yaxis().set_label_coords(-0.15, 0.5)\n\n\n\n    # Generate the step response and plot it\n    sys_closed = (K*sys).feedback(1)\n    if tvect is None:\n        tvect, yout = step_response(sys_closed)\n    else:\n        tvect, yout = step_response(sys_closed,tvect)\n    ax_step.plot(tvect, yout)\n    ax_step.axhline(1.,linestyle=\':\',color=\'k\',zorder=-20)\n\n    # Manually adjust the spacing and draw the canvas\n    fig.subplots_adjust(top=0.9,wspace = 0.3,hspace=0.35)\n    fig.canvas.draw()\n\n'"
External_Libraries/python_control_master/control/statefbk.py,36,"b'# statefbk.py - tools for state feedback control\n#\n# Author: Richard M. Murray, Roberto Bucher\n# Date: 31 May 2010\n#\n# This file contains routines for designing state space controllers\n#\n# Copyright (c) 2010 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# $Id$\n\n# External packages and modules\nimport numpy as np\nimport scipy as sp\nfrom . import statesp\nfrom .statesp import _ssmatrix\nfrom .exception import ControlSlycot, ControlArgument, ControlDimension\n\n__all__ = [\'ctrb\', \'obsv\', \'gram\', \'place\', \'place_varga\', \'lqr\', \'acker\']\n\n\n# Pole placement\ndef place(A, B, p):\n    """"""Place closed loop eigenvalues\n    K = place(A, B, p)\n\n    Parameters\n    ----------\n    A : 2-d array\n        Dynamics matrix\n    B : 2-d array\n        Input matrix\n    p : 1-d list\n        Desired eigenvalue locations\n\n    Returns\n    -------\n    K : 2-d array\n        Gain such that A - B K has eigenvalues given in p\n\n    Algorithm\n    ---------\n    This is a wrapper function for scipy.signal.place_poles, which\n    implements the Tits and Yang algorithm [1]. It will handle SISO,\n    MISO, and MIMO systems. If you want more control over the algorithm,\n    use scipy.signal.place_poles directly.\n\n    [1] A.L. Tits and Y. Yang, ""Globally convergent algorithms for robust\n    pole assignment by state feedback, IEEE Transactions on Automatic\n    Control, Vol. 41, pp. 1432-1452, 1996.\n\n    Limitations\n    -----------\n    The algorithm will not place poles at the same location more\n    than rank(B) times.\n\n    Examples\n    --------\n    >>> A = [[-1, -1], [0, 1]]\n    >>> B = [[0], [1]]\n    >>> K = place(A, B, [-2, -5])\n\n    See Also\n    --------\n    place_varga, acker\n    """"""\n    from scipy.signal import place_poles\n\n    # Convert the system inputs to NumPy arrays\n    A_mat = np.array(A)\n    B_mat = np.array(B)\n    if (A_mat.shape[0] != A_mat.shape[1]):\n        raise ControlDimension(""A must be a square matrix"")\n\n    if (A_mat.shape[0] != B_mat.shape[0]):\n        err_str = ""The number of rows of A must equal the number of rows in B""\n        raise ControlDimension(err_str)\n\n    # Convert desired poles to numpy array\n    placed_eigs = np.array(p)\n\n    result = place_poles(A_mat, B_mat, placed_eigs, method=\'YT\')\n    K = result.gain_matrix\n    return _ssmatrix(K)\n\n\ndef place_varga(A, B, p, dtime=False, alpha=None):\n    """"""Place closed loop eigenvalues\n    K = place_varga(A, B, p, dtime=False, alpha=None)\n\n    Required Parameters\n    ----------\n    A : 2-d array\n        Dynamics matrix\n    B : 2-d array\n        Input matrix\n    p : 1-d list\n        Desired eigenvalue locations\n\n    Optional Parameters\n    ---------------\n    dtime: False for continuous time pole placement or True for discrete time.\n            The default is dtime=False.\n    alpha: double scalar\n           If DICO=\'C\', then place_varga will leave the eigenvalues with real\n           real part less than alpha untouched.\n           If DICO=\'D\', the place_varga will leave eigenvalues with modulus\n           less than alpha untouched.\n\n           By default (alpha=None), place_varga computes alpha such that all\n           poles will be placed.\n\n    Returns\n    -------\n    K : 2D array\n        Gain such that A - B K has eigenvalues given in p.\n\n\n    Algorithm\n    ---------\n        This function is a wrapper for the slycot function sb01bd, which\n        implements the pole placement algorithm of Varga [1]. In contrast to\n        the algorithm used by place(), the Varga algorithm can place\n        multiple poles at the same location. The placement, however, may not\n        be as robust.\n\n        [1] Varga A. ""A Schur method for pole assignment.""\n            IEEE Trans. Automatic Control, Vol. AC-26, pp. 517-519, 1981.\n\n    Examples\n    --------\n    >>> A = [[-1, -1], [0, 1]]\n    >>> B = [[0], [1]]\n    >>> K = place_varga(A, B, [-2, -5])\n\n    See Also:\n    --------\n    place, acker\n    """"""\n\n    # Make sure that SLICOT is installed\n    try:\n        from slycot import sb01bd\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb01bd\'"")\n\n    # Convert the system inputs to NumPy arrays\n    A_mat = np.array(A)\n    B_mat = np.array(B)\n    if (A_mat.shape[0] != A_mat.shape[1] or\n        A_mat.shape[0] != B_mat.shape[0]):\n        raise ControlDimension(""matrix dimensions are incorrect"")\n\n    # Compute the system eigenvalues and convert poles to numpy array\n    system_eigs = np.linalg.eig(A_mat)[0]\n    placed_eigs = np.array(p)\n\n    # Need a character parameter for SB01BD\n    if dtime:\n        DICO = \'D\'\n    else:\n        DICO = \'C\'\n\n    if alpha is None:\n        # SB01BD ignores eigenvalues with real part less than alpha\n        # (if DICO=\'C\') or with modulus less than alpha\n        # (if DICO = \'D\').\n        if dtime:\n            # For discrete time, slycot only cares about modulus, so just make\n            # alpha the smallest it can be.\n            alpha = 0.0\n        else:\n            # Choosing alpha=min_eig is insufficient and can lead to an\n            # error or not having all the eigenvalues placed that we wanted.\n            # Evidently, what python thinks are the eigs is not precisely\n            # the same as what slicot thinks are the eigs. So we need some\n            # numerical breathing room. The following is pretty heuristic,\n            # but does the trick\n            alpha = -2*abs(min(system_eigs.real))\n    elif dtime and alpha < 0.0:\n        raise ValueError(""Need alpha > 0 when DICO=\'D\'"")\n\n\n    # Call SLICOT routine to place the eigenvalues\n    A_z,w,nfp,nap,nup,F,Z = \\\n        sb01bd(B_mat.shape[0], B_mat.shape[1], len(placed_eigs), alpha,\n               A_mat, B_mat, placed_eigs, DICO)\n\n    # Return the gain matrix, with MATLAB gain convention\n    return _ssmatrix(-F)\n\n# Contributed by Roberto Bucher <roberto.bucher@supsi.ch>\ndef acker(A, B, poles):\n    """"""Pole placement using Ackermann method\n\n    Call:\n    K = acker(A, B, poles)\n\n    Parameters\n    ----------\n    A, B : 2-d arrays\n        State and input matrix of the system\n    poles: 1-d list\n        Desired eigenvalue locations\n\n    Returns\n    -------\n    K: matrix\n        Gains such that A - B K has given eigenvalues\n\n    """"""\n    # Convert the inputs to matrices\n    a = _ssmatrix(A)\n    b = _ssmatrix(B)\n\n    # Make sure the system is controllable\n    ct = ctrb(A, B)\n    if np.linalg.matrix_rank(ct) != a.shape[0]:\n        raise ValueError(""System not reachable; pole placement invalid"")\n\n    # Compute the desired characteristic polynomial\n    p = np.real(np.poly(poles))\n\n    # Place the poles using Ackermann\'s method\n    # TODO: compute pmat using Horner\'s method (O(n) instead of O(n^2))\n    n = np.size(p)\n    pmat = p[n-1] * np.linalg.matrix_power(a, 0)\n    for i in np.arange(1,n):\n        pmat = pmat + np.dot(p[n-i-1], np.linalg.matrix_power(a, i))\n    K = np.linalg.solve(ct, pmat)\n\n    K = K[-1][:]                # Extract the last row\n    return _ssmatrix(K)\n\ndef lqr(*args, **keywords):\n    """"""lqr(A, B, Q, R[, N])\n\n    Linear quadratic regulator design\n\n    The lqr() function computes the optimal state feedback controller\n    that minimizes the quadratic cost\n\n    .. math:: J = \\int_0^\\infty (x\' Q x + u\' R u + 2 x\' N u) dt\n\n    The function can be called with either 3, 4, or 5 arguments:\n\n    * ``lqr(sys, Q, R)``\n    * ``lqr(sys, Q, R, N)``\n    * ``lqr(A, B, Q, R)``\n    * ``lqr(A, B, Q, R, N)``\n\n    where `sys` is an `LTI` object, and `A`, `B`, `Q`, `R`, and `N` are\n    2d arrays or matrices of appropriate dimension.\n\n    Parameters\n    ----------\n    A, B: 2-d array\n        Dynamics and input matrices\n    sys: LTI (StateSpace or TransferFunction)\n        Linear I/O system\n    Q, R: 2-d array\n        State and input weight matrices\n    N: 2-d array, optional\n        Cross weight matrix\n\n    Returns\n    -------\n    K: 2D array\n        State feedback gains\n    S: 2D array\n        Solution to Riccati equation\n    E: 1D array\n        Eigenvalues of the closed loop system\n\n    Examples\n    --------\n    >>> K, S, E = lqr(sys, Q, R, [N])\n    >>> K, S, E = lqr(A, B, Q, R, [N])\n\n    """"""\n\n    # Make sure that SLICOT is installed\n    try:\n        from slycot import sb02md\n        from slycot import sb02mt\n    except ImportError:\n        raise ControlSlycot(""can\'t find slycot module \'sb02md\' or \'sb02nt\'"")\n\n    #\n    # Process the arguments and figure out what inputs we received\n    #\n\n    # Get the system description\n    if (len(args) < 3):\n        raise ControlArgument(""not enough input arguments"")\n\n    try:\n        # If this works, we were (probably) passed a system as the\n        # first argument; extract A and B\n        A = np.array(args[0].A, ndmin=2, dtype=float);\n        B = np.array(args[0].B, ndmin=2, dtype=float);\n        index = 1;\n    except AttributeError:\n        # Arguments should be A and B matrices\n        A = np.array(args[0], ndmin=2, dtype=float);\n        B = np.array(args[1], ndmin=2, dtype=float);\n        index = 2;\n\n    # Get the weighting matrices (converting to matrices, if needed)\n    Q = np.array(args[index], ndmin=2, dtype=float);\n    R = np.array(args[index+1], ndmin=2, dtype=float);\n    if (len(args) > index + 2):\n        N = np.array(args[index+2], ndmin=2, dtype=float);\n    else:\n        N = np.zeros((Q.shape[0], R.shape[1]));\n\n    # Check dimensions for consistency\n    nstates = B.shape[0];\n    ninputs = B.shape[1];\n    if (A.shape[0] != nstates or A.shape[1] != nstates):\n        raise ControlDimension(""inconsistent system dimensions"")\n\n    elif (Q.shape[0] != nstates or Q.shape[1] != nstates or\n          R.shape[0] != ninputs or R.shape[1] != ninputs or\n          N.shape[0] != nstates or N.shape[1] != ninputs):\n        raise ControlDimension(""incorrect weighting matrix dimensions"")\n\n    # Compute the G matrix required by SB02MD\n    A_b,B_b,Q_b,R_b,L_b,ipiv,oufact,G = \\\n        sb02mt(nstates, ninputs, B, R, A, Q, N, jobl=\'N\');\n\n    # Call the SLICOT function\n    X,rcond,w,S,U,A_inv = sb02md(nstates, A_b, G, Q_b, \'C\')\n\n    # Now compute the return value\n    # We assume that R is positive definite and, hence, invertible\n    K = np.linalg.solve(R, np.dot(B.T, X) + N.T);\n    S = X;\n    E = w[0:nstates];\n\n    return _ssmatrix(K), _ssmatrix(S), E\n\ndef ctrb(A, B):\n    """"""Controllabilty matrix\n\n    Parameters\n    ----------\n    A, B: array_like or string\n        Dynamics and input matrix of the system\n\n    Returns\n    -------\n    C: matrix\n        Controllability matrix\n\n    Examples\n    --------\n    >>> C = ctrb(A, B)\n\n    """"""\n\n    # Convert input parameters to matrices (if they aren\'t already)\n    amat = _ssmatrix(A)\n    bmat = _ssmatrix(B)\n    n = np.shape(amat)[0]\n\n    # Construct the controllability matrix\n    ctrb = np.hstack([bmat] + [np.dot(np.linalg.matrix_power(amat, i), bmat)\n                                      for i in range(1, n)])\n    return _ssmatrix(ctrb)\n\ndef obsv(A, C):\n    """"""Observability matrix\n\n    Parameters\n    ----------\n    A, C: array_like or string\n        Dynamics and output matrix of the system\n\n    Returns\n    -------\n    O: matrix\n        Observability matrix\n\n    Examples\n    --------\n    >>> O = obsv(A, C)\n\n   """"""\n\n    # Convert input parameters to matrices (if they aren\'t already)\n    amat = _ssmatrix(A)\n    cmat = _ssmatrix(C)\n    n = np.shape(amat)[0]\n\n    # Construct the observability matrix\n    obsv = np.vstack([cmat] + [np.dot(cmat, np.linalg.matrix_power(amat, i))\n                               for i in range(1, n)])\n    return _ssmatrix(obsv)\n\ndef gram(sys,type):\n    """"""Gramian (controllability or observability)\n\n    Parameters\n    ----------\n    sys: StateSpace\n        State-space system to compute Gramian for\n    type: String\n        Type of desired computation.\n        `type` is either \'c\' (controllability) or \'o\' (observability). To compute the\n        Cholesky factors of gramians use \'cf\' (controllability) or \'of\' (observability)\n\n    Returns\n    -------\n    gram: array\n        Gramian of system\n\n    Raises\n    ------\n    ValueError\n        * if system is not instance of StateSpace class\n        * if `type` is not \'c\', \'o\', \'cf\' or \'of\'\n        * if system is unstable (sys.A has eigenvalues not in left half plane)\n\n    ImportError\n        if slycot routine sb03md cannot be found\n        if slycot routine sb03od cannot be found\n\n    Examples\n    --------\n    >>> Wc = gram(sys,\'c\')\n    >>> Wo = gram(sys,\'o\')\n    >>> Rc = gram(sys,\'cf\'), where Wc=Rc\'*Rc\n    >>> Ro = gram(sys,\'of\'), where Wo=Ro\'*Ro\n\n    """"""\n\n    #Check for ss system object\n    if not isinstance(sys,statesp.StateSpace):\n        raise ValueError(""System must be StateSpace!"")\n    if type not in [\'c\', \'o\', \'cf\', \'of\']:\n        raise ValueError(""That type is not supported!"")\n\n    #TODO: Check for continous or discrete, only continuous supported right now\n        # if isCont():\n        #    dico = \'C\'\n        # elif isDisc():\n        #    dico = \'D\'\n        # else:\n    dico = \'C\'\n\n    #TODO: Check system is stable, perhaps a utility in ctrlutil.py\n        # or a method of the StateSpace class?\n    if np.any(np.linalg.eigvals(sys.A).real >= 0.0):\n        raise ValueError(""Oops, the system is unstable!"")\n\n    if type==\'c\' or type==\'o\':\n        #Compute Gramian by the Slycot routine sb03md\n        #make sure Slycot is installed\n        try:\n            from slycot import sb03md\n        except ImportError:\n            raise ControlSlycot(""can\'t find slycot module \'sb03md\'"")\n        if type==\'c\':\n            tra = \'T\'\n            C = -np.dot(sys.B,sys.B.transpose())\n        elif type==\'o\':\n            tra = \'N\'\n            C = -np.dot(sys.C.transpose(),sys.C)\n        n = sys.states\n        U = np.zeros((n,n))\n        A = np.array(sys.A)         # convert to NumPy array for slycot\n        X,scale,sep,ferr,w = sb03md(n, C, A, U, dico, job=\'X\', fact=\'N\', trana=tra)\n        gram = X\n        return _ssmatrix(gram)\n\n    elif type==\'cf\' or type==\'of\':\n        #Compute cholesky factored gramian from slycot routine sb03od\n        try:\n            from slycot import sb03od\n        except ImportError:\n            raise ControlSlycot(""can\'t find slycot module \'sb03od\'"")\n        tra=\'N\'\n        n = sys.states\n        Q = np.zeros((n,n))\n        A = np.array(sys.A)         # convert to NumPy array for slycot\n        if type==\'cf\':\n            m = sys.B.shape[1]\n            B = np.zeros_like(A)\n            B[0:m,0:n] = sys.B.transpose()\n            X,scale,w = sb03od(n, m, A.transpose(), Q, B, dico, fact=\'N\', trans=tra)\n        elif type==\'of\':\n            m = sys.C.shape[0]\n            C = np.zeros_like(A)\n            C[0:n,0:m] = sys.C.transpose()\n            X,scale,w = sb03od(n, m, A, Q, C.transpose(), dico, fact=\'N\', trans=tra)\n        gram = X\n        return _ssmatrix(gram)\n'"
External_Libraries/python_control_master/control/statesp.py,56,"b'""""""statesp.py\n\nState space representation and functions.\n\nThis file contains the StateSpace class, which is used to represent linear\nsystems in state space.  This is the primary representation for the\npython-control library.\n\n""""""\n\n# Python 3 compatibility (needs to go here)\nfrom __future__ import print_function\nfrom __future__ import division # for _convertToStateSpace\n\n""""""Copyright (c) 2010 by California Institute of Technology\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 24 May 09\nRevised: Kevin K. Chen, Dec 10\n\n$Id$\n""""""\n\nimport math\nimport numpy as np\nfrom numpy import any, array, asarray, concatenate, cos, delete, \\\n    dot, empty, exp, eye, isinf, ones, pad, sin, zeros, squeeze\nfrom numpy.random import rand, randn\nfrom numpy.linalg import solve, eigvals, matrix_rank\nfrom numpy.linalg.linalg import LinAlgError\nimport scipy as sp\nfrom scipy.signal import lti, cont2discrete\nfrom warnings import warn\nfrom .lti import LTI, timebase, timebaseEqual, isdtime\nfrom . import config\nfrom copy import deepcopy\n\n__all__ = [\'StateSpace\', \'ss\', \'rss\', \'drss\', \'tf2ss\', \'ssdata\']\n\n\n# Define module default parameter values\n_statesp_defaults = {\n    \'statesp.use_numpy_matrix\':True,\n}\n\n\ndef _ssmatrix(data, axis=1):\n    """"""Convert argument to a (possibly empty) state space matrix.\n\n    Parameters\n    ----------\n    data : array, list, or string\n        Input data defining the contents of the 2D array\n    axis : 0 or 1\n        If input data is 1D, which axis to use for return object.  The default\n        is 1, corresponding to a row matrix.\n\n    Returns\n    -------\n    arr : 2D array, with shape (0, 0) if a is empty\n\n    """"""\n    # Convert the data into an array or matrix, as configured\n    # If data is passed as a string, use (deprecated?) matrix constructor\n    if config.defaults[\'statesp.use_numpy_matrix\'] or isinstance(data, str):\n        arr = np.matrix(data, dtype=float)\n    else:\n        arr = np.array(data, dtype=float)\n    ndim = arr.ndim\n    shape = arr.shape\n\n    # Change the shape of the array into a 2D array\n    if (ndim > 2):\n        raise ValueError(""state-space matrix must be 2-dimensional"")\n\n    elif (ndim == 2 and shape == (1, 0)) or \\\n         (ndim == 1 and shape == (0, )):\n        # Passed an empty matrix or empty vector; change shape to (0, 0)\n        shape = (0, 0)\n\n    elif ndim == 1:\n        # Passed a row or column vector\n        shape = (1, shape[0]) if axis == 1 else (shape[0], 1)\n\n    elif ndim == 0:\n        # Passed a constant; turn into a matrix\n        shape = (1, 1)\n\n    #  Create the actual object used to store the result\n    return arr.reshape(shape)\n\n\nclass StateSpace(LTI):\n    """"""StateSpace(A, B, C, D[, dt])\n\n    A class for representing state-space models\n\n    The StateSpace class is used to represent state-space realizations of linear\n    time-invariant (LTI) systems:\n\n        dx/dt = A x + B u\n            y = C x + D u\n\n    where u is the input, y is the output, and x is the state.\n\n    The main data members are the A, B, C, and D matrices.  The class also\n    keeps track of the number of states (i.e., the size of A).  The data\n    format used to store state space matrices is set using the value of\n    `config.defaults[\'use_numpy_matrix\']`.  If True (default), the state space\n    elements are stored as `numpy.matrix` objects; otherwise they are\n    `numpy.ndarray` objects.  The :func:`~control.use_numpy_matrix` function\n    can be used to set the storage type.\n\n    Discrete-time state space system are implemented by using the \'dt\'\n    instance variable and setting it to the sampling period.  If \'dt\' is not\n    None, then it must match whenever two state space systems are combined.\n    Setting dt = 0 specifies a continuous system, while leaving dt = None\n    means the system timebase is not specified.  If \'dt\' is set to True, the\n    system will be treated as a discrete time system with unspecified sampling\n    time.\n\n    """"""\n\n    # Allow ndarray * StateSpace to give StateSpace._rmul_() priority\n    __array_priority__ = 11     # override ndarray and matrix types\n\n\n    def __init__(self, *args, **kw):\n        """"""\n        StateSpace(A, B, C, D[, dt])\n\n        Construct a state space object.\n\n        The default constructor is StateSpace(A, B, C, D), where A, B, C, D\n        are matrices or equivalent objects.  To create a discrete time system,\n        use StateSpace(A, B, C, D, dt) where \'dt\' is the sampling time (or\n        True for unspecified sampling time).  To call the copy constructor,\n        call StateSpace(sys), where sys is a StateSpace object.\n\n        """"""\n        if len(args) == 4:\n            # The user provided A, B, C, and D matrices.\n            (A, B, C, D) = args\n            dt = None\n        elif len(args) == 5:\n            # Discrete time system\n            (A, B, C, D, dt) = args\n        elif len(args) == 1:\n            # Use the copy constructor.\n            if not isinstance(args[0], StateSpace):\n                raise TypeError(""The one-argument constructor can only take in a StateSpace ""\n                                ""object.  Received %s."" % type(args[0]))\n            A = args[0].A\n            B = args[0].B\n            C = args[0].C\n            D = args[0].D\n            try:\n                dt = args[0].dt\n            except NameError:\n                dt = None\n        else:\n            raise ValueError(""Needs 1 or 4 arguments; received %i."" % len(args))\n\n        # Process keyword arguments\n        remove_useless = kw.get(\'remove_useless\', True)\n\n        # Convert all matrices to standard form\n        A = _ssmatrix(A)\n        B = _ssmatrix(B, axis=0)\n        C = _ssmatrix(C, axis=1)\n        if np.isscalar(D) and D == 0 and B.shape[1] > 0 and C.shape[0] > 0:\n            # If D is a scalar zero, broadcast it to the proper size\n            D = np.zeros((C.shape[0], B.shape[1]))\n        D = _ssmatrix(D)\n\n        # TODO: use super here?\n        LTI.__init__(self, inputs=D.shape[1], outputs=D.shape[0], dt=dt)\n        self.A = A\n        self.B = B\n        self.C = C\n        self.D = D\n\n        self.states = A.shape[1]\n\n        if 0 == self.states:\n            # static gain\n            # matrix\'s default ""empty"" shape is 1x0\n            A.shape = (0,0)\n            B.shape = (0,self.inputs)\n            C.shape = (self.outputs,0)\n\n        # Check that the matrix sizes are consistent.\n        if self.states != A.shape[0]:\n            raise ValueError(""A must be square."")\n        if self.states != B.shape[0]:\n            raise ValueError(""A and B must have the same number of rows."")\n        if self.states != C.shape[1]:\n            raise ValueError(""A and C must have the same number of columns."")\n        if self.inputs != B.shape[1]:\n            raise ValueError(""B and D must have the same number of columns."")\n        if self.outputs != C.shape[0]:\n            raise ValueError(""C and D must have the same number of rows."")\n\n        # Check for states that don\'t do anything, and remove them.\n        if remove_useless: self._remove_useless_states()\n\n    def _remove_useless_states(self):\n        """"""Check for states that don\'t do anything, and remove them.\n\n        Scan the A, B, and C matrices for rows or columns of zeros.  If the\n        zeros are such that a particular state has no effect on the input-output\n        dynamics, then remove that state from the A, B, and C matrices.\n\n        """"""\n\n        # Search for useless states and get indices of these states.\n        #\n        # Note: shape from np.where depends on whether we are storing state\n        # space objects as np.matrix or np.array.  Code below will work\n        # correctly in either case.\n        ax1_A = np.where(~self.A.any(axis=1))[0]\n        ax1_B = np.where(~self.B.any(axis=1))[0]\n        ax0_A = np.where(~self.A.any(axis=0))[-1]\n        ax0_C = np.where(~self.C.any(axis=0))[-1]\n        useless_1 = np.intersect1d(ax1_A, ax1_B, assume_unique=True)\n        useless_2 = np.intersect1d(ax0_A, ax0_C, assume_unique=True)\n        useless = np.union1d(useless_1, useless_2)\n\n        # Remove the useless states.\n        self.A = delete(self.A, useless, 0)\n        self.A = delete(self.A, useless, 1)\n        self.B = delete(self.B, useless, 0)\n        self.C = delete(self.C, useless, 1)\n\n        self.states = self.A.shape[0]\n        self.inputs = self.B.shape[1]\n        self.outputs = self.C.shape[0]\n\n    def __str__(self):\n        """"""String representation of the state space.""""""\n\n        str = ""A = "" + self.A.__str__() + ""\\n\\n""\n        str += ""B = "" + self.B.__str__() + ""\\n\\n""\n        str += ""C = "" + self.C.__str__() + ""\\n\\n""\n        str += ""D = "" + self.D.__str__() + ""\\n""\n        # TODO: replace with standard calls to lti functions\n        if (type(self.dt) == bool and self.dt is True):\n            str += ""\\ndt unspecified\\n""\n        elif (not (self.dt is None) and type(self.dt) != bool and self.dt > 0):\n            str += ""\\ndt = "" + self.dt.__str__() + ""\\n""\n        return str\n\n    # represent as string, makes display work for IPython\n    __repr__ = __str__\n\n    # Negation of a system\n    def __neg__(self):\n        """"""Negate a state space system.""""""\n\n        return StateSpace(self.A, self.B, -self.C, -self.D, self.dt)\n\n    # Addition of two state space systems (parallel interconnection)\n    def __add__(self, other):\n        """"""Add two LTI systems (parallel connection).""""""\n\n        # Check for a couple of special cases\n        if isinstance(other, (int, float, complex, np.number)):\n            # Just adding a scalar; put it in the D matrix\n            A, B, C = self.A, self.B, self.C\n            D = self.D + other\n            dt = self.dt\n        else:\n            other = _convertToStateSpace(other)\n\n            # Check to make sure the dimensions are OK\n            if ((self.inputs != other.inputs) or\n                    (self.outputs != other.outputs)):\n                raise ValueError(""Systems have different shapes."")\n\n            # Figure out the sampling time to use\n            if self.dt is None and other.dt is not None:\n                dt = other.dt       # use dt from second argument\n            elif (other.dt is None and self.dt is not None) or \\\n                    (timebaseEqual(self, other)):\n                dt = self.dt        # use dt from first argument\n            else:\n                raise ValueError(""Systems have different sampling times"")\n\n            # Concatenate the various arrays\n            A = concatenate((\n                concatenate((self.A, zeros((self.A.shape[0],\n                                           other.A.shape[-1]))),axis=1),\n                concatenate((zeros((other.A.shape[0], self.A.shape[-1])),\n                                other.A),axis=1)\n                            ),axis=0)\n            B = concatenate((self.B, other.B), axis=0)\n            C = concatenate((self.C, other.C), axis=1)\n            D = self.D + other.D\n\n        return StateSpace(A, B, C, D, dt)\n\n    # Right addition - just switch the arguments\n    def __radd__(self, other):\n        """"""Right add two LTI systems (parallel connection).""""""\n\n        return self + other\n\n    # Subtraction of two state space systems (parallel interconnection)\n    def __sub__(self, other):\n        """"""Subtract two LTI systems.""""""\n\n        return self + (-other)\n\n    def __rsub__(self, other):\n        """"""Right subtract two LTI systems.""""""\n\n        return other + (-self)\n\n    # Multiplication of two state space systems (series interconnection)\n    def __mul__(self, other):\n        """"""Multiply two LTI objects (serial connection).""""""\n\n        # Check for a couple of special cases\n        if isinstance(other, (int, float, complex, np.number)):\n            # Just multiplying by a scalar; change the output\n            A, B = self.A, self.B\n            C = self.C * other\n            D = self.D * other\n            dt = self.dt\n        else:\n            other = _convertToStateSpace(other)\n\n            # Check to make sure the dimensions are OK\n            if self.inputs != other.outputs:\n                raise ValueError(""C = A * B: A has %i column(s) (input(s)), \\\nbut B has %i row(s)\\n(output(s))."" % (self.inputs, other.outputs))\n\n            # Figure out the sampling time to use\n            if (self.dt == None and other.dt != None):\n                dt = other.dt       # use dt from second argument\n            elif (other.dt == None and self.dt != None) or \\\n                    (timebaseEqual(self, other)):\n                dt = self.dt        # use dt from first argument\n            else:\n                raise ValueError(""Systems have different sampling times"")\n\n            # Concatenate the various arrays\n            A = concatenate(\n                (concatenate((other.A,\n                              zeros((other.A.shape[0], self.A.shape[1]))),\n                             axis=1),\n                 concatenate((np.dot(self.B, other.C), self.A), axis=1)),\n                axis=0)\n            B = concatenate((other.B, np.dot(self.B, other.D)), axis=0)\n            C = concatenate((np.dot(self.D, other.C), self.C),axis=1)\n            D = np.dot(self.D, other.D)\n\n        return StateSpace(A, B, C, D, dt)\n\n    # Right multiplication of two state space systems (series interconnection)\n    # Just need to convert LH argument to a state space object\n    # TODO: __rmul__ only works for special cases (??)\n    def __rmul__(self, other):\n        """"""Right multiply two LTI objects (serial connection).""""""\n\n        # Check for a couple of special cases\n        if isinstance(other, (int, float, complex, np.number)):\n            # Just multiplying by a scalar; change the input\n            A, C = self.A, self.C\n            B = self.B * other\n            D = self.D * other\n            return StateSpace(A, B, C, D, self.dt)\n\n        # is lti, and convertible?\n        if isinstance(other, LTI):\n            return _convertToStateSpace(other) * self\n\n        # try to treat this as a matrix\n        try:\n            X = _ssmatrix(other)\n            C = np.dot(X, self.C)\n            D = np.dot(X, self.D)\n            return StateSpace(self.A, self.B, C, D, self.dt)\n\n        except Exception as e:\n            print(e)\n            pass\n        raise TypeError(""can\'t interconnect systems"")\n\n    # TODO: __div__ and __rdiv__ are not written yet.\n    def __div__(self, other):\n        """"""Divide two LTI systems.""""""\n\n        raise NotImplementedError(""StateSpace.__div__ is not implemented yet."")\n\n    def __rdiv__(self, other):\n        """"""Right divide two LTI systems.""""""\n\n        raise NotImplementedError(""StateSpace.__rdiv__ is not implemented yet."")\n\n    def evalfr(self, omega):\n        """"""Evaluate a SS system\'s transfer function at a single frequency.\n\n        self._evalfr(omega) returns the value of the transfer function matrix\n        with input value s = i * omega.\n\n        """"""\n        warn(""StateSpace.evalfr(omega) will be deprecated in a future ""\n             ""release of python-control; use evalfr(sys, omega*1j) instead"",\n             PendingDeprecationWarning)\n        return self._evalfr(omega)\n\n    def _evalfr(self, omega):\n        """"""Evaluate a SS system\'s transfer function at a single frequency""""""\n        # Figure out the point to evaluate the transfer function\n        if isdtime(self, strict=True):\n            dt = timebase(self)\n            s = exp(1.j * omega * dt)\n            if omega * dt > math.pi:\n                warn(""_evalfr: frequency evaluation above Nyquist frequency"")\n        else:\n            s = omega * 1.j\n\n        return self.horner(s)\n\n    def horner(self, s):\n        """"""Evaluate the systems\'s transfer function for a complex variable\n\n        Returns a matrix of values evaluated at complex variable s.\n        """"""\n        resp = np.dot(self.C, solve(s * eye(self.states) - self.A,\n                                    self.B)) + self.D\n        return array(resp)\n\n    # Method for generating the frequency response of the system\n    def freqresp(self, omega):\n        """"""Evaluate the system\'s transfer func. at a list of freqs, omega.\n\n        mag, phase, omega = self.freqresp(omega)\n\n        Reports the frequency response of the system,\n\n             G(j*omega) = mag*exp(j*phase)\n\n        for continuous time. For discrete time systems, the response is\n        evaluated around the unit circle such that\n\n             G(exp(j*omega*dt)) = mag*exp(j*phase).\n\n        Parameters\n        ----------\n        omega : array\n            A list of frequencies in radians/sec at which the system should be\n            evaluated. The list can be either a python list or a numpy array\n            and will be sorted before evaluation.\n\n        Returns\n        -------\n        mag : float\n            The magnitude (absolute value, not dB or log10) of the system\n            frequency response.\n\n        phase : float\n            The wrapped phase in radians of the system frequency response.\n\n        omega : array\n            The list of sorted frequencies at which the response was\n            evaluated.\n\n        """"""\n\n        # In case omega is passed in as a list, rather than a proper array.\n        omega = np.asarray(omega)\n\n        numFreqs = len(omega)\n        Gfrf = np.empty((self.outputs, self.inputs, numFreqs),\n                        dtype=np.complex128)\n\n        # Sort frequency and calculate complex frequencies on either imaginary\n        # axis (continuous time) or unit circle (discrete time).\n        omega.sort()\n        if isdtime(self, strict=True):\n            dt = timebase(self)\n            cmplx_freqs = exp(1.j * omega * dt)\n            if max(np.abs(omega)) * dt > math.pi:\n                warn(""freqresp: frequency evaluation above Nyquist frequency"")\n        else:\n            cmplx_freqs = omega * 1.j\n\n        # Do the frequency response evaluation. Use TB05AD from Slycot\n        # if it\'s available, otherwise use the built-in horners function.\n        try:\n            from slycot import tb05ad\n\n            n = np.shape(self.A)[0]\n            m = self.inputs\n            p = self.outputs\n            # The first call both evaluates C(sI-A)^-1 B and also returns\n            # Hessenberg transformed matrices at, bt, ct.\n            result = tb05ad(n, m, p, cmplx_freqs[0], self.A,\n                            self.B, self.C, job=\'NG\')\n            # When job=\'NG\', result = (at, bt, ct, g_i, hinvb, info)\n            at = result[0]\n            bt = result[1]\n            ct = result[2]\n\n            # TB05AD frequency evaluation does not include direct feedthrough.\n            Gfrf[:, :, 0] = result[3] + self.D\n\n            # Now, iterate through the remaining frequencies using the\n            # transformed state matrices, at, bt, ct.\n\n            # Start at the second frequency, already have the first.\n            for kk, cmplx_freqs_kk in enumerate(cmplx_freqs[1:numFreqs]):\n                result = tb05ad(n, m, p, cmplx_freqs_kk, at,\n                                bt, ct, job=\'NH\')\n                # When job=\'NH\', result = (g_i, hinvb, info)\n\n                # kk+1 because enumerate starts at kk = 0.\n                # but zero-th spot is already filled.\n                Gfrf[:, :, kk+1] = result[0] + self.D\n\n        except ImportError:  # Slycot unavailable. Fall back to horner.\n            for kk, cmplx_freqs_kk in enumerate(cmplx_freqs):\n                Gfrf[:, :, kk] = self.horner(cmplx_freqs_kk)\n\n        #      mag           phase           omega\n        return np.abs(Gfrf), np.angle(Gfrf), omega\n\n    # Compute poles and zeros\n    def pole(self):\n        """"""Compute the poles of a state space system.""""""\n\n        return eigvals(self.A) if self.states else np.array([])\n\n    def zero(self):\n        """"""Compute the zeros of a state space system.""""""\n\n        if not self.states:\n            return np.array([])\n\n        # Use AB08ND from Slycot if it\'s available, otherwise use\n        # scipy.lingalg.eigvals().\n        try:\n            from slycot import ab08nd\n\n            out = ab08nd(self.A.shape[0], self.B.shape[1], self.C.shape[0],\n                         self.A, self.B, self.C, self.D)\n            nu = out[0]\n            if nu == 0:\n                return np.array([])\n            else:\n                return sp.linalg.eigvals(out[8][0:nu, 0:nu], out[9][0:nu, 0:nu])\n\n        except ImportError:  # Slycot unavailable. Fall back to scipy.\n            if self.C.shape[0] != self.D.shape[1]:\n                raise NotImplementedError(""StateSpace.zero only supports ""\n                                          ""systems with the same number of ""\n                                          ""inputs as outputs."")\n\n            # This implements the QZ algorithm for finding transmission zeros\n            # from\n            # https://dspace.mit.edu/bitstream/handle/1721.1/841/P-0802-06587335.pdf.\n            # The QZ algorithm solves the generalized eigenvalue problem: given\n            # `L = [A, B; C, D]` and `M = [I_nxn 0]`, find all finite lambda\n            # for which there exist nontrivial solutions of the equation\n            # `Lz - lamba Mz`.\n            #\n            # The generalized eigenvalue problem is only solvable if its\n            # arguments are square matrices.\n            L = concatenate((concatenate((self.A, self.B), axis=1),\n                             concatenate((self.C, self.D), axis=1)), axis=0)\n            M = pad(eye(self.A.shape[0]), ((0, self.C.shape[0]),\n                                           (0, self.B.shape[1])), ""constant"")\n            return np.array([x for x in sp.linalg.eigvals(L, M, overwrite_a=True)\n                             if not isinf(x)])\n\n    # Feedback around a state space system\n    def feedback(self, other=1, sign=-1):\n        """"""Feedback interconnection between two LTI systems.""""""\n\n        other = _convertToStateSpace(other)\n\n        # Check to make sure the dimensions are OK\n        if (self.inputs != other.outputs) or (self.outputs != other.inputs):\n                raise ValueError(""State space systems don\'t have compatible inputs/outputs for ""\n                                 ""feedback."")\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif other.dt is None and self.dt is not None or timebaseEqual(self, other):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        A1 = self.A\n        B1 = self.B\n        C1 = self.C\n        D1 = self.D\n        A2 = other.A\n        B2 = other.B\n        C2 = other.C\n        D2 = other.D\n\n        F = eye(self.inputs) - sign * np.dot(D2, D1)\n        if matrix_rank(F) != self.inputs:\n            raise ValueError(""I - sign * D2 * D1 is singular to working precision."")\n\n        # Precompute F\\D2 and F\\C2 (E = inv(F))\n        # We can solve two linear systems in one pass, since the\n        # coefficients matrix F is the same. Thus, we perform the LU\n        # decomposition (cubic runtime complexity) of F only once!\n        # The remaining back substitutions are only quadratic in runtime.\n        E_D2_C2 = solve(F, concatenate((D2, C2), axis=1))\n        E_D2 = E_D2_C2[:, :other.inputs]\n        E_C2 = E_D2_C2[:, other.inputs:]\n\n        T1 = eye(self.outputs) + sign * np.dot(D1, E_D2)\n        T2 = eye(self.inputs) + sign * np.dot(E_D2, D1)\n\n        A = concatenate(\n            (concatenate(\n                (A1 + sign * np.dot(np.dot(B1, E_D2), C1),\n                 sign * np.dot(B1, E_C2)), axis=1),\n             concatenate(\n                 (np.dot(B2, np.dot(T1, C1)),\n                  A2 + sign * np.dot(np.dot(B2, D1), E_C2)), axis=1)),\n            axis=0)\n        B = concatenate((np.dot(B1, T2), np.dot(np.dot(B2, D1), T2)), axis=0)\n        C = concatenate((np.dot(T1, C1), sign * np.dot(D1, E_C2)), axis=1)\n        D = np.dot(D1, T2)\n\n        return StateSpace(A, B, C, D, dt)\n\n    def lft(self, other, nu=-1, ny=-1):\n        """"""Return the Linear Fractional Transformation.\n\n        A definition of the LFT operator can be found in Appendix A.7,\n        page 512 in the 2nd Edition, Multivariable Feedback Control by\n        Sigurd Skogestad.\n\n        An alternative definition can be found here:\n        https://www.mathworks.com/help/control/ref/lft.html\n\n        Parameters\n        ----------\n        other : LTI\n            The lower LTI system\n        ny : int, optional\n            Dimension of (plant) measurement output.\n        nu : int, optional\n            Dimension of (plant) control input.\n\n        """"""\n        other = _convertToStateSpace(other)\n        # maximal values for nu, ny\n        if ny == -1:\n            ny = min(other.inputs, self.outputs)\n        if nu == -1:\n            nu = min(other.outputs, self.inputs)\n        # dimension check\n        # TODO\n\n        # Figure out the sampling time to use\n        if (self.dt == None and other.dt != None):\n            dt = other.dt       # use dt from second argument\n        elif (other.dt == None and self.dt != None) or \\\n                timebaseEqual(self, other):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different time bases"")\n\n        # submatrices\n        A = self.A\n        B1 = self.B[:, :self.inputs - nu]\n        B2 = self.B[:, self.inputs - nu:]\n        C1 = self.C[:self.outputs - ny, :]\n        C2 = self.C[self.outputs - ny:, :]\n        D11 = self.D[:self.outputs - ny, :self.inputs - nu]\n        D12 = self.D[:self.outputs - ny, self.inputs - nu:]\n        D21 = self.D[self.outputs - ny:, :self.inputs - nu]\n        D22 = self.D[self.outputs - ny:, self.inputs - nu:]\n\n        # submatrices\n        Abar = other.A\n        Bbar1 = other.B[:, :ny]\n        Bbar2 = other.B[:, ny:]\n        Cbar1 = other.C[:nu, :]\n        Cbar2 = other.C[nu:, :]\n        Dbar11 = other.D[:nu, :ny]\n        Dbar12 = other.D[:nu, ny:]\n        Dbar21 = other.D[nu:, :ny]\n        Dbar22 = other.D[nu:, ny:]\n\n        # well-posed check\n        F = np.block([[np.eye(ny), -D22], [-Dbar11, np.eye(nu)]])\n        if matrix_rank(F) != ny + nu:\n            raise ValueError(""lft not well-posed to working precision."")\n\n        # solve for the resulting ss by solving for [y, u] using [x,\n        # xbar] and [w1, w2].\n        TH = np.linalg.solve(F, np.block(\n            [[C2, np.zeros((ny, other.states)), D21, np.zeros((ny, other.inputs - ny))],\n             [np.zeros((nu, self.states)), Cbar1, np.zeros((nu, self.inputs - nu)), Dbar12]]\n        ))\n        T11 = TH[:ny, :self.states]\n        T12 = TH[:ny, self.states: self.states + other.states]\n        T21 = TH[ny:, :self.states]\n        T22 = TH[ny:, self.states: self.states + other.states]\n        H11 = TH[:ny, self.states + other.states: self.states + other.states + self.inputs - nu]\n        H12 = TH[:ny, self.states + other.states + self.inputs - nu:]\n        H21 = TH[ny:, self.states + other.states: self.states + other.states + self.inputs - nu]\n        H22 = TH[ny:, self.states + other.states + self.inputs - nu:]\n\n        Ares = np.block([\n            [A + B2.dot(T21), B2.dot(T22)],\n            [Bbar1.dot(T11), Abar + Bbar1.dot(T12)]\n        ])\n\n        Bres = np.block([\n            [B1 + B2.dot(H21), B2.dot(H22)],\n            [Bbar1.dot(H11), Bbar2 + Bbar1.dot(H12)]\n        ])\n\n        Cres = np.block([\n            [C1 + D12.dot(T21), D12.dot(T22)],\n            [Dbar21.dot(T11), Cbar2 + Dbar21.dot(T12)]\n        ])\n\n        Dres = np.block([\n            [D11 + D12.dot(H21), D12.dot(H22)],\n            [Dbar21.dot(H11), Dbar22 + Dbar21.dot(H12)]\n        ])\n        return StateSpace(Ares, Bres, Cres, Dres, dt)\n\n    def minreal(self, tol=0.0):\n        """"""Calculate a minimal realization, removes unobservable and\n        uncontrollable states""""""\n        if self.states:\n            try:\n                from slycot import tb01pd\n                B = empty((self.states, max(self.inputs, self.outputs)))\n                B[:,:self.inputs] = self.B\n                C = empty((max(self.outputs, self.inputs), self.states))\n                C[:self.outputs,:] = self.C\n                A, B, C, nr = tb01pd(self.states, self.inputs, self.outputs,\n                                     self.A, B, C, tol=tol)\n                return StateSpace(A[:nr,:nr], B[:nr,:self.inputs],\n                                  C[:self.outputs,:nr], self.D)\n            except ImportError:\n                raise TypeError(""minreal requires slycot tb01pd"")\n        else:\n            return StateSpace(self)\n\n\n    # TODO: add discrete time check\n    def returnScipySignalLTI(self):\n        """"""Return a list of a list of scipy.signal.lti objects.\n\n        For instance,\n\n        >>> out = ssobject.returnScipySignalLTI()\n        >>> out[3][5]\n\n        is a signal.scipy.lti object corresponding to the transfer function from\n        the 6th input to the 4th output.""""""\n\n        # Preallocate the output.\n        out = [[[] for _ in range(self.inputs)] for _ in range(self.outputs)]\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                out[i][j] = lti(asarray(self.A), asarray(self.B[:, j]),\n                                asarray(self.C[i, :]), self.D[i, j])\n\n        return out\n\n    def append(self, other):\n        """"""Append a second model to the present model. The second\n        model is converted to state-space if necessary, inputs and\n        outputs are appended and their order is preserved""""""\n        if not isinstance(other, StateSpace):\n            other = _convertToStateSpace(other)\n\n        if self.dt != other.dt:\n            raise ValueError(""Systems must have the same time step"")\n\n        n = self.states + other.states\n        m = self.inputs + other.inputs\n        p = self.outputs + other.outputs\n        A = zeros((n, n))\n        B = zeros((n, m))\n        C = zeros((p, n))\n        D = zeros((p, m))\n        A[:self.states, :self.states] = self.A\n        A[self.states:, self.states:] = other.A\n        B[:self.states, :self.inputs] = self.B\n        B[self.states:, self.inputs:] = other.B\n        C[:self.outputs, :self.states] = self.C\n        C[self.outputs:, self.states:] = other.C\n        D[:self.outputs, :self.inputs] = self.D\n        D[self.outputs:, self.inputs:] = other.D\n        return StateSpace(A, B, C, D, self.dt)\n\n    def __getitem__(self, indices):\n        """"""Array style access""""""\n        if len(indices) != 2:\n            raise IOError(\'must provide indices of length 2 for state space\')\n        i = indices[0]\n        j = indices[1]\n        return StateSpace(self.A, self.B[:, j], self.C[i, :], self.D[i, j], self.dt)\n\n    def sample(self, Ts, method=\'zoh\', alpha=None):\n        """"""Convert a continuous time system to discrete time\n\n        Creates a discrete-time system from a continuous-time system by\n        sampling.  Multiple methods of conversion are supported.\n\n        Parameters\n        ----------\n        Ts : float\n            Sampling period\n        method :  {""gbt"", ""bilinear"", ""euler"", ""backward_diff"", ""zoh""}\n            Which method to use:\n\n            * gbt: generalized bilinear transformation\n            * bilinear: Tustin\'s approximation (""gbt"" with alpha=0.5)\n            * euler: Euler (or forward differencing) method (""gbt"" with\n              alpha=0)\n            * backward_diff: Backwards differencing (""gbt"" with alpha=1.0)\n            * zoh: zero-order hold (default)\n\n        alpha : float within [0, 1]\n            The generalized bilinear transformation weighting parameter, which\n            should only be specified with method=""gbt"", and is ignored\n            otherwise\n\n        Returns\n        -------\n        sysd : StateSpace\n            Discrete time system, with sampling rate Ts\n\n        Notes\n        -----\n        Uses the command \'cont2discrete\' from scipy.signal\n\n        Examples\n        --------\n        >>> sys = StateSpace(0, 1, 1, 0)\n        >>> sysd = sys.sample(0.5, method=\'bilinear\')\n\n        """"""\n        if not self.isctime():\n            raise ValueError(""System must be continuous time system"")\n\n        sys = (self.A, self.B, self.C, self.D)\n        Ad, Bd, C, D, dt = cont2discrete(sys, Ts, method, alpha)\n        return StateSpace(Ad, Bd, C, D, dt)\n\n    def dcgain(self):\n        """"""Return the zero-frequency gain\n\n        The zero-frequency gain of a continuous-time state-space\n        system is given by:\n\n        .. math: G(0) = - C A^{-1} B + D\n\n        and of a discrete-time state-space system by:\n\n        .. math: G(1) = C (I - A)^{-1} B + D\n\n        Returns\n        -------\n        gain : ndarray\n            An array of shape (outputs,inputs); the array will either\n            be the zero-frequency (or DC) gain, or, if the frequency\n            response is singular, the array will be filled with np.nan.\n        """"""\n        try:\n            if self.isctime():\n                gain = np.asarray(self.D-self.C.dot(np.linalg.solve(self.A, self.B)))\n            else:\n                gain = self.horner(1)\n        except LinAlgError:\n            # eigenvalue at DC\n            gain = np.tile(np.nan, (self.outputs, self.inputs))\n        return np.squeeze(gain)\n\n\n# TODO: add discrete time check\ndef _convertToStateSpace(sys, **kw):\n    """"""Convert a system to state space form (if needed).\n\n    If sys is already a state space, then it is returned.  If sys is a transfer\n    function object, then it is converted to a state space and returned.  If sys\n    is a scalar, then the number of inputs and outputs can be specified\n    manually, as in:\n\n    >>> sys = _convertToStateSpace(3.) # Assumes inputs = outputs = 1\n    >>> sys = _convertToStateSpace(1., inputs=3, outputs=2)\n\n    In the latter example, A = B = C = 0 and D = [[1., 1., 1.]\n                                                  [1., 1., 1.]].\n\n    """"""\n    from .xferfcn import TransferFunction\n    import itertools\n    if isinstance(sys, StateSpace):\n        if len(kw):\n            raise TypeError(""If sys is a StateSpace, _convertToStateSpace \\\ncannot take keywords."")\n\n        # Already a state space system; just return it\n        return sys\n    elif isinstance(sys, TransferFunction):\n        try:\n            from slycot import td04ad\n            if len(kw):\n                raise TypeError(""If sys is a TransferFunction, ""\n                                ""_convertToStateSpace cannot take keywords."")\n\n            # Change the numerator and denominator arrays so that the transfer\n            # function matrix has a common denominator.\n            # matrices are also sized/padded to fit td04ad\n            num, den, denorder = sys.minreal()._common_den()\n\n            # transfer function to state space conversion now should work!\n            ssout = td04ad(\'C\', sys.inputs, sys.outputs,\n                           denorder, den, num, tol=0)\n\n            states = ssout[0]\n            return StateSpace(ssout[1][:states, :states], ssout[2][:states, :sys.inputs],\n                              ssout[3][:sys.outputs, :states], ssout[4], sys.dt)\n        except ImportError:\n            # No Slycot.  Scipy tf->ss can\'t handle MIMO, but static\n            # MIMO is an easy special case we can check for here\n            maxn = max(max(len(n) for n in nrow)\n                       for nrow in sys.num)\n            maxd = max(max(len(d) for d in drow)\n                       for drow in sys.den)\n            if 1 == maxn and 1 == maxd:\n                D = empty((sys.outputs, sys.inputs), dtype=float)\n                for i, j in itertools.product(range(sys.outputs), range(sys.inputs)):\n                    D[i, j] = sys.num[i][j][0] / sys.den[i][j][0]\n                return StateSpace([], [], [], D, sys.dt)\n            else:\n                if sys.inputs != 1 or sys.outputs != 1:\n                    raise TypeError(""No support for MIMO without slycot"")\n\n                # TODO: do we want to squeeze first and check dimenations?\n                # I think this will fail if num and den aren\'t 1-D after\n                # the squeeze\n                A, B, C, D = sp.signal.tf2ss(squeeze(sys.num), squeeze(sys.den))\n                return StateSpace(A, B, C, D, sys.dt)\n\n    elif isinstance(sys, (int, float, complex, np.number)):\n        if ""inputs"" in kw:\n            inputs = kw[""inputs""]\n        else:\n            inputs = 1\n        if ""outputs"" in kw:\n            outputs = kw[""outputs""]\n        else:\n            outputs = 1\n\n        # Generate a simple state space system of the desired dimension\n        # The following Doesn\'t work due to inconsistencies in ltisys:\n        #   return StateSpace([[]], [[]], [[]], eye(outputs, inputs))\n        return StateSpace(0., zeros((1, inputs)), zeros((outputs, 1)),\n            sys * ones((outputs, inputs)))\n\n    # If this is a matrix, try to create a constant feedthrough\n    try:\n        D = _ssmatrix(sys)\n        return StateSpace([], [], [], D)\n    except Exception as e:\n        print(""Failure to assume argument is matrix-like in"" \\\n            "" _convertToStateSpace, result %s"" % e)\n\n    raise TypeError(""Can\'t convert given type to StateSpace system."")\n\n# TODO: add discrete time option\ndef _rss_generate(states, inputs, outputs, type):\n    """"""Generate a random state space.\n\n    This does the actual random state space generation expected from rss and\n    drss.  type is \'c\' for continuous systems and \'d\' for discrete systems.\n\n    """"""\n\n    # Probability of repeating a previous root.\n    pRepeat = 0.05\n    # Probability of choosing a real root.  Note that when choosing a complex\n    # root, the conjugate gets chosen as well.  So the expected proportion of\n    # real roots is pReal / (pReal + 2 * (1 - pReal)).\n    pReal = 0.6\n    # Probability that an element in B or C will not be masked out.\n    pBCmask = 0.8\n    # Probability that an element in D will not be masked out.\n    pDmask = 0.3\n    # Probability that D = 0.\n    pDzero = 0.5\n\n    # Check for valid input arguments.\n    if states < 1 or states % 1:\n        raise ValueError(""states must be a positive integer.  states = %g."" %\n            states)\n    if inputs < 1 or inputs % 1:\n        raise ValueError(""inputs must be a positive integer.  inputs = %g."" %\n            inputs)\n    if outputs < 1 or outputs % 1:\n        raise ValueError(""outputs must be a positive integer.  outputs = %g."" %\n            outputs)\n\n    # Make some poles for A.  Preallocate a complex array.\n    poles = zeros(states) + zeros(states) * 0.j\n    i = 0\n\n    while i < states:\n        if rand() < pRepeat and i != 0 and i != states - 1:\n            # Small chance of copying poles, if we\'re not at the first or last\n            # element.\n            if poles[i-1].imag == 0:\n                # Copy previous real pole.\n                poles[i] = poles[i-1]\n                i += 1\n            else:\n                # Copy previous complex conjugate pair of poles.\n                poles[i:i+2] = poles[i-2:i]\n                i += 2\n        elif rand() < pReal or i == states - 1:\n            # No-oscillation pole.\n            if type == \'c\':\n                poles[i] = -exp(randn()) + 0.j\n            elif type == \'d\':\n                poles[i] = 2. * rand() - 1.\n            i += 1\n        else:\n            # Complex conjugate pair of oscillating poles.\n            if type == \'c\':\n                poles[i] = complex(-exp(randn()), 3. * exp(randn()))\n            elif type == \'d\':\n                mag = rand()\n                phase = 2. * math.pi * rand()\n                poles[i] = complex(mag * cos(phase), mag * sin(phase))\n            poles[i+1] = complex(poles[i].real, -poles[i].imag)\n            i += 2\n\n    # Now put the poles in A as real blocks on the diagonal.\n    A = zeros((states, states))\n    i = 0\n    while i < states:\n        if poles[i].imag == 0:\n            A[i, i] = poles[i].real\n            i += 1\n        else:\n            A[i, i] = A[i+1, i+1] = poles[i].real\n            A[i, i+1] = poles[i].imag\n            A[i+1, i] = -poles[i].imag\n            i += 2\n    # Finally, apply a transformation so that A is not block-diagonal.\n    while True:\n        T = randn(states, states)\n        try:\n            A = dot(solve(T, A), T)  # A = T \\ A * T\n            break\n        except LinAlgError:\n            # In the unlikely event that T is rank-deficient, iterate again.\n            pass\n\n    # Make the remaining matrices.\n    B = randn(states, inputs)\n    C = randn(outputs, states)\n    D = randn(outputs, inputs)\n\n    # Make masks to zero out some of the elements.\n    while True:\n        Bmask = rand(states, inputs) < pBCmask\n        if any(Bmask):  # Retry if we get all zeros.\n            break\n    while True:\n        Cmask = rand(outputs, states) < pBCmask\n        if any(Cmask):  # Retry if we get all zeros.\n            break\n    if rand() < pDzero:\n        Dmask = zeros((outputs, inputs))\n    else:\n        Dmask = rand(outputs, inputs) < pDmask\n\n    # Apply masks.\n    B = B * Bmask\n    C = C * Cmask\n    D = D * Dmask\n\n    return StateSpace(A, B, C, D)\n\n\n# Convert a MIMO system to a SISO system\n# TODO: add discrete time check\ndef _mimo2siso(sys, input, output, warn_conversion=False):\n    #pylint: disable=W0622\n    """"""\n    Convert a MIMO system to a SISO system. (Convert a system with multiple\n    inputs and/or outputs, to a system with a single input and output.)\n\n    The input and output that are used in the SISO system can be selected\n    with the parameters ``input`` and ``output``. All other inputs are set\n    to 0, all other outputs are ignored.\n\n    If ``sys`` is already a SISO system, it will be returned unaltered.\n\n    Parameters\n    ----------\n    sys : StateSpace\n        Linear (MIMO) system that should be converted.\n    input : int\n        Index of the input that will become the SISO system\'s only input.\n    output : int\n        Index of the output that will become the SISO system\'s only output.\n    warn_conversion : bool, optional\n        If `True`, print a message when sys is a MIMO system,\n        warning that a conversion will take place.  Default is False.\n\n    Returns\n    sys : StateSpace\n        The converted (SISO) system.\n    """"""\n    if not (isinstance(input, int) and isinstance(output, int)):\n        raise TypeError(""Parameters ``input`` and ``output`` must both ""\n                        ""be integer numbers."")\n    if not (0 <= input < sys.inputs):\n        raise ValueError(""Selected input does not exist. ""\n                         ""Selected input: {sel}, ""\n                         ""number of system inputs: {ext}.""\n                         .format(sel=input, ext=sys.inputs))\n    if not (0 <= output < sys.outputs):\n        raise ValueError(""Selected output does not exist. ""\n                         ""Selected output: {sel}, ""\n                         ""number of system outputs: {ext}.""\n                         .format(sel=output, ext=sys.outputs))\n    #Convert sys to SISO if necessary\n    if sys.inputs > 1 or sys.outputs > 1:\n        if warn_conversion:\n            warn(""Converting MIMO system to SISO system. ""\n                 ""Only input {i} and output {o} are used.""\n                 .format(i=input, o=output))\n        # $X = A*X + B*U\n        #  Y = C*X + D*U\n        new_B = sys.B[:, input]\n        new_C = sys.C[output, :]\n        new_D = sys.D[output, input]\n        sys = StateSpace(sys.A, new_B, new_C, new_D, sys.dt)\n\n    return sys\n\n\ndef _mimo2simo(sys, input, warn_conversion=False):\n    # pylint: disable=W0622\n    """"""\n    Convert a MIMO system to a SIMO system. (Convert a system with multiple\n    inputs and/or outputs, to a system with a single input but possibly\n    multiple outputs.)\n\n    The input that is used in the SIMO system can be selected with the\n    parameter ``input``. All other inputs are set to 0, all other\n    outputs are ignored.\n\n    If ``sys`` is already a SIMO system, it will be returned unaltered.\n\n    Parameters\n    ----------\n    sys: StateSpace\n        Linear (MIMO) system that should be converted.\n    input: int\n        Index of the input that will become the SIMO system\'s only input.\n    warn_conversion: bool\n        If True: print a warning message when sys is a MIMO system.\n        Warn that a conversion will take place.\n\n    Returns\n    -------\n    sys: StateSpace\n        The converted (SIMO) system.\n    """"""\n    if not (isinstance(input, int)):\n        raise TypeError(""Parameter ``input`` be an integer number."")\n    if not (0 <= input < sys.inputs):\n        raise ValueError(""Selected input does not exist. ""\n                         ""Selected input: {sel}, ""\n                         ""number of system inputs: {ext}.""\n                         .format(sel=input, ext=sys.inputs))\n    # Convert sys to SISO if necessary\n    if sys.inputs > 1:\n        if warn_conversion:\n            warn(""Converting MIMO system to SIMO system. ""\n                 ""Only input {i} is used."" .format(i=input))\n        # $X = A*X + B*U\n        #  Y = C*X + D*U\n        new_B = sys.B[:, input]\n        new_D = sys.D[:, input]\n        sys = StateSpace(sys.A, new_B, sys.C, new_D, sys.dt)\n\n    return sys\n\n\ndef ss(*args):\n    """"""ss(A, B, C, D[, dt])\n\n    Create a state space system.\n\n    The function accepts either 1, 4 or 5 parameters:\n\n    ``ss(sys)``\n        Convert a linear system into space system form. Always creates a\n        new system, even if sys is already a StateSpace object.\n\n    ``ss(A, B, C, D)``\n        Create a state space system from the matrices of its state and\n        output equations:\n\n        .. math::\n            \\\\dot x = A \\\\cdot x + B \\\\cdot u\n\n            y = C \\\\cdot x + D \\\\cdot u\n\n    ``ss(A, B, C, D, dt)``\n        Create a discrete-time state space system from the matrices of\n        its state and output equations:\n\n        .. math::\n            x[k+1] = A \\\\cdot x[k] + B \\\\cdot u[k]\n\n            y[k] = C \\\\cdot x[k] + D \\\\cdot u[ki]\n\n        The matrices can be given as *array like* data types or strings.\n        Everything that the constructor of :class:`numpy.matrix` accepts is\n        permissible here too.\n\n    Parameters\n    ----------\n    sys: StateSpace or TransferFunction\n        A linear system\n    A: array_like or string\n        System matrix\n    B: array_like or string\n        Control matrix\n    C: array_like or string\n        Output matrix\n    D: array_like or string\n        Feed forward matrix\n    dt: If present, specifies the sampling period and a discrete time\n        system is created\n\n    Returns\n    -------\n    out: :class:`StateSpace`\n        The new linear system\n\n    Raises\n    ------\n    ValueError\n        if matrix sizes are not self-consistent\n\n    See Also\n    --------\n    StateSpace\n    tf\n    ss2tf\n    tf2ss\n\n    Examples\n    --------\n    >>> # Create a StateSpace object from four ""matrices"".\n    >>> sys1 = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n\n    >>> # Convert a TransferFunction to a StateSpace object.\n    >>> sys_tf = tf([2.], [1., 3])\n    >>> sys2 = ss(sys_tf)\n\n    """"""\n\n    if len(args) == 4 or len(args) == 5:\n        return StateSpace(*args)\n    elif len(args) == 1:\n        from .xferfcn import TransferFunction\n        sys = args[0]\n        if isinstance(sys, StateSpace):\n            return deepcopy(sys)\n        elif isinstance(sys, TransferFunction):\n            return tf2ss(sys)\n        else:\n            raise TypeError(""ss(sys): sys must be a StateSpace or \\\nTransferFunction object.  It is %s."" % type(sys))\n    else:\n        raise ValueError(""Needs 1 or 4 arguments; received %i."" % len(args))\n\n\ndef tf2ss(*args):\n    """"""tf2ss(sys)\n\n    Transform a transfer function to a state space system.\n\n    The function accepts either 1 or 2 parameters:\n\n    ``tf2ss(sys)``\n        Convert a linear system into transfer function form. Always creates\n        a new system, even if sys is already a TransferFunction object.\n\n    ``tf2ss(num, den)``\n        Create a transfer function system from its numerator and denominator\n        polynomial coefficients.\n\n        For details see: :func:`tf`\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace or TransferFunction)\n        A linear system\n    num: array_like, or list of list of array_like\n        Polynomial coefficients of the numerator\n    den: array_like, or list of list of array_like\n        Polynomial coefficients of the denominator\n\n    Returns\n    -------\n    out: StateSpace\n        New linear system in state space form\n\n    Raises\n    ------\n    ValueError\n        if `num` and `den` have invalid or unequal dimensions, or if an\n        invalid number of arguments is passed in\n    TypeError\n        if `num` or `den` are of incorrect type, or if sys is not a\n        TransferFunction object\n\n    See Also\n    --------\n    ss\n    tf\n    ss2tf\n\n    Examples\n    --------\n    >>> num = [[[1., 2.], [3., 4.]], [[5., 6.], [7., 8.]]]\n    >>> den = [[[9., 8., 7.], [6., 5., 4.]], [[3., 2., 1.], [-1., -2., -3.]]]\n    >>> sys1 = tf2ss(num, den)\n\n    >>> sys_tf = tf(num, den)\n    >>> sys2 = tf2ss(sys_tf)\n\n    """"""\n\n    from .xferfcn import TransferFunction\n    if len(args) == 2 or len(args) == 3:\n        # Assume we were given the num, den\n        return _convertToStateSpace(TransferFunction(*args))\n\n    elif len(args) == 1:\n        sys = args[0]\n        if not isinstance(sys, TransferFunction):\n            raise TypeError(""tf2ss(sys): sys must be a TransferFunction \\\nobject."")\n        return _convertToStateSpace(sys)\n    else:\n        raise ValueError(""Needs 1 or 2 arguments; received %i."" % len(args))\n\n\ndef rss(states=1, outputs=1, inputs=1):\n    """"""\n    Create a stable *continuous* random state space object.\n\n    Parameters\n    ----------\n    states : integer\n        Number of state variables\n    inputs : integer\n        Number of system inputs\n    outputs : integer\n        Number of system outputs\n\n    Returns\n    -------\n    sys : StateSpace\n        The randomly created linear system\n\n    Raises\n    ------\n    ValueError\n        if any input is not a positive integer\n\n    See Also\n    --------\n    drss\n\n    Notes\n    -----\n    If the number of states, inputs, or outputs is not specified, then the\n    missing numbers are assumed to be 1.  The poles of the returned system\n    will always have a negative real part.\n\n    """"""\n\n    return _rss_generate(states, inputs, outputs, \'c\')\n\n\ndef drss(states=1, outputs=1, inputs=1):\n    """"""\n    Create a stable *discrete* random state space object.\n\n    Parameters\n    ----------\n    states : integer\n        Number of state variables\n    inputs : integer\n        Number of system inputs\n    outputs : integer\n        Number of system outputs\n\n    Returns\n    -------\n    sys : StateSpace\n        The randomly created linear system\n\n    Raises\n    ------\n    ValueError\n        if any input is not a positive integer\n\n    See Also\n    --------\n    rss\n\n    Notes\n    -----\n    If the number of states, inputs, or outputs is not specified, then the\n    missing numbers are assumed to be 1.  The poles of the returned system\n    will always have a magnitude less than 1.\n\n    """"""\n\n    return _rss_generate(states, inputs, outputs, \'d\')\n\n\ndef ssdata(sys):\n    """"""\n    Return state space data objects for a system\n\n    Parameters\n    ----------\n    sys : LTI (StateSpace, or TransferFunction)\n        LTI system whose data will be returned\n\n    Returns\n    -------\n    (A, B, C, D): list of matrices\n        State space data for the system\n    """"""\n    ss = _convertToStateSpace(sys)\n    return ss.A, ss.B, ss.C, ss.D\n'"
External_Libraries/python_control_master/control/timeresp.py,37,"b'# timeresp.py - time-domain simulation routines\n#\n# This file contains a collection of functions that calculate time\n# responses for linear systems.\n\n""""""The :mod:`~control.timeresp` module contains a collection of\nfunctions that are used to compute time-domain simulations of LTI\nsystems.\n\nArguments to time-domain simulations include a time vector, an input\nvector (when needed), and an initial condition vector.  The most\ngeneral function for simulating LTI systems the\n:func:`forced_response` function, which has the form::\n\n    t, y = forced_response(sys, T, U, X0)\n\nwhere `T` is a vector of times at which the response should be\nevaluated, `U` is a vector of inputs (one for each time point) and\n`X0` is the initial condition for the system.\n\nSee :ref:`time-series-convention` for more information on how time\nseries data are represented.\n\n""""""\n\n""""""Copyright (c) 2011 by California Institute of Technology\nAll rights reserved.\n\nCopyright (c) 2011 by Eike Welk\nCopyright (c) 2010 by SciPy Developers\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nInitial Author: Eike Welk\nDate: 12 May 2011\n$Id$\n""""""\n\n# Libraries that we make use of\nimport scipy as sp              # SciPy library (used all over)\nimport numpy as np              # NumPy library\nfrom scipy.signal.ltisys import _default_response_times\nimport warnings\nfrom .lti import LTI     # base class of StateSpace, TransferFunction\nfrom .statesp import _convertToStateSpace, _mimo2simo, _mimo2siso\nfrom .lti import isdtime, isctime\n\n__all__ = [\'forced_response\', \'step_response\', \'step_info\', \'initial_response\',\n           \'impulse_response\']\n\n\n# Helper function for checking array-like parameters\ndef _check_convert_array(in_obj, legal_shapes, err_msg_start, squeeze=False,\n                         transpose=False):\n    """"""\n    Helper function for checking array-like parameters.\n\n    * Check type and shape of ``in_obj``.\n    * Convert ``in_obj`` to an array if necessary.\n    * Change shape of ``in_obj`` according to parameter ``squeeze``.\n    * If ``in_obj`` is a scalar (number) it is converted to an array with\n      a legal shape, that is filled with the scalar value.\n\n    The function raises an exception when it detects an error.\n\n    Parameters\n    ----------\n    in_obj: array like object\n        The array or matrix which is checked.\n\n    legal_shapes: list of tuple\n        A list of shapes that in_obj can legally have.\n        The special value ""any"" means that there can be any\n        number of elements in a certain dimension.\n\n        * ``(2, 3)`` describes an array with 2 rows and 3 columns\n        * ``(2, ""any"")`` describes an array with 2 rows and any number of\n          columns\n\n    err_msg_start: str\n        String that is prepended to the error messages, when this function\n        raises an exception. It should be used to identify the argument which\n        is currently checked.\n\n    squeeze: bool\n        If True, all dimensions with only one element are removed from the\n        array. If False the array\'s shape is unmodified.\n\n        For example:\n        ``array([[1,2,3]])`` is converted to ``array([1, 2, 3])``\n\n   transpose: bool\n        If True, assume that input arrays are transposed for the standard\n        format.  Used to convert MATLAB-style inputs to our format.\n\n    Returns:\n\n    out_array: array\n        The checked and converted contents of ``in_obj``.\n    """"""\n    # convert nearly everything to an array.\n    out_array = np.asarray(in_obj)\n    if (transpose):\n        out_array = np.transpose(out_array)\n\n    # Test element data type, elements must be numbers\n    legal_kinds = set((""i"", ""f"", ""c""))  # integer, float, complex\n    if out_array.dtype.kind not in legal_kinds:\n        err_msg = ""Wrong element data type: \'{d}\'. Array elements "" \\\n                  ""must be numbers."".format(d=str(out_array.dtype))\n        raise TypeError(err_msg_start + err_msg)\n\n    # If array is zero dimensional (in_obj is scalar):\n    # create array with legal shape filled with the original value.\n    if out_array.ndim == 0:\n        for s_legal in legal_shapes:\n            # search for shape that does not contain the special symbol any.\n            if ""any"" in s_legal:\n                continue\n            the_val = out_array[()]\n            out_array = np.empty(s_legal, \'d\')\n            out_array.fill(the_val)\n            break\n\n    # Test shape\n    def shape_matches(s_legal, s_actual):\n        """"""Test if two shape tuples match""""""\n        # Array must have required number of dimensions\n        if len(s_legal) != len(s_actual):\n            return False\n        # All dimensions must contain required number of elements. Joker: ""all""\n        for n_legal, n_actual in zip(s_legal, s_actual):\n            if n_legal == ""any"":\n                continue\n            if n_legal != n_actual:\n                return False\n        return True\n\n    # Iterate over legal shapes, and see if any matches out_array\'s shape.\n    for s_legal in legal_shapes:\n        if shape_matches(s_legal, out_array.shape):\n            break\n    else:\n        legal_shape_str = "" or "".join([str(s) for s in legal_shapes])\n        err_msg = ""Wrong shape (rows, columns): {a}. Expected: {e}."" \\\n                  .format(e=legal_shape_str, a=str(out_array.shape))\n        raise ValueError(err_msg_start + err_msg)\n\n    # Convert shape\n    if squeeze:\n        out_array = np.squeeze(out_array)\n        # We don\'t want zero dimensional arrays\n        if out_array.shape == tuple():\n            out_array = out_array.reshape((1,))\n\n    return out_array\n\n\n# Forced response of a linear system\ndef forced_response(sys, T=None, U=0., X0=0., transpose=False,\n                    interpolate=False, squeeze=True):\n    """"""Simulate the output of a linear system.\n\n    As a convenience for parameters `U`, `X0`:\n    Numbers (scalars) are converted to constant arrays with the correct shape.\n    The correct shape is inferred from arguments `sys` and `T`.\n\n    For information on the **shape** of parameters `U`, `T`, `X0` and\n    return values `T`, `yout`, `xout`, see :ref:`time-series-convention`.\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace, or TransferFunction)\n        LTI system to simulate\n\n    T: array-like, optional for discrete LTI `sys`\n        Time steps at which the input is defined; values must be evenly spaced.\n\n    U: array-like or number, optional\n        Input array giving input at each time `T` (default = 0).\n\n        If `U` is ``None`` or ``0``, a special algorithm is used. This special\n        algorithm is faster than the general algorithm, which is used\n        otherwise.\n\n    X0: array-like or number, optional\n        Initial condition (default = 0).\n\n    transpose: bool, optional (default=False)\n        If True, transpose all input and output arrays (for backward\n        compatibility with MATLAB and scipy.signal.lsim)\n\n    interpolate: bool, optional (default=False)\n        If True and system is a discrete time system, the input will\n        be interpolated between the given time steps and the output\n        will be given at system sampling rate.  Otherwise, only return\n        the output at the times given in `T`.  No effect on continuous\n        time simulations (default = False).\n\n    squeeze: bool, optional (default=True)\n        If True, remove single-dimensional entries from the shape of\n        the output.  For single output systems, this converts the\n        output response to a 1D array.\n\n    Returns\n    -------\n    T: array\n        Time values of the output.\n    yout: array\n        Response of the system.\n    xout: array\n        Time evolution of the state vector.\n\n    See Also\n    --------\n    step_response, initial_response, impulse_response\n\n    Examples\n    --------\n    >>> T, yout, xout = forced_response(sys, T, u, X0)\n\n    See :ref:`time-series-convention`.\n\n    """"""\n    if not isinstance(sys, LTI):\n        raise TypeError(\'Parameter ``sys``: must be a ``LTI`` object. \'\n                        \'(For example ``StateSpace`` or ``TransferFunction``)\')\n    sys = _convertToStateSpace(sys)\n    A, B, C, D = np.asarray(sys.A), np.asarray(sys.B), np.asarray(sys.C), \\\n        np.asarray(sys.D)\n#    d_type = A.dtype\n    n_states = A.shape[0]\n    n_inputs = B.shape[1]\n    n_outputs = C.shape[0]\n\n    # Convert inputs to numpy arrays for easier shape checking\n    if U is not None:\n        U = np.asarray(U)\n    if T is not None:\n        T = np.asarray(T)\n\n    # Set and/or check time vector in discrete time case\n    if isdtime(sys, strict=True):\n        if T is None:\n            if U is None:\n                raise ValueError(\'Parameters ``T`` and ``U`` can\\\'t both be\'\n                                 \'zero for discrete-time simulation\')\n            # Set T to equally spaced samples with same length as U\n            if U.ndim == 1:\n                n_steps = U.shape[0]\n            else:\n                n_steps = U.shape[1]\n            T = np.array(range(n_steps)) * (1 if sys.dt is True else sys.dt)\n        else:\n            # Make sure the input vector and time vector have same length\n            # TODO: allow interpolation of the input vector\n            if (U.ndim == 1 and U.shape[0] != T.shape[0]) or \\\n                    (U.ndim > 1 and U.shape[1] != T.shape[0]):\n                ValueError(\'Pamameter ``T`` must have same elements as\'\n                           \' the number of columns in input array ``U``\')\n\n    # Test if T has shape (n,) or (1, n);\n    # T must be array-like and values must be increasing.\n    # The length of T determines the length of the input vector.\n    if T is None:\n        raise ValueError(\'Parameter ``T``: must be array-like, and contain \'\n                         \'(strictly monotonic) increasing numbers.\')\n    T = _check_convert_array(T, [(\'any\',), (1, \'any\')],\n                             \'Parameter ``T``: \', squeeze=True,\n                             transpose=transpose)\n    dt = T[1] - T[0]\n    if not np.allclose(T[1:] - T[:-1], dt):\n        raise ValueError(""Parameter ``T``: time values must be ""\n                         ""equally spaced."")\n    n_steps = T.shape[0]            # number of simulation steps\n\n    # create X0 if not given, test if X0 has correct shape\n    X0 = _check_convert_array(X0, [(n_states,), (n_states, 1)],\n                              \'Parameter ``X0``: \', squeeze=True)\n\n    xout = np.zeros((n_states, n_steps))\n    xout[:, 0] = X0\n    yout = np.zeros((n_outputs, n_steps))\n\n    # Separate out the discrete and continuous time cases\n    if isctime(sys):\n        # Solve the differential equation, copied from scipy.signal.ltisys.\n        dot, squeeze, = np.dot, np.squeeze  # Faster and shorter code\n\n        # Faster algorithm if U is zero\n        if U is None or (isinstance(U, (int, float)) and U == 0):\n            # Solve using matrix exponential\n            expAdt = sp.linalg.expm(A * dt)\n            for i in range(1, n_steps):\n                xout[:, i] = dot(expAdt, xout[:, i-1])\n            yout = dot(C, xout)\n\n        # General algorithm that interpolates U in between output points\n        else:\n            # Test if U has correct shape and type\n            legal_shapes = [(n_steps,), (1, n_steps)] if n_inputs == 1 else \\\n                           [(n_inputs, n_steps)]\n            U = _check_convert_array(U, legal_shapes,\n                                     \'Parameter ``U``: \', squeeze=False,\n                                     transpose=transpose)\n            # convert 1D array to 2D array with only one row\n            if len(U.shape) == 1:\n                U = U.reshape(1, -1)  # pylint: disable=E1103\n\n            # Algorithm: to integrate from time 0 to time dt, with linear\n            # interpolation between inputs u(0) = u0 and u(dt) = u1, we solve\n            #   xdot = A x + B u,        x(0) = x0\n            #   udot = (u1 - u0) / dt,   u(0) = u0.\n            #\n            # Solution is\n            #   [ x(dt) ]       [ A*dt  B*dt  0 ] [  x0   ]\n            #   [ u(dt) ] = exp [  0     0    I ] [  u0   ]\n            #   [u1 - u0]       [  0     0    0 ] [u1 - u0]\n\n            M = np.block([[A * dt, B * dt, np.zeros((n_states, n_inputs))],\n                         [np.zeros((n_inputs, n_states + n_inputs)),\n                          np.identity(n_inputs)],\n                         [np.zeros((n_inputs, n_states + 2 * n_inputs))]])\n            expM = sp.linalg.expm(M)\n            Ad = expM[:n_states, :n_states]\n            Bd1 = expM[:n_states, n_states+n_inputs:]\n            Bd0 = expM[:n_states, n_states:n_states + n_inputs] - Bd1\n\n            for i in range(1, n_steps):\n                xout[:, i] = (dot(Ad, xout[:, i-1]) + dot(Bd0, U[:, i-1]) +\n                              dot(Bd1, U[:, i]))\n            yout = dot(C, xout) + dot(D, U)\n        tout = T\n\n    else:\n        # Discrete type system => use SciPy signal processing toolbox\n        if sys.dt is not True:\n            # Make sure that the time increment is a multiple of sampling time\n\n            # First make sure that time increment is bigger than sampling time\n            if dt < sys.dt:\n                raise ValueError(""Time steps ``T`` must match sampling time"")\n\n            # Now check to make sure it is a multiple (with check against\n            # sys.dt because floating point mod can have small errors\n            elif not (np.isclose(dt % sys.dt, 0) or\n                      np.isclose(dt % sys.dt, sys.dt)):\n                raise ValueError(""Time steps ``T`` must be multiples of ""\n                                 ""sampling time"")\n        else:\n            sys.dt = dt         # For unspecified sampling time, use time incr\n\n        # Discrete time simulation using signal processing toolbox\n        dsys = (A, B, C, D, sys.dt)\n\n        # Use signal processing toolbox for the discrete time simulation\n        # Transpose the input to match toolbox convention\n        tout, yout, xout = sp.signal.dlsim(dsys, np.transpose(U), T, X0)\n\n        if not interpolate:\n            # If dt is different from sys.dt, resample the output\n            inc = int(round(dt / sys.dt))\n            tout = T            # Return exact list of time steps\n            yout = yout[::inc, :]\n            xout = xout[::inc, :]\n\n        # Transpose the output and state vectors to match local convention\n        xout = sp.transpose(xout)\n        yout = sp.transpose(yout)\n\n    # Get rid of unneeded dimensions\n    if squeeze:\n        yout = np.squeeze(yout)\n        xout = np.squeeze(xout)\n\n    # See if we need to transpose the data back into MATLAB form\n    if transpose:\n        tout = np.transpose(tout)\n        yout = np.transpose(yout)\n        xout = np.transpose(xout)\n\n    return tout, yout, xout\n\n\ndef _get_ss_simo(sys, input=None, output=None):\n    """"""Return a SISO or SIMO state-space version of sys\n\n    If input is not specified, select first input and issue warning\n    """"""\n    sys_ss = _convertToStateSpace(sys)\n    if sys_ss.issiso():\n        return sys_ss\n    warn = False\n    if input is None:\n        # issue warning if input is not given\n        warn = True\n        input = 0\n    if output is None:\n        return _mimo2simo(sys_ss, input, warn_conversion=warn)\n    else:\n        return _mimo2siso(sys_ss, input, output, warn_conversion=warn)\n\n\ndef step_response(sys, T=None, X0=0., input=None, output=None,\n                  transpose=False, return_x=False, squeeze=True, number_of_samples=100):\n    # pylint: disable=W0622\n    """"""Step response of a linear system\n\n    If the system has multiple inputs or outputs (MIMO), one input has\n    to be selected for the simulation. Optionally, one output may be\n    selected. The parameters `input` and `output` do this. All other\n    inputs are set to 0, all other outputs are ignored.\n\n    For information on the **shape** of parameters `T`, `X0` and\n    return values `T`, `yout`, see :ref:`time-series-convention`.\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        Index of the input that will be used in this simulation.\n\n    output: int\n        Index of the output that will be used in this simulation. Set to None\n        to not trim outputs\n\n    transpose: bool\n        If True, transpose all input and output arrays (for backward\n        compatibility with MATLAB and scipy.signal.lsim)\n\n    return_x: bool\n        If True, return the state vector (default = False).\n\n    squeeze: bool, optional (default=True)\n        If True, remove single-dimensional entries from the shape of\n        the output.  For single output systems, this converts the\n        output response to a 1D array.\n\n    Returns\n    -------\n    T: array\n        Time values of the output\n\n    yout: array\n        Response of the system\n\n    xout: array\n        Individual response of each x variable\n\n    See Also\n    --------\n    forced_response, initial_response, impulse_response\n\n    Examples\n    --------\n    >>> T, yout = step_response(sys, T, X0)\n    """"""\n    sys = _get_ss_simo(sys, input, output)\n    if T is None:\n        if isctime(sys):\n            T = _default_response_times(sys.A, number_of_samples)\n        else:\n            # For discrete time, use integers\n            tvec = _default_response_times(sys.A, number_of_samples)\n            T = range(int(np.ceil(max(tvec))))\n\n    U = np.ones_like(T)\n\n    T, yout, xout = forced_response(sys, T, U, X0, transpose=transpose,\n                                    squeeze=squeeze)\n\n    if return_x:\n        return T, yout, xout\n\n    return T, yout\n\n\ndef step_info(sys, T=None, SettlingTimeThreshold=0.02,\n              RiseTimeLimits=(0.1, 0.9)):\n    \'\'\'\n    Step response characteristics (Rise time, Settling Time, Peak and others).\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    SettlingTimeThreshold: float value, optional\n        Defines the error to compute settling time (default = 0.02)\n\n    RiseTimeLimits: tuple (lower_threshold, upper_theshold)\n        Defines the lower and upper threshold for RiseTime computation\n\n    Returns\n    -------\n    S: a dictionary containing:\n        RiseTime: Time from 10% to 90% of the steady-state value.\n        SettlingTime: Time to enter inside a default error of 2%\n        SettlingMin: Minimum value after RiseTime\n        SettlingMax: Maximum value after RiseTime\n        Overshoot: Percentage of the Peak relative to steady value\n        Undershoot: Percentage of undershoot\n        Peak: Absolute peak value\n        PeakTime: time of the Peak\n        SteadyStateValue: Steady-state value\n\n\n    See Also\n    --------\n    step, lsim, initial, impulse\n\n    Examples\n    --------\n    >>> info = step_info(sys, T)\n    \'\'\'\n    sys = _get_ss_simo(sys)\n    if T is None:\n        if isctime(sys):\n            T = _default_response_times(sys.A, 1000)\n        else:\n            # For discrete time, use integers\n            tvec = _default_response_times(sys.A, 1000)\n            T = range(int(np.ceil(max(tvec))))\n\n    T, yout = step_response(sys, T)\n\n    # Steady state value\n    InfValue = yout[-1]\n\n    # RiseTime\n    tr_lower_index = (np.where(yout >= RiseTimeLimits[0] * InfValue)[0])[0]\n    tr_upper_index = (np.where(yout >= RiseTimeLimits[1] * InfValue)[0])[0]\n    RiseTime = T[tr_upper_index] - T[tr_lower_index]\n\n    # SettlingTime\n    sup_margin = (1. + SettlingTimeThreshold) * InfValue\n    inf_margin = (1. - SettlingTimeThreshold) * InfValue\n    # find Steady State looking for the first point out of specified limits\n    for i in reversed(range(T.size)):\n        if((yout[i] <= inf_margin) | (yout[i] >= sup_margin)):\n            SettlingTime = T[i + 1]\n            break\n\n    # Peak\n    PeakIndex = np.abs(yout).argmax()\n    PeakValue = yout[PeakIndex]\n    PeakTime = T[PeakIndex]\n    SettlingMax = (yout).max()\n    SettlingMin = (yout[tr_upper_index:]).min()\n    # I\'m really not very confident about UnderShoot:\n    UnderShoot = yout.min()\n    OverShoot = 100. * (yout.max() - InfValue) / (InfValue - yout[0])\n\n    # Return as a dictionary\n    S = {\n        \'RiseTime\': RiseTime,\n        \'SettlingTime\': SettlingTime,\n        \'SettlingMin\': SettlingMin,\n        \'SettlingMax\': SettlingMax,\n        \'Overshoot\': OverShoot,\n        \'Undershoot\': UnderShoot,\n        \'Peak\': PeakValue,\n        \'PeakTime\': PeakTime,\n        \'SteadyStateValue\': InfValue\n    }\n\n    return S\n\n\ndef initial_response(sys, T=None, X0=0., input=0, output=None,\n                     transpose=False, return_x=False, squeeze=True, number_of_samples=1000):\n    # pylint: disable=W0622\n    """"""Initial condition response of a linear system\n\n    If the system has multiple outputs (MIMO), optionally, one output\n    may be selected. If no selection is made for the output, all\n    outputs are given.\n\n    For information on the **shape** of parameters `T`, `X0` and\n    return values `T`, `yout`, see :ref:`time-series-convention`.\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like object or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        Ignored, has no meaning in initial condition calculation. Parameter\n        ensures compatibility with step_response and impulse_response\n\n    output: int\n        Index of the output that will be used in this simulation. Set to None\n        to not trim outputs\n\n    transpose: bool\n        If True, transpose all input and output arrays (for backward\n        compatibility with MATLAB and scipy.signal.lsim)\n\n    return_x: bool\n        If True, return the state vector (default = False).\n\n    squeeze: bool, optional (default=True)\n        If True, remove single-dimensional entries from the shape of\n        the output.  For single output systems, this converts the\n        output response to a 1D array.\n\n    Returns\n    -------\n    T: array\n        Time values of the output\n    yout: array\n        Response of the system\n    xout: array\n        Individual response of each x variable\n\n    See Also\n    --------\n    forced_response, impulse_response, step_response\n\n    Examples\n    --------\n    >>> T, yout = initial_response(sys, T, X0)\n    """"""\n    sys = _get_ss_simo(sys, input, output)\n\n    # Create time and input vectors; checking is done in forced_response(...)\n    # The initial vector X0 is created in forced_response(...) if necessary\n    if T is None:\n        if isctime(sys):\n            T = _default_response_times(sys.A, number_of_samples)\n        else:\n            # For discrete time, use integers\n            tvec = _default_response_times(sys.A, number_of_samples)\n            T = range(int(np.ceil(max(tvec))))\n    U = np.zeros_like(T)\n\n    T, yout, _xout = forced_response(sys, T, U, X0, transpose=transpose,\n                                     squeeze=squeeze)\n\n    if return_x:\n        return T, yout, _xout\n\n    return T, yout\n\n\ndef impulse_response(sys, T=None, X0=0., input=0, output=None,\n                     transpose=False, return_x=False, squeeze=True, number_of_samples=100):\n    # pylint: disable=W0622\n    """"""Impulse response of a linear system\n\n    If the system has multiple inputs or outputs (MIMO), one input has\n    to be selected for the simulation. Optionally, one output may be\n    selected. The parameters `input` and `output` do this. All other\n    inputs are set to 0, all other outputs are ignored.\n\n    For information on the **shape** of parameters `T`, `X0` and\n    return values `T`, `yout`, see :ref:`time-series-convention`.\n\n    Parameters\n    ----------\n    sys: StateSpace, TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like object or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        Index of the input that will be used in this simulation.\n\n    output: int\n        Index of the output that will be used in this simulation. Set to None\n        to not trim outputs\n\n    transpose: bool\n        If True, transpose all input and output arrays (for backward\n        compatibility with MATLAB and scipy.signal.lsim)\n\n    return_x: bool\n        If True, return the state vector (default = False).\n\n    squeeze: bool, optional (default=True)\n        If True, remove single-dimensional entries from the shape of\n        the output.  For single output systems, this converts the\n        output response to a 1D array.\n\n    Returns\n    -------\n    T: array\n        Time values of the output\n    yout: array\n        Response of the system\n    xout: array\n        Individual response of each x variable\n\n    See Also\n    --------\n    forced_response, initial_response, step_response\n\n    Examples\n    --------\n    >>> T, yout = impulse_response(sys, T, X0)\n    """"""\n    sys = _get_ss_simo(sys, input, output)\n\n    # System has direct feedthrough, can\'t simulate impulse response\n    # numerically\n    if np.any(sys.D != 0) and isctime(sys):\n        warnings.warn(""System has direct feedthrough: ``D != 0``. The ""\n                      ""infinite impulse at ``t=0`` does not appear in the ""\n                      ""output.\\n""\n                      ""Results may be meaningless!"")\n\n    # create X0 if not given, test if X0 has correct shape.\n    # Must be done here because it is used for computations here.\n    n_states = sys.A.shape[0]\n    X0 = _check_convert_array(X0, [(n_states,), (n_states, 1)],\n                              \'Parameter ``X0``: \\n\', squeeze=True)\n\n    # Compute T and U, no checks necessary, they will be checked in lsim\n    if T is None:\n        if isctime(sys):\n            T = _default_response_times(sys.A, number_of_samples)\n        else:\n            # For discrete time, use integers\n            tvec = _default_response_times(sys.A, number_of_samples)\n            T = range(int(np.ceil(max(tvec))))\n\n    U = np.zeros_like(T)\n\n    # Compute new X0 that contains the impulse\n    # We can\'t put the impulse into U because there is no numerical\n    # representation for it (infinitesimally short, infinitely high).\n    # See also: http://www.mathworks.com/support/tech-notes/1900/1901.html\n    if isctime(sys):\n        B = np.asarray(sys.B).squeeze()\n        new_X0 = B + X0\n    else:\n        new_X0 = X0\n        U[0] = 1.\n\n    T, yout, _xout = forced_response(sys, T, U, new_X0, transpose=transpose,\n                                     squeeze=squeeze)\n\n    if return_x:\n        return T, yout, _xout\n\n    return T, yout\n'"
External_Libraries/python_control_master/control/xferfcn.py,18,"b'""""""xferfcn.py\n\nTransfer function representation and functions.\n\nThis file contains the TransferFunction class and also functions\nthat operate on transfer functions.  This is the primary representation\nfor the python-control library.\n""""""\n\n# Python 3 compatibility (needs to go here)\nfrom __future__ import print_function\nfrom __future__ import division\n\n""""""Copyright (c) 2010 by California Institute of Technology\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 24 May 09\nRevised: Kevin K. Chen, Dec 10\n\n$Id$\n\n""""""\n\n# External function declarations\nimport numpy as np\nfrom numpy import angle, array, empty, finfo, ndarray, ones, \\\n    polyadd, polymul, polyval, roots, sqrt, zeros, squeeze, exp, pi, \\\n    where, delete, real, poly, nonzero\nimport scipy as sp\nfrom numpy.polynomial.polynomial import polyfromroots\nfrom scipy.signal import lti, tf2zpk, zpk2tf, cont2discrete\nfrom copy import deepcopy\nfrom warnings import warn\nfrom itertools import chain\nfrom .lti import LTI, timebaseEqual, timebase, isdtime\n\n__all__ = [\'TransferFunction\', \'tf\', \'ss2tf\', \'tfdata\']\n\n\nclass TransferFunction(LTI):\n\n    """"""TransferFunction(num, den[, dt])\n\n    A class for representing transfer functions\n\n    The TransferFunction class is used to represent systems in transfer\n    function form.\n\n    The main data members are \'num\' and \'den\', which are 2-D lists of arrays\n    containing MIMO numerator and denominator coefficients.  For example,\n\n    >>> num[2][5] = numpy.array([1., 4., 8.])\n\n    means that the numerator of the transfer function from the 6th input to the\n    3rd output is set to s^2 + 4s + 8.\n\n    Discrete-time transfer functions are implemented by using the \'dt\'\n    instance variable and setting it to something other than \'None\'.  If \'dt\'\n    has a non-zero value, then it must match whenever two transfer functions\n    are combined.  If \'dt\' is set to True, the system will be treated as a\n    discrete time system with unspecified sampling time.\n\n    The TransferFunction class defines two constants ``s`` and ``z`` that\n    represent the differentiation and delay operators in continuous and\n    discrete time.  These can be used to create variables that allow algebraic\n    creation of transfer functions.  For example,\n\n    >>> s = TransferFunction.s\n    >>> G  = (s + 1)/(s**2 + 2*s + 1)\n\n    """"""\n    def __init__(self, *args):\n        """"""TransferFunction(num, den[, dt])\n\n        Construct a transfer function.\n\n        The default constructor is TransferFunction(num, den), where num and\n        den are lists of lists of arrays containing polynomial coefficients.\n        To create a discrete time transfer funtion, use TransferFunction(num,\n        den, dt) where \'dt\' is the sampling time (or True for unspecified\n        sampling time).  To call the copy constructor, call\n        TransferFunction(sys), where sys is a TransferFunction object\n        (continuous or discrete).\n\n        """"""\n        args = deepcopy(args)\n        if len(args) == 2:\n            # The user provided a numerator and a denominator.\n            (num, den) = args\n            dt = None\n        elif len(args) == 3:\n            # Discrete time transfer function\n            (num, den, dt) = args\n        elif len(args) == 1:\n            # Use the copy constructor.\n            if not isinstance(args[0], TransferFunction):\n                raise TypeError(""The one-argument constructor can only take \\\n                        in a TransferFunction object.  Received %s.""\n                                % type(args[0]))\n            num = args[0].num\n            den = args[0].den\n            # TODO: not sure this can ever happen since dt is always present\n            try:\n                dt = args[0].dt\n            except NameError:   # pragma: no coverage\n                dt = None\n        else:\n            raise ValueError(""Needs 1, 2 or 3 arguments; received %i.""\n                             % len(args))\n\n        num = _clean_part(num)\n        den = _clean_part(den)\n\n        inputs = len(num[0])\n        outputs = len(num)\n\n        # Make sure numerator and denominator matrices have consistent sizes\n        if inputs != len(den[0]):\n            raise ValueError(\n                ""The numerator has %i input(s), but the denominator has ""\n                ""%i input(s)."" % (inputs, len(den[0])))\n        if outputs != len(den):\n            raise ValueError(\n                ""The numerator has %i output(s), but the denominator has ""\n                ""%i output(s)."" % (outputs, len(den)))\n\n        # Additional checks/updates on structure of the transfer function\n        for i in range(outputs):\n            # Make sure that each row has the same number of columns\n            if len(num[i]) != inputs:\n                raise ValueError(\n                    ""Row 0 of the numerator matrix has %i elements, but row ""\n                    ""%i has %i."" % (inputs, i, len(num[i])))\n            if len(den[i]) != inputs:\n                raise ValueError(\n                    ""Row 0 of the denominator matrix has %i elements, but row ""\n                    ""%i has %i."" % (inputs, i, len(den[i])))\n\n            # Check for zeros in numerator or denominator\n            # TODO: Right now these checks are only done during construction.\n            # It might be worthwhile to think of a way to perform checks if the\n            # user modifies the transfer function after construction.\n            for j in range(inputs):\n                # Check that we don\'t have any zero denominators.\n                zeroden = True\n                for k in den[i][j]:\n                    if k:\n                        zeroden = False\n                        break\n                if zeroden:\n                    raise ValueError(\n                        ""Input %i, output %i has a zero denominator.""\n                        % (j + 1, i + 1))\n\n                # If we have zero numerators, set the denominator to 1.\n                zeronum = True\n                for k in num[i][j]:\n                    if k:\n                        zeronum = False\n                        break\n                if zeronum:\n                    den[i][j] = ones(1)\n\n        LTI.__init__(self, inputs, outputs, dt)\n        self.num = num\n        self.den = den\n\n        self._truncatecoeff()\n\n    def __call__(self, s):\n        """"""Evaluate the system\'s transfer function for a complex variable\n\n        For a SISO transfer function, returns the value of the\n        transfer function.  For a MIMO transfer fuction, returns a\n        matrix of values evaluated at complex variable s.""""""\n\n        if self.issiso():\n            # return a scalar\n            return self.horner(s)[0][0]\n        else:\n            # return a matrix\n            return self.horner(s)\n\n    def _truncatecoeff(self):\n        """"""Remove extraneous zero coefficients from num and den.\n\n        Check every element of the numerator and denominator matrices, and\n        truncate leading zeros.  For instance, running self._truncatecoeff()\n        will reduce self.num = [[[0, 0, 1, 2]]] to [[[1, 2]]].\n\n        """"""\n\n        # Beware: this is a shallow copy.  This should be okay.\n        data = [self.num, self.den]\n        for p in range(len(data)):\n            for i in range(self.outputs):\n                for j in range(self.inputs):\n                    # Find the first nontrivial coefficient.\n                    nonzero = None\n                    for k in range(data[p][i][j].size):\n                        if data[p][i][j][k]:\n                            nonzero = k\n                            break\n\n                    if nonzero is None:\n                        # The array is all zeros.\n                        data[p][i][j] = zeros(1)\n                    else:\n                        # Truncate the trivial coefficients.\n                        data[p][i][j] = data[p][i][j][nonzero:]\n        [self.num, self.den] = data\n\n    def __str__(self, var=None):\n        """"""String representation of the transfer function.""""""\n\n        mimo = self.inputs > 1 or self.outputs > 1\n        if var is None:\n            # TODO: replace with standard calls to lti functions\n            var = \'s\' if self.dt is None or self.dt == 0 else \'z\'\n        outstr = """"\n\n        for i in range(self.inputs):\n            for j in range(self.outputs):\n                if mimo:\n                    outstr += ""\\nInput %i to output %i:"" % (i + 1, j + 1)\n\n                # Convert the numerator and denominator polynomials to strings.\n                numstr = _tf_polynomial_to_string(self.num[j][i], var=var)\n                denstr = _tf_polynomial_to_string(self.den[j][i], var=var)\n\n                # Figure out the length of the separating line\n                dashcount = max(len(numstr), len(denstr))\n                dashes = \'-\' * dashcount\n\n                # Center the numerator or denominator\n                if len(numstr) < dashcount:\n                    numstr = (\' \' * int(round((dashcount - len(numstr)) / 2)) +\n                              numstr)\n                if len(denstr) < dashcount:\n                    denstr = (\' \' * int(round((dashcount - len(denstr)) / 2)) +\n                              denstr)\n\n                outstr += ""\\n"" + numstr + ""\\n"" + dashes + ""\\n"" + denstr + ""\\n""\n\n        # See if this is a discrete time system with specific sampling time\n        if not (self.dt is None) and type(self.dt) != bool and self.dt > 0:\n            # TODO: replace with standard calls to lti functions\n            outstr += ""\\ndt = "" + self.dt.__str__() + ""\\n""\n\n        return outstr\n\n    # represent as string, makes display work for IPython\n    __repr__ = __str__\n\n    def _repr_latex_(self, var=None):\n        """"""LaTeX representation of transfer function, for Jupyter notebook""""""\n\n        mimo = self.inputs > 1 or self.outputs > 1\n\n        if var is None:\n            # ! TODO: replace with standard calls to lti functions\n            var = \'s\' if self.dt is None or self.dt == 0 else \'z\'\n\n        out = [\'$$\']\n\n        if mimo:\n            out.append(r""\\begin{bmatrix}"")\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                # Convert the numerator and denominator polynomials to strings.\n                numstr = _tf_polynomial_to_string(self.num[i][j], var=var)\n                denstr = _tf_polynomial_to_string(self.den[i][j], var=var)\n\n                out += [r""\\frac{"", numstr, ""}{"", denstr, ""}""]\n\n                if mimo and j < self.outputs - 1:\n                    out.append(""&"")\n\n            if mimo:\n                out.append(r""\\\\"")\n\n        if mimo:\n            out.append(r"" \\end{bmatrix}"")\n\n        # See if this is a discrete time system with specific sampling time\n        if not (self.dt is None) and type(self.dt) != bool and self.dt > 0:\n            out += [""\\quad dt = "", str(self.dt)]\n\n        out.append(""$$"")\n\n        return \'\'.join(out)\n\n    def __neg__(self):\n        """"""Negate a transfer function.""""""\n\n        num = deepcopy(self.num)\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                num[i][j] *= -1\n\n        return TransferFunction(num, self.den, self.dt)\n\n    def __add__(self, other):\n        """"""Add two LTI objects (parallel connection).""""""\n        from .statesp import StateSpace\n\n        # Convert the second argument to a transfer function.\n        if isinstance(other, StateSpace):\n            other = _convert_to_transfer_function(other)\n        elif not isinstance(other, TransferFunction):\n            other = _convert_to_transfer_function(other, inputs=self.inputs,\n                                                  outputs=self.outputs)\n\n        # Check that the input-output sizes are consistent.\n        if self.inputs != other.inputs:\n            raise ValueError(\n                ""The first summand has %i input(s), but the second has %i.""\n                % (self.inputs, other.inputs))\n        if self.outputs != other.outputs:\n            raise ValueError(\n                ""The first summand has %i output(s), but the second has %i.""\n                % (self.outputs, other.outputs))\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif (other.dt is None and self.dt is not None) or \\\n             (timebaseEqual(self, other)):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        # Preallocate the numerator and denominator of the sum.\n        num = [[[] for j in range(self.inputs)] for i in range(self.outputs)]\n        den = [[[] for j in range(self.inputs)] for i in range(self.outputs)]\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                num[i][j], den[i][j] = _add_siso(\n                    self.num[i][j], self.den[i][j],\n                    other.num[i][j], other.den[i][j])\n\n        return TransferFunction(num, den, dt)\n\n    def __radd__(self, other):\n        """"""Right add two LTI objects (parallel connection).""""""\n        return self + other\n\n    def __sub__(self, other):\n        """"""Subtract two LTI objects.""""""\n        return self + (-other)\n\n    def __rsub__(self, other):\n        """"""Right subtract two LTI objects.""""""\n        return other + (-self)\n\n    def __mul__(self, other):\n        """"""Multiply two LTI objects (serial connection).""""""\n        # Convert the second argument to a transfer function.\n        if isinstance(other, (int, float, complex, np.number)):\n            other = _convert_to_transfer_function(other, inputs=self.inputs,\n                                                  outputs=self.inputs)\n        else:\n            other = _convert_to_transfer_function(other)\n\n        # Check that the input-output sizes are consistent.\n        if self.inputs != other.outputs:\n            raise ValueError(\n                ""C = A * B: A has %i column(s) (input(s)), but B has %i ""\n                ""row(s)\\n(output(s))."" % (self.inputs, other.outputs))\n\n        inputs = other.inputs\n        outputs = self.outputs\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif (other.dt is None and self.dt is not None) or \\\n             (self.dt == other.dt):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        # Preallocate the numerator and denominator of the sum.\n        num = [[[0] for j in range(inputs)] for i in range(outputs)]\n        den = [[[1] for j in range(inputs)] for i in range(outputs)]\n\n        # Temporary storage for the summands needed to find the (i, j)th\n        # element of the product.\n        num_summand = [[] for k in range(self.inputs)]\n        den_summand = [[] for k in range(self.inputs)]\n\n        # Multiply & add.\n        for row in range(outputs):\n            for col in range(inputs):\n                for k in range(self.inputs):\n                    num_summand[k] = polymul(\n                        self.num[row][k], other.num[k][col])\n                    den_summand[k] = polymul(\n                        self.den[row][k], other.den[k][col])\n                    num[row][col], den[row][col] = _add_siso(\n                        num[row][col], den[row][col],\n                        num_summand[k], den_summand[k])\n\n        return TransferFunction(num, den, dt)\n\n    def __rmul__(self, other):\n        """"""Right multiply two LTI objects (serial connection).""""""\n\n        # Convert the second argument to a transfer function.\n        if isinstance(other, (int, float, complex, np.number)):\n            other = _convert_to_transfer_function(other, inputs=self.inputs,\n                                                  outputs=self.inputs)\n        else:\n            other = _convert_to_transfer_function(other)\n\n        # Check that the input-output sizes are consistent.\n        if other.inputs != self.outputs:\n            raise ValueError(\n                ""C = A * B: A has %i column(s) (input(s)), but B has %i ""\n                ""row(s)\\n(output(s))."" % (other.inputs, self.outputs))\n\n        inputs = self.inputs\n        outputs = other.outputs\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif (other.dt is None and self.dt is not None) \\\n                or (self.dt == other.dt):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        # Preallocate the numerator and denominator of the sum.\n        num = [[[0] for j in range(inputs)] for i in range(outputs)]\n        den = [[[1] for j in range(inputs)] for i in range(outputs)]\n\n        # Temporary storage for the summands needed to find the\n        # (i, j)th element\n        # of the product.\n        num_summand = [[] for k in range(other.inputs)]\n        den_summand = [[] for k in range(other.inputs)]\n\n        for i in range(outputs):  # Iterate through rows of product.\n            for j in range(inputs):  # Iterate through columns of product.\n                for k in range(other.inputs):  # Multiply & add.\n                    num_summand[k] = polymul(other.num[i][k], self.num[k][j])\n                    den_summand[k] = polymul(other.den[i][k], self.den[k][j])\n                    num[i][j], den[i][j] = _add_siso(\n                        num[i][j], den[i][j],\n                        num_summand[k], den_summand[k])\n\n        return TransferFunction(num, den, dt)\n\n    # TODO: Division of MIMO transfer function objects is not written yet.\n    def __truediv__(self, other):\n        """"""Divide two LTI objects.""""""\n\n        if isinstance(other, (int, float, complex, np.number)):\n            other = _convert_to_transfer_function(\n                other, inputs=self.inputs,\n                outputs=self.inputs)\n        else:\n            other = _convert_to_transfer_function(other)\n\n        if (self.inputs > 1 or self.outputs > 1 or\n                other.inputs > 1 or other.outputs > 1):\n            raise NotImplementedError(\n                ""TransferFunction.__truediv__ is currently \\\n                implemented only for SISO systems."")\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif (other.dt is None and self.dt is not None) or \\\n             (self.dt == other.dt):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        num = polymul(self.num[0][0], other.den[0][0])\n        den = polymul(self.den[0][0], other.num[0][0])\n\n        return TransferFunction(num, den, dt)\n\n    # TODO: Remove when transition to python3 complete\n    def __div__(self, other):\n        return TransferFunction.__truediv__(self, other)\n\n    # TODO: Division of MIMO transfer function objects is not written yet.\n    def __rtruediv__(self, other):\n        """"""Right divide two LTI objects.""""""\n        if isinstance(other, (int, float, complex, np.number)):\n            other = _convert_to_transfer_function(\n                other, inputs=self.inputs,\n                outputs=self.inputs)\n        else:\n            other = _convert_to_transfer_function(other)\n\n        if (self.inputs > 1 or self.outputs > 1 or\n                other.inputs > 1 or other.outputs > 1):\n            raise NotImplementedError(\n                ""TransferFunction.__rtruediv__ is currently implemented only ""\n                ""for SISO systems."")\n\n        return other / self\n\n    # TODO: Remove when transition to python3 complete\n    def __rdiv__(self, other):\n        return TransferFunction.__rtruediv__(self, other)\n\n    def __pow__(self, other):\n        if not type(other) == int:\n            raise ValueError(""Exponent must be an integer"")\n        if other == 0:\n            return TransferFunction([1], [1])  # unity\n        if other > 0:\n            return self * (self**(other - 1))\n        if other < 0:\n            return (TransferFunction([1], [1]) / self) * (self**(other + 1))\n\n    def __getitem__(self, key):\n        key1, key2 = key\n\n        # pre-process\n        if isinstance(key1, int):\n            key1 = slice(key1, key1 + 1, 1)\n        if isinstance(key2, int):\n            key2 = slice(key2, key2 + 1, 1)\n        # dim1\n        start1, stop1, step1 = key1.start, key1.stop, key1.step\n        if step1 is None:\n            step1 = 1\n        if start1 is None:\n            start1 = 0\n        if stop1 is None:\n            stop1 = len(self.num)\n        # dim1\n        start2, stop2, step2 = key2.start, key2.stop, key2.step\n        if step2 is None:\n            step2 = 1\n        if start2 is None:\n            start2 = 0\n        if stop2 is None:\n            stop2 = len(self.num[0])\n\n        num = []\n        den = []\n        for i in range(start1, stop1, step1):\n            num_i = []\n            den_i = []\n            for j in range(start2, stop2, step2):\n                num_i.append(self.num[i][j])\n                den_i.append(self.den[i][j])\n            num.append(num_i)\n            den.append(den_i)\n        if self.isctime():\n            return TransferFunction(num, den)\n        else:\n            return TransferFunction(num, den, self.dt)\n\n    def evalfr(self, omega):\n        """"""Evaluate a transfer function at a single angular frequency.\n\n        self._evalfr(omega) returns the value of the transfer function\n        matrix with input value s = i * omega.\n\n        """"""\n        warn(""TransferFunction.evalfr(omega) will be deprecated in a ""\n             ""future release of python-control; use evalfr(sys, omega*1j) ""\n             ""instead"", PendingDeprecationWarning)\n        return self._evalfr(omega)\n\n    def _evalfr(self, omega):\n        """"""Evaluate a transfer function at a single angular frequency.""""""\n        # TODO: implement for discrete time systems\n        if isdtime(self, strict=True):\n            # Convert the frequency to discrete time\n            dt = timebase(self)\n            s = exp(1.j * omega * dt)\n            if np.any(omega * dt > pi):\n                warn(""_evalfr: frequency evaluation above Nyquist frequency"")\n        else:\n            s = 1.j * omega\n\n        return self.horner(s)\n\n    def horner(self, s):\n        """"""Evaluate the systems\'s transfer function for a complex variable\n\n        Returns a matrix of values evaluated at complex variable s.\n        """"""\n\n        # Preallocate the output.\n        if getattr(s, \'__iter__\', False):\n            out = empty((self.outputs, self.inputs, len(s)), dtype=complex)\n        else:\n            out = empty((self.outputs, self.inputs), dtype=complex)\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                out[i][j] = (polyval(self.num[i][j], s) /\n                             polyval(self.den[i][j], s))\n\n        return out\n\n    # Method for generating the frequency response of the system\n    def freqresp(self, omega):\n        """"""Evaluate a transfer function at a list of angular frequencies.\n\n        mag, phase, omega = self.freqresp(omega)\n\n        reports the value of the magnitude, phase, and angular frequency of\n        the transfer function matrix evaluated at s = i * omega, where omega\n        is a list of angular frequencies, and is a sorted version of the input\n        omega.\n\n        """"""\n\n        # Preallocate outputs.\n        numfreq = len(omega)\n        mag = empty((self.outputs, self.inputs, numfreq))\n        phase = empty((self.outputs, self.inputs, numfreq))\n\n        # Figure out the frequencies\n        omega.sort()\n        if isdtime(self, strict=True):\n            dt = timebase(self)\n            slist = np.array([exp(1.j * w * dt) for w in omega])\n            if max(omega) * dt > pi:\n                warn(""freqresp: frequency evaluation above Nyquist frequency"")\n        else:\n            slist = np.array([1j * w for w in omega])\n\n        # Compute frequency response for each input/output pair\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                fresp = (polyval(self.num[i][j], slist) /\n                         polyval(self.den[i][j], slist))\n                mag[i, j, :] = abs(fresp)\n                phase[i, j, :] = angle(fresp)\n\n        return mag, phase, omega\n\n    def pole(self):\n        """"""Compute the poles of a transfer function.""""""\n        num, den, denorder = self._common_den()\n        rts = []\n        for d, o in zip(den, denorder):\n            rts.extend(roots(d[:o + 1]))\n        return np.array(rts)\n\n    def zero(self):\n        """"""Compute the zeros of a transfer function.""""""\n        if self.inputs > 1 or self.outputs > 1:\n            raise NotImplementedError(\n                ""TransferFunction.zero is currently only implemented ""\n                ""for SISO systems."")\n        else:\n            # for now, just give zeros of a SISO tf\n            return roots(self.num[0][0])\n\n    def feedback(self, other=1, sign=-1):\n        """"""Feedback interconnection between two LTI objects.""""""\n        other = _convert_to_transfer_function(other)\n\n        if (self.inputs > 1 or self.outputs > 1 or\n                other.inputs > 1 or other.outputs > 1):\n            # TODO: MIMO feedback\n            raise NotImplementedError(\n                ""TransferFunction.feedback is currently only implemented ""\n                ""for SISO functions."")\n\n        # Figure out the sampling time to use\n        if self.dt is None and other.dt is not None:\n            dt = other.dt       # use dt from second argument\n        elif (other.dt is None and self.dt is not None) or \\\n             (self.dt == other.dt):\n            dt = self.dt        # use dt from first argument\n        else:\n            raise ValueError(""Systems have different sampling times"")\n\n        num1 = self.num[0][0]\n        den1 = self.den[0][0]\n        num2 = other.num[0][0]\n        den2 = other.den[0][0]\n\n        num = polymul(num1, den2)\n        den = polyadd(polymul(den2, den1), -sign * polymul(num2, num1))\n\n        return TransferFunction(num, den, dt)\n\n        # For MIMO or SISO systems, the analytic expression is\n        #     self / (1 - sign * other * self)\n        # But this does not work correctly because the state size will be too\n        # large.\n\n    def minreal(self, tol=None):\n        """"""Remove cancelling pole/zero pairs from a transfer function""""""\n        # based on octave minreal\n\n        # default accuracy\n        from sys import float_info\n        sqrt_eps = sqrt(float_info.epsilon)\n\n        # pre-allocate arrays\n        num = [[[] for j in range(self.inputs)] for i in range(self.outputs)]\n        den = [[[] for j in range(self.inputs)] for i in range(self.outputs)]\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n\n                # split up in zeros, poles and gain\n                newzeros = []\n                zeros = roots(self.num[i][j])\n                poles = roots(self.den[i][j])\n                gain = self.num[i][j][0] / self.den[i][j][0]\n\n                # check all zeros\n                for z in zeros:\n                    t = tol or \\\n                        1000 * max(float_info.epsilon, abs(z) * sqrt_eps)\n                    idx = where(abs(z - poles) < t)[0]\n                    if len(idx):\n                        # cancel this zero against one of the poles\n                        poles = delete(poles, idx[0])\n                    else:\n                        # keep this zero\n                        newzeros.append(z)\n\n                # poly([]) returns a scalar, but we always want a 1d array\n                num[i][j] = np.atleast_1d(gain * real(poly(newzeros)))\n                den[i][j] = np.atleast_1d(real(poly(poles)))\n\n        # end result\n        return TransferFunction(num, den, self.dt)\n\n    def returnScipySignalLTI(self):\n        """"""Return a list of a list of scipy.signal.lti objects.\n\n        For instance,\n\n        >>> out = tfobject.returnScipySignalLTI()\n        >>> out[3][5]\n\n        is a signal.scipy.lti object corresponding to the\n        transfer function from the 6th input to the 4th output.\n\n        """"""\n\n        # TODO: implement for discrete time systems\n        if self.dt != 0 and self.dt is not None:\n            raise NotImplementedError(""Function not \\\n                    implemented in discrete time"")\n\n        # Preallocate the output.\n        out = [[[] for j in range(self.inputs)] for i in range(self.outputs)]\n\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                out[i][j] = lti(self.num[i][j], self.den[i][j])\n\n        return out\n\n    def _common_den(self, imag_tol=None):\n        """"""\n        Compute MIMO common denominators; return them and adjusted numerators.\n\n        This function computes the denominators per input containing all\n        the poles of sys.den, and reports it as the array den.  The\n        output numerator array num is modified to use the common\n        denominator for this input/column; the coefficient arrays are also\n        padded with zeros to be the same size for all num/den.\n        num is an sys.outputs by sys.inputs\n        by len(d) array.\n\n        Parameters\n        ----------\n        imag_tol: float\n            Threshold for the imaginary part of a root to use in detecting\n            complex poles\n\n        Returns\n        -------\n        num: array\n            Multi-dimensional array of numerator coefficients. num[i][j]\n            gives the numerator coefficient array for the ith input and jth\n            output, also prepared for use in td04ad; matches the denorder\n            order; highest coefficient starts on the left.\n\n        den: array\n            Multi-dimensional array of coefficients for common denominator\n            polynomial, one row per input. The array is prepared for use in\n            slycot td04ad, the first element is the highest-order polynomial\n            coefficiend of s, matching the order in denorder, if denorder <\n            number of columns in den, the den is padded with zeros\n\n        denorder: array of int, orders of den, one per input\n\n\n\n        Examples\n        --------\n        >>> num, den, denorder = sys._common_den()\n\n        """"""\n\n        # Machine precision for floats.\n        eps = finfo(float).eps\n\n        # Decide on the tolerance to use in deciding of a pole is complex\n        if (imag_tol is None):\n            imag_tol = 1e-8     # TODO: figure out the right number to use\n\n        # A list to keep track of cumulative poles found as we scan\n        # self.den[..][..]\n        poles = [[] for j in range(self.inputs)]\n\n        # RvP, new implementation 180526, issue #194\n\n        # pre-calculate the poles for all num, den\n        # has zeros, poles, gain, list for pole indices not in den,\n        # number of poles known at the time analyzed\n\n        # do not calculate minreal. Rory\'s hint .minreal()\n        poleset = []\n        for i in range(self.outputs):\n            poleset.append([])\n            for j in range(self.inputs):\n                if abs(self.num[i][j]).max() <= eps:\n                    poleset[-1].append([array([], dtype=float),\n                                        roots(self.den[i][j]), 0.0, [], 0])\n                else:\n                    z, p, k = tf2zpk(self.num[i][j], self.den[i][j])\n                    poleset[-1].append([z, p, k, [], 0])\n\n        # collect all individual poles\n        epsnm = eps * self.inputs * self.outputs\n        for j in range(self.inputs):\n            for i in range(self.outputs):\n                currentpoles = poleset[i][j][1]\n                nothave = ones(currentpoles.shape, dtype=bool)\n                for ip, p in enumerate(poles[j]):\n                    idx, = nonzero(\n                        (abs(currentpoles - p) < epsnm) * nothave)\n                    if len(idx):\n                        nothave[idx[0]] = False\n                    else:\n                        # remember id of pole not in tf\n                        poleset[i][j][3].append(ip)\n                for h, c in zip(nothave, currentpoles):\n                    if h:\n                        poles[j].append(c)\n                # remember how many poles now known\n                poleset[i][j][4] = len(poles[j])\n\n        # figure out maximum number of poles, for sizing the den\n        npmax = max([len(p) for p in poles])\n        den = zeros((self.inputs, npmax + 1), dtype=float)\n        num = zeros((max(1, self.outputs, self.inputs),\n                     max(1, self.outputs, self.inputs), npmax + 1),\n                    dtype=float)\n        denorder = zeros((self.inputs,), dtype=int)\n\n        for j in range(self.inputs):\n            if not len(poles[j]):\n                # no poles matching this input; only one or more gains\n                den[j, 0] = 1.0\n                for i in range(self.outputs):\n                    num[i, j, 0] = poleset[i][j][2]\n            else:\n                # create the denominator matching this input polyfromroots\n                # gives coeffs in opposite order from what we use coefficients\n                # should be padded on right, ending at np\n                np = len(poles[j])\n                den[j, np::-1] = polyfromroots(poles[j]).real\n                denorder[j] = np\n\n                # now create the numerator, also padded on the right\n                for i in range(self.outputs):\n                    # start with the current set of zeros for this output\n                    nwzeros = list(poleset[i][j][0])\n                    # add all poles not found in the original denominator,\n                    # and the ones later added from other denominators\n                    for ip in chain(poleset[i][j][3],\n                                    range(poleset[i][j][4], np)):\n                        nwzeros.append(poles[j][ip])\n\n                    numpoly = poleset[i][j][2] * polyfromroots(nwzeros).real\n                    # print(numpoly, den[j])\n                    # polyfromroots gives coeffs in opposite order => invert\n                    # numerator polynomial should be padded on left and right\n                    #   ending at np to line up with what td04ad expects...\n                    num[i, j, np + 1 - len(numpoly):np + 1] = numpoly[::-1]\n                    # print(num[i, j])\n\n        if (abs(den.imag) > epsnm).any():\n            print(""Warning: The denominator has a nontrivial imaginary part: ""\n                  "" %f"" % abs(den.imag).max())\n        den = den.real\n\n        return num, den, denorder\n\n    def sample(self, Ts, method=\'zoh\', alpha=None):\n        """"""Convert a continuous-time system to discrete time\n\n        Creates a discrete-time system from a continuous-time system by\n        sampling.  Multiple methods of conversion are supported.\n\n        Parameters\n        ----------\n        Ts : float\n            Sampling period\n        method : {""gbt"", ""bilinear"", ""euler"", ""backward_diff"",\n                  ""zoh"", ""matched""}\n            Method to use for sampling:\n\n            * gbt: generalized bilinear transformation\n            * bilinear: Tustin\'s approximation (""gbt"" with alpha=0.5)\n            * euler: Euler (or forward difference) method (""gbt"" with alpha=0)\n            * backward_diff: Backwards difference (""gbt"" with alpha=1.0)\n            * zoh: zero-order hold (default)\n\n        alpha : float within [0, 1]\n            The generalized bilinear transformation weighting parameter, which\n            should only be specified with method=""gbt"", and is ignored\n            otherwise.\n\n        Returns\n        -------\n        sysd : StateSpace system\n            Discrete time system, with sampling rate Ts\n\n        Notes\n        -----\n        1. Available only for SISO systems\n\n        2. Uses the command `cont2discrete` from `scipy.signal`\n\n        Examples\n        --------\n        >>> sys = TransferFunction(1, [1,1])\n        >>> sysd = sys.sample(0.5, method=\'bilinear\')\n\n        """"""\n        if not self.isctime():\n            raise ValueError(""System must be continuous time system"")\n        if not self.issiso():\n            raise NotImplementedError(""MIMO implementation not available"")\n        if method == ""matched"":\n            return _c2d_matched(self, Ts)\n        sys = (self.num[0][0], self.den[0][0])\n        numd, dend, dt = cont2discrete(sys, Ts, method, alpha)\n        return TransferFunction(numd[0, :], dend, dt)\n\n    def dcgain(self):\n        """"""Return the zero-frequency (or DC) gain\n\n        For a continous-time transfer function G(s), the DC gain is G(0)\n        For a discrete-time transfer function G(z), the DC gain is G(1)\n\n        Returns\n        -------\n        gain : ndarray\n            The zero-frequency gain\n        """"""\n        if self.isctime():\n            return self._dcgain_cont()\n        else:\n            return self(1)\n\n    def _dcgain_cont(self):\n        """"""_dcgain_cont() -> DC gain as matrix or scalar\n\n        Special cased evaluation at 0 for continuous-time systems.""""""\n        gain = np.empty((self.outputs, self.inputs), dtype=float)\n        for i in range(self.outputs):\n            for j in range(self.inputs):\n                num = self.num[i][j][-1]\n                den = self.den[i][j][-1]\n                if den:\n                    gain[i][j] = num / den\n                else:\n                    if num:\n                        # numerator nonzero: infinite gain\n                        gain[i][j] = np.inf\n                    else:\n                        # numerator is zero too: give up\n                        gain[i][j] = np.nan\n        return np.squeeze(gain)\n\n\n# c2d function contributed by Benjamin White, Oct 2012\ndef _c2d_matched(sysC, Ts):\n    # Pole-zero match method of continuous to discrete time conversion\n    szeros, spoles, sgain = tf2zpk(sysC.num[0][0], sysC.den[0][0])\n    zzeros = [0] * len(szeros)\n    zpoles = [0] * len(spoles)\n    pregainnum = [0] * len(szeros)\n    pregainden = [0] * len(spoles)\n    for idx, s in enumerate(szeros):\n        sTs = s * Ts\n        z = exp(sTs)\n        zzeros[idx] = z\n        pregainnum[idx] = 1 - z\n    for idx, s in enumerate(spoles):\n        sTs = s * Ts\n        z = exp(sTs)\n        zpoles[idx] = z\n        pregainden[idx] = 1 - z\n    zgain = np.multiply.reduce(pregainnum) / np.multiply.reduce(pregainden)\n    gain = sgain / zgain\n    sysDnum, sysDden = zpk2tf(zzeros, zpoles, gain)\n    return TransferFunction(sysDnum, sysDden, Ts)\n\n# Utility function to convert a transfer function polynomial to a string\n# Borrowed from poly1d library\n\n\ndef _tf_polynomial_to_string(coeffs, var=\'s\'):\n    """"""Convert a transfer function polynomial to a string""""""\n\n    thestr = ""0""\n\n    # Compute the number of coefficients\n    N = len(coeffs) - 1\n\n    for k in range(len(coeffs)):\n        coefstr = \'%.4g\' % abs(coeffs[k])\n        if coefstr[-4:] == \'0000\':\n            coefstr = coefstr[:-5]\n        power = (N - k)\n        if power == 0:\n            if coefstr != \'0\':\n                newstr = \'%s\' % (coefstr,)\n            else:\n                if k == 0:\n                    newstr = \'0\'\n                else:\n                    newstr = \'\'\n        elif power == 1:\n            if coefstr == \'0\':\n                newstr = \'\'\n            elif coefstr == \'1\':\n                newstr = var\n            else:\n                newstr = \'%s %s\' % (coefstr, var)\n        else:\n            if coefstr == \'0\':\n                newstr = \'\'\n            elif coefstr == \'1\':\n                newstr = \'%s^%d\' % (var, power,)\n            else:\n                newstr = \'%s %s^%d\' % (coefstr, var, power)\n\n        if k > 0:\n            if newstr != \'\':\n                if coeffs[k] < 0:\n                    thestr = ""%s - %s"" % (thestr, newstr)\n                else:\n                    thestr = ""%s + %s"" % (thestr, newstr)\n        elif (k == 0) and (newstr != \'\') and (coeffs[k] < 0):\n            thestr = ""-%s"" % (newstr,)\n        else:\n            thestr = newstr\n    return thestr\n\n\ndef _add_siso(num1, den1, num2, den2):\n    """"""Return num/den = num1/den1 + num2/den2.\n\n    Each numerator and denominator is a list of polynomial coefficients.\n\n    """"""\n\n    num = polyadd(polymul(num1, den2), polymul(num2, den1))\n    den = polymul(den1, den2)\n\n    return num, den\n\n\ndef _convert_to_transfer_function(sys, **kw):\n    """"""Convert a system to transfer function form (if needed).\n\n    If sys is already a transfer function, then it is returned.  If sys is a\n    state space object, then it is converted to a transfer function and\n    returned.  If sys is a scalar, then the number of inputs and outputs can be\n    specified manually, as in:\n\n    >>> sys = _convert_to_transfer_function(3.) # Assumes inputs = outputs = 1\n    >>> sys = _convert_to_transfer_function(1., inputs=3, outputs=2)\n\n    In the latter example, sys\'s matrix transfer function is [[1., 1., 1.]\n                                                              [1., 1., 1.]].\n\n    If sys is an array-like type, then it is converted to a constant-gain\n    transfer function.\n\n    >>> sys = _convert_to_transfer_function([[1., 0.], [2., 3.]])\n\n    In this example, the numerator matrix will be\n       [[[1.0], [0.0]], [[2.0], [3.0]]]\n    and the denominator matrix [[[1.0], [1.0]], [[1.0], [1.0]]]\n\n    """"""\n    from .statesp import StateSpace\n\n    if isinstance(sys, TransferFunction):\n        if len(kw):\n            raise TypeError(""If sys is a TransferFunction, "" +\n                            ""_convertToTransferFunction cannot take keywords."")\n\n        return sys\n    elif isinstance(sys, StateSpace):\n\n        if 0 == sys.states:\n            # Slycot doesn\'t like static SS->TF conversion, so handle\n            # it first.  Can\'t join this with the no-Slycot branch,\n            # since that doesn\'t handle general MIMO systems\n            num = [[[sys.D[i, j]] for j in range(sys.inputs)]\n                   for i in range(sys.outputs)]\n            den = [[[1.] for j in range(sys.inputs)]\n                   for i in range(sys.outputs)]\n        else:\n            try:\n                from slycot import tb04ad\n                if len(kw):\n                    raise TypeError(\n                        ""If sys is a StateSpace, "" +\n                        ""_convertToTransferFunction cannot take keywords."")\n\n                # Use Slycot to make the transformation\n                # Make sure to convert system matrices to numpy arrays\n                tfout = tb04ad(\n                    sys.states, sys.inputs, sys.outputs, array(sys.A),\n                    array(sys.B), array(sys.C), array(sys.D), tol1=0.0)\n\n                # Preallocate outputs.\n                num = [[[] for j in range(sys.inputs)]\n                       for i in range(sys.outputs)]\n                den = [[[] for j in range(sys.inputs)]\n                       for i in range(sys.outputs)]\n\n                for i in range(sys.outputs):\n                    for j in range(sys.inputs):\n                        num[i][j] = list(tfout[6][i, j, :])\n                        # Each transfer function matrix row\n                        # has a common denominator.\n                        den[i][j] = list(tfout[5][i, :])\n\n            except ImportError:\n                # If slycot is not available, use signal.lti (SISO only)\n                if sys.inputs != 1 or sys.outputs != 1:\n                    raise TypeError(""No support for MIMO without slycot."")\n\n                # Do the conversion using sp.signal.ss2tf\n                # Note that this returns a 2D array for the numerator\n                num, den = sp.signal.ss2tf(sys.A, sys.B, sys.C, sys.D)\n                num = squeeze(num)  # Convert to 1D array\n                den = squeeze(den)  # Probably not needed\n\n        return TransferFunction(num, den, sys.dt)\n\n    elif isinstance(sys, (int, float, complex, np.number)):\n        if ""inputs"" in kw:\n            inputs = kw[""inputs""]\n        else:\n            inputs = 1\n        if ""outputs"" in kw:\n            outputs = kw[""outputs""]\n        else:\n            outputs = 1\n\n        num = [[[sys] for j in range(inputs)] for i in range(outputs)]\n        den = [[[1] for j in range(inputs)] for i in range(outputs)]\n\n        return TransferFunction(num, den)\n\n    # If this is array-like, try to create a constant feedthrough\n    try:\n        D = array(sys)\n        outputs, inputs = D.shape\n        num = [[[D[i, j]] for j in range(inputs)] for i in range(outputs)]\n        den = [[[1] for j in range(inputs)] for i in range(outputs)]\n        return TransferFunction(num, den)\n    except Exception as e:\n        print(""Failure to assume argument is matrix-like in""\n              "" _convertToTransferFunction, result %s"" % e)\n\n    raise TypeError(""Can\'t convert given type to TransferFunction system."")\n\n\ndef tf(*args):\n    """"""tf(num, den[, dt])\n\n    Create a transfer function system. Can create MIMO systems.\n\n    The function accepts either 1, 2, or 3 parameters:\n\n    ``tf(sys)``\n        Convert a linear system into transfer function form. Always creates\n        a new system, even if sys is already a TransferFunction object.\n\n    ``tf(num, den)``\n        Create a transfer function system from its numerator and denominator\n        polynomial coefficients.\n\n        If `num` and `den` are 1D array_like objects, the function creates a\n        SISO system.\n\n        To create a MIMO system, `num` and `den` need to be 2D nested lists\n        of array_like objects. (A 3 dimensional data structure in total.)\n        (For details see note below.)\n\n    ``tf(num, den, dt)``\n        Create a discrete time transfer function system; dt can either be a\n        positive number indicating the sampling time or \'True\' if no\n        specific timebase is given.\n\n    ``tf(\'s\')`` or ``tf(\'z\')``\n        Create a transfer function representing the differential operator\n        (\'s\') or delay operator (\'z\').\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace or TransferFunction)\n        A linear system\n    num: array_like, or list of list of array_like\n        Polynomial coefficients of the numerator\n    den: array_like, or list of list of array_like\n        Polynomial coefficients of the denominator\n\n    Returns\n    -------\n    out: :class:`TransferFunction`\n        The new linear system\n\n    Raises\n    ------\n    ValueError\n        if `num` and `den` have invalid or unequal dimensions\n    TypeError\n        if `num` or `den` are of incorrect type\n\n    See Also\n    --------\n    TransferFunction\n    ss\n    ss2tf\n    tf2ss\n\n    Notes\n    -----\n    ``num[i][j]`` contains the polynomial coefficients of the numerator\n    for the transfer function from the (j+1)st input to the (i+1)st output.\n    ``den[i][j]`` works the same way.\n\n    The list ``[2, 3, 4]`` denotes the polynomial :math:`2s^2 + 3s + 4`.\n\n    The special forms ``tf(\'s\')`` and ``tf(\'z\')`` can be used to create\n    transfer functions for differentiation and unit delays.\n\n    Examples\n    --------\n    >>> # Create a MIMO transfer function object\n    >>> # The transfer function from the 2nd input to the 1st output is\n    >>> # (3s + 4) / (6s^2 + 5s + 4).\n    >>> num = [[[1., 2.], [3., 4.]], [[5., 6.], [7., 8.]]]\n    >>> den = [[[9., 8., 7.], [6., 5., 4.]], [[3., 2., 1.], [-1., -2., -3.]]]\n    >>> sys1 = tf(num, den)\n\n    >>> # Create a variable \'s\' to allow algebra operations for SISO systems\n    >>> s = tf(\'s\')\n    >>> G  = (s + 1)/(s**2 + 2*s + 1)\n\n    >>> # Convert a StateSpace to a TransferFunction object.\n    >>> sys_ss = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> sys2 = tf(sys1)\n\n    """"""\n\n    if len(args) == 2 or len(args) == 3:\n        return TransferFunction(*args)\n    elif len(args) == 1:\n        # Look for special cases defining differential/delay operator\n        if args[0] == \'s\':\n            return TransferFunction.s\n        elif args[0] == \'z\':\n            return TransferFunction.z\n\n        from .statesp import StateSpace\n        sys = args[0]\n        if isinstance(sys, StateSpace):\n            return ss2tf(sys)\n        elif isinstance(sys, TransferFunction):\n            return deepcopy(sys)\n        else:\n            raise TypeError(""tf(sys): sys must be a StateSpace or ""\n                            ""TransferFunction object.   It is %s."" % type(sys))\n    else:\n        raise ValueError(""Needs 1 or 2 arguments; received %i."" % len(args))\n\n\ndef ss2tf(*args):\n    """"""ss2tf(sys)\n\n    Transform a state space system to a transfer function.\n\n    The function accepts either 1 or 4 parameters:\n\n    ``ss2tf(sys)``\n        Convert a linear system into space system form. Always creates a\n        new system, even if sys is already a StateSpace object.\n\n    ``ss2tf(A, B, C, D)``\n        Create a state space system from the matrices of its state and\n        output equations.\n\n        For details see: :func:`ss`\n\n    Parameters\n    ----------\n    sys: StateSpace\n        A linear system\n    A: array_like or string\n        System matrix\n    B: array_like or string\n        Control matrix\n    C: array_like or string\n        Output matrix\n    D: array_like or string\n        Feedthrough matrix\n\n    Returns\n    -------\n    out: TransferFunction\n        New linear system in transfer function form\n\n    Raises\n    ------\n    ValueError\n        if matrix sizes are not self-consistent, or if an invalid number of\n        arguments is passed in\n    TypeError\n        if `sys` is not a StateSpace object\n\n    See Also\n    --------\n    tf\n    ss\n    tf2ss\n\n    Examples\n    --------\n    >>> A = [[1., -2], [3, -4]]\n    >>> B = [[5.], [7]]\n    >>> C = [[6., 8]]\n    >>> D = [[9.]]\n    >>> sys1 = ss2tf(A, B, C, D)\n\n    >>> sys_ss = ss(A, B, C, D)\n    >>> sys2 = ss2tf(sys_ss)\n\n    """"""\n\n    from .statesp import StateSpace\n    if len(args) == 4 or len(args) == 5:\n        # Assume we were given the A, B, C, D matrix and (optional) dt\n        return _convert_to_transfer_function(StateSpace(*args))\n\n    elif len(args) == 1:\n        sys = args[0]\n        if isinstance(sys, StateSpace):\n            return _convert_to_transfer_function(sys)\n        else:\n            raise TypeError(\n                ""ss2tf(sys): sys must be a StateSpace object.  It is %s.""\n                % type(sys))\n    else:\n        raise ValueError(""Needs 1 or 4 arguments; received %i."" % len(args))\n\n\ndef tfdata(sys):\n    """"""\n    Return transfer function data objects for a system\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace, or TransferFunction)\n        LTI system whose data will be returned\n\n    Returns\n    -------\n    (num, den): numerator and denominator arrays\n        Transfer function coefficients (SISO only)\n    """"""\n    tf = _convert_to_transfer_function(sys)\n\n    return tf.num, tf.den\n\n\ndef _clean_part(data):\n    """"""\n    Return a valid, cleaned up numerator or denominator\n    for the TransferFunction class.\n\n    Parameters\n    ----------\n    data: numerator or denominator of a transfer function.\n\n    Returns\n    -------\n    data: list of lists of ndarrays, with int converted to float\n    """"""\n    valid_types = (int, float, complex, np.number)\n    valid_collection = (list, tuple, ndarray)\n\n    if (isinstance(data, valid_types) or\n            (isinstance(data, ndarray) and data.ndim == 0)):\n        # Data is a scalar (including 0d ndarray)\n        data = [[array([data])]]\n    elif (isinstance(data, ndarray) and data.ndim == 3 and\n          isinstance(data[0, 0, 0], valid_types)):\n        data = [[array(data[i, j])\n                 for j in range(data.shape[1])]\n                for i in range(data.shape[0])]\n    elif (isinstance(data, valid_collection) and\n            all([isinstance(d, valid_types) for d in data])):\n        data = [[array(data)]]\n    elif (isinstance(data, (list, tuple)) and\n          isinstance(data[0], (list, tuple)) and\n          (isinstance(data[0][0], valid_collection) and\n           all([isinstance(d, valid_types) for d in data[0][0]]))):\n        data = list(data)\n        for j in range(len(data)):\n            data[j] = list(data[j])\n            for k in range(len(data[j])):\n                data[j][k] = array(data[j][k])\n    else:\n        # If the user passed in anything else, then it\'s unclear what\n        # the meaning is.\n        raise TypeError(\n            ""The numerator and denominator inputs must be scalars or vectors ""\n            ""(for\\nSISO), or lists of lists of vectors (for SISO or MIMO)."")\n\n    # Check for coefficients that are ints and convert to floats\n    for i in range(len(data)):\n        for j in range(len(data[i])):\n            for k in range(len(data[i][j])):\n                if isinstance(data[i][j][k], (int, np.int)):\n                    data[i][j][k] = float(data[i][j][k])\n\n    return data\n\n\n# Define constants to represent differentiation, unit delay\nTransferFunction.s = TransferFunction([1, 0], [1], 0)\nTransferFunction.z = TransferFunction([1, 0], [1], True)\n'"
External_Libraries/python_control_master/doc/conf.py,0,"b'# -*- coding: utf-8 -*-\n#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# http://www.sphinx-doc.org/en/master/config\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\nsys.path.insert(0, os.path.abspath(\'../\'))\n\n# Use the readthedocs.org theme if installed\non_rtd = os.environ.get(\'READTHEDOCS\', None) == \'True\'\n\nif not on_rtd:  # only import and set the theme if we\'re building docs locally\n    try:\n        import sphinx_rtd_theme\n        html_theme = \'sphinx_rtd_theme\'\n        html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n    except ImportError:\n        html_theme = \'default\'\n\n# -- Project information -----------------------------------------------------\n\nproject = u\'Python Control Systems Library\'\ncopyright = u\'2019, python-control.org\'\nauthor = u\'Python Control Developers\'\n\n# Version information - read from the source code\nimport re\nimport control\n\n# The short X.Y.Z version\nversion = re.sub(r\'(\\d+\\.\\d+\\.\\d+)(.*)\', r\'\\1\', control.__version__)\n\n# The full version, including alpha/beta/rc tags\nrelease = control.__version__\nprint(""version %s, release %s"" % (version, release))\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\', \'sphinx.ext.todo\', \'sphinx.ext.napoleon\',\n    \'sphinx.ext.intersphinx\', \'sphinx.ext.imgmath\', \n    \'sphinx.ext.autosummary\',\n]\n\n# scan documents for autosummary directives and generate stub pages for each.\nautosummary_generate = True\n\n# list of autodoc directive flags that should be automatically applied\n# to all autodoc directives.\nautodoc_default_flags = [\'members\', \'inherited-members\']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = [u\'_build\', \'Thumbs.db\', \'.DS_Store\']\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n#This config value contains the locations and names of other projects that \n#should be linked to in this documentation.\nintersphinx_mapping = \\\n    {\'scipy\':(\'https://docs.scipy.org/doc/scipy/reference/\', None),\n     \'numpy\':(\'https://docs.scipy.org/doc/numpy\', None)}\n\n#If this is True, todo and todolist produce output, else they produce nothing. \n#The default is False.\ntodo_include_todos = True\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\n# html_static_path = [\'_static\']\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don\'t match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``[\'localtoc.html\', \'relations.html\', \'sourcelink.html\',\n# \'searchbox.html\']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'PythonControlLibrarydoc\'\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size (\'letterpaper\' or \'a4paper\').\n    #\n    # \'papersize\': \'letterpaper\',\n\n    # The font size (\'10pt\', \'11pt\' or \'12pt\').\n    #\n    # \'pointsize\': \'10pt\',\n\n    # Additional stuff for the LaTeX preamble.\n    #\n    # \'preamble\': \'\',\n\n    # Latex figure (float) alignment\n    #\n    # \'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'PythonControlLibrary.tex\', u\'Python Control Library Documentation\',\n     u\'RMM\', \'manual\'),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'pythoncontrollibrary\', u\'Python Control Library Documentation\',\n     [author], 1)\n]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'PythonControlLibrary\', u\'Python Control Library Documentation\',\n     author, \'PythonControlLibrary\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for intersphinx extension ---------------------------------------\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {\'https://docs.python.org/\': None}\n'"
External_Libraries/python_control_master/external/controls.py,0,"b'# controls.py - Ryan Krauss\'s control module\n# $Id: controls.py 30 2010-11-06 16:26:19Z murrayrm $\n\n""""""This module is for analyzing linear, time-invariant dynamic systems\nand feedback control systems using the Laplace transform.  The heart\nof the module is the TransferFunction class, which represents a\ntransfer function as a ratio of numerator and denominator polynomials\nin s.  TransferFunction is derived from scipy.signal.lti.""""""\n\nimport glob, pdb\nfrom math import atan2, log10\n\nfrom scipy import *\nfrom scipy import signal\nfrom scipy import interpolate, integrate\nfrom scipy.linalg import inv as inverse\nfrom scipy.optimize import newton, fmin, fminbound\n#from scipy.io import read_array, save, loadmat, write_array\nfrom scipy import signal\nfrom numpy.linalg import LinAlgError\n\nfrom  IPython.Debugger import Pdb\n\nimport sys, os, copy, time\n\nfrom matplotlib.ticker import LogFormatterMathtext\n\nversion = \'1.1.4\'\n\nclass MyFormatter(LogFormatterMathtext):\n   def __call__(self, x, pos=None):\n       if pos==0: return \'\'  # pos=0 is the first tick\n       else: return LogFormatterMathtext.__call__(self, x, pos)\n\n\ndef shift(vectin, new):\n    N = len(vectin)-1\n    for n in range(N,0,-1):\n        vectin[n]=vectin[n-1]\n    vectin[0]=new\n    return vectin\n\ndef myeq(p1,p2):\n    """"""Test the equality of the of two polynomials based on\n    coeffiecents.""""""\n    if hasattr(p1, \'coeffs\') and hasattr(p2, \'coeffs\'):\n       c1=p1.coeffs\n       c2=p2.coeffs\n    else:\n       return False\n    if len(c1)!=len(c2):\n        return False\n    else:\n        testvect=c1==c2\n        if hasattr(testvect,\'all\'):\n            return testvect.all()\n        else:\n            return testvect\n\ndef build_fit_matrix(output_vect, input_vect, numorder, denorder):\n    """"""Build the [A] matrix used in least squares curve fitting\n    according to\n\n    output_vect = [A]c\n\n    as described in fit_discrete_response.""""""\n    A = zeros((len(output_vect),numorder+denorder+1))#the +1 accounts\n         #for the fact that both the numerator and the denominator\n         #have zero-order terms (which would give +2), but the\n         #zero order denominator term is actually not used in the fit\n         #(that is the output vector)\n    curin = input_vect\n    A[:,0] = curin\n    for n in range(1, numorder+1):\n        curin = r_[[0.0], curin[0:-1]]#prepend a 0 to curin and drop its\n                                    #last element\n        A[:,n] = curin\n    curout = -output_vect#this is the first output column, but it not\n                        #actually used\n    firstden = numorder+1\n    for n in range(0, denorder):\n        curout = r_[[0.0], curout[0:-1]]\n        A[:,firstden+n] = curout\n    return A\n    \n\ndef fit_discrete_response(output_vect, input_vect, numorder, denorder):\n    """"""Find the coefficients of a digital transfer function that give\n    the best fit to output_vect in a least squares sense.  output_vect\n    is the output of the system and input_vect is the input.  The\n    input and output vectors are shifted backward in time a maximum of\n    numorder and denorder steps respectively.  Each shifted vector\n    becomes a column in the matrix for the least squares curve fit of\n    the form\n\n    output_vect = [A]c\n\n    where [A] is the matrix whose columns are shifted versions of\n    input_vect and output_vect and c is composed of the numerator and\n    denominator coefficients of the transfer function. numorder and\n    denorder are the highest power of z in the numerator or\n    denominator respectively.\n\n    In essence, the approach is to find the coefficients that best fit\n    related the input_vect and output_vect according to the difference\n    equation\n\n    y(k) = b_0 x(k) + b_1 x(k-1) + b_2 x(k-2) + ... + b_m x(k-m)\n           - a_1 y(k-1) - a_2 y(k-2) - ... - a_n y(k-n)\n\n    where x = input_vect, y = output_vect, m = numorder, and\n    n = denorder.  The unknown coefficient vector is then\n\n    c = [b_0, b_1, b_2, ... , b_m, a_1, a_2, ..., a_n]\n\n    Note that a_0 is forced to be 1.\n\n    The matrix [A] is then composed of [A] = [X(k) X(k-1) X(k-2)\n    ... Y(k-1) Y(k-2) ...]  where X(k-2) represents the input_vect\n    shifted 2 elements and Y(k-2) represents the output_vect shifted\n    two elements.""""""\n    A = build_fit_matrix(output_vect, input_vect, numorder, denorder)\n    fitres = linalg.lstsq(A, output_vect)\n    x = fitres[0]\n    numz = x[0:numorder+1]\n    denz = x[numorder+1:]\n    denz = r_[[1.0],denz]\n    return numz, denz\n\ndef prependzeros(num, den):\n    nd = len(den)\n    if isscalar(num):\n       nn = 1\n    else:\n       nn = len(num)\n    if nn < nd:\n        zvect = zeros(nd-nn)\n        numout = r_[zvect, num]\n    else:\n        numout = num\n    return numout, den\n\ndef in_with_tol(elem, searchlist, rtol=1e-5, atol=1e-10):\n    """"""Determine whether or not elem+/-tol matches an element of\n    searchlist.""""""\n    for n, item in enumerate(searchlist):\n       if allclose(item, elem, rtol=rtol, atol=atol):\n            return n\n    return -1\n\n\n\ndef PolyToLatex(polyin, var=\'s\', fmt=\'%0.5g\', eps=1e-12):\n    N = polyin.order\n    clist = polyin.coeffs\n    outstr = \'\'\n    for i, c in enumerate(clist):\n        curexp = N-i\n        curcoeff = fmt%c\n        if curexp > 0:\n            if curexp == 1:\n                curs = var\n            else:\n                curs = var+\'^%i\'%curexp\n            #Handle coeffs of +/- 1 in a special way:\n            if 1-eps < c < 1+eps:\n                curcoeff = \'\'\n            elif -1-eps < c < -1+eps:\n                curcoeff = \'-\'\n        else:\n            curs=\'\'\n        curstr = curcoeff+curs\n        if c > 0 and outstr:\n            curcoeff = \'+\'+curcoeff\n        if abs(c) > eps:\n            outstr+=curcoeff+curs\n    return outstr\n\n    \ndef polyfactor(num, den, prepend=True, rtol=1e-5, atol=1e-10):\n    """"""Factor out any common roots from the polynomials represented by\n    the vectors num and den and return new coefficient vectors with\n    any common roots cancelled.\n\n    Because poly1d does not think in terms of z^-1, z^-2, etc. it may\n    be necessary to add zeros to the beginning of the numpoly coeffs\n    to represent multiplying through be z^-n where n is the order of\n    the denominator.  If prependzeros is Trus, the numerator and\n    denominator coefficient vectors will have the same length.""""""\n    numpoly = poly1d(num)\n    denpoly = poly1d(den)\n    nroots = roots(numpoly).tolist()\n    droots = roots(denpoly).tolist()\n    n = 0\n    while n < len(nroots):\n        curn = nroots[n]\n        ind = in_with_tol(curn, droots, rtol=rtol, atol=atol)\n        if ind > -1:\n            nroots.pop(n)\n            droots.pop(ind)\n            #numpoly, rn = polydiv(numpoly, poly(curn))\n            #denpoly, rd = polydiv(denpoly, poly(curn))\n        else:\n            n += 1\n    numpoly = poly(nroots)\n    denpoly = poly(droots)\n    nvect = numpoly\n    dvect = denpoly\n    if prepend:\n        nout, dout = prependzeros(nvect, dvect)\n    else:\n        nout = nvect\n        dout = dvect\n    return nout, dout\n\n\ndef polysubstitute(polyin, numsub, densub):\n    """"""Substitute one polynomial into another to support Tustin and\n    other c2d algorithms of a similar approach.  The idea is to make\n    it easy to substitute\n\n        a  z-1\n    s = - -----\n        T  z+1\n\n    or other forms involving ratios of polynomials for s in a\n    polynomial of s such as the numerator or denominator of a transfer\n    function.\n\n    For the tustin example above, numsub=a*(z-1) and densub=T*(z+1),\n    where numsub and densub are scipy.poly1d instances.\n\n    Note that this approach seems to have substantial floating point\n    problems.""""""\n    mys = TransferFunction(numsub, densub)\n    out = 0.0\n    no = polyin.order\n    for n, coeff in enumerate(polyin.coeffs):\n        curterm = coeff*mys**(no-n)\n        out = out+curterm\n    return out\n\n\ndef tustin_sub(polyin, T, a=2.0):\n    numsub = a*poly1d([1.0,-1.0])\n    densub = T*poly1d([1.0,1.0])\n    out = polysubstitute(polyin, numsub, densub)\n    out.myvar = \'z\'\n    return out\n    \n\ndef create_swept_sine_input(maxt, dt, maxf, minf=0.0, deadtime=2.0):\n    t = arange(0, maxt, dt)\n    u = sweptsine(t, minf=minf, maxf=maxf)\n    if deadtime:\n        deadt = arange(0,deadtime, dt)\n        zv = zeros_like(deadt)\n        u = r_[zv, u, zv]\n    return u\n\ndef create_swept_sine_t(maxt, dt, deadtime=2.0):\n    t = arange(0, maxt, dt)\n    if deadtime:\n        deadt = arange(0,deadtime, dt)\n        t = t+max(deadt)+dt\n        tpost = deadt+max(t)+dt\n        return r_[deadt, t, tpost]\n    else:\n        return t\n\ndef ADC(vectin, bits=9, vmax=2.5, vmin=-2.5):\n    """"""Simulate the sampling portion of an analog-to-digital\n    conversion by outputing an integer number of counts associate with\n    each voltage in vectin.""""""\n    dv = (vmax-vmin)/2**bits\n    vect2 = clip(vectin, vmin, vmax)\n    counts = vect2/dv\n    return counts.astype(int)\n\n\ndef CountsToFloat(counts, bits=9, vmax=2.5, vmin=-2.5):\n    """"""Convert the integer output of ADC to a floating point number by\n    mulitplying by dv.""""""\n    dv = (vmax-vmin)/2**bits\n    return dv*counts\n\n\ndef epslist(listin, eps=1.0e-12):\n    """"""Make a copy of listin and then check each element of the copy\n    to see if its absolute value is greater than eps.  Set to zero all\n    elements in the copied list whose absolute values are less than\n    eps.  Return the copied list.""""""\n    listout = copy.deepcopy(listin)\n    for i in range(len(listout)):\n        if abs(listout[i])<eps:\n            listout[i] = 0.0\n    return listout\n\n\ndef _PlotMatrixvsF(freqvect,matin,linetype=\'\',linewidth=None, semilogx=True, allsolid=False, axis=None):\n    mykwargs={}\n    usepylab = False\n    if axis is None:\n       import pylab\n       axis = pylab.gca()\n       usepylab = True\n    if len(shape(matin))==1:\n        myargs=[freqvect,matin]\n        if linetype:\n            myargs.append(linetype)\n        else:\n            mykwargs.update(_getlinetype(axis))\n        if linewidth:\n            mykwargs[\'linewidth\']=linewidth\n        if semilogx:\n            curline,=axis.semilogx(*myargs,**mykwargs)\n        else:\n            curline,=axis.plot(*myargs,**mykwargs)\n        mylines=[curline]\n#        _inccount()\n    else:\n        mylines=[]\n        for q in range(shape(matin)[1]):\n            myargs=[freqvect,matin[:,q]]\n            if linetype:\n                myargs.append(linetype)\n            else:\n                mykwargs.update(_getlinetype(axis))\n            if linewidth:\n                mykwargs[\'linewidth\']=linewidth\n            if semilogx:\n                curline,=axis.semilogx(*myargs,**mykwargs)\n            else:\n                curline,=axis.plot(*myargs,**mykwargs)\n            mylines.append(curline)\n#            _inccount()\n    return mylines\n\n\ndef _PlotMag(freqvect, bodein, linetype=\'-\', linewidth=0, axis=None):\n    if callable(bodein.dBmag):\n        myvect=bodein.dBmag()\n    else:\n        myvect=bodein.dBmag\n    return _PlotMatrixvsF(freqvect, myvect, linetype=linetype, linewidth=linewidth, axis=axis)\n\n\ndef _PlotPhase(freqvect, bodein, linetype=\'-\', linewidth=0, axis=None):\n    return _PlotMatrixvsF(freqvect,bodein.phase,linetype=linetype,linewidth=linewidth, axis=axis)\n\n\ndef _k_poles(TF,poleloc):\n    L = TF.num(poleloc)/TF.den(poleloc)\n    k = 1.0/abs(L)\n    poles = TF._RLFindRoots([k])\n    poles = TF._RLSortRoots(poles)\n    return k,poles\n\ndef _checkpoles(poleloc,pnew):\n    evect = abs(poleloc-array(pnew))\n    ind = evect.argmin()\n    pout = pnew[ind]\n    return pout\n\n\ndef _realizable(num, den):\n    realizable = False\n    if not isscalar(den):        \n        if isscalar(num):\n            realizable = True\n        elif len(den) >= len(num):\n            realizable = True\n    return realizable\n\n\ndef shape_u(uvect, slope):\n    u_shaped = zeros_like(uvect)\n    u_shaped[0] = uvect[0]\n\n    N = len(uvect)\n\n    for n in range(1, N):\n        diff = uvect[n] - u_shaped[n-1]\n        if diff > slope:\n            u_shaped[n] = u_shaped[n-1] + slope\n        elif diff < -1*slope:\n            u_shaped[n] = u_shaped[n-1] - slope\n        else:\n            u_shaped[n] = uvect[n]\n    return u_shaped\n\n\nclass TransferFunction(signal.lti):\n    def __setattr__(self, attr, val):\n        realizable = False\n        if hasattr(self, \'den\') and hasattr(self, \'num\'):\n            realizable = _realizable(self.num, self.den)\n        if realizable:\n            signal.lti.__setattr__(self, attr, val)\n        else:\n            self.__dict__[attr] = val\n\n          \n    def __init__(self, num, den, dt=0.01, maxt=5.0, myvar=\'s\', label=\'G\'):\n        """"""num and den are either scalar constants or lists that are\n        passed to scipy.poly1d to create a list of coefficients.""""""\n        #print(\'in TransferFunction.__init__, dt=%s\' % dt)\n        if _realizable(num, den):\n            num = atleast_1d(num)\n            den = atleast_1d(den)\n            start_num_ind = nonzero(num)[0][0]\n            start_den_ind = nonzero(den)[0][0]\n            num_ = num[start_num_ind:]\n            den_ = den[start_den_ind:]\n            signal.lti.__init__(self, num_, den_)\n        else:\n            z, p, k = signal.tf2zpk(num, den)\n            self.gain = k\n        self.num = poly1d(num)\n        self.den = poly1d(den) \n        self.dt = dt\n        self.myvar = myvar\n        self.maxt = maxt\n        self.label = label\n\n\n    def print_poles(self, label=None):\n       if label is None:\n          label = self.label\n       print(label +\' poles =\' + str(self.poles))\n       \n\n    def __repr__(self, labelstr=\'controls.TransferFunction\'):\n        nstr=str(self.num)#.strip()\n        dstr=str(self.den)#.strip()\n        nstr=nstr.replace(\'x\',self.myvar)\n        dstr=dstr.replace(\'x\',self.myvar)\n        n=len(dstr)\n        m=len(nstr)\n        shift=(n-m)/2*\' \'\n        nstr=nstr.replace(\'\\n\',\'\\n\'+shift)\n        tempstr=labelstr+\'\\n\'+shift+nstr+\'\\n\'+\'-\'*n+\'\\n \'+dstr\n        return tempstr\n\n\n    def __call__(self,s,optargs=()):\n        return self.num(s)/self.den(s)\n\n\n    def __add__(self,other):\n        if hasattr(other,\'num\') and hasattr(other,\'den\'):\n            if len(self.den.coeffs)==len(other.den.coeffs) and \\\n                   (self.den.coeffs==other.den.coeffs).all():\n                return TransferFunction(self.num+other.num,self.den)\n            else:\n                return TransferFunction(self.num*other.den+other.num*self.den,self.den*other.den)\n        elif isinstance(other, int) or isinstance(other, float):\n            return TransferFunction(other*self.den+self.num,self.den)\n        else:\n            raise ValueError, \'do not know how to add TransferFunction and \'+str(other) +\' which is of type \'+str(type(other))\n\n    def __radd__(self,other):\n        return self.__add__(other)\n\n\n    def __mul__(self,other):\n        if isinstance(other, Digital_P_Control):\n           return self.__class__(other.kp*self.num, self.den)\n        elif hasattr(other,\'num\') and hasattr(other,\'den\'):\n            if myeq(self.num,other.den) and myeq(self.den,other.num):\n                return 1\n            elif myeq(self.num,other.den):\n                return self.__class__(other.num,self.den)\n            elif myeq(self.den,other.num):\n                return self.__class__(self.num,other.den)\n            else:\n               gain = self.gain*other.gain\n               new_num, new_den = polyfactor(self.num*other.num, \\\n                                             self.den*other.den)\n               newtf = self.__class__(new_num*gain, new_den)\n               return newtf\n        elif isinstance(other, int) or isinstance(other, float):\n            return self.__class__(other*self.num,self.den)\n\n\n    def __pow__(self, expon):\n        """"""Basically, go self*self*self as many times as necessary.  I\n        haven\'t thought about negative exponents.  I don\'t think this\n        would be hard, you would just need to keep dividing by self\n        until you got the right answer.""""""\n        assert expon >= 0, \'TransferFunction.__pow__ does not yet support negative exponents.\'\n        out = 1.0\n        for n in range(expon):\n            out *= self\n        return out\n\n\n    def __rmul__(self,other):\n        return self.__mul__(other)\n\n\n    def __div__(self,other):\n        if hasattr(other,\'num\') and hasattr(other,\'den\'):\n            if myeq(self.den,other.den):\n                return TransferFunction(self.num,other.num)\n            else:\n                return TransferFunction(self.num*other.den,self.den*other.num)\n        elif isinstance(other, int) or isinstance(other, float):\n            return TransferFunction(self.num,other*self.den)\n\n\n    def __rdiv__(self, other):\n        print(\'calling TransferFunction.__rdiv__\')\n        return self.__div__(other)\n\n\n    def __truediv__(self,other):\n        return self.__div__(other)\n\n\n    def _get_set_dt(self, dt=None):\n        if dt is not None:\n            self.dt = float(dt)\n        return self.dt\n\n\n    def simplify(self, rtol=1e-5, atol=1e-10):\n        """"""Return a new TransferFunction object with poles and zeros\n        that nearly cancel (within real or absolutie tolerance rtol\n        and atol) removed.""""""\n        gain = self.gain\n        new_num, new_den = polyfactor(self.num, self.den, prepend=False)\n        newtf = self.__class__(new_num*gain, new_den)\n        return newtf\n\n                 \n    def ToLatex(self, eps=1e-12, fmt=\'%0.5g\', ds=True):\n        mynum = self.num\n        myden = self.den\n        npart = PolyToLatex(mynum)\n        dpart = PolyToLatex(myden)\n        outstr = \'\\\\frac{\'+npart+\'}{\'+dpart+\'}\'\n        if ds:\n            outstr = \'\\\\displaystyle \'+outstr\n        return outstr\n\n\n    def RootLocus(self, kvect, fig=None, fignum=1, \\\n                  clear=True, xlim=None, ylim=None, plotstr=\'-\'):\n        """"""Calculate the root locus by finding the roots of 1+k*TF(s)\n        where TF is self.num(s)/self.den(s) and each k is an element\n        of kvect.""""""\n        if fig is None:\n            import pylab\n            fig = pylab.figure(fignum)\n        if clear:\n            fig.clf()\n        ax = fig.add_subplot(111)\n        mymat = self._RLFindRoots(kvect)\n        mymat = self._RLSortRoots(mymat)\n        #plot open loop poles\n        poles = array(self.den.r)\n        ax.plot(real(poles), imag(poles), \'x\')\n        #plot open loop zeros\n        zeros = array(self.num.r)\n        if zeros.any():\n            ax.plot(real(zeros), imag(zeros), \'o\')\n        for col in mymat.T:\n            ax.plot(real(col), imag(col), plotstr)\n        if xlim:\n            ax.set_xlim(xlim)\n        if ylim:\n            ax.set_ylim(ylim)\n        ax.set_xlabel(\'Real\')\n        ax.set_ylabel(\'Imaginary\')\n        return mymat\n\n\n    def _RLFindRoots(self, kvect):\n        """"""Find the roots for the root locus.""""""\n        roots = []\n        for k in kvect:\n            curpoly = self.den+k*self.num\n            curroots = curpoly.r\n            curroots.sort()\n            roots.append(curroots)\n        mymat = row_stack(roots)\n        return mymat\n\n\n    def _RLSortRoots(self, mymat):\n        """"""Sort the roots from self._RLFindRoots, so that the root\n        locus doesn\'t show weird pseudo-branches as roots jump from\n        one branch to another.""""""\n        sorted = zeros_like(mymat)\n        for n, row in enumerate(mymat):\n            if n==0:\n                sorted[n,:] = row\n            else:\n                #sort the current row by finding the element with the\n                #smallest absolute distance to each root in the\n                #previous row\n                available = range(len(prevrow))\n                for elem in row:\n                    evect = elem-prevrow[available]\n                    ind1 = abs(evect).argmin()\n                    ind = available.pop(ind1)\n                    sorted[n,ind] = elem\n            prevrow = sorted[n,:]\n        return sorted\n        \n\n    def opt(self, kguess):\n        pnew = self._RLFindRoots(kguess)\n        pnew = self._RLSortRoots(pnew)[0]\n        if len(pnew)>1:\n           pnew = _checkpoles(self.poleloc,pnew)\n           e = abs(pnew-self.poleloc)**2\n        return sum(e)\n\n\n    def rlocfind(self, poleloc):\n        self.poleloc = poleloc\n        kinit,pinit = _k_poles(self,poleloc)\n        k = fmin(self.opt,[kinit])[0]\n        poles = self._RLFindRoots([k])\n        poles = self._RLSortRoots(poles)\n        return k, poles\n\n\n    def PlotTimeResp(self, u, t, fig, clear=True, label=\'model\', mysub=111):\n        ax = fig.add_subplot(mysub)\n        if clear:\n            ax.cla()\n        try:\n            y = self.lsim(u, t)\n        except:\n            y = self.lsim2(u, t)\n        ax.plot(t, y, label=label)\n        return ax\n\n\n##     def BodePlot(self, f, fig, clear=False):\n##         mtf = self.FreqResp(\n##         ax1 = fig.axes[0]\n##         ax1.semilogx(modelf,20*log10(abs(mtf)))\n##         mphase = angle(mtf, deg=1)\n##         ax2 = fig.axes[1]\n##         ax2.semilogx(modelf, mphase)\n\n        \n    def SimpleFactor(self):\n        mynum=self.num\n        myden=self.den\n        dsf=myden[myden.order]\n        nsf=mynum[mynum.order]\n        sden=myden/dsf\n        snum=mynum/nsf\n        poles=sden.r\n        residues=zeros(shape(sden.r),\'D\')\n        factors=[]\n        for x,p in enumerate(poles):\n            polearray=poles.copy()\n            polelist=polearray.tolist()\n            mypole=polelist.pop(x)\n            tempden=1.0\n            for cp in polelist:\n                tempden=tempden*(poly1d([1,-cp]))\n            tempTF=TransferFunction(snum,tempden)\n            curres=tempTF(mypole)\n            residues[x]=curres\n            curTF=TransferFunction(curres,poly1d([1,-mypole]))\n            factors.append(curTF)\n        return factors,nsf,dsf\n\n    def factor_constant(self, const):\n        """"""Divide numerator and denominator coefficients by const""""""\n        self.num = self.num/const\n        self.den = self.den/const\n\n    def lsim(self, u, t, interp=0, returnall=False, X0=None, hmax=None):\n        """"""Find the response of the TransferFunction to the input u\n        with time vector t.  Uses signal.lsim.\n\n        return y the response of the system.""""""\n        try:\n           out = signal.lsim(self, u, t, interp=interp, X0=X0)\n        except LinAlgError:\n           #if the system has a pure integrator, lsim won\'t work.\n           #Call lsim2.\n           out = self.lsim2(u, t, X0=X0, returnall=True, hmax=hmax)\n                 #override returnall because it is handled below\n        if returnall:#most users will just want the system output y,\n                     #but some will need the (t, y, x) tuple that\n                     #signal.lsim returns\n            return out\n        else:\n            return out[1]\n\n##     def lsim2(self, u, t, returnall=False, X0=None):\n##         #tempsys=signal.lti(self.num,self.den)\n##         if returnall:\n##             return signal.lsim2(self, u, t, X0=X0)\n##         else:\n##             return signal.lsim2(self, u, t, X0=X0)[1]\n\n    def lsim2(self, U, T, X0=None, returnall=False, hmax=None):\n       """"""Simulate output of a continuous-time linear system, using ODE solver.\n\n       Inputs:\n\n           system -- an instance of the LTI class or a tuple describing the\n           system.  The following gives the number of elements in\n           the tuple and the interpretation.\n           2 (num, den)\n           3 (zeros, poles, gain)\n           4 (A, B, C, D)\n       U -- an input array describing the input at each time T\n             (linear interpolation is assumed between given times).\n             If there are multiple inputs, then each column of the\n             rank-2 array represents an input.\n       T -- the time steps at which the input is defined and at which\n             the output is desired.\n       X0 -- (optional, default=0) the initial conditions on the state vector.\n\n       Outputs: (T, yout, xout)\n\n       T -- the time values for the output.\n       yout -- the response of the system.\n       xout -- the time-evolution of the state-vector.\n       """"""\n       # system is an lti system or a sequence\n       #  with 2 (num, den)\n       #       3 (zeros, poles, gain)\n       #       4 (A, B, C, D)\n       #  describing the system\n       #  U is an input vector at times T\n       #   if system describes multiple outputs\n       #   then U can be a rank-2 array with the number of columns\n       #   being the number of inputs\n\n       # rather than use lsim, use direct integration and matrix-exponential.\n       if hmax is None:\n          hmax = T[1]-T[0]\n       U = atleast_1d(U)\n       T = atleast_1d(T)\n       if len(U.shape) == 1:\n           U = U.reshape((U.shape[0],1))\n       sU = U.shape\n       if len(T.shape) != 1:\n           raise ValueError, ""T must be a rank-1 array.""\n       if sU[0] != len(T):\n           raise ValueError, ""U must have the same number of rows as elements in T.""\n       if sU[1] != self.inputs:\n           raise ValueError, ""System does not define that many inputs.""\n\n       if X0 is None:\n           X0 = zeros(self.B.shape[0],self.A.dtype)\n\n       # for each output point directly integrate assume zero-order hold\n       #   or linear interpolation.\n\n       ufunc = interpolate.interp1d(T, U, kind=\'linear\', axis=0, \\\n                                    bounds_error=False)\n\n       def fprime(x, t, self, ufunc):\n           return dot(self.A,x) + squeeze(dot(self.B,nan_to_num(ufunc([t]))))\n\n       xout = integrate.odeint(fprime, X0, T, args=(self, ufunc), hmax=hmax)\n       yout = dot(self.C,transpose(xout)) + dot(self.D,transpose(U))\n       if returnall:\n          return T, squeeze(transpose(yout)), xout\n       else:\n          return squeeze(transpose(yout))\n\n\n    def residue(self, tol=1e-3, verbose=0):\n        """"""from scipy.signal.residue:\n\n        Compute residues/partial-fraction expansion of b(s) / a(s).\n\n        If M = len(b) and N = len(a)\n\n                b(s)     b[0] s**(M-1) + b[1] s**(M-2) + ... + b[M-1]\n        H(s) = ------ = ----------------------------------------------\n                a(s)     a[0] s**(N-1) + a[1] s**(N-2) + ... + a[N-1]\n\n                 r[0]       r[1]             r[-1]\n             = -------- + -------- + ... + --------- + k(s)\n               (s-p[0])   (s-p[1])         (s-p[-1])\n\n        If there are any repeated roots (closer than tol), then the\n        partial fraction expansion has terms like\n\n            r[i]      r[i+1]              r[i+n-1]\n          -------- + ----------- + ... + -----------\n          (s-p[i])  (s-p[i])**2          (s-p[i])**n\n\n          returns r, p, k\n          """"""\n        r,p,k = signal.residue(self.num, self.den, tol=tol)\n        if verbose>0:\n            print(\'r=\'+str(r))\n            print(\'\')\n            print(\'p=\'+str(p))\n            print(\'\')\n            print(\'k=\'+str(k))\n\n        return r, p, k\n\n\n    def PartFrac(self, eps=1.0e-12):\n        """"""Compute the partial fraction expansion based on the residue\n        command.  In the final polynomials, coefficients whose\n        absolute values are less than eps are set to zero.""""""\n        r,p,k = self.residue()\n\n        rlist = r.tolist()\n        plist = p.tolist()\n\n        N = len(rlist)\n\n        tflist = []\n        eps = 1e-12\n\n        while N > 0:\n            curr = rlist.pop(0)\n            curp = plist.pop(0)\n            if abs(curp.imag) < eps:\n                #This is a purely real pole.  The portion of the partial\n                #fraction expansion corresponding to this pole is curr/(s-curp)\n                curtf = TransferFunction(curr,[1,-curp])\n            else:\n                #this is a complex pole and we need to find its conjugate and\n                #handle them together\n                cind = plist.index(curp.conjugate())\n                rconj = rlist.pop(cind)\n                pconj = plist.pop(cind)\n                p1 = poly1d([1,-curp])\n                p2 = poly1d([1,-pconj])\n                #num = curr*p2+rconj*p1\n                Nr = curr.real\n                Ni = curr.imag\n                Pr = curp.real\n                Pi = curp.imag\n                numlist = [2.0*Nr,-2.0*(Nr*Pr+Ni*Pi)]\n                numlist = epslist(numlist, eps)\n                num = poly1d(numlist)\n                denlist = [1, -2.0*Pr,Pr**2+Pi**2]\n                denlist = epslist(denlist, eps)\n                den = poly1d(denlist)\n                curtf = TransferFunction(num,den)\n            tflist.append(curtf)\n            N = len(rlist)\n        return tflist\n    \n\n    def FreqResp(self, f, fignum=1, fig=None, clear=True, \\\n                 grid=True, legend=None, legloc=1, legsub=1, \\\n                 use_rad=False, **kwargs):\n        """"""Compute the frequency response of the transfer function\n        using the frequency vector f, returning a complex vector.\n\n        The frequency response (Bode plot) will be plotted on\n        figure(fignum) unless fignum=None.\n\n        legend should be a list of legend entries if a legend is\n        desired.  If legend is not None, the legend will be placed on\n        the top half of the plot (magnitude portion) if legsub=1, or\n        on the bottom half with legsub=2.  legloc follows the same\n        rules as the pylab legend command (1 is top right and goes\n        counter-clockwise from there.)""""""\n        testvect=real(f)==0\n        if testvect.all():\n           s=f#then you really sent me s and not f\n        else:\n           if use_rad:\n              s = 1.0j*f\n           else:\n              s=2.0j*pi*f\n        self.comp = self.num(s)/self.den(s)\n        self.dBmag = 20*log10(abs(self.comp))\n        rphase = unwrap(angle(self.comp))\n        self.phase = rphase*180.0/pi\n        \n        if fig is None:\n            if fignum is not None:\n                import pylab\n                fig = pylab.figure(fignum)\n            \n        if fig is not None:\n            if clear:\n                fig.clf()\n                ax1 = fig.add_subplot(2,1,1)\n                ax2 = fig.add_subplot(2,1,2, sharex=ax1)\n            else:\n                ax1 = fig.axes[0]\n                ax2 = fig.axes[1]\n\n        if fig is not None:\n            myargs=[\'linetype\',\'linewidth\']\n            subkwargs={}\n            for key in myargs:\n                if kwargs.has_key(key):\n                    subkwargs[key]=kwargs[key]\n            #myind=ax1._get_lines.count\n            mylines=_PlotMag(f, self, axis=ax1, **subkwargs)\n            ax1.set_ylabel(\'Mag. Ratio (dB)\')\n            ax1.xaxis.set_major_formatter(MyFormatter())\n            if grid:\n               ax1.grid(1)\n            if legend is not None and legsub==1:\n               ax1.legend(legend, legloc)\n            mylines=_PlotPhase(f, self, axis=ax2, **subkwargs)\n            ax2.set_ylabel(\'Phase (deg.)\')\n            if use_rad:\n               ax2.set_xlabel(\'$\\\\omega$ (rad./sec.)\')\n            else:\n               ax2.set_xlabel(\'Freq. (Hz)\')\n            ax2.xaxis.set_major_formatter(MyFormatter())\n            if grid:\n               ax2.grid(1)\n            if legend is not None and legsub==2:\n               ax2.legend(legend, legloc)\n        return self.comp\n\n\n    def CrossoverFreq(self, f):\n       if not hasattr(self, \'dBmag\'):\n          self.FreqResp(f, fignum=None)\n       t1 = squeeze(self.dBmag > 0.0)\n       t2 = r_[t1[1:],t1[0]]\n       t3 = (t1 & -t2)\n       myinds = where(t3)[0]\n       if not myinds.any():\n          return None, []\n       maxind = max(myinds)\n       return f[maxind], maxind\n\n\n    def PhaseMargin(self,f):\n       fc,ind=self.CrossoverFreq(f)\n       if not fc:\n          return 180.0\n       return 180.0+squeeze(self.phase[ind])\n\n\n    def create_tvect(self, dt=None, maxt=None):\n        if dt is None:\n            dt = self.dt\n        else:\n            self.dt = dt\n        assert dt is not None, ""You must either pass in a dt or call create_tvect on an instance with a self.dt already defined.""\n        if maxt is None:\n            if hasattr(self,\'maxt\'):\n                maxt = self.maxt\n            else:\n                maxt = 100*dt\n        else:\n            self.maxt = maxt\n        tvect = arange(0,maxt+dt/2.0,dt)\n        self.t = tvect\n        return tvect\n\n\n    def create_impulse(self, dt=None, maxt=None, imp_time=0.5):\n        """"""Create the input impulse vector to be used in least squares\n        curve fitting of the c2d function.""""""\n        if dt is None:\n        \tdt = self.dt\n        indon = int(imp_time/dt)\n        tvect = self.create_tvect(dt=dt, maxt=maxt)\n        imp = zeros_like(tvect)\n        imp[indon] = 1.0\n        return imp\n    \n\n    def create_step_input(self, dt=None, maxt=None, indon=5):\n        """"""Create the input impulse vector to be used in least squares\n        curve fitting of the c2d function.""""""\n        tvect = self.create_tvect(dt=dt, maxt=maxt)\n        mystep = zeros_like(tvect)\n        mystep[indon:] = 1.0\n        return mystep\n\n\n    def step_response(self, t=None, dt=None, maxt=None, \\\n                      step_time=None, fignum=1, clear=True, \\\n                      plotu=False, amp=1.0, interp=0, fig=None, \\\n                      fmts=[\'-\',\'-\'], legloc=0, returnall=0, \\\n                      legend=None, **kwargs):\n        """"""Find the response of the system to a step input.  If t is\n        not given, then the time vector will go from 0 to maxt in\n        steps of dt i.e. t=arange(0,maxt,dt).  If dt and maxt are not\n        given, the parameters from the TransferFunction instance will\n        be used.\n\n        step_time is the time when the step input turns on.  If not\n        given, it will default to 0.\n\n        If clear is True, the figure will be cleared first.\n        clear=False could be used to overlay the step responses of\n        multiple TransferFunction\'s.\n\n        plotu=True means that the step input will also be shown on the\n        graph.\n\n        amp is the amplitude of the step input.\n\n        return y unless returnall is set then return y, t, u\n\n        where y is the response of the transfer function, t is the\n        time vector, and u is the step input vector.""""""\n        if t is not None:\n           tvect = t\n        else:\n           tvect = self.create_tvect(dt=dt, maxt=maxt)\n        u = zeros_like(tvect)\n        if dt is None:\n            dt = self.dt\n        if step_time is None:\n            step_time = 0.0\n            #step_time = 0.1*tvect.max()\n        if kwargs.has_key(\'indon\'):\n            indon = kwargs[\'indon\']\n        else:\n            indon = int(step_time/dt)\n        u[indon:] = amp\n        try:\n            ystep = self.lsim(u, tvect, interp=interp)#[1]#the outputs of lsim are (t, y,x)\n        except:\n            ystep = self.lsim2(u, tvect)#[1]\n\n        if fig is None:\n            if fignum is not None:\n                import pylab\n                fig = pylab.figure(fignum)\n            \n        if fig is not None:\n            if clear:\n                fig.clf()\n            ax = fig.add_subplot(111)\n            if plotu:\n                leglist =[\'Input\',\'Output\'] \n                ax.plot(tvect, u, fmts[0], linestyle=\'steps\', **kwargs)#assume step input wants \'steps\' linestyle\n                ofmt = fmts[1]\n            else:\n                ofmt = fmts[0]\n            ax.plot(tvect, ystep, ofmt, **kwargs)\n            ax.set_ylabel(\'Step Response\')\n            ax.set_xlabel(\'Time (sec)\')\n            if legend is not None:\n               ax.legend(legend, loc=legloc)\n            elif plotu:\n                ax.legend(leglist, loc=legloc)\n            #return ystep, ax\n        #else:\n            #return ystep\n        if returnall:\n           return ystep, tvect, u\n        else:\n           return ystep\n\n\n\n    def impulse_response(self, dt=None, maxt=None, fignum=1, \\\n                         clear=True, amp=1.0, fig=None, \\\n                         fmt=\'-\', **kwargs):\n        """"""Find the impulse response of the system using\n        scipy.signal.impulse.\n\n        The time vector will go from 0 to maxt in steps of dt\n        i.e. t=arange(0,maxt,dt).  If dt and maxt are not given, the\n        parameters from the TransferFunction instance will be used.\n\n        If clear is True, the figure will be cleared first.\n        clear=False could be used to overlay the impulse responses of\n        multiple TransferFunction\'s.\n\n        amp is the amplitude of the impulse input.\n\n        return y, t\n\n        where y is the impulse response of the transfer function and t\n        is the time vector.""""""\n\n        tvect = self.create_tvect(dt=dt, maxt=maxt)\n        temptf = amp*self\n        tout, yout = temptf.impulse(T=tvect)\n\n        if fig is None:\n            if fignum is not None:\n                import pylab\n                fig = pylab.figure(fignum)\n            \n        if fig is not None:\n            if clear:\n                fig.clf()\n            ax = fig.add_subplot(111)\n            ax.plot(tvect, yout, fmt, **kwargs)\n            ax.set_ylabel(\'Impulse Response\')\n            ax.set_xlabel(\'Time (sec)\')\n\n        return yout, tout\n\n        \n    def swept_sine_response(self, maxf, minf=0.0, dt=None, maxt=None, deadtime=2.0, interp=0):\n        u = create_swept_sine_input(maxt, dt, maxf, minf=minf, deadtime=deadtime)\n        t = create_swept_sine_t(maxt, dt, deadtime=deadtime)\n        ysweep = self.lsim(u, t, interp=interp)\n        return t, u, ysweep\n\n    \n    def _c2d_sub(self, numsub, densub, scale):\n        """"""This method performs substitutions for continuous to\n        digital conversions using the form:\n\n                    numsub\n        s = scale* --------\n                    densub\n\n        where scale is a floating point number and numsub and densub\n        are poly1d instances.\n\n        For example, scale = 2.0/T, numsub = poly1d([1,-1]), and\n        densub = poly1d([1,1]) for a Tustin c2d transformation.""""""\n        m = self.num.order\n        n = self.den.order\n        mynum = 0.0\n        for p, coeff in enumerate(self.num.coeffs):\n            mynum += poly1d(coeff*(scale**(m-p))*((numsub**(m-p))*(densub**(n-(m-p)))))\n        myden = 0.0\n        for p, coeff in enumerate(self.den.coeffs):\n            myden += poly1d(coeff*(scale**(n-p))*((numsub**(n-p))*(densub**(n-(n-p)))))\n        return mynum.coeffs, myden.coeffs\n\n        \n    def c2d_tustin(self, dt=None, a=2.0):\n        """"""Convert a continuous time transfer function into a digital\n        one by substituting\n        \n            a  z-1\n        s = - -----\n            T  z+1\n\n        into the compensator, where a is typically 2.0""""""\n        #print(\'in TransferFunction.c2d_tustin, dt=%s\' % dt)\n        dt = self._get_set_dt(dt)\n        #print(\'in TransferFunction.c2d_tustin after _get_set_dt, dt=%s\' % dt)\n        scale = a/dt\n        numsub = poly1d([1.0,-1.0])\n        densub = poly1d([1.0,1.0])\n        mynum, myden = self._c2d_sub(numsub, densub, scale)\n        mynum = mynum/myden[0]\n        myden = myden/myden[0]\n        return mynum, myden\n        \n        \n\n    def c2d(self, dt=None, maxt=None, method=\'zoh\', step_time=0.5, a=2.0):\n        """"""Find a numeric approximation of the discrete transfer\n        function of the system.\n\n        The general approach is to find the response of the system\n        using lsim and fit a discrete transfer function to that\n        response as a least squares problem.\n        \n        dt is the time between discrete time intervals (i.e. the\n        sample time).\n\n        maxt is the length of time for which to calculate the system\n        respnose.  An attempt is made to guess an appropriate stopping\n        time if maxt is None.  For now, this defaults to 100*dt,\n        assuming that dt is appropriate for the system poles.\n\n        method is a string describing the c2d conversion algorithm.\n        method = \'zoh refers to a zero-order hold for a sampled-data\n        system and follows the approach outlined by Dorsey in section\n        14.17 of\n        ""Continuous and Discrete Control Systems"" summarized on page\n        472 of the 2002 edition.\n\n        Other supported options for method include \'tustin\'\n\n        indon gives the index of when the step input should switch on\n        for zoh or when the impulse should happen otherwise.  There\n        should probably be enough zero entries before the input occurs\n        to accomidate the order of the discrete transfer function.\n\n        a is used only if method = \'tustin\' and it is substituted in the form\n\n             a  z-1\n         s = - -----\n             T  z+1\n\n        a is almost always equal to 2.\n        """"""\n        if method.lower() == \'zoh\':\n            ystep = self.step_response(dt=dt, maxt=maxt, step_time=step_time)[0]\n            myimp = self.create_impulse(dt=dt, maxt=maxt, imp_time=step_time)\n            #Pdb().set_trace()\n            print(\'You called c2d with ""zoh"".  This is most likely bad.\')\n            nz, dz = fit_discrete_response(ystep, myimp, self.den.order, self.den.order+1)#we want the numerator order to be one less than the denominator order - the denominator order +1 is the order of the denominator during a step response\n            #multiply by (1-z^-1)\n            nz2 = r_[nz, [0.0]]\n            nzs = r_[[0.0],nz]\n            nz3 = nz2 - nzs\n            nzout, dzout = polyfactor(nz3, dz)\n            return nzout, dzout\n            #return nz3, dz\n        elif method.lower() == \'tustin\':\n            #The basic approach for tustin is to create a transfer\n            #function that represents s mapped into z and then\n            #substitute this s(z)=a/T*(z-1)/(z+1) into the continuous\n            #transfer function\n            return self.c2d_tustin(dt=dt, a=a)\n        else:\n            raise ValueError, \'c2d method not understood:\'+str(method)\n\n\n\n    def DigitalSim(self, u, method=\'zoh\', bits=9, vmin=-2.5, vmax=2.5, dt=None, maxt=None, digitize=True):\n        """"""Simulate the digital reponse of the transfer to input u.  u\n        is assumed to be an input signal that has been sampled with\n        frequency 1/dt.  u is further assumed to be a floating point\n        number with precision much higher than bits.  u will be\n        digitized over the range [min, max], which is broken up into\n        2**bits number of bins.\n\n        The A and B vectors from c2d conversion will be found using\n        method, dt, and maxt.  Note that maxt is only used for\n        method=\'zoh\'.\n\n        Once A and B have been found, the digital reponse of the\n        system to the digitized input u will be found.""""""\n        B, A = self.c2d(dt=dt, maxt=maxt, method=method)\n        assert A[0]==1.0, ""A[0]!=1 in c2d result, A=""+str(A)\n        uvect = zeros(len(B), dtype=\'d\')\n        yvect = zeros(len(A)-1, dtype=\'d\')\n        if digitize:\n            udig = ADC(u, bits, vmax=vmax, vmin=vmin)\n            dv = (vmax-vmin)/(2**bits-1)\n        else:\n            udig = u\n            dv = 1.0\n        Ydig = zeros(len(u), dtype=\'d\')\n        for n, u0 in enumerate(udig):\n            uvect = shift(uvect, u0)\n            curY = dot(uvect,B)\n            negpart = dot(yvect,A[1:])\n            curY -= negpart\n            if digitize:\n                curY = int(curY)\n            Ydig[n] = curY\n            yvect = shift(yvect, curY)\n        return Ydig*dv\n\nTF = TransferFunction\n\nclass Input(TransferFunction):\n    def __repr__(self):\n        return TransferFunction.__repr__(self, labelstr=\'controls.Input\')\n\n\nclass Compensator(TransferFunction):\n   def __init__(self, num, den, *args, **kwargs):\n      #print(\'in Compensator.__init__\')\n      #Pdb().set_trace()\n      TransferFunction.__init__(self, num, den, *args, **kwargs)\n      \n      \n   def c2d(self, dt=None, a=2.0):\n      """"""Compensators should use Tustin for c2d conversion.  This\n      method is just and alias for TransferFunction.c2d_tustin""""""\n      #print(\'in Compensators.c2d, dt=%s\' % dt)\n      #Pdb().set_trace()\n      return TransferFunction.c2d_tustin(self, dt=dt, a=a)\n\n   def __repr__(self):\n        return TransferFunction.__repr__(self, labelstr=\'controls.Compensator\')\n\n\n\nclass Digital_Compensator(object):\n   def __init__(self, num, den, input_vect=None, output_vect=None):\n      self.num = num\n      self.den = den\n      self.input = input_vect\n      self.output = output_vect\n      self.Nnum = len(self.num)\n      self.Nden = len(self.den)\n      \n\n   def calc_out(self, i):\n      out = 0.0\n      for n, bn in enumerate(self.num):\n         out += self.input[i-n]*bn\n\n      for n in range(1, self.Nden):\n         out -= self.output[i-n]*self.den[n]\n      out = out/self.den[0]\n      return out\n\n\nclass Digital_PI(object):\n   def __init__(self, kp, ki, input_vect=None, output_vect=None):\n      self.kp = kp\n      self.ki = ki\n      self.input = input_vect\n      self.output = output_vect\n      self.esum = 0.0\n\n\n   def prep(self):\n      self.esum = zeros_like(self.input)\n\n\n   def calc_out(self, i):\n      self.esum[i] = self.esum[i-1]+self.input[i]\n      out = self.input[i]*self.kp+self.esum[i]*self.ki\n      return out\n      \n\nclass Digital_P_Control(Digital_Compensator):\n   def __init__(self, kp, input_vect=None, output_vect=None):\n      self.kp = kp\n      self.input = input_vect\n      self.output = output_vect\n      self.num = poly1d([kp])\n      self.den = poly1d([1])\n      self.gain = 1\n\n   def calc_out(self, i):\n      self.output[i] = self.kp*self.input[i]\n      return self.output[i]\n   \n\ndef dig_comp_from_c_comp(c_comp, dt):\n   """"""Convert a continuous compensator into a digital one using Tustin\n   and sampling time dt.""""""\n   b, a = c_comp.c2d_tustin(dt=dt)\n   return Digital_Compensator(b, a)\n\n\nclass FirstOrderCompensator(Compensator):\n   def __init__(self, K, z, p, dt=0.004):\n      """"""Create a first order compensator whose transfer function is\n\n               K*(s+z)\n      D(s) = -----------\n                (s+p)    """"""\n      Compensator.__init__(self, K*poly1d([1,z]), [1,p])\n      \n\n   def __repr__(self):\n        return TransferFunction.__repr__(self, labelstr=\'controls.FirstOrderCompensator\')\n\n\n   def ToPSoC(self, dt=0.004):\n      b, a = self.c2d(dt=dt)\n      outstr = \'v = %f*e%+f*ep%+f*vp;\'%(b[0],b[1],-a[1])\n      print(\'PSoC str:\')\n      print(outstr)\n      return outstr\n\n\ndef sat(vin, vmax=2.0):\n    if vin > vmax:\n        return vmax\n    elif vin < -1*vmax:\n        return -1*vmax\n    else:\n        return vin\n\nclass ButterworthFilter(Compensator):\n    def __init__(self,fc,mag=1.0):\n        """"""Create a compensator that is a second order Butterworth\n        filter.  fc is the corner frequency in Hz and mag is the low\n        frequency magnitude so that the transfer function will be\n        mag*wn**2/(s**2+2*z*wn*s+wn**2) where z=1/sqrt(2) and\n        wn=2.0*pi*fc.""""""\n        z=1.0/sqrt(2.0)\n        wn=2.0*pi*fc\n        Compensator.__init__(self,mag*wn**2,[1.0,2.0*z*wn,wn**2])\n\nclass Closed_Loop_System_with_Sat(object):\n   def __init__(self, plant_tf, Kp, sat):\n      self.plant_tf = plant_tf\n      self.Kp = Kp\n      self.sat = sat\n\n\n   def lsim(self, u, t, X0=None, include_sat=True, \\\n            returnall=0, lsim2=0, verbosity=0):\n      dt = t[1]-t[0]\n      if X0 is None:\n         X0 = zeros((2,len(self.plant_tf.den.coeffs)-1))\n      N = len(t)\n      y = zeros(N)\n      v = zeros(N)\n      x_n = X0\n      for n in range(1,N):\n          t_n = t[n]\n          if verbosity > 0:\n             print(\'t_n=\'+str(t_n))\n          e = u[n]-y[n-1]\n          v_n = self.Kp*e\n          if include_sat:\n              v_n = sat(v_n, vmax=self.sat)\n          #simulate for one dt using ZOH\n          if lsim2:\n             t_nn, y_n, x_n = self.plant_tf.lsim2([v_n,v_n], [t_n, t_n+dt], X0=x_n[-1], returnall=1)\n          else:\n             t_nn, y_n, x_n = self.plant_tf.lsim([v_n,v_n], [t_n, t_n+dt], X0=x_n[-1], returnall=1)\n             \n          y[n] = y_n[-1]\n          v[n] = v_n\n      self.y = y\n      self.v = v\n      self.u = u\n      if returnall:\n         return y, v\n      else:\n         return y\n\n\n      \n      \n      \ndef step_input():\n    return Input(1,[1,0])\n\n    \ndef feedback(olsys,H=1):\n    """"""Calculate the closed-loop transfer function\n\n                 olsys\n      cltf = --------------\n              1+H*olsys\n\n     where olsys is the transfer function of the open loop\n     system (Gc*Gp) and H is the transfer function in the feedback\n     loop (H=1 for unity feedback).""""""\n    clsys=olsys/(1.0+H*olsys)\n    return clsys\n\n\n\ndef Usweep(ti,maxt,minf=0.0,maxf=10.0):\n    """"""Return the current value (scalar) of a swept sine signal - must be used\n    with list comprehension to generate a vector.\n\n    ti - current time (scalar)\n    minf - lowest frequency in the sweep\n    maxf - highest frequency in the sweep\n    maxt - T or the highest value in the time vector""""""\n    if ti<0.0:\n        return 0.0\n    else:\n        curf=(maxf-minf)*ti/maxt+minf\n        if ti<(maxt*0.95):\n            return sin(2*pi*curf*ti)\n        else:\n            return 0.0\n\n\ndef sweptsine(t,minf=0.0, maxf=10.0):\n    """"""Generate a sweptsine vector by calling Usweep for each ti in t.""""""\n    T=max(t)-min(t)\n    Us = [Usweep(ti,T,minf,maxf) for ti in t]\n    return array(Us)\n\n\nmytypes=[\'-\',\'--\',\':\',\'-.\']\ncolors=[\'b\',\'y\',\'r\',\'g\',\'c\',\'k\']#[\'y\',\'b\',\'r\',\'g\',\'c\',\'k\']\n\ndef _getlinetype(ax=None):\n    if ax is None:\n       import pylab\n       ax = pylab.gca()\n    myind=ax._get_lines.count\n    return {\'color\':colors[myind % len(colors)],\'linestyle\':mytypes[myind % len(mytypes)]}\n\n\ndef create_step_vector(t, step_time=0.0, amp=1.0):\n   u = zeros_like(t)\n   dt = t[1]-t[0]\n   indon = int(step_time/dt)\n   u[indon:] = amp\n   return u\n\n\ndef rate_limiter(uin, du):\n   uout = zeros_like(uin)\n   N = len(uin)\n   for n in range(1,N):\n      curchange = uin[n]-uout[n-1]\n      if curchange > du:\n         uout[n] = uout[n-1]+du\n      elif curchange < -du:\n         uout[n] = uout[n-1]-du\n      else:\n         uout[n] = uin[n]\n   return uout\n\n\n\n   \n'"
External_Libraries/python_control_master/external/yottalab.py,1,"b'""""""\nThis is a procedural interface to the yttalab library\n\nroberto.bucher@supsi.ch\n\nThe following commands are provided:\n\nDesign and plot commands\n  dlqr        - Discrete linear quadratic regulator\n  d2c         - discrete to continous time conversion\n  full_obs    - full order observer\n  red_obs     - reduced order observer\n  comp_form   - state feedback controller+observer in compact form\n  comp_form_i - state feedback controller+observer+integ in compact form\n  set_aw      - introduce anti-windup into controller\n  bb_dcgain   - return the steady state value of the step response\n  placep      - Pole placement (replacement for place)\n  bb_c2d      - Continous to discrete conversion\n\n  Old functions now corrected in python control\n  bb_dare     - Solve Riccati equation for discrete time systems\n  \n""""""\nfrom numpy import hstack, vstack, rank, imag, zeros, eye, mat, \\\n    array, shape, real, sort, around\nfrom scipy import poly \nfrom scipy.linalg import inv, expm, eig, eigvals, logm\nimport scipy as sp\nfrom slycot import sb02od\nfrom matplotlib.pyplot import *\nfrom control import *\nfrom supsictrl import _wrapper\n\ndef d2c(sys,method=\'zoh\'):\n    """"""Continous to discrete conversion with ZOH method\n\n    Call:\n    sysc=c2d(sys,method=\'log\')\n\n    Parameters\n    ----------\n    sys :   System in statespace or Tf form \n    method: \'zoh\' or \'bi\'\n\n    Returns\n    -------\n    sysc: continous system ss or tf\n    \n\n    """"""\n    flag = 0\n    if isinstance(sys, TransferFunction):\n        sys=tf2ss(sys)\n        flag=1\n\n    a=sys.A\n    b=sys.B\n    c=sys.C\n    d=sys.D\n    Ts=sys.dt\n    n=shape(a)[0]\n    nb=shape(b)[1]\n    nc=shape(c)[0]\n    tol=1e-12\n    \n    if method==\'zoh\':\n        if n==1:\n            if b[0,0]==1:\n                A=0\n                B=b/sys.dt\n                C=c\n                D=d\n        else:\n            tmp1=hstack((a,b))\n            tmp2=hstack((zeros((nb,n)),eye(nb)))\n            tmp=vstack((tmp1,tmp2))\n            s=logm(tmp)\n            s=s/Ts\n            if norm(imag(s),inf) > sqrt(sp.finfo(float).eps):\n                print ""Warning: accuracy may be poor""\n            s=real(s)\n            A=s[0:n,0:n]\n            B=s[0:n,n:n+nb]\n            C=c\n            D=d\n    elif method==\'foh\':\n        a=mat(a)\n        b=mat(b)\n        c=mat(c)\n        d=mat(d)\n        Id = mat(eye(n))\n        A = logm(a)/Ts\n        A = real(around(A,12))\n        Amat = mat(A)\n        B = (a-Id)**(-2)*Amat**2*b*Ts\n        B = real(around(B,12))\n        Bmat = mat(B)\n        C = c\n        D = d - C*(Amat**(-2)/Ts*(a-Id)-Amat**(-1))*Bmat\n        D = real(around(D,12))\n    elif method==\'bi\':\n        a=mat(a)\n        b=mat(b)\n        c=mat(c)\n        d=mat(d)\n        poles=eigvals(a)\n        if any(abs(poles-1)<200*sp.finfo(float).eps):\n            print ""d2c: some poles very close to one. May get bad results.""\n        \n        I=mat(eye(n,n))\n        tk = 2 / sqrt (Ts)\n        A = (2/Ts)*(a-I)*inv(a+I)\n        iab = inv(I+a)*b\n        B = tk*iab\n        C = tk*(c*inv(I+a))\n        D = d- (c*iab)\n    else:\n        print ""Method not supported""\n        return\n    \n    sysc=StateSpace(A,B,C,D)\n    if flag==1:\n        sysc=ss2tf(sysc)\n    return sysc\n\ndef dlqr(*args, **keywords):\n    """"""Linear quadratic regulator design for discrete systems\n\n    Usage\n    =====\n    [K, S, E] = dlqr(A, B, Q, R, [N])\n    [K, S, E] = dlqr(sys, Q, R, [N])\n\n    The dlqr() function computes the optimal state feedback controller\n    that minimizes the quadratic cost\n\n        J = \\sum_0^\\infty x\' Q x + u\' R u + 2 x\' N u\n\n    Inputs\n    ------\n    A, B: 2-d arrays with dynamics and input matrices\n    sys: linear I/O system \n    Q, R: 2-d array with state and input weight matrices\n    N: optional 2-d array with cross weight matrix\n\n    Outputs\n    -------\n    K: 2-d array with state feedback gains\n    S: 2-d array with solution to Riccati equation\n    E: 1-d array with eigenvalues of the closed loop system\n    """"""\n\n    # \n    # Process the arguments and figure out what inputs we received\n    #\n    \n    # Get the system description\n    if (len(args) < 3):\n        raise ControlArgument(""not enough input arguments"")\n\n    elif (ctrlutil.issys(args[0])):\n        # We were passed a system as the first argument; extract A and B\n        A = array(args[0].A, ndmin=2, dtype=float);\n        B = array(args[0].B, ndmin=2, dtype=float);\n        index = 1;\n        if args[0].dt==0.0:\n            print ""dlqr works only for discrete systems!""\n            return\n    else:\n        # Arguments should be A and B matrices\n        A = array(args[0], ndmin=2, dtype=float);\n        B = array(args[1], ndmin=2, dtype=float);\n        index = 2;\n\n    # Get the weighting matrices (converting to matrices, if needed)\n    Q = array(args[index], ndmin=2, dtype=float);\n    R = array(args[index+1], ndmin=2, dtype=float);\n    if (len(args) > index + 2): \n        N = array(args[index+2], ndmin=2, dtype=float);\n        Nflag = 1;\n    else:\n        N = zeros((Q.shape[0], R.shape[1]));\n        Nflag = 0;\n\n    # Check dimensions for consistency\n    nstates = B.shape[0];\n    ninputs = B.shape[1];\n    if (A.shape[0] != nstates or A.shape[1] != nstates):\n        raise ControlDimension(""inconsistent system dimensions"")\n\n    elif (Q.shape[0] != nstates or Q.shape[1] != nstates or\n          R.shape[0] != ninputs or R.shape[1] != ninputs or\n          N.shape[0] != nstates or N.shape[1] != ninputs):\n        raise ControlDimension(""incorrect weighting matrix dimensions"")\n\n    if Nflag==1:\n        Ao=A-B*inv(R)*N.T\n        Qo=Q-N*inv(R)*N.T\n    else:\n        Ao=A\n        Qo=Q\n    \n    #Solve the riccati equation\n    (X,L,G) = dare(Ao,B,Qo,R)\n#    X = bb_dare(Ao,B,Qo,R)\n\n    # Now compute the return value\n    Phi=mat(A)\n    H=mat(B)\n    K=inv(H.T*X*H+R)*(H.T*X*Phi+N.T)\n    L=eig(Phi-H*K)\n    return K,X,L\n\ndef full_obs(sys,poles):\n    """"""Full order observer of the system sys\n\n    Call:\n    obs=full_obs(sys,poles)\n\n    Parameters\n    ----------\n    sys : System in State Space form\n    poles: desired observer poles\n\n    Returns\n    -------\n    obs: ss\n    Observer\n\n    """"""\n    if isinstance(sys, TransferFunction):\n        ""System must be in state space form""\n        return\n    a=mat(sys.A)\n    b=mat(sys.B)\n    c=mat(sys.C)\n    d=mat(sys.D)\n    L=placep(a.T,c.T,poles)\n    L=mat(L).T\n    Ao=a-L*c\n    Bo=hstack((b-L*d,L))\n    n=shape(Ao)\n    m=shape(Bo)\n    Co=eye(n[0],n[1])\n    Do=zeros((n[0],m[1]))\n    obs=StateSpace(Ao,Bo,Co,Do,sys.dt)\n    return obs\n\ndef red_obs(sys,T,poles):\n    """"""Reduced order observer of the system sys\n\n    Call:\n    obs=red_obs(sys,T,poles)\n\n    Parameters\n    ----------\n    sys : System in State Space form\n    T: Complement matrix\n    poles: desired observer poles\n\n    Returns\n    -------\n    obs: ss\n    Reduced order Observer\n\n    """"""\n    if isinstance(sys, TransferFunction):\n        ""System must be in state space form""\n        return\n    a=mat(sys.A)\n    b=mat(sys.B)\n    c=mat(sys.C)\n    d=mat(sys.D)\n    T=mat(T)\n    P=mat(vstack((c,T)))\n    invP=inv(P)\n    AA=P*a*invP\n    ny=shape(c)[0]\n    nx=shape(a)[0]\n    nu=shape(b)[1]\n\n    A11=AA[0:ny,0:ny]\n    A12=AA[0:ny,ny:nx]\n    A21=AA[ny:nx,0:ny]\n    A22=AA[ny:nx,ny:nx]\n\n    L1=placep(A22.T,A12.T,poles)\n    L1=mat(L1).T\n\n    nn=nx-ny\n\n    tmp1=mat(hstack((-L1,eye(nn,nn))))\n    tmp2=mat(vstack((zeros((ny,nn)),eye(nn,nn))))\n    Ar=tmp1*P*a*invP*tmp2\n \n    tmp3=vstack((eye(ny,ny),L1))\n    tmp3=mat(hstack((P*b,P*a*invP*tmp3)))\n    tmp4=hstack((eye(nu,nu),zeros((nu,ny))))\n    tmp5=hstack((-d,eye(ny,ny)))\n    tmp4=mat(vstack((tmp4,tmp5)))\n\n    Br=tmp1*tmp3*tmp4\n\n    Cr=invP*tmp2\n\n    tmp5=hstack((zeros((ny,nu)),eye(ny,ny)))\n    tmp6=hstack((zeros((nn,nu)),L1))\n    tmp5=mat(vstack((tmp5,tmp6)))\n    Dr=invP*tmp5*tmp4\n    \n    obs=StateSpace(Ar,Br,Cr,Dr,sys.dt)\n    return obs\n\ndef comp_form(sys,obs,K):\n    """"""Compact form Conroller+Observer\n\n    Call:\n    contr=comp_form(sys,obs,K)\n\n    Parameters\n    ----------\n    sys : System in State Space form\n    obs : Observer in State Space form\n    K: State feedback gains\n\n    Returns\n    -------\n    contr: ss\n    Controller\n\n    """"""\n    nx=shape(sys.A)[0]\n    ny=shape(sys.C)[0]\n    nu=shape(sys.B)[1]\n    no=shape(obs.A)[0]\n\n    Bu=mat(obs.B[:,0:nu])\n    By=mat(obs.B[:,nu:])\n    Du=mat(obs.D[:,0:nu])\n    Dy=mat(obs.D[:,nu:])\n\n    X=inv(eye(nu,nu)+K*Du)\n\n    Ac = mat(obs.A)-Bu*X*K*mat(obs.C);\n    Bc = hstack((Bu*X,By-Bu*X*K*Dy))\n    Cc = -X*K*mat(obs.C);\n    Dc = hstack((X,-X*K*Dy))\n    contr = StateSpace(Ac,Bc,Cc,Dc,sys.dt)\n    return contr\n\ndef comp_form_i(sys,obs,K,Ts,Cy=[[1]]):\n    """"""Compact form Conroller+Observer+Integral part\n    Only for discrete systems!!!\n\n    Call:\n    contr=comp_form_i(sys,obs,K,Ts[,Cy])\n\n    Parameters\n    ----------\n    sys : System in State Space form\n    obs : Observer in State Space form\n    K: State feedback gains\n    Ts: Sampling time\n    Cy: feedback matric to choose the output for integral part\n\n    Returns\n    -------\n    contr: ss\n    Controller\n\n    """"""\n    if sys.dt==0.0:\n        print ""contr_form_i works only with discrete systems!""\n        return\n\n    ny=shape(sys.C)[0]\n    nu=shape(sys.B)[1]\n    nx=shape(sys.A)[0]\n    no=shape(obs.A)[0]\n    ni=shape(mat(Cy))[0]\n\n    B_obsu = mat(obs.B[:,0:nu])\n    B_obsy = mat(obs.B[:,nu:nu+ny])\n    D_obsu = mat(obs.D[:,0:nu])\n    D_obsy = mat(obs.D[:,nu:nu+ny])\n\n    k=mat(K)\n    nk=shape(k)[1]\n    Ke=k[:,nk-ni:]\n    K=k[:,0:nk-ni]\n    X = inv(eye(nu,nu)+K*D_obsu);\n\n    a=mat(obs.A)\n    c=mat(obs.C)\n    Cy=mat(Cy)\n\n    tmp1=hstack((a-B_obsu*X*K*c,-B_obsu*X*Ke))\n\n    tmp2=hstack((zeros((ni,no)),eye(ni,ni)))\n    A_ctr=vstack((tmp1,tmp2))\n\n    tmp1=hstack((zeros((no,ni)),-B_obsu*X*K*D_obsy+B_obsy))\n    tmp2=hstack((eye(ni,ni)*Ts,-Cy*Ts))\n    B_ctr=vstack((tmp1,tmp2))\n\n    C_ctr=hstack((-X*K*c,-X*Ke))\n    D_ctr=hstack((zeros((nu,ni)),-X*K*D_obsy))\n\n    contr=StateSpace(A_ctr,B_ctr,C_ctr,D_ctr,sys.dt)\n    return contr\n    \ndef sysctr(sys,contr):\n    """"""Build the discrete system controller+plant+output feedback\n\n    Call:\n    syscontr=sysctr(sys,contr)\n\n    Parameters\n    ----------\n    sys : Continous System in State Space form\n    contr: Controller (with observer if required)\n \n    Returns\n    -------\n    sysc: ss system\n    The system with reference as input and outputs of plants \n    as output\n\n    """"""\n    if contr.dt!=sys.dt:\n        print ""Systems with different sampling time!!!""\n        return\n    sysf=sys*contr\n\n    nu=shape(sysf.B)[1]\n    b1=mat(sysf.B[:,0])\n    b2=mat(sysf.B[:,1:nu])\n    d1=mat(sysf.D[:,0])\n    d2=mat(sysf.D[:,1:nu])\n\n    n2=shape(d2)[0]\n\n    Id=mat(eye(n2,n2))\n    X=inv(Id-d2)\n\n    Af=mat(sysf.A)+b2*X*mat(sysf.C)\n    Bf=b1+b2*X*d1\n    Cf=X*mat(sysf.C)\n    Df=X*d1\n\n    sysc=StateSpace(Af,Bf,Cf,Df,sys.dt)\n    return sysc\n\ndef set_aw(sys,poles):\n    """"""Divide in controller in input and feedback part\n       for anti-windup\n\n    Usage\n    =====\n    [sys_in,sys_fbk]=set_aw(sys,poles)\n\n    Inputs\n    ------\n\n    sys: controller\n    poles : poles for the anti-windup filter\n\n    Outputs\n    -------\n    sys_in, sys_fbk: controller in input and feedback part\n    """"""\n    sys = ss(sys)\n    den_old=poly(eigvals(sys.A))\n    sys=tf(sys)\n    den = poly(poles)\n    tmp= tf(den_old,den,sys.dt)\n    sys_in=tmp*sys\n    sys_in = sys_in.minreal()\n    sys_in = ss(sys_in)\n    sys_fbk=1-tmp\n    sys_fbk = sys_fbk.minreal()\n    sys_fbk = ss(sys_fbk)\n    return sys_in, sys_fbk\n\ndef placep(A,B,P):\n    """"""Return the steady state value of the step response os sysmatrix K for\n    pole placement\n\n    Usage\n    =====\n    K = placep(A,B,P)\n\n    Inputs\n    ------\n\n    A  : State matrix A\n    B  : INput matrix\n    P  : desired poles\n\n    Outputs\n    -------\n    K : State gains for pole placement\n    """"""\n    \n    n = shape(A)[0]\n    m = shape(B)[1]\n    tol = 0.0\n    mode = 1;\n\n    wrka = zeros((n,m))\n    wrk1 = zeros(m)\n    wrk2 = zeros(m)\n    iwrk = zeros((m),np.int)\n\n    A,B,ncont,indcont,nblk,z = _wrapper.ssxmc(n,m,A,n,B,wrka,wrk1,wrk2,iwrk,tol,mode)\n    P = sort(P)\n    wr = real(P)\n    wi = imag(P)\n\n    g = zeros((m,n))\n\n    mx = max(2,m)\n    rm1 = zeros((m,m))\n    rm2 = zeros((m,mx))\n    rv1 = zeros(n)\n    rv2 = zeros(n)\n    rv3 = zeros(m)\n    rv4 = zeros(m)\n\n    A,B,g,z,ierr,jpvt = _wrapper.polmc(A,B,g,wr,wi,z,indcont,nblk,rm1, rm2, rv1, rv2, rv3, rv4)\n\n    return g\n\n""""""\nThese functions are now implemented in python control and should not be used anymore\n""""""\n\ndef bb_dare(A,B,Q,R):\n    """"""Solve Riccati equation for discrete time systems\n\n    Usage\n    =====\n    [K, S, E] = bb_dare(A, B, Q, R)\n\n    Inputs\n    ------\n    A, B: 2-d arrays with dynamics and input matrices\n    sys: linear I/O system \n    Q, R: 2-d array with state and input weight matrices\n\n    Outputs\n    -------\n    X: solution of the Riccati eq.\n    """"""\n\n    # Check dimensions for consistency\n    nstates = B.shape[0];\n    ninputs = B.shape[1];\n    if (A.shape[0] != nstates or A.shape[1] != nstates):\n        raise ControlDimension(""inconsistent system dimensions"")\n\n    elif (Q.shape[0] != nstates or Q.shape[1] != nstates or\n          R.shape[0] != ninputs or R.shape[1] != ninputs) :\n        raise ControlDimension(""incorrect weighting matrix dimensions"")\n\n    X,rcond,w,S,T = \\\n        sb02od(nstates, ninputs, A, B, Q, R, \'D\');\n\n    return X\n\n\n\ndef bb_dcgain(sys):\n    """"""Return the steady state value of the step response os sys\n\n    Usage\n    =====\n    dcgain=dcgain(sys)\n\n    Inputs\n    ------\n\n    sys: system\n\n    Outputs\n    -------\n    dcgain : steady state value\n    """"""\n\n    a=mat(sys.A)\n    b=mat(sys.B)\n    c=mat(sys.C)\n    d=mat(sys.D)\n    nx=shape(a)[0]\n    if sys.dt!=0.0:\n        a=a-eye(nx,nx)\n    r=rank(a)\n    if r<nx:\n        gm=[]\n    else:\n        gm=-c*inv(a)*b+d\n    return array(gm)\n\ndef bb_c2d(sys,Ts,method=\'zoh\'):\n    """"""Continous to discrete conversion with ZOH method\n\n    Call:\n    sysd=c2d(sys,Ts,method=\'zoh\')\n\n    Parameters\n    ----------\n    sys :   System in statespace or Tf form \n    Ts:     Sampling Time\n    method: \'zoh\', \'bi\' or \'matched\'\n\n    Returns\n    -------\n    sysd: ss or Tf system\n    Discrete system\n\n    """"""\n    flag = 0\n    if isinstance(sys, TransferFunction):\n        sys=tf2ss(sys)\n        flag=1\n\n    a=sys.A\n    b=sys.B\n    c=sys.C\n    d=sys.D\n    n=shape(a)[0]\n    nb=shape(b)[1]\n    nc=shape(c)[0]\n\n    if method==\'zoh\':\n        ztmp=zeros((nb,n+nb))\n        tmp=hstack((a,b))\n        tmp=vstack((tmp,ztmp))\n        tmp=expm(tmp*Ts)\n        A=tmp[0:n,0:n]\n        B=tmp[0:n,n:n+nb]\n        C=c\n        D=d\n    elif method==\'foh\':\n        a=mat(a)\n        b=mat(b)\n        c=mat(c)\n        d=mat(d)\n        Id = mat(eye(n))\n        A = expm(a*Ts)\n        B = a**(-2)/Ts*(expm(a*Ts)-Id)**2*b\n        C = c\n        D = d + c*(a**(-2)/Ts*(expm(a*Ts)-Id)-a**(-1))*b        \n    elif method==\'bi\':\n        a=mat(a)\n        b=mat(b)\n        c=mat(c)\n        d=mat(d)\n        IT=mat(2/Ts*eye(n,n))\n        A=(IT+a)*inv(IT-a)\n        iab=inv(IT-a)*b\n        tk=2/sqrt(Ts)\n        B=tk*iab\n        C=tk*(c*inv(IT-a))\n        D=d+c*iab\n    elif method==\'matched\':\n        if nb!=1 and nc!=1:\n            print ""System is not SISO""\n            return\n        p=exp(sys.poles*Ts)\n        z=exp(sys.zeros*Ts)\n        infinite_zeros = len(sys.poles) - len(sys.zeros) - 1\n        for i in range(0,infinite_zeros):\n            z=hstack((z,-1))\n        [A,B,C,D]=zpk2ss(z,p,1)\n        sysd=StateSpace(A,B,C,D,Ts)\n        cg = dcgain(sys)\n        dg = dcgain(sysd)\n        [A,B,C,D]=zpk2ss(z,p,cg/dg)\n    else:\n        print ""Method not supported""\n        return\n    \n    sysd=StateSpace(A,B,C,D,Ts)\n    if flag==1:\n        sysd=ss2tf(sysd)\n    return sysd\n\n\n'"
External_Libraries/python_control_master/control/bench/time_freqresp.py,0,"b'from control import tf\nfrom control.matlab import rss\nfrom numpy import logspace\nfrom timeit import timeit\n\nnstates = 10\nsys = rss(nstates)\nsys_tf = tf(sys)\nw = logspace(-1,1,50)\nntimes = 1000\ntime_ss = timeit(""sys.freqresp(w)"", setup=""from __main__ import sys, w"", number=ntimes)\ntime_tf = timeit(""sys_tf.freqresp(w)"", setup=""from __main__ import sys_tf, w"", number=ntimes)\nprint(""State-space model on %d states: %f"" % (nstates, time_ss))\nprint(""Transfer-function model on %d states: %f"" % (nstates, time_tf))\n'"
External_Libraries/python_control_master/control/flatsys/__init__.py,0,"b'# flatsys/__init__.py: flat systems package initialization file\n#\n# Copyright (c) 2019 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n#\n# Author: Richard M. Murray\n# Date: 1 Jul 2019\n\nr""""""The :mod:`control.flatsys` package contains a set of classes and functions\nthat can be used to compute trajectories for differentially flat systems.\n\nA differentially flat system is defined by creating an object using the\n:class:`~control.flatsys.FlatSystem` class, which has member functions for\nmapping the system state and input into and out of flat coordinates.  The\n:func:`~control.flatsys.point_to_point` function can be used to create a\ntrajectory between two endpoints, written in terms of a set of basis functions\ndefined using the :class:`~control.flatsys.BasisFamily` class.  The resulting\ntrajectory is return as a :class:`~control.flatsys.SystemTrajectory` object\nand can be evaluated using the :func:`~control.flatsys.SystemTrajectory.eval`\nmember function.\n\n""""""\n\n# Basis function families\nfrom .basis import BasisFamily\nfrom .poly import PolyFamily\n\n# Classes\nfrom .systraj import SystemTrajectory\nfrom .flatsys import FlatSystem\nfrom .linflat import LinearFlatSystem\n\n# Package functions\nfrom .flatsys import point_to_point\n'"
External_Libraries/python_control_master/control/flatsys/basis.py,0,"b'# basis.py - BasisFamily class\n# RMM, 10 Nov 2012\n#\n# The BasisFamily class is used to specify a set of basis functions for\n# implementing differential flatness computations.\n#\n# Copyright (c) 2012 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\n\n# Basis family class (for use as a base class)\nclass BasisFamily:\n    """"""Base class for implementing basis functions for flat systems.\n\n    A BasisFamily object is used to construct trajectories for a flat system.\n    The class must implement a single function that computes the jth\n    derivative of the ith basis function at a time t:\n\n      :math:`z_i^{(q)}(t)` = basis.eval_deriv(self, i, j, t)\n\n    """"""\n    def __init__(self, N):\n        """"""Create a basis family of order N.""""""\n        self.N = N                    # save number of basis functions\n'"
External_Libraries/python_control_master/control/flatsys/flatsys.py,9,"b'# flatsys.py - trajectory generation for differentially flat systems\n# RMM, 10 Nov 2012\n#\n# This file contains routines for computing trajectories for differentially\n# flat nonlinear systems.  It is (very) loosely based on the NTG software\n# package developed by Mark Milam and Kudah Mushambi, but rewritten from\n# scratch in python.\n#\n# Copyright (c) 2012 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\nimport numpy as np\nfrom .poly import PolyFamily\nfrom .systraj import SystemTrajectory\nfrom ..iosys import NonlinearIOSystem\n\n\n# Flat system class (for use as a base class)\nclass FlatSystem(NonlinearIOSystem):\n    """"""Base class for representing a differentially flat system.\n\n    The FlatSystem class is used as a base class to describe differentially\n    flat systems for trajectory generation.  The class must implement two\n    functions:\n\n    zflag = flatsys.foward(x, u)\n        This function computes the flag (derivatives) of the flat output.\n        The inputs to this function are the state \'x\' and inputs \'u\' (both\n        1D arrays).  The output should be a 2D array with the first\n        dimension equal to the number of system inputs and the second\n        dimension of the length required to represent the full system\n        dynamics (typically the number of states)\n\n    x, u = flatsys.reverse(zflag)\n        This function system state and inputs give the the flag (derivatives)\n        of the flat output.  The input to this function is an 2D array whose\n        first dimension is equal to the number of system inputs and whose\n        second dimension is of length required to represent the full system\n        dynamics (typically the number of states).  The output is the state\n        `x` and inputs `u` (both 1D arrays).\n\n    A flat system is also an input/output system supporting simulation,\n    composition, and linearization.  If the update and output methods are\n    given, they are used in place of the flat coordinates.\n\n    """"""\n    def __init__(self,\n                 forward, reverse,              # flat system\n                 updfcn=None, outfcn=None,      # I/O system\n                 inputs=None, outputs=None,\n                 states=None, params={}, dt=None, name=None):\n        """"""Create a differentially flat input/output system.\n\n        The FlatIOSystem constructor is used to create an input/output system\n        object that also represents a differentially flat system.  The output\n        of the system does not need to be the differentially flat output.\n\n        Parameters\n        ----------\n        forward : callable\n            A function to compute the flat flag given the states and input.\n        reverse : callable\n            A function to compute the states and input given the flat flag.\n        updfcn : callable, optional\n            Function returning the state update function\n\n                `updfcn(t, x, u[, param]) -> array`\n\n            where `x` is a 1-D array with shape (nstates,), `u` is a 1-D array\n            with shape (ninputs,), `t` is a float representing the currrent\n            time, and `param` is an optional dict containing the values of\n            parameters used by the function.  If not specified, the state\n            space update will be computed using the flat system coordinates.\n        outfcn : callable\n            Function returning the output at the given state\n\n                `outfcn(t, x, u[, param]) -> array`\n\n            where the arguments are the same as for `upfcn`.  If not\n            specified, the output will be the flat outputs.\n        inputs : int, list of str, or None\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If\n            this parameter is not given or given as `None`, the relevant\n            quantity will be determined when possible based on other\n            information provided to functions using the system.\n        outputs : int, list of str, or None\n            Description of the system outputs.  Same format as `inputs`.\n        states : int, list of str, or None\n            Description of the system states.  Same format as `inputs`.\n        dt : None, True or float, optional\n            System timebase.  None (default) indicates continuous\n            time, True indicates discrete time with undefined sampling\n            time, positive number is discrete time with specified\n            sampling time.\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n        name : string, optional\n            System name (used for specifying signals)\n\n        Returns\n        -------\n        InputOutputSystem\n            Input/output system object\n\n        """"""\n        # TODO: specify default update and output functions\n        if updfcn is None: updfcn = self._flat_updfcn\n        if outfcn is None: outfcn = self._flat_outfcn\n\n        # Initialize as an input/output system\n        NonlinearIOSystem.__init__(\n            self, updfcn, outfcn, inputs=inputs, outputs=outputs,\n            states=states, params=params, dt=dt, name=name)\n\n        # Save the functions to compute forward and reverse conversions\n        if forward is not None: self.forward = forward\n        if reverse is not None: self.reverse = reverse\n\n    def forward(self, x, u, params={}):\n        """"""Compute the flat flag given the states and input.\n\n        Given the states and inputs for a system, compute the flat\n        outputs and their derivatives (the flat ""flag"") for the\n        system.\n\n        Parameters\n        ----------\n        x : list or array\n            The state of the  system.\n        u : list or array\n            The input to the  system.\n        params : dict, optional\n            Parameter values for the system.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n\n        Returns\n        -------\n        zflag : list of 1D arrays\n            For each flat output :math:`z_i`, zflag[i] should be an\n            ndarray of length :math:`q_i` that contains the flat\n            output and its first :math:`q_i` derivatives.\n\n        """"""\n        pass\n\n    def reverse(self, zflag, params={}):\n        """"""Compute the states and input given the flat flag.\n\n        Parameters\n        ----------\n        zflag : list of arrays\n            For each flat output :math:`z_i`, zflag[i] should be an\n            ndarray of length :math:`q_i` that contains the flat\n            output and its first :math:`q_i` derivatives.\n        params : dict, optional\n            Parameter values for the system.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n\n        Returns\n        -------\n        x : 1D array\n            The state of the system corresponding to the flat flag.\n        u : 1D array\n            The input to the system corresponding to the flat flag.\n\n        """"""\n        pass\n\n    def _flat_updfcn(self, t, x, u, params={}):\n        # TODO: implement state space update using flat coordinates\n        raise NotImplementedError(""update function for flat system not given"")\n\n    def _flat_outfcn(self, t, x, u, params={}):\n        # Return the flat output\n        zflag = self.forward(x, u, params)\n        return np.array(zflag[:][0])\n\n\n# Solve a point to point trajectory generation problem for a linear system\ndef point_to_point(sys, x0, u0, xf, uf, Tf, T0=0, basis=None, cost=None):\n    """"""Compute trajectory between an initial and final conditions.\n\n    Compute a feasible trajectory for a differentially flat system between an\n    initial condition and a final condition.\n\n    Parameters\n    ----------\n    flatsys : FlatSystem object\n        Description of the differentially flat system.  This object must\n        define a function flatsys.forward() that takes the system state and\n        produceds the flag of flat outputs and a system flatsys.reverse()\n        that takes the flag of the flat output and prodes the state and\n        input.\n\n    x0, u0, xf, uf : 1D arrays\n        Define the desired initial and final conditions for the system.  If\n        any of the values are given as None, they are replaced by a vector of\n        zeros of the appropriate dimension.\n\n    Tf : float\n        The final time for the trajectory (corresponding to xf)\n\n    T0 : float (optional)\n        The initial time for the trajectory (corresponding to x0).  If not\n        specified, its value is taken to be zero.\n\n    basis : BasisFamily object (optional)\n        The basis functions to use for generating the trajectory.  If not\n        specified, the PolyFamily basis family will be used, with the minimal\n        number of elements required to find a feasible trajectory (twice\n        the number of system states)\n\n    Returns\n    -------\n    traj : SystemTrajectory object\n        The system trajectory is returned as an object that implements the\n        eval() function, we can be used to compute the value of the state\n        and input and a given time t.\n\n    """"""\n    #\n    # Make sure the problem is one that we can handle\n    #\n    # TODO: put in tests for flat system input\n    # TODO: process initial and final conditions to allow x0 or (x0, u0)\n    if x0 is None: x0 = np.zeros(sys.nstates)\n    if u0 is None: u0 = np.zeros(sys.ninputs)\n    if xf is None: xf = np.zeros(sys.nstates)\n    if uf is None: uf = np.zeros(sys.ninputs)\n\n    #\n    # Determine the basis function set to use and make sure it is big enough\n    #\n\n    # If no basis set was specified, use a polynomial basis (poor choice...)\n    if (basis is None): basis = PolyFamily(2*sys.nstates, Tf)\n\n    # Make sure we have enough basis functions to solve the problem\n    if (basis.N * sys.ninputs < 2 * (sys.nstates + sys.ninputs)):\n        raise ValueError(""basis set is too small"")\n\n    #\n    # Map the initial and final conditions to flat output conditions\n    #\n    # We need to compute the output ""flag"": [z(t), z\'(t), z\'\'(t), ...]\n    # and then evaluate this at the initial and final condition.\n    #\n    # TODO: should be able to represent flag variables as 1D arrays\n    # TODO: need inputs to fully define the flag\n    zflag_T0 = sys.forward(x0, u0)\n    zflag_Tf = sys.forward(xf, uf)\n\n    #\n    # Compute the matrix constraints for initial and final conditions\n    #\n    # This computation depends on the basis function we are using.  It\n    # essentially amounts to evaluating the basis functions and their\n    # derivatives at the initial and final conditions.\n\n    # Figure out the size of the problem we are solving\n    flag_tot = np.sum([len(zflag_T0[i]) for i in range(sys.ninputs)])\n\n    # Start by creating an empty matrix that we can fill up\n    # TODO: allow a different number of basis elements for each flat output\n    M = np.zeros((2 * flag_tot, basis.N * sys.ninputs))\n\n    # Now fill in the rows for the initial and final states\n    flag_off = 0\n    coeff_off = 0\n    for i in range(sys.ninputs):\n        flag_len = len(zflag_T0[i])\n        for j in range(basis.N):\n            for k in range(flag_len):\n                M[flag_off + k, coeff_off + j] = basis.eval_deriv(j, k, T0)\n                M[flag_tot + flag_off + k, coeff_off + j] = \\\n                    basis.eval_deriv(j, k, Tf)\n        flag_off += flag_len\n        coeff_off += basis.N\n\n    # Create an empty matrix that we can fill up\n    Z = np.zeros(2 * flag_tot)\n\n    # Compute the flag vector to use for the right hand side by\n    # stacking up the flags for each input\n    # TODO: make this more pythonic\n    flag_off = 0\n    for i in range(sys.ninputs):\n        flag_len = len(zflag_T0[i])\n        for j in range(flag_len):\n            Z[flag_off + j] = zflag_T0[i][j]\n            Z[flag_tot + flag_off + j] = zflag_Tf[i][j]\n        flag_off += flag_len\n\n    #\n    # Solve for the coefficients of the flat outputs\n    #\n    # At this point, we need to solve the equation M alpha = zflag, where M\n    # is the matrix constrains for initial and final conditions and zflag =\n    # [zflag_T0; zflag_tf].  Since everything is linear, just compute the\n    # least squares solution for now.\n    #\n    # TODO: need to allow cost and constraints...\n    alpha, residuals, rank, s = np.linalg.lstsq(M, Z, rcond=None)\n\n    #\n    # Transform the trajectory from flat outputs to states and inputs\n    #\n    systraj = SystemTrajectory(sys, basis)\n\n    # Store the flag lengths and coefficients\n    # TODO: make this more pythonic\n    coeff_off = 0\n    for i in range(sys.ninputs):\n        # Grab the coefficients corresponding to this flat output\n        systraj.coeffs.append(alpha[coeff_off:coeff_off + basis.N])\n        coeff_off += basis.N\n\n        # Keep track of the length of the flat flag for this output\n        systraj.flaglen.append(len(zflag_T0[i]))\n\n    # Return a function that computes inputs and states as a function of time\n    return systraj\n'"
External_Libraries/python_control_master/control/flatsys/linflat.py,12,"b'# linflat.py - FlatSystem subclass for linear systems\n# RMM, 10 November 2012\n#\n# This file defines a FlatSystem class for a linear system.\n#\n# Copyright (c) 2012 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#\n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n#\n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\nimport numpy as np\nimport control\nfrom .flatsys import FlatSystem\nfrom ..iosys import LinearIOSystem\n\n\nclass LinearFlatSystem(FlatSystem, LinearIOSystem):\n    def __init__(self, linsys, inputs=None, outputs=None, states=None,\n                 name=None):\n        """"""Define a flat system from a SISO LTI system.\n\n        Given a reachable, single-input/single-output, linear time-invariant\n        system, create a differentially flat system representation.\n\n        Parameters\n        ----------\n        linsys : StateSpace\n            LTI StateSpace system to be converted\n        inputs : int, list of str or None, optional\n            Description of the system inputs.  This can be given as an integer\n            count or as a list of strings that name the individual signals.\n            If an integer count is specified, the names of the signal will be\n            of the form `s[i]` (where `s` is one of `u`, `y`, or `x`).  If\n            this parameter is not given or given as `None`, the relevant\n            quantity will be determined when possible based on other\n            information provided to functions using the system.\n        outputs : int, list of str or None, optional\n            Description of the system outputs.  Same format as `inputs`.\n        states : int, list of str, or None, optional\n            Description of the system states.  Same format as `inputs`.\n        dt : None, True or float, optional\n            System timebase.  None (default) indicates continuous\n            time, True indicates discrete time with undefined sampling\n            time, positive number is discrete time with specified\n            sampling time.\n        params : dict, optional\n            Parameter values for the systems.  Passed to the evaluation\n            functions for the system as default values, overriding internal\n            defaults.\n        name : string, optional\n            System name (used for specifying signals)\n\n        Returns\n        -------\n        iosys : LinearFlatSystem\n            Linear system represented as an flat input/output system\n\n        """"""\n        # Make sure we can handle the system\n        if (not control.isctime(linsys)):\n            raise control.ControlNotImplemented(\n                ""requires continuous time, linear control system"")\n        elif (not control.issiso(linsys)):\n            raise control.ControlNotImplemented(\n                ""only single input, single output systems are supported"")\n\n        # Initialize the object as a LinearIO system\n        LinearIOSystem.__init__(\n            self, linsys, inputs=inputs, outputs=outputs, states=states,\n            name=name)\n\n        # Find the transformation to chain of integrators form\n        zsys, Tr = control.reachable_form(linsys)\n        Tr = Tr[::-1, ::]               # flip rows\n\n        # Extract the information that we need\n        self.F = zsys.A[0, ::-1]        # input function coeffs\n        self.T = Tr                     # state space transformation\n        self.Tinv = np.linalg.inv(Tr)   # compute inverse once\n\n        # Compute the flat output variable z = C x\n        Cfz = np.zeros(np.shape(linsys.C)); Cfz[0, 0] = 1\n        self.Cf = np.dot(Cfz, Tr)\n\n    # Compute the flat flag from the state (and input)\n    def forward(self, x, u):\n        """"""Compute the flat flag given the states and input.\n\n        See :func:`control.flatsys.FlatSystem.forward` for more info.\n\n        """"""\n        x = np.reshape(x, (-1, 1))\n        u = np.reshape(u, (1, -1))\n        zflag = [np.zeros(self.nstates + 1)]\n        zflag[0][0] = np.dot(self.Cf, x)\n        H = self.Cf                     # initial state transformation\n        for i in range(1, self.nstates + 1):\n            zflag[0][i] = np.dot(H, np.dot(self.A, x) + np.dot(self.B, u))\n            H = np.dot(H, self.A)       # derivative for next iteration\n        return zflag\n\n    # Compute state and input from flat flag\n    def reverse(self, zflag):\n        """"""Compute the states and input given the flat flag.\n\n        See :func:`control.flatsys.FlatSystem.reverse` for more info.\n\n        """"""\n        z = zflag[0][0:-1]\n        x = np.dot(self.Tinv, z)\n        u = zflag[0][-1] - np.dot(self.F, z)\n        return np.reshape(x, self.nstates), np.reshape(u, self.ninputs)\n'"
External_Libraries/python_control_master/control/flatsys/poly.py,1,"b'# poly.m - simple set of polynomial basis functions\n# TODO: rename this as taylor.m\n# RMM, 10 Nov 2012\n#\n# This class implements a set of simple basis functions consisting of powers\n# of t: 1, t, t^2, ...\n#\n# Copyright (c) 2012 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# \n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# \n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\nimport numpy as np\nfrom scipy.special import factorial\nfrom .basis import BasisFamily\n\nclass PolyFamily(BasisFamily):\n    r""""""Polynomial basis functions.\n\n    This class represents the family of polynomials of the form\n\n    .. math::\n         \\phi_i(t) = t^i\n\n    """"""\n    def __init__(self, N):\n        """"""Create a polynomial basis of order N.""""""\n        self.N = N                    # save number of basis functions\n\n    # Compute the kth derivative of the ith basis function at time t\n    def eval_deriv(self, i, k, t):\n        """"""Evaluate the kth derivative of the ith basis function at time t.""""""\n        if (i < k): return 0;           # higher derivative than power\n        return factorial(i)/factorial(i-k) * np.power(t, i-k)\n'"
External_Libraries/python_control_master/control/flatsys/systraj.py,3,"b'# systraj.py - SystemTrajectory class\n# RMM, 10 November 2012\n#\n# The SystemTrajetory class is used to store a feasible trajectory for\n# the state and input of a (nonlinear) control system.\n#\n# Copyright (c) 2012 by California Institute of Technology\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n# 1. Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n# \n# 2. Redistributions in binary form must reproduce the above copyright\n#    notice, this list of conditions and the following disclaimer in the\n#    documentation and/or other materials provided with the distribution.\n# \n# 3. Neither the name of the California Institute of Technology nor\n#    the names of its contributors may be used to endorse or promote\n#    products derived from this software without specific prior\n#    written permission.\n# \n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\n# OR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\n# USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n# SUCH DAMAGE.\n\nimport numpy as np\n\nclass SystemTrajectory:\n    """"""Class representing a system trajectory.\n\n    The `SystemTrajectory` class is used to represent the trajectory of\n    a (differentially flat) system.  Used by the\n    :func:`~control.trajsys.point_to_point` function to return a\n    trajectory.\n\n    """"""\n    def __init__(self, sys, basis, coeffs=[], flaglen=[]):\n        """"""Initilize a system trajectory object.\n\n        Parameters\n        ----------\n        sys : FlatSystem\n            Flat system object associated with this trajectory.\n        basis : BasisFamily\n            Family of basis vectors to use to represent the trajectory.\n        coeffs : list of 1D arrays, optional\n            For each flat output, define the coefficients of the basis\n            functions used to represent the trajectory.  Defaults to an empty\n            list.\n        flaglen : list of ints, optional\n            For each flat output, the number of derivatives of the flat output\n            used to define the trajectory.  Defaults to an empty list.\n\n        """"""\n        self.nstates = sys.nstates\n        self.ninputs = sys.ninputs\n        self.system = sys\n        self.basis = basis\n        self.coeffs = list(coeffs)\n        self.flaglen = list(flaglen)\n\n    # Evaluate the trajectory over a list of time points\n    def eval(self, tlist):\n        """"""Return the state and input for a trajectory at a list of times.\n\n        Evaluate the trajectory at a list of time points, returning the state\n        and input vectors for the trajectory:\n\n            x, u = traj.eval(tlist)\n\n        Parameters\n        ----------\n        tlist : 1D array\n            List of times to evaluate the trajectory.\n\n        Returns\n        -------\n        x : 2D array\n            For each state, the values of the state at the given times.\n        u : 2D array\n            For each input, the values of the input at the given times.\n\n        """"""\n        # Allocate space for the outputs\n        xd = np.zeros((self.nstates, len(tlist)))\n        ud = np.zeros((self.ninputs, len(tlist)))\n\n        # Go through each time point and compute xd and ud via flat variables\n        # TODO: make this more pythonic\n        for tind, t in enumerate(tlist):\n            zflag = []\n            for i in range(self.ninputs):\n                flag_len = self.flaglen[i]\n                zflag.append(np.zeros(flag_len))\n                for j in range(self.basis.N):\n                    for k in range(flag_len):\n                        #! TODO: rewrite eval_deriv to take in time vector\n                        zflag[i][k] += self.coeffs[i][j] * \\\n                            self.basis.eval_deriv(j, k, t)\n\n            # Now copy the states and inputs\n            # TODO: revisit order of list arguments\n            xd[:,tind], ud[:,tind] = self.system.reverse(zflag)\n\n        return xd, ud\n'"
External_Libraries/python_control_master/control/matlab/__init__.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nThe :mod:`control.matlab` module contains a number of functions that emulate\nsome of the functionality of MATLAB.  The intent of these functions is to\nprovide a simple interface to the python control systems library\n(python-control) for people who are familiar with the MATLAB Control Systems\nToolbox (tm).\n""""""\n\n""""""Copyright (c) 2009 by California Institute of Technology\nAll rights reserved.\n\nCopyright (c) 2011 by Eike Welk\n\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the California Institute of Technology nor\n   the names of its contributors may be used to endorse or promote\n   products derived from this software without specific prior\n   written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Richard M. Murray\nDate: 29 May 09\nRevised: Kevin K. Chen, Dec 10\n\n$Id$\n\n""""""\n\n# Import MATLAB-like functions that are defined in other packages\nfrom scipy.signal import zpk2ss, ss2zpk, tf2zpk, zpk2tf\nfrom numpy import linspace, logspace\n\n# If configuration is not yet set, import and use MATLAB defaults\nimport sys\nif not (\'.config\' in sys.modules):\n    from .. import config\n    config.use_matlab_defaults()\n\n# Control system library\nfrom ..statesp import *\nfrom ..xferfcn import *\nfrom ..lti import *\nfrom ..frdata import *\nfrom ..dtime import *\nfrom ..exception import ControlArgument\n\n# Import MATLAB-like functions that can be used as-is\nfrom ..ctrlutil import *\nfrom ..freqplot import nyquist, gangof4\nfrom ..nichols import nichols\nfrom ..bdalg import *\nfrom ..pzmap import *\nfrom ..statefbk import *\nfrom ..delay import *\nfrom ..modelsimp import *\nfrom ..mateqn import *\nfrom ..margins import margin\nfrom ..rlocus import rlocus\nfrom ..dtime import c2d\nfrom ..sisotool import sisotool\n\n# Import functions specific to Matlab compatibility package\nfrom .timeresp import *\nfrom .wrappers import *\n\n# Set up defaults corresponding to MATLAB conventions\nfrom ..config import *\nuse_matlab_defaults()\n\nr""""""\nThe following tables give an overview of the module ``control.matlab``.\nThey also show the implementation progress and the planned features of the\nmodule.\n\nThe symbols in the first column show the current state of a feature:\n\n* ``*`` : The feature is currently implemented.\n* ``-`` : The feature is not planned for implementation.\n* ``s`` : A similar feature from another library (Scipy) is imported into\n  the module, until the feature is implemented here.\n\n\nCreating linear models\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`tf`                  create transfer function (TF) models\n\\   zpk                         create zero/pole/gain (ZPK) models.\n\\*  :func:`ss`                  create state-space (SS) models\n\\   dss                         create descriptor state-space models\n\\   delayss                     create state-space models with delayed terms\n\\*  :func:`frd`                 create frequency response data (FRD) models\n\\   lti/exp                     create pure continuous-time delays (TF and\n                                ZPK only)\n\\   filt                        specify digital filters\n\\-  lti/set                     set/modify properties of LTI models\n\\-  setdelaymodel               specify internal delay model (state space\n                                only)\n\\*  :func:`rss`                 create a random continuous state space model\n\\*  :func:`drss`                create a random discrete state space model\n==  ==========================  ============================================\n\n\nData extraction\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`tfdata`              extract numerators and denominators\n\\   lti/zpkdata                 extract zero/pole/gain data\n\\   lti/ssdata                  extract state-space matrices\n\\   lti/dssdata                 descriptor version of SSDATA\n\\   frd/frdata                  extract frequency response data\n\\   lti/get                     access values of LTI model properties\n\\   ss/getDelayModel            access internal delay model (state space)\n==  ==========================  ============================================\n\n\nConversions\n----------------------------------------------------------------------------\n\n==  ============================   ============================================\n\\*  :func:`tf`                     conversion to transfer function\n\\   zpk                            conversion to zero/pole/gain\n\\*  :func:`ss`                     conversion to state space\n\\*  :func:`frd`                    conversion to frequency data\n\\*  :func:`c2d`                    continuous to discrete conversion\n\\   d2c                            discrete to continuous conversion\n\\   d2d                            resample discrete-time model\n\\   upsample                       upsample discrete-time LTI systems\n\\*  :func:`ss2tf`                  state space to transfer function\n\\s  :func:`~scipy.signal.ss2zpk`   transfer function to zero-pole-gain\n\\*  :func:`tf2ss`                  transfer function to state space\n\\s  :func:`~scipy.signal.tf2zpk`   transfer function to zero-pole-gain\n\\s  :func:`~scipy.signal.zpk2ss`   zero-pole-gain to state space\n\\s  :func:`~scipy.signal.zpk2tf`   zero-pole-gain to transfer function\n==  ============================   ============================================\n\n\nSystem interconnections\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`~control.append`     group LTI models by appending inputs/outputs\n\\*  :func:`~control.parallel`   connect LTI models in parallel\n                                (see also overloaded ``+``)\n\\*  :func:`~control.series`     connect LTI models in series\n                                (see also overloaded ``*``)\n\\*  :func:`~control.feedback`   connect lti models with a feedback loop\n\\   lti/lft                     generalized feedback interconnection\n\\*  :func:`~control.connect`    arbitrary interconnection of lti models\n\\   sumblk                      summing junction (for use with connect)\n\\   strseq                      builds sequence of indexed strings\n                                (for I/O naming)\n==  ==========================  ============================================\n\n\nSystem gain and dynamics\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`dcgain`              steady-state (D.C.) gain\n\\   lti/bandwidth               system bandwidth\n\\   lti/norm                    h2 and Hinfinity norms of LTI models\n\\*  :func:`pole`                system poles\n\\*  :func:`zero`                system (transmission) zeros\n\\   lti/order                   model order (number of states)\n\\*  :func:`~control.pzmap`      pole-zero map (TF only)\n\\   lti/iopzmap                 input/output pole-zero map\n\\*  :func:`damp`                natural frequency, damping of system poles\n\\   esort                       sort continuous poles by real part\n\\   dsort                       sort discrete poles by magnitude\n\\   lti/stabsep                 stable/unstable decomposition\n\\   lti/modsep                  region-based modal decomposition\n==  ==========================  ============================================\n\n\nTime-domain analysis\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`step`                step response\n\\   stepinfo                    step response characteristics\n\\*  :func:`impulse`             impulse response\n\\*  :func:`initial`             free response with initial conditions\n\\*  :func:`lsim`                response to user-defined input signal\n\\   lsiminfo                    linear response characteristics\n\\   gensig                      generate input signal for LSIM\n\\   covar                       covariance of response to white noise\n==  ==========================  ============================================\n\n\nFrequency-domain analysis\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`bode`                Bode plot of the frequency response\n\\   lti/bodemag                 Bode magnitude diagram only\n\\   sigma                       singular value frequency plot\n\\*  :func:`~control.nyquist`    Nyquist plot\n\\*  :func:`~control.nichols`    Nichols plot\n\\*  :func:`margin`              gain and phase margins\n\\   lti/allmargin               all crossover frequencies and margins\n\\*  :func:`freqresp`            frequency response over a frequency grid\n\\*  :func:`evalfr`              frequency response at single frequency\n==  ==========================  ============================================\n\n\nModel simplification\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`~control.minreal`    minimal realization; pole/zero cancellation\n\\   ss/sminreal                 structurally minimal realization\n\\*  :func:`~control.hsvd`       hankel singular values (state contributions)\n\\*  :func:`~control.balred`     reduced-order approximations of LTI models\n\\*  :func:`~control.modred`     model order reduction\n==  ==========================  ============================================\n\n\nCompensator design\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`rlocus`              evans root locus\n\\*  :func:`sisotool`            SISO controller design\n\\*  :func:`~control.place`      pole placement\n\\   estim                       form estimator given estimator gain\n\\   reg                         form regulator given state-feedback and\n                                estimator gains\n==  ==========================  ============================================\n\n\nLQR/LQG design\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\   ss/lqg                      single-step LQG design\n\\*  :func:`~control.lqr`        linear quadratic (LQ) state-fbk regulator\n\\   dlqr                        discrete-time LQ state-feedback regulator\n\\   lqry                        LQ regulator with output weighting\n\\   lqrd                        discrete LQ regulator for continuous plant\n\\   ss/lqi                      Linear-Quadratic-Integral (LQI) controller\n\\   ss/kalman                   Kalman state estimator\n\\   ss/kalmd                    discrete Kalman estimator for cts plant\n\\   ss/lqgreg                   build LQG regulator from LQ gain and Kalman\n                                estimator\n\\   ss/lqgtrack                 build LQG servo-controller\n\\   augstate                    augment output by appending states\n==  ==========================  ============================================\n\n\nState-space (SS) models\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`rss`                 random stable cts-time state-space models\n\\*  :func:`drss`                random stable disc-time state-space models\n\\   ss2ss                       state coordinate transformation\n\\   canon                       canonical forms of state-space models\n\\*  :func:`~control.ctrb`       controllability matrix\n\\*  :func:`~control.obsv`       observability matrix\n\\*  :func:`~control.gram`       controllability and observability gramians\n\\   ss/prescale                 optimal scaling of state-space models.\n\\   balreal                     gramian-based input/output balancing\n\\   ss/xperm                    reorder states.\n==  ==========================  ============================================\n\n\nFrequency response data (FRD) models\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\   frd/chgunits                change frequency vector units\n\\   frd/fcat                    merge frequency responses\n\\   frd/fselect                 select frequency range or subgrid\n\\   frd/fnorm                   peak gain as a function of frequency\n\\   frd/abs                     entrywise magnitude of frequency response\n\\   frd/real                    real part of the frequency response\n\\   frd/imag                    imaginary part of the frequency response\n\\   frd/interp                  interpolate frequency response data\n\\*  :func:`~control.mag2db`     convert magnitude to decibels (dB)\n\\*  :func:`~control.db2mag`     convert decibels (dB) to magnitude\n==  ==========================  ============================================\n\n\nTime delays\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\   lti/hasdelay                true for models with time delays\n\\   lti/totaldelay              total delay between each input/output pair\n\\   lti/delay2z                 replace delays by poles at z=0 or FRD phase\n                                shift\n\\*  :func:`~control.pade`       pade approximation of time delays\n==  ==========================  ============================================\n\n\nModel dimensions and characteristics\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\   class                       model type (\'tf\', \'zpk\', \'ss\', or \'frd\')\n\\   isa                         test if model is of given type\n\\   tf/size                     model sizes\n\\   lti/ndims                   number of dimensions\n\\   lti/isempty                 true for empty models\n\\   lti/isct                    true for continuous-time models\n\\   lti/isdt                    true for discrete-time models\n\\   lti/isproper                true for proper models\n\\   lti/issiso                  true for single-input/single-output models\n\\   lti/isstable                true for models with stable dynamics\n\\   lti/reshape                 reshape array of linear models\n==  ==========================  ============================================\n\nOverloaded arithmetic operations\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  \\+ and -                    add, subtract systems (parallel connection)\n\\*  \\*                          multiply systems (series connection)\n\\   /                           right divide -- sys1\\*inv(sys2)\n\\-   \\\\                         left divide -- inv(sys1)\\*sys2\n\\   ^                           powers of a given system\n\\   \'                           pertransposition\n\\   .\'                          transposition of input/output map\n\\   .\\*                         element-by-element multiplication\n\\   [..]                        concatenate models along inputs or outputs\n\\   lti/stack                   stack models/arrays along some dimension\n\\   lti/inv                     inverse of an LTI system\n\\   lti/conj                    complex conjugation of model coefficients\n==  ==========================  ============================================\n\nMatrix equation solvers and linear algebra\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`~control.lyap`       solve continuous-time Lyapunov equations\n\\*  :func:`~control.dlyap`      solve discrete-time Lyapunov equations\n\\   lyapchol, dlyapchol         square-root Lyapunov solvers\n\\*  :func:`~control.care`       solve continuous-time algebraic Riccati\n                                equations\n\\*  :func:`~control.dare`       solve disc-time algebraic Riccati equations\n\\   gcare, gdare                generalized Riccati solvers\n\\   bdschur                     block diagonalization of a square matrix\n==  ==========================  ============================================\n\n\nAdditional functions\n----------------------------------------------------------------------------\n\n==  ==========================  ============================================\n\\*  :func:`~control.gangof4`    generate the Gang of 4 sensitivity plots\n\\*  :func:`~numpy.linspace`     generate a set of numbers that are linearly\n                                spaced\n\\*  :func:`~numpy.logspace`     generate a set of numbers that are\n                                logarithmically spaced\n\\*  :func:`~control.unwrap`     unwrap phase angle to give continuous curve\n==  ==========================  ============================================\n\n""""""\n'"
External_Libraries/python_control_master/control/matlab/timeresp.py,0,"b'""""""\nTime response routines in the Matlab compatibility package\n\nNote that the return arguments are different than in the standard control package.\n""""""\n\n__all__ = [\'step\', \'stepinfo\', \'impulse\', \'initial\', \'lsim\']\n\ndef step(sys, T=None, X0=0., input=0, output=None, return_x=False):\n    \'\'\'\n    Step response of a linear system\n\n    If the system has multiple inputs or outputs (MIMO), one input has\n    to be selected for the simulation.  Optionally, one output may be\n    selected. If no selection is made for the output, all outputs are\n    given. The parameters `input` and `output` do this. All other\n    inputs are set to 0, all other outputs are ignored.\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        Index of the input that will be used in this simulation.\n\n    output: int\n        If given, index of the output that is returned by this simulation.\n\n    Returns\n    -------\n    yout: array\n        Response of the system\n\n    T: array\n        Time values of the output\n\n    xout: array (if selected)\n        Individual response of each x variable\n\n\n\n    See Also\n    --------\n    lsim, initial, impulse\n\n    Examples\n    --------\n    >>> yout, T = step(sys, T, X0)\n    \'\'\'\n    from ..timeresp import step_response\n\n    T, yout, xout = step_response(sys, T, X0, input, output,\n                                  transpose = True, return_x=True)\n\n    if return_x:\n        return yout, T, xout\n\n    return yout, T\n\ndef stepinfo(sys, T=None, SettlingTimeThreshold=0.02, RiseTimeLimits=(0.1,0.9)):\n    \'\'\'\n    Step response characteristics (Rise time, Settling Time, Peak and others).\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    SettlingTimeThreshold: float value, optional\n        Defines the error to compute settling time (default = 0.02)\n\n    RiseTimeLimits: tuple (lower_threshold, upper_theshold)\n        Defines the lower and upper threshold for RiseTime computation\n\n    Returns\n    -------\n    S: a dictionary containing:\n        RiseTime: Time from 10% to 90% of the steady-state value.\n        SettlingTime: Time to enter inside a default error of 2%\n        SettlingMin: Minimum value after RiseTime\n        SettlingMax: Maximum value after RiseTime\n        Overshoot: Percentage of the Peak relative to steady value\n        Undershoot: Percentage of undershoot\n        Peak: Absolute peak value\n        PeakTime: time of the Peak\n        SteadyStateValue: Steady-state value\n\n\n    See Also\n    --------\n    step, lsim, initial, impulse\n\n    Examples\n    --------\n    >>> S = stepinfo(sys, T)\n    \'\'\'\n    from ..timeresp import step_info\n\n    S = step_info(sys, T, SettlingTimeThreshold, RiseTimeLimits)\n\n    return S\n\ndef impulse(sys, T=None, X0=0., input=0, output=None, return_x=False):\n    \'\'\'\n    Impulse response of a linear system\n\n    If the system has multiple inputs or outputs (MIMO), one input has\n    to be selected for the simulation.  Optionally, one output may be\n    selected. If no selection is made for the output, all outputs are\n    given. The parameters `input` and `output` do this. All other\n    inputs are set to 0, all other outputs are ignored.\n\n    Parameters\n    ----------\n    sys: StateSpace, TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        Index of the input that will be used in this simulation.\n\n    output: int\n        Index of the output that will be used in this simulation.\n\n    Returns\n    -------\n    yout: array\n        Response of the system\n\n    T: array\n        Time values of the output\n\n    xout: array (if selected)\n        Individual response of each x variable\n\n    See Also\n    --------\n    lsim, step, initial\n\n    Examples\n    --------\n    >>> yout, T = impulse(sys, T)\n    \'\'\'\n    from ..timeresp import impulse_response\n    T, yout, xout = impulse_response(sys, T, X0, input, output,\n                                     transpose = True, return_x=True)\n\n    if return_x:\n        return yout, T, xout\n\n    return yout, T\n\ndef initial(sys, T=None, X0=0., input=None, output=None, return_x=False):\n    \'\'\'\n    Initial condition response of a linear system\n\n    If the system has multiple outputs (?IMO), optionally, one output\n    may be selected. If no selection is made for the output, all\n    outputs are given.\n\n    Parameters\n    ----------\n    sys: StateSpace, or TransferFunction\n        LTI system to simulate\n\n    T: array-like object, optional\n        Time vector (argument is autocomputed if not given)\n\n    X0: array-like object or number, optional\n        Initial condition (default = 0)\n\n        Numbers are converted to constant arrays with the correct shape.\n\n    input: int\n        This input is ignored, but present for compatibility with step\n        and impulse.\n\n    output: int\n        If given, index of the output that is returned by this simulation.\n\n    Returns\n    -------\n    yout: array\n        Response of the system\n\n    T: array\n        Time values of the output\n\n    xout: array (if selected)\n        Individual response of each x variable\n\n    See Also\n    --------\n    lsim, step, impulse\n\n    Examples\n    --------\n    >>> yout, T = initial(sys, T, X0)\n\n    \'\'\'\n    from ..timeresp import initial_response\n    T, yout, xout = initial_response(sys, T, X0, output=output,\n                                     transpose=True, return_x=True)\n\n    if return_x:\n        return yout, T, xout\n\n    return yout, T\n\ndef lsim(sys, U=0., T=None, X0=0.):\n    \'\'\'\n    Simulate the output of a linear system.\n\n    As a convenience for parameters `U`, `X0`:\n    Numbers (scalars) are converted to constant arrays with the correct shape.\n    The correct shape is inferred from arguments `sys` and `T`.\n\n    Parameters\n    ----------\n    sys: LTI (StateSpace, or TransferFunction)\n        LTI system to simulate\n\n    U: array-like or number, optional\n        Input array giving input at each time `T` (default = 0).\n\n        If `U` is ``None`` or ``0``, a special algorithm is used. This special\n        algorithm is faster than the general algorithm, which is used otherwise.\n\n    T: array-like\n        Time steps at which the input is defined, numbers must be (strictly\n        monotonic) increasing.\n\n    X0: array-like or number, optional\n        Initial condition (default = 0).\n\n    Returns\n    -------\n    yout: array\n        Response of the system.\n    T: array\n        Time values of the output.\n    xout: array\n        Time evolution of the state vector.\n\n    See Also\n    --------\n    step, initial, impulse\n\n    Examples\n    --------\n    >>> yout, T, xout = lsim(sys, U, T, X0)\n    \'\'\'\n    from ..timeresp import forced_response\n    T, yout, xout = forced_response(sys, T, U, X0, transpose = True)\n    return yout, T, xout\n'"
External_Libraries/python_control_master/control/matlab/wrappers.py,1,"b'""""""\nWrappers for the Matlab compatibility module\n""""""\n\nimport numpy as np\nfrom ..statesp import ss\nfrom ..xferfcn import tf\nfrom scipy.signal import zpk2tf\n\n__all__ = [\'bode\', \'ngrid\', \'dcgain\']\n\ndef bode(*args, **keywords):\n    """"""bode(syslist[, omega, dB, Hz, deg, ...])\n\n    Bode plot of the frequency response\n\n    Plots a bode gain and phase diagram\n\n    Parameters\n    ----------\n    sys : LTI, or list of LTI\n        System for which the Bode response is plotted and give. Optionally\n        a list of systems can be entered, or several systems can be\n        specified (i.e. several parameters). The sys arguments may also be\n        interspersed with format strings. A frequency argument (array_like)\n        may also be added, some examples:\n        * >>> bode(sys, w)                    # one system, freq vector\n        * >>> bode(sys1, sys2, ..., sysN)     # several systems\n        * >>> bode(sys1, sys2, ..., sysN, w)\n        * >>> bode(sys1, \'plotstyle1\', ..., sysN, \'plotstyleN\') # + plot formats\n    omega: freq_range\n        Range of frequencies in rad/s\n    dB : boolean\n        If True, plot result in dB\n    Hz : boolean\n        If True, plot frequency in Hz (omega must be provided in rad/sec)\n    deg : boolean\n        If True, return phase in degrees (else radians)\n    Plot : boolean\n        If True, plot magnitude and phase\n\n    Examples\n    --------\n    >>> sys = ss(""1. -2; 3. -4"", ""5.; 7"", ""6. 8"", ""9."")\n    >>> mag, phase, omega = bode(sys)\n\n    .. todo::\n\n        Document these use cases\n\n        * >>> bode(sys, w)\n        * >>> bode(sys1, sys2, ..., sysN)\n        * >>> bode(sys1, sys2, ..., sysN, w)\n        * >>> bode(sys1, \'plotstyle1\', ..., sysN, \'plotstyleN\')\n    """"""\n\n    # If the first argument is a list, then assume python-control calling format\n    from ..freqplot import bode as bode_orig\n    if (getattr(args[0], \'__iter__\', False)):\n        return bode_orig(*args, **keywords)\n\n    # Otherwise, run through the arguments and collect up arguments\n    syslist = []; plotstyle=[]; omega=None;\n    i = 0;\n    while i < len(args):\n        # Check to see if this is a system of some sort\n        from ..ctrlutil import issys\n        if (issys(args[i])):\n            # Append the system to our list of systems\n            syslist.append(args[i])\n            i += 1\n\n            # See if the next object is a plotsytle (string)\n            if (i < len(args) and isinstance(args[i], str)):\n                plotstyle.append(args[i])\n                i += 1\n\n            # Go on to the next argument\n            continue\n\n        # See if this is a frequency list\n        elif (isinstance(args[i], (list, np.ndarray))):\n            omega = args[i]\n            i += 1\n            break\n\n        else:\n            raise ControlArgument(""unrecognized argument type"")\n\n    # Check to make sure that we processed all arguments\n    if (i < len(args)):\n        raise ControlArgument(""not all arguments processed"")\n\n    # Check to make sure we got the same number of plotstyles as systems\n    if (len(plotstyle) != 0 and len(syslist) != len(plotstyle)):\n        raise ControlArgument(""number of systems and plotstyles should be equal"")\n\n    # Warn about unimplemented plotstyles\n    #! TODO: remove this when plot styles are implemented in bode()\n    #! TODO: uncomment unit test code that tests this out\n    if (len(plotstyle) != 0):\n        print(""Warning (matlab.bode): plot styles not implemented"");\n\n    # Call the bode command\n    return bode_orig(syslist, omega, **keywords)\n\nfrom ..nichols import nichols_grid\ndef ngrid():\n    return nichols_grid()\nngrid.__doc__ = nichols_grid.__doc__\n\ndef dcgain(*args):\n    \'\'\'\n    Compute the gain of the system in steady state.\n\n    The function takes either 1, 2, 3, or 4 parameters:\n\n    Parameters\n    ----------\n    A, B, C, D: array-like\n        A linear system in state space form.\n    Z, P, k: array-like, array-like, number\n        A linear system in zero, pole, gain form.\n    num, den: array-like\n        A linear system in transfer function form.\n    sys: LTI (StateSpace or TransferFunction)\n        A linear system object.\n\n    Returns\n    -------\n    gain: ndarray\n        The gain of each output versus each input:\n        :math:`y = gain \\cdot u`\n\n    Notes\n    -----\n    This function is only useful for systems with invertible system\n    matrix ``A``.\n\n    All systems are first converted to state space form. The function then\n    computes:\n\n    .. math:: gain = - C \\cdot A^{-1} \\cdot B + D\n    \'\'\'\n    #Convert the parameters to state space form\n    if len(args) == 4:\n        A, B, C, D = args\n        return ss(A, B, C, D).dcgain()\n    elif len(args) == 3:\n        Z, P, k = args\n        num, den = zpk2tf(Z, P, k)\n        return tf(num, den).dcgain()\n    elif len(args) == 2:\n        num, den = args\n        return tf(num, den).dcgain()\n    elif len(args) == 1:\n        sys, = args\n        return sys.dcgain()\n    else:\n        raise ValueError(""Function ``dcgain`` needs either 1, 2, 3 or 4 ""\n                         ""arguments."")\n'"
External_Libraries/python_control_master/control/tests/__init__.py,0,b''
External_Libraries/python_control_master/control/tests/bdalg_test.py,70,"b'#!/usr/bin/env python\n#\n# bdalg_test.py - test suit for block diagram algebra\n# RMM, 30 Mar 2011 (based on TestBDAlg from v0.4a)\n\nimport unittest\nimport numpy as np\nfrom numpy import sort\nimport control as ctrl\nfrom control.xferfcn import TransferFunction\nfrom control.statesp import StateSpace\nfrom control.bdalg import feedback\nfrom control.lti import zero, pole\n\nclass TestFeedback(unittest.TestCase):\n    """"""These are tests for the feedback function in bdalg.py.  Currently, some\n    of the tests are not implemented, or are not working properly.  TODO: these\n    need to be fixed.""""""\n\n    def setUp(self):\n        """"""This contains some random LTI systems and scalars for testing.""""""\n\n        # Two random SISO systems.\n        self.sys1 = TransferFunction([1, 2], [1, 2, 3])\n        self.sys2 = StateSpace([[1., 4.], [3., 2.]], [[1.], [-4.]],\n            [[1., 0.]], [[0.]])\n        # Two random scalars.\n        self.x1 = 2.5\n        self.x2 = -3.\n\n    def testScalarScalar(self):\n        """"""Scalar system with scalar feedback block.""""""\n\n        ans1 = feedback(self.x1, self.x2)\n        ans2 = feedback(self.x1, self.x2, 1.)\n\n        self.assertAlmostEqual(ans1.num[0][0][0] / ans1.den[0][0][0],\n            -2.5 / 6.5)\n        self.assertAlmostEqual(ans2.num[0][0][0] / ans2.den[0][0][0], 2.5 / 8.5)\n\n    def testScalarSS(self):\n        """"""Scalar system with state space feedback block.""""""\n\n        ans1 = feedback(self.x1, self.sys2)\n        ans2 = feedback(self.x1, self.sys2, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.A, [[-1.5, 4.], [13., 2.]])\n        np.testing.assert_array_almost_equal(ans1.B, [[2.5], [-10.]])\n        np.testing.assert_array_almost_equal(ans1.C, [[-2.5, 0.]])\n        np.testing.assert_array_almost_equal(ans1.D, [[2.5]])\n        np.testing.assert_array_almost_equal(ans2.A, [[3.5, 4.], [-7., 2.]])\n        np.testing.assert_array_almost_equal(ans2.B, [[2.5], [-10.]])\n        np.testing.assert_array_almost_equal(ans2.C, [[2.5, 0.]])\n        np.testing.assert_array_almost_equal(ans2.D, [[2.5]])\n\n        # Make sure default arugments work as well\n        ans3 = feedback(self.sys2, 1)\n        ans4 = feedback(self.sys2)\n        np.testing.assert_array_almost_equal(ans3.A, ans4.A)\n        np.testing.assert_array_almost_equal(ans3.B, ans4.B)\n        np.testing.assert_array_almost_equal(ans3.C, ans4.C)\n        np.testing.assert_array_almost_equal(ans3.D, ans4.D)\n\n    def testScalarTF(self):\n        """"""Scalar system with transfer function feedback block.""""""\n\n        ans1 = feedback(self.x1, self.sys1)\n        ans2 = feedback(self.x1, self.sys1, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.num, [[[2.5, 5., 7.5]]])\n        np.testing.assert_array_almost_equal(ans1.den, [[[1., 4.5, 8.]]])\n        np.testing.assert_array_almost_equal(ans2.num, [[[2.5, 5., 7.5]]])\n        np.testing.assert_array_almost_equal(ans2.den, [[[1., -0.5, -2.]]])\n\n        # Make sure default arugments work as well\n        ans3 = feedback(self.sys1, 1)\n        ans4 = feedback(self.sys1)\n        np.testing.assert_array_almost_equal(ans3.num, ans4.num)\n        np.testing.assert_array_almost_equal(ans3.den, ans4.den)\n\n    def testSSScalar(self):\n        """"""State space system with scalar feedback block.""""""\n\n        ans1 = feedback(self.sys2, self.x1)\n        ans2 = feedback(self.sys2, self.x1, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.A, [[-1.5, 4.], [13., 2.]])\n        np.testing.assert_array_almost_equal(ans1.B, [[1.], [-4.]])\n        np.testing.assert_array_almost_equal(ans1.C, [[1., 0.]])\n        np.testing.assert_array_almost_equal(ans1.D, [[0.]])\n        np.testing.assert_array_almost_equal(ans2.A, [[3.5, 4.], [-7., 2.]])\n        np.testing.assert_array_almost_equal(ans2.B, [[1.], [-4.]])\n        np.testing.assert_array_almost_equal(ans2.C, [[1., 0.]])\n        np.testing.assert_array_almost_equal(ans2.D, [[0.]])\n\n    def testSSSS1(self):\n        """"""State space system with state space feedback block.""""""\n\n        ans1 = feedback(self.sys2, self.sys2)\n        ans2 = feedback(self.sys2, self.sys2, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.A, [[1., 4., -1., 0.],\n            [3., 2., 4., 0.], [1., 0., 1., 4.], [-4., 0., 3., 2]])\n        np.testing.assert_array_almost_equal(ans1.B, [[1.], [-4.], [0.], [0.]])\n        np.testing.assert_array_almost_equal(ans1.C, [[1., 0., 0., 0.]])\n        np.testing.assert_array_almost_equal(ans1.D, [[0.]])\n        np.testing.assert_array_almost_equal(ans2.A, [[1., 4., 1., 0.],\n            [3., 2., -4., 0.], [1., 0., 1., 4.], [-4., 0., 3., 2.]])\n        np.testing.assert_array_almost_equal(ans2.B, [[1.], [-4.], [0.], [0.]])\n        np.testing.assert_array_almost_equal(ans2.C, [[1., 0., 0., 0.]])\n        np.testing.assert_array_almost_equal(ans2.D, [[0.]])\n\n    def testSSSS2(self):\n        """"""State space system with state space feedback block, including a\n        direct feedthrough term.""""""\n\n        sys3 = StateSpace([[-1., 4.], [2., -3]], [[2.], [3.]], [[-3., 1.]],\n            [[-2.]])\n        sys4 = StateSpace([[-3., -2.], [1., 4.]], [[-2.], [-6.]], [[2., -3.]],\n            [[3.]])\n\n        ans1 = feedback(sys3, sys4)\n        ans2 = feedback(sys3, sys4, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.A,\n            [[-4.6, 5.2, 0.8, -1.2], [-3.4, -1.2, 1.2, -1.8],\n             [-1.2, 0.4, -1.4, -4.4], [-3.6, 1.2, 5.8, -3.2]])\n        np.testing.assert_array_almost_equal(ans1.B,\n            [[-0.4], [-0.6], [-0.8], [-2.4]])\n        np.testing.assert_array_almost_equal(ans1.C, [[0.6, -0.2, -0.8, 1.2]])\n        np.testing.assert_array_almost_equal(ans1.D, [[0.4]])\n        np.testing.assert_array_almost_equal(ans2.A,\n            [[-3.57142857142857, 4.85714285714286, 0.571428571428571,\n                -0.857142857142857],\n             [-1.85714285714286, -1.71428571428571, 0.857142857142857,\n                -1.28571428571429],\n             [0.857142857142857, -0.285714285714286, -1.85714285714286,\n                -3.71428571428571],\n             [2.57142857142857, -0.857142857142857, 4.42857142857143,\n                -1.14285714285714]])\n        np.testing.assert_array_almost_equal(ans2.B, [[0.285714285714286],\n            [0.428571428571429], [0.571428571428571], [1.71428571428571]])\n        np.testing.assert_array_almost_equal(ans2.C, [[-0.428571428571429,\n            0.142857142857143, -0.571428571428571, 0.857142857142857]])\n        np.testing.assert_array_almost_equal(ans2.D, [[-0.285714285714286]])\n\n\n    def testSSTF(self):\n        """"""State space system with transfer function feedback block.""""""\n\n        # This functionality is not implemented yet.\n        pass\n\n    def testTFScalar(self):\n        """"""Transfer function system with scalar feedback block.""""""\n\n        ans1 = feedback(self.sys1, self.x1)\n        ans2 = feedback(self.sys1, self.x1, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.num, [[[1., 2.]]])\n        np.testing.assert_array_almost_equal(ans1.den, [[[1., 4.5, 8.]]])\n        np.testing.assert_array_almost_equal(ans2.num, [[[1., 2.]]])\n        np.testing.assert_array_almost_equal(ans2.den, [[[1., -0.5, -2.]]])\n\n    def testTFSS(self):\n        """"""Transfer function system with state space feedback block.""""""\n\n        # This functionality is not implemented yet.\n        pass\n\n    def testTFTF(self):\n        """"""Transfer function system with transfer function feedback block.""""""\n\n        ans1 = feedback(self.sys1, self.sys1)\n        ans2 = feedback(self.sys1, self.sys1, 1.)\n\n        np.testing.assert_array_almost_equal(ans1.num, [[[1., 4., 7., 6.]]])\n        np.testing.assert_array_almost_equal(ans1.den,\n            [[[1., 4., 11., 16., 13.]]])\n        np.testing.assert_array_almost_equal(ans2.num, [[[1., 4., 7., 6.]]])\n        np.testing.assert_array_almost_equal(ans2.den, [[[1., 4., 9., 8., 5.]]])\n\n    def testLists(self):\n        """"""Make sure that lists of various lengths work for operations""""""\n        sys1 = ctrl.tf([1, 1], [1, 2])\n        sys2 = ctrl.tf([1, 3], [1, 4])\n        sys3 = ctrl.tf([1, 5], [1, 6])\n        sys4 = ctrl.tf([1, 7], [1, 8])\n        sys5 = ctrl.tf([1, 9], [1, 0])\n\n        # Series\n        sys1_2 = ctrl.series(sys1, sys2)\n        np.testing.assert_array_almost_equal(sort(pole(sys1_2)), [-4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_2)), [-3., -1.])\n        \n        sys1_3 = ctrl.series(sys1, sys2, sys3);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_3)),\n                                             [-6., -4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_3)), \n                                             [-5., -3., -1.])\n        \n        sys1_4 = ctrl.series(sys1, sys2, sys3, sys4);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_4)),\n                                             [-8., -6., -4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_4)),\n                                             [-7., -5., -3., -1.])\n        \n        sys1_5 = ctrl.series(sys1, sys2, sys3, sys4, sys5);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_5)),\n                                             [-8., -6., -4., -2., -0.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_5)), \n                                             [-9., -7., -5., -3., -1.])\n\n        # Parallel \n        sys1_2 = ctrl.parallel(sys1, sys2)\n        np.testing.assert_array_almost_equal(sort(pole(sys1_2)), [-4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_2)),\n                                             sort(zero(sys1 + sys2)))\n        \n        sys1_3 = ctrl.parallel(sys1, sys2, sys3);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_3)),\n                                             [-6., -4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_3)), \n                                             sort(zero(sys1 + sys2 + sys3)))\n        \n        sys1_4 = ctrl.parallel(sys1, sys2, sys3, sys4);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_4)),\n                                             [-8., -6., -4., -2.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_4)), \n                                             sort(zero(sys1 + sys2 + \n                                                       sys3 + sys4)))\n\n        \n        sys1_5 = ctrl.parallel(sys1, sys2, sys3, sys4, sys5);\n        np.testing.assert_array_almost_equal(sort(pole(sys1_5)),\n                                             [-8., -6., -4., -2., -0.])\n        np.testing.assert_array_almost_equal(sort(zero(sys1_5)), \n                                             sort(zero(sys1 + sys2 + \n                                                       sys3 + sys4 + sys5)))\n    def testMimoSeries(self):\n        """"""regression: bdalg.series reverses order of arguments""""""\n        g1 = ctrl.ss([],[],[],[[1,2],[0,3]])\n        g2 = ctrl.ss([],[],[],[[1,0],[2,3]])\n        ref = g2*g1\n        tst = ctrl.series(g1,g2)\n        # assert_array_equal on mismatched matrices gives\n        # ""repr failed for <matrix>: ...""\n        def assert_equal(x,y):\n            np.testing.assert_array_equal(np.asarray(x),\n                                          np.asarray(y))\n        assert_equal(ref.A, tst.A)\n        assert_equal(ref.B, tst.B)\n        assert_equal(ref.C, tst.C)\n        assert_equal(ref.D, tst.D)\n\n    def test_feedback_args(self):\n        # Added 25 May 2019 to cover missing exception handling in feedback()\n        # If first argument is not LTI or convertable, generate an exception\n        args = ([1], self.sys2)\n        self.assertRaises(TypeError, ctrl.feedback, *args)\n\n        # If second argument is not LTI or convertable, generate an exception\n        args = (self.sys1, np.array([1]))\n        self.assertRaises(TypeError, ctrl.feedback, *args)\n\n        # Convert first argument to FRD, if needed\n        h = TransferFunction([1], [1, 2, 2])\n        omega = np.logspace(-1, 2, 10)\n        frd = ctrl.FRD(h, omega)\n        sys = ctrl.feedback(1, frd)\n        self.assertTrue(isinstance(sys, ctrl.FRD))\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestFeedback)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/canonical_test.py,109,"b'#!/usr/bin/env python\n\nimport unittest\nimport numpy as np\nfrom control import ss, tf, tf2ss, ss2tf\nfrom control.canonical import canonical_form, reachable_form, \\\n    observable_form, modal_form, similarity_transform\nfrom control.exception import ControlNotImplemented\n\nclass TestCanonical(unittest.TestCase):\n    """"""Tests for the canonical forms class""""""\n\n    def test_reachable_form(self):\n        """"""Test the reachable canonical form""""""\n\n        # Create a system in the reachable canonical form\n        coeffs = [1.0, 2.0, 3.0, 4.0, 1.0]\n        A_true = np.polynomial.polynomial.polycompanion(coeffs)\n        A_true = np.fliplr(np.rot90(A_true))\n        B_true = np.matrix(""1.0 0.0 0.0 0.0"").T\n        C_true = np.matrix(""1.0 1.0 1.0 1.0"")\n        D_true = 42.0\n\n        # Perform a coordinate transform with a random invertible matrix\n        T_true = np.matrix([[-0.27144004, -0.39933167,  0.75634684,  0.44135471],\n                            [-0.74855725, -0.39136285, -0.18142339, -0.50356997],\n                            [-0.40688007,  0.81416369,  0.38002113, -0.16483334],\n                            [-0.44769516,  0.15654653, -0.50060858,  0.72419146]])\n        A = np.linalg.solve(T_true, A_true)*T_true\n        B = np.linalg.solve(T_true, B_true)\n        C = C_true*T_true\n        D = D_true\n\n        # Create a state space system and convert it to the reachable canonical form\n        sys_check, T_check = canonical_form(ss(A, B, C, D), ""reachable"")\n\n        # Check against the true values\n        np.testing.assert_array_almost_equal(sys_check.A, A_true)\n        np.testing.assert_array_almost_equal(sys_check.B, B_true)\n        np.testing.assert_array_almost_equal(sys_check.C, C_true)\n        np.testing.assert_array_almost_equal(sys_check.D, D_true)\n        np.testing.assert_array_almost_equal(T_check, T_true)\n\n        # Reachable form only supports SISO\n        sys = tf([[ [1], [1] ]], [[ [1, 2, 1], [1, 2, 1] ]])\n        np.testing.assert_raises(ControlNotImplemented, reachable_form, sys)\n        \n\n    def test_unreachable_system(self):\n        """"""Test reachable canonical form with an unreachable system""""""\n\n        # Create an unreachable system\n        A = np.matrix(""1.0 2.0 2.0; 4.0 5.0 5.0; 7.0 8.0 8.0"")\n        B = np.matrix(""1.0 1.0 1.0"").T\n        C = np.matrix(""1.0 1.0 1.0"")\n        D = 42.0\n        sys = ss(A, B, C, D)\n\n        # Check if an exception is raised\n        np.testing.assert_raises(ValueError, canonical_form, sys, ""reachable"")\n\n    def test_modal_form(self):\n        """"""Test the modal canonical form""""""\n\n        # Create a system in the modal canonical form\n        A_true = np.diag([4.0, 3.0, 2.0, 1.0]) # order from the largest to the smallest\n        B_true = np.matrix(""1.1 2.2 3.3 4.4"").T\n        C_true = np.matrix(""1.3 1.4 1.5 1.6"")\n        D_true = 42.0\n\n        # Perform a coordinate transform with a random invertible matrix\n        T_true = np.matrix([[-0.27144004, -0.39933167,  0.75634684,  0.44135471],\n                            [-0.74855725, -0.39136285, -0.18142339, -0.50356997],\n                            [-0.40688007,  0.81416369,  0.38002113, -0.16483334],\n                            [-0.44769516,  0.15654653, -0.50060858,  0.72419146]])\n        A = np.linalg.solve(T_true, A_true)*T_true\n        B = np.linalg.solve(T_true, B_true)\n        C = C_true*T_true\n        D = D_true\n\n        # Create a state space system and convert it to the modal canonical form\n        sys_check, T_check = canonical_form(ss(A, B, C, D), ""modal"")\n\n        # Check against the true values\n        # TODO: Test in respect to ambiguous transformation (system characteristics?)\n        np.testing.assert_array_almost_equal(sys_check.A, A_true)\n        #np.testing.assert_array_almost_equal(sys_check.B, B_true)\n        #np.testing.assert_array_almost_equal(sys_check.C, C_true)\n        np.testing.assert_array_almost_equal(sys_check.D, D_true)\n        #np.testing.assert_array_almost_equal(T_check, T_true)\n\n        # Check conversion when there are complex eigenvalues\n        A_true = np.array([[-1,  1,  0,  0],\n                           [-1, -1,  0,  0],\n                           [ 0,  0, -2,  0],\n                           [ 0,  0,  0, -3]])\n        B_true = np.array([[0], [1], [0], [1]])\n        C_true = np.array([[1, 0, 0, 1]])\n        D_true = np.array([[0]])\n\n        A = np.linalg.solve(T_true, A_true) * T_true\n        B = np.linalg.solve(T_true, B_true)\n        C = C_true * T_true\n        D = D_true\n\n        # Create state space system and convert to modal canonical form\n        sys_check, T_check = canonical_form(ss(A, B, C, D), \'modal\')\n\n        # Check A and D matrix, which are uniquely defined\n        np.testing.assert_array_almost_equal(sys_check.A, A_true)\n        np.testing.assert_array_almost_equal(sys_check.D, D_true)\n\n        # B matrix should be all ones (or zero if not controllable)\n        # TODO: need to update modal_form() to implement this\n        if np.allclose(T_check, T_true):\n            np.testing.assert_array_almost_equal(sys_check.B, B_true)\n            np.testing.assert_array_almost_equal(sys_check.C, C_true)\n\n        # Make sure Hankel coefficients are OK\n        from numpy.linalg import matrix_power\n        for i in range(A.shape[0]):\n            np.testing.assert_almost_equal(\n                np.dot(np.dot(C_true, matrix_power(A_true, i)), B_true),\n                np.dot(np.dot(C, matrix_power(A, i)), B))\n\n        # Reorder rows to get complete coverage (real eigenvalue cxrtvfirst)\n        A_true = np.array([[-1,  0, 0,  0],\n                           [ 0, -2,  1,  0],\n                           [ 0, -1, -2,  0],\n                           [ 0,  0,  0, -3]])\n        B_true = np.array([[0], [0], [1], [1]])\n        C_true = np.array([[0, 1, 0, 1]])\n        D_true = np.array([[0]])\n\n        A = np.linalg.solve(T_true, A_true) * T_true\n        B = np.linalg.solve(T_true, B_true)\n        C = C_true * T_true\n        D = D_true\n\n        # Create state space system and convert to modal canonical form\n        sys_check, T_check = canonical_form(ss(A, B, C, D), \'modal\')\n\n        # Check A and D matrix, which are uniquely defined\n        np.testing.assert_array_almost_equal(sys_check.A, A_true)\n        np.testing.assert_array_almost_equal(sys_check.D, D_true)\n\n        # B matrix should be all ones (or zero if not controllable)\n        # TODO: need to update modal_form() to implement this\n        if np.allclose(T_check, T_true):\n            np.testing.assert_array_almost_equal(sys_check.B, B_true)\n            np.testing.assert_array_almost_equal(sys_check.C, C_true)\n\n        # Make sure Hankel coefficients are OK\n        from numpy.linalg import matrix_power\n        for i in range(A.shape[0]):\n            np.testing.assert_almost_equal(\n                np.dot(np.dot(C_true, matrix_power(A_true, i)), B_true),\n                np.dot(np.dot(C, matrix_power(A, i)), B))\n            \n        # Modal form only supports SISO\n        sys = tf([[ [1], [1] ]], [[ [1, 2, 1], [1, 2, 1] ]])\n        np.testing.assert_raises(ControlNotImplemented, modal_form, sys)\n        \n    def test_observable_form(self):\n        """"""Test the observable canonical form""""""\n\n        # Create a system in the observable canonical form\n        coeffs = [1.0, 2.0, 3.0, 4.0, 1.0]\n        A_true = np.polynomial.polynomial.polycompanion(coeffs)\n        A_true = np.fliplr(np.flipud(A_true))\n        B_true = np.matrix(""1.0 1.0 1.0 1.0"").T\n        C_true = np.matrix(""1.0 0.0 0.0 0.0"")\n        D_true = 42.0\n\n        # Perform a coordinate transform with a random invertible matrix\n        T_true = np.matrix([[-0.27144004, -0.39933167,  0.75634684,  0.44135471],\n                            [-0.74855725, -0.39136285, -0.18142339, -0.50356997],\n                            [-0.40688007,  0.81416369,  0.38002113, -0.16483334],\n                            [-0.44769516,  0.15654653, -0.50060858,  0.72419146]])\n        A = np.linalg.solve(T_true, A_true)*T_true\n        B = np.linalg.solve(T_true, B_true)\n        C = C_true*T_true\n        D = D_true\n\n        # Create a state space system and convert it to the observable canonical form\n        sys_check, T_check = canonical_form(ss(A, B, C, D), ""observable"")\n\n        # Check against the true values\n        np.testing.assert_array_almost_equal(sys_check.A, A_true)\n        np.testing.assert_array_almost_equal(sys_check.B, B_true)\n        np.testing.assert_array_almost_equal(sys_check.C, C_true)\n        np.testing.assert_array_almost_equal(sys_check.D, D_true)\n        np.testing.assert_array_almost_equal(T_check, T_true)\n\n        # Observable form only supports SISO\n        sys = tf([[ [1], [1] ]], [[ [1, 2, 1], [1, 2, 1] ]])\n        np.testing.assert_raises(ControlNotImplemented, observable_form, sys)\n        \n\n    def test_unobservable_system(self):\n        """"""Test observable canonical form with an unobservable system""""""\n\n        # Create an unobservable system\n        A = np.matrix(""1.0 2.0 2.0; 4.0 5.0 5.0; 7.0 8.0 8.0"")\n        B = np.matrix(""1.0 1.0 1.0"").T\n        C = np.matrix(""1.0 1.0 1.0"")\n        D = 42.0\n        sys = ss(A, B, C, D)\n\n        # Check if an exception is raised\n        np.testing.assert_raises(ValueError, canonical_form, sys, ""observable"")\n\n    def test_arguments(self):\n        # Additional unit tests added on 25 May 2019 to increase coverage\n\n        # Unknown canonical forms should generate exception\n        sys = tf([1], [1, 2, 1])\n        np.testing.assert_raises(\n            ControlNotImplemented, canonical_form, sys, \'unknown\')\n\n    def test_similarity(self):\n        """"""Test similarty transform""""""\n\n        # Single input, single output systems\n        siso_ini = tf2ss(tf([1, 1], [1, 1, 1]))\n        for form in \'reachable\', \'observable\':\n            # Convert the system to one of the canonical forms\n            siso_can, T_can = canonical_form(siso_ini, form)\n\n            # Use a similarity transformation to transform it back\n            siso_sim = similarity_transform(siso_can, np.linalg.inv(T_can))\n\n            # Make sure everything goes back to the original form\n            np.testing.assert_array_almost_equal(siso_sim.A, siso_ini.A)\n            np.testing.assert_array_almost_equal(siso_sim.B, siso_ini.B)\n            np.testing.assert_array_almost_equal(siso_sim.C, siso_ini.C)\n            np.testing.assert_array_almost_equal(siso_sim.D, siso_ini.D)\n\n        # Multi-input, multi-output systems\n        mimo_ini = ss(\n            [[-1, 1, 0, 0], [0, -2, 1, 0], [0, 0, -3, 1], [0, 0, 0, -4]],\n            [[1, 0], [0, 0], [0, 1], [1, 1]],\n            [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0]],\n            np.zeros((3, 2)))\n\n        # Simple transformation: row/col flips + scaling\n        mimo_txf = np.array(\n            [[0, 1, 0, 0], [2, 0, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])\n\n        # Transform the system and transform it back\n        mimo_sim = similarity_transform(mimo_ini, mimo_txf)\n        mimo_new = similarity_transform(mimo_sim, np.linalg.inv(mimo_txf))\n        np.testing.assert_array_almost_equal(mimo_new.A, mimo_ini.A)\n        np.testing.assert_array_almost_equal(mimo_new.B, mimo_ini.B)\n        np.testing.assert_array_almost_equal(mimo_new.C, mimo_ini.C)\n        np.testing.assert_array_almost_equal(mimo_new.D, mimo_ini.D)\n\n        # Make sure rescaling by identify does nothing\n        mimo_new = similarity_transform(mimo_ini, np.eye(4))\n        np.testing.assert_array_almost_equal(mimo_new.A, mimo_ini.A)\n        np.testing.assert_array_almost_equal(mimo_new.B, mimo_ini.B)\n        np.testing.assert_array_almost_equal(mimo_new.C, mimo_ini.C)\n        np.testing.assert_array_almost_equal(mimo_new.D, mimo_ini.D)\n        \n        # Time rescaling\n        mimo_tim = similarity_transform(mimo_ini, np.eye(4), timescale=0.3)\n        mimo_new = similarity_transform(mimo_tim, np.eye(4), timescale=1/0.3)\n        np.testing.assert_array_almost_equal(mimo_new.A, mimo_ini.A)\n        np.testing.assert_array_almost_equal(mimo_new.B, mimo_ini.B)\n        np.testing.assert_array_almost_equal(mimo_new.C, mimo_ini.C)\n        np.testing.assert_array_almost_equal(mimo_new.D, mimo_ini.D)\n\n        # Time + transformation, in one step\n        mimo_sim = similarity_transform(mimo_ini, mimo_txf, timescale=0.3)\n        mimo_new = similarity_transform(mimo_sim, np.linalg.inv(mimo_txf),\n                                        timescale=1/0.3)\n        np.testing.assert_array_almost_equal(mimo_new.A, mimo_ini.A)\n        np.testing.assert_array_almost_equal(mimo_new.B, mimo_ini.B)\n        np.testing.assert_array_almost_equal(mimo_new.C, mimo_ini.C)\n        np.testing.assert_array_almost_equal(mimo_new.D, mimo_ini.D)\n\n        # Time + transformation, in two steps\n        mimo_sim = similarity_transform(mimo_ini, mimo_txf, timescale=0.3)\n        mimo_tim = similarity_transform(mimo_sim, np.eye(4), timescale=1/0.3)\n        mimo_new = similarity_transform(mimo_tim, np.linalg.inv(mimo_txf))\n        np.testing.assert_array_almost_equal(mimo_new.A, mimo_ini.A)\n        np.testing.assert_array_almost_equal(mimo_new.B, mimo_ini.B)\n        np.testing.assert_array_almost_equal(mimo_new.C, mimo_ini.C)\n        np.testing.assert_array_almost_equal(mimo_new.D, mimo_ini.D)\n        \ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestFeedback)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/config_test.py,26,"b""#!/usr/bin/env python\n#\n# config_test.py - test config module\n# RMM, 25 may 2019\n#\n# This test suite checks the functionality of the config module\n\nimport unittest\nimport numpy as np\nimport control as ct\nimport matplotlib.pyplot as plt\nfrom math import pi, log10\n\n\nclass TestConfig(unittest.TestCase):\n    def setUp(self):\n        # Create a simple second order system to use for testing\n        self.sys = ct.tf([10], [1, 2, 1])\n\n    def test_set_defaults(self):\n        ct.config.set_defaults('config', test1=1, test2=2, test3=None)\n        self.assertEqual(ct.config.defaults['config.test1'], 1)\n        self.assertEqual(ct.config.defaults['config.test2'], 2)\n        self.assertEqual(ct.config.defaults['config.test3'], None)\n\n    def test_get_param(self):\n        self.assertEqual(\n            ct.config._get_param('bode', 'dB'),\n            ct.config.defaults['bode.dB'])\n        self.assertEqual(ct.config._get_param('bode', 'dB', 1), 1)\n        ct.config.defaults['config.test1'] = 1\n        self.assertEqual(ct.config._get_param('config', 'test1', None), 1)\n        self.assertEqual(ct.config._get_param('config', 'test1', None, 1), 1)\n        \n        ct.config.defaults['config.test3'] = None\n        self.assertEqual(ct.config._get_param('config', 'test3'), None)\n        self.assertEqual(ct.config._get_param('config', 'test3', 1), 1)\n        self.assertEqual(\n            ct.config._get_param('config', 'test3', None, 1), None)\n        \n        self.assertEqual(ct.config._get_param('config', 'test4'), None)\n        self.assertEqual(ct.config._get_param('config', 'test4', 1), 1)\n        self.assertEqual(ct.config._get_param('config', 'test4', 2, 1), 2)\n        self.assertEqual(ct.config._get_param('config', 'test4', None, 3), 3)\n\n        self.assertEqual(\n            ct.config._get_param('config', 'test4', {'test4':1}, None), 1)\n\n\n    def test_fbs_bode(self):\n        ct.use_fbs_defaults();\n\n        # Generate a Bode plot\n        plt.figure()\n        omega = np.logspace(-3, 3, 100)\n        ct.bode_plot(self.sys, omega)\n\n        # Get the magnitude line\n        mag_axis = plt.gcf().axes[0]\n        mag_line = mag_axis.get_lines()\n        mag_data = mag_line[0].get_data()\n        mag_x, mag_y = mag_data\n\n        # Make sure the x-axis is in rad/sec and y-axis is in natural units\n        np.testing.assert_almost_equal(mag_x[0], 0.001, decimal=6)\n        np.testing.assert_almost_equal(mag_y[0], 10, decimal=3)\n\n        # Get the phase line\n        phase_axis = plt.gcf().axes[1]\n        phase_line = phase_axis.get_lines()\n        phase_data = phase_line[0].get_data()\n        phase_x, phase_y = phase_data\n\n        # Make sure the x-axis is in rad/sec and y-axis is in degrees\n        np.testing.assert_almost_equal(phase_x[-1], 1000, decimal=0)\n        np.testing.assert_almost_equal(phase_y[-1], -180, decimal=0)\n\n        # Override the defaults and make sure that works as well\n        plt.figure()\n        ct.bode_plot(self.sys, omega, dB=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_y[0], 20*log10(10), decimal=3)\n\n        plt.figure()\n        ct.bode_plot(self.sys, omega, Hz=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_x[0], 0.001 / (2*pi), decimal=6)\n\n        plt.figure()\n        ct.bode_plot(self.sys, omega, deg=False)\n        phase_x, phase_y = (((plt.gcf().axes[1]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(phase_y[-1], -pi, decimal=2)\n\n        ct.reset_defaults()\n        \n    def test_matlab_bode(self):\n        ct.use_matlab_defaults();\n\n        # Generate a Bode plot\n        plt.figure()\n        omega = np.logspace(-3, 3, 100)\n        ct.bode_plot(self.sys, omega)\n\n        # Get the magnitude line\n        mag_axis = plt.gcf().axes[0]\n        mag_line = mag_axis.get_lines()\n        mag_data = mag_line[0].get_data()\n        mag_x, mag_y = mag_data\n\n        # Make sure the x-axis is in Hertz and y-axis is in dB\n        np.testing.assert_almost_equal(mag_x[0], 0.001 / (2*pi), decimal=6)\n        np.testing.assert_almost_equal(mag_y[0], 20*log10(10), decimal=3)\n\n        # Get the phase line\n        phase_axis = plt.gcf().axes[1]\n        phase_line = phase_axis.get_lines()\n        phase_data = phase_line[0].get_data()\n        phase_x, phase_y = phase_data\n\n        # Make sure the x-axis is in Hertz and y-axis is in degrees\n        np.testing.assert_almost_equal(phase_x[-1], 1000 / (2*pi), decimal=1)\n        np.testing.assert_almost_equal(phase_y[-1], -180, decimal=0)\n        \n        # Override the defaults and make sure that works as well\n        plt.figure()\n        ct.bode_plot(self.sys, omega, dB=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_y[0], 20*log10(10), decimal=3)\n\n        plt.figure()\n        ct.bode_plot(self.sys, omega, Hz=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_x[0], 0.001 / (2*pi), decimal=6)\n\n        plt.figure()\n        ct.bode_plot(self.sys, omega, deg=False)\n        phase_x, phase_y = (((plt.gcf().axes[1]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(phase_y[-1], -pi, decimal=2)\n\n        ct.reset_defaults()\n\n    def test_custom_bode_default(self):\n        ct.config.defaults['bode.dB'] = True\n        ct.config.defaults['bode.deg'] = True\n        ct.config.defaults['bode.Hz'] = True\n\n        # Generate a Bode plot\n        plt.figure()\n        omega = np.logspace(-3, 3, 100)\n        ct.bode_plot(self.sys, omega, dB=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_y[0], 20*log10(10), decimal=3)\n\n        # Override defaults\n        plt.figure()\n        ct.bode_plot(self.sys, omega, Hz=True, deg=False, dB=True)\n        mag_x, mag_y = (((plt.gcf().axes[0]).get_lines())[0]).get_data()\n        phase_x, phase_y = (((plt.gcf().axes[1]).get_lines())[0]).get_data()\n        np.testing.assert_almost_equal(mag_x[0], 0.001 / (2*pi), decimal=6)\n        np.testing.assert_almost_equal(mag_y[0], 20*log10(10), decimal=3)\n        np.testing.assert_almost_equal(phase_y[-1], -pi, decimal=2)\n\n        ct.reset_defaults()\n\n    def test_bode_number_of_samples(self):\n        # Set the number of samples (default is 50, from np.logspace)\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, omega_num=87)\n        self.assertEqual(len(mag_ret), 87)\n\n        # Change the default number of samples\n        ct.config.defaults['freqplot.number_of_samples'] = 76\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys)\n        self.assertEqual(len(mag_ret), 76)\n        \n        # Override the default number of samples\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, omega_num=87)\n        self.assertEqual(len(mag_ret), 87)\n\n        ct.reset_defaults()\n\n    def test_bode_feature_periphery_decade(self):\n        # Generate a sample Bode plot to figure out the range it uses\n        ct.reset_defaults()     # Make sure starting state is correct\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, Hz=False)\n        omega_min, omega_max = omega_ret[[0,  -1]]\n\n        # Reset the periphery decade value (should add one decade on each end)\n        ct.config.defaults['freqplot.feature_periphery_decades'] = 2\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, Hz=False)\n        np.testing.assert_almost_equal(omega_ret[0], omega_min/10)\n        np.testing.assert_almost_equal(omega_ret[-1], omega_max * 10)\n\n        # Make sure it also works in rad/sec, in opposite direction\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, Hz=True)\n        omega_min, omega_max = omega_ret[[0,  -1]]\n        ct.config.defaults['freqplot.feature_periphery_decades'] = 1\n        mag_ret, phase_ret, omega_ret = ct.bode_plot(self.sys, Hz=True)\n        np.testing.assert_almost_equal(omega_ret[0], omega_min*10)\n        np.testing.assert_almost_equal(omega_ret[-1], omega_max/10)\n\n        ct.reset_defaults()\n\n    def test_reset_defaults(self):\n        ct.use_matlab_defaults()\n        ct.reset_defaults()\n        self.assertEqual(ct.config.defaults['bode.dB'], False)\n        self.assertEqual(ct.config.defaults['bode.deg'], True)\n        self.assertEqual(ct.config.defaults['bode.Hz'], False)\n        self.assertEqual(\n            ct.config.defaults['freqplot.number_of_samples'], None)\n        self.assertEqual(\n            ct.config.defaults['freqplot.feature_periphery_decades'], 1.0)\n\n    def tearDown(self):\n        # Get rid of any figures that we created\n        plt.close('all')\n\n        # Reset the configuration defaults\n        ct.config.reset_defaults()\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestTimeresp)\n\n\nif __name__ == '__main__':\n    unittest.main()\n"""
External_Libraries/python_control_master/control/tests/convert_test.py,32,"b'#!/usr/bin/env python\n\n""""""convert_test.py\n\nTest state space and transfer function conversion.\n\nCurrently, this unit test script is not complete.  It converts several random\nstate spaces back and forth between state space and transfer function\nrepresentations.  Ideally, it should be able to assert that the conversion\noutputs are correct.  This is not yet implemented.\n\nAlso, the conversion seems to enter an infinite loop once in a while.  The cause\nof this is unknown.\n\n""""""\n\nfrom __future__ import print_function\nimport unittest\nimport numpy as np\nfrom control import matlab\nfrom control.statesp import _mimo2siso\nfrom control.statefbk import ctrb, obsv\nfrom control.freqplot import bode\nfrom control.matlab import tf\nfrom control.exception import slycot_check\n\nclass TestConvert(unittest.TestCase):\n    """"""Test state space and transfer function conversions.""""""\n\n    def setUp(self):\n        """"""Set up testing parameters.""""""\n\n        # Number of times to run each of the randomized tests.\n        self.numTests = 1  # almost guarantees failure\n        # Maximum number of states to test + 1\n        self.maxStates = 4\n        # Maximum number of inputs and outputs to test + 1\n        # If slycot is not installed, just check SISO\n        self.maxIO = 5 if slycot_check() else 2\n        # Set to True to print systems to the output.\n        self.debug = False\n        # get consistent results\n        np.random.seed(7)\n\n    def printSys(self, sys, ind):\n        """"""Print system to the standard output.""""""\n\n        if self.debug:\n            print(""sys%i:\\n"" % ind)\n            print(sys)\n\n    def testConvert(self):\n        """"""Test state space to transfer function conversion.""""""\n        verbose = self.debug\n\n        # print __doc__\n\n        # Machine precision for floats.\n        # eps = np.finfo(float).eps\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    # start with a random SS system and transform to TF then\n                    # back to SS, check that the matrices are the same.\n                    ssOriginal = matlab.rss(states, outputs, inputs)\n                    if (verbose):\n                        self.printSys(ssOriginal, 1)\n\n                    # Make sure the system is not degenerate\n                    Cmat = ctrb(ssOriginal.A, ssOriginal.B)\n                    if (np.linalg.matrix_rank(Cmat) != states):\n                        if (verbose):\n                            print(""  skipping (not reachable)"")\n                        continue\n                    Omat = obsv(ssOriginal.A, ssOriginal.C)\n                    if (np.linalg.matrix_rank(Omat) != states):\n                        if (verbose):\n                            print(""  skipping (not observable)"")\n                        continue\n\n                    tfOriginal = matlab.tf(ssOriginal)\n                    if (verbose):\n                        self.printSys(tfOriginal, 2)\n\n                    ssTransformed = matlab.ss(tfOriginal)\n                    if (verbose):\n                        self.printSys(ssTransformed, 3)\n\n                    tfTransformed = matlab.tf(ssTransformed)\n                    if (verbose):\n                        self.printSys(tfTransformed, 4)\n\n                    # Check to see if the state space systems have same dim\n                    if (ssOriginal.states != ssTransformed.states):\n                        print(""WARNING: state space dimension mismatch: "" + \\\n                            ""%d versus %d"" % \\\n                            (ssOriginal.states, ssTransformed.states))\n\n                    # Now make sure the frequency responses match\n                    # Since bode() only handles SISO, go through each I/O pair\n                    # For phase, take sine and cosine to avoid +/- 360 offset\n                    for inputNum in range(inputs):\n                        for outputNum in range(outputs):\n                            if (verbose):\n                                print(""Checking input %d, output %d"" \\\n                                    % (inputNum, outputNum))\n                            ssorig_mag, ssorig_phase, ssorig_omega = \\\n                                bode(_mimo2siso(ssOriginal, \\\n                                                        inputNum, outputNum), \\\n                                                 deg=False, Plot=False)\n                            ssorig_real = ssorig_mag * np.cos(ssorig_phase)\n                            ssorig_imag = ssorig_mag * np.sin(ssorig_phase)\n\n                            #\n                            # Make sure TF has same frequency response\n                            #\n                            num = tfOriginal.num[outputNum][inputNum]\n                            den = tfOriginal.den[outputNum][inputNum]\n                            tforig = tf(num, den)\n\n                            tforig_mag, tforig_phase, tforig_omega = \\\n                                bode(tforig, ssorig_omega, \\\n                                                 deg=False, Plot=False)\n\n                            tforig_real = tforig_mag * np.cos(tforig_phase)\n                            tforig_imag = tforig_mag * np.sin(tforig_phase)\n                            np.testing.assert_array_almost_equal( \\\n                                ssorig_real, tforig_real)\n                            np.testing.assert_array_almost_equal( \\\n                                ssorig_imag, tforig_imag)\n\n                            #\n                            # Make sure xform\'d SS has same frequency response\n                            #\n                            ssxfrm_mag, ssxfrm_phase, ssxfrm_omega = \\\n                                bode(_mimo2siso(ssTransformed, \\\n                                                        inputNum, outputNum), \\\n                                                 ssorig_omega, \\\n                                                 deg=False, Plot=False)\n                            ssxfrm_real = ssxfrm_mag * np.cos(ssxfrm_phase)\n                            ssxfrm_imag = ssxfrm_mag * np.sin(ssxfrm_phase)\n                            np.testing.assert_array_almost_equal( \\\n                            ssorig_real, ssxfrm_real)\n                            np.testing.assert_array_almost_equal( \\\n                            ssorig_imag, ssxfrm_imag)\n                            #\n                            # Make sure xform\'d TF has same frequency response\n                            #\n                            num = tfTransformed.num[outputNum][inputNum]\n                            den = tfTransformed.den[outputNum][inputNum]\n                            tfxfrm = tf(num, den)\n                            tfxfrm_mag, tfxfrm_phase, tfxfrm_omega = \\\n                                bode(tfxfrm, ssorig_omega, \\\n                                                 deg=False, Plot=False)\n\n                            tfxfrm_real = tfxfrm_mag * np.cos(tfxfrm_phase)\n                            tfxfrm_imag = tfxfrm_mag * np.sin(tfxfrm_phase)\n                            np.testing.assert_array_almost_equal( \\\n                                ssorig_real, tfxfrm_real)\n                            np.testing.assert_array_almost_equal( \\\n                                ssorig_imag, tfxfrm_imag)\n\n    def testConvertMIMO(self):\n        """"""Test state space to transfer function conversion.""""""\n        verbose = self.debug\n\n        # Do a MIMO conversation and make sure that it is processed\n        # correctly both with and without slycot\n        #\n        # Example from issue #120, jgoppert\n        import control\n\n        # Set up a transfer function (should always work)\n        tfcn = control.tf([[[-235, 1.146e4],\n                            [-235, 1.146E4],\n                            [-235, 1.146E4, 0]]],\n                          [[[1, 48.78, 0],\n                            [1, 48.78, 0, 0],\n                            [0.008, 1.39, 48.78]]])\n\n        # Convert to state space and look for an error\n        if (not slycot_check()):\n            self.assertRaises(TypeError, control.tf2ss, tfcn)\n\n    def testTf2ssStaticSiso(self):\n        """"""Regression: tf2ss for SISO static gain""""""\n        import control\n        gsiso = control.tf2ss(control.tf(23, 46))\n        self.assertEqual(0, gsiso.states)\n        self.assertEqual(1, gsiso.inputs)\n        self.assertEqual(1, gsiso.outputs)\n        # in all cases ratios are exactly representable, so assert_array_equal is fine\n        np.testing.assert_array_equal([[0.5]], gsiso.D)\n\n    def testTf2ssStaticMimo(self):\n        """"""Regression: tf2ss for MIMO static gain""""""\n        import control\n        # 2x3 TFM\n        gmimo = control.tf2ss(control.tf(\n                [[ [23],   [3],  [5] ], [ [-1],  [0.125],  [101.3] ]],\n                [[ [46], [0.1], [80] ], [  [2],   [-0.1],      [1] ]]))\n        self.assertEqual(0, gmimo.states)\n        self.assertEqual(3, gmimo.inputs)\n        self.assertEqual(2, gmimo.outputs)\n        d = np.matrix([[0.5, 30, 0.0625], [-0.5, -1.25, 101.3]])\n        np.testing.assert_array_equal(d, gmimo.D)\n\n    def testSs2tfStaticSiso(self):\n        """"""Regression: ss2tf for SISO static gain""""""\n        import control\n        gsiso = control.ss2tf(control.ss([], [], [], 0.5))\n        np.testing.assert_array_equal([[[0.5]]], gsiso.num)\n        np.testing.assert_array_equal([[[1.]]], gsiso.den)\n\n    def testSs2tfStaticMimo(self):\n        """"""Regression: ss2tf for MIMO static gain""""""\n        import control\n        # 2x3 TFM\n        a = []\n        b = []\n        c = []\n        d = np.matrix([[0.5, 30, 0.0625], [-0.5, -1.25, 101.3]])\n        gtf = control.ss2tf(control.ss(a,b,c,d))\n\n        # we need a 3x2x1 array to compare with gtf.num\n        # np.testing.assert_array_equal doesn\'t seem to like a matrices\n        # with an extra dimension, so convert to ndarray\n        numref = np.asarray(d)[...,np.newaxis]\n        np.testing.assert_array_equal(numref, np.array(gtf.num) / np.array(gtf.den))\n\n    def testTf2SsDuplicatePoles(self):\n        """"""Tests for ""too few poles for MIMO tf #111"" """"""\n        import control\n        try:\n            import slycot\n            num = [ [ [1], [0] ],\n                   [ [0], [1] ] ]\n\n            den = [ [ [1,0], [1] ],\n                [ [1],   [1,0] ] ]\n            g = control.tf(num, den)\n            s = control.ss(g)\n            np.testing.assert_array_equal(g.pole(), s.pole())\n        except ImportError:\n            print(""Slycot not present, skipping"")\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_tf2ss_robustness(self):\n        """"""Unit test to make sure that tf2ss is working correctly.\n         Source: https://github.com/python-control/python-control/issues/240\n        """"""\n        import control\n        \n        num =  [ [[0], [1]],           [[1],   [0]] ]\n        den1 = [ [[1], [1,1]],         [[1,4], [1]] ]\n        sys1tf = control.tf(num, den1)\n        sys1ss = control.tf2ss(sys1tf)\n\n        # slight perturbation\n        den2 = [ [[1], [1e-10, 1, 1]], [[1,4], [1]] ]\n        sys2tf = control.tf(num, den2)\n        sys2ss = control.tf2ss(sys2tf)\n\n        # Make sure that the poles match for StateSpace and TransferFunction\n        np.testing.assert_array_almost_equal(np.sort(sys1tf.pole()),\n                                             np.sort(sys1ss.pole()))\n        np.testing.assert_array_almost_equal(np.sort(sys2tf.pole()),\n                                             np.sort(sys2ss.pole()))\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestConvert)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/ctrlutil_test.py,15,"b'import unittest\nimport numpy as np\nfrom control.ctrlutil import *\n\nclass TestUtils(unittest.TestCase):\n    def setUp(self):\n        self.mag = np.array([1, 10, 100, 2, 0.1, 0.01])\n        self.db = np.array([0, 20, 40, 6.0205999, -20, -40])\n\n    def check_unwrap_array(self, angle, period=None):\n        if period is None:\n            angle_mod = angle % (2 * np.pi)\n            angle_unwrap = unwrap(angle_mod)\n        else:\n            angle_mod = angle % period\n            angle_unwrap = unwrap(angle_mod, period)\n        np.testing.assert_array_almost_equal(angle_unwrap, angle)\n\n    def test_unwrap_increasing(self):\n        angle = np.linspace(0, 20, 50)\n        self.check_unwrap_array(angle)\n\n    def test_unwrap_decreasing(self):\n        angle = np.linspace(0, -20, 50)\n        self.check_unwrap_array(angle)\n\n    def test_unwrap_inc_degrees(self):\n        angle = np.linspace(0, 720, 50)\n        self.check_unwrap_array(angle, 360)\n\n    def test_unwrap_dec_degrees(self):\n        angle = np.linspace(0, -720, 50)\n        self.check_unwrap_array(angle, 360)\n\n    def test_unwrap_large_skips(self):\n        angle = np.array([0., 4 * np.pi, -2 * np.pi])\n        np.testing.assert_array_almost_equal(unwrap(angle), [0., 0., 0.])\n\n    def test_unwrap_list(self):\n        angle = [0, 2.2, 5.4, -0.4]\n        angle_unwrapped = [0, 0.2, 0.4, 0.6]\n        np.testing.assert_array_almost_equal(unwrap(angle, 1.0), angle_unwrapped)\n\n    def test_db2mag(self):\n        for mag, db in zip(self.mag, self.db):\n            np.testing.assert_almost_equal(mag, db2mag(db))\n\n    def test_db2mag_array(self):\n        mag_array = db2mag(self.db)\n        np.testing.assert_array_almost_equal(mag_array, self.mag)\n\n    def test_mag2db(self):\n        for db, mag in zip(self.db, self.mag):\n            np.testing.assert_almost_equal(db, mag2db(mag))\n\n    def test_mag2db_array(self):\n        db_array = mag2db(self.mag)\n        np.testing.assert_array_almost_equal(db_array, self.db)\n\n\ndef test_suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestUtils)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/delay_test.py,8,"b'#!/usr/bin/env python -*-coding: utf-8-*-\n#\n# Test Pade approx\n#\n# Primitive; ideally test to numerical limits\n\nfrom __future__ import division\n\nimport unittest\n\nimport numpy as np\n\nfrom control.delay import pade\n\n\nclass TestPade(unittest.TestCase):\n\n    # Reference data from Miklos Vajta\'s paper ""Some remarks on\n    # Pad\xc3\xa9-approximations"", Table 1, with corrections.  The\n    # corrections are to highest power coeff in numerator for\n    # (ddeg,ndeg)=(4,3) and (5,4); use Eq (12) in the paper to verify\n\n    # all for T = 1\n    ref = [\n        # dendeg   numdeg   den        num\n        ( 1,       1,       [1,2],     [-1,2]),\n        ( 1,       0,       [1,1],     [1]),\n        ( 2,       2,       [1,6,12],  [1,-6,12]),\n        ( 2,       1,       [1,4,6],   [-2,6]),\n        ( 3,       3,       [1,12,60,120], [-1,12,-60,120]),\n        ( 3,       2,       [1,9,36,60], [3,-24,60]),\n        ( 4,       4,       [1,20,180,840,1680], [1,-20,180,-840,1680]),\n        ( 4,       3,       [1,16,120,480,840], [-4,60,-360,840]),\n        ( 5,       5,       [1,30,420,3360,15120,30240], [-1,30,-420,3360,-15120,30240]),\n        ( 5,       4,       [1,25,300,2100,8400,15120,], [5,-120,1260,-6720,15120]),\n        ]\n\n    def testRefs(self):\n        ""test reference cases for T=1""\n        T = 1\n        for dendeg, numdeg, refden, refnum in self.ref:\n            num, den = pade(T, dendeg, numdeg)\n            np.testing.assert_array_almost_equal_nulp(np.array(refden), den, nulp=2)\n            np.testing.assert_array_almost_equal_nulp(np.array(refnum), num, nulp=2)\n\n    def testTvalues(self):\n        ""test reference cases for T!=1""\n        Ts = [1/53, 21.95]\n        for dendeg, numdeg, baseden, basenum in self.ref:\n            for T in Ts:\n                refden = T**np.arange(dendeg, -1, -1)*baseden\n                refnum = T**np.arange(numdeg, -1, -1)*basenum\n                refnum /= refden[0]\n                refden /= refden[0]\n                num, den = pade(T, dendeg, numdeg)\n                np.testing.assert_array_almost_equal_nulp(refden, den, nulp=2)\n                np.testing.assert_array_almost_equal_nulp(refnum, num, nulp=2)\n\n    def testErrors(self):\n        ""ValueError raised for invalid arguments""\n        self.assertRaises(ValueError,pade,-1,1) # T<0\n        self.assertRaises(ValueError,pade,1,-1) # dendeg < 0\n        self.assertRaises(ValueError,pade,1,2,-3) # numdeg < 0\n        self.assertRaises(ValueError,pade,1,2,3)  # numdeg > dendeg\n\n    def testNumdeg(self):\n        ""numdeg argument follows docs""\n        # trivialish - interface check, not math check\n        T = 1\n        dendeg = 5\n        ref = [pade(T,dendeg,numdeg)\n               for numdeg in range(0,dendeg+1)]\n        testneg = [pade(T,dendeg,numdeg)\n                   for numdeg in range(-dendeg,0)]\n        self.assertEqual(ref[:-1],testneg)\n        self.assertEqual(ref[-1], pade(T,dendeg,dendeg))\n        self.assertEqual(ref[-1], pade(T,dendeg,None))\n        self.assertEqual(ref[-1], pade(T,dendeg))\n\n    def testT0(self):\n        ""T=0 always returns [1],[1]""\n        T = 0\n        refnum = [1.0]\n        refden = [1.0]\n        for dendeg in range(1, 6):\n            for numdeg in range(0, dendeg+1):\n                num, den = pade(T, dendeg, numdeg)\n                np.testing.assert_array_almost_equal_nulp(np.array(refnum), np.array(num))\n                np.testing.assert_array_almost_equal_nulp(np.array(refden), np.array(den))\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/discrete_test.py,14,"b'#!/usr/bin/env python\n#\n# discrete_test.py - test discrete time classes\n# RMM, 9 Sep 2012\n\nimport unittest\nimport numpy as np\nfrom control import *\nfrom control import matlab\n\nclass TestDiscrete(unittest.TestCase):\n    """"""Tests for the DiscreteStateSpace class.""""""\n\n    def setUp(self):\n        """"""Set up a SISO and MIMO system to test operations on.""""""\n\n        # Single input, single output continuous and discrete time systems\n        sys = matlab.rss(3, 1, 1)\n        self.siso_ss1 = StateSpace(sys.A, sys.B, sys.C, sys.D)\n        self.siso_ss1c = StateSpace(sys.A, sys.B, sys.C, sys.D, 0.0)\n        self.siso_ss1d = StateSpace(sys.A, sys.B, sys.C, sys.D, 0.1)\n        self.siso_ss2d = StateSpace(sys.A, sys.B, sys.C, sys.D, 0.2)\n        self.siso_ss3d = StateSpace(sys.A, sys.B, sys.C, sys.D, True)\n\n        # Two input, two output continuous time system\n        A = [[-3., 4., 2.], [-1., -3., 0.], [2., 5., 3.]]\n        B = [[1., 4.], [-3., -3.], [-2., 1.]]\n        C = [[4., 2., -3.], [1., 4., 3.]]\n        D = [[-2., 4.], [0., 1.]]\n        self.mimo_ss1 = StateSpace(A, B, C, D)\n        self.mimo_ss1c = StateSpace(A, B, C, D, 0)\n\n        # Two input, two output discrete time system\n        self.mimo_ss1d = StateSpace(A, B, C, D, 0.1)\n\n        # Same system, but with a different sampling time\n        self.mimo_ss2d = StateSpace(A, B, C, D, 0.2)\n\n        # Single input, single output continuus and discrete transfer function\n        self.siso_tf1 = TransferFunction([1, 1], [1, 2, 1])\n        self.siso_tf1c = TransferFunction([1, 1], [1, 2, 1], 0)\n        self.siso_tf1d = TransferFunction([1, 1], [1, 2, 1], 0.1)\n        self.siso_tf2d = TransferFunction([1, 1], [1, 2, 1], 0.2)\n        self.siso_tf3d = TransferFunction([1, 1], [1, 2, 1], True)\n\n    def testTimebaseEqual(self):\n        self.assertEqual(timebaseEqual(self.siso_ss1, self.siso_tf1), True)\n        self.assertEqual(timebaseEqual(self.siso_ss1, self.siso_ss1c), True)\n        self.assertEqual(timebaseEqual(self.siso_ss1, self.siso_ss1d), True)\n        self.assertEqual(timebaseEqual(self.siso_ss1d, self.siso_ss1c), False)\n        self.assertEqual(timebaseEqual(self.siso_ss1d, self.siso_ss2d), False)\n        self.assertEqual(timebaseEqual(self.siso_ss1d, self.siso_ss3d), False)\n\n    def testSystemInitialization(self):\n        # Check to make sure systems are discrete time with proper variables\n        self.assertEqual(self.siso_ss1.dt, None)\n        self.assertEqual(self.siso_ss1c.dt, 0)\n        self.assertEqual(self.siso_ss1d.dt, 0.1)\n        self.assertEqual(self.siso_ss2d.dt, 0.2)\n        self.assertEqual(self.siso_ss3d.dt, True)\n        self.assertEqual(self.mimo_ss1c.dt, 0)\n        self.assertEqual(self.mimo_ss1d.dt, 0.1)\n        self.assertEqual(self.mimo_ss2d.dt, 0.2)\n        self.assertEqual(self.siso_tf1.dt, None)\n        self.assertEqual(self.siso_tf1c.dt, 0)\n        self.assertEqual(self.siso_tf1d.dt, 0.1)\n        self.assertEqual(self.siso_tf2d.dt, 0.2)\n        self.assertEqual(self.siso_tf3d.dt, True)\n\n    def testCopyConstructor(self):\n        for sys in (self.siso_ss1, self.siso_ss1c, self.siso_ss1d):\n            newsys = StateSpace(sys);\n            self.assertEqual(sys.dt, newsys.dt)\n        for sys in (self.siso_tf1, self.siso_tf1c, self.siso_tf1d):\n            newsys = TransferFunction(sys);\n            self.assertEqual(sys.dt, newsys.dt)\n\n    def test_timebase(self):\n        self.assertEqual(timebase(1), None);\n        self.assertRaises(ValueError, timebase, [1, 2])\n        self.assertEqual(timebase(self.siso_ss1, strict=False), None);\n        self.assertEqual(timebase(self.siso_ss1, strict=True), None);\n        self.assertEqual(timebase(self.siso_ss1c), 0);\n        self.assertEqual(timebase(self.siso_ss1d), 0.1);\n        self.assertEqual(timebase(self.siso_ss2d), 0.2);\n        self.assertEqual(timebase(self.siso_ss3d), True);\n        self.assertEqual(timebase(self.siso_ss3d, strict=False), 1);\n        self.assertEqual(timebase(self.siso_tf1, strict=False), None);\n        self.assertEqual(timebase(self.siso_tf1, strict=True), None);\n        self.assertEqual(timebase(self.siso_tf1c), 0);\n        self.assertEqual(timebase(self.siso_tf1d), 0.1);\n        self.assertEqual(timebase(self.siso_tf2d), 0.2);\n        self.assertEqual(timebase(self.siso_tf3d), True);\n        self.assertEqual(timebase(self.siso_tf3d, strict=False), 1);\n\n    def test_timebase_conversions(self):\n        \'\'\'Check to make sure timebases transfer properly\'\'\'\n        tf1 = TransferFunction([1,1],[1,2,3])       # unspecified\n        tf2 = TransferFunction([1,1],[1,2,3], 0)    # cont time\n        tf3 = TransferFunction([1,1],[1,2,3], True) # dtime, unspec \n        tf4 = TransferFunction([1,1],[1,2,3], 1)    # dtime, dt=1\n\n        # Make sure unspecified timebase is converted correctly\n        self.assertEqual(timebase(tf1*tf1), timebase(tf1))\n        self.assertEqual(timebase(tf1*tf2), timebase(tf2))\n        self.assertEqual(timebase(tf1*tf3), timebase(tf3))\n        self.assertEqual(timebase(tf1*tf4), timebase(tf4))\n        self.assertEqual(timebase(tf2*tf1), timebase(tf2))\n        self.assertEqual(timebase(tf3*tf1), timebase(tf3))\n        self.assertEqual(timebase(tf4*tf1), timebase(tf4))\n        self.assertEqual(timebase(tf1+tf1), timebase(tf1))\n        self.assertEqual(timebase(tf1+tf2), timebase(tf2))\n        self.assertEqual(timebase(tf1+tf3), timebase(tf3))\n        self.assertEqual(timebase(tf1+tf4), timebase(tf4))\n        self.assertEqual(timebase(feedback(tf1, tf1)), timebase(tf1))\n        self.assertEqual(timebase(feedback(tf1, tf2)), timebase(tf2))\n        self.assertEqual(timebase(feedback(tf1, tf3)), timebase(tf3))\n        self.assertEqual(timebase(feedback(tf1, tf4)), timebase(tf4))\n\n        # Make sure discrete time without sampling is converted correctly\n        self.assertEqual(timebase(tf3*tf3), timebase(tf3))\n        self.assertEqual(timebase(tf3*tf4), timebase(tf4))\n        self.assertEqual(timebase(tf3+tf3), timebase(tf3))\n        self.assertEqual(timebase(tf3+tf3), timebase(tf4))\n        self.assertEqual(timebase(feedback(tf3, tf3)), timebase(tf3))\n        self.assertEqual(timebase(feedback(tf3, tf4)), timebase(tf4))\n\n        # Make sure all other combinations are errors\n        try:\n            tf2*tf3             # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        try:\n            tf2*tf4             # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        try:\n            tf2+tf3             # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        try:\n            tf2+tf4             # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        try:\n            feedback(tf2, tf3)  # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        try:\n            feedback(tf2, tf4)   # Error; incompatible timebases\n            raise ValueError(""incompatible operation allowed"")\n        except ValueError:\n            pass\n        \n    def testisdtime(self):\n        # Constant\n        self.assertEqual(isdtime(1), True);\n        self.assertEqual(isdtime(1, strict=True), False);\n\n        # State space\n        self.assertEqual(isdtime(self.siso_ss1), True);\n        self.assertEqual(isdtime(self.siso_ss1, strict=True), False);\n        self.assertEqual(isdtime(self.siso_ss1c), False);\n        self.assertEqual(isdtime(self.siso_ss1c, strict=True), False);\n        self.assertEqual(isdtime(self.siso_ss1d), True);\n        self.assertEqual(isdtime(self.siso_ss1d, strict=True), True);\n        self.assertEqual(isdtime(self.siso_ss3d, strict=True), True);\n\n        # Transfer function\n        self.assertEqual(isdtime(self.siso_tf1), True);\n        self.assertEqual(isdtime(self.siso_tf1, strict=True), False);\n        self.assertEqual(isdtime(self.siso_tf1c), False);\n        self.assertEqual(isdtime(self.siso_tf1c, strict=True), False);\n        self.assertEqual(isdtime(self.siso_tf1d), True);\n        self.assertEqual(isdtime(self.siso_tf1d, strict=True), True);\n        self.assertEqual(isdtime(self.siso_tf3d, strict=True), True);\n\n    def testisctime(self):\n        # Constant\n        self.assertEqual(isctime(1), True);\n        self.assertEqual(isctime(1, strict=True), False);\n\n        # State Space\n        self.assertEqual(isctime(self.siso_ss1), True);\n        self.assertEqual(isctime(self.siso_ss1, strict=True), False);\n        self.assertEqual(isctime(self.siso_ss1c), True);\n        self.assertEqual(isctime(self.siso_ss1c, strict=True), True);\n        self.assertEqual(isctime(self.siso_ss1d), False);\n        self.assertEqual(isctime(self.siso_ss1d, strict=True), False);\n        self.assertEqual(isctime(self.siso_ss3d, strict=True), False);\n\n        # Transfer Function\n        self.assertEqual(isctime(self.siso_tf1), True);\n        self.assertEqual(isctime(self.siso_tf1, strict=True), False);\n        self.assertEqual(isctime(self.siso_tf1c), True);\n        self.assertEqual(isctime(self.siso_tf1c, strict=True), True);\n        self.assertEqual(isctime(self.siso_tf1d), False);\n        self.assertEqual(isctime(self.siso_tf1d, strict=True), False);\n        self.assertEqual(isctime(self.siso_tf3d, strict=True), False);\n\n    def testAddition(self):\n        # State space addition\n        sys = self.siso_ss1 + self.siso_ss1d\n        sys = self.siso_ss1 + self.siso_ss1c\n        sys = self.siso_ss1c + self.siso_ss1\n        sys = self.siso_ss1d + self.siso_ss1\n        sys = self.siso_ss1c + self.siso_ss1c\n        sys = self.siso_ss1d + self.siso_ss1d\n        sys = self.siso_ss3d + self.siso_ss3d\n        self.assertRaises(ValueError, StateSpace.__add__, self.mimo_ss1c,\n                          self.mimo_ss1d)\n        self.assertRaises(ValueError, StateSpace.__add__, self.mimo_ss1d,\n                          self.mimo_ss2d)\n        self.assertRaises(ValueError, StateSpace.__add__, self.siso_ss1d,\n                          self.siso_ss3d)\n\n        # Transfer function addition\n        sys = self.siso_tf1 + self.siso_tf1d\n        sys = self.siso_tf1 + self.siso_tf1c\n        sys = self.siso_tf1c + self.siso_tf1\n        sys = self.siso_tf1d + self.siso_tf1\n        sys = self.siso_tf1c + self.siso_tf1c\n        sys = self.siso_tf1d + self.siso_tf1d\n        sys = self.siso_tf2d + self.siso_tf2d\n        self.assertRaises(ValueError, TransferFunction.__add__, self.siso_tf1c,\n                          self.siso_tf1d)\n        self.assertRaises(ValueError, TransferFunction.__add__, self.siso_tf1d,\n                          self.siso_tf2d)\n        self.assertRaises(ValueError, TransferFunction.__add__, self.siso_tf1d,\n                          self.siso_tf3d)\n\n        # State space + transfer function\n        sys = self.siso_ss1c + self.siso_tf1c\n        sys = self.siso_tf1c + self.siso_ss1c\n        sys = self.siso_ss1d + self.siso_tf1d\n        sys = self.siso_tf1d + self.siso_ss1d\n        self.assertRaises(ValueError, TransferFunction.__add__, self.siso_tf1c,\n                          self.siso_ss1d)\n\n    def testMultiplication(self):\n        # State space addition\n        sys = self.siso_ss1 * self.siso_ss1d\n        sys = self.siso_ss1 * self.siso_ss1c\n        sys = self.siso_ss1c * self.siso_ss1\n        sys = self.siso_ss1d * self.siso_ss1\n        sys = self.siso_ss1c * self.siso_ss1c\n        sys = self.siso_ss1d * self.siso_ss1d\n        self.assertRaises(ValueError, StateSpace.__mul__, self.mimo_ss1c,\n                          self.mimo_ss1d)\n        self.assertRaises(ValueError, StateSpace.__mul__, self.mimo_ss1d,\n                          self.mimo_ss2d)\n        self.assertRaises(ValueError, StateSpace.__mul__, self.siso_ss1d,\n                          self.siso_ss3d)\n\n        # Transfer function addition\n        sys = self.siso_tf1 * self.siso_tf1d\n        sys = self.siso_tf1 * self.siso_tf1c\n        sys = self.siso_tf1c * self.siso_tf1\n        sys = self.siso_tf1d * self.siso_tf1\n        sys = self.siso_tf1c * self.siso_tf1c\n        sys = self.siso_tf1d * self.siso_tf1d\n        self.assertRaises(ValueError, TransferFunction.__mul__, self.siso_tf1c,\n                          self.siso_tf1d)\n        self.assertRaises(ValueError, TransferFunction.__mul__, self.siso_tf1d,\n                          self.siso_tf2d)\n        self.assertRaises(ValueError, TransferFunction.__mul__, self.siso_tf1d,\n                          self.siso_tf3d)\n\n        # State space * transfer function\n        sys = self.siso_ss1c * self.siso_tf1c\n        sys = self.siso_tf1c * self.siso_ss1c\n        sys = self.siso_ss1d * self.siso_tf1d\n        sys = self.siso_tf1d * self.siso_ss1d\n        self.assertRaises(ValueError, TransferFunction.__mul__, self.siso_tf1c,\n                          self.siso_ss1d)\n\n\n    def testFeedback(self):\n        # State space addition\n        sys = feedback(self.siso_ss1, self.siso_ss1d)\n        sys = feedback(self.siso_ss1, self.siso_ss1c)\n        sys = feedback(self.siso_ss1c, self.siso_ss1)\n        sys = feedback(self.siso_ss1d, self.siso_ss1)\n        sys = feedback(self.siso_ss1c, self.siso_ss1c)\n        sys = feedback(self.siso_ss1d, self.siso_ss1d)\n        self.assertRaises(ValueError, feedback, self.mimo_ss1c, self.mimo_ss1d)\n        self.assertRaises(ValueError, feedback, self.mimo_ss1d, self.mimo_ss2d)\n        self.assertRaises(ValueError, feedback, self.siso_ss1d, self.siso_ss3d)\n\n        # Transfer function addition\n        sys = feedback(self.siso_tf1, self.siso_tf1d)\n        sys = feedback(self.siso_tf1, self.siso_tf1c)\n        sys = feedback(self.siso_tf1c, self.siso_tf1)\n        sys = feedback(self.siso_tf1d, self.siso_tf1)\n        sys = feedback(self.siso_tf1c, self.siso_tf1c)\n        sys = feedback(self.siso_tf1d, self.siso_tf1d)\n        self.assertRaises(ValueError, feedback, self.siso_tf1c, self.siso_tf1d)\n        self.assertRaises(ValueError, feedback, self.siso_tf1d, self.siso_tf2d)\n        self.assertRaises(ValueError, feedback, self.siso_tf1d, self.siso_tf3d)\n\n        # State space, transfer function\n        sys = feedback(self.siso_ss1c, self.siso_tf1c)\n        sys = feedback(self.siso_tf1c, self.siso_ss1c)\n        sys = feedback(self.siso_ss1d, self.siso_tf1d)\n        sys = feedback(self.siso_tf1d, self.siso_ss1d)\n        self.assertRaises(ValueError, feedback, self.siso_tf1c, self.siso_ss1d)\n\n    def testSimulation(self):\n        T = range(100)\n        U = np.sin(T)\n\n        # For now, just check calling syntax\n        # TODO: add checks on output of simulations\n        tout, yout = step_response(self.siso_ss1d)\n        tout, yout = step_response(self.siso_ss1d, T)\n        tout, yout = impulse_response(self.siso_ss1d, T)\n        tout, yout = impulse_response(self.siso_ss1d)\n        tout, yout, xout = forced_response(self.siso_ss1d, T, U, 0)\n        tout, yout, xout = forced_response(self.siso_ss2d, T, U, 0)\n        tout, yout, xout = forced_response(self.siso_ss3d, T, U, 0)\n\n    def test_sample_system(self):\n        # Make sure we can convert various types of systems\n        for sysc in (self.siso_tf1, self.siso_tf1c,\n                     self.siso_ss1, self.siso_ss1c,\n                     self.mimo_ss1, self.mimo_ss1c):\n            for method in (""zoh"", ""bilinear"", ""euler"", ""backward_diff""):\n                sysd = sample_system(sysc, 1, method=method)\n                self.assertEqual(sysd.dt, 1)\n\n        # Check ""matched"", defined only for SISO transfer functions\n        for sysc in (self.siso_tf1, self.siso_tf1c):\n            sysd = sample_system(sysc, 1, method=""matched"")\n            self.assertEqual(sysd.dt, 1)\n\n        # Check errors\n        self.assertRaises(ValueError, sample_system, self.siso_ss1d, 1)\n        self.assertRaises(ValueError, sample_system, self.siso_tf1d, 1)\n        self.assertRaises(ValueError, sample_system, self.siso_ss1, 1, \'unknown\')\n\n    def test_sample_ss(self):\n        # double integrators, two different ways\n        sys1 = StateSpace([[0.,1.],[0.,0.]], [[0.],[1.]], [[1.,0.]], 0.)\n        sys2 = StateSpace([[0.,0.],[1.,0.]], [[1.],[0.]], [[0.,1.]], 0.)\n        I = np.eye(2)\n        for sys in (sys1, sys2):\n            for h in (0.1, 0.5, 1, 2):\n                Ad = I + h * sys.A\n                Bd = h * sys.B + 0.5 * h**2 * (sys.A * sys.B)\n                sysd = sample_system(sys, h, method=\'zoh\')\n                np.testing.assert_array_almost_equal(sysd.A, Ad)\n                np.testing.assert_array_almost_equal(sysd.B, Bd)\n                np.testing.assert_array_almost_equal(sysd.C, sys.C)\n                np.testing.assert_array_almost_equal(sysd.D, sys.D)\n                self.assertEqual(sysd.dt, h)\n\n    def test_sample_tf(self):\n        # double integrator\n        sys = TransferFunction(1, [1,0,0])\n        for h in (0.1, 0.5, 1, 2):\n            numd_expected = 0.5 * h**2 * np.array([1.,1.])\n            dend_expected = np.array([1.,-2.,1.])\n            sysd = sample_system(sys, h, method=\'zoh\')\n            self.assertEqual(sysd.dt, h)\n            numd = sysd.num[0][0]\n            dend = sysd.den[0][0]\n            np.testing.assert_array_almost_equal(numd, numd_expected)\n            np.testing.assert_array_almost_equal(dend, dend_expected)\n\n    def test_discrete_bode(self):\n        # Create a simple discrete time system and check the calculation\n        sys = TransferFunction([1], [1, 0.5], 1)\n        omega = [1, 2, 3]\n        mag_out, phase_out, omega_out = bode(sys, omega)\n        H_z = list(map(lambda w: 1./(np.exp(1.j * w) + 0.5), omega))\n        np.testing.assert_array_almost_equal(omega, omega_out)\n        np.testing.assert_array_almost_equal(mag_out, np.absolute(H_z))\n        np.testing.assert_array_almost_equal(phase_out, np.angle(H_z))\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestDiscrete)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/flatsys_test.py,27,"b'#!/usr/bin/env python\n#\n# flatsys_test.py - test flat system module\n# RMM, 29 Jun 2019\n#\n# This test suite checks to make sure that the basic functions supporting\n# differential flat systetms are functioning.  It doesn\'t do exhaustive\n# testing of operations on flat systems.  Separate unit tests should be\n# created for that purpose.\n\nimport unittest\nimport numpy as np\nimport scipy as sp\nimport control as ct\nimport control.flatsys as fs\nfrom distutils.version import StrictVersion\n\n\nclass TestFlatSys(unittest.TestCase):\n    def setUp(self):\n        ct.use_numpy_matrix(False)\n\n    def test_double_integrator(self):\n        # Define a second order integrator\n        sys = ct.StateSpace([[-1, 1], [0, -2]], [[0], [1]], [[1, 0]], 0)\n        flatsys = fs.LinearFlatSystem(sys)\n\n        # Define the endpoints of a trajectory\n        x1 = [0, 0]; u1 = [0]; T1 = 1\n        x2 = [1, 0]; u2 = [0]; T2 = 2\n        x3 = [0, 1]; u3 = [0]; T3 = 3\n        x4 = [1, 1]; u4 = [1]; T4 = 4\n\n        # Define the basis set\n        poly = fs.PolyFamily(6)\n\n        # Plan trajectories for various combinations\n        for x0, u0, xf, uf, Tf in [\n            (x1, u1, x2, u2, T2), (x1, u1, x3, u3, T3), (x1, u1, x4, u4, T4)]:\n            traj = fs.point_to_point(flatsys, x0, u0, xf, uf, Tf, basis=poly)\n\n            # Verify that the trajectory computation is correct\n            x, u = traj.eval([0, Tf])\n            np.testing.assert_array_almost_equal(x0, x[:, 0])\n            np.testing.assert_array_almost_equal(u0, u[:, 0])\n            np.testing.assert_array_almost_equal(xf, x[:, 1])\n            np.testing.assert_array_almost_equal(uf, u[:, 1])\n\n            # Simulate the system and make sure we stay close to desired traj\n            T = np.linspace(0, Tf, 100)\n            xd, ud = traj.eval(T)\n\n            t, y, x = ct.forced_response(sys, T, ud, x0)\n            np.testing.assert_array_almost_equal(x, xd, decimal=3)\n\n    def test_kinematic_car(self):\n        """"""Differential flatness for a kinematic car""""""\n        def vehicle_flat_forward(x, u, params={}):\n            b = params.get(\'wheelbase\', 3.)             # get parameter values\n            zflag = [np.zeros(3), np.zeros(3)]          # list for flag arrays\n            zflag[0][0] = x[0]                          # flat outputs\n            zflag[1][0] = x[1]\n            zflag[0][1] = u[0] * np.cos(x[2])           # first derivatives\n            zflag[1][1] = u[0] * np.sin(x[2])\n            thdot = (u[0]/b) * np.tan(u[1])             # dtheta/dt\n            zflag[0][2] = -u[0] * thdot * np.sin(x[2])  # second derivatives\n            zflag[1][2] =  u[0] * thdot * np.cos(x[2])\n            return zflag\n\n        def vehicle_flat_reverse(zflag, params={}):\n            b = params.get(\'wheelbase\', 3.)             # get parameter values\n            x = np.zeros(3); u = np.zeros(2)            # vectors to store x, u\n            x[0] = zflag[0][0]                          # x position\n            x[1] = zflag[1][0]                          # y position\n            x[2] = np.arctan2(zflag[1][1], zflag[0][1]) # angle\n            u[0] = zflag[0][1] * np.cos(x[2]) + zflag[1][1] * np.sin(x[2])\n            thdot_v = zflag[1][2] * np.cos(x[2]) - zflag[0][2] * np.sin(x[2])\n            u[1] = np.arctan2(thdot_v, u[0]**2 / b)\n            return x, u\n\n        def vehicle_update(t, x, u, params):\n            b = params.get(\'wheelbase\', 3.)             # get parameter values\n            dx = np.array([\n                np.cos(x[2]) * u[0],\n                np.sin(x[2]) * u[0],\n                (u[0]/b) * np.tan(u[1])\n            ])\n            return dx\n\n        def vehicle_output(t, x, u, params): return x\n\n        # Create differentially flat input/output system\n        vehicle_flat = fs.FlatSystem(\n            vehicle_flat_forward, vehicle_flat_reverse, vehicle_update,\n            vehicle_output, inputs=(\'v\', \'delta\'), outputs=(\'x\', \'y\', \'theta\'),\n            states=(\'x\', \'y\', \'theta\'))\n\n        # Define the endpoints of the trajectory\n        x0 = [0., -2., 0.]; u0 = [10., 0.]\n        xf = [100., 2., 0.]; uf = [10., 0.]\n        Tf = 10\n\n        # Define a set of basis functions to use for the trajectories\n        poly = fs.PolyFamily(6)\n\n        # Find trajectory between initial and final conditions\n        traj = fs.point_to_point(vehicle_flat, x0, u0, xf, uf, Tf, basis=poly)\n\n        # Verify that the trajectory computation is correct\n        x, u = traj.eval([0, Tf])\n        np.testing.assert_array_almost_equal(x0, x[:, 0])\n        np.testing.assert_array_almost_equal(u0, u[:, 0])\n        np.testing.assert_array_almost_equal(xf, x[:, 1])\n        np.testing.assert_array_almost_equal(uf, u[:, 1])\n\n        # Simulate the system and make sure we stay close to desired traj\n        T = np.linspace(0, Tf, 500)\n        xd, ud = traj.eval(T)\n\n        # For SciPy 1.0+, integrate equations and compare to desired\n        if StrictVersion(sp.__version__) >= ""1.0"":\n            t, y, x = ct.input_output_response(\n                vehicle_flat, T, ud, x0, return_x=True)\n            np.testing.assert_allclose(x, xd, atol=0.01, rtol=0.01)\n\n    def tearDown(self):\n        ct.reset_defaults()\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestFlatSys)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/frd_test.py,94,"b'#!/usr/bin/env python\n#\n# frd_test.py - test FRD class\n# RvP, 4 Oct 2012\n\n\nimport unittest\nimport sys as pysys\nimport numpy as np\nimport control as ct\nfrom control.statesp import StateSpace\nfrom control.xferfcn import TransferFunction\nfrom control.frdata import FRD, _convertToFRD\nfrom control import bdalg\nfrom control import freqplot\nfrom control.exception import slycot_check\nimport matplotlib.pyplot as plt\n\n\nclass TestFRD(unittest.TestCase):\n    """"""These are tests for functionality and correct reporting of the\n    frequency response data class.""""""\n\n    def testBadInputType(self):\n        """"""Give the constructor invalid input types.""""""\n        self.assertRaises(ValueError, FRD)\n        self.assertRaises(TypeError, FRD, [1])\n\n    def testInconsistentDimension(self):\n        self.assertRaises(TypeError, FRD, [1, 1], [1, 2, 3])\n\n    def testSISOtf(self):\n        # get a SISO transfer function\n        h = TransferFunction([1], [1, 2, 2])\n        omega = np.logspace(-1, 2, 10)\n        frd = FRD(h, omega)\n        assert isinstance(frd, FRD)\n\n        np.testing.assert_array_almost_equal(\n            frd.freqresp([1.0]), h.freqresp([1.0]))\n\n    def testOperators(self):\n        # get two SISO transfer functions\n        h1 = TransferFunction([1], [1, 2, 2])\n        h2 = TransferFunction([1], [0.1, 1])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(h1, omega)\n        f2 = FRD(h2, omega)\n\n        np.testing.assert_array_almost_equal(\n            (f1 + f2).freqresp([0.1, 1.0, 10])[0],\n            (h1 + h2).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1 + f2).freqresp([0.1, 1.0, 10])[1],\n            (h1 + h2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1 - f2).freqresp([0.1, 1.0, 10])[0],\n            (h1 - h2).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1 - f2).freqresp([0.1, 1.0, 10])[1],\n            (h1 - h2).freqresp([0.1, 1.0, 10])[1])\n\n        # multiplication and division\n        np.testing.assert_array_almost_equal(\n            (f1 * f2).freqresp([0.1, 1.0, 10])[1],\n            (h1 * h2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1 / f2).freqresp([0.1, 1.0, 10])[1],\n            (h1 / h2).freqresp([0.1, 1.0, 10])[1])\n\n        # with default conversion from scalar\n        np.testing.assert_array_almost_equal(\n            (f1 * 1.5).freqresp([0.1, 1.0, 10])[1],\n            (h1 * 1.5).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1 / 1.7).freqresp([0.1, 1.0, 10])[1],\n            (h1 / 1.7).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (2.2 * f2).freqresp([0.1, 1.0, 10])[1],\n            (2.2 * h2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (1.3 / f2).freqresp([0.1, 1.0, 10])[1],\n            (1.3 / h2).freqresp([0.1, 1.0, 10])[1])\n\n    def testOperatorsTf(self):\n        # get two SISO transfer functions\n        h1 = TransferFunction([1], [1, 2, 2])\n        h2 = TransferFunction([1], [0.1, 1])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(h1, omega)\n        f2 = FRD(h2, omega)\n        f2  # reference to avoid pyflakes error\n\n        np.testing.assert_array_almost_equal(\n            (f1 + h2).freqresp([0.1, 1.0, 10])[0],\n            (h1 + h2).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1 + h2).freqresp([0.1, 1.0, 10])[1],\n            (h1 + h2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1 - h2).freqresp([0.1, 1.0, 10])[0],\n            (h1 - h2).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1 - h2).freqresp([0.1, 1.0, 10])[1],\n            (h1 - h2).freqresp([0.1, 1.0, 10])[1])\n        # multiplication and division\n        np.testing.assert_array_almost_equal(\n            (f1 * h2).freqresp([0.1, 1.0, 10])[1],\n            (h1 * h2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1 / h2).freqresp([0.1, 1.0, 10])[1],\n            (h1 / h2).freqresp([0.1, 1.0, 10])[1])\n        # the reverse does not work\n\n    def testbdalg(self):\n        # get two SISO transfer functions\n        h1 = TransferFunction([1], [1, 2, 2])\n        h2 = TransferFunction([1], [0.1, 1])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(h1, omega)\n        f2 = FRD(h2, omega)\n\n        np.testing.assert_array_almost_equal(\n            (bdalg.series(f1, f2)).freqresp([0.1, 1.0, 10])[0],\n            (bdalg.series(h1, h2)).freqresp([0.1, 1.0, 10])[0])\n\n        np.testing.assert_array_almost_equal(\n            (bdalg.parallel(f1, f2)).freqresp([0.1, 1.0, 10])[0],\n            (bdalg.parallel(h1, h2)).freqresp([0.1, 1.0, 10])[0])\n\n        np.testing.assert_array_almost_equal(\n            (bdalg.feedback(f1, f2)).freqresp([0.1, 1.0, 10])[0],\n            (bdalg.feedback(h1, h2)).freqresp([0.1, 1.0, 10])[0])\n\n        np.testing.assert_array_almost_equal(\n            (bdalg.negate(f1)).freqresp([0.1, 1.0, 10])[0],\n            (bdalg.negate(h1)).freqresp([0.1, 1.0, 10])[0])\n\n#       append() and connect() not implemented for FRD objects\n#        np.testing.assert_array_almost_equal(\n#            (bdalg.append(f1, f2)).freqresp([0.1, 1.0, 10])[0],\n#            (bdalg.append(h1, h2)).freqresp([0.1, 1.0, 10])[0])\n#\n#        f3 = bdalg.append(f1, f2, f2)\n#        h3 = bdalg.append(h1, h2, h2)\n#        Q = np.mat([ [1, 2], [2, -1] ])\n#        np.testing.assert_array_almost_equal(\n#           (bdalg.connect(f3, Q, [2], [1])).freqresp([0.1, 1.0, 10])[0],\n#            (bdalg.connect(h3, Q, [2], [1])).freqresp([0.1, 1.0, 10])[0])\n\n    def testFeedback(self):\n        h1 = TransferFunction([1], [1, 2, 2])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(h1, omega)\n        np.testing.assert_array_almost_equal(\n            f1.feedback(1).freqresp([0.1, 1.0, 10])[0],\n            h1.feedback(1).freqresp([0.1, 1.0, 10])[0])\n\n        # Make sure default argument also works\n        np.testing.assert_array_almost_equal(\n            f1.feedback().freqresp([0.1, 1.0, 10])[0],\n            h1.feedback().freqresp([0.1, 1.0, 10])[0])\n\n    def testFeedback2(self):\n        h2 = StateSpace([[-1.0, 0], [0, -2.0]], [[0.4], [0.1]],\n                        [[1.0, 0], [0, 1]], [[0.0], [0.0]])\n        # h2.feedback([[0.3, 0.2], [0.1, 0.1]])\n\n    def testAuto(self):\n        omega = np.logspace(-1, 2, 10)\n        f1 = _convertToFRD(1, omega)\n        f2 = _convertToFRD(np.matrix([[1, 0], [0.1, -1]]), omega)\n        f2 = _convertToFRD([[1, 0], [0.1, -1]], omega)\n        f1, f2  # reference to avoid pyflakes error\n\n    def testNyquist(self):\n        h1 = TransferFunction([1], [1, 2, 2])\n        omega = np.logspace(-1, 2, 40)\n        f1 = FRD(h1, omega, smooth=True)\n        freqplot.nyquist(f1, np.logspace(-1, 2, 100))\n        # plt.savefig(\'/dev/null\', format=\'svg\')\n        plt.figure(2)\n        freqplot.nyquist(f1, f1.omega)\n        # plt.savefig(\'/dev/null\', format=\'svg\')\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMO(self):\n        sys = StateSpace([[-0.5, 0.0], [0.0, -1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[0.0, 0.0], [0.0, 0.0]])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(sys, omega)\n        np.testing.assert_array_almost_equal(\n            sys.freqresp([0.1, 1.0, 10])[0],\n            f1.freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            sys.freqresp([0.1, 1.0, 10])[1],\n            f1.freqresp([0.1, 1.0, 10])[1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMOfb(self):\n        sys = StateSpace([[-0.5, 0.0], [0.0, -1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[0.0, 0.0], [0.0, 0.0]])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(sys, omega).feedback([[0.1, 0.3], [0.0, 1.0]])\n        f2 = FRD(sys.feedback([[0.1, 0.3], [0.0, 1.0]]), omega)\n        np.testing.assert_array_almost_equal(\n            f1.freqresp([0.1, 1.0, 10])[0],\n            f2.freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            f1.freqresp([0.1, 1.0, 10])[1],\n            f2.freqresp([0.1, 1.0, 10])[1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMOfb2(self):\n        sys = StateSpace(np.matrix(\'-2.0 0 0; 0 -1 1; 0 0 -3\'),\n                         np.matrix(\'1.0 0; 0 0; 0 1\'),\n                         np.eye(3), np.zeros((3, 2)))\n        omega = np.logspace(-1, 2, 10)\n        K = np.matrix(\'1 0.3 0; 0.1 0 0\')\n        f1 = FRD(sys, omega).feedback(K)\n        f2 = FRD(sys.feedback(K), omega)\n        np.testing.assert_array_almost_equal(\n            f1.freqresp([0.1, 1.0, 10])[0],\n            f2.freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            f1.freqresp([0.1, 1.0, 10])[1],\n            f2.freqresp([0.1, 1.0, 10])[1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMOMult(self):\n        sys = StateSpace([[-0.5, 0.0], [0.0, -1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[0.0, 0.0], [0.0, 0.0]])\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(sys, omega)\n        f2 = FRD(sys, omega)\n        np.testing.assert_array_almost_equal(\n            (f1*f2).freqresp([0.1, 1.0, 10])[0],\n            (sys*sys).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1*f2).freqresp([0.1, 1.0, 10])[1],\n            (sys*sys).freqresp([0.1, 1.0, 10])[1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMOSmooth(self):\n        sys = StateSpace([[-0.5, 0.0], [0.0, -1.0]],\n                         [[1.0, 0.0], [0.0, 1.0]],\n                         [[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]],\n                         [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n        sys2 = np.matrix([[1, 0, 0], [0, 1, 0]]) * sys\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(sys, omega, smooth=True)\n        f2 = FRD(sys2, omega, smooth=True)\n        np.testing.assert_array_almost_equal(\n            (f1*f2).freqresp([0.1, 1.0, 10])[0],\n            (sys*sys2).freqresp([0.1, 1.0, 10])[0])\n        np.testing.assert_array_almost_equal(\n            (f1*f2).freqresp([0.1, 1.0, 10])[1],\n            (sys*sys2).freqresp([0.1, 1.0, 10])[1])\n        np.testing.assert_array_almost_equal(\n            (f1*f2).freqresp([0.1, 1.0, 10])[2],\n            (sys*sys2).freqresp([0.1, 1.0, 10])[2])\n\n    def testAgainstOctave(self):\n        # with data from octave:\n        # sys = ss([-2 0 0; 0 -1 1; 0 0 -3],\n        #  [1 0; 0 0; 0 1], eye(3), zeros(3,2))\n        # bfr = frd(bsys, [1])\n        sys = StateSpace(np.matrix(\'-2.0 0 0; 0 -1 1; 0 0 -3\'),\n                         np.matrix(\'1.0 0; 0 0; 0 1\'),\n                         np.eye(3), np.zeros((3, 2)))\n        omega = np.logspace(-1, 2, 10)\n        f1 = FRD(sys, omega)\n        np.testing.assert_array_almost_equal(\n            (f1.freqresp([1.0])[0] *\n             np.exp(1j*f1.freqresp([1.0])[1])).reshape(3, 2),\n            np.matrix(\'0.4-0.2j 0; 0 0.1-0.2j; 0 0.3-0.1j\'))\n\n    def test_string_representation(self):\n        sys = FRD([1, 2, 3], [4, 5, 6])\n        print(sys)              # Just print without checking\n\n    def test_frequency_mismatch(self):\n        # Overlapping but non-equal frequency ranges\n        sys1 = FRD([1, 2, 3], [4, 5, 6])\n        sys2 = FRD([2, 3, 4], [5, 6, 7])\n        self.assertRaises(NotImplementedError, FRD.__add__, sys1, sys2)\n\n        # One frequency range is a subset of another\n        sys1 = FRD([1, 2, 3], [4, 5, 6])\n        sys2 = FRD([2, 3], [4, 5])\n        self.assertRaises(NotImplementedError, FRD.__add__, sys1, sys2)\n\n    def test_size_mismatch(self):\n        sys1 = FRD(ct.rss(2, 2, 2), np.logspace(-1, 1, 10))\n\n        # Different number of inputs\n        sys2 = FRD(ct.rss(3, 1, 2), np.logspace(-1, 1, 10))\n        self.assertRaises(ValueError, FRD.__add__, sys1, sys2)\n\n        # Different number of outputs\n        sys2 = FRD(ct.rss(3, 2, 1), np.logspace(-1, 1, 10))\n        self.assertRaises(ValueError, FRD.__add__, sys1, sys2)\n\n        # Inputs and outputs don\'t match\n        self.assertRaises(ValueError, FRD.__mul__, sys2, sys1)\n\n        # Feedback mismatch\n        self.assertRaises(ValueError, FRD.feedback, sys2, sys1)\n\n    def test_operator_conversion(self):\n        sys_tf = ct.tf([1], [1, 2, 1])\n        frd_tf = FRD(sys_tf, np.logspace(-1, 1, 10))\n        frd_2 = FRD(2 * np.ones(10), np.logspace(-1, 1, 10))\n\n        # Make sure that we can add, multiply, and feedback constants\n        sys_add = frd_tf + 2\n        chk_add = frd_tf + frd_2\n        np.testing.assert_array_almost_equal(sys_add.omega, chk_add.omega)\n        np.testing.assert_array_almost_equal(sys_add.fresp, chk_add.fresp)\n\n        sys_radd = 2 + frd_tf\n        chk_radd = frd_2 + frd_tf\n        np.testing.assert_array_almost_equal(sys_radd.omega, chk_radd.omega)\n        np.testing.assert_array_almost_equal(sys_radd.fresp, chk_radd.fresp)\n\n        sys_sub = frd_tf - 2\n        chk_sub = frd_tf - frd_2\n        np.testing.assert_array_almost_equal(sys_sub.omega, chk_sub.omega)\n        np.testing.assert_array_almost_equal(sys_sub.fresp, chk_sub.fresp)\n\n        sys_rsub = 2 - frd_tf\n        chk_rsub = frd_2 - frd_tf\n        np.testing.assert_array_almost_equal(sys_rsub.omega, chk_rsub.omega)\n        np.testing.assert_array_almost_equal(sys_rsub.fresp, chk_rsub.fresp)\n\n        sys_mul = frd_tf * 2\n        chk_mul = frd_tf * frd_2\n        np.testing.assert_array_almost_equal(sys_mul.omega, chk_mul.omega)\n        np.testing.assert_array_almost_equal(sys_mul.fresp, chk_mul.fresp)\n\n        sys_rmul = 2 * frd_tf\n        chk_rmul = frd_2 * frd_tf\n        np.testing.assert_array_almost_equal(sys_rmul.omega, chk_rmul.omega)\n        np.testing.assert_array_almost_equal(sys_rmul.fresp, chk_rmul.fresp)\n\n        sys_rdiv = 2 / frd_tf\n        chk_rdiv = frd_2 / frd_tf\n        np.testing.assert_array_almost_equal(sys_rdiv.omega, chk_rdiv.omega)\n        np.testing.assert_array_almost_equal(sys_rdiv.fresp, chk_rdiv.fresp)\n\n        sys_pow = frd_tf**2\n        chk_pow = FRD(sys_tf**2, np.logspace(-1, 1, 10))\n        np.testing.assert_array_almost_equal(sys_pow.omega, chk_pow.omega)\n        np.testing.assert_array_almost_equal(sys_pow.fresp, chk_pow.fresp)\n\n        sys_pow = frd_tf**-2\n        chk_pow = FRD(sys_tf**-2, np.logspace(-1, 1, 10))\n        np.testing.assert_array_almost_equal(sys_pow.omega, chk_pow.omega)\n        np.testing.assert_array_almost_equal(sys_pow.fresp, chk_pow.fresp)\n\n        # Assertion error if we try to raise to a non-integer power\n        self.assertRaises(ValueError, FRD.__pow__, frd_tf, 0.5)\n\n        # Selected testing on transfer function conversion\n        sys_add = frd_2 + sys_tf\n        chk_add = frd_2 + frd_tf\n        np.testing.assert_array_almost_equal(sys_add.omega, chk_add.omega)\n        np.testing.assert_array_almost_equal(sys_add.fresp, chk_add.fresp)\n\n        # Input/output mismatch size mismatch in  rmul\n        sys1 = FRD(ct.rss(2, 2, 2), np.logspace(-1, 1, 10))\n        self.assertRaises(ValueError, FRD.__rmul__, frd_2, sys1)\n\n        # Make sure conversion of something random generates exception\n        self.assertRaises(TypeError,  FRD.__add__, frd_tf, \'string\')\n\n    def test_eval(self):\n        sys_tf = ct.tf([1], [1, 2, 1])\n        frd_tf = FRD(sys_tf, np.logspace(-1, 1, 3))\n        np.testing.assert_almost_equal(sys_tf.evalfr(1), frd_tf.eval(1))\n\n        # Should get an error if we evaluate at an unknown frequency\n        self.assertRaises(ValueError, frd_tf.eval, 2)\n\n    # This test only works in Python 3 due to a conflict with the same\n    # warning type in other test modules (frd_test.py).  See\n    # https://bugs.python.org/issue4180 for more details\n    @unittest.skipIf(pysys.version_info < (3, 0), ""test requires Python 3+"")\n    def test_evalfr_deprecated(self):\n        sys_tf = ct.tf([1], [1, 2, 1])\n        frd_tf = FRD(sys_tf, np.logspace(-1, 1, 3))\n\n        # Deprecated version of the call (should generate warning)\n        import warnings\n        with warnings.catch_warnings():\n            # Make warnings generate an exception\n            warnings.simplefilter(\'error\')\n\n            # Make sure that we get a pending deprecation warning\n            self.assertRaises(PendingDeprecationWarning, frd_tf.evalfr, 1.)\n\n        # FRD.evalfr() is being deprecated\n        import warnings\n        with warnings.catch_warnings():\n            # Make warnings generate an exception\n            warnings.simplefilter(\'error\')\n\n            # Make sure that we get a pending deprecation warning\n            self.assertRaises(PendingDeprecationWarning, frd_tf.evalfr, 1.)\n\n            \ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestFRD)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/freqresp_test.py,21,"b'#!/usr/bin/env python\n#\n# freqresp_test.py - test frequency response functions\n# RMM, 30 May 2016 (based on timeresp_test.py)\n#\n# This is a rudimentary set of tests for frequency response functions,\n# including bode plots.\n\nimport unittest\nimport numpy as np\nimport control as ctrl\nfrom control.statesp import StateSpace\nfrom control.xferfcn import TransferFunction\nfrom control.matlab import ss, tf, bode, rss\nfrom control.exception import slycot_check\nfrom control.tests.margin_test import assert_array_almost_equal\nimport matplotlib.pyplot as plt\n\nclass TestFreqresp(unittest.TestCase):\n   def setUp(self):\n      self.A = np.matrix(\'1,1;0,1\')\n      self.C = np.matrix(\'1,0\')\n      self.omega = np.linspace(10e-2,10e2,1000)\n\n   def test_siso(self):\n      B = np.matrix(\'0;1\')\n      D = 0\n      sys = StateSpace(self.A,B,self.C,D)\n\n      # test frequency response\n      frq=sys.freqresp(self.omega)\n\n      # test bode plot\n      bode(sys)\n\n      # Convert to transfer function and test bode\n      systf = tf(sys)\n      bode(systf)\n\n   def test_superimpose(self):\n      # Test to make sure that multiple calls to plots superimpose their\n      # data on the same axes unless told to do otherwise\n\n      # Generate two plots in a row; should be on the same axes\n      plt.figure(1); plt.clf()\n      ctrl.bode_plot(ctrl.tf([1], [1,2,1]))\n      ctrl.bode_plot(ctrl.tf([5], [1, 1]))\n\n      # Check to make sure there are two axes and that each axes has two lines\n      self.assertEqual(len(plt.gcf().axes), 2)\n      for ax in plt.gcf().axes:\n         # Make sure there are 2 lines in each subplot\n         assert len(ax.get_lines()) == 2\n      \n      # Generate two plots as a list; should be on the same axes\n      plt.figure(2); plt.clf();\n      ctrl.bode_plot([ctrl.tf([1], [1,2,1]), ctrl.tf([5], [1, 1])])\n\n      # Check to make sure there are two axes and that each axes has two lines\n      self.assertEqual(len(plt.gcf().axes), 2)\n      for ax in plt.gcf().axes:\n         # Make sure there are 2 lines in each subplot\n         assert len(ax.get_lines()) == 2\n\n      # Generate two separate plots; only the second should appear\n      plt.figure(3); plt.clf();\n      ctrl.bode_plot(ctrl.tf([1], [1,2,1]))\n      plt.clf()\n      ctrl.bode_plot(ctrl.tf([5], [1, 1]))\n\n      # Check to make sure there are two axes and that each axes has one line\n      self.assertEqual(len(plt.gcf().axes), 2)\n      for ax in plt.gcf().axes:\n         # Make sure there is only 1 line in the subplot\n         assert len(ax.get_lines()) == 1\n\n      # Now add a line to the magnitude plot and make sure if is there\n      for ax in plt.gcf().axes:\n         if ax.get_label() == \'control-bode-magnitude\':\n            break\n      ax.semilogx([1e-2, 1e1], 20 * np.log10([1, 1]), \'k-\')\n      self.assertEqual(len(ax.get_lines()), 2)\n\n   def test_doubleint(self):\n      # 30 May 2016, RMM: added to replicate typecast bug in freqresp.py\n      A = np.matrix(\'0, 1; 0, 0\');\n      B = np.matrix(\'0; 1\');\n      C = np.matrix(\'1, 0\');\n      D = 0;\n      sys = ss(A, B, C, D);\n      bode(sys);\n\n   @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n   def test_mimo(self):\n      # MIMO\n      B = np.matrix(\'1,0;0,1\')\n      D = np.matrix(\'0,0\')\n      sysMIMO = ss(self.A,B,self.C,D)\n\n      frqMIMO = sysMIMO.freqresp(self.omega)\n      tfMIMO = tf(sysMIMO)\n\n      #bode(sysMIMO) # - should throw not implemented exception\n      #bode(tfMIMO) # - should throw not implemented exception\n\n      #plt.figure(3)\n      #plt.semilogx(self.omega,20*np.log10(np.squeeze(frq[0])))\n\n      #plt.figure(4)\n      #bode(sysMIMO,self.omega)\n\n   def test_bode_margin(self):\n      num = [1000]\n      den = [1, 25, 100, 0]\n      sys = ctrl.tf(num, den)\n      plt.figure()\n      ctrl.bode_plot(sys, margins=True,dB=False,deg = True, Hz=False)\n      fig = plt.gcf()\n      allaxes = fig.get_axes()\n\n      mag_to_infinity = (np.array([6.07828691, 6.07828691]),\n                         np.array([1.00000000e+00, 1.00000000e-08]))\n      assert_array_almost_equal(mag_to_infinity, allaxes[0].lines[2].get_data())\n\n      gm_to_infinty = (np.array([10., 10.]), np.array([4.00000000e-01, 1.00000000e-08]))\n      assert_array_almost_equal(gm_to_infinty, allaxes[0].lines[3].get_data())\n\n      one_to_gm = (np.array([10., 10.]), np.array([1., 0.4]))\n      assert_array_almost_equal(one_to_gm, allaxes[0].lines[4].get_data())\n\n      pm_to_infinity = (np.array([6.07828691, 6.07828691]),\n                        np.array([100000., -157.46405841]))\n      assert_array_almost_equal(pm_to_infinity, allaxes[1].lines[2].get_data())\n\n      pm_to_phase = (np.array([6.07828691, 6.07828691]), np.array([-157.46405841, -180.]))\n      assert_array_almost_equal(pm_to_phase, allaxes[1].lines[3].get_data())\n\n      phase_to_infinity = (np.array([10., 10.]), np.array([1.00000000e-08, -1.80000000e+02]))\n      assert_array_almost_equal(phase_to_infinity, allaxes[1].lines[4].get_data())\n\n   def test_discrete(self):\n      # Test discrete time frequency response\n\n      # SISO state space systems with either fixed or unspecified sampling times\n      sys = rss(3, 1, 1)\n      siso_ss1d = StateSpace(sys.A, sys.B, sys.C, sys.D, 0.1)\n      siso_ss2d = StateSpace(sys.A, sys.B, sys.C, sys.D, True)\n\n      # MIMO state space systems with either fixed or unspecified sampling times\n      A = [[-3., 4., 2.], [-1., -3., 0.], [2., 5., 3.]]\n      B = [[1., 4.], [-3., -3.], [-2., 1.]]\n      C = [[4., 2., -3.], [1., 4., 3.]]\n      D = [[-2., 4.], [0., 1.]]\n      mimo_ss1d = StateSpace(A, B, C, D, 0.1)\n      mimo_ss2d = StateSpace(A, B, C, D, True)\n\n      # SISO transfer functions\n      siso_tf1d = TransferFunction([1, 1], [1, 2, 1], 0.1)\n      siso_tf2d = TransferFunction([1, 1], [1, 2, 1], True)\n\n      # Go through each system and call the code, checking return types\n      for sys in (siso_ss1d, siso_ss2d, mimo_ss1d, mimo_ss2d,\n                siso_tf1d, siso_tf2d):\n         # Set frequency range to just below Nyquist freq (for Bode)\n         omega_ok = np.linspace(10e-4,0.99,100) * np.pi/sys.dt\n\n         # Test frequency response\n         ret = sys.freqresp(omega_ok)\n\n         # Check for warning if frequency is out of range\n         import warnings\n         warnings.simplefilter(\'always\', UserWarning)   # don\'t supress\n         with warnings.catch_warnings(record=True) as w:\n            # Set up warnings filter to only show warnings in control module\n            warnings.filterwarnings(""ignore"")\n            warnings.filterwarnings(""always"", module=""control"")\n\n            # Look for a warning about sampling above Nyquist frequency\n            omega_bad = np.linspace(10e-4,1.1,10) * np.pi/sys.dt\n            ret = sys.freqresp(omega_bad)\n            print(""len(w) ="", len(w))\n            self.assertEqual(len(w), 1)\n            self.assertIn(""above"", str(w[-1].message))\n            self.assertIn(""Nyquist"", str(w[-1].message))\n\n         # Test bode plots (currently only implemented for SISO)\n         if (sys.inputs == 1 and sys.outputs == 1):\n            # Generic call (frequency range calculated automatically)\n            ret_ss = bode(sys)\n\n            # Convert to transfer function and test bode again\n            systf = tf(sys);\n            ret_tf = bode(systf)\n\n            # Make sure we can pass a frequency range\n            bode(sys, omega_ok)\n\n         else:\n            # Calling bode should generate a not implemented error\n            self.assertRaises(NotImplementedError, bode, (sys,))\n\n      def test_options(self):\n         """"""Test ability to set parameter values""""""\n      # Generate a Bode plot of a transfer function\n      sys = ctrl.tf([1000], [1, 25, 100, 0])\n      fig1 = plt.figure()\n      ctrl.bode_plot(sys, dB=False, deg = True, Hz=False)\n\n      # Save the parameter values\n      left1, right1 = fig1.axes[0].xaxis.get_data_interval()\n      numpoints1 = len(fig1.axes[0].lines[0].get_data()[0])\n\n      # Same transfer function, but add a decade on each end\n      ctrl.config.set_defaults(\'freqplot\', feature_periphery_decades=2)\n      fig2 = plt.figure()\n      ctrl.bode_plot(sys, dB=False, deg = True, Hz=False)\n      left2, right2 = fig2.axes[0].xaxis.get_data_interval()\n\n      # Make sure we got an extra decade on each end\n      self.assertAlmostEqual(left2, 0.1 * left1)\n      self.assertAlmostEqual(right2, 10 * right1)\n\n      # Same transfer function, but add more points to the plot\n      ctrl.config.set_defaults(\n         \'freqplot\', feature_periphery_decades=2, number_of_samples=13)\n      fig3 = plt.figure()\n      ctrl.bode_plot(sys, dB=False, deg = True, Hz=False)\n      numpoints3 = len(fig3.axes[0].lines[0].get_data()[0])\n\n      # Make sure we got the right number of points\n      self.assertNotEqual(numpoints1, numpoints3)\n      self.assertEqual(numpoints3, 13)\n\n      # Reset default parameters to avoid contamination\n      ctrl.config.reset_defaults()\n\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestTimeresp)\n\nif __name__ == \'__main__\':\n   unittest.main()\n'"
External_Libraries/python_control_master/control/tests/input_element_int_test.py,8,"b'# input_element_int_test.py\n#\n# Author: Kangwon Lee (kangwonlee)\n# Date: 22 Oct 2017\n#\n# Unit tests contributed as part of PR #158, ""SISO tf() may not work\n# with numpy arrays with numpy.int elements""\n#\n# Modified:\n# * 29 Dec 2017, RMM - updated file name and added header\n\nimport unittest\nimport numpy as np\nimport control as ctl\n\nclass TestTfInputIntElement(unittest.TestCase):\n    # currently these do not pass\n    def test_tf_den_with_numpy_int_element(self):\n        num = 1\n        den = np.convolve([1, 2, 1], [1, 1, 1])\n\n        sys = ctl.tf(num, den)\n\n        self.assertAlmostEqual(1.0, ctl.dcgain(sys))\n\n    def test_tf_num_with_numpy_int_element(self):\n        num = np.convolve([1], [1, 1])\n        den = np.convolve([1, 2, 1], [1, 1, 1])\n\n        sys = ctl.tf(num, den)\n\n        self.assertAlmostEqual(1.0, ctl.dcgain(sys))\n\n    # currently these pass\n    def test_tf_input_with_int_element_works(self):\n        num = 1\n        den = np.convolve([1.0, 2, 1], [1, 1, 1])\n\n        sys = ctl.tf(num, den)\n\n        self.assertAlmostEqual(1.0, ctl.dcgain(sys))\n\n    def test_ss_input_with_int_element(self):\n        ident = np.matrix(np.identity(2), dtype=int)\n        a = np.matrix([[0, 1],\n                       [-1, -2]], dtype=int) * ident\n        b = np.matrix([[0],\n                       [1]], dtype=int)\n        c = np.matrix([[0, 1]], dtype=int)\n        d = 0\n\n        sys = ctl.ss(a, b, c, d)\n        sys2 = ctl.ss2tf(sys)\n        self.assertAlmostEqual(ctl.dcgain(sys), ctl.dcgain(sys2))\n'"
External_Libraries/python_control_master/control/tests/iosys_test.py,153,"b'#!/usr/bin/env python\n#\n# iosys_test.py - test input/output system oeprations\n# RMM, 17 Apr 2019\n#\n# This test suite checks to make sure that basic input/output class\n# operations are working.  It doesn\'t do exhaustive testing of\n# operations on input/output systems.  Separate unit tests should be\n# created for that purpose.\n\nimport unittest\nimport warnings\nimport numpy as np\nimport scipy as sp\nimport control as ct\nimport control.iosys as ios\nfrom distutils.version import StrictVersion\n\nclass TestIOSys(unittest.TestCase):\n    def setUp(self):\n        # Turn off numpy matrix warnings\n        import warnings\n        warnings.simplefilter(\'ignore\', category=PendingDeprecationWarning)\n\n        # Create a single input/single output linear system\n        self.siso_linsys = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[0], [1]], [[1, 0]], [[0]])\n\n        # Create a multi input/multi output linear system\n        self.mimo_linsys1 = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[1, 0], [0, 1]],\n            [[1, 0], [0, 1]], np.zeros((2,2)))\n\n        # Create a multi input/multi output linear system\n        self.mimo_linsys2 = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[0, 1], [1, 0]],\n            [[1, 0], [0, 1]], np.zeros((2,2)))\n\n        # Create simulation parameters\n        self.T = np.linspace(0, 10, 100)\n        self.U = np.sin(self.T)\n        self.X0 = [0, 0]\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_linear_iosys(self):\n        # Create an input/output system from the linear system\n        linsys = self.siso_linsys\n        iosys = ios.LinearIOSystem(linsys)\n\n        # Make sure that the right hand side matches linear system\n        for x, u in (([0, 0], 0), ([1, 0], 0), ([0, 1], 0), ([0, 0], 1)):\n            np.testing.assert_array_almost_equal(\n                np.reshape(iosys._rhs(0, x, u), (-1,1)),\n                linsys.A * np.reshape(x, (-1, 1)) + linsys.B * u)\n\n        # Make sure that simulations also line up\n        T, U, X0 = self.T, self.U, self.X0\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_tf2io(self):\n        # Create a transfer function from the state space system\n        linsys = self.siso_linsys\n        tfsys = ct.ss2tf(linsys)\n        iosys = ct.tf2io(tfsys)\n\n        # Verify correctness via simulation\n        T, U, X0 = self.T, self.U, self.X0\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n    def test_ss2io(self):\n        # Create an input/output system from the linear system\n        linsys = self.siso_linsys\n        iosys = ct.ss2io(linsys)\n        np.testing.assert_array_equal(linsys.A, iosys.A)\n        np.testing.assert_array_equal(linsys.B, iosys.B)\n        np.testing.assert_array_equal(linsys.C, iosys.C)\n        np.testing.assert_array_equal(linsys.D, iosys.D)\n\n        # Try adding names to things\n        iosys_named = ct.ss2io(linsys, inputs=\'u\', outputs=\'y\',\n                               states=[\'x1\', \'x2\'], name=\'iosys_named\')\n        self.assertEqual(iosys_named.find_input(\'u\'), 0)\n        self.assertEqual(iosys_named.find_input(\'x\'), None)\n        self.assertEqual(iosys_named.find_output(\'y\'), 0)\n        self.assertEqual(iosys_named.find_output(\'u\'), None)\n        self.assertEqual(iosys_named.find_state(\'x0\'), None)\n        self.assertEqual(iosys_named.find_state(\'x1\'), 0)\n        self.assertEqual(iosys_named.find_state(\'x2\'), 1)\n        np.testing.assert_array_equal(linsys.A, iosys_named.A)\n        np.testing.assert_array_equal(linsys.B, iosys_named.B)\n        np.testing.assert_array_equal(linsys.C, iosys_named.C)\n        np.testing.assert_array_equal(linsys.D, iosys_named.D)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_nonlinear_iosys(self):\n        # Create a simple nonlinear I/O system\n        nlsys = ios.NonlinearIOSystem(predprey)\n        T = self.T\n\n        # Start by simulating from an equilibrium point\n        X0 = [0, 0]\n        ios_t, ios_y = ios.input_output_response(nlsys, T, 0, X0)\n        np.testing.assert_array_almost_equal(ios_y, np.zeros(np.shape(ios_y)))\n\n        # Now simulate from a nonzero point\n        X0 = [0.5, 0.5]\n        ios_t, ios_y = ios.input_output_response(nlsys, T, 0, X0)\n\n        #\n        # Simulate a linear function as a nonlinear function and compare\n        #\n        # Create a single input/single output linear system\n        linsys = self.siso_linsys\n\n        # Create a nonlinear system with the same dynamics\n        nlupd = lambda t, x, u, params: \\\n            np.reshape(linsys.A * np.reshape(x, (-1, 1)) + linsys.B * u, (-1,))\n        nlout = lambda t, x, u, params: \\\n            np.reshape(linsys.C * np.reshape(x, (-1, 1)) + linsys.D * u, (-1,))\n        nlsys = ios.NonlinearIOSystem(nlupd, nlout)\n\n        # Make sure that simulations also line up\n        T, U, X0 = self.T, self.U, self.X0\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(nlsys, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n    def test_linearize(self):\n        # Create a single input/single output linear system\n        linsys = self.siso_linsys\n        iosys = ios.LinearIOSystem(linsys)\n\n        # Linearize it and make sure we get back what we started with\n        linearized = iosys.linearize([0, 0], 0)\n        np.testing.assert_array_almost_equal(linsys.A, linearized.A)\n        np.testing.assert_array_almost_equal(linsys.B, linearized.B)\n        np.testing.assert_array_almost_equal(linsys.C, linearized.C)\n        np.testing.assert_array_almost_equal(linsys.D, linearized.D)\n\n        # Create a simple nonlinear system to check (kinematic car)\n        def kincar_update(t, x, u, params):\n            return np.array([np.cos(x[2]) * u[0], np.sin(x[2]) * u[0], u[1]])\n        def kincar_output(t, x, u, params):\n            return np.array([x[0], x[1]])\n        iosys = ios.NonlinearIOSystem(kincar_update, kincar_output)\n        linearized = iosys.linearize([0, 0, 0], [0, 0])\n        np.testing.assert_array_almost_equal(linearized.A, np.zeros((3,3)))\n        np.testing.assert_array_almost_equal(\n            linearized.B, [[1, 0], [0, 0], [0, 1]])\n        np.testing.assert_array_almost_equal(\n            linearized.C, [[1, 0, 0], [0, 1, 0]])\n        np.testing.assert_array_almost_equal(linearized.D, np.zeros((2,2)))\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_connect(self):\n        # Define a couple of (linear) systems to interconnection\n        linsys1 = self.siso_linsys\n        iosys1 = ios.LinearIOSystem(linsys1)\n        linsys2 = self.siso_linsys\n        iosys2 = ios.LinearIOSystem(linsys2)\n\n        # Connect systems in different ways and compare to StateSpace\n        linsys_series = linsys2 * linsys1\n        iosys_series = ios.InterconnectedSystem(\n            (iosys1, iosys2),   # systems\n            ((1, 0),),          # interconnection (series)\n            0,                  # input = first system\n            1                   # output = second system\n        )\n\n        # Run a simulation and compare to linear response\n        T, U = self.T, self.U\n        X0 = np.concatenate((self.X0, self.X0))\n        ios_t, ios_y, ios_x = ios.input_output_response(\n            iosys_series, T, U, X0, return_x=True)\n        lti_t, lti_y, lti_x = ct.forced_response(linsys_series, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n        # Connect systems with different timebases\n        linsys2c = self.siso_linsys\n        linsys2c.dt = 0         # Reset the timebase\n        iosys2c = ios.LinearIOSystem(linsys2c)\n        iosys_series = ios.InterconnectedSystem(\n            (iosys1, iosys2c),   # systems\n            ((1, 0),),          # interconnection (series)\n            0,                  # input = first system\n            1                   # output = second system\n        )\n        self.assertTrue(ct.isctime(iosys_series, strict=True))\n        ios_t, ios_y, ios_x = ios.input_output_response(\n            iosys_series, T, U, X0, return_x=True)\n        lti_t, lti_y, lti_x = ct.forced_response(linsys_series, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n        # Feedback interconnection\n        linsys_feedback = ct.feedback(linsys1, linsys2)\n        iosys_feedback = ios.InterconnectedSystem(\n            (iosys1, iosys2),   # systems\n            ((1, 0),            # input of sys2 = output of sys1\n             (0, (1, 0, -1))),  # input of sys1 = -output of sys2\n            0,                  # input = first system\n            0                   # output = first system\n        )\n        ios_t, ios_y, ios_x = ios.input_output_response(\n            iosys_feedback, T, U, X0, return_x=True)\n        lti_t, lti_y, lti_x = ct.forced_response(linsys_feedback, T, U, X0)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_static_nonlinearity(self):\n        # Linear dynamical system\n        linsys = self.siso_linsys\n        ioslin = ios.LinearIOSystem(linsys)\n\n        # Nonlinear saturation\n        sat = lambda u: u if abs(u) < 1 else np.sign(u)\n        sat_output = lambda t, x, u, params: sat(u)\n        nlsat =  ios.NonlinearIOSystem(None, sat_output, inputs=1, outputs=1)\n\n        # Set up parameters for simulation\n        T, U, X0 = self.T, 2 * self.U, self.X0\n        Usat = np.vectorize(sat)(U)\n\n        # Make sure saturation works properly by comparing linear system with\n        # saturated input to nonlinear system with saturation composition\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, Usat, X0)\n        ios_t, ios_y, ios_x = ios.input_output_response(\n            ioslin * nlsat, T, U, X0, return_x=True)\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=2)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_algebraic_loop(self):\n        # Create some linear and nonlinear systems to play with\n        linsys = self.siso_linsys\n        lnios = ios.LinearIOSystem(linsys)\n        nlios =  ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1)\n        nlios1 = nlios.copy()\n        nlios2 = nlios.copy()\n\n        # Set up parameters for simulation\n        T, U, X0 = self.T, self.U, self.X0\n\n        # Single nonlinear system - no states \n        ios_t, ios_y = ios.input_output_response(nlios, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, U*U, decimal=3)\n\n        # Composed nonlinear system (series)\n        ios_t, ios_y = ios.input_output_response(nlios1 * nlios2, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, U**4, decimal=3)\n\n        # Composed nonlinear system (parallel)\n        ios_t, ios_y = ios.input_output_response(nlios1 + nlios2, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, 2*U**2, decimal=3)\n\n        # Nonlinear system composed with LTI system (series)\n        ios_t, ios_y = ios.input_output_response(\n            nlios * lnios * nlios, T, U, X0)\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U*U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lti_y*lti_y, decimal=3)\n\n        # Nonlinear system in feeback loop with LTI system\n        iosys = ios.InterconnectedSystem(\n            (lnios, nlios),         # linear system w/ nonlinear feedback\n            ((1,),                  # feedback interconnection (sig to 0)\n             (0, (1, 0, -1))),\n            0,                      # input to linear system\n            0                       # output from linear system\n        )\n        ios_t, ios_y = ios.input_output_response(iosys, T, U, X0)\n        # No easy way to test the result\n\n        # Algebraic loop from static nonlinear system in feedback\n        # (error will be due to no states)\n        iosys = ios.InterconnectedSystem(\n            (nlios1, nlios2),       # two copies of a static nonlinear system\n            ((0, 1),                # feedback interconnection\n             (1, (0, 0, -1))),\n            0, 0\n        )\n        args = (iosys, T, U, X0)\n        self.assertRaises(RuntimeError, ios.input_output_response, *args)\n\n        # Algebraic loop due to feedthrough term\n        linsys = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[0], [1]], [[1, 0]], [[1]])\n        lnios = ios.LinearIOSystem(linsys)\n        iosys = ios.InterconnectedSystem(\n            (nlios, lnios),         # linear system w/ nonlinear feedback\n            ((0, 1),                # feedback interconnection\n             (1, (0, 0, -1))),\n            0, 0\n        )\n        args = (iosys, T, U, X0)\n        # ios_t, ios_y = ios.input_output_response(iosys, T, U, X0)\n        self.assertRaises(RuntimeError, ios.input_output_response, *args)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_summer(self):\n        # Construct a MIMO system for testing\n        linsys = self.mimo_linsys1\n        linio = ios.LinearIOSystem(linsys)\n\n        linsys_parallel = linsys + linsys\n        iosys_parallel = linio + linio\n\n        # Set up parameters for simulation\n        T = self.T\n        U = [np.sin(T), np.cos(T)]\n        X0 = 0\n\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_parallel, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_parallel, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_rmul(self):\n        # Test right multiplication\n        # TODO: replace with better tests when conversions are implemented\n\n        # Set up parameters for simulation\n        T, U, X0 = self.T, self.U, self.X0\n\n        # Linear system with input and output nonlinearities\n        # Also creates a nested interconnected system\n        ioslin = ios.LinearIOSystem(self.siso_linsys)\n        nlios =  ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1)\n        sys1 = nlios * ioslin\n        sys2 = ios.InputOutputSystem.__rmul__(nlios, sys1)\n\n        # Make sure we got the right thing (via simulation comparison)\n        ios_t, ios_y = ios.input_output_response(sys2, T, U, X0)\n        lti_t, lti_y, lti_x = ct.forced_response(ioslin, T, U*U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lti_y*lti_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_neg(self):\n        """"""Test negation of a system""""""\n\n        # Set up parameters for simulation\n        T, U, X0 = self.T, self.U, self.X0\n\n        # Static nonlinear system\n        nlios =  ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1)\n        ios_t, ios_y = ios.input_output_response(-nlios, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, -U*U, decimal=3)\n\n        # Linear system with input nonlinearity\n        # Also creates a nested interconnected system\n        ioslin = ios.LinearIOSystem(self.siso_linsys)\n        sys = (ioslin) * (-nlios)\n\n        # Make sure we got the right thing (via simulation comparison)\n        ios_t, ios_y = ios.input_output_response(sys, T, U, X0)\n        lti_t, lti_y, lti_x = ct.forced_response(ioslin, T, U*U, X0)\n        np.testing.assert_array_almost_equal(ios_y, -lti_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_feedback(self):\n        # Set up parameters for simulation\n        T, U, X0 = self.T, self.U, self.X0\n\n        # Linear system with constant feedback (via ""nonlinear"" mapping)\n        ioslin = ios.LinearIOSystem(self.siso_linsys)\n        nlios =  ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u, inputs=1, outputs=1)\n        iosys = ct.feedback(ioslin, nlios)\n        linsys = ct.feedback(self.siso_linsys, 1)\n\n        ios_t, ios_y = ios.input_output_response(iosys, T, U, X0)\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lti_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_bdalg_functions(self):\n        """"""Test block diagram functions algebra on I/O systems""""""\n        # Set up parameters for simulation\n        T = self.T\n        U = [np.sin(T), np.cos(T)]\n        X0 = 0\n\n        # Set up systems to be composed\n        linsys1 = self.mimo_linsys1\n        linio1 = ios.LinearIOSystem(linsys1)\n        linsys2 = self.mimo_linsys2\n        linio2 = ios.LinearIOSystem(linsys2)\n\n        # Series interconnection\n        linsys_series = ct.series(linsys1, linsys2)\n        iosys_series = ct.series(linio1, linio2)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_series, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_series, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Make sure that systems don\'t commute\n        linsys_series = ct.series(linsys2, linsys1)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_series, T, U, X0)\n        self.assertFalse((np.abs(lin_y - ios_y) < 1e-3).all())\n\n        # Parallel interconnection\n        linsys_parallel = ct.parallel(linsys1, linsys2)\n        iosys_parallel = ct.parallel(linio1, linio2)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_parallel, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_parallel, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Negation\n        linsys_negate = ct.negate(linsys1)\n        iosys_negate = ct.negate(linio1)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_negate, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_negate, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Feedback interconnection\n        linsys_feedback = ct.feedback(linsys1, linsys2)\n        iosys_feedback = ct.feedback(linio1, linio2)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_feedback, T, U, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_feedback, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_nonsquare_bdalg(self):\n        # Set up parameters for simulation\n        T = self.T\n        U2 = [np.sin(T), np.cos(T)]\n        U3 = [np.sin(T), np.cos(T), T]\n        X0 = 0\n\n        # Set up systems to be composed\n        linsys_2i3o = ct.StateSpace(\n            [[-1, 1, 0], [0, -2, 0], [0, 0, -3]], [[1, 0], [0, 1], [1, 1]],\n            [[1, 0, 0], [0, 1, 0], [0, 0, 1]], np.zeros((3, 2)))\n        iosys_2i3o = ios.LinearIOSystem(linsys_2i3o)\n\n        linsys_3i2o = ct.StateSpace(\n            [[-1, 1, 0], [0, -2, 0], [0, 0, -3]],\n            [[1, 0, 0], [0, 1, 0], [0, 0, 1]],\n            [[1, 0, 1], [0, 1, -1]], np.zeros((2, 3)))\n        iosys_3i2o = ios.LinearIOSystem(linsys_3i2o)\n\n        # Multiplication\n        linsys_multiply = linsys_3i2o * linsys_2i3o\n        iosys_multiply = iosys_3i2o * iosys_2i3o\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_multiply, T, U2, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_multiply, T, U2, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        linsys_multiply = linsys_2i3o * linsys_3i2o\n        iosys_multiply = iosys_2i3o * iosys_3i2o\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_multiply, T, U3, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_multiply, T, U3, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Right multiplication\n        # TODO: add real tests once conversion from other types is supported\n        iosys_multiply = ios.InputOutputSystem.__rmul__(iosys_3i2o, iosys_2i3o)\n        ios_t, ios_y = ios.input_output_response(iosys_multiply, T, U3, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Feedback\n        linsys_multiply = ct.feedback(linsys_3i2o, linsys_2i3o)\n        iosys_multiply = iosys_3i2o.feedback(iosys_2i3o)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys_multiply, T, U3, X0)\n        ios_t, ios_y = ios.input_output_response(iosys_multiply, T, U3, X0)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Mismatch should generate exception\n        args = (iosys_3i2o, iosys_3i2o)\n        self.assertRaises(ValueError, ct.series, *args)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_discrete(self):\n        """"""Test discrete time functionality""""""\n        # Create some linear and nonlinear systems to play with\n        linsys = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[0], [1]], [[1, 0]], [[0]], True)\n        lnios = ios.LinearIOSystem(linsys)\n\n        # Set up parameters for simulation\n        T, U, X0 = self.T, self.U, self.X0\n\n        # Simulate and compare to LTI output\n        ios_t, ios_y = ios.input_output_response(lnios, T, U, X0)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_t, lin_t, decimal=3)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n        # Test MIMO system, converted to discrete time\n        linsys = ct.StateSpace(self.mimo_linsys1)\n        linsys.dt = self.T[1] - self.T[0]\n        lnios = ios.LinearIOSystem(linsys)\n\n        # Set up parameters for simulation\n        T = self.T\n        U = [np.sin(T), np.cos(T)]\n        X0 = 0\n\n        # Simulate and compare to LTI output\n        ios_t, ios_y = ios.input_output_response(lnios, T, U, X0)\n        lin_t, lin_y, lin_x = ct.forced_response(linsys, T, U, X0)\n        np.testing.assert_array_almost_equal(ios_t, lin_t, decimal=3)\n        np.testing.assert_array_almost_equal(ios_y, lin_y, decimal=3)\n\n    def test_find_eqpts(self):\n        """"""Test find_eqpt function""""""\n        # Simple equilibrium point with no inputs\n        nlsys = ios.NonlinearIOSystem(predprey)\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys, [1.6, 1.2], None, return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(xeq, [1.64705879, 1.17923874])\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((2,)))\n\n        # Ducted fan dynamics with output = velocity\n        nlsys = ios.NonlinearIOSystem(pvtol, lambda t, x, u, params: x[0:2])\n\n        # Make sure the origin is a fixed point\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys, [0, 0, 0, 0], [0, 4*9.8], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((4,)))\n        np.testing.assert_array_almost_equal(xeq, [0, 0, 0, 0])\n\n        # Use a small lateral force to cause motion\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys, [0, 0, 0, 0], [0.01, 4*9.8], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((4,)), decimal=5)\n\n        # Equilibrium point with fixed output\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys, [0, 0, 0, 0], [0.01, 4*9.8],\n            y0=[0.1, 0.1], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys._out(0, xeq, ueq), [0.1, 0.1], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((4,)), decimal=5)\n\n        # Specify outputs to constrain (replicate previous)\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys, [0, 0, 0, 0], [0.01, 4*9.8], y0=[0.1, 0.1],\n            iy = [0, 1], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys._out(0, xeq, ueq), [0.1, 0.1], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((4,)), decimal=5)\n\n        # Specify inputs to constrain (replicate previous), w/ no result\n        xeq, ueq = ios.find_eqpt(\n            nlsys, [0, 0, 0, 0], [0.01, 4*9.8], y0=[0.1, 0.1], iu = [])\n        np.testing.assert_array_almost_equal(\n            nlsys._out(0, xeq, ueq), [0.1, 0.1], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys._rhs(0, xeq, ueq), np.zeros((4,)), decimal=5)\n\n        # Now solve the problem with the original PVTOL variables\n        # Constrain the output angle and x velocity\n        nlsys_full = ios.NonlinearIOSystem(pvtol_full, None)\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys_full, [0, 0, 0, 0, 0, 0], [0.01, 4*9.8],\n            y0=[0, 0, 0.1, 0.1, 0, 0], iy = [2, 3],\n            idx=[2, 3, 4, 5], ix=[0, 1], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._out(0, xeq, ueq)[[2, 3]], [0.1, 0.1], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._rhs(0, xeq, ueq)[-4:], np.zeros((4,)), decimal=5)\n\n        # Fix one input and vary the other\n        nlsys_full = ios.NonlinearIOSystem(pvtol_full, None)\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys_full, [0, 0, 0, 0, 0, 0], [0.01, 4*9.8],\n            y0=[0, 0, 0.1, 0.1, 0, 0], iy=[3], iu=[1],\n            idx=[2, 3, 4, 5], ix=[0, 1], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_almost_equal(ueq[1], 4*9.8, decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._out(0, xeq, ueq)[[3]], [0.1], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._rhs(0, xeq, ueq)[-4:], np.zeros((4,)), decimal=5)\n\n        # PVTOL with output = y velocity\n        xeq, ueq, result = ios.find_eqpt(\n            nlsys_full, [0, 0, 0, 0.1, 0, 0], [0.01, 4*9.8],\n            y0=[0, 0, 0, 0.1, 0, 0], iy=[3],\n            dx0=[0.1, 0, 0, 0, 0, 0], idx=[1, 2, 3, 4, 5],\n            ix=[0, 1], return_result=True)\n        self.assertTrue(result.success)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._out(0, xeq, ueq)[-3:], [0.1, 0, 0], decimal=5)\n        np.testing.assert_array_almost_equal(\n            nlsys_full._rhs(0, xeq, ueq)[-5:], np.zeros((5,)), decimal=5)\n\n        # Unobservable system\n        linsys = ct.StateSpace(\n            [[-1, 1], [0, -2]], [[0], [1]], [[0, 0]], [[0]])\n        lnios = ios.LinearIOSystem(linsys)\n\n        # If result is returned, user has to check\n        xeq, ueq, result = ios.find_eqpt(\n            lnios, [0, 0], [0], y0=[1], return_result=True)\n        self.assertFalse(result.success)\n\n        # If result is not returned, find_eqpt should return None\n        xeq, ueq = ios.find_eqpt(lnios, [0, 0], [0], y0=[1])\n        self.assertEqual(xeq, None)\n        self.assertEqual(ueq, None)\n\n    @unittest.skipIf(StrictVersion(sp.__version__) < ""1.0"",\n                     ""requires SciPy 1.0 or greater"")\n    def test_params(self):\n        # Start with the default set of parameters\n        ios_secord_default = ios.NonlinearIOSystem(\n            secord_update, secord_output, inputs=1, outputs=1, states=2)\n        lin_secord_default = ios.linearize(ios_secord_default, [0, 0], [0])\n        w_default, v_default = np.linalg.eig(lin_secord_default.A)\n\n        # New copy, with modified parameters\n        ios_secord_update = ios.NonlinearIOSystem(\n            secord_update, secord_output, inputs=1, outputs=1, states=2,\n            params={\'omega0\':2, \'zeta\':0})\n\n        # Make sure the default parameters haven\'t changed\n        lin_secord_check = ios.linearize(ios_secord_default, [0, 0], [0])\n        w, v = np.linalg.eig(lin_secord_check.A)\n        np.testing.assert_array_almost_equal(np.sort(w), np.sort(w_default))\n\n        # Make sure updated system parameters got set correctly\n        lin_secord_update = ios.linearize(ios_secord_update, [0, 0], [0])\n        w, v = np.linalg.eig(lin_secord_update.A)\n        np.testing.assert_array_almost_equal(np.sort(w), np.sort([2j, -2j]))\n\n        # Change the parameters of the default sys just for the linearization\n        lin_secord_local = ios.linearize(ios_secord_default, [0, 0], [0],\n                                          params={\'zeta\':0})\n        w, v = np.linalg.eig(lin_secord_local.A)\n        np.testing.assert_array_almost_equal(np.sort(w), np.sort([1j, -1j]))\n\n        # Change the parameters of the updated sys just for the linearization\n        lin_secord_local = ios.linearize(ios_secord_update, [0, 0], [0],\n                                          params={\'zeta\':0, \'omega0\':3})\n        w, v = np.linalg.eig(lin_secord_local.A)\n        np.testing.assert_array_almost_equal(np.sort(w), np.sort([3j, -3j]))\n\n        # Make sure that changes propagate through interconnections\n        ios_series_default_local = ios_secord_default * ios_secord_update\n        lin_series_default_local = ios.linearize(\n            ios_series_default_local, [0, 0, 0, 0], [0])\n        w, v = np.linalg.eig(lin_series_default_local.A)\n        np.testing.assert_array_almost_equal(\n            np.sort(w), np.sort(np.concatenate((w_default, [2j, -2j]))))\n\n        # Show that we can change the parameters at linearization\n        lin_series_override = ios.linearize(\n            ios_series_default_local, [0, 0, 0, 0], [0],\n            params={\'zeta\':0, \'omega0\':4})\n        w, v = np.linalg.eig(lin_series_override.A)\n        np.testing.assert_array_almost_equal(w, [4j, -4j, 4j, -4j])\n\n        # Check for warning if we try to set params for LinearIOSystem\n        linsys = self.siso_linsys\n        iosys = ios.LinearIOSystem(linsys)\n        T, U, X0 = self.T, self.U, self.X0\n        lti_t, lti_y, lti_x = ct.forced_response(linsys, T, U, X0)\n        with warnings.catch_warnings(record=True) as warnval:\n            # Turn off deprecation warnings\n            warnings.simplefilter(""ignore"", category=DeprecationWarning)\n            warnings.simplefilter(""ignore"", category=PendingDeprecationWarning)\n\n            # Trigger a warning\n            ios_t, ios_y = ios.input_output_response(\n                iosys, T, U, X0, params={\'something\':0})\n\n            # Verify that we got a warning\n            self.assertEqual(len(warnval), 1)\n            self.assertTrue(issubclass(warnval[-1].category, UserWarning))\n            self.assertTrue(""LinearIOSystem"" in str(warnval[-1].message))\n            self.assertTrue(""ignored"" in str(warnval[-1].message))\n\n        # Check to make sure results are OK\n        np.testing.assert_array_almost_equal(lti_t, ios_t)\n        np.testing.assert_array_almost_equal(lti_y, ios_y, decimal=3)\n\n    def test_named_signals(self):\n        sys1 = ios.NonlinearIOSystem(\n            updfcn = lambda t, x, u, params: np.array(\n                np.dot(self.mimo_linsys1.A, np.reshape(x, (-1, 1))) \\\n                + np.dot(self.mimo_linsys1.B, np.reshape(u, (-1, 1)))\n            ).reshape(-1,),\n            outfcn = lambda t, x, u, params: np.array(\n                self.mimo_linsys1.C * np.reshape(x, (-1, 1)) \\\n                + self.mimo_linsys1.D * np.reshape(u, (-1, 1))\n            ).reshape(-1,),\n            inputs = (\'u[0]\', \'u[1]\'),\n            outputs = (\'y[0]\', \'y[1]\'),\n            states = self.mimo_linsys1.states,\n            name = \'sys1\')\n        sys2 = ios.LinearIOSystem(self.mimo_linsys2,\n            inputs = (\'u[0]\', \'u[1]\'),\n            outputs = (\'y[0]\', \'y[1]\'),\n            name = \'sys2\')\n\n        # Series interconnection (sys1 * sys2) using __mul__\n        ios_mul = sys1 * sys2\n        ss_series = self.mimo_linsys1 * self.mimo_linsys2\n        lin_series = ct.linearize(ios_mul, 0, 0)\n        for M, N in ((ss_series.A, lin_series.A), (ss_series.B, lin_series.B),\n                     (ss_series.C, lin_series.C), (ss_series.D, lin_series.D)):\n            np.testing.assert_array_almost_equal(M, N)\n\n        # Series interconnection (sys1 * sys2) using series\n        ios_series = ct.series(sys2, sys1)\n        ss_series = ct.series(self.mimo_linsys2, self.mimo_linsys1)\n        lin_series = ct.linearize(ios_series, 0, 0)\n        for M, N in ((ss_series.A, lin_series.A), (ss_series.B, lin_series.B),\n                     (ss_series.C, lin_series.C), (ss_series.D, lin_series.D)):\n            np.testing.assert_array_almost_equal(M, N)\n\n        # Series interconnection (sys1 * sys2) using named + mixed signals\n        ios_connect = ios.InterconnectedSystem(\n            (sys2, sys1),\n            connections=(\n                ((\'sys1\', \'u[0]\'), \'sys2.y[0]\'),\n                (\'sys1.u[1]\', \'sys2.y[1]\')\n            ),\n            inplist=(\'sys2.u[0]\', (\'sys2\', 1)),\n            outlist=((1, \'y[0]\'), \'sys1.y[1]\')\n        )\n        lin_series = ct.linearize(ios_connect, 0, 0)\n        for M, N in ((ss_series.A, lin_series.A), (ss_series.B, lin_series.B),\n                     (ss_series.C, lin_series.C), (ss_series.D, lin_series.D)):\n            np.testing.assert_array_almost_equal(M, N)\n\n        # Make sure that we can use input signal names as system outputs\n        ios_connect = ios.InterconnectedSystem(\n            (sys1, sys2),\n            connections=(\n                (\'sys2.u[0]\', \'sys1.y[0]\'), (\'sys2.u[1]\', \'sys1.y[1]\'),\n                (\'sys1.u[0]\', \'-sys2.y[0]\'), (\'sys1.u[1]\', \'-sys2.y[1]\')\n            ),\n            inplist=(\'sys1.u[0]\', \'sys1.u[1]\'),\n            outlist=(\'sys2.u[0]\', \'sys2.u[1]\')  # = sys1.y[0], sys1.y[1]\n        )\n        ss_feedback = ct.feedback(self.mimo_linsys1, self.mimo_linsys2)\n        lin_feedback = ct.linearize(ios_connect, 0, 0)\n        np.testing.assert_array_almost_equal(ss_feedback.A, lin_feedback.A)\n        np.testing.assert_array_almost_equal(ss_feedback.B, lin_feedback.B)\n        np.testing.assert_array_almost_equal(ss_feedback.C, lin_feedback.C)\n        np.testing.assert_array_almost_equal(ss_feedback.D, lin_feedback.D)\n\n    def test_lineariosys_statespace(self):\n        """"""Make sure that a LinearIOSystem is also a StateSpace object""""""\n        iosys_siso = ct.LinearIOSystem(self.siso_linsys)\n        self.assertTrue(isinstance(iosys_siso, ct.StateSpace))\n\n        # Make sure that state space functions work for LinearIOSystems\n        np.testing.assert_array_equal(\n            iosys_siso.pole(), self.siso_linsys.pole())\n        omega = np.logspace(.1, 10, 100)\n        mag_io, phase_io, omega_io = iosys_siso.freqresp(omega)\n        mag_ss, phase_ss, omega_ss = self.siso_linsys.freqresp(omega)\n        np.testing.assert_array_equal(mag_io, mag_ss)\n        np.testing.assert_array_equal(phase_io, phase_ss)\n        np.testing.assert_array_equal(omega_io, omega_ss)\n\n        # LinearIOSystem methods should override StateSpace methods\n        io_mul = iosys_siso * iosys_siso\n        self.assertTrue(isinstance(io_mul, ct.InputOutputSystem))\n\n        # But also retain linear structure\n        self.assertTrue(isinstance(io_mul, ct.StateSpace))\n\n        # And make sure the systems match\n        ss_series = self.siso_linsys * self.siso_linsys\n        np.testing.assert_array_equal(io_mul.A, ss_series.A)\n        np.testing.assert_array_equal(io_mul.B, ss_series.B)\n        np.testing.assert_array_equal(io_mul.C, ss_series.C)\n        np.testing.assert_array_equal(io_mul.D, ss_series.D)\n\n        # Make sure that series does the same thing\n        io_series = ct.series(iosys_siso, iosys_siso)\n        self.assertTrue(isinstance(io_series, ct.InputOutputSystem))\n        self.assertTrue(isinstance(io_series, ct.StateSpace))\n        np.testing.assert_array_equal(io_series.A, ss_series.A)\n        np.testing.assert_array_equal(io_series.B, ss_series.B)\n        np.testing.assert_array_equal(io_series.C, ss_series.C)\n        np.testing.assert_array_equal(io_series.D, ss_series.D)\n\n        # Test out feedback as well\n        io_feedback = ct.feedback(iosys_siso, iosys_siso)\n        self.assertTrue(isinstance(io_series, ct.InputOutputSystem))\n\n        # But also retain linear structure\n        self.assertTrue(isinstance(io_series, ct.StateSpace))\n\n        # And make sure the systems match\n        ss_feedback = ct.feedback(self.siso_linsys, self.siso_linsys)\n        np.testing.assert_array_equal(io_feedback.A, ss_feedback.A)\n        np.testing.assert_array_equal(io_feedback.B, ss_feedback.B)\n        np.testing.assert_array_equal(io_feedback.C, ss_feedback.C)\n        np.testing.assert_array_equal(io_feedback.D, ss_feedback.D)\n\n\n    def test_duplicates(self):\n        nlios =  ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1)\n\n        # Turn off deprecation warnings\n        warnings.simplefilter(""ignore"", category=DeprecationWarning)\n        warnings.simplefilter(""ignore"", category=PendingDeprecationWarning)\n\n        # Duplicate objects\n        with warnings.catch_warnings(record=True) as warnval:\n            # Trigger a warning\n            ios_series = nlios * nlios\n\n            # Verify that we got a warning\n            self.assertEqual(len(warnval), 1)\n            self.assertTrue(issubclass(warnval[-1].category, UserWarning))\n            self.assertTrue(""Duplicate object"" in str(warnval[-1].message))\n\n        # Nonduplicate objects\n        nlios1 = nlios.copy()\n        nlios2 = nlios.copy()\n        with warnings.catch_warnings(record=True) as warnval:\n            ios_series = nlios1 * nlios2\n            self.assertEqual(len(warnval), 0)\n\n        # Duplicate names\n        iosys_siso = ct.LinearIOSystem(self.siso_linsys)\n        nlios1 = ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1, name=""sys"")\n        nlios2 = ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1, name=""sys"")\n        with warnings.catch_warnings(record=True) as warnval:\n            # Trigger a warning\n            iosys = ct.InterconnectedSystem(\n                (nlios1, iosys_siso, nlios2), inputs=0, outputs=0, states=0)\n\n            # Verify that we got a warning\n            self.assertEqual(len(warnval), 1)\n            self.assertTrue(issubclass(warnval[-1].category, UserWarning))\n            self.assertTrue(""Duplicate name"" in str(warnval[-1].message))\n\n        # Same system, different names => everything should be OK\n        nlios1 = ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1, name=""nlios1"")\n        nlios2 = ios.NonlinearIOSystem(None, \\\n            lambda t, x, u, params: u*u, inputs=1, outputs=1, name=""nlios2"")\n        with warnings.catch_warnings(record=True) as warnval:\n            iosys = ct.InterconnectedSystem(\n                (nlios1, iosys_siso, nlios2), inputs=0, outputs=0, states=0)\n            self.assertEqual(len(warnval), 0)\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestTimeresp)\n\n\n# Predator prey dynamics\ndef predprey(t, x, u, params={}):\n    r = params.get(\'r\', 2)\n    d = params.get(\'d\', 0.7)\n    b = params.get(\'b\', 0.3)\n    k = params.get(\'k\', 10)\n    a = params.get(\'a\', 8)\n    c = params.get(\'c\', 4)\n\n    # Dynamics for the system\n    dx0 = r * x[0] * (1 - x[0]/k) - a * x[1] * x[0]/(c + x[0])\n    dx1 = b * a * x[1] * x[0] / (c + x[0]) - d * x[1]\n\n    return np.array([dx0, dx1])\n\n\n# Reduced planar vertical takeoff and landing dynamics\ndef pvtol(t, x, u, params={}):\n    from math import sin, cos\n    m = params.get(\'m\', 4.)      # kg, system mass\n    J = params.get(\'J\', 0.0475)  # kg m^2, system inertia \n    r = params.get(\'r\', 0.25)    # m, thrust offset\n    g = params.get(\'g\', 9.8)     # m/s, gravitational constant\n    c = params.get(\'c\', 0.05)    # N s/m, rotational damping\n    l = params.get(\'c\', 0.1)     # m, pivot location\n    return np.array([\n        x[3],\n        -c/m * x[1] + 1/m * cos(x[0]) * u[0] - 1/m * sin(x[0]) * u[1],\n        -g - c/m * x[2] + 1/m * sin(x[0]) * u[0] + 1/m * cos(x[0]) * u[1],\n        -l/J * sin(x[0]) + r/J * u[0]\n    ])\n\ndef pvtol_full(t, x, u, params={}):\n    from math import sin, cos\n    m = params.get(\'m\', 4.)      # kg, system mass\n    J = params.get(\'J\', 0.0475)  # kg m^2, system inertia \n    r = params.get(\'r\', 0.25)    # m, thrust offset\n    g = params.get(\'g\', 9.8)     # m/s, gravitational constant\n    c = params.get(\'c\', 0.05)    # N s/m, rotational damping\n    l = params.get(\'c\', 0.1)     # m, pivot location\n    return np.array([\n        x[3], x[4], x[5],\n        -c/m * x[3] + 1/m * cos(x[2]) * u[0] - 1/m * sin(x[2]) * u[1],\n        -g - c/m * x[4] + 1/m * sin(x[2]) * u[0] + 1/m * cos(x[2]) * u[1],\n        -l/J * sin(x[2]) + r/J * u[0]\n    ])\n\n\n# Second order system dynamics\ndef secord_update(t, x, u, params={}):\n    omega0 = params.get(\'omega0\', 1.)\n    zeta = params.get(\'zeta\', 0.5)\n    u = np.array(u, ndmin=1)\n    return np.array([\n        x[1],\n        -2 * zeta * omega0 * x[1] - omega0*omega0 * x[0] + u[0]\n    ])\ndef secord_output(t, x, u, params={}):\n    return np.array([x[0]])\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/lti_test.py,12,"b'#!/usr/bin/env python\n\nimport unittest\nimport numpy as np\nfrom control.lti import *\nfrom control.xferfcn import tf\nfrom control import c2d\nfrom control.matlab import tf2ss\nfrom control.exception import slycot_check\n\nclass TestUtils(unittest.TestCase):\n    def test_pole(self):\n        sys = tf(126, [-1, 42])\n        np.testing.assert_equal(sys.pole(), 42)\n        np.testing.assert_equal(pole(sys), 42)\n\n    def test_zero(self):\n        sys = tf([-1, 42], [1, 10])\n        np.testing.assert_equal(sys.zero(), 42)\n        np.testing.assert_equal(zero(sys), 42)\n\n    def test_issiso(self):\n        self.assertEqual(issiso(1), True)\n        self.assertRaises(ValueError, issiso, 1, strict=True)\n\n        # SISO transfer function\n        sys = tf([-1, 42], [1, 10])\n        self.assertEqual(issiso(sys), True)\n        self.assertEqual(issiso(sys, strict=True), True)\n\n        # SISO state space system\n        sys = tf2ss(sys)\n        self.assertEqual(issiso(sys), True)\n        self.assertEqual(issiso(sys, strict=True), True)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_issiso_mimo(self):\n        # MIMO transfer function\n        sys = tf([[[-1, 41], [1]], [[1, 2], [3, 4]]],\n                 [[[1, 10], [1, 20]], [[1, 30], [1, 40]]]);\n        self.assertEqual(issiso(sys), False)\n        self.assertEqual(issiso(sys, strict=True), False)\n\n        # MIMO state space system\n        sys = tf2ss(sys)\n        self.assertEqual(issiso(sys), False)\n        self.assertEqual(issiso(sys, strict=True), False)\n\n    def test_damp(self):\n        # Test the continuous time case.\n        zeta = 0.1\n        wn = 42\n        p = -wn * zeta + 1j * wn * np.sqrt(1 - zeta**2)\n        sys = tf(1, [1, 2 * zeta * wn, wn**2])\n        expected = ([wn, wn], [zeta, zeta], [p, p.conjugate()])\n        np.testing.assert_equal(sys.damp(), expected)\n        np.testing.assert_equal(damp(sys), expected)\n\n        # Also test the discrete time case.\n        dt = 0.001\n        sys_dt = c2d(sys, dt, method=\'matched\')\n        p_zplane = np.exp(p*dt)\n        expected_dt = ([wn, wn], [zeta, zeta],\n                       [p_zplane, p_zplane.conjugate()])\n        np.testing.assert_almost_equal(sys_dt.damp(), expected_dt)\n        np.testing.assert_almost_equal(damp(sys_dt), expected_dt)\n\n    def test_dcgain(self):\n        sys = tf(84, [1, 2])\n        np.testing.assert_equal(sys.dcgain(), 42)\n        np.testing.assert_equal(dcgain(sys), 42)\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestUtils)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/margin_test.py,23,"b'#!/usr/bin/env python\n#\n# margin_test.py - test suit for stability margin commands\n# RMM, 15 Jul 2011\n\nfrom __future__ import print_function\nimport unittest\nimport numpy as np\nfrom control.xferfcn import TransferFunction\nfrom control.frdata import FRD\nfrom control.statesp import StateSpace\nfrom control.margins import *\n\ndef assert_array_almost_equal(x, y, ndigit=4):\n\n    x = np.array(x)\n    y = np.array(y)\n    try:\n        if np.isfinite(x).any() and \\\n           np.equal(np.isfinite(x), np.isfinite(y)).all() and \\\n           np.equal(np.isnan(x), np.isnan(y)).all():\n            np.testing.assert_array_almost_equal(\n                x[np.isfinite(x)], y[np.isfinite(y)], ndigit)\n            return\n    except TypeError as e:\n        print(""Error"", e, ""with"", x, ""and"", y)\n        #raise e\n    np.testing.assert_array_almost_equal(x, y, ndigit)\n\nclass TestMargin(unittest.TestCase):\n    """"""These are tests for the margin commands in margin.py.""""""\n\n    def setUp(self):\n        # system, gain margin, gm freq, phase margin, pm freq\n        s = TransferFunction([1, 0], [1])\n        self.tsys = (\n        (TransferFunction([1, 2], [1, 2, 3]),\n         [], [], [], []),\n        (TransferFunction([1], [1, 2, 3, 4]),\n        [2.001], [1.7321], [], []),\n        (StateSpace([[1., 4.], [3., 2.]], [[1.], [-4.]],\n            [[1., 0.]], [[0.]]),\n        [], [], [147.0743], [2.5483]),\n        ((8.75*(4*s**2+0.4*s+1))/((100*s+1)*(s**2+0.22*s+1)) * \n         1./(s**2/(10.**2)+2*0.04*s/10.+1), \n        [2.2716], [10.0053], [97.5941, -157.7904, 134.7359],\n        [0.0850, 0.9373, 1.0919]))\n        \n\n        """"""\n        sys1 = tf([1, 2], [1, 2, 3]);\n        sys2 = tf([1], [1, 2, 3, 4]);\n        sys3 = ss([1, 4; 3, 2], [1; -4], ...\n            [1, 0], [0])\n        s = tf(\'s\')\n        sys4 = (8.75*(4*s^2+0.4*s+1))/((100*s+1)*(s^2+0.22*s+1)) * ...\n                                      1.0/(s^2/(10.0^2)+2*0.04*s/10.0+1);\n        """"""\n\n        self.sys1 = TransferFunction([1, 2], [1, 2, 3])\n        # alternative\n        # sys1 = tf([1, 2], [1, 2, 3])\n        self.sys2 = TransferFunction([1], [1, 2, 3, 4])\n        self.sys3 = StateSpace([[1., 4.], [3., 2.]], [[1.], [-4.]],\n            [[1., 0.]], [[0.]])\n        s = TransferFunction([1, 0], [1])\n        self.sys4 = (8.75*(4*s**2+0.4*s+1))/((100*s+1)*(s**2+0.22*s+1)) * \\\n                                      1./(s**2/(10.**2)+2*0.04*s/10.+1)\n        self.stability_margins4 = \\\n          [2.2716, 97.5941, 0.5591, 10.0053, 0.0850, 9.9918]\n\n        """"""\n        hm1 = s/(s+1);\n        h0 = 1/(s+1)^3;\n        h1 = (s + 0.1)/s/(s+1);\n        h2 = (s + 0.1)/s^2/(s+1);\n        h3 = (s + 0.1)*(s+0.1)/s^3/(s+1);\n        """"""\n        self.types = {\n            \'typem1\': s/(s+1),\n            \'type0\': 1/(s+1)**3,\n            \'type1\': (s + 0.1)/s/(s+1),\n            \'type2\': (s + 0.1)/s**2/(s+1),\n            \'type3\': (s + 0.1)*(s+0.1)/s**3/(s+1) }\n        self.tmargin = ( self.types,\n            dict(sys=\'typem1\', K=2.0, digits=3, result=(\n                float(\'Inf\'), -120.0007, float(\'NaN\'), 0.5774)),\n            dict(sys=\'type0\', K = 0.8, digits=3, result=(\n                10.0014, float(\'inf\'), 1.7322, float(\'nan\'))),\n            dict(sys=\'type0\', K = 2.0, digits=2, result=(\n                4.000,  67.6058,  1.7322,   0.7663)),\n            dict(sys=\'type1\', K=1.0, digits=4, result=(\n                float(\'Inf\'), 144.9032, float(\'NaN\'), 0.3162)),\n            dict(sys=\'type2\', K=1.0, digits=4, result=(\n                float(\'Inf\'), 44.4594, float(\'NaN\'), 0.7907)),\n            dict(sys=\'type3\', K=1.0, digits=3, result=(\n                0.0626, 37.1748, 0.1119, 0.7951)),\n            )\n        \n        \n        # from ""A note on the Gain and Phase Margin Concepts\n        # Journal of Control and Systems Engineering, Yazdan Bavafi-Toosi,\n        # Dec 2015, vol 3 iss 1, pp 51-59\n        #\n        # A cornucopia of tricky systems for phase / gain margin\n        # Still have to convert more to tests + fix margin to handle\n        # also these torture cases\n        """"""\n        % matlab compatible\n        s = tf(\'s\');\n        h21 = 0.002*(s+0.02)*(s+0.05)*(s+5)*(s+10)/( ...\n                (s-0.0005)*(s+0.0001)*(s+0.01)*(s+0.2)*(s+1)*(s+100)^2 );\n        h23 = ((s+0.1)^2 + 1)*(s-0.1)/( ...\n                ((s+0.1)^2+4)*(s+1) );\n        h25a = s/(s^2+2*s+2)^4; h25b = h25a*100;\n        h26a = ((s-0.1)^2 + 1)/( ...\n                (s + 0.1)*((s-0.2)^2 + 4) ) ;\n        h26b = ((s-0.1)^2 + 1)/( ...\n                (s - 0.3)*((s-0.2)^2 + 4) );\n        """"""\n        self.yazdan = {\n            \'example21\' :\n            0.002*(s+0.02)*(s+0.05)*(s+5)*(s+10)/(\n                (s-0.0005)*(s+0.0001)*(s+0.01)*(s+0.2)*(s+1)*(s+100)**2 ),\n            \n            \'example23\' :\n            ((s+0.1)**2 + 1)*(s-0.1)/(\n                ((s+0.1)**2+4)*(s+1) ),\n            \n            \'example25a\' :\n            s/(s**2+2*s+2)**4,\n            \n            \'example26a\' :\n            ((s-0.1)**2 + 1)/(\n                (s + 0.1)*((s-0.2)**2 + 4) ),\n            \n            \'example26b\': ((s-0.1)**2 + 1)/(\n                (s - 0.3)*((s-0.2)**2 + 4) )\n        }\n        self.yazdan[\'example24\'] = self.yazdan[\'example21\']*20000\n        self.yazdan[\'example25b\'] = self.yazdan[\'example25a\']*100\n        self.yazdan[\'example22\'] = self.yazdan[\'example21\']*(s**2 - 2*s + 401)\n        self.ymargin = (\n            dict(sys=\'example21\', K=1.0, digits=2, result=(\n                0.0100,  -14.5640,         0,    0.0022)),\n            dict(sys=\'example21\', K=1000.0, digits=2, result=(\n                0.1793, 22.5215, 0.0243, 0.0630)),\n            dict(sys=\'example21\', K=5000.0, digits=4, result=(\n                4.5596, 21.2101, 0.4385, 0.1868)),\n                    )\n\n        self.yallmargin = (\n            dict(sys=\'example21\', K=1.0, result=(\n                [0.01, 179.2931, 2.2798e+4, 1.5946e+07, 7.2477e+08],\n                [0, 0.0243, 0.4385, 6.8640, 84.9323],\n                [-14.5640],\n                [0.0022]))\n        )\n            \n            \n    def test_stability_margins(self):\n        omega = np.logspace(-2, 2, 2000)\n        for sys,rgm,rwgm,rpm,rwpm in self.tsys:\n            print(sys)\n            out = np.array(stability_margins(sys))\n            gm, pm, sm, wg, wp, ws = out\n            outf = np.array(stability_margins(FRD(sys, omega)))\n            print(out,\'\\n\', outf)\n            #print(out != np.array(None))\n            assert_array_almost_equal(\n                out, outf, 2)\n        # final one with fixed values\n        assert_array_almost_equal(\n            [gm, pm, sm, wg, wp, ws],\n            self.stability_margins4, 3)\n\n    def test_margin(self):\n        gm, pm, wg, wp = margin(self.sys4)\n        assert_array_almost_equal(\n            [gm, pm, wg, wp],\n            self.stability_margins4[:2] + self.stability_margins4[3:5], 3)\n\n        \n    def test_stability_margins_all(self):\n        for sys,rgm,rwgm,rpm,rwpm in self.tsys:\n            out = stability_margins(sys, returnall=True)\n            gm, pm, sm, wg, wp, ws = out\n            print(sys)\n            for res,comp in zip(out, (rgm,rpm,[],rwgm,rwpm,[])):\n                if comp:\n                    print(res, \'\\n\', comp)\n                    assert_array_almost_equal(\n                        res, comp, 2)\n\n    def test_phase_crossover_frequencies(self):\n        omega, gain = phase_crossover_frequencies(self.sys2)\n        assert_array_almost_equal(omega, [1.73205,  0.])\n        assert_array_almost_equal(gain, [-0.5,  0.25])\n\n        tf = TransferFunction([1],[1,1])\n        omega, gain = phase_crossover_frequencies(tf)\n        assert_array_almost_equal(omega, [0.])\n        assert_array_almost_equal(gain, [1.])\n\n        # testing MIMO, only (0,0) element is considered\n        tf = TransferFunction([[[1],[2]],[[3],[4]]],\n                              [[[1, 2, 3, 4],[1,1]],[[1,1],[1,1]]])\n        omega, gain = phase_crossover_frequencies(tf)\n        assert_array_almost_equal(omega, [1.73205081,  0.])\n        assert_array_almost_equal(gain, [-0.5,  0.25])\n\n    def test_mag_phase_omega(self):\n        # test for bug reported in gh-58\n        sys = TransferFunction(15, [1, 6, 11, 6])\n        out = stability_margins(sys)\n        omega = np.logspace(-2,2,1000)\n        mag, phase, omega = sys.freqresp(omega)\n        #print( mag, phase, omega)\n        out2 = stability_margins((mag, phase*180/np.pi, omega))\n        ind = [0,1,3,4]   # indices of gm, pm, wg, wp -- ignore sm\n        marg1 = np.array(out)[ind]\n        marg2 = np.array(out2)[ind]\n        assert_array_almost_equal(marg1, marg2, 4)\n\n    def test_frd(self):\n        f = np.array([0.005, 0.010, 0.020, 0.030, 0.040,\n              0.050, 0.060, 0.070, 0.080, 0.090,\n              0.100, 0.200, 0.300, 0.400, 0.500,\n              0.750, 1.000, 1.250, 1.500, 1.750,\n              2.000, 2.250, 2.500, 2.750, 3.000,\n              3.250, 3.500, 3.750, 4.000, 4.250,\n              4.500, 4.750, 5.000, 6.000, 7.000,\n              8.000, 9.000, 10.000 ])\n        gain = np.array([  0.0,   0.0,   0.0,   0.0,   0.0,\n                        0.0,   0.0,   0.0,   0.0,   0.0,\n                   0.0,   0.1,   0.2,   0.3,   0.5,\n                   0.5,  -0.4,  -2.3,  -4.8,  -7.3,\n                  -9.6, -11.7, -13.6, -15.3, -16.9,\n                 -18.3, -19.6, -20.8, -22.0, -23.1,\n                 -24.1, -25.0, -25.9, -29.1, -31.9,\n                 -34.2, -36.2, -38.1 ])\n        phase = np.array([    0,    -1,    -2,    -3,    -4,\n                     -5,    -6,    -7,    -8,    -9,\n                    -10,   -19,   -29,   -40,   -51,\n                    -81,  -114,  -144,  -168,  -187,\n                   -202,  -214,  -224,  -233,  -240,\n                   -247,  -253,  -259,  -264,  -269,\n                   -273,  -277,  -280,  -292,  -301,\n                   -307,  -313,  -317 ])\n        # calculate response as complex number\n        resp = 10**(gain / 20) * np.exp(1j * phase / (180./np.pi))\n        # frequency response data\n        fresp = FRD(resp, f*2*np.pi, smooth=True)\n        s=TransferFunction([1,0],[1])\n        G=1./(s**2)\n        K=1.\n        C=K*(1+1.9*s)\n        TFopen=fresp*C*G\n        gm, pm, sm, wg, wp, ws = stability_margins(TFopen)\n        assert_array_almost_equal(\n            [pm], [44.55], 2)\n\n    def test_nocross(self):\n        # what happens when no gain/phase crossover?\n        s = TransferFunction([1, 0], [1])\n        h1 = 1/(1+s)\n        h2 = 3*(10+s)/(2+s)\n        h3 = 0.01*(10-s)/(2+s)/(1+s)\n        gm, pm, wm, wg, wp, ws = stability_margins(h1)\n        assert_array_almost_equal(\n            [gm, pm, wg, wp],\n            [float(\'Inf\'), float(\'Inf\'), float(\'NaN\'), float(\'NaN\')]) \n        gm, pm, wm, wg, wp, ws = stability_margins(h2)\n        self.assertEqual(pm, float(\'Inf\'))\n        gm, pm, wm, wg, wp, ws = stability_margins(h3)\n        self.assertTrue(np.isnan(wp))\n        omega = np.logspace(-2,2, 100)\n        out1b = stability_margins(FRD(h1, omega))\n        out2b = stability_margins(FRD(h2, omega))\n        out3b = stability_margins(FRD(h3, omega))\n\n    def test_zmore_margin(self):\n        print(""""""\n        warning, Matlab gives different values (0 and 0) for gain\n        margin of the following system:\n        {type2!s}\n        python-control gives inf\n        difficult to argue which is right? Special case or different\n        approach?\n\n        edge cases, like\n        {type0!s}\n        which approaches a gain of 1 for w -> 0, are also not identically\n        indicated, Matlab gives phase margin -180, at w = 0. for higher or\n        lower gains, results match\n        """""".format(**self.types))\n                \n        sdict = self.tmargin[0]\n        for test in self.tmargin[1:]:\n            res = margin(sdict[test[\'sys\']]*test[\'K\'])\n            print(""more margin {}\\n"".format(sdict[test[\'sys\']]),\n                  res, \'\\n\', test[\'result\'])\n            assert_array_almost_equal(\n                res, test[\'result\'], test[\'digits\'])\n        sdict = self.yazdan\n        for test in self.ymargin:\n            res = margin(sdict[test[\'sys\']]*test[\'K\'])\n            print(""more margin {}\\n"".format(sdict[test[\'sys\']]),\n                  res, \'\\n\', test[\'result\'])\n            assert_array_almost_equal(\n                res, test[\'result\'], test[\'digits\'])\n\ndef test_suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestMargin)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/mateqn_test.py,0,"b'#!/usr/bin/env python\nfrom __future__ import print_function\n#\n# mateqn_test.py - test wuit for matrix equation solvers\n#\n#! Currently uses numpy.testing framework; will dump you out of unittest\n#! if an error occurs.  Should figure out the right way to fix this.\n\n"""""" Test cases for lyap, dlyap, care and dare functions in the file\npyctrl_lin_alg.py. """"""\n\n""""""Copyright (c) 2011, All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions\nare met:\n\n1. Redistributions of source code must retain the above copyright\n   notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright\n   notice, this list of conditions and the following disclaimer in the\n   documentation and/or other materials provided with the distribution.\n\n3. Neither the name of the project author nor the names of its\n   contributors may be used to endorse or promote products derived\n   from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\nFOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CALTECH\nOR THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF\nUSE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGE.\n\nAuthor: Bjorn Olofsson\n""""""\n\nimport unittest\nfrom numpy import matrix\nfrom numpy.testing import assert_array_almost_equal, assert_array_less\n# need scipy version of eigvals for generalized eigenvalue problem\nfrom scipy.linalg import eigvals, solve\nfrom scipy import zeros,dot\nfrom control.mateqn import lyap,dlyap,care,dare\nfrom control.exception import slycot_check\n\n@unittest.skipIf(not slycot_check(), ""slycot not installed"")\nclass TestMatrixEquations(unittest.TestCase):\n    """"""These are tests for the matrix equation solvers in mateqn.py""""""\n\n    def test_lyap(self):\n        A = matrix([[-1, 1],[-1, 0]])\n        Q = matrix([[1,0],[0,1]])\n        X = lyap(A,Q)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X + X * A.T + Q, zeros((2,2)))\n\n        A = matrix([[1, 2],[-3, -4]])\n        Q = matrix([[3, 1],[1, 1]])\n        X = lyap(A,Q)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X + X * A.T + Q, zeros((2,2)))\n\n    def test_lyap_sylvester(self):\n        A = 5\n        B = matrix([[4, 3], [4, 3]])\n        C = matrix([2, 1])\n        X = lyap(A,B,C)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X + X * B + C, zeros((1,2)))\n\n        A = matrix([[2,1],[1,2]])\n        B = matrix([[1,2],[0.5,0.1]])\n        C = matrix([[1,0],[0,1]])\n        X = lyap(A,B,C)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X + X * B + C, zeros((2,2)))\n\n    def test_lyap_g(self):\n        A = matrix([[-1, 2],[-3, -4]])\n        Q = matrix([[3, 1],[1, 1]])\n        E = matrix([[1,2],[2,1]])\n        X = lyap(A,Q,None,E)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * E.T + E * X * A.T + Q, zeros((2,2)))\n\n    def test_dlyap(self):\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[1,0],[0,1]])\n        X = dlyap(A,Q)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * A.T - X + Q, zeros((2,2)))\n\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[3, 1],[1, 1]])\n        X = dlyap(A,Q)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * A.T - X + Q, zeros((2,2)))\n\n    def test_dlyap_g(self):\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[3, 1],[1, 1]])\n        E = matrix([[1, 1],[2, 1]])\n        X = dlyap(A,Q,None,E)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * A.T - E * X * E.T + Q, zeros((2,2)))\n\n    def test_dlyap_sylvester(self):\n        A = 5\n        B = matrix([[4, 3], [4, 3]])\n        C = matrix([2, 1])\n        X = dlyap(A,B,C)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * B.T - X + C, zeros((1,2)))\n\n        A = matrix([[2,1],[1,2]])\n        B = matrix([[1,2],[0.5,0.1]])\n        C = matrix([[1,0],[0,1]])\n        X = dlyap(A,B,C)\n        # print(""The solution obtained is "", X)\n        assert_array_almost_equal(A * X * B.T - X + C, zeros((2,2)))\n\n    def test_care(self):\n        A = matrix([[-2, -1],[-1, -1]])\n        Q = matrix([[0, 0],[0, 1]])\n        B = matrix([[1, 0],[0, 4]])\n\n        X,L,G = care(A,B,Q)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(A.T * X + X * A - X * B * B.T * X + Q,\n                                  zeros((2,2)))\n        assert_array_almost_equal(B.T * X, G)\n\n    def test_care_g(self):\n        A = matrix([[-2, -1],[-1, -1]])\n        Q = matrix([[0, 0],[0, 1]])\n        B = matrix([[1, 0],[0, 4]])\n        R = matrix([[2, 0],[0, 1]])\n        S = matrix([[0, 0],[0, 0]])\n        E = matrix([[2, 1],[1, 2]])\n\n        X,L,G = care(A,B,Q,R,S,E)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * E + E.T * X * A -\n            (E.T * X * B + S) * solve(R, B.T * X * E + S.T)  + Q, zeros((2,2)))\n        assert_array_almost_equal(solve(R, B.T * X * E + S.T), G)\n\n        A = matrix([[-2, -1],[-1, -1]])\n        Q = matrix([[0, 0],[0, 1]])\n        B = matrix([[1],[0]])\n        R = 1\n        S = matrix([[1],[0]])\n        E = matrix([[2, 1],[1, 2]])\n\n        X,L,G = care(A,B,Q,R,S,E)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * E + E.T * X * A -\n            (E.T * X * B + S) / R * (B.T * X * E + S.T) + Q , zeros((2,2)))\n        assert_array_almost_equal(dot( 1/R , dot(B.T,dot(X,E)) + S.T) , G)\n\n    def test_dare(self):\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[2, 1],[1, 0]])\n        B = matrix([[2, 1],[0, 1]])\n        R = matrix([[1, 0],[0, 1]])\n\n        X,L,G = dare(A,B,Q,R)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * A - X -\n            A.T * X * B * solve(B.T * X * B + R, B.T * X * A) + Q, zeros((2,2)))\n        assert_array_almost_equal(solve(B.T * X * B + R, B.T * X * A), G)\n        # check for stable closed loop\n        lam = eigvals(A - B * G)\n        assert_array_less(abs(lam), 1.0)\n\n        A = matrix([[1, 0],[-1, 1]])\n        Q = matrix([[0, 1],[1, 1]])\n        B = matrix([[1],[0]])\n        R = 2\n\n        X,L,G = dare(A,B,Q,R)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * A - X -\n            A.T * X * B * solve(B.T *  X * B + R, B.T * X * A) + Q, zeros((2,2)))\n        assert_array_almost_equal(B.T * X * A / (B.T * X * B + R), G)\n        # check for stable closed loop\n        lam = eigvals(A - B * G)\n        assert_array_less(abs(lam), 1.0)\n\n    def test_dare_g(self):\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[2, 1],[1, 3]])\n        B = matrix([[1, 5],[2, 4]])\n        R = matrix([[1, 0],[0, 1]])\n        S = matrix([[1, 0],[2, 0]])\n        E = matrix([[2, 1],[1, 2]])\n\n        X,L,G = dare(A,B,Q,R,S,E)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * A - E.T * X * E -\n            (A.T * X * B + S) * solve(B.T * X * B + R, B.T * X * A + S.T) + Q,\n            zeros((2,2)) )\n        assert_array_almost_equal(solve(B.T * X * B + R, B.T * X * A + S.T), G)\n        # check for stable closed loop\n        lam = eigvals(A - B * G, E)\n        assert_array_less(abs(lam), 1.0)\n\n        A = matrix([[-0.6, 0],[-0.1, -0.4]])\n        Q = matrix([[2, 1],[1, 3]])\n        B = matrix([[1],[2]])\n        R = 1\n        S = matrix([[1],[2]])\n        E = matrix([[2, 1],[1, 2]])\n\n        X,L,G = dare(A,B,Q,R,S,E)\n        # print(""The solution obtained is"", X)\n        assert_array_almost_equal(\n            A.T * X * A - E.T * X * E -\n            (A.T * X * B + S) * solve(B.T * X * B + R, B.T * X * A + S.T) + Q,\n            zeros((2,2)) )\n        assert_array_almost_equal((B.T * X * A + S.T) / (B.T * X * B + R), G)\n        # check for stable closed loop\n        lam = eigvals(A - B * G, E)\n        assert_array_less(abs(lam), 1.0)\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestMatrixEquations)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/matlab_test.py,125,"b'#!/usr/bin/env python\n#\n# matlab_test.py - test MATLAB compatibility\n# RMM, 30 Mar 2011 (based on TestMatlab from v0.4a)\n#\n# This test suite just goes through and calls all of the MATLAB\n# functions using different systems and arguments to make sure that\n# nothing crashes.  It doesn\'t test actual functionality; the module\n# specific unit tests will do that.\n\nfrom __future__ import print_function\nimport unittest\nimport numpy as np\nfrom scipy.linalg import eigvals\nimport scipy as sp\nfrom control.matlab import *\nfrom control.frdata import FRD\nfrom control.exception import slycot_check\nimport warnings\n\n# for running these through Matlab or Octave\n\'\'\'\nsiso_ss1 = ss([1. -2.; 3. -4.], [5.; 7.], [6. 8.], [0])\n\nsiso_tf1 = tf([1], [1, 2, 1])\nsiso_tf2 = tf([1, 1], [1, 2, 3, 1])\n\nsiso_tf3 = tf(siso_ss1)\nsiso_ss2 = ss(siso_tf2)\nsiso_ss3 = ss(siso_tf3)\nsiso_tf4 = tf(siso_ss2)\n\nA =[ 1. -2. 0.  0.;\n     3. -4. 0.  0.;\n     0.  0. 1. -2.;\n     0.  0. 3. -4. ]\nB = [ 5. 0.;\n      7. 0.;\n      0. 5.;\n      0. 7. ]\nC = [ 6. 8. 0. 0.;\n      0. 0. 6. 8. ]\nD = [ 9. 0.;\n      0. 9. ]\nmimo_ss1 = ss(A, B, C, D)\n\n% all boring, since no cross-over\nmargin(siso_tf1)\nmargin(siso_tf2)\nmargin(siso_ss1)\nmargin(siso_ss2)\n\n% make a bit better\n[gm, pm, gmc, pmc] = margin(siso_ss2*siso_ss2*2)\n\n\'\'\'\n\nclass TestMatlab(unittest.TestCase):\n    def setUp(self):\n        """"""Set up some systems for testing out MATLAB functions""""""\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5.; 7."")\n        C = np.matrix(""6. 8."")\n        D = np.matrix(""9."")\n        self.siso_ss1 = ss(A,B,C,D)\n\n        # Create some transfer functions\n        self.siso_tf1 = tf([1], [1, 2, 1]);\n        self.siso_tf2 = tf([1, 1], [1, 2, 3, 1]);\n\n        # Conversions\n        self.siso_tf3 = tf(self.siso_ss1);\n        self.siso_ss2 = ss(self.siso_tf2);\n        self.siso_ss3 = tf2ss(self.siso_tf3);\n        self.siso_tf4 = ss2tf(self.siso_ss2);\n\n        #Create MIMO system, contains ``siso_ss1`` twice\n        A = np.matrix(""1. -2. 0.  0.;""\n                      ""3. -4. 0.  0.;""\n                      ""0.  0. 1. -2.;""\n                      ""0.  0. 3. -4. "")\n        B = np.matrix(""5. 0.;""\n                      ""7. 0.;""\n                      ""0. 5.;""\n                      ""0. 7. "")\n        C = np.matrix(""6. 8. 0. 0.;""\n                      ""0. 0. 6. 8. "")\n        D = np.matrix(""9. 0.;""\n                      ""0. 9. "")\n        self.mimo_ss1 = ss(A, B, C, D)\n\n        # get consistent test results\n        np.random.seed(0)\n\n    def testParallel(self):\n        sys1 = parallel(self.siso_ss1, self.siso_ss2)\n        sys1 = parallel(self.siso_ss1, self.siso_tf2)\n        sys1 = parallel(self.siso_tf1, self.siso_ss2)\n        sys1 = parallel(1, self.siso_ss2)\n        sys1 = parallel(1, self.siso_tf2)\n        sys1 = parallel(self.siso_ss1, 1)\n        sys1 = parallel(self.siso_tf1, 1)\n\n    def testSeries(self):\n        sys1 = series(self.siso_ss1, self.siso_ss2)\n        sys1 = series(self.siso_ss1, self.siso_tf2)\n        sys1 = series(self.siso_tf1, self.siso_ss2)\n        sys1 = series(1, self.siso_ss2)\n        sys1 = series(1, self.siso_tf2)\n        sys1 = series(self.siso_ss1, 1)\n        sys1 = series(self.siso_tf1, 1)\n\n    def testFeedback(self):\n        sys1 = feedback(self.siso_ss1, self.siso_ss2)\n        sys1 = feedback(self.siso_ss1, self.siso_tf2)\n        sys1 = feedback(self.siso_tf1, self.siso_ss2)\n        sys1 = feedback(1, self.siso_ss2)\n        sys1 = feedback(1, self.siso_tf2)\n        sys1 = feedback(self.siso_ss1, 1)\n        sys1 = feedback(self.siso_tf1, 1)\n\n    def testPoleZero(self):\n        pole(self.siso_ss1);\n        pole(self.siso_tf1);\n        pole(self.siso_tf2);\n        zero(self.siso_ss1);\n        zero(self.siso_tf1);\n        zero(self.siso_tf2);\n\n    def testPZmap(self):\n        # pzmap(self.siso_ss1);         not implemented\n        # pzmap(self.siso_ss2);         not implemented\n        pzmap(self.siso_tf1);\n        pzmap(self.siso_tf2);\n        pzmap(self.siso_tf2, Plot=False);\n\n    def testStep(self):\n        t = np.linspace(0, 1, 10)\n        # Test transfer function\n        yout, tout = step(self.siso_tf1, T=t)\n        youttrue = np.array([0, 0.0057, 0.0213, 0.0446, 0.0739,\n                             0.1075, 0.1443, 0.1832, 0.2235, 0.2642])\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Test SISO system with direct feedthrough\n        sys = self.siso_ss1\n        youttrue = np.array([9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                             42.3227, 44.9694, 47.1599, 48.9776])\n\n        yout, tout = step(sys, T=t)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Play with arguments\n        yout, tout = step(sys, T=t, X0=0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        X0 = np.array([0, 0]);\n        yout, tout = step(sys, T=t, X0=X0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        yout, tout, xout = step(sys, T=t, X0=0, return_x=True)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        if slycot_check():\n            # Test MIMO system, which contains ``siso_ss1`` twice\n            sys = self.mimo_ss1\n            y_00, _t = step(sys, T=t, input=0, output=0)\n            y_11, _t = step(sys, T=t, input=1, output=1)\n            np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n    def testImpulse(self):\n        t = np.linspace(0, 1, 10)\n        # test transfer function\n        yout, tout = impulse(self.siso_tf1, T=t)\n        youttrue = np.array([0., 0.0994, 0.1779, 0.2388, 0.2850, 0.3188,\n                             0.3423, 0.3573, 0.3654, 0.3679])\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # produce a warning for a system with direct feedthrough\n        with warnings.catch_warnings():\n            warnings.simplefilter(""ignore"")\n            #Test SISO system\n            sys = self.siso_ss1\n            youttrue = np.array([86., 70.1808, 57.3753, 46.9975, 38.5766, 31.7344,\n                                 26.1668, 21.6292, 17.9245, 14.8945])\n            yout, tout = impulse(sys, T=t)\n            np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(tout, t)\n\n            # Play with arguments\n            yout, tout = impulse(sys, T=t, X0=0)\n            np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(tout, t)\n\n            X0 = np.array([0, 0]);\n            yout, tout = impulse(sys, T=t, X0=X0)\n            np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(tout, t)\n\n            yout, tout, xout = impulse(sys, T=t, X0=0, return_x=True)\n            np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(tout, t)\n\n            if slycot_check():\n                #Test MIMO system, which contains ``siso_ss1`` twice\n                sys = self.mimo_ss1\n                y_00, _t = impulse(sys, T=t, input=0, output=0)\n                y_11, _t = impulse(sys, T=t, input=1, output=1)\n                np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n                np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n    def testInitial(self):\n        #Test SISO system\n        sys = self.siso_ss1\n        t = np.linspace(0, 1, 10)\n        x0 = np.matrix("".5; 1."")\n        youttrue = np.array([11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                             1.1508, 0.5833, 0.1645, -0.1391])\n        yout, tout = initial(sys, T=t, X0=x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Play with arguments\n        yout, tout, xout = initial(sys, T=t, X0=x0, return_x=True)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        if slycot_check():\n            #Test MIMO system, which contains ``siso_ss1`` twice\n            sys = self.mimo_ss1\n            x0 = np.matrix("".5; 1.; .5; 1."")\n            y_00, _t = initial(sys, T=t, X0=x0, input=0, output=0)\n            y_11, _t = initial(sys, T=t, X0=x0, input=1, output=1)\n            np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n            np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n    def testLsim(self):\n        t = np.linspace(0, 1, 10)\n\n        #compute step response - test with state space, and transfer function\n        #objects\n        u = np.array([1., 1, 1, 1, 1, 1, 1, 1, 1, 1])\n        youttrue = np.array([9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                             42.3227, 44.9694, 47.1599, 48.9776])\n        yout, tout, _xout = lsim(self.siso_ss1, u, t)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n        yout, _t, _xout = lsim(self.siso_tf3, u, t)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n        #test with initial value and special algorithm for ``U=0``\n        u=0\n        x0 = np.matrix("".5; 1."")\n        youttrue = np.array([11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                             1.1508, 0.5833, 0.1645, -0.1391])\n        yout, _t, _xout = lsim(self.siso_ss1, u, t, x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n        if slycot_check():\n            #Test MIMO system, which contains ``siso_ss1`` twice\n            #first system: initial value, second system: step response\n            u = np.array([[0., 1.], [0, 1], [0, 1], [0, 1], [0, 1],\n                          [0, 1], [0, 1], [0, 1], [0, 1], [0, 1]])\n            x0 = np.matrix("".5; 1; 0; 0"")\n            youttrue = np.array([[11., 9.], [8.1494, 17.6457],\n                                 [5.9361, 24.7072], [4.2258, 30.4855],\n                                 [2.9118, 35.2234], [1.9092, 39.1165],\n                                 [1.1508, 42.3227], [0.5833, 44.9694],\n                                 [0.1645, 47.1599], [-0.1391, 48.9776]])\n            yout, _t, _xout = lsim(self.mimo_ss1, u, t, x0)\n            np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n    def testMargin(self):\n        #! TODO: check results to make sure they are OK\n        gm, pm, wg, wp = margin(self.siso_tf1);\n        gm, pm, wg, wp = margin(self.siso_tf2);\n        gm, pm, wg, wp = margin(self.siso_ss1);\n        gm, pm, wg, wp = margin(self.siso_ss2);\n        gm, pm, wg, wp = margin(self.siso_ss2*self.siso_ss2*2);\n        np.testing.assert_array_almost_equal(\n            [gm, pm, wg, wp], [1.5451, 75.9933, 1.2720, 0.6559], decimal=3)\n\n    def testDcgain(self):\n        #Create different forms of a SISO system\n        A, B, C, D = self.siso_ss1.A, self.siso_ss1.B, self.siso_ss1.C, \\\n                     self.siso_ss1.D\n        Z, P, k = sp.signal.ss2zpk(A, B, C, D)\n        num, den = sp.signal.ss2tf(A, B, C, D)\n        sys_ss = self.siso_ss1\n\n        #Compute the gain with ``dcgain``\n        gain_abcd = dcgain(A, B, C, D)\n        gain_zpk = dcgain(Z, P, k)\n        gain_numden = dcgain(np.squeeze(num), den)\n        gain_sys_ss = dcgain(sys_ss)\n        # print(\'\\ngain_abcd:\', gain_abcd, \'gain_zpk:\', gain_zpk)\n        # print(\'gain_numden:\', gain_numden, \'gain_sys_ss:\', gain_sys_ss)\n\n        #Compute the gain with a long simulation\n        t = linspace(0, 1000, 1000)\n        y, _t = step(sys_ss, t)\n        gain_sim = y[-1]\n        # print(\'gain_sim:\', gain_sim)\n\n        #All gain values must be approximately equal to the known gain\n        np.testing.assert_array_almost_equal(\n            [gain_abcd, gain_zpk, gain_numden, gain_sys_ss,\n             gain_sim],\n            [59, 59, 59, 59, 59])\n\n        if slycot_check():\n            # Test with MIMO system, which contains ``siso_ss1`` twice\n            gain_mimo = dcgain(self.mimo_ss1)\n            # print(\'gain_mimo: \\n\', gain_mimo)\n            np.testing.assert_array_almost_equal(gain_mimo, [[59., 0 ],\n                                                             [0,  59.]])\n\n    def testBode(self):\n        bode(self.siso_ss1)\n        bode(self.siso_tf1)\n        bode(self.siso_tf2)\n        (mag, phase, freq) = bode(self.siso_tf2, Plot=False)\n        bode(self.siso_tf1, self.siso_tf2)\n        w = logspace(-3, 3);\n        bode(self.siso_ss1, w)\n        bode(self.siso_ss1, self.siso_tf2, w)\n#       Not yet implemented\n#       bode(self.siso_ss1, \'-\', self.siso_tf1, \'b--\', self.siso_tf2, \'k.\')\n\n    def testRlocus(self):\n        rlocus(self.siso_ss1)\n        rlocus(self.siso_tf1)\n        rlocus(self.siso_tf2)\n        klist = [1, 10, 100]\n        rlist, klist_out = rlocus(self.siso_tf2, klist, Plot=False)\n        np.testing.assert_equal(len(rlist), len(klist))\n        np.testing.assert_array_equal(klist, klist_out)\n\n    def testNyquist(self):\n        nyquist(self.siso_ss1)\n        nyquist(self.siso_tf1)\n        nyquist(self.siso_tf2)\n        w = logspace(-3, 3);\n        nyquist(self.siso_tf2, w)\n        (real, imag, freq) = nyquist(self.siso_tf2, w, Plot=False)\n\n    def testNichols(self):\n        nichols(self.siso_ss1)\n        nichols(self.siso_tf1)\n        nichols(self.siso_tf2)\n        w = logspace(-3, 3);\n        nichols(self.siso_tf2, w)\n        nichols(self.siso_tf2, grid=False)\n\n    def testFreqresp(self):\n        w = logspace(-3, 3)\n        freqresp(self.siso_ss1, w)\n        freqresp(self.siso_ss2, w)\n        freqresp(self.siso_ss3, w)\n        freqresp(self.siso_tf1, w)\n        freqresp(self.siso_tf2, w)\n        freqresp(self.siso_tf3, w)\n\n    def testEvalfr(self):\n        w = 1j\n        np.testing.assert_almost_equal(evalfr(self.siso_ss1, w), 44.8-21.4j)\n        evalfr(self.siso_ss2, w)\n        evalfr(self.siso_ss3, w)\n        evalfr(self.siso_tf1, w)\n        evalfr(self.siso_tf2, w)\n        evalfr(self.siso_tf3, w)\n        if slycot_check():\n            np.testing.assert_array_almost_equal(\n                evalfr(self.mimo_ss1, w),\n                np.array( [[44.8-21.4j, 0.], [0., 44.8-21.4j]]))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testHsvd(self):\n        hsvd(self.siso_ss1)\n        hsvd(self.siso_ss2)\n        hsvd(self.siso_ss3)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testBalred(self):\n        balred(self.siso_ss1, 1)\n        balred(self.siso_ss2, 2)\n        balred(self.siso_ss3, [2, 2])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testModred(self):\n        modred(self.siso_ss1, [1])\n        modred(self.siso_ss2 * self.siso_ss1, [0, 1])\n        modred(self.siso_ss1, [1], \'matchdc\')\n        modred(self.siso_ss1, [1], \'truncate\')\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga(self):\n        place_varga(self.siso_ss1.A, self.siso_ss1.B, [-2, -2])\n\n    def testPlace(self):\n        place(self.siso_ss1.A, self.siso_ss1.B, [-2, -2.5])\n\n    def testAcker(self):\n        acker(self.siso_ss1.A, self.siso_ss1.B, [-2, -2.5])\n\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testLQR(self):\n        (K, S, E) = lqr(self.siso_ss1.A, self.siso_ss1.B, np.eye(2), np.eye(1))\n\n        # Should work if [Q N;N\' R] is positive semi-definite\n        (K, S, E) = lqr(self.siso_ss2.A, self.siso_ss2.B, 10*np.eye(3), \\\n                            np.eye(1), [[1], [1], [2]])\n\n    @unittest.skip(""check not yet implemented"")\n    def testLQR_checks(self):\n        # Make sure we get a warning if [Q N;N\' R] is not positive semi-definite\n        (K, S, E) = lqr(self.siso_ss2.A, self.siso_ss2.B, np.eye(3), \\\n                            np.eye(1), [[1], [1], [2]])\n\n    def testRss(self):\n        rss(1)\n        rss(2)\n        rss(2, 1, 3)\n\n    def testDrss(self):\n        drss(1)\n        drss(2)\n        drss(2, 1, 3)\n\n    def testCtrb(self):\n        ctrb(self.siso_ss1.A, self.siso_ss1.B)\n        ctrb(self.siso_ss2.A, self.siso_ss2.B)\n\n    def testObsv(self):\n        obsv(self.siso_ss1.A, self.siso_ss1.C)\n        obsv(self.siso_ss2.A, self.siso_ss2.C)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGram(self):\n        gram(self.siso_ss1, \'c\')\n        gram(self.siso_ss2, \'c\')\n        gram(self.siso_ss1, \'o\')\n        gram(self.siso_ss2, \'o\')\n\n    def testPade(self):\n        pade(1, 1)\n        pade(1, 2)\n        pade(5, 4)\n\n    def testOpers(self):\n        self.siso_ss1 + self.siso_ss2\n        self.siso_tf1 + self.siso_tf2\n        self.siso_ss1 + self.siso_tf2\n        self.siso_tf1 + self.siso_ss2\n        self.siso_ss1 * self.siso_ss2\n        self.siso_tf1 * self.siso_tf2\n        self.siso_ss1 * self.siso_tf2\n        self.siso_tf1 * self.siso_ss2\n        # self.siso_ss1 / self.siso_ss2         not implemented yet\n        # self.siso_tf1 / self.siso_tf2\n        # self.siso_ss1 / self.siso_tf2\n        # self.siso_tf1 / self.siso_ss2\n\n    def testUnwrap(self):\n        phase = np.array(range(1, 100)) / 10.;\n        wrapped = phase % (2 * np.pi)\n        unwrapped = unwrap(wrapped)\n\n    def testSISOssdata(self):\n        ssdata_1 = ssdata(self.siso_ss2);\n        ssdata_2 = ssdata(self.siso_tf2);\n        for i in range(len(ssdata_1)):\n            np.testing.assert_array_almost_equal(ssdata_1[i], ssdata_2[i])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMIMOssdata(self):\n        m = (self.mimo_ss1.A, self.mimo_ss1.B, self.mimo_ss1.C, self.mimo_ss1.D)\n        ssdata_1 = ssdata(self.mimo_ss1);\n        for i in range(len(ssdata_1)):\n            np.testing.assert_array_almost_equal(ssdata_1[i], m[i])\n\n    def testSISOtfdata(self):\n        tfdata_1 = tfdata(self.siso_tf2);\n        tfdata_2 = tfdata(self.siso_tf2);\n        for i in range(len(tfdata_1)):\n            np.testing.assert_array_almost_equal(tfdata_1[i], tfdata_2[i])\n\n    def testDamp(self):\n        A = np.mat(\'\'\'-0.2  0.06 0    -1;\n               0    0    1     0;\n             -17    0   -3.8   1;\n               9.4  0   -0.4  -0.6\'\'\')\n        B = np.mat(\'\'\'-0.01  0.06;\n               0     0;\n             -32     5.4;\n               2.6  -7\'\'\')\n        C = np.eye(4)\n        D = np.zeros((4,2))\n        sys = ss(A, B, C, D)\n        wn, Z, p = damp(sys, False)\n        # print (wn)\n        np.testing.assert_array_almost_equal(\n            wn, np.array([4.07381994,   3.28874827,   3.28874827,\n                          1.08937685e-03]))\n        np.testing.assert_array_almost_equal(\n            Z, np.array([1.0, 0.07983139,  0.07983139, 1.0]))\n\n    def testConnect(self):\n        sys1 = ss(""1. -2; 3. -4"", ""5.; 7"", ""6, 8"", ""9."")\n        sys2 = ss(""-1."", ""1."", ""1."", ""0."")\n        sys = append(sys1, sys2)\n        Q= np.mat([ [ 1, 2], [2, -1] ]) # basically feedback, output 2 in 1\n        sysc = connect(sys, Q, [2], [1, 2])\n        # print(sysc)\n        np.testing.assert_array_almost_equal(\n            sysc.A, np.mat(\'1 -2 5; 3 -4 7; -6 -8 -10\'))\n        np.testing.assert_array_almost_equal(\n            sysc.B, np.mat(\'0; 0; 1\'))\n        np.testing.assert_array_almost_equal(\n            sysc.C, np.mat(\'6 8 9; 0 0 1\'))\n        np.testing.assert_array_almost_equal(\n            sysc.D, np.mat(\'0; 0\'))\n\n    def testConnect2(self):\n        sys = append(ss([[-5, -2.25], [4, 0]], [[2], [0]],\n                          [[0, 1.125]], [[0]]),\n                       ss([[-1.6667, 0], [1, 0]], [[2], [0]],\n                          [[0, 3.3333]], [[0]]),\n                       1)\n        Q = [ [ 1, 3], [2, 1], [3, -2]]\n        sysc = connect(sys, Q, [3], [3, 1, 2])\n        np.testing.assert_array_almost_equal(\n            sysc.A, np.mat([[-5, -2.25, 0, -6.6666],\n                            [4, 0, 0, 0],\n                            [0, 2.25, -1.6667, 0],\n                            [0, 0, 1, 0]]))\n        np.testing.assert_array_almost_equal(\n            sysc.B, np.mat([[2], [0], [0], [0]]))\n        np.testing.assert_array_almost_equal(\n            sysc.C, np.mat([[0, 0, 0, -3.3333],\n                            [0, 1.125, 0, 0],\n                            [0, 0, 0, 3.3333]]))\n        np.testing.assert_array_almost_equal(\n            sysc.D, np.mat([[1], [0], [0]]))\n\n\n\n    def testFRD(self):\n        h = tf([1], [1, 2, 2])\n        omega = np.logspace(-1, 2, 10)\n        frd1 = frd(h, omega)\n        assert isinstance(frd1, FRD)\n        frd2 = frd(frd1.fresp[0,0,:], omega)\n        assert isinstance(frd2, FRD)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMinreal(self, verbose=False):\n        """"""Test a minreal model reduction""""""\n        #A = [-2, 0.5, 0; 0.5, -0.3, 0; 0, 0, -0.1]\n        A = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        #B = [0.3, -1.3; 0.1, 0; 1, 0]\n        B = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        #C = [0, 0.1, 0; -0.3, -0.2, 0]\n        C = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        #D = [0 -0.8; -0.3 0]\n        D = [[0., -0.8], [-0.3, 0.]]\n        # sys = ss(A, B, C, D)\n\n        sys = ss(A, B, C, D)\n        sysr = minreal(sys, verbose=verbose)\n        self.assertEqual(sysr.states, 2)\n        self.assertEqual(sysr.inputs, sys.inputs)\n        self.assertEqual(sysr.outputs, sys.outputs)\n        np.testing.assert_array_almost_equal(\n            eigvals(sysr.A), [-2.136154, -0.1638459])\n\n        s = tf([1, 0], [1])\n        h = (s+1)*(s+2.00000000001)/(s+2)/(s**2+s+1)\n        hm = minreal(h, verbose=verbose)\n        hr = (s+1)/(s**2+s+1)\n        np.testing.assert_array_almost_equal(hm.num[0][0], hr.num[0][0])\n        np.testing.assert_array_almost_equal(hm.den[0][0], hr.den[0][0])\n\n    def testSS2cont(self):\n        sys = ss(\n            np.mat(""-3 4 2; -1 -3 0; 2 5 3""),\n            np.mat(""1 4 ; -3 -3; -2 1""),\n            np.mat(""4 2 -3; 1 4 3""),\n            np.mat(""-2 4; 0 1""))\n        sysd = c2d(sys, 0.1)\n        np.testing.assert_array_almost_equal(\n            np.mat(\n                """"""0.742840837331905  0.342242024293711  0.203124211149560;\n                  -0.074130792143890  0.724553295044645 -0.009143771143630;\n                   0.180264783290485  0.544385612448419  1.370501013067845""""""),\n            sysd.A)\n        np.testing.assert_array_almost_equal(\n            np.mat("""""" 0.012362066084719   0.301932197918268;\n                      -0.260952977031384  -0.274201791021713;\n                      -0.304617775734327   0.075182622718853""""""), sysd.B)\n\n    def testCombi01(self):\n        # test from a ""real"" case, combines tf, ss, connect and margin\n        # this is a type 2 system, with phase starting at -180. The\n        # margin command should remove the solution for w = nearly zero\n\n        # Example is a concocted two-body satellite with flexible link\n        Jb = 400;\n        Jp = 1000;\n        k = 10;\n        b = 5;\n\n        # can now define an ""s"" variable, to make TF\'s\n        s = tf([1, 0], [1]);\n        hb1 = 1/(Jb*s);\n        hb2 = 1/s;\n        hp1 = 1/(Jp*s);\n        hp2 = 1/s;\n\n        # convert to ss and append\n        sat0 = append(ss(hb1), ss(hb2), k, b, ss(hp1), ss(hp2));\n\n        # connection of the elements with connect call\n        Q = [[1, -3, -4],  # link moment (spring, damper), feedback to body\n             [2,  1,  0],  # link integrator to body velocity\n             [3,  2, -6],  # spring input, th_b - th_p\n             [4,  1, -5],  # damper input\n             [5,  3,  4],  # link moment, acting on payload\n             [6,  5,  0]]\n        inputs = [1];\n        outputs = [1, 2, 5, 6];\n        sat1 = connect(sat0, Q, inputs, outputs);\n\n        # matched notch filter\n        wno = 0.19\n        z1 = 0.05\n        z2 = 0.7\n        Hno = (1+2*z1/wno*s+s**2/wno**2)/(1+2*z2/wno*s+s**2/wno**2)\n\n        # the controller, Kp = 1 for now\n        Kp = 1.64\n        tau_PD = 50.\n        Hc = (1 + tau_PD*s)*Kp\n\n        # start with the basic satellite model sat1, and get the\n        # payload attitude response\n        Hp = tf(sp.matrix([0, 0, 0, 1])*sat1)\n\n        # total open loop\n        Hol = Hc*Hno*Hp\n\n        gm, pm, wg, wp = margin(Hol)\n        # print(""%f %f %f %f"" % (gm, pm, wg, wp))\n        self.assertAlmostEqual(gm, 3.32065569155)\n        self.assertAlmostEqual(pm, 46.9740430224)\n        self.assertAlmostEqual(wg, 0.176469728448)\n        self.assertAlmostEqual(wp, 0.0616288455466)\n\n    def test_tf_string_args(self):\n        # Make sure that the \'s\' variable is defined properly\n        s = tf(\'s\')\n        G = (s + 1)/(s**2 + 2*s + 1)\n        np.testing.assert_array_almost_equal(G.num, [[[1, 1]]])\n        np.testing.assert_array_almost_equal(G.den, [[[1, 2, 1]]])\n        self.assertTrue(isctime(G, strict=True))\n\n        # Make sure that the \'z\' variable is defined properly\n        z = tf(\'z\')\n        G = (z + 1)/(z**2 + 2*z + 1)\n        np.testing.assert_array_almost_equal(G.num, [[[1, 1]]])\n        np.testing.assert_array_almost_equal(G.den, [[[1, 2, 1]]])\n        self.assertTrue(isdtime(G, strict=True))\n\n\n#! TODO: not yet implemented\n#    def testMIMOtfdata(self):\n#        sisotf = ss2tf(self.siso_ss1)\n#        tfdata_1 = tfdata(sisotf)\n#        tfdata_2 = tfdata(self.mimo_ss1, input=0, output=0)\n#        for i in range(len(tfdata)):\n#            np.testing.assert_array_almost_equal(tfdata_1[i], tfdata_2[i])\n\ndef test_suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestMatlab)\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/minreal_test.py,16,"b'#!/usr/bin/env python\n#\n# minreal_test.py - test state space class\n# Rvp, 13 Jun 2013\n\nimport unittest\nimport numpy as np\nfrom scipy.linalg import eigvals\nfrom control import matlab\nfrom control.statesp import StateSpace\nfrom control.xferfcn import TransferFunction\nfrom itertools import permutations\nfrom control.exception import slycot_check\n\n@unittest.skipIf(not slycot_check(), ""slycot not installed"")\nclass TestMinreal(unittest.TestCase):\n    """"""Tests for the StateSpace class.""""""\n\n    def setUp(self):\n        np.random.seed(5)\n        # depending on the seed and minreal performance, a number of\n        # reductions is produced. If random gen or minreal change, this\n        # will be likely to fail\n        self.nreductions = 0\n\n    def assert_numden_almost_equal(self, n1, n2, d1, d2):\n        n1[np.abs(n1) < 1e-10] = 0.\n        n1 = np.trim_zeros(n1)\n        d1[np.abs(d1) < 1e-10] = 0.\n        d1 = np.trim_zeros(d1)\n        n2[np.abs(n2) < 1e-10] = 0.\n        n2 = np.trim_zeros(n2)\n        d2[np.abs(d2) < 1e-10] = 0.\n        d2 = np.trim_zeros(d2)\n        np.testing.assert_array_almost_equal(n1, n2)\n        np.testing.assert_array_almost_equal(d2, d2)\n\n\n    def testMinrealBrute(self):\n        for n, m, p in permutations(range(1,6), 3):\n            s = matlab.rss(n, p, m)\n            sr = s.minreal()\n            if s.states > sr.states:\n                self.nreductions += 1\n            else:\n                # Check to make sure that poles and zeros match\n\n                # For poles, just look at eigenvalues of A\n                np.testing.assert_array_almost_equal(\n                    np.sort(eigvals(s.A)), np.sort(eigvals(sr.A)))\n\n                # For zeros, need to extract SISO systems\n                for i in range(m):\n                    for j in range(p):\n                        # Extract SISO dynamixs from input i to output j\n                        s1 = matlab.ss(s.A, s.B[:,i], s.C[j,:], s.D[j,i])\n                        s2 = matlab.ss(sr.A, sr.B[:,i], sr.C[j,:], sr.D[j,i])\n\n                        # Check that the zeros match\n                        # Note: sorting doesn\'t work => have to do the hard way\n                        z1 = matlab.zero(s1)\n                        z2 = matlab.zero(s2)\n\n                        # Start by making sure we have the same # of zeros\n                        self.assertEqual(len(z1), len(z2))\n\n                        # Make sure all zeros in s1 are in s2\n                        for zero in z1:\n                            # Find the closest zero\n                            self.assertAlmostEqual(min(abs(z2 - zero)), 0.)\n\n                        # Make sure all zeros in s2 are in s1\n                        for zero in z2:\n                            # Find the closest zero\n                            self.assertAlmostEqual(min(abs(z1 - zero)), 0.)\n\n        # Make sure that the number of systems reduced is as expected\n        # (Need to update this number if you change the seed at top of file)\n        self.assertEqual(self.nreductions, 2)\n\n    def testMinrealSS(self):\n        """"""Test a minreal model reduction""""""\n        #A = [-2, 0.5, 0; 0.5, -0.3, 0; 0, 0, -0.1]\n        A = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        #B = [0.3, -1.3; 0.1, 0; 1, 0]\n        B = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        #C = [0, 0.1, 0; -0.3, -0.2, 0]\n        C = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        #D = [0 -0.8; -0.3 0]\n        D = [[0., -0.8], [-0.3, 0.]]\n        # sys = ss(A, B, C, D)\n\n        sys = StateSpace(A, B, C, D)\n        sysr = sys.minreal()\n        self.assertEqual(sysr.states, 2)\n        self.assertEqual(sysr.inputs, sys.inputs)\n        self.assertEqual(sysr.outputs, sys.outputs)\n        np.testing.assert_array_almost_equal(\n            eigvals(sysr.A), [-2.136154, -0.1638459])\n\n    def testMinrealtf(self):\n        """"""Try the minreal function, and also test easy entry by creation\n        of a Laplace variable s""""""\n        s = TransferFunction([1, 0], [1])\n        h = (s+1)*(s+2.00000000001)/(s+2)/(s**2+s+1)\n        hm = h.minreal()\n        hr = (s+1)/(s**2+s+1)\n        np.testing.assert_array_almost_equal(hm.num[0][0], hr.num[0][0])\n        np.testing.assert_array_almost_equal(hm.den[0][0], hr.den[0][0])\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestMinreal)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/modelsimp_array_test.py,68,"b'#!/usr/bin/env python\n#\n# modelsimp_test.py - test model reduction functions\n# RMM, 30 Mar 2011 (based on TestModelSimp from v0.4a)\n\nimport unittest\nimport numpy as np\nimport warnings\nimport control\nfrom control.modelsimp import *\nfrom control.matlab import *\nfrom control.exception import slycot_check\n\nclass TestModelsimp(unittest.TestCase):\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        control.use_numpy_matrix(False)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testHSVD(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n        C = np.array([[6., 8.]])\n        D = np.array([[9.]])\n        sys = ss(A,B,C,D)\n        hsv = hsvd(sys)\n        hsvtrue = np.array([24.42686, 0.5731395]) # from MATLAB\n        np.testing.assert_array_almost_equal(hsv, hsvtrue)\n\n        # Make sure default type values are correct\n        self.assertTrue(isinstance(hsv, np.ndarray))\n        self.assertFalse(isinstance(hsv, np.matrix))\n\n        # Check that using numpy.matrix does *not* affect answer\n        with warnings.catch_warnings(record=True) as w:\n            control.use_numpy_matrix(True)\n            self.assertTrue(issubclass(w[-1].category, UserWarning))\n\n            # Redefine the system (using np.matrix for storage)\n            sys = ss(A, B, C, D)\n\n            # Compute the Hankel singular value decomposition\n            hsv = hsvd(sys)\n\n            # Make sure that return type is correct\n            self.assertTrue(isinstance(hsv, np.ndarray))\n            self.assertFalse(isinstance(hsv, np.matrix))\n\n            # Go back to using the normal np.array representation\n            control.use_numpy_matrix(False)\n\n    def testMarkov(self):\n        U = np.array([[1.], [1.], [1.], [1.], [1.]])\n        Y = U\n        M = 3\n        H = markov(Y,U,M)\n        Htrue = np.array([[1.], [0.], [0.]])\n        np.testing.assert_array_almost_equal( H, Htrue )\n\n    def testModredMatchDC(self):\n        #balanced realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.array(\n            [[-1.958, -1.194, 1.824, -1.464],\n             [-1.194, -0.8344, 2.563, -1.351],\n             [-1.824, -2.563, -1.124, 2.704],\n             [-1.464, -1.351, -2.704, -11.08]])\n        B = np.array([[-0.9057], [-0.4068], [-0.3263], [-0.3474]])\n        C = np.array([[-0.9057, -0.4068, 0.3263, -0.3474]])\n        D = np.array([[0.]])\n        sys = ss(A,B,C,D)\n        rsys = modred(sys,[2, 3],\'matchdc\')\n        Artrue = np.array([[-4.431, -4.552], [-4.552, -5.361]])\n        Brtrue = np.array([[-1.362], [-1.031]])\n        Crtrue = np.array([[-1.362, -1.031]])\n        Drtrue = np.array([[-0.08384]])\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=2)\n\n    def testModredUnstable(self):\n        # Check if an error is thrown when an unstable system is given\n        A = np.array(\n            [[4.5418, 3.3999, 5.0342, 4.3808],\n             [0.3890, 0.3599, 0.4195, 0.1760],\n             [-4.2117, -3.2395, -4.6760, -4.2180],\n             [0.0052, 0.0429, 0.0155, 0.2743]])\n        B = np.array([[1.0, 1.0], [2.0, 2.0], [3.0, 3.0], [4.0, 4.0]])\n        C = np.array([[1.0, 2.0, 3.0, 4.0], [1.0, 2.0, 3.0, 4.0]])\n        D = np.array([[0.0, 0.0], [0.0, 0.0]])\n        sys = ss(A,B,C,D)\n        np.testing.assert_raises(ValueError, modred, sys, [2, 3])\n\n    def testModredTruncate(self):\n        #balanced realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.array(\n            [[-1.958, -1.194, 1.824, -1.464],\n             [-1.194, -0.8344, 2.563, -1.351],\n             [-1.824, -2.563, -1.124, 2.704],\n             [-1.464, -1.351, -2.704, -11.08]])\n        B = np.array([[-0.9057], [-0.4068], [-0.3263], [-0.3474]])\n        C = np.array([[-0.9057, -0.4068, 0.3263, -0.3474]])\n        D = np.array([[0.]])\n        sys = ss(A,B,C,D)\n        rsys = modred(sys,[2, 3],\'truncate\')\n        Artrue = np.array([[-1.958, -1.194], [-1.194, -0.8344]])\n        Brtrue = np.array([[-0.9057], [-0.4068]])\n        Crtrue = np.array([[-0.9057, -0.4068]])\n        Drtrue = np.array([[0.]])\n        np.testing.assert_array_almost_equal(rsys.A, Artrue)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue)\n\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testBalredTruncate(self):\n        #controlable canonical realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.array(\n            [[-15., -7.5, -6.25, -1.875],\n             [8., 0., 0., 0.],\n             [0., 4., 0., 0.],\n             [0., 0., 1., 0.]])\n        B = np.array([[2.], [0.], [0.], [0.]])\n        C = np.array([[0.5, 0.6875, 0.7031, 0.5]])\n        D = np.array([[0.]])\n        sys = ss(A,B,C,D)\n        orders = 2\n        rsys = balred(sys,orders,method=\'truncate\')\n        Artrue = np.array([[-1.958, -1.194], [-1.194, -0.8344]])\n        Brtrue = np.array([[0.9057], [0.4068]])\n        Crtrue = np.array([[0.9057, 0.4068]])\n        Drtrue = np.array([[0.]])\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=2)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=4)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testBalredMatchDC(self):\n        #controlable canonical realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.array(\n            [[-15., -7.5, -6.25, -1.875],\n             [8., 0., 0., 0.],\n             [0., 4., 0., 0.],\n             [0., 0., 1., 0.]])\n        B = np.array([[2.], [0.], [0.], [0.]])\n        C = np.array([[0.5, 0.6875, 0.7031, 0.5]])\n        D = np.array([[0.]])\n        sys = ss(A,B,C,D)\n        orders = 2\n        rsys = balred(sys,orders,method=\'matchdc\')\n        Artrue = np.array(\n            [[-4.43094773, -4.55232904],\n             [-4.55232904, -5.36195206]])\n        Brtrue = np.array([[1.36235673], [1.03114388]])\n        Crtrue = np.array([[1.36235673, 1.03114388]])\n        Drtrue = np.array([[-0.08383902]])\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=2)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=4)\n\n    def tearDown(self):\n        # Reset configuration variables to their original settings\n        control.config.reset_defaults()\n        \ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestModelsimp)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/modelsimp_test.py,61,"b'#!/usr/bin/env python\n#\n# modelsimp_test.py - test model reduction functions\n# RMM, 30 Mar 2011 (based on TestModelSimp from v0.4a)\n\nimport unittest\nimport numpy as np\nfrom control.modelsimp import *\nfrom control.matlab import *\nfrom control.exception import slycot_check\n\nclass TestModelsimp(unittest.TestCase):\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testHSVD(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5.; 7."")\n        C = np.matrix(""6. 8."")\n        D = np.matrix(""9."")\n        sys = ss(A,B,C,D)\n        hsv = hsvd(sys)\n        hsvtrue = [24.42686, 0.5731395]  # from MATLAB\n        np.testing.assert_array_almost_equal(hsv, hsvtrue)\n\n    def testMarkov(self):\n        U = np.matrix(""1.; 1.; 1.; 1.; 1."")\n        Y = U\n        M = 3\n        H = markov(Y,U,M)\n        Htrue = np.matrix(""1.; 0.; 0."")\n        np.testing.assert_array_almost_equal( H, Htrue )\n\n    def testModredMatchDC(self):\n        #balanced realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.matrix(\'-1.958, -1.194, 1.824, -1.464; \\\n        -1.194, -0.8344, 2.563, -1.351; \\\n        -1.824, -2.563, -1.124, 2.704; \\\n        -1.464, -1.351, -2.704, -11.08\')\n        B = np.matrix(\'-0.9057; -0.4068; -0.3263; -0.3474\')\n        C = np.matrix(\'-0.9057, -0.4068, 0.3263, -0.3474\')\n        D = np.matrix(\'0.\')\n        sys = ss(A,B,C,D)\n        rsys = modred(sys,[2, 3],\'matchdc\')\n        Artrue = np.matrix(\'-4.431, -4.552; -4.552, -5.361\')\n        Brtrue = np.matrix(\'-1.362; -1.031\')\n        Crtrue = np.matrix(\'-1.362, -1.031\')\n        Drtrue = np.matrix(\'-0.08384\')\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=3)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=2)\n\n    def testModredUnstable(self):\n        # Check if an error is thrown when an unstable system is given\n        A = np.matrix(\'4.5418, 3.3999, 5.0342, 4.3808; \\\n        0.3890, 0.3599, 0.4195, 0.1760; \\\n        -4.2117, -3.2395, -4.6760, -4.2180; \\\n        0.0052, 0.0429, 0.0155, 0.2743\')\n        B = np.matrix(\'1.0, 1.0; 2.0, 2.0; 3.0, 3.0; 4.0, 4.0\')\n        C = np.matrix(\'1.0, 2.0, 3.0, 4.0; 1.0, 2.0, 3.0, 4.0\')\n        D = np.matrix(\'0.0, 0.0; 0.0, 0.0\')\n        sys = ss(A,B,C,D)\n        np.testing.assert_raises(ValueError, modred, sys, [2, 3])\n\n    def testModredTruncate(self):\n        #balanced realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.matrix(\'-1.958, -1.194, 1.824, -1.464; \\\n        -1.194, -0.8344, 2.563, -1.351; \\\n        -1.824, -2.563, -1.124, 2.704; \\\n        -1.464, -1.351, -2.704, -11.08\')\n        B = np.matrix(\'-0.9057; -0.4068; -0.3263; -0.3474\')\n        C = np.matrix(\'-0.9057, -0.4068, 0.3263, -0.3474\')\n        D = np.matrix(\'0.\')\n        sys = ss(A,B,C,D)\n        rsys = modred(sys,[2, 3],\'truncate\')\n        Artrue = np.matrix(\'-1.958, -1.194; -1.194, -0.8344\')\n        Brtrue = np.matrix(\'-0.9057; -0.4068\')\n        Crtrue = np.matrix(\'-0.9057, -0.4068\')\n        Drtrue = np.matrix(\'0.\')\n        np.testing.assert_array_almost_equal(rsys.A, Artrue)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue)\n\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testBalredTruncate(self):\n        #controlable canonical realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.matrix(\'-15., -7.5, -6.25, -1.875; \\\n        8., 0., 0., 0.; \\\n        0., 4., 0., 0.; \\\n        0., 0., 1., 0.\')\n        B = np.matrix(\'2.; 0.; 0.; 0.\')\n        C = np.matrix(\'0.5, 0.6875, 0.7031, 0.5\')\n        D = np.matrix(\'0.\')\n        sys = ss(A,B,C,D)\n        orders = 2\n        rsys = balred(sys,orders,method=\'truncate\')\n        Artrue = np.matrix(\'-1.958, -1.194; -1.194, -0.8344\')\n        Brtrue = np.matrix(\'0.9057; 0.4068\')\n        Crtrue = np.matrix(\'0.9057, 0.4068\')\n        Drtrue = np.matrix(\'0.\')\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=2)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=4)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testBalredMatchDC(self):\n        #controlable canonical realization computed in matlab for the transfer function:\n        # num = [1 11 45 32], den = [1 15 60 200 60]\n        A = np.matrix(\'-15., -7.5, -6.25, -1.875; \\\n        8., 0., 0., 0.; \\\n        0., 4., 0., 0.; \\\n        0., 0., 1., 0.\')\n        B = np.matrix(\'2.; 0.; 0.; 0.\')\n        C = np.matrix(\'0.5, 0.6875, 0.7031, 0.5\')\n        D = np.matrix(\'0.\')\n        sys = ss(A,B,C,D)\n        orders = 2\n        rsys = balred(sys,orders,method=\'matchdc\')\n        Artrue = np.matrix(\'-4.43094773, -4.55232904; -4.55232904, -5.36195206\')\n        Brtrue = np.matrix(\'1.36235673; 1.03114388\')\n        Crtrue = np.matrix(\'1.36235673, 1.03114388\')\n        Drtrue = np.matrix(\'-0.08383902\')\n        np.testing.assert_array_almost_equal(rsys.A, Artrue,decimal=2)\n        np.testing.assert_array_almost_equal(rsys.B, Brtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.C, Crtrue,decimal=4)\n        np.testing.assert_array_almost_equal(rsys.D, Drtrue,decimal=4)\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestModelsimp)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/nichols_test.py,0,"b'#!/usr/bin/env python\n#\n# nichols_test.py - test Nichols plot\n# RMM, 31 Mar 2011\n\nimport unittest\nimport numpy as np\nfrom control.matlab import *\n\nclass TestStateSpace(unittest.TestCase):\n    """"""Tests for the Nichols plots.""""""\n\n    def setUp(self):\n        """"""Set up a system to test operations on.""""""\n\n        A = [[-3., 4., 2.], [-1., -3., 0.], [2., 5., 3.]]\n        B = [[1.], [-3.], [-2.]]\n        C = [[4., 2., -3.]]\n        D = [[0.]]\n\n        self.sys = StateSpace(A, B, C, D)\n\n    def testNicholsPlain(self):\n        """"""Generate a Nichols plot.""""""\n        nichols(self.sys)\n\n    def testNgrid(self):\n        """"""Generate a Nichols plot.""""""\n        nichols(self.sys, grid=False)\n        ngrid()\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestStateSpace)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/phaseplot_test.py,6,"b""#!/usr/bin/env python\n#\n# phaseplot_test.py - test phase plot functions\n# RMM, 17 24 2011 (based on TestMatlab from v0.4c)\n#\n# This test suite calls various phaseplot functions.  Since the plots\n# themselves can't be verified, this is mainly here to make sure all\n# of the function arguments are handled correctly.  If you run an\n# individual test by itself and then type show(), it should pop open\n# the figures so that you can check them visually.\n\nimport unittest\nimport numpy as np\nimport scipy as sp\nimport matplotlib.pyplot as mpl\nfrom control import phase_plot\nfrom numpy import pi\n\nclass TestPhasePlot(unittest.TestCase):\n    def setUp(self):\n        pass;\n\n    def testInvPendNoSims(self):\n        phase_plot(self.invpend_ode, (-6,6,10), (-6,6,10));\n\n    def testInvPendSims(self):\n        phase_plot(self.invpend_ode, (-6,6,10), (-6,6,10),\n                  X0 = ([1,1], [-1,1]));\n\n    def testInvPendTimePoints(self):\n        phase_plot(self.invpend_ode, (-6,6,10), (-6,6,10),\n                  X0 = ([1,1], [-1,1]), T=np.linspace(0,5,100));\n\n    def testInvPendLogtime(self):\n        phase_plot(self.invpend_ode, X0 =\n                  [ [-2*pi, 1.6], [-2*pi, 0.5], [-1.8, 2.1],\n                    [-1, 2.1], [4.2, 2.1], [5, 2.1],\n                    [2*pi, -1.6], [2*pi, -0.5], [1.8, -2.1],\n                    [1, -2.1], [-4.2, -2.1], [-5, -2.1] ],\n                  T = np.linspace(0, 40, 200),\n                  logtime=(3, 0.7),\n                  verbose=False)\n\n    def testInvPendAuto(self):\n        phase_plot(self.invpend_ode, lingrid = 0, X0=\n                  [[-2.3056, 2.1], [2.3056, -2.1]], T=6, verbose=False)\n\n    def testOscillatorParams(self):\n        m = 1; b = 1; k = 1;\t\t\t# default values\n        phase_plot(self.oscillator_ode, timepts = [0.3, 1, 2, 3], X0 =\n                  [[-1,1], [-0.3,1], [0,1], [0.25,1], [0.5,1], [0.7,1],\n                   [1,1], [1.3,1], [1,-1], [0.3,-1], [0,-1], [-0.25,-1],\n                   [-0.5,-1], [-0.7,-1], [-1,-1], [-1.3,-1]],\n                  T = np.linspace(0, 10, 100), parms = (m, b, k));\n\n    def testNoArrows(self):\n        # Test case from aramakrl that was generating a type error\n        # System does not have arrows\n        # cf. issue #96,\n        # https://github.com/python-control/python-control/issues/96\n        def d1(x1x2,t):\n            x1,x2 = x1x2\n            return np.array([x2, x2 - 2*x1])\n\n        x1x2_0 = np.array([[-1.,1.], [-1.,-1.], [1.,1.], [1.,-1.],\n                           [-1.,0.],[1.,0.],[0.,-1.],[0.,1.],[0.,0.]])\n\n        mpl.figure(1)\n        phase_plot(d1,X0=x1x2_0,T=100)\n\n    # Sample dynamical systems - inverted pendulum\n    def invpend_ode(self, x, t, m=1., l=1., b=0, g=9.8):\n        import numpy as np\n        return (x[1], -b/m*x[1] + (g*l/m) * np.sin(x[0]))\n\n    # Sample dynamical systems - oscillator\n    def oscillator_ode(self, x, t, m=1., b=1, k=1, extra=None):\n        return (x[1], -k/m*x[0] - b/m*x[1])\n\ndef suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestPhasePlot)\n\nif __name__ == '__main__':\n    unittest.main()\n"""
External_Libraries/python_control_master/control/tests/rlocus_test.py,5,"b'#!/usr/bin/env python\n#\n# rlocus_test.py - unit test for root locus diagrams\n# RMM, 1 Jul 2011\n\nimport unittest\nimport numpy as np\nfrom control.rlocus import root_locus, _RLClickDispatcher\nfrom control.xferfcn import TransferFunction\nfrom control.statesp import StateSpace\nfrom control.bdalg import feedback\nimport matplotlib.pyplot as plt\nfrom control.tests.margin_test import assert_array_almost_equal\n\n\nclass TestRootLocus(unittest.TestCase):\n    """"""These are tests for the feedback function in rlocus.py.""""""\n\n    def setUp(self):\n        """"""This contains some random LTI systems and scalars for testing.""""""\n\n        # Two random SISO systems.\n        sys1 = TransferFunction([1, 2], [1, 2, 3])\n        sys2 = StateSpace([[1., 4.], [3., 2.]], [[1.], [-4.]],\n            [[1., 0.]], [[0.]])\n        self.systems = (sys1, sys2)\n\n    def check_cl_poles(self, sys, pole_list, k_list):\n        for k, poles in zip(k_list, pole_list):\n            poles_expected = np.sort(feedback(sys, k).pole())\n            poles = np.sort(poles)\n            np.testing.assert_array_almost_equal(poles, poles_expected)\n\n    def testRootLocus(self):\n        """"""Basic root locus plot""""""\n        klist = [-1, 0, 1]\n        for sys in self.systems:\n            roots, k_out = root_locus(sys, klist, Plot=False)\n            np.testing.assert_equal(len(roots), len(klist))\n            np.testing.assert_array_equal(klist, k_out)\n            self.check_cl_poles(sys, roots, klist)\n\n    def test_without_gains(self):\n        for sys in self.systems:\n            roots, kvect = root_locus(sys, Plot=False)\n            self.check_cl_poles(sys, roots, kvect)\n\n    def test_root_locus_zoom(self):\n        """"""Check the zooming functionality of the Root locus plot""""""\n        system = TransferFunction([1000], [1, 25, 100, 0])\n        root_locus(system)\n        fig = plt.gcf()\n        ax_rlocus = fig.axes[0]\n\n        event = type(\'test\', (object,), {\'xdata\': 14.7607954359, \'ydata\': -35.6171379864, \'inaxes\': ax_rlocus.axes})()\n        ax_rlocus.set_xlim((-10.813628105112421, 14.760795435937652))\n        ax_rlocus.set_ylim((-35.61713798641108, 33.879716621220311))\n        plt.get_current_fig_manager().toolbar.mode = \'zoom rect\'\n        _RLClickDispatcher(event, system, fig, ax_rlocus, \'-\')\n\n        zoom_x = ax_rlocus.lines[-2].get_data()[0][0:5]\n        zoom_y = ax_rlocus.lines[-2].get_data()[1][0:5]\n        zoom_y = [abs(y) for y in zoom_y]\n\n        zoom_x_valid = [-5. ,- 4.61281263, - 4.16689986, - 4.04122642, - 3.90736502]\n        zoom_y_valid = [0. ,0., 0., 0., 0.]\n\n        assert_array_almost_equal(zoom_x,zoom_x_valid)\n        assert_array_almost_equal(zoom_y,zoom_y_valid)\n\ndef test_suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestRootLocus)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/robust_array_test.py,24,"b'import unittest\nimport numpy as np\nimport control\nimport control.robust\nfrom control.exception import slycot_check\n\nclass TestHinf(unittest.TestCase):\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        control.use_numpy_matrix(False)\n        \n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testHinfsyn(self):\n        """"""Test hinfsyn""""""\n        p = control.ss(-1, [[1, 1]], [[1], [1]], [[0, 1], [1, 0]])\n        k, cl, gam, rcond = control.robust.hinfsyn(p, 1, 1)\n        # from Octave, which also uses SB10AD:\n        #   a= -1; b1= 1; b2= 1; c1= 1; c2= 1; d11= 0; d12= 1; d21= 1; d22= 0;\n        #   g = ss(a,[b1,b2],[c1;c2],[d11,d12;d21,d22]);\n        #   [k,cl] = hinfsyn(g,1,1);\n        np.testing.assert_array_almost_equal(k.A, [[-3]])\n        np.testing.assert_array_almost_equal(k.B, [[1]])\n        np.testing.assert_array_almost_equal(k.C, [[-1]])\n        np.testing.assert_array_almost_equal(k.D, [[0]])\n        np.testing.assert_array_almost_equal(cl.A, [[-1, -1], [1, -3]])\n        np.testing.assert_array_almost_equal(cl.B, [[1], [1]])\n        np.testing.assert_array_almost_equal(cl.C, [[1, -1]])\n        np.testing.assert_array_almost_equal(cl.D, [[0]])\n\n    # TODO: add more interesting examples\n\n    def tearDown(self):\n        control.config.reset_defaults()\n\n\nclass TestH2(unittest.TestCase):\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        control.use_numpy_matrix(False)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testH2syn(self):\n        """"""Test h2syn""""""\n        p = control.ss(-1, [[1, 1]], [[1], [1]], [[0, 1], [1, 0]])\n        k = control.robust.h2syn(p, 1, 1)\n        # from Octave, which also uses SB10HD for H-2 synthesis:\n        #   a= -1; b1= 1; b2= 1; c1= 1; c2= 1; d11= 0; d12= 1; d21= 1; d22= 0;\n        #   g = ss(a,[b1,b2],[c1;c2],[d11,d12;d21,d22]);\n        #   k = h2syn(g,1,1);\n        # the solution is the same as for the hinfsyn test\n        np.testing.assert_array_almost_equal(k.A, [[-3]])\n        np.testing.assert_array_almost_equal(k.B, [[1]])\n        np.testing.assert_array_almost_equal(k.C, [[-1]])\n        np.testing.assert_array_almost_equal(k.D, [[0]])\n\n    def tearDown(self):\n        control.config.reset_defaults()\n\n\nclass TestAugw(unittest.TestCase):\n    """"""Test control.robust.augw""""""\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        control.use_numpy_matrix(False)\n\n    # tolerance for system equality\n    TOL = 1e-8\n\n    def siso_almost_equal(self, g, h):\n        """"""siso_almost_equal(g,h) -> None\n        Raises AssertionError if g and h, two SISO LTI objects, are not almost equal""""""\n        from control import tf, minreal\n        gmh = tf(minreal(g - h, verbose=False))\n        if not (gmh.num[0][0] < self.TOL).all():\n            maxnum = max(abs(gmh.num[0][0]))\n            raise AssertionError(\n                \'systems not approx equal; max num. coeff is {}\\nsys 1:\\n{}\\nsys 2:\\n{}\'.format(\n                    maxnum, g, h))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW1(self):\n        """"""SISO plant with S weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w1 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w1)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW2(self):\n        """"""SISO plant with KS weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w2 = ss([-2], [1.], [1.], [2.])\n        p = augw(g, w2=w2)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z2 should be 0\n        self.siso_almost_equal(ss([], [], [], 0), p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW3(self):\n        """"""SISO plant with T weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w3 = ss([-2], [1.], [1.], [2.])\n        p = augw(g, w3=w3)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z3 should be 0\n        self.siso_almost_equal(ss([], [], [], 0), p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW123(self):\n        """"""SISO plant with all weights""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w1 = ss([-2.], [2.], [1.], [2.])\n        w2 = ss([-3.], [3.], [1.], [3.])\n        w3 = ss([-4.], [4.], [1.], [4.])\n        p = augw(g, w1, w2, w3)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[1, 0])\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[2, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[3, 0])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g, p[0, 1])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[1, 1])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g, p[2, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[3, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW1(self):\n        """"""MIMO plant with S weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w1 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w1)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z1 should be diag(w1,w1)\n        self.siso_almost_equal(w1, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(w1, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(-w1 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(-w1 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(-w1 * g[1, 1], p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW2(self):\n        """"""MIMO plant with KS weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w2 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w2=w2)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(0, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[0, 2])\n        self.siso_almost_equal(0, p[0, 3])\n        self.siso_almost_equal(0, p[1, 2])\n        self.siso_almost_equal(w2, p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW3(self):\n        """"""MIMO plant with T weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w3 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w3=w3)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(0, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(w3 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(w3 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(w3 * g[1, 1], p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW123(self):\n        """"""MIMO plant with all weights""""""\n        from control import augw, ss, append\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        # this should be expaned to w1*I\n        w1 = ss([-2.], [2.], [1.], [2.])\n        # diagonal weighting\n        w2 = append(ss([-3.], [3.], [1.], [3.]), ss([-4.], [4.], [1.], [4.]))\n        # full weighting\n        w3 = ss([[-4., -5], [-6, -7]],\n                [[2., 3.], [5., 7.]],\n                [[11., 13.], [17., 19.]],\n                [[23., 29.], [31., 37.]])\n        p = augw(g, w1, w2, w3)\n        self.assertEqual(8, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(w1, p[1, 1])\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(0, p[3, 1])\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[4, 0])\n        self.siso_almost_equal(0, p[4, 1])\n        self.siso_almost_equal(0, p[5, 0])\n        self.siso_almost_equal(0, p[5, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[6, 0])\n        self.siso_almost_equal(0, p[6, 1])\n        self.siso_almost_equal(0, p[7, 0])\n        self.siso_almost_equal(1, p[7, 1])\n\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(-w1 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(-w1 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(-w1 * g[1, 1], p[1, 3])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2[0, 0], p[2, 2])\n        self.siso_almost_equal(w2[0, 1], p[2, 3])\n        self.siso_almost_equal(w2[1, 0], p[3, 2])\n        self.siso_almost_equal(w2[1, 1], p[3, 3])\n        # u->z3 should be w3*g\n        w3g = w3 * g;\n        self.siso_almost_equal(w3g[0, 0], p[4, 2])\n        self.siso_almost_equal(w3g[0, 1], p[4, 3])\n        self.siso_almost_equal(w3g[1, 0], p[5, 2])\n        self.siso_almost_equal(w3g[1, 1], p[5, 3])\n        # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[6, 2])\n        self.siso_almost_equal(-g[0, 1], p[6, 3])\n        self.siso_almost_equal(-g[1, 0], p[7, 2])\n        self.siso_almost_equal(-g[1, 1], p[7, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testErrors(self):\n        """"""Error cases handled""""""\n        from control import augw, ss\n        # no weights\n        g1by1 = ss(-1, 1, 1, 0)\n        g2by2 = ss(-np.eye(2), np.eye(2), np.eye(2), np.zeros((2, 2)))\n        self.assertRaises(ValueError, augw, g1by1)\n        # mismatched size of weight and plant\n        self.assertRaises(ValueError, augw, g1by1, w1=g2by2)\n        self.assertRaises(ValueError, augw, g1by1, w2=g2by2)\n        self.assertRaises(ValueError, augw, g1by1, w3=g2by2)\n\n    def tearDown(self):\n        control.config.reset_defaults()\n\n\nclass TestMixsyn(unittest.TestCase):\n    """"""Test control.robust.mixsyn""""""\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        control.use_numpy_matrix(False)\n        \n    # it\'s a relatively simple wrapper; compare results with augw, hinfsyn\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSiso(self):\n        """"""mixsyn with SISO system""""""\n        from control import tf, augw, hinfsyn, mixsyn\n        from control import ss\n        # Skogestad+Postlethwaite, Multivariable Feedback Control, 1st Ed., Example 2.11\n        s = tf([1, 0], 1)\n        # plant\n        g = 200 / (10 * s + 1) / (0.05 * s + 1) ** 2\n        # sensitivity weighting\n        M = 1.5\n        wb = 10\n        A = 1e-4\n        w1 = (s / M + wb) / (s + wb * A)\n        # KS weighting\n        w2 = tf(1, 1)\n\n        p = augw(g, w1, w2)\n        kref, clref, gam, rcond = hinfsyn(p, 1, 1)\n        ktest, cltest, info = mixsyn(g, w1, w2)\n        # check similar to S+P\'s example\n        np.testing.assert_allclose(gam, 1.37, atol=1e-2)\n\n        # mixsyn is a convenience wrapper around augw and hinfsyn, so\n        # results will be exactly the same.  Given than, use the lazy\n        # but fragile testing option.\n        np.testing.assert_allclose(ktest.A, kref.A)\n        np.testing.assert_allclose(ktest.B, kref.B)\n        np.testing.assert_allclose(ktest.C, kref.C)\n        np.testing.assert_allclose(ktest.D, kref.D)\n\n        np.testing.assert_allclose(cltest.A, clref.A)\n        np.testing.assert_allclose(cltest.B, clref.B)\n        np.testing.assert_allclose(cltest.C, clref.C)\n        np.testing.assert_allclose(cltest.D, clref.D)\n\n        np.testing.assert_allclose(gam, info[0])\n\n        np.testing.assert_allclose(rcond, info[1])\n\n    def tearDown(self):\n        control.config.reset_defaults()\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/robust_test.py,24,"b'import unittest\nimport numpy as np\nimport control\nimport control.robust\nfrom control.exception import slycot_check\n\n\nclass TestHinf(unittest.TestCase):\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testHinfsyn(self):\n        """"""Test hinfsyn""""""\n        p = control.ss(-1, [1, 1], [[1], [1]], [[0, 1], [1, 0]])\n        k, cl, gam, rcond = control.robust.hinfsyn(p, 1, 1)\n        # from Octave, which also uses SB10AD:\n        #   a= -1; b1= 1; b2= 1; c1= 1; c2= 1; d11= 0; d12= 1; d21= 1; d22= 0;\n        #   g = ss(a,[b1,b2],[c1;c2],[d11,d12;d21,d22]);\n        #   [k,cl] = hinfsyn(g,1,1);\n        np.testing.assert_array_almost_equal(k.A, [[-3]])\n        np.testing.assert_array_almost_equal(k.B, [[1]])\n        np.testing.assert_array_almost_equal(k.C, [[-1]])\n        np.testing.assert_array_almost_equal(k.D, [[0]])\n        np.testing.assert_array_almost_equal(cl.A, [[-1, -1], [1, -3]])\n        np.testing.assert_array_almost_equal(cl.B, [[1], [1]])\n        np.testing.assert_array_almost_equal(cl.C, [[1, -1]])\n        np.testing.assert_array_almost_equal(cl.D, [[0]])\n\n    # TODO: add more interesting examples\n\n\nclass TestH2(unittest.TestCase):\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testH2syn(self):\n        """"""Test h2syn""""""\n        p = control.ss(-1, [1, 1], [[1], [1]], [[0, 1], [1, 0]])\n        k = control.robust.h2syn(p, 1, 1)\n        # from Octave, which also uses SB10HD for H-2 synthesis:\n        #   a= -1; b1= 1; b2= 1; c1= 1; c2= 1; d11= 0; d12= 1; d21= 1; d22= 0;\n        #   g = ss(a,[b1,b2],[c1;c2],[d11,d12;d21,d22]);\n        #   k = h2syn(g,1,1);\n        # the solution is the same as for the hinfsyn test\n        np.testing.assert_array_almost_equal(k.A, [[-3]])\n        np.testing.assert_array_almost_equal(k.B, [[1]])\n        np.testing.assert_array_almost_equal(k.C, [[-1]])\n        np.testing.assert_array_almost_equal(k.D, [[0]])\n\n\nclass TestAugw(unittest.TestCase):\n    """"""Test control.robust.augw""""""\n\n    # tolerance for system equality\n    TOL = 1e-8\n\n    def siso_almost_equal(self, g, h):\n        """"""siso_almost_equal(g,h) -> None\n        Raises AssertionError if g and h, two SISO LTI objects, are not almost equal""""""\n        from control import tf, minreal\n        gmh = tf(minreal(g - h, verbose=False))\n        if not (gmh.num[0][0] < self.TOL).all():\n            maxnum = max(abs(gmh.num[0][0]))\n            raise AssertionError(\n                \'systems not approx equal; max num. coeff is {}\\nsys 1:\\n{}\\nsys 2:\\n{}\'.format(\n                    maxnum, g, h))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW1(self):\n        """"""SISO plant with S weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w1 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w1)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW2(self):\n        """"""SISO plant with KS weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w2 = ss([-2], [1.], [1.], [2.])\n        p = augw(g, w2=w2)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z2 should be 0\n        self.siso_almost_equal(ss([], [], [], 0), p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW3(self):\n        """"""SISO plant with T weighting""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w3 = ss([-2], [1.], [1.], [2.])\n        p = augw(g, w3=w3)\n        self.assertEqual(2, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z3 should be 0\n        self.siso_almost_equal(ss([], [], [], 0), p[0, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[1, 0])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g, p[0, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[1, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSisoW123(self):\n        """"""SISO plant with all weights""""""\n        from control import augw, ss\n        g = ss([-1.], [1.], [1.], [1.])\n        w1 = ss([-2.], [2.], [1.], [2.])\n        w2 = ss([-3.], [3.], [1.], [3.])\n        w3 = ss([-4.], [4.], [1.], [4.])\n        p = augw(g, w1, w2, w3)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(2, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[1, 0])\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[2, 0])\n        # w->v should be 1\n        self.siso_almost_equal(ss([], [], [], [1]), p[3, 0])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g, p[0, 1])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[1, 1])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g, p[2, 1])\n        # u->v should be -g\n        self.siso_almost_equal(-g, p[3, 1])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW1(self):\n        """"""MIMO plant with S weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w1 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w1)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z1 should be diag(w1,w1)\n        self.siso_almost_equal(w1, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(w1, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(-w1 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(-w1 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(-w1 * g[1, 1], p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW2(self):\n        """"""MIMO plant with KS weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w2 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w2=w2)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(0, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2, p[0, 2])\n        self.siso_almost_equal(0, p[0, 3])\n        self.siso_almost_equal(0, p[1, 2])\n        self.siso_almost_equal(w2, p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW3(self):\n        """"""MIMO plant with T weighting""""""\n        from control import augw, ss\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        w3 = ss([-2], [2.], [1.], [2.])\n        p = augw(g, w3=w3)\n        self.assertEqual(4, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(0, p[1, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(1, p[3, 1])\n        # u->z3 should be w3*g\n        self.siso_almost_equal(w3 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(w3 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(w3 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(w3 * g[1, 1], p[1, 3])\n        # # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[2, 2])\n        self.siso_almost_equal(-g[0, 1], p[2, 3])\n        self.siso_almost_equal(-g[1, 0], p[3, 2])\n        self.siso_almost_equal(-g[1, 1], p[3, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testMimoW123(self):\n        """"""MIMO plant with all weights""""""\n        from control import augw, ss, append, minreal\n        g = ss([[-1., -2], [-3, -4]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]],\n               [[1., 0.], [0., 1.]])\n        # this should be expaned to w1*I\n        w1 = ss([-2.], [2.], [1.], [2.])\n        # diagonal weighting\n        w2 = append(ss([-3.], [3.], [1.], [3.]), ss([-4.], [4.], [1.], [4.]))\n        # full weighting\n        w3 = ss([[-4., -5], [-6, -7]],\n                [[2., 3.], [5., 7.]],\n                [[11., 13.], [17., 19.]],\n                [[23., 29.], [31., 37.]])\n        p = augw(g, w1, w2, w3)\n        self.assertEqual(8, p.outputs)\n        self.assertEqual(4, p.inputs)\n        # w->z1 should be w1\n        self.siso_almost_equal(w1, p[0, 0])\n        self.siso_almost_equal(0, p[0, 1])\n        self.siso_almost_equal(0, p[1, 0])\n        self.siso_almost_equal(w1, p[1, 1])\n        # w->z2 should be 0\n        self.siso_almost_equal(0, p[2, 0])\n        self.siso_almost_equal(0, p[2, 1])\n        self.siso_almost_equal(0, p[3, 0])\n        self.siso_almost_equal(0, p[3, 1])\n        # w->z3 should be 0\n        self.siso_almost_equal(0, p[4, 0])\n        self.siso_almost_equal(0, p[4, 1])\n        self.siso_almost_equal(0, p[5, 0])\n        self.siso_almost_equal(0, p[5, 1])\n        # w->v should be I\n        self.siso_almost_equal(1, p[6, 0])\n        self.siso_almost_equal(0, p[6, 1])\n        self.siso_almost_equal(0, p[7, 0])\n        self.siso_almost_equal(1, p[7, 1])\n\n        # u->z1 should be -w1*g\n        self.siso_almost_equal(-w1 * g[0, 0], p[0, 2])\n        self.siso_almost_equal(-w1 * g[0, 1], p[0, 3])\n        self.siso_almost_equal(-w1 * g[1, 0], p[1, 2])\n        self.siso_almost_equal(-w1 * g[1, 1], p[1, 3])\n        # u->z2 should be w2\n        self.siso_almost_equal(w2[0, 0], p[2, 2])\n        self.siso_almost_equal(w2[0, 1], p[2, 3])\n        self.siso_almost_equal(w2[1, 0], p[3, 2])\n        self.siso_almost_equal(w2[1, 1], p[3, 3])\n        # u->z3 should be w3*g\n        w3g = w3 * g;\n        self.siso_almost_equal(w3g[0, 0], minreal(p[4, 2]))\n        self.siso_almost_equal(w3g[0, 1], minreal(p[4, 3]))\n        self.siso_almost_equal(w3g[1, 0], minreal(p[5, 2]))\n        self.siso_almost_equal(w3g[1, 1], minreal(p[5, 3]))\n        # u->v should be -g\n        self.siso_almost_equal(-g[0, 0], p[6, 2])\n        self.siso_almost_equal(-g[0, 1], p[6, 3])\n        self.siso_almost_equal(-g[1, 0], p[7, 2])\n        self.siso_almost_equal(-g[1, 1], p[7, 3])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testErrors(self):\n        """"""Error cases handled""""""\n        from control import augw, ss\n        # no weights\n        g1by1 = ss(-1, 1, 1, 0)\n        g2by2 = ss(-np.eye(2), np.eye(2), np.eye(2), np.zeros((2, 2)))\n        self.assertRaises(ValueError, augw, g1by1)\n        # mismatched size of weight and plant\n        self.assertRaises(ValueError, augw, g1by1, w1=g2by2)\n        self.assertRaises(ValueError, augw, g1by1, w2=g2by2)\n        self.assertRaises(ValueError, augw, g1by1, w3=g2by2)\n\n\nclass TestMixsyn(unittest.TestCase):\n    """"""Test control.robust.mixsyn""""""\n\n    # it\'s a relatively simple wrapper; compare results with augw, hinfsyn\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testSiso(self):\n        """"""mixsyn with SISO system""""""\n        from control import tf, augw, hinfsyn, mixsyn\n        from control import ss\n        # Skogestad+Postlethwaite, Multivariable Feedback Control, 1st Ed., Example 2.11\n        s = tf([1, 0], 1)\n        # plant\n        g = 200 / (10 * s + 1) / (0.05 * s + 1) ** 2\n        # sensitivity weighting\n        M = 1.5\n        wb = 10\n        A = 1e-4\n        w1 = (s / M + wb) / (s + wb * A)\n        # KS weighting\n        w2 = tf(1, 1)\n\n        p = augw(g, w1, w2)\n        kref, clref, gam, rcond = hinfsyn(p, 1, 1)\n        ktest, cltest, info = mixsyn(g, w1, w2)\n        # check similar to S+P\'s example\n        np.testing.assert_allclose(gam, 1.37, atol=1e-2)\n\n        # mixsyn is a convenience wrapper around augw and hinfsyn, so\n        # results will be exactly the same.  Given than, use the lazy\n        # but fragile testing option.\n        np.testing.assert_allclose(ktest.A, kref.A)\n        np.testing.assert_allclose(ktest.B, kref.B)\n        np.testing.assert_allclose(ktest.C, kref.C)\n        np.testing.assert_allclose(ktest.D, kref.D)\n\n        np.testing.assert_allclose(cltest.A, clref.A)\n        np.testing.assert_allclose(cltest.B, clref.B)\n        np.testing.assert_allclose(cltest.C, clref.C)\n        np.testing.assert_allclose(cltest.D, clref.D)\n\n        np.testing.assert_allclose(gam, info[0])\n\n        np.testing.assert_allclose(rcond, info[1])\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/run_all.py,0,"b'#!/usr/bin/env python\n#\n# test_all.py - test suit for python-control\n# RMM, 30 Mar 2011\n\nfrom __future__ import print_function\nimport unittest                 # unit test module\nimport re                       # regular expressions\nimport os                       # operating system commands\n\ndef test_all(verbosity=0):\n    """""" Runs all tests written for python-control.\n    """"""\n    try:                      # autodiscovery (python 2.7+)\n        start_dir = \'./\'\n        pattern = \'*_test.py\'\n        top_level_dir = \'../\'\n        testModules = \\\n            unittest.defaultTestLoader.discover(start_dir, pattern=pattern, \\\n                                                top_level_dir=top_level_dir)\n\n        for mod in test_mods:\n            print(\'Running tests in\', mod)\n            tests = unittest.defaultTestLoader.loadTestFromModule(mod)\n            t = unittest.TextTestRunner()\n            t.run(tests)\n            print(\'Completed tests in\', mod)\n\n    except:\n        testModules = findTests(\'./tests/\')\n\n        # Now go through each module and run all of its tests.\n        for mod in testModules:\n            print(\'Running tests in\', mod)\n            suiteList=[]        # list of unittest.TestSuite objects\n            exec(\'import \'+mod+\' as currentModule\')\n\n            try:\n                currentSuite = currentModule.suite()\n                if isinstance(currentSuite, unittest.TestSuite):\n                    suiteList.append(currentModule.suite())\n                else:\n                    print(mod + \'.suite() doesn\\\'t return a TestSuite\')\n            except:\n                print(\'The test module \'+mod+\' doesnt have \' + \\\n                    \'a proper suite() function\')\n\n            t=unittest.TextTestRunner(verbosity=verbosity)\n            t.run(unittest.TestSuite(unittest.TestSuite(suiteList)))\n            print(\'Completed tests in\', mod)\n\ndef findTests(testdir = \'./\', pattern = ""[^.#]*_test.py$""):\n    """"""Since python <2.7 doesn\'t have test discovery, this finds tests in the\n    provided directory. The default is to check the current directory. Any files\n    that match test* or Test* are considered unittest modules and checked for\n    a module.suite() function (in tests()).""""""\n\n    # Get list of files in test directory\n    fileList = os.listdir(testdir)\n\n    # Go through the files and look for anything that matches the pattern\n    testModules= []\n    for fileName in fileList:\n        if (re.match(pattern, fileName)):\n            testModules.append(fileName[:-len(\'.py\')])\n\n    # Return all of the modules that we find\n    return testModules\n\nif __name__==\'__main__\':\n  test_all()\n'"
External_Libraries/python_control_master/control/tests/sisotool_test.py,9,"b'import unittest\nimport numpy as np\nfrom control.sisotool import sisotool\nfrom control.tests.margin_test import assert_array_almost_equal\nfrom control.rlocus import _RLClickDispatcher\nfrom control.xferfcn import TransferFunction\nimport matplotlib.pyplot as plt\n\nclass TestSisotool(unittest.TestCase):\n    """"""These are tests for the sisotool in sisotool.py.""""""\n\n    def setUp(self):\n        # One random SISO system.\n        self.system = TransferFunction([1000],[1,25,100,0])\n\n    def test_sisotool(self):\n        sisotool(self.system,Hz=False)\n        fig = plt.gcf()\n        ax_mag,ax_rlocus,ax_phase,ax_step = fig.axes[0],fig.axes[1],fig.axes[2],fig.axes[3]\n\n        # Check the initial root locus plot points\n        initial_point_0 = (np.array([-22.53155977]),np.array([0.]))\n        initial_point_1 = (np.array([-1.23422011]), np.array([-6.54667031]))\n        initial_point_2 = (np.array([-1.23422011]), np.array([06.54667031]))\n        assert_array_almost_equal(ax_rlocus.lines[0].get_data(),initial_point_0)\n        assert_array_almost_equal(ax_rlocus.lines[1].get_data(),initial_point_1)\n        assert_array_almost_equal(ax_rlocus.lines[2].get_data(),initial_point_2)\n\n        # Check the step response before moving the point\n        step_response_original = np.array([ 0.,          0.02233651,  0.13118374,  0.33078542,  0.5907113,   0.87041549, 1.13038536,  1.33851053,  1.47374666,  1.52757114])\n        assert_array_almost_equal(ax_step.lines[0].get_data()[1][:10],step_response_original)\n\n        bode_plot_params = {\n            \'omega\': None,\n            \'dB\': False,\n            \'Hz\': False,\n            \'deg\': True,\n            \'omega_limits\': None,\n            \'omega_num\': None,\n            \'sisotool\': True,\n            \'fig\': fig,\n            \'margins\': True\n        }\n\n        # Move the rootlocus to another point\n        event = type(\'test\', (object,), {\'xdata\': 2.31206868287,\'ydata\':15.5983051046, \'inaxes\':ax_rlocus.axes})()\n        _RLClickDispatcher(event=event, sys=self.system, fig=fig,ax_rlocus=ax_rlocus,sisotool=True, plotstr=\'-\' ,bode_plot_params=bode_plot_params, tvect=None)\n\n        # Check the moved root locus plot points\n        moved_point_0 = (np.array([-29.91742755]), np.array([0.]))\n        moved_point_1 = (np.array([2.45871378]), np.array([-15.52647768]))\n        moved_point_2 = (np.array([2.45871378]), np.array([15.52647768]))\n        assert_array_almost_equal(ax_rlocus.lines[-3].get_data(),moved_point_0)\n        assert_array_almost_equal(ax_rlocus.lines[-2].get_data(),moved_point_1)\n        assert_array_almost_equal(ax_rlocus.lines[-1].get_data(),moved_point_2)\n\n        # Check if the bode_mag line has moved\n        bode_mag_moved = np.array([ 111.83321224,   92.29238035,   76.02822315,   62.46884113,   51.14108703, 41.6554004,    33.69409534,   27.00237344,   21.38086717,   16.67791585])\n        assert_array_almost_equal(ax_mag.lines[0].get_data()[1][10:20],bode_mag_moved)\n\n        # Check if the step response has changed\n        step_response_moved = np.array([[ 0.,          0.02458187,  0.16529784 , 0.46602716 , 0.91012035 , 1.43364313, 1.93996334 , 2.3190105  , 2.47041552 , 2.32724853] ])\n        assert_array_almost_equal(ax_step.lines[0].get_data()[1][:10],step_response_moved)\n\ndef test_suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestSisotool)\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/slycot_convert_test.py,12,"b'#!/usr/bin/env python\n#\n# slycot_convert_test.py - test SLICOT-based conversions\n# RMM, 30 Mar 2011 (based on TestSlycot from v0.4a)\n\nfrom __future__ import print_function\nimport unittest\nimport numpy as np\nfrom control import matlab\nfrom control.exception import slycot_check\n\n\n@unittest.skipIf(not slycot_check(), ""slycot not installed"")\nclass TestSlycot(unittest.TestCase):\n    """"""TestSlycot compares transfer function and state space conversions for\n        various numbers of inputs,outputs and states.\n       1. Usually passes for SISO systems of any state dim, occasonally,\n          there will be a dimension mismatch if the original randomly\n          generated ss system is not minimal because td04ad returns a\n          minimal system.\n\n       2. For small systems with many inputs, n<<m, the tests fail\n          because td04ad returns a minimal ss system which has fewer\n          states than the original system. It is typical for systems\n          with many more inputs than states to have extraneous states.\n\n       3. For systems with larger dimensions, n~>5 and with 2 or more\n          outputs the conversion to statespace (td04ad) intermittently\n          results in an equivalent realization of higher order than the\n          original tf order. We think this has to do with minimu\n          realization tolerances in the Fortran. The algorithm doesn\'t\n          recognize that two denominators are identical and so it\n          creates a system with nearly duplicate eigenvalues and\n          double the state dimension. This should not be a problem in\n          the python-control usage because the common_den() method finds\n          repeated roots within a tolerance that we specify.\n\n       Matlab: Matlab seems to force its statespace system output to\n       have order less than or equal to the order of denominators provided,\n       avoiding the problem of very large state dimension we describe in 3.\n       It does however, still have similar problems with pole/zero\n       cancellation such as we encounter in 2, where a statespace system\n       may have fewer states than the original order of transfer function.\n    """"""\n    def setUp(self):\n        """"""Define some test parameters.""""""\n        self.numTests = 5\n        self.maxStates = 10\n        self.maxI = 1\n        self.maxO = 1\n\n    def testTF(self, verbose=False):\n        """""" Directly tests the functions tb04ad and td04ad through direct\n            comparison of transfer function coefficients.\n            Similar to convert_test, but tests at a lower level.\n        """"""\n        from slycot import tb04ad, td04ad\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxI+1):\n                for outputs in range(1, self.maxO+1):\n                    for testNum in range(self.numTests):\n                        ssOriginal = matlab.rss(states, outputs, inputs)\n                        if (verbose):\n                            print(\'====== Original SS ==========\')\n                            print(ssOriginal)\n                            print(\'states=\', states)\n                            print(\'inputs=\', inputs)\n                            print(\'outputs=\', outputs)\n\n                        tfOriginal_Actrb, tfOriginal_Bctrb, tfOriginal_Cctrb,\\\n                            tfOrigingal_nctrb, tfOriginal_index,\\\n                            tfOriginal_dcoeff, tfOriginal_ucoeff =\\\n                            tb04ad(states, inputs, outputs,\n                                   ssOriginal.A, ssOriginal.B,\n                                   ssOriginal.C, ssOriginal.D, tol1=0.0)\n\n                        ssTransformed_nr, ssTransformed_A, ssTransformed_B,\\\n                            ssTransformed_C, ssTransformed_D\\\n                            = td04ad(\'R\', inputs, outputs, tfOriginal_index,\n                                     tfOriginal_dcoeff, tfOriginal_ucoeff,\n                                     tol=0.0)\n\n                        tfTransformed_Actrb, tfTransformed_Bctrb,\\\n                            tfTransformed_Cctrb, tfTransformed_nctrb,\\\n                            tfTransformed_index, tfTransformed_dcoeff,\\\n                            tfTransformed_ucoeff = tb04ad(\n                                ssTransformed_nr, inputs, outputs,\n                                ssTransformed_A, ssTransformed_B,\n                                ssTransformed_C, ssTransformed_D, tol1=0.0)\n                        # print(\'size(Trans_A)=\',ssTransformed_A.shape)\n                        if (verbose):\n                            print(\'===== Transformed SS ==========\')\n                            print(matlab.ss(ssTransformed_A, ssTransformed_B,\n                                            ssTransformed_C, ssTransformed_D))\n                            # print(\'Trans_nr=\',ssTransformed_nr\n                            # print(\'tfOrig_index=\',tfOriginal_index)\n                            # print(\'tfOrig_ucoeff=\',tfOriginal_ucoeff)\n                            # print(\'tfOrig_dcoeff=\',tfOriginal_dcoeff)\n                            # print(\'tfTrans_index=\',tfTransformed_index)\n                            # print(\'tfTrans_ucoeff=\',tfTransformed_ucoeff)\n                            # print(\'tfTrans_dcoeff=\',tfTransformed_dcoeff)\n                        # Compare the TF directly, must match\n                        # numerators\n                        # TODO test failing!\n                        # np.testing.assert_array_almost_equal(\n                        #    tfOriginal_ucoeff, tfTransformed_ucoeff, decimal=3)\n                        # denominators\n                        # np.testing.assert_array_almost_equal(\n                        #    tfOriginal_dcoeff, tfTransformed_dcoeff, decimal=3)\n\n    def testFreqResp(self):\n        """"""Compare the bode reponses of the SS systems and TF systems to the original SS\n           They generally are different realizations but have same freq resp.\n           Currently this test may only be applied to SISO systems.\n        """"""\n        from slycot import tb04ad, td04ad\n        for states in range(1, self.maxStates):\n            for testNum in range(self.numTests):\n                for inputs in range(1, 1):\n                    for outputs in range(1, 1):\n                        ssOriginal = matlab.rss(states, outputs, inputs)\n\n                        tfOriginal_Actrb, tfOriginal_Bctrb, tfOriginal_Cctrb,\\\n                            tfOrigingal_nctrb, tfOriginal_index,\\\n                            tfOriginal_dcoeff, tfOriginal_ucoeff = tb04ad(\n                                states, inputs, outputs, ssOriginal.A,\n                                ssOriginal.B, ssOriginal.C, ssOriginal.D,\n                                tol1=0.0)\n\n                        ssTransformed_nr, ssTransformed_A, ssTransformed_B,\\\n                            ssTransformed_C, ssTransformed_D\\\n                            = td04ad(\'R\', inputs, outputs, tfOriginal_index,\n                                     tfOriginal_dcoeff, tfOriginal_ucoeff,\n                                     tol=0.0)\n\n                        tfTransformed_Actrb, tfTransformed_Bctrb,\\\n                            tfTransformed_Cctrb, tfTransformed_nctrb,\\\n                            tfTransformed_index, tfTransformed_dcoeff,\\\n                            tfTransformed_ucoeff = tb04ad(\n                                ssTransformed_nr, inputs, outputs,\n                                ssTransformed_A, ssTransformed_B,\n                                ssTransformed_C, ssTransformed_D,\n                                tol1=0.0)\n\n                        numTransformed = np.array(tfTransformed_ucoeff)\n                        denTransformed = np.array(tfTransformed_dcoeff)\n                        numOriginal = np.array(tfOriginal_ucoeff)\n                        denOriginal = np.array(tfOriginal_dcoeff)\n\n                        ssTransformed = matlab.ss(ssTransformed_A,\n                                                  ssTransformed_B,\n                                                  ssTransformed_C,\n                                                  ssTransformed_D)\n                        for inputNum in range(inputs):\n                            for outputNum in range(outputs):\n                                [ssOriginalMag, ssOriginalPhase, freq] =\\\n                                    matlab.bode(ssOriginal, Plot=False)\n                                [tfOriginalMag, tfOriginalPhase, freq] =\\\n                                    matlab.bode(matlab.tf(\n                                        numOriginal[outputNum][inputNum],\n                                        denOriginal[outputNum]), Plot=False)\n                                [ssTransformedMag, ssTransformedPhase, freq] =\\\n                                    matlab.bode(ssTransformed,\n                                                freq, Plot=False)\n                                [tfTransformedMag, tfTransformedPhase, freq] =\\\n                                    matlab.bode(matlab.tf(\n                                        numTransformed[outputNum][inputNum],\n                                        denTransformed[outputNum]),\n                                        freq, Plot=False)\n                                # print(\'numOrig=\',\n                                #  numOriginal[outputNum][inputNum])\n                                # print(\'denOrig=\',\n                                #  denOriginal[outputNum])\n                                # print(\'numTrans=\',\n                                #  numTransformed[outputNum][inputNum])\n                                # print(\'denTrans=\',\n                                #  denTransformed[outputNum])\n                                np.testing.assert_array_almost_equal(\n                                    ssOriginalMag, tfOriginalMag, decimal=3)\n                                np.testing.assert_array_almost_equal(\n                                    ssOriginalPhase, tfOriginalPhase,\n                                    decimal=3)\n                                np.testing.assert_array_almost_equal(\n                                    ssOriginalMag, ssTransformedMag, decimal=3)\n                                np.testing.assert_array_almost_equal(\n                                    ssOriginalPhase, ssTransformedPhase,\n                                    decimal=3)\n                                np.testing.assert_array_almost_equal(\n                                    tfOriginalMag, tfTransformedMag, decimal=3)\n                                np.testing.assert_array_almost_equal(\n                                    tfOriginalPhase, tfTransformedPhase,\n                                    decimal=2)\n\n\n# These are here for once the above is made into a unittest.\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestSlycot)\n\nif __name__ == \'__main__\':\n    unittest.main()\n\n'"
External_Libraries/python_control_master/control/tests/statefbk_array_test.py,130,"b'#!/usr/bin/env python\n#\n# statefbk_test.py - test state feedback functions\n# RMM, 30 Mar 2011 (based on TestStatefbk from v0.4a)\n\nfrom __future__ import print_function\nimport unittest\nimport sys as pysys\nimport numpy as np\nimport warnings\nfrom control.statefbk import ctrb, obsv, place, place_varga, lqr, gram, acker\nfrom control.matlab import *\nfrom control.exception import slycot_check, ControlDimension\nfrom control.mateqn import care, dare\nfrom control.config import use_numpy_matrix, reset_defaults\n\nclass TestStatefbk(unittest.TestCase):\n    """"""Test state feedback functions""""""\n\n    def setUp(self):\n        # Use array instead of matrix (and save old value to restore at end)\n        use_numpy_matrix(False)\n\n        # Maximum number of states to test + 1\n        self.maxStates = 5\n        # Maximum number of inputs and outputs to test + 1\n        self.maxTries = 4\n        # Set to True to print systems to the output.\n        self.debug = False\n        # get consistent test results\n        np.random.seed(0)\n\n    def testCtrbSISO(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        B = np.array([[5.], [7.]])\n        Wctrue = np.array([[5., 19.], [7., 43.]])\n\n        Wc = ctrb(A, B)\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n        self.assertTrue(isinstance(Wc, np.ndarray))\n        self.assertFalse(isinstance(Wc, np.matrix))\n\n    # This test only works in Python 3 due to a conflict with the same\n    # warning type in other test modules (frd_test.py).  See\n    # https://bugs.python.org/issue4180 for more details\n    @unittest.skipIf(pysys.version_info < (3, 0), ""test requires Python 3+"")\n    def test_ctrb_siso_deprecated(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        B = np.array([[5.], [7.]])\n        \n        # Check that default using np.matrix generates a warning\n        # TODO: remove this check with matrix type is deprecated\n        warnings.resetwarnings()\n        with warnings.catch_warnings(record=True) as w:\n            use_numpy_matrix(True)\n            self.assertTrue(issubclass(w[-1].category, UserWarning))\n            \n            Wc = ctrb(A, B)\n            self.assertTrue(isinstance(Wc, np.matrix))\n            self.assertTrue(issubclass(w[-1].category,\n                                       PendingDeprecationWarning))\n            use_numpy_matrix(False)\n\n    def testCtrbMIMO(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        Wctrue = np.array([[5., 6., 19., 22.], [7., 8., 43., 50.]])\n        Wc = ctrb(A, B)\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n\n        # Make sure default type values are correct\n        self.assertTrue(isinstance(Wc, np.ndarray))\n\n    def testObsvSISO(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        C = np.array([[5., 7.]])\n        Wotrue = np.array([[5., 7.], [26., 38.]])\n        Wo = obsv(A, C)\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n        # Make sure default type values are correct\n        self.assertTrue(isinstance(Wo, np.ndarray))\n\n    # This test only works in Python 3 due to a conflict with the same\n    # warning type in other test modules (frd_test.py).  See\n    # https://bugs.python.org/issue4180 for more details\n    @unittest.skipIf(pysys.version_info < (3, 0), ""test requires Python 3+"")\n    def test_obsv_siso_deprecated(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        C = np.array([[5., 7.]])\n\n        # Check that default type generates a warning\n        # TODO: remove this check with matrix type is deprecated\n        with warnings.catch_warnings(record=True) as w:\n            use_numpy_matrix(True, warn=False) # warnings off\n            self.assertEqual(len(w), 0)\n            \n            Wo = obsv(A, C)\n            self.assertTrue(isinstance(Wo, np.matrix))\n            use_numpy_matrix(False)\n\n    def testObsvMIMO(self):\n        A = np.array([[1., 2.], [3., 4.]])\n        C = np.array([[5., 6.], [7., 8.]])\n        Wotrue = np.array([[5., 6.], [7., 8.], [23., 34.], [31., 46.]])\n        Wo = obsv(A, C)\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    def testCtrbObsvDuality(self):\n        A = np.array([[1.2, -2.3], [3.4, -4.5]])\n        B = np.array([[5.8, 6.9], [8., 9.1]])\n        Wc = ctrb(A, B)\n        A = np.transpose(A)\n        C = np.transpose(B)\n        Wo = np.transpose(obsv(A, C));\n        np.testing.assert_array_almost_equal(Wc,Wo)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWc(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        C = np.array([[4., 5.], [6., 7.]])\n        D = np.array([[13., 14.], [15., 16.]])\n        sys = ss(A, B, C, D)\n        Wctrue = np.array([[18.5, 24.5], [24.5, 32.5]])\n        Wc = gram(sys, \'c\')\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n\n    # This test only works in Python 3 due to a conflict with the same\n    # warning type in other test modules (frd_test.py).  See\n    # https://bugs.python.org/issue4180 for more details\n    @unittest.skipIf(pysys.version_info < (3, 0) or not slycot_check(),\n                     ""test requires Python 3+ and slycot"")\n    def test_gram_wc_deprecated(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        C = np.array([[4., 5.], [6., 7.]])\n        D = np.array([[13., 14.], [15., 16.]])\n        sys = ss(A, B, C, D)\n\n        # Check that default type generates a warning\n        # TODO: remove this check with matrix type is deprecated\n        with warnings.catch_warnings(record=True) as w:\n            use_numpy_matrix(True)\n            self.assertTrue(issubclass(w[-1].category, UserWarning))\n            \n            Wc = gram(sys, \'c\')\n            self.assertTrue(isinstance(Wc, np.ndarray))\n            use_numpy_matrix(False)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramRc(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        C = np.array([[4., 5.], [6., 7.]])\n        D = np.array([[13., 14.], [15., 16.]])\n        sys = ss(A, B, C, D)\n        Rctrue = np.array([[4.30116263, 5.6961343], [0., 0.23249528]])\n        Rc = gram(sys, \'cf\')\n        np.testing.assert_array_almost_equal(Rc, Rctrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWo(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        C = np.array([[4., 5.], [6., 7.]])\n        D = np.array([[13., 14.], [15., 16.]])\n        sys = ss(A, B, C, D)\n        Wotrue = np.array([[257.5, -94.5], [-94.5, 56.5]])\n        Wo = gram(sys, \'o\')\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWo2(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n        C = np.array([[6., 8.]])\n        D = np.array([[9.]])\n        sys = ss(A,B,C,D)\n        Wotrue = np.array([[198., -72.], [-72., 44.]])\n        Wo = gram(sys, \'o\')\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramRo(self):\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5., 6.], [7., 8.]])\n        C = np.array([[4., 5.], [6., 7.]])\n        D = np.array([[13., 14.], [15., 16.]])\n        sys = ss(A, B, C, D)\n        Rotrue = np.array([[16.04680654, -5.8890222], [0., 4.67112593]])\n        Ro = gram(sys, \'of\')\n        np.testing.assert_array_almost_equal(Ro, Rotrue)\n\n    def testGramsys(self):\n        num =[1.]\n        den = [1., 1., 1.]\n        sys = tf(num,den)\n        self.assertRaises(ValueError, gram, sys, \'o\')\n        self.assertRaises(ValueError, gram, sys, \'c\')\n\n    def testAcker(self):\n        for states in range(1, self.maxStates):\n            for i in range(self.maxTries):\n                # start with a random SS system and transform to TF then\n                # back to SS, check that the matrices are the same.\n                sys = rss(states, 1, 1)\n                if (self.debug):\n                    print(sys)\n\n                # Make sure the system is not degenerate\n                Cmat = ctrb(sys.A, sys.B)\n                if np.linalg.matrix_rank(Cmat) != states:\n                    if (self.debug):\n                        print(""  skipping (not reachable or ill conditioned)"")\n                        continue\n\n                # Place the poles at random locations\n                des = rss(states, 1, 1);\n                poles = pole(des)\n\n                # Now place the poles using acker\n                K = acker(sys.A, sys.B, poles)\n                new = ss(sys.A - sys.B * K, sys.B, sys.C, sys.D)\n                placed = pole(new)\n\n                # Debugging code\n                # diff = np.sort(poles) - np.sort(placed)\n                # if not all(diff < 0.001):\n                #     print(""Found a problem:"")\n                #     print(sys)\n                #     print(""desired = "", poles)\n\n                np.testing.assert_array_almost_equal(np.sort(poles),\n                                                     np.sort(placed), decimal=4)\n\n    def testPlace(self):\n        # Matrices shamelessly stolen from scipy example code.\n        A = np.array([[1.380,  -0.2077,  6.715, -5.676],\n                      [-0.5814, -4.290,   0,      0.6750],\n                      [1.067,   4.273,  -6.654,  5.893],\n                      [0.0480,  4.273,   1.343, -2.104]])\n\n        B = np.array([[0,      5.679],\n                      [1.136,  1.136],\n                      [0,      0,],\n                      [-3.146,  0]])\n        P = np.array([-0.5+1j, -0.5-1j, -5.0566, -8.6659])\n        K = place(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n        # Test that the dimension checks work.\n        np.testing.assert_raises(ControlDimension, place, A[1:, :], B, P)\n        np.testing.assert_raises(ControlDimension, place, A, B[1:, :], P)\n\n        # Check that we get an error if we ask for too many poles in the same\n        # location. Here, rank(B) = 2, so lets place three at the same spot.\n        P_repeated = np.array([-0.5, -0.5, -0.5, -8.6659])\n        np.testing.assert_raises(ValueError, place, A, B, P_repeated)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_continuous(self):\n        """"""\n        Check that we can place eigenvalues for dtime=False\n        """"""\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([-2., -2.])\n        K = place_varga(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n        # Test that the dimension checks work.\n        np.testing.assert_raises(ControlDimension, place, A[1:, :], B, P)\n        np.testing.assert_raises(ControlDimension, place, A, B[1:, :], P)\n\n        # Regression test against bug #177\n        # https://github.com/python-control/python-control/issues/177\n        A = np.array([[0, 1], [100, 0]])\n        B = np.array([[0], [1]])\n        P = np.array([-20 + 10*1j, -20 - 10*1j])\n        K = place_varga(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_continuous_partial_eigs(self):\n        """"""\n        Check that we are able to use the alpha parameter to only place\n        a subset of the eigenvalues, for the continous time case.\n        """"""\n        # A matrix has eigenvalues at s=-1, and s=-2. Choose alpha = -1.5\n        # and check that eigenvalue at s=-2 stays put.\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([-3.])\n        P_expected = np.array([-2.0, -3.0])\n        alpha = -1.5\n        K = place_varga(A, B, P, alpha=alpha)\n\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P_expected.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P_expected, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_discrete(self):\n        """"""\n        Check that we can place poles using dtime=True (discrete time)\n        """"""\n        A = np.array([[1., 0], [0, 0.5]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([0.5, 0.5])\n        K = place_varga(A, B, P, dtime=True)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_discrete_partial_eigs(self):\n        """"""""\n        Check that we can only assign a single eigenvalue in the discrete\n        time case.\n        """"""\n        # A matrix has eigenvalues at 1.0 and 0.5. Set alpha = 0.51, and\n        # check that the eigenvalue at 0.5 is not moved.\n        A = np.array([[1., 0], [0, 0.5]])\n        B = np.array([[5.], [7.]])\n        P = np.array([0.2, 0.6])\n        P_expected = np.array([0.5, 0.6])\n        alpha = 0.51\n        K = place_varga(A, B, P, dtime=True, alpha=alpha)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        P_expected.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P_expected, P_placed)\n\n\n    def check_LQR(self, K, S, poles, Q, R):\n        S_expected = np.array(np.sqrt(Q * R))\n        K_expected = S_expected / R\n        poles_expected = np.array([-K_expected])\n        np.testing.assert_array_almost_equal(S, S_expected)\n        np.testing.assert_array_almost_equal(K, K_expected)\n        np.testing.assert_array_almost_equal(poles, poles_expected)\n\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_LQR_integrator(self):\n        A, B, Q, R = 0., 1., 10., 2.\n        K, S, poles = lqr(A, B, Q, R)\n        self.check_LQR(K, S, poles, Q, R)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_LQR_3args(self):\n        sys = ss(0., 1., 1., 0.)\n        Q, R = 10., 2.\n        K, S, poles = lqr(sys, Q, R)\n        self.check_LQR(K, S, poles, Q, R)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_care(self):\n        #unit test for stabilizing and anti-stabilizing feedbacks\n        #continuous-time\n\n        A = np.diag([1,-1])\n        B = np.identity(2)\n        Q = np.identity(2)\n        R = np.identity(2)\n        S = 0 * B\n        E = np.identity(2)\n        X, L , G = care(A, B, Q, R, S, E, stabilizing=True)\n        assert np.all(np.real(L) < 0)\n        X, L , G = care(A, B, Q, R, S, E, stabilizing=False)\n        assert np.all(np.real(L) > 0)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_dare(self):\n        #discrete-time\n        A = np.diag([0.5,2])\n        B = np.identity(2)\n        Q = np.identity(2)\n        R = np.identity(2)\n        S = 0 * B\n        E = np.identity(2)\n        X, L , G = dare(A, B, Q, R, S, E, stabilizing=True)\n        assert np.all(np.abs(L) < 1)\n        X, L , G = dare(A, B, Q, R, S, E, stabilizing=False)\n        assert np.all(np.abs(L) > 1)\n\n    def tearDown(self):\n        reset_defaults()\n\n\ndef test_suite():\n    \n   status1 = unittest.TestLoader().loadTestsFromTestCase(TestStatefbk)\n   status2 = unittest.TestLoader().loadTestsFromTestCase(TestStatefbk)\n   return status1 and status2\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/statefbk_test.py,114,"b'#!/usr/bin/env python\n#\n# statefbk_test.py - test state feedback functions\n# RMM, 30 Mar 2011 (based on TestStatefbk from v0.4a)\n\nfrom __future__ import print_function\nimport unittest\nimport numpy as np\nfrom control.statefbk import ctrb, obsv, place, place_varga, lqr, gram, acker\nfrom control.matlab import *\nfrom control.exception import slycot_check, ControlDimension\nfrom control.mateqn import care, dare\n\nclass TestStatefbk(unittest.TestCase):\n    """"""Test state feedback functions""""""\n\n    def setUp(self):\n        # Maximum number of states to test + 1\n        self.maxStates = 5\n        # Maximum number of inputs and outputs to test + 1\n        self.maxTries = 4\n        # Set to True to print systems to the output.\n        self.debug = False\n        # get consistent test results\n        np.random.seed(0)\n\n    def testCtrbSISO(self):\n        A = np.matrix(""1. 2.; 3. 4."")\n        B = np.matrix(""5.; 7."")\n        Wctrue = np.matrix(""5. 19.; 7. 43."")\n        Wc = ctrb(A,B)\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n\n    def testCtrbMIMO(self):\n        A = np.matrix(""1. 2.; 3. 4."")\n        B = np.matrix(""5. 6.; 7. 8."")\n        Wctrue = np.matrix(""5. 6. 19. 22.; 7. 8. 43. 50."")\n        Wc = ctrb(A,B)\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n\n    def testObsvSISO(self):\n        A = np.matrix(""1. 2.; 3. 4."")\n        C = np.matrix(""5. 7."")\n        Wotrue = np.matrix(""5. 7.; 26. 38."")\n        Wo = obsv(A,C)\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    def testObsvMIMO(self):\n        A = np.matrix(""1. 2.; 3. 4."")\n        C = np.matrix(""5. 6.; 7. 8."")\n        Wotrue = np.matrix(""5. 6.; 7. 8.; 23. 34.; 31. 46."")\n        Wo = obsv(A,C)\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    def testCtrbObsvDuality(self):\n        A = np.matrix(""1.2 -2.3; 3.4 -4.5"")\n        B = np.matrix(""5.8 6.9; 8. 9.1"")\n        Wc = ctrb(A,B);\n        A = np.transpose(A)\n        C = np.transpose(B)\n        Wo = np.transpose(obsv(A,C));\n        np.testing.assert_array_almost_equal(Wc,Wo)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWc(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5. 6.; 7. 8."")\n        C = np.matrix(""4. 5.; 6. 7."")\n        D = np.matrix(""13. 14.; 15. 16."")\n        sys = ss(A, B, C, D)\n        Wctrue = np.matrix(""18.5 24.5; 24.5 32.5"")\n        Wc = gram(sys,\'c\')\n        np.testing.assert_array_almost_equal(Wc, Wctrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramRc(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5. 6.; 7. 8."")\n        C = np.matrix(""4. 5.; 6. 7."")\n        D = np.matrix(""13. 14.; 15. 16."")\n        sys = ss(A, B, C, D)\n        Rctrue = np.matrix(""4.30116263 5.6961343; 0. 0.23249528"")\n        Rc = gram(sys,\'cf\')\n        np.testing.assert_array_almost_equal(Rc, Rctrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWo(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5. 6.; 7. 8."")\n        C = np.matrix(""4. 5.; 6. 7."")\n        D = np.matrix(""13. 14.; 15. 16."")\n        sys = ss(A, B, C, D)\n        Wotrue = np.matrix(""257.5 -94.5; -94.5 56.5"")\n        Wo = gram(sys,\'o\')\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramWo2(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5.; 7."")\n        C = np.matrix(""6. 8."")\n        D = np.matrix(""9."")\n        sys = ss(A,B,C,D)\n        Wotrue = np.matrix(""198. -72.; -72. 44."")\n        Wo = gram(sys,\'o\')\n        np.testing.assert_array_almost_equal(Wo, Wotrue)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testGramRo(self):\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5. 6.; 7. 8."")\n        C = np.matrix(""4. 5.; 6. 7."")\n        D = np.matrix(""13. 14.; 15. 16."")\n        sys = ss(A, B, C, D)\n        Rotrue = np.matrix(""16.04680654 -5.8890222; 0. 4.67112593"")\n        Ro = gram(sys,\'of\')\n        np.testing.assert_array_almost_equal(Ro, Rotrue)\n\n    def testGramsys(self):\n        num =[1.]\n        den = [1., 1., 1.]\n        sys = tf(num,den)\n        self.assertRaises(ValueError, gram, sys, \'o\')\n        self.assertRaises(ValueError, gram, sys, \'c\')\n\n    def testAcker(self):\n        for states in range(1, self.maxStates):\n            for i in range(self.maxTries):\n                # start with a random SS system and transform to TF then\n                # back to SS, check that the matrices are the same.\n                sys = rss(states, 1, 1)\n                if (self.debug):\n                    print(sys)\n\n                # Make sure the system is not degenerate\n                Cmat = ctrb(sys.A, sys.B)\n                if np.linalg.matrix_rank(Cmat) != states:\n                    if (self.debug):\n                        print(""  skipping (not reachable or ill conditioned)"")\n                        continue\n\n                # Place the poles at random locations\n                des = rss(states, 1, 1);\n                poles = pole(des)\n\n                # Now place the poles using acker\n                K = acker(sys.A, sys.B, poles)\n                new = ss(sys.A - sys.B * K, sys.B, sys.C, sys.D)\n                placed = pole(new)\n\n                # Debugging code\n                # diff = np.sort(poles) - np.sort(placed)\n                # if not all(diff < 0.001):\n                #     print(""Found a problem:"")\n                #     print(sys)\n                #     print(""desired = "", poles)\n\n                np.testing.assert_array_almost_equal(np.sort(poles),\n                                                     np.sort(placed), decimal=4)\n\n    def testPlace(self):\n        # Matrices shamelessly stolen from scipy example code.\n        A = np.array([[1.380,  -0.2077,  6.715, -5.676],\n                      [-0.5814, -4.290,   0,      0.6750],\n                      [1.067,   4.273,  -6.654,  5.893],\n                      [0.0480,  4.273,   1.343, -2.104]])\n\n        B = np.array([[0,      5.679],\n                      [1.136,  1.136],\n                      [0,      0,],\n                      [-3.146,  0]])\n        P = np.array([-0.5+1j, -0.5-1j, -5.0566, -8.6659])\n        K = place(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n        # Test that the dimension checks work.\n        np.testing.assert_raises(ControlDimension, place, A[1:, :], B, P)\n        np.testing.assert_raises(ControlDimension, place, A, B[1:, :], P)\n\n        # Check that we get an error if we ask for too many poles in the same\n        # location. Here, rank(B) = 2, so lets place three at the same spot.\n        P_repeated = np.array([-0.5, -0.5, -0.5, -8.6659])\n        np.testing.assert_raises(ValueError, place, A, B, P_repeated)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_continuous(self):\n        """"""\n        Check that we can place eigenvalues for dtime=False\n        """"""\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([-2., -2.])\n        K = place_varga(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n        # Test that the dimension checks work.\n        np.testing.assert_raises(ControlDimension, place, A[1:, :], B, P)\n        np.testing.assert_raises(ControlDimension, place, A, B[1:, :], P)\n\n        # Regression test against bug #177\n        # https://github.com/python-control/python-control/issues/177\n        A = np.array([[0, 1], [100, 0]])\n        B = np.array([[0], [1]])\n        P = np.array([-20 + 10*1j, -20 - 10*1j])\n        K = place_varga(A, B, P)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_continuous_partial_eigs(self):\n        """"""\n        Check that we are able to use the alpha parameter to only place\n        a subset of the eigenvalues, for the continous time case.\n        """"""\n        # A matrix has eigenvalues at s=-1, and s=-2. Choose alpha = -1.5\n        # and check that eigenvalue at s=-2 stays put.\n        A = np.array([[1., -2.], [3., -4.]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([-3.])\n        P_expected = np.array([-2.0, -3.0])\n        alpha = -1.5\n        K = place_varga(A, B, P, alpha=alpha)\n\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P_expected.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P_expected, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_discrete(self):\n        """"""\n        Check that we can place poles using dtime=True (discrete time)\n        """"""\n        A = np.array([[1., 0], [0, 0.5]])\n        B = np.array([[5.], [7.]])\n\n        P = np.array([0.5, 0.5])\n        K = place_varga(A, B, P, dtime=True)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        # No guarantee of the ordering, so sort them\n        P.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P, P_placed)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def testPlace_varga_discrete_partial_eigs(self):\n        """"""""\n        Check that we can only assign a single eigenvalue in the discrete\n        time case.\n        """"""\n        # A matrix has eigenvalues at 1.0 and 0.5. Set alpha = 0.51, and\n        # check that the eigenvalue at 0.5 is not moved.\n        A = np.array([[1., 0], [0, 0.5]])\n        B = np.array([[5.], [7.]])\n        P = np.array([0.2, 0.6])\n        P_expected = np.array([0.5, 0.6])\n        alpha = 0.51\n        K = place_varga(A, B, P, dtime=True, alpha=alpha)\n        P_placed = np.linalg.eigvals(A - B.dot(K))\n        P_expected.sort()\n        P_placed.sort()\n        np.testing.assert_array_almost_equal(P_expected, P_placed)\n\n\n    def check_LQR(self, K, S, poles, Q, R):\n        S_expected = np.array(np.sqrt(Q * R))\n        K_expected = S_expected / R\n        poles_expected = np.array([-K_expected])\n        np.testing.assert_array_almost_equal(S, S_expected)\n        np.testing.assert_array_almost_equal(K, K_expected)\n        np.testing.assert_array_almost_equal(poles, poles_expected)\n\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_LQR_integrator(self):\n        A, B, Q, R = 0., 1., 10., 2.\n        K, S, poles = lqr(A, B, Q, R)\n        self.check_LQR(K, S, poles, Q, R)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_LQR_3args(self):\n        sys = ss(0., 1., 1., 0.)\n        Q, R = 10., 2.\n        K, S, poles = lqr(sys, Q, R)\n        self.check_LQR(K, S, poles, Q, R)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_care(self):\n        #unit test for stabilizing and anti-stabilizing feedbacks\n        #continuous-time\n\n        A = np.diag([1,-1])\n        B = np.identity(2)\n        Q = np.identity(2)\n        R = np.identity(2)\n        S = 0 * B\n        E = np.identity(2)\n        X, L , G = care(A, B, Q, R, S, E, stabilizing=True)\n        assert np.all(np.real(L) < 0)\n        X, L , G = care(A, B, Q, R, S, E, stabilizing=False)\n        assert np.all(np.real(L) > 0)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_dare(self):\n        #discrete-time\n        A = np.diag([0.5,2])\n        B = np.identity(2)\n        Q = np.identity(2)\n        R = np.identity(2)\n        S = 0 * B\n        E = np.identity(2)\n        X, L , G = dare(A, B, Q, R, S, E, stabilizing=True)\n        assert np.all(np.abs(L) < 1)\n        X, L , G = dare(A, B, Q, R, S, E, stabilizing=False)\n        assert np.all(np.abs(L) > 1)\n\n\ndef test_suite():\n   return unittest.TestLoader().loadTestsFromTestCase(TestStatefbk)\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/statesp_array_test.py,113,"b'#!/usr/bin/env python\n#\n# statesp_test.py - test state space class with use_numpy_matrix(False)\n# RMM, 14 Jun 2019 (coverted from statesp_test.py)\n\nimport unittest\nimport numpy as np\nfrom numpy.linalg import solve\nfrom scipy.linalg import eigvals, block_diag\nfrom control import matlab\nfrom control.statesp import StateSpace, _convertToStateSpace, tf2ss\nfrom control.xferfcn import TransferFunction, ss2tf\nfrom control.lti import evalfr\nfrom control.exception import slycot_check\nfrom control.config import use_numpy_matrix, reset_defaults\n\nclass TestStateSpace(unittest.TestCase):\n    """"""Tests for the StateSpace class.""""""\n\n    def setUp(self):\n        """"""Set up a MIMO system to test operations on.""""""\n        use_numpy_matrix(False)\n\n        # sys1: 3-states square system (2 inputs x 2 outputs)\n        A322 = [[-3., 4., 2.],\n                [-1., -3., 0.],\n                [2., 5., 3.]]\n        B322 = [[1., 4.],\n                [-3., -3.],\n                [-2., 1.]]\n        C322 = [[4., 2., -3.],\n                [1., 4., 3.]]\n        D322 = [[-2., 4.],\n                [0., 1.]]\n        self.sys322 = StateSpace(A322, B322, C322, D322)\n\n        # sys1: 2-states square system (2 inputs x 2 outputs)\n        A222 = [[4., 1.],\n                [2., -3]]\n        B222 = [[5., 2.],\n                [-3., -3.]]\n        C222 = [[2., -4],\n                [0., 1.]]\n        D222 = [[3., 2.],\n                [1., -1.]]\n        self.sys222 = StateSpace(A222, B222, C222, D222)\n\n        # sys3: 6 states non square system (2 inputs x 3 outputs)\n        A623 = np.array([[1, 0, 0, 0, 0, 0],\n                         [0, 1, 0, 0, 0, 0],\n                         [0, 0, 3, 0, 0, 0],\n                         [0, 0, 0, -4, 0, 0],\n                         [0, 0, 0, 0, -1, 0],\n                         [0, 0, 0, 0, 0, 3]])\n        B623 = np.array([[0, -1],\n                        [-1, 0],\n                        [1, -1],\n                        [0, 0],\n                        [0, 1],\n                        [-1, -1]])\n        C623 = np.array([[1, 0, 0, 1, 0, 0],\n                         [0, 1, 0, 1, 0, 1],\n                         [0, 0, 1, 0, 0, 1]])\n        D623 = np.zeros((3, 2))\n        self.sys623 = StateSpace(A623, B623, C623, D623)\n\n    def test_matlab_style_constructor(self):\n        # Use (deprecated?) matrix-style construction string (w/ warnings off)\n        import warnings\n        warnings.filterwarnings(""ignore"")   # turn off warnings\n        sys = StateSpace(""-1 1; 0 2"", ""0; 1"", ""1, 0"", ""0"")\n        warnings.resetwarnings()            # put things back to original state\n        self.assertEqual(sys.A.shape, (2, 2))\n        self.assertEqual(sys.B.shape, (2, 1))\n        self.assertEqual(sys.C.shape, (1, 2))\n        self.assertEqual(sys.D.shape, (1, 1))\n        for X in [sys.A, sys.B, sys.C, sys.D]:\n            self.assertTrue(isinstance(X, np.matrix))\n\n    def test_pole(self):\n        """"""Evaluate the poles of a MIMO system.""""""\n\n        p = np.sort(self.sys322.pole())\n        true_p = np.sort([3.34747678408874,\n                          -3.17373839204437 + 1.47492908003839j,\n                          -3.17373839204437 - 1.47492908003839j])\n\n        np.testing.assert_array_almost_equal(p, true_p)\n\n    def test_zero_empty(self):\n        """"""Test to make sure zero() works with no zeros in system.""""""\n        sys = _convertToStateSpace(TransferFunction([1], [1, 2, 1]))\n        np.testing.assert_array_equal(sys.zero(), np.array([]))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_siso(self):\n        """"""Evaluate the zeros of a SISO system.""""""\n        # extract only first input / first output system of sys222. This system is denoted sys111\n        #  or tf111\n        tf111 = ss2tf(self.sys222)\n        sys111 = tf2ss(tf111[0, 0])\n\n        # compute zeros as root of the characteristic polynomial at the numerator of tf111\n        # this method is simple and assumed as valid in this test\n        true_z = np.sort(tf111[0, 0].zero())\n        # Compute the zeros through ab08nd, which is tested here\n        z = np.sort(sys111.zero())\n\n        np.testing.assert_almost_equal(true_z, z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys322_square(self):\n        """"""Evaluate the zeros of a square MIMO system.""""""\n\n        z = np.sort(self.sys322.zero())\n        true_z = np.sort([44.41465, -0.490252, -5.924398])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys222_square(self):\n        """"""Evaluate the zeros of a square MIMO system.""""""\n\n        z = np.sort(self.sys222.zero())\n        true_z = np.sort([-10.568501,   3.368501])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys623_non_square(self):\n        """"""Evaluate the zeros of a non square MIMO system.""""""\n\n        z = np.sort(self.sys623.zero())\n        true_z = np.sort([2., -1.])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    def test_add_ss(self):\n        """"""Add two MIMO systems.""""""\n\n        A = [[-3., 4., 2., 0., 0.], [-1., -3., 0., 0., 0.],\n             [2., 5., 3., 0., 0.], [0., 0., 0., 4., 1.], [0., 0., 0., 2., -3.]]\n        B = [[1., 4.], [-3., -3.], [-2., 1.], [5., 2.], [-3., -3.]]\n        C = [[4., 2., -3., 2., -4.], [1., 4., 3., 0., 1.]]\n        D = [[1., 6.], [1., 0.]]\n\n        sys = self.sys322 + self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_subtract_ss(self):\n        """"""Subtract two MIMO systems.""""""\n\n        A = [[-3., 4., 2., 0., 0.], [-1., -3., 0., 0., 0.],\n             [2., 5., 3., 0., 0.], [0., 0., 0., 4., 1.], [0., 0., 0., 2., -3.]]\n        B = [[1., 4.], [-3., -3.], [-2., 1.], [5., 2.], [-3., -3.]]\n        C = [[4., 2., -3., -2., 4.], [1., 4., 3., 0., -1.]]\n        D = [[-5., 2.], [-1., 2.]]\n\n        sys = self.sys322 - self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_multiply_ss(self):\n        """"""Multiply two MIMO systems.""""""\n\n        A = [[4., 1., 0., 0., 0.], [2., -3., 0., 0., 0.], [2., 0., -3., 4., 2.],\n             [-6., 9., -1., -3., 0.], [-4., 9., 2., 5., 3.]]\n        B = [[5., 2.], [-3., -3.], [7., -2.], [-12., -3.], [-5., -5.]]\n        C = [[-4., 12., 4., 2., -3.], [0., 1., 1., 4., 3.]]\n        D = [[-2., -8.], [1., -1.]]\n\n        sys = self.sys322 * self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_evalfr(self):\n        """"""Evaluate the frequency response at one frequency.""""""\n\n        A = [[-2, 0.5], [0.5, -0.3]]\n        B = [[0.3, -1.3], [0.1, 0.]]\n        C = [[0., 0.1], [-0.3, -0.2]]\n        D = [[0., -0.8], [-0.3, 0.]]\n        sys = StateSpace(A, B, C, D)\n\n        resp = [[4.37636761487965e-05 - 0.0152297592997812j,\n                 -0.792603938730853 + 0.0261706783369803j],\n                [-0.331544857768052 + 0.0576105032822757j,\n                 0.128919037199125 - 0.143824945295405j]]\n\n        # Correct versions of the call\n        np.testing.assert_almost_equal(evalfr(sys, 1j), resp)\n        np.testing.assert_almost_equal(sys._evalfr(1.), resp)\n\n        # Deprecated version of the call (should generate warning)\n        import warnings\n        with warnings.catch_warnings(record=True) as w:\n            # Set up warnings filter to only show warnings in control module\n            warnings.filterwarnings(""ignore"")\n            warnings.filterwarnings(""always"", module=""control"")\n\n            # Make sure that we get a pending deprecation warning\n            sys.evalfr(1.)\n            assert len(w) == 1\n            assert issubclass(w[-1].category, PendingDeprecationWarning)\n\n            # Leave the warnings filter like we found it\n            warnings.resetwarnings()\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_freq_resp(self):\n        """"""Evaluate the frequency response at multiple frequencies.""""""\n\n        A = [[-2, 0.5], [0.5, -0.3]]\n        B = [[0.3, -1.3], [0.1, 0.]]\n        C = [[0., 0.1], [-0.3, -0.2]]\n        D = [[0., -0.8], [-0.3, 0.]]\n        sys = StateSpace(A, B, C, D)\n\n        true_mag = [[[0.0852992637230322, 0.00103596611395218],\n                    [0.935374692849736, 0.799380720864549]],\n                   [[0.55656854563842, 0.301542699860857],\n                    [0.609178071542849, 0.0382108097985257]]]\n        true_phase = [[[-0.566195599644593, -1.68063565332582],\n                      [3.0465958317514, 3.14141384339534]],\n                     [[2.90457947657161, 3.10601268291914],\n                      [-0.438157380501337, -1.40720969147217]]]\n        true_omega = [0.1, 10.]\n\n        mag, phase, omega = sys.freqresp(true_omega)\n\n        np.testing.assert_almost_equal(mag, true_mag)\n        np.testing.assert_almost_equal(phase, true_phase)\n        np.testing.assert_equal(omega, true_omega)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_minreal(self):\n        """"""Test a minreal model reduction.""""""\n        # A = [-2, 0.5, 0; 0.5, -0.3, 0; 0, 0, -0.1]\n        A = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        # B = [0.3, -1.3; 0.1, 0; 1, 0]\n        B = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        # C = [0, 0.1, 0; -0.3, -0.2, 0]\n        C = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        # D = [0 -0.8; -0.3 0]\n        D = [[0., -0.8], [-0.3, 0.]]\n        # sys = ss(A, B, C, D)\n\n        sys = StateSpace(A, B, C, D)\n        sysr = sys.minreal()\n        self.assertEqual(sysr.states, 2)\n        self.assertEqual(sysr.inputs, sys.inputs)\n        self.assertEqual(sysr.outputs, sys.outputs)\n        np.testing.assert_array_almost_equal(\n            eigvals(sysr.A), [-2.136154, -0.1638459])\n\n    def test_append_ss(self):\n        """"""Test appending two state-space systems.""""""\n        A1 = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        B1 = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        C1 = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        D1 = [[0., -0.8], [-0.3, 0.]]\n        A2 = [[-1.]]\n        B2 = [[1.2]]\n        C2 = [[0.5]]\n        D2 = [[0.4]]\n        A3 = [[-2, 0.5, 0, 0], [0.5, -0.3, 0, 0], [0, 0, -0.1, 0],\n              [0, 0, 0., -1.]]\n        B3 = [[0.3, -1.3, 0], [0.1, 0., 0], [1.0, 0.0, 0], [0., 0, 1.2]]\n        C3 = [[0., 0.1, 0.0, 0.0], [-0.3, -0.2, 0.0, 0.0], [0., 0., 0., 0.5]]\n        D3 = [[0., -0.8, 0.], [-0.3, 0., 0.], [0., 0., 0.4]]\n        sys1 = StateSpace(A1, B1, C1, D1)\n        sys2 = StateSpace(A2, B2, C2, D2)\n        sys3 = StateSpace(A3, B3, C3, D3)\n        sys3c = sys1.append(sys2)\n        np.testing.assert_array_almost_equal(sys3.A, sys3c.A)\n        np.testing.assert_array_almost_equal(sys3.B, sys3c.B)\n        np.testing.assert_array_almost_equal(sys3.C, sys3c.C)\n        np.testing.assert_array_almost_equal(sys3.D, sys3c.D)\n\n    def test_append_tf(self):\n        """"""Test appending a state-space system with a tf""""""\n        A1 = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        B1 = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        C1 = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        D1 = [[0., -0.8], [-0.3, 0.]]\n        s = TransferFunction([1, 0], [1])\n        h = 1 / (s + 1) / (s + 2)\n        sys1 = StateSpace(A1, B1, C1, D1)\n        sys2 = _convertToStateSpace(h)\n        sys3c = sys1.append(sys2)\n        np.testing.assert_array_almost_equal(sys1.A, sys3c.A[:3, :3])\n        np.testing.assert_array_almost_equal(sys1.B, sys3c.B[:3, :2])\n        np.testing.assert_array_almost_equal(sys1.C, sys3c.C[:2, :3])\n        np.testing.assert_array_almost_equal(sys1.D, sys3c.D[:2, :2])\n        np.testing.assert_array_almost_equal(sys2.A, sys3c.A[3:, 3:])\n        np.testing.assert_array_almost_equal(sys2.B, sys3c.B[3:, 2:])\n        np.testing.assert_array_almost_equal(sys2.C, sys3c.C[2:, 3:])\n        np.testing.assert_array_almost_equal(sys2.D, sys3c.D[2:, 2:])\n        np.testing.assert_array_almost_equal(sys3c.A[:3, 3:], np.zeros((3, 2)))\n        np.testing.assert_array_almost_equal(sys3c.A[3:, :3], np.zeros((2, 3)))\n\n    def test_array_access_ss(self):\n\n        sys1 = StateSpace([[1., 2.], [3., 4.]],\n                          [[5., 6.], [6., 8.]],\n                          [[9., 10.], [11., 12.]],\n                          [[13., 14.], [15., 16.]], 1)\n\n        sys1_11 = sys1[0, 1]\n        np.testing.assert_array_almost_equal(sys1_11.A,\n                                             sys1.A)\n        np.testing.assert_array_almost_equal(sys1_11.B,\n                                             sys1.B[:, [1]])\n        np.testing.assert_array_almost_equal(sys1_11.C,\n                                             sys1.C[[0], :])\n        np.testing.assert_array_almost_equal(sys1_11.D, sys1.D[0,1])\n\n        assert sys1.dt == sys1_11.dt\n\n    def test_dc_gain_cont(self):\n        """"""Test DC gain for continuous-time state-space systems.""""""\n        sys = StateSpace(-2., 6., 5., 0)\n        np.testing.assert_equal(sys.dcgain(), 15.)\n\n        sys2 = StateSpace(-2, [[6., 4.]], [[5.], [7.], [11]], np.zeros((3, 2)))\n        expected = np.array([[15., 10.], [21., 14.], [33., 22.]])\n        np.testing.assert_array_equal(sys2.dcgain(), expected)\n\n        sys3 = StateSpace(0., 1., 1., 0.)\n        np.testing.assert_equal(sys3.dcgain(), np.nan)\n\n    def test_dc_gain_discr(self):\n        """"""Test DC gain for discrete-time state-space systems.""""""\n        # static gain\n        sys = StateSpace([], [], [], 2, True)\n        np.testing.assert_equal(sys.dcgain(), 2)\n\n        # averaging filter\n        sys = StateSpace(0.5, 0.5, 1, 0, True)\n        np.testing.assert_almost_equal(sys.dcgain(), 1)\n\n        # differencer\n        sys = StateSpace(0, 1, -1, 1, True)\n        np.testing.assert_equal(sys.dcgain(), 0)\n\n        # summer\n        sys = StateSpace(1, 1, 1, 0, True)\n        np.testing.assert_equal(sys.dcgain(), np.nan)\n\n    def test_dc_gain_integrator(self):\n        """"""DC gain when eigenvalue at DC returns appropriately sized array of nan.""""""\n        # the SISO case is also tested in test_dc_gain_{cont,discr}\n        import itertools\n        # iterate over input and output sizes, and continuous (dt=None) and discrete (dt=True) time\n        for inputs, outputs, dt in itertools.product(range(1, 6), range(1, 6), [None, True]):\n            states = max(inputs, outputs)\n\n            # a matrix that is singular at DC, and has no ""useless"" states as in\n            # _remove_useless_states\n            a = np.triu(np.tile(2, (states, states)))\n            # eigenvalues all +2, except for ...\n            a[0, 0] = 0 if dt is None else 1\n            b = np.eye(max(inputs, states))[:states, :inputs]\n            c = np.eye(max(outputs, states))[:outputs, :states]\n            d = np.zeros((outputs, inputs))\n            sys = StateSpace(a, b, c, d, dt)\n            dc = np.squeeze(np.tile(np.nan, (outputs, inputs)))\n            np.testing.assert_array_equal(dc, sys.dcgain())\n\n    def test_scalar_static_gain(self):\n        """"""Regression: can we create a scalar static gain?""""""\n        g1 = StateSpace([], [], [], [2])\n        g2 = StateSpace([], [], [], [3])\n\n        # make sure StateSpace internals, specifically ABC matrix\n        # sizes, are OK for LTI operations\n        g3 = g1 * g2\n        self.assertEqual(6, g3.D[0, 0])\n        g4 = g1 + g2\n        self.assertEqual(5, g4.D[0, 0])\n        g5 = g1.feedback(g2)\n        np.testing.assert_array_almost_equal(2. / 7, g5.D[0, 0])\n        g6 = g1.append(g2)\n        np.testing.assert_array_equal(np.diag([2, 3]), g6.D)\n\n    def test_matrix_static_gain(self):\n        """"""Regression: can we create matrix static gains?""""""\n        d1 = np.array([[1, 2, 3], [4, 5, 6]])\n        d2 = np.array([[7, 8], [9, 10], [11, 12]])\n        g1 = StateSpace([], [], [], d1)\n\n        # _remove_useless_states was making A = [[0]]\n        self.assertEqual((0, 0), g1.A.shape)\n\n        g2 = StateSpace([], [], [], d2)\n        g3 = StateSpace([], [], [], d2.T)\n\n        h1 = g1 * g2\n        np.testing.assert_array_equal(np.dot(d1, d2), h1.D)\n        h2 = g1 + g3\n        np.testing.assert_array_equal(d1 + d2.T, h2.D)\n        h3 = g1.feedback(g2)\n        np.testing.assert_array_almost_equal(\n            solve(np.eye(2) + np.dot(d1, d2), d1), h3.D)\n        h4 = g1.append(g2)\n        np.testing.assert_array_equal(block_diag(d1, d2), h4.D)\n\n    def test_remove_useless_states(self):\n        """"""Regression: _remove_useless_states gives correct ABC sizes.""""""\n        g1 = StateSpace(np.zeros((3, 3)),\n                        np.zeros((3, 4)),\n                        np.zeros((5, 3)),\n                        np.zeros((5, 4)))\n        self.assertEqual((0, 0), g1.A.shape)\n        self.assertEqual((0, 4), g1.B.shape)\n        self.assertEqual((5, 0), g1.C.shape)\n        self.assertEqual((5, 4), g1.D.shape)\n        self.assertEqual(0, g1.states)\n\n    def test_bad_empty_matrices(self):\n        """"""Mismatched ABCD matrices when some are empty.""""""\n        self.assertRaises(ValueError, StateSpace, [1], [], [], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [1], [], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [], [1], [], [1])\n        self.assertRaises(ValueError, StateSpace, [], [1], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [], [], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [1], [1], [])\n\n    def test_minreal_static_gain(self):\n        """"""Regression: minreal on static gain was failing.""""""\n        g1 = StateSpace([], [], [], [1])\n        g2 = g1.minreal()\n        np.testing.assert_array_equal(g1.A, g2.A)\n        np.testing.assert_array_equal(g1.B, g2.B)\n        np.testing.assert_array_equal(g1.C, g2.C)\n        np.testing.assert_array_equal(g1.D, g2.D)\n\n    def test_empty(self):\n        """"""Regression: can we create an empty StateSpace object?""""""\n        g1 = StateSpace([], [], [], [])\n        self.assertEqual(0, g1.states)\n        self.assertEqual(0, g1.inputs)\n        self.assertEqual(0, g1.outputs)\n\n    def test_matrix_to_state_space(self):\n        """"""_convertToStateSpace(matrix) gives ss([],[],[],D)""""""\n        D = np.array([[1, 2, 3], [4, 5, 6]])\n        g = _convertToStateSpace(D)\n\n        def empty(shape):\n            m = np.array([])\n            m.shape = shape\n            return m\n        np.testing.assert_array_equal(empty((0, 0)), g.A)\n        np.testing.assert_array_equal(empty((0, D.shape[1])), g.B)\n        np.testing.assert_array_equal(empty((D.shape[0], 0)), g.C)\n        np.testing.assert_array_equal(D, g.D)\n\n    def test_lft(self):\n        """""" test lft function with result obtained from matlab implementation""""""\n        # test case\n        A = [[1, 2, 3],\n             [1, 4, 5],\n             [2, 3, 4]]\n        B = [[0, 2],\n             [5, 6],\n             [5, 2]]\n        C = [[1, 4, 5],\n             [2, 3, 0]]\n        D = [[0, 0],\n             [3, 0]]\n        P = StateSpace(A, B, C, D)\n        Ak = [[0, 2, 3],\n              [2, 3, 5],\n              [2, 1, 9]]\n        Bk = [[1, 1],\n              [2, 3],\n              [9, 4]]\n        Ck = [[1, 4, 5],\n              [2, 3, 6]]\n        Dk = [[0, 2],\n              [0, 0]]\n        K = StateSpace(Ak, Bk, Ck, Dk)\n\n        # case 1\n        pk = P.lft(K, 2, 1)\n        Amatlab = [1, 2, 3, 4, 6, 12, 1, 4, 5, 17, 38, 61, 2, 3, 4, 9, 26, 37, 2, 3, 0, 3, 14, 18, 4, 6, 0, 8, 27, 35, 18, 27, 0, 29, 109, 144]\n        Bmatlab = [0, 10, 10, 7, 15, 58]\n        Cmatlab = [1, 4, 5, 0, 0, 0]\n        Dmatlab = [0]\n        np.testing.assert_allclose(np.array(pk.A).reshape(-1), Amatlab)\n        np.testing.assert_allclose(np.array(pk.B).reshape(-1), Bmatlab)\n        np.testing.assert_allclose(np.array(pk.C).reshape(-1), Cmatlab)\n        np.testing.assert_allclose(np.array(pk.D).reshape(-1), Dmatlab)\n\n        # case 2\n        pk = P.lft(K)\n        Amatlab = [1, 2, 3, 4, 6, 12, -3, -2, 5, 11, 14, 31, -2, -3, 4, 3, 2, 7, 0.6, 3.4, 5, -0.6, -0.4, 0, 0.8, 6.2, 10, 0.2, -4.2, -4, 7.4, 33.6, 45, -0.4, -8.6, -3]\n        Bmatlab = []\n        Cmatlab = []\n        Dmatlab = []\n        np.testing.assert_allclose(np.array(pk.A).reshape(-1), Amatlab)\n        np.testing.assert_allclose(np.array(pk.B).reshape(-1), Bmatlab)\n        np.testing.assert_allclose(np.array(pk.C).reshape(-1), Cmatlab)\n        np.testing.assert_allclose(np.array(pk.D).reshape(-1), Dmatlab)\n\n    def test_horner(self):\n        """"""Test horner() function""""""\n        # Make sure we can compute the transfer function at a complex value\n        self.sys322.horner(1.+1.j)\n\n        # Make sure result agrees with frequency response\n        mag, phase, omega = self.sys322.freqresp([1])\n        np.testing.assert_array_almost_equal(\n            self.sys322.horner(1.j),\n            mag[:,:,0] * np.exp(1.j * phase[:,:,0]))\n\n    def tearDown(self):\n        reset_defaults()        # reset configuration defaults\n\n\nclass TestRss(unittest.TestCase):\n    """"""These are tests for the proper functionality of statesp.rss.""""""\n\n    def setUp(self):\n        use_numpy_matrix(False)\n\n        # Number of times to run each of the randomized tests.\n        self.numTests = 100\n        # Maxmimum number of states to test + 1\n        self.maxStates = 10\n        # Maximum number of inputs and outputs to test + 1\n        self.maxIO = 5\n\n    def test_shape(self):\n        """"""Test that rss outputs have the right state, input, and output size.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.rss(states, outputs, inputs)\n                    self.assertEqual(sys.states, states)\n                    self.assertEqual(sys.inputs, inputs)\n                    self.assertEqual(sys.outputs, outputs)\n\n    def test_pole(self):\n        """"""Test that the poles of rss outputs have a negative real part.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.rss(states, outputs, inputs)\n                    p = sys.pole()\n                    for z in p:\n                        self.assertTrue(z.real < 0)\n\n    def tearDown(self):\n        reset_defaults()        # reset configuration defaults\n\n\nclass TestDrss(unittest.TestCase):\n    """"""These are tests for the proper functionality of statesp.drss.""""""\n\n    def setUp(self):\n        use_numpy_matrix(False)\n        \n        # Number of times to run each of the randomized tests.\n        self.numTests = 100\n        # Maximum number of states to test + 1\n        self.maxStates = 10\n        # Maximum number of inputs and outputs to test + 1\n        self.maxIO = 5\n\n    def test_shape(self):\n        """"""Test that drss outputs have the right state, input, and output size.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.drss(states, outputs, inputs)\n                    self.assertEqual(sys.states, states)\n                    self.assertEqual(sys.inputs, inputs)\n                    self.assertEqual(sys.outputs, outputs)\n\n    def test_pole(self):\n        """"""Test that the poles of drss outputs have less than unit magnitude.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.drss(states, outputs, inputs)\n                    p = sys.pole()\n                    for z in p:\n                        self.assertTrue(abs(z) < 1)\n\n    def test_pole_static(self):\n        """"""Regression: pole() of static gain is empty array.""""""\n        np.testing.assert_array_equal(np.array([]),\n                                      StateSpace([], [], [], [[1]]).pole())\n\n    def test_copy_constructor(self):\n        # Create a set of matrices for a simple linear system\n        A = np.array([[-1]])\n        B = np.array([[1]])\n        C = np.array([[1]])\n        D = np.array([[0]])\n\n        # Create the first linear system and a copy\n        linsys = StateSpace(A, B, C, D)\n        cpysys = StateSpace(linsys)\n\n        # Change the original A matrix\n        A[0, 0] = -2\n        np.testing.assert_array_equal(linsys.A, [[-1]]) # original value\n        np.testing.assert_array_equal(cpysys.A, [[-1]]) # original value\n\n        # Change the A matrix for the original system\n        linsys.A[0, 0] = -3\n        np.testing.assert_array_equal(cpysys.A, [[-1]]) # original value\n\n    def tearDown(self):\n        reset_defaults()        # reset configuration defaults\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestStateSpace)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/statesp_test.py,115,"b'#!/usr/bin/env python\n#\n# statesp_test.py - test state space class\n# RMM, 30 Mar 2011 (based on TestStateSp from v0.4a)\n\nimport unittest\nimport numpy as np\nfrom numpy.linalg import solve\nfrom scipy.linalg import eigvals, block_diag\nfrom control import matlab\nfrom control.statesp import StateSpace, _convertToStateSpace, tf2ss\nfrom control.xferfcn import TransferFunction, ss2tf\nfrom control.lti import evalfr\nfrom control.exception import slycot_check\n\n\nclass TestStateSpace(unittest.TestCase):\n    """"""Tests for the StateSpace class.""""""\n\n    def setUp(self):\n        """"""Set up a MIMO system to test operations on.""""""\n\n        # sys1: 3-states square system (2 inputs x 2 outputs)\n        A322 = [[-3., 4., 2.],\n                [-1., -3., 0.],\n                [2., 5., 3.]]\n        B322 = [[1., 4.],\n                [-3., -3.],\n                [-2., 1.]]\n        C322 = [[4., 2., -3.],\n                [1., 4., 3.]]\n        D322 = [[-2., 4.],\n                [0., 1.]]\n        self.sys322 = StateSpace(A322, B322, C322, D322)\n\n        # sys1: 2-states square system (2 inputs x 2 outputs)\n        A222 = [[4., 1.],\n                [2., -3]]\n        B222 = [[5., 2.],\n                [-3., -3.]]\n        C222 = [[2., -4],\n                [0., 1.]]\n        D222 = [[3., 2.],\n                [1., -1.]]\n        self.sys222 = StateSpace(A222, B222, C222, D222)\n\n        # sys3: 6 states non square system (2 inputs x 3 outputs)\n        A623 = np.array([[1, 0, 0, 0, 0, 0],\n                         [0, 1, 0, 0, 0, 0],\n                         [0, 0, 3, 0, 0, 0],\n                         [0, 0, 0, -4, 0, 0],\n                         [0, 0, 0, 0, -1, 0],\n                         [0, 0, 0, 0, 0, 3]])\n        B623 = np.array([[0, -1],\n                        [-1, 0],\n                        [1, -1],\n                        [0, 0],\n                        [0, 1],\n                        [-1, -1]])\n        C623 = np.array([[1, 0, 0, 1, 0, 0],\n                         [0, 1, 0, 1, 0, 1],\n                         [0, 0, 1, 0, 0, 1]])\n        D623 = np.zeros((3, 2))\n        self.sys623 = StateSpace(A623, B623, C623, D623)\n\n    def test_D_broadcast(self):\n        """"""Test broadcast of D=0 to the right shape""""""\n        # Giving D as a scalar 0 should broadcast to the right shape\n        sys = StateSpace(self.sys623.A, self.sys623.B, self.sys623.C, 0)\n        np.testing.assert_array_equal(self.sys623.D, sys.D)\n\n        # Giving D as a matrix of the wrong size should generate an error\n        with self.assertRaises(ValueError):\n            sys = StateSpace(sys.A, sys.B, sys.C, np.array([[0]]))\n\n        # Make sure that empty systems still work\n        sys = StateSpace([], [], [], 1)\n        np.testing.assert_array_equal(sys.D, [[1]])\n\n        sys = StateSpace([], [], [], [[0]])\n        np.testing.assert_array_equal(sys.D, [[0]])\n\n        sys = StateSpace([], [], [], [0])\n        np.testing.assert_array_equal(sys.D, [[0]])\n\n        sys = StateSpace([], [], [], 0)\n        np.testing.assert_array_equal(sys.D, [[0]])\n\n    def test_pole(self):\n        """"""Evaluate the poles of a MIMO system.""""""\n\n        p = np.sort(self.sys322.pole())\n        true_p = np.sort([3.34747678408874,\n                          -3.17373839204437 + 1.47492908003839j,\n                          -3.17373839204437 - 1.47492908003839j])\n\n        np.testing.assert_array_almost_equal(p, true_p)\n\n    def test_zero_empty(self):\n        """"""Test to make sure zero() works with no zeros in system.""""""\n        sys = _convertToStateSpace(TransferFunction([1], [1, 2, 1]))\n        np.testing.assert_array_equal(sys.zero(), np.array([]))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_siso(self):\n        """"""Evaluate the zeros of a SISO system.""""""\n        # extract only first input / first output system of sys222. This system is denoted sys111\n        #  or tf111\n        tf111 = ss2tf(self.sys222)\n        sys111 = tf2ss(tf111[0, 0])\n\n        # compute zeros as root of the characteristic polynomial at the numerator of tf111\n        # this method is simple and assumed as valid in this test\n        true_z = np.sort(tf111[0, 0].zero())\n        # Compute the zeros through ab08nd, which is tested here\n        z = np.sort(sys111.zero())\n\n        np.testing.assert_almost_equal(true_z, z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys322_square(self):\n        """"""Evaluate the zeros of a square MIMO system.""""""\n\n        z = np.sort(self.sys322.zero())\n        true_z = np.sort([44.41465, -0.490252, -5.924398])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys222_square(self):\n        """"""Evaluate the zeros of a square MIMO system.""""""\n\n        z = np.sort(self.sys222.zero())\n        true_z = np.sort([-10.568501,   3.368501])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_zero_mimo_sys623_non_square(self):\n        """"""Evaluate the zeros of a non square MIMO system.""""""\n\n        z = np.sort(self.sys623.zero())\n        true_z = np.sort([2., -1.])\n        np.testing.assert_array_almost_equal(z, true_z)\n\n    def test_add_ss(self):\n        """"""Add two MIMO systems.""""""\n\n        A = [[-3., 4., 2., 0., 0.], [-1., -3., 0., 0., 0.],\n             [2., 5., 3., 0., 0.], [0., 0., 0., 4., 1.], [0., 0., 0., 2., -3.]]\n        B = [[1., 4.], [-3., -3.], [-2., 1.], [5., 2.], [-3., -3.]]\n        C = [[4., 2., -3., 2., -4.], [1., 4., 3., 0., 1.]]\n        D = [[1., 6.], [1., 0.]]\n\n        sys = self.sys322 + self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_subtract_ss(self):\n        """"""Subtract two MIMO systems.""""""\n\n        A = [[-3., 4., 2., 0., 0.], [-1., -3., 0., 0., 0.],\n             [2., 5., 3., 0., 0.], [0., 0., 0., 4., 1.], [0., 0., 0., 2., -3.]]\n        B = [[1., 4.], [-3., -3.], [-2., 1.], [5., 2.], [-3., -3.]]\n        C = [[4., 2., -3., -2., 4.], [1., 4., 3., 0., -1.]]\n        D = [[-5., 2.], [-1., 2.]]\n\n        sys = self.sys322 - self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_multiply_ss(self):\n        """"""Multiply two MIMO systems.""""""\n\n        A = [[4., 1., 0., 0., 0.], [2., -3., 0., 0., 0.], [2., 0., -3., 4., 2.],\n             [-6., 9., -1., -3., 0.], [-4., 9., 2., 5., 3.]]\n        B = [[5., 2.], [-3., -3.], [7., -2.], [-12., -3.], [-5., -5.]]\n        C = [[-4., 12., 4., 2., -3.], [0., 1., 1., 4., 3.]]\n        D = [[-2., -8.], [1., -1.]]\n\n        sys = self.sys322 * self.sys222\n\n        np.testing.assert_array_almost_equal(sys.A, A)\n        np.testing.assert_array_almost_equal(sys.B, B)\n        np.testing.assert_array_almost_equal(sys.C, C)\n        np.testing.assert_array_almost_equal(sys.D, D)\n\n    def test_evalfr(self):\n        """"""Evaluate the frequency response at one frequency.""""""\n\n        A = [[-2, 0.5], [0.5, -0.3]]\n        B = [[0.3, -1.3], [0.1, 0.]]\n        C = [[0., 0.1], [-0.3, -0.2]]\n        D = [[0., -0.8], [-0.3, 0.]]\n        sys = StateSpace(A, B, C, D)\n\n        resp = [[4.37636761487965e-05 - 0.0152297592997812j,\n                 -0.792603938730853 + 0.0261706783369803j],\n                [-0.331544857768052 + 0.0576105032822757j,\n                 0.128919037199125 - 0.143824945295405j]]\n\n        # Correct versions of the call\n        np.testing.assert_almost_equal(evalfr(sys, 1j), resp)\n        np.testing.assert_almost_equal(sys._evalfr(1.), resp)\n\n        # Deprecated version of the call (should generate warning)\n        import warnings\n        with warnings.catch_warnings(record=True) as w:\n            # Set up warnings filter to only show warnings in control module\n            warnings.filterwarnings(""ignore"")\n            warnings.filterwarnings(""always"", module=""control"")\n\n            # Make sure that we get a pending deprecation warning\n            sys.evalfr(1.)\n            assert len(w) == 1\n            assert issubclass(w[-1].category, PendingDeprecationWarning)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_freq_resp(self):\n        """"""Evaluate the frequency response at multiple frequencies.""""""\n\n        A = [[-2, 0.5], [0.5, -0.3]]\n        B = [[0.3, -1.3], [0.1, 0.]]\n        C = [[0., 0.1], [-0.3, -0.2]]\n        D = [[0., -0.8], [-0.3, 0.]]\n        sys = StateSpace(A, B, C, D)\n\n        true_mag = [[[0.0852992637230322, 0.00103596611395218],\n                    [0.935374692849736, 0.799380720864549]],\n                   [[0.55656854563842, 0.301542699860857],\n                    [0.609178071542849, 0.0382108097985257]]]\n        true_phase = [[[-0.566195599644593, -1.68063565332582],\n                      [3.0465958317514, 3.14141384339534]],\n                     [[2.90457947657161, 3.10601268291914],\n                      [-0.438157380501337, -1.40720969147217]]]\n        true_omega = [0.1, 10.]\n\n        mag, phase, omega = sys.freqresp(true_omega)\n\n        np.testing.assert_almost_equal(mag, true_mag)\n        np.testing.assert_almost_equal(phase, true_phase)\n        np.testing.assert_equal(omega, true_omega)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_minreal(self):\n        """"""Test a minreal model reduction.""""""\n        # A = [-2, 0.5, 0; 0.5, -0.3, 0; 0, 0, -0.1]\n        A = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        # B = [0.3, -1.3; 0.1, 0; 1, 0]\n        B = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        # C = [0, 0.1, 0; -0.3, -0.2, 0]\n        C = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        # D = [0 -0.8; -0.3 0]\n        D = [[0., -0.8], [-0.3, 0.]]\n        # sys = ss(A, B, C, D)\n\n        sys = StateSpace(A, B, C, D)\n        sysr = sys.minreal()\n        self.assertEqual(sysr.states, 2)\n        self.assertEqual(sysr.inputs, sys.inputs)\n        self.assertEqual(sysr.outputs, sys.outputs)\n        np.testing.assert_array_almost_equal(\n            eigvals(sysr.A), [-2.136154, -0.1638459])\n\n    def test_append_ss(self):\n        """"""Test appending two state-space systems.""""""\n        A1 = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        B1 = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        C1 = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        D1 = [[0., -0.8], [-0.3, 0.]]\n        A2 = [[-1.]]\n        B2 = [[1.2]]\n        C2 = [[0.5]]\n        D2 = [[0.4]]\n        A3 = [[-2, 0.5, 0, 0], [0.5, -0.3, 0, 0], [0, 0, -0.1, 0],\n              [0, 0, 0., -1.]]\n        B3 = [[0.3, -1.3, 0], [0.1, 0., 0], [1.0, 0.0, 0], [0., 0, 1.2]]\n        C3 = [[0., 0.1, 0.0, 0.0], [-0.3, -0.2, 0.0, 0.0], [0., 0., 0., 0.5]]\n        D3 = [[0., -0.8, 0.], [-0.3, 0., 0.], [0., 0., 0.4]]\n        sys1 = StateSpace(A1, B1, C1, D1)\n        sys2 = StateSpace(A2, B2, C2, D2)\n        sys3 = StateSpace(A3, B3, C3, D3)\n        sys3c = sys1.append(sys2)\n        np.testing.assert_array_almost_equal(sys3.A, sys3c.A)\n        np.testing.assert_array_almost_equal(sys3.B, sys3c.B)\n        np.testing.assert_array_almost_equal(sys3.C, sys3c.C)\n        np.testing.assert_array_almost_equal(sys3.D, sys3c.D)\n\n    def test_append_tf(self):\n        """"""Test appending a state-space system with a tf""""""\n        A1 = [[-2, 0.5, 0], [0.5, -0.3, 0], [0, 0, -0.1]]\n        B1 = [[0.3, -1.3], [0.1, 0.], [1.0, 0.0]]\n        C1 = [[0., 0.1, 0.0], [-0.3, -0.2, 0.0]]\n        D1 = [[0., -0.8], [-0.3, 0.]]\n        s = TransferFunction([1, 0], [1])\n        h = 1 / (s + 1) / (s + 2)\n        sys1 = StateSpace(A1, B1, C1, D1)\n        sys2 = _convertToStateSpace(h)\n        sys3c = sys1.append(sys2)\n        np.testing.assert_array_almost_equal(sys1.A, sys3c.A[:3, :3])\n        np.testing.assert_array_almost_equal(sys1.B, sys3c.B[:3, :2])\n        np.testing.assert_array_almost_equal(sys1.C, sys3c.C[:2, :3])\n        np.testing.assert_array_almost_equal(sys1.D, sys3c.D[:2, :2])\n        np.testing.assert_array_almost_equal(sys2.A, sys3c.A[3:, 3:])\n        np.testing.assert_array_almost_equal(sys2.B, sys3c.B[3:, 2:])\n        np.testing.assert_array_almost_equal(sys2.C, sys3c.C[2:, 3:])\n        np.testing.assert_array_almost_equal(sys2.D, sys3c.D[2:, 2:])\n        np.testing.assert_array_almost_equal(sys3c.A[:3, 3:], np.zeros((3, 2)))\n        np.testing.assert_array_almost_equal(sys3c.A[3:, :3], np.zeros((2, 3)))\n\n    def test_array_access_ss(self):\n\n        sys1 = StateSpace([[1., 2.], [3., 4.]],\n                          [[5., 6.], [6., 8.]],\n                          [[9., 10.], [11., 12.]],\n                          [[13., 14.], [15., 16.]], 1)\n\n        sys1_11 = sys1[0, 1]\n        np.testing.assert_array_almost_equal(sys1_11.A,\n                                             sys1.A)\n        np.testing.assert_array_almost_equal(sys1_11.B,\n                                             sys1.B[:, 1])\n        np.testing.assert_array_almost_equal(sys1_11.C,\n                                             sys1.C[0, :])\n        np.testing.assert_array_almost_equal(sys1_11.D,\n                                             sys1.D[0, 1])\n\n        assert sys1.dt == sys1_11.dt\n\n    def test_dc_gain_cont(self):\n        """"""Test DC gain for continuous-time state-space systems.""""""\n        sys = StateSpace(-2., 6., 5., 0)\n        np.testing.assert_equal(sys.dcgain(), 15.)\n\n        sys2 = StateSpace(-2, [6., 4.], [[5.], [7.], [11]], np.zeros((3, 2)))\n        expected = np.array([[15., 10.], [21., 14.], [33., 22.]])\n        np.testing.assert_array_equal(sys2.dcgain(), expected)\n\n        sys3 = StateSpace(0., 1., 1., 0.)\n        np.testing.assert_equal(sys3.dcgain(), np.nan)\n\n    def test_dc_gain_discr(self):\n        """"""Test DC gain for discrete-time state-space systems.""""""\n        # static gain\n        sys = StateSpace([], [], [], 2, True)\n        np.testing.assert_equal(sys.dcgain(), 2)\n\n        # averaging filter\n        sys = StateSpace(0.5, 0.5, 1, 0, True)\n        np.testing.assert_almost_equal(sys.dcgain(), 1)\n\n        # differencer\n        sys = StateSpace(0, 1, -1, 1, True)\n        np.testing.assert_equal(sys.dcgain(), 0)\n\n        # summer\n        sys = StateSpace(1, 1, 1, 0, True)\n        np.testing.assert_equal(sys.dcgain(), np.nan)\n\n    def test_dc_gain_integrator(self):\n        """"""DC gain when eigenvalue at DC returns appropriately sized array of nan.""""""\n        # the SISO case is also tested in test_dc_gain_{cont,discr}\n        import itertools\n        # iterate over input and output sizes, and continuous (dt=None) and discrete (dt=True) time\n        for inputs, outputs, dt in itertools.product(range(1, 6), range(1, 6), [None, True]):\n            states = max(inputs, outputs)\n\n            # a matrix that is singular at DC, and has no ""useless"" states as in\n            # _remove_useless_states\n            a = np.triu(np.tile(2, (states, states)))\n            # eigenvalues all +2, except for ...\n            a[0, 0] = 0 if dt is None else 1\n            b = np.eye(max(inputs, states))[:states, :inputs]\n            c = np.eye(max(outputs, states))[:outputs, :states]\n            d = np.zeros((outputs, inputs))\n            sys = StateSpace(a, b, c, d, dt)\n            dc = np.squeeze(np.tile(np.nan, (outputs, inputs)))\n            np.testing.assert_array_equal(dc, sys.dcgain())\n\n    def test_scalar_static_gain(self):\n        """"""Regression: can we create a scalar static gain?""""""\n        g1 = StateSpace([], [], [], [2])\n        g2 = StateSpace([], [], [], [3])\n\n        # make sure StateSpace internals, specifically ABC matrix\n        # sizes, are OK for LTI operations\n        g3 = g1 * g2\n        self.assertEqual(6, g3.D[0, 0])\n        g4 = g1 + g2\n        self.assertEqual(5, g4.D[0, 0])\n        g5 = g1.feedback(g2)\n        self.assertAlmostEqual(2. / 7, g5.D[0, 0])\n        g6 = g1.append(g2)\n        np.testing.assert_array_equal(np.diag([2, 3]), g6.D)\n\n    def test_matrix_static_gain(self):\n        """"""Regression: can we create matrix static gains?""""""\n        d1 = np.matrix([[1, 2, 3], [4, 5, 6]])\n        d2 = np.matrix([[7, 8], [9, 10], [11, 12]])\n        g1 = StateSpace([], [], [], d1)\n\n        # _remove_useless_states was making A = [[0]]\n        self.assertEqual((0, 0), g1.A.shape)\n\n        g2 = StateSpace([], [], [], d2)\n        g3 = StateSpace([], [], [], d2.T)\n\n        h1 = g1 * g2\n        np.testing.assert_array_equal(d1 * d2, h1.D)\n        h2 = g1 + g3\n        np.testing.assert_array_equal(d1 + d2.T, h2.D)\n        h3 = g1.feedback(g2)\n        np.testing.assert_array_almost_equal(\n            solve(np.eye(2) + d1 * d2, d1), h3.D)\n        h4 = g1.append(g2)\n        np.testing.assert_array_equal(block_diag(d1, d2), h4.D)\n\n    def test_remove_useless_states(self):\n        """"""Regression: _remove_useless_states gives correct ABC sizes.""""""\n        g1 = StateSpace(np.zeros((3, 3)),\n                        np.zeros((3, 4)),\n                        np.zeros((5, 3)),\n                        np.zeros((5, 4)))\n        self.assertEqual((0, 0), g1.A.shape)\n        self.assertEqual((0, 4), g1.B.shape)\n        self.assertEqual((5, 0), g1.C.shape)\n        self.assertEqual((5, 4), g1.D.shape)\n        self.assertEqual(0, g1.states)\n\n    def test_bad_empty_matrices(self):\n        """"""Mismatched ABCD matrices when some are empty.""""""\n        self.assertRaises(ValueError, StateSpace, [1], [], [], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [1], [], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [], [1], [], [1])\n        self.assertRaises(ValueError, StateSpace, [], [1], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [], [], [1], [1])\n        self.assertRaises(ValueError, StateSpace, [1], [1], [1], [])\n\n    def test_minreal_static_gain(self):\n        """"""Regression: minreal on static gain was failing.""""""\n        g1 = StateSpace([], [], [], [1])\n        g2 = g1.minreal()\n        np.testing.assert_array_equal(g1.A, g2.A)\n        np.testing.assert_array_equal(g1.B, g2.B)\n        np.testing.assert_array_equal(g1.C, g2.C)\n        np.testing.assert_array_equal(g1.D, g2.D)\n\n    def test_empty(self):\n        """"""Regression: can we create an empty StateSpace object?""""""\n        g1 = StateSpace([], [], [], [])\n        self.assertEqual(0, g1.states)\n        self.assertEqual(0, g1.inputs)\n        self.assertEqual(0, g1.outputs)\n\n    def test_matrix_to_state_space(self):\n        """"""_convertToStateSpace(matrix) gives ss([],[],[],D)""""""\n        D = np.matrix([[1, 2, 3], [4, 5, 6]])\n        g = _convertToStateSpace(D)\n\n        def empty(shape):\n            m = np.matrix([])\n            m.shape = shape\n            return m\n        np.testing.assert_array_equal(empty((0, 0)), g.A)\n        np.testing.assert_array_equal(empty((0, D.shape[1])), g.B)\n        np.testing.assert_array_equal(empty((D.shape[0], 0)), g.C)\n        np.testing.assert_array_equal(D, g.D)\n\n    def test_lft(self):\n        """""" test lft function with result obtained from matlab implementation""""""\n        # test case\n        A = [[1, 2, 3],\n             [1, 4, 5],\n             [2, 3, 4]]\n        B = [[0, 2],\n             [5, 6],\n             [5, 2]]\n        C = [[1, 4, 5],\n             [2, 3, 0]]\n        D = [[0, 0],\n             [3, 0]]\n        P = StateSpace(A, B, C, D)\n        Ak = [[0, 2, 3],\n              [2, 3, 5],\n              [2, 1, 9]]\n        Bk = [[1, 1],\n              [2, 3],\n              [9, 4]]\n        Ck = [[1, 4, 5],\n              [2, 3, 6]]\n        Dk = [[0, 2],\n              [0, 0]]\n        K = StateSpace(Ak, Bk, Ck, Dk)\n\n        # case 1\n        pk = P.lft(K, 2, 1)\n        Amatlab = [1, 2, 3, 4, 6, 12, 1, 4, 5, 17, 38, 61, 2, 3, 4, 9, 26, 37, 2, 3, 0, 3, 14, 18, 4, 6, 0, 8, 27, 35, 18, 27, 0, 29, 109, 144]\n        Bmatlab = [0, 10, 10, 7, 15, 58]\n        Cmatlab = [1, 4, 5, 0, 0, 0]\n        Dmatlab = [0]\n        np.testing.assert_allclose(np.array(pk.A).reshape(-1), Amatlab)\n        np.testing.assert_allclose(np.array(pk.B).reshape(-1), Bmatlab)\n        np.testing.assert_allclose(np.array(pk.C).reshape(-1), Cmatlab)\n        np.testing.assert_allclose(np.array(pk.D).reshape(-1), Dmatlab)\n\n        # case 2\n        pk = P.lft(K)\n        Amatlab = [1, 2, 3, 4, 6, 12, -3, -2, 5, 11, 14, 31, -2, -3, 4, 3, 2, 7, 0.6, 3.4, 5, -0.6, -0.4, 0, 0.8, 6.2, 10, 0.2, -4.2, -4, 7.4, 33.6, 45, -0.4, -8.6, -3]\n        Bmatlab = []\n        Cmatlab = []\n        Dmatlab = []\n        np.testing.assert_allclose(np.array(pk.A).reshape(-1), Amatlab)\n        np.testing.assert_allclose(np.array(pk.B).reshape(-1), Bmatlab)\n        np.testing.assert_allclose(np.array(pk.C).reshape(-1), Cmatlab)\n        np.testing.assert_allclose(np.array(pk.D).reshape(-1), Dmatlab)\n\nclass TestRss(unittest.TestCase):\n    """"""These are tests for the proper functionality of statesp.rss.""""""\n\n    def setUp(self):\n        # Number of times to run each of the randomized tests.\n        self.numTests = 100\n        # Maxmimum number of states to test + 1\n        self.maxStates = 10\n        # Maximum number of inputs and outputs to test + 1\n        self.maxIO = 5\n\n    def test_shape(self):\n        """"""Test that rss outputs have the right state, input, and output size.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.rss(states, outputs, inputs)\n                    self.assertEqual(sys.states, states)\n                    self.assertEqual(sys.inputs, inputs)\n                    self.assertEqual(sys.outputs, outputs)\n\n    def test_pole(self):\n        """"""Test that the poles of rss outputs have a negative real part.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.rss(states, outputs, inputs)\n                    p = sys.pole()\n                    for z in p:\n                        self.assertTrue(z.real < 0)\n\n\nclass TestDrss(unittest.TestCase):\n    """"""These are tests for the proper functionality of statesp.drss.""""""\n\n    def setUp(self):\n        # Number of times to run each of the randomized tests.\n        self.numTests = 100\n        # Maximum number of states to test + 1\n        self.maxStates = 10\n        # Maximum number of inputs and outputs to test + 1\n        self.maxIO = 5\n\n    def test_shape(self):\n        """"""Test that drss outputs have the right state, input, and output size.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.drss(states, outputs, inputs)\n                    self.assertEqual(sys.states, states)\n                    self.assertEqual(sys.inputs, inputs)\n                    self.assertEqual(sys.outputs, outputs)\n\n    def test_pole(self):\n        """"""Test that the poles of drss outputs have less than unit magnitude.""""""\n\n        for states in range(1, self.maxStates):\n            for inputs in range(1, self.maxIO):\n                for outputs in range(1, self.maxIO):\n                    sys = matlab.drss(states, outputs, inputs)\n                    p = sys.pole()\n                    for z in p:\n                        self.assertTrue(abs(z) < 1)\n\n    def test_pole_static(self):\n        """"""Regression: pole() of static gain is empty array.""""""\n        np.testing.assert_array_equal(np.array([]),\n                                      StateSpace([], [], [], [[1]]).pole())\n\n    def test_copy_constructor(self):\n        # Create a set of matrices for a simple linear system\n        A = np.array([[-1]])\n        B = np.array([[1]])\n        C = np.array([[1]])\n        D = np.array([[0]])\n\n        # Create the first linear system and a copy\n        linsys = StateSpace(A, B, C, D)\n        cpysys = StateSpace(linsys)\n\n        # Change the original A matrix\n        A[0, 0] = -2\n        np.testing.assert_array_equal(linsys.A, [[-1]]) # original value\n        np.testing.assert_array_equal(cpysys.A, [[-1]]) # original value\n\n        # Change the A matrix for the original system\n        linsys.A[0, 0] = -3\n        np.testing.assert_array_equal(cpysys.A, [[-1]]) # original value\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestStateSpace)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/test_control_matlab.py,10,"b'\'\'\'\nCopyright (C) 2011 by Eike Welk.\n\nTest the control.matlab toolbox.\n\'\'\'\n\nimport unittest\n\nimport numpy as np\nimport scipy.signal\nfrom numpy.testing import assert_array_almost_equal\nfrom numpy import array, asarray, matrix, asmatrix, zeros, ones, linspace,\\\n                  all, hstack, vstack, c_, r_\nfrom matplotlib.pylab import show, figure, plot, legend, subplot2grid\nfrom control.matlab import ss, step, impulse, initial, lsim, dcgain, \\\n                           ss2tf\nfrom control.statesp import _mimo2siso\nfrom control.timeresp import _check_convert_array\nfrom control.exception import slycot_check\nimport warnings\n\nclass TestControlMatlab(unittest.TestCase):\n\n    def setUp(self):\n        pass\n\n    def plot_matrix(self):\n        #Test: can matplotlib correctly plot matrices?\n        #Yes, but slightly inconvenient\n        figure()\n        t = matrix([[ 1.],\n                    [ 2.],\n                    [ 3.],\n                    [ 4.]])\n        y = matrix([[ 1., 4.],\n                    [ 4., 5.],\n                    [ 9., 6.],\n                    [16., 7.]])\n        plot(t, y)\n        #plot(asarray(t)[0], asarray(y)[0])\n\n\n    def make_SISO_mats(self):\n        """"""Return matrices for a SISO system""""""\n        A = matrix([[-81.82, -45.45],\n                    [ 10.,    -1.  ]])\n        B = matrix([[9.09],\n                    [0.  ]])\n        C = matrix([[0, 0.159]])\n        D = zeros((1, 1))\n        return A, B, C, D\n\n    def make_MIMO_mats(self):\n        """"""Return matrices for a MIMO system""""""\n        A = array([[-81.82, -45.45,   0,      0   ],\n                   [ 10,     -1,      0,      0   ],\n                   [  0,      0,    -81.82, -45.45],\n                   [  0,      0,     10,     -1,  ]])\n        B = array([[9.09, 0   ],\n                   [0   , 0   ],\n                   [0   , 9.09],\n                   [0   , 0   ]])\n        C = array([[0, 0.159, 0, 0    ],\n                   [0, 0,     0, 0.159]])\n        D = zeros((2, 2))\n        return A, B, C, D\n\n    def test_dcgain(self):\n        """"""Test function dcgain with different systems""""""\n        if slycot_check():\n            #Test MIMO systems\n            A, B, C, D = self.make_MIMO_mats()\n\n            gain1 = dcgain(ss(A, B, C, D))\n            gain2 = dcgain(A, B, C, D)\n            sys_tf = ss2tf(A, B, C, D)\n            gain3 = dcgain(sys_tf)\n            gain4 = dcgain(sys_tf.num, sys_tf.den)\n            #print(""gain1:"", gain1)\n\n            assert_array_almost_equal(gain1,\n                                      array([[0.0269, 0.    ],\n                                             [0.    , 0.0269]]),\n                                      decimal=4)\n            assert_array_almost_equal(gain1, gain2)\n            assert_array_almost_equal(gain3, gain4)\n            assert_array_almost_equal(gain1, gain4)\n\n        #Test SISO systems\n        A, B, C, D = self.make_SISO_mats()\n\n        gain1 = dcgain(ss(A, B, C, D))\n        assert_array_almost_equal(gain1,\n                                  array([[0.0269]]),\n                                  decimal=4)\n\n    def test_dcgain_2(self):\n        """"""Test function dcgain with different systems""""""\n        #Create different forms of a SISO system\n        A, B, C, D = self.make_SISO_mats()\n        num, den = scipy.signal.ss2tf(A, B, C, D)\n        # numerator is only a constant here; pick it out to avoid numpy warning\n        Z, P, k = scipy.signal.tf2zpk(num[0][-1], den)\n        sys_ss = ss(A, B, C, D)\n\n        #Compute the gain with ``dcgain``\n        gain_abcd = dcgain(A, B, C, D)\n        gain_zpk = dcgain(Z, P, k)\n        gain_numden = dcgain(np.squeeze(num), den)\n        gain_sys_ss = dcgain(sys_ss)\n        # print(\'gain_abcd:\', gain_abcd, \'gain_zpk:\', gain_zpk)\n        # print(\'gain_numden:\', gain_numden, \'gain_sys_ss:\', gain_sys_ss)\n\n        #Compute the gain with a long simulation\n        t = linspace(0, 1000, 1000)\n        y, _t = step(sys_ss, t)\n        gain_sim = y[-1]\n        # print(\'gain_sim:\', gain_sim)\n\n        #All gain values must be approximately equal to the known gain\n        assert_array_almost_equal([gain_abcd,   gain_zpk,\n                                   gain_numden, gain_sys_ss, gain_sim],\n                                  [0.026948, 0.026948, 0.026948, 0.026948,\n                                   0.026948],\n                                  decimal=6)\n\n    def test_step(self):\n        """"""Test function ``step``.""""""\n        figure(); plot_shape = (1, 3)\n\n        #Test SISO system\n        A, B, C, D = self.make_SISO_mats()\n        sys = ss(A, B, C, D)\n        #print(sys)\n        #print(""gain:"", dcgain(sys))\n\n        subplot2grid(plot_shape, (0, 0))\n        t, y = step(sys)\n        plot(t, y)\n\n        subplot2grid(plot_shape, (0, 1))\n        T = linspace(0, 2, 100)\n        X0 = array([1, 1])\n        t, y = step(sys, T, X0)\n        plot(t, y)\n\n        # Test output of state vector\n        t, y, x = step(sys, return_x=True)\n\n        #Test MIMO system\n        A, B, C, D = self.make_MIMO_mats()\n        sys = ss(A, B, C, D)\n\n        subplot2grid(plot_shape, (0, 2))\n        t, y = step(sys)\n        plot(t, y)\n\n    def test_impulse(self):\n        A, B, C, D = self.make_SISO_mats()\n        sys = ss(A, B, C, D)\n\n        figure()\n\n        #everything automatically\n        t, y = impulse(sys)\n        plot(t, y, label=\'Simple Case\')\n\n        #supply time and X0\n        T = linspace(0, 2, 100)\n        X0 = [0.2, 0.2]\n        t, y = impulse(sys, T, X0)\n        plot(t, y, label=\'t=0..2, X0=[0.2, 0.2]\')\n\n        #Test system with direct feed-though, the function should print a warning.\n        D = [[0.5]]\n        sys_ft = ss(A, B, C, D)\n        with warnings.catch_warnings():\n            warnings.simplefilter(""ignore"")\n            t, y = impulse(sys_ft)\n            plot(t, y, label=\'Direct feedthrough D=[[0.5]]\')\n\n        #Test MIMO system\n        A, B, C, D = self.make_MIMO_mats()\n        sys = ss(A, B, C, D)\n        t, y = impulse(sys)\n        plot(t, y, label=\'MIMO System\')\n\n        legend(loc=\'best\')\n        #show()\n\n\n    def test_initial(self):\n        A, B, C, D = self.make_SISO_mats()\n        sys = ss(A, B, C, D)\n\n        figure(); plot_shape = (1, 3)\n\n        #X0=0 : must produce line at 0\n        subplot2grid(plot_shape, (0, 0))\n        t, y = initial(sys)\n        plot(t, y)\n\n        #X0=[1,1] : produces a spike\n        subplot2grid(plot_shape, (0, 1))\n        t, y = initial(sys, X0=matrix(""1; 1""))\n        plot(t, y)\n\n        #Test MIMO system\n        A, B, C, D = self.make_MIMO_mats()\n        sys = ss(A, B, C, D)\n        #X0=[1,1] : produces same spike as above spike\n        subplot2grid(plot_shape, (0, 2))\n        t, y = initial(sys, X0=[1, 1, 0, 0])\n        plot(t, y)\n\n        #show()\n\n    #! Old test; no longer functional?? (RMM, 3 Nov 2012)\n    @unittest.skip(""skipping test_check_convert_shape, need to update test"")\n    def test_check_convert_shape(self):\n        #TODO: check if shape is correct everywhere.\n        #Correct input ---------------------------------------------\n        #Recognize correct shape\n        #Input is array, shape (3,), single legal shape\n        arr = _check_convert_array(array([1., 2, 3]), [(3,)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Input is array, shape (3,), two legal shapes\n        arr = _check_convert_array(array([1., 2, 3]), [(3,), (1,3)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Input is array, 2D, shape (1,3)\n        arr = _check_convert_array(array([[1., 2, 3]]), [(3,), (1,3)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Test special value any\n        #Input is array, 2D, shape (1,3)\n        arr = _check_convert_array(array([[1., 2, 3]]), [(4,), (1,""any"")], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Input is array, 2D, shape (3,1)\n        arr = _check_convert_array(array([[1.], [2], [3]]), [(4,), (""any"", 1)],\n                                   \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Convert array-like objects to arrays\n        #Input is matrix, shape (1,3), must convert to array\n        arr = _check_convert_array(matrix(""1. 2 3""), [(3,), (1,3)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Input is list, shape (1,3), must convert to array\n        arr = _check_convert_array([[1., 2, 3]], [(3,), (1,3)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n\n        #Special treatment of scalars and zero dimensional arrays:\n        #They are converted to an array of a legal shape, filled with the scalar\n        #value\n        arr = _check_convert_array(5, [(3,), (1,3)], \'Test: \')\n        assert isinstance(arr, np.ndarray)\n        assert arr.shape == (3,)\n        assert_array_almost_equal(arr, [5, 5, 5])\n\n        #Squeeze shape\n        #Input is array, 2D, shape (1,3)\n        arr = _check_convert_array(array([[1., 2, 3]]), [(3,), (1,3)],\n                                        \'Test: \', squeeze=True)\n        assert isinstance(arr, np.ndarray)\n        assert not isinstance(arr, matrix)\n        assert arr.shape == (3,)  #Shape must be squeezed. (1,3) -> (3,)\n\n        #Erroneous input -----------------------------------------------------\n        #test wrong element data types\n        #Input is array of functions, 2D, shape (1,3)\n        self.assertRaises(TypeError, _check_convert_array(array([[min, max, all]]),\n            [(3,), (1,3)], \'Test: \', squeeze=True))\n\n        #Test wrong shapes\n        #Input has shape (4,) but (3,) or (1,3) are legal shapes\n        self.assertRaises(ValueError, _check_convert_array(array([1., 2, 3, 4]),\n            [(3,), (1,3)], \'Test: \'))\n\n    @unittest.skip(""skipping test_lsim, need to update test"")\n    def test_lsim(self):\n        A, B, C, D = self.make_SISO_mats()\n        sys = ss(A, B, C, D)\n\n        figure(); plot_shape = (2, 2)\n\n        #Test with arrays\n        subplot2grid(plot_shape, (0, 0))\n        t = linspace(0, 1, 100)\n        u = r_[1:1:50j, 0:0:50j]\n        y, _t, _x = lsim(sys, u, t)\n        plot(t, y, label=\'y\')\n        plot(t, u/10, label=\'u/10\')\n        legend(loc=\'best\')\n\n        #Test with U=None - uses 2nd algorithm which is much faster.\n        subplot2grid(plot_shape, (0, 1))\n        t = linspace(0, 1, 100)\n        x0 = [-1, -1]\n        y, _t, _x = lsim(sys, U=None, T=t, X0=x0)\n        plot(t, y, label=\'y\')\n        legend(loc=\'best\')\n\n        #Test with U=0, X0=0\n        #Correct reaction to zero dimensional special values\n        subplot2grid(plot_shape, (0, 1))\n        t = linspace(0, 1, 100)\n        y, _t, _x = lsim(sys, U=0, T=t, X0=0)\n        plot(t, y, label=\'y\')\n        legend(loc=\'best\')\n\n        #Test with matrices\n        subplot2grid(plot_shape, (1, 0))\n        t = matrix(linspace(0, 1, 100))\n        u = matrix(r_[1:1:50j, 0:0:50j])\n        x0 = matrix(""0.; 0"")\n        y, t_out, _x = lsim(sys, u, t, x0)\n        plot(t_out, y, label=\'y\')\n        plot(t_out, asarray(u/10)[0], label=\'u/10\')\n        legend(loc=\'best\')\n\n        #Test with MIMO system\n        subplot2grid(plot_shape, (1, 1))\n        A, B, C, D = self.make_MIMO_mats()\n        sys = ss(A, B, C, D)\n        t = matrix(linspace(0, 1, 100))\n        u = array([r_[1:1:50j, 0:0:50j],\n                   r_[0:1:50j, 0:0:50j]])\n        x0 = [0, 0, 0, 0]\n        y, t_out, _x = lsim(sys, u, t, x0)\n        plot(t_out, y[0], label=\'y[0]\')\n        plot(t_out, y[1], label=\'y[1]\')\n        plot(t_out, u[0]/10, label=\'u[0]/10\')\n        plot(t_out, u[1]/10, label=\'u[1]/10\')\n        legend(loc=\'best\')\n\n\n        #Test with wrong values for t\n        #T is None; - special handling: Value error\n        self.assertRaises(ValueError, lsim(sys, U=0, T=None, x0=0))\n        #T=""hello"" : Wrong type\n        #TODO: better wording of error messages of ``lsim`` and\n        #      ``_check_convert_array``, when wrong type is given.\n        #      Current error message is too cryptic.\n        self.assertRaises(TypeError, lsim(sys, U=0, T=""hello"", x0=0))\n        #T=0; - T can not be zero dimensional, it determines the size of the\n        #       input vector ``U``\n        self.assertRaises(ValueError, lsim(sys, U=0, T=0, x0=0))\n        #T is not monotonically increasing\n        self.assertRaises(ValueError, lsim(sys, U=0, T=[0., 1., 2., 2., 3.], x0=0))\n        #show()\n\n    def assert_systems_behave_equal(self, sys1, sys2):\n        \'\'\'\n        Test if the behavior of two LTI systems is equal. Raises ``AssertionError``\n        if the systems are not equal.\n\n        Works only for SISO systems.\n\n        Currently computes dcgain, and computes step response.\n        \'\'\'\n        #gain of both systems must be the same\n        assert_array_almost_equal(dcgain(sys1), dcgain(sys2))\n\n        #Results of ``step`` simulation must be the same too\n        y1, t1 = step(sys1)\n        y2, t2 = step(sys2, t1)\n        assert_array_almost_equal(y1, y2)\n\n    def test_convert_MIMO_to_SISO(self):\n        \'\'\'Convert mimo to siso systems\'\'\'\n        #Test with our usual systems --------------------------------------------\n        #SISO PT2 system\n        As, Bs, Cs, Ds = self.make_SISO_mats()\n        sys_siso = ss(As, Bs, Cs, Ds)\n        #MIMO system that contains two independent copies of the SISO system above\n        Am, Bm, Cm, Dm = self.make_MIMO_mats()\n        sys_mimo = ss(Am, Bm, Cm, Dm)\n        #    t, y = step(sys_siso)\n        #    plot(t, y, label=\'sys_siso d=0\')\n\n        sys_siso_00 = _mimo2siso(sys_mimo, input=0, output=0,\n                                         warn_conversion=False)\n        sys_siso_11 = _mimo2siso(sys_mimo, input=1, output=1,\n                                         warn_conversion=False)\n        #print(""sys_siso_00 ---------------------------------------------"")\n        #print(sys_siso_00)\n        #print(""sys_siso_11 ---------------------------------------------"")\n        #print(sys_siso_11)\n\n        #gain of converted system and equivalent SISO system must be the same\n        self.assert_systems_behave_equal(sys_siso, sys_siso_00)\n        self.assert_systems_behave_equal(sys_siso, sys_siso_11)\n\n        #Test with additional systems --------------------------------------------\n        #They have crossed inputs and direct feedthrough\n        #SISO system\n        As = matrix([[-81.82, -45.45],\n                     [ 10.,    -1.  ]])\n        Bs = matrix([[9.09],\n                     [0.  ]])\n        Cs = matrix([[0, 0.159]])\n        Ds = matrix([[0.02]])\n        sys_siso = ss(As, Bs, Cs, Ds)\n        #    t, y = step(sys_siso)\n        #    plot(t, y, label=\'sys_siso d=0.02\')\n        #    legend(loc=\'best\')\n\n        #MIMO system\n        #The upper left sub-system uses : input 0, output 1\n        #The lower right sub-system uses: input 1, output 0\n        Am = array([[-81.82, -45.45,   0,      0   ],\n                    [ 10,     -1,      0,      0   ],\n                    [  0,      0,    -81.82, -45.45],\n                    [  0,      0,     10,     -1,  ]])\n        Bm = array([[9.09, 0   ],\n                    [0   , 0   ],\n                    [0   , 9.09],\n                    [0   , 0   ]])\n        Cm = array([[0, 0,     0, 0.159],\n                    [0, 0.159, 0, 0    ]])\n        Dm = matrix([[0,   0.02],\n                     [0.02, 0  ]])\n        sys_mimo = ss(Am, Bm, Cm, Dm)\n\n\n        sys_siso_01 = _mimo2siso(sys_mimo, input=0, output=1,\n                                         warn_conversion=False)\n        sys_siso_10 = _mimo2siso(sys_mimo, input=1, output=0,\n                                         warn_conversion=False)\n        # print(""sys_siso_01 ---------------------------------------------"")\n        # print(sys_siso_01)\n        # print(""sys_siso_10 ---------------------------------------------"")\n        # print(sys_siso_10)\n\n        #gain of converted system and equivalent SISO system must be the same\n        self.assert_systems_behave_equal(sys_siso, sys_siso_01)\n        self.assert_systems_behave_equal(sys_siso, sys_siso_10)\n\n    def debug_nasty_import_problem():\n        \'\'\'\n        ``*.egg`` files have precedence over ``PYTHONPATH``. Therefore packages\n        that were installed with ``easy_install``, can not be easily developed with\n        Eclipse.\n\n        See also:\n        http://bugs.python.org/setuptools/issue53\n\n        Use this function to debug the issue.\n        \'\'\'\n        #print the directories where python searches for modules and packages.\n        import sys\n        print(\'sys.path: -----------------------------------\')\n        for name in sys.path:\n            print(name)\n\n\nif __name__ == \'__main__\':\n    unittest.main()\n# vi:ts=4:sw=4:expandtab\n'"
External_Libraries/python_control_master/control/tests/timeresp_test.py,158,"b'#!/usr/bin/env python\n#\n# timeresp_test.py - test time response functions\n# RMM, 17 Jun 2011 (based on TestMatlab from v0.4c)\n#\n# This test suite just goes through and calls all of the MATLAB\n# functions using different systems and arguments to make sure that\n# nothing crashes.  It doesn\'t test actual functionality; the module\n# specific unit tests will do that.\n\nimport unittest\nimport numpy as np\nfrom control.timeresp import *\nfrom control.statesp import *\nfrom control.xferfcn import TransferFunction, _convert_to_transfer_function\nfrom control.dtime import c2d\nfrom control.exception import slycot_check\n\nclass TestTimeresp(unittest.TestCase):\n    def setUp(self):\n        """"""Set up some systems for testing out MATLAB functions""""""\n        A = np.matrix(""1. -2.; 3. -4."")\n        B = np.matrix(""5.; 7."")\n        C = np.matrix(""6. 8."")\n        D = np.matrix(""9."")\n        self.siso_ss1 = StateSpace(A, B, C, D)\n\n        # Create some transfer functions\n        self.siso_tf1 = TransferFunction([1], [1, 2, 1])\n        self.siso_tf2 = _convert_to_transfer_function(self.siso_ss1)\n\n        # Create MIMO system, contains ``siso_ss1`` twice\n        A = np.matrix(""1. -2. 0.  0.;""\n                      ""3. -4. 0.  0.;""\n                      ""0.  0. 1. -2.;""\n                      ""0.  0. 3. -4. "")\n        B = np.matrix(""5. 0.;""\n                      ""7. 0.;""\n                      ""0. 5.;""\n                      ""0. 7. "")\n        C = np.matrix(""6. 8. 0. 0.;""\n                      ""0. 0. 6. 8. "")\n        D = np.matrix(""9. 0.;""\n                      ""0. 9. "")\n        self.mimo_ss1 = StateSpace(A, B, C, D)\n\n        # Create discrete time systems\n        self.siso_dtf1 = TransferFunction([1], [1, 1, 0.25], True)\n        self.siso_dtf2 = TransferFunction([1], [1, 1, 0.25], 0.2)\n        self.siso_dss1 = tf2ss(self.siso_dtf1)\n        self.siso_dss2 = tf2ss(self.siso_dtf2)\n        self.mimo_dss1 = StateSpace(A, B, C, D, True)\n        self.mimo_dss2 = c2d(self.mimo_ss1, 0.2)\n\n    def test_step_response(self):\n        # Test SISO system\n        sys = self.siso_ss1\n        t = np.linspace(0, 1, 10)\n        youttrue = np.array([9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                             42.3227, 44.9694, 47.1599, 48.9776])\n\n        # SISO call\n        tout, yout = step_response(sys, T=t)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Play with arguments\n        tout, yout = step_response(sys, T=t, X0=0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        X0 = np.array([0, 0])\n        tout, yout = step_response(sys, T=t, X0=X0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        tout, yout, xout = step_response(sys, T=t, X0=0, return_x=True)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Test MIMO system, which contains ``siso_ss1`` twice\n        sys = self.mimo_ss1\n        _t, y_00 = step_response(sys, T=t, input=0, output=0)\n        _t, y_11 = step_response(sys, T=t, input=1, output=1)\n        np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n        # Make sure continuous and discrete time use same return conventions\n        sysc = self.mimo_ss1\n        sysd = c2d(sysc, 1)           # discrete time system\n        Tvec = np.linspace(0, 10, 11) # make sure to use integer times 0..10\n        Tc, youtc = step_response(sysc, Tvec, input=0)\n        Td, youtd = step_response(sysd, Tvec, input=0)\n        np.testing.assert_array_equal(Tc.shape, Td.shape)\n        np.testing.assert_array_equal(youtc.shape, youtd.shape)\n\n    def test_step_info(self):\n        # From matlab docs:\n        sys = TransferFunction([1,5,5],[1,1.65,5,6.5,2])\n        Strue = {\n            \'RiseTime\': 3.8456,\n            \'SettlingTime\': 27.9762,\n            \'SettlingMin\': 2.0689,\n            \'SettlingMax\': 2.6873,\n            \'Overshoot\': 7.4915,\n            \'Undershoot\': 0,\n            \'Peak\': 2.6873,\n            \'PeakTime\': 8.0530\n        }\n\n        S = step_info(sys)\n\n        # Very arbitrary tolerance because I don\'t know if the\n        # response from the MATLAB is really that accurate.\n        # maybe it is a good idea to change the Strue to match\n        # but I didn\'t do it because I don\'t know if it is\n        # accurate either...\n        rtol = 2e-2\n        np.testing.assert_allclose(\n            S.get(\'RiseTime\'),\n            Strue.get(\'RiseTime\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'SettlingTime\'),\n            Strue.get(\'SettlingTime\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'SettlingMin\'),\n            Strue.get(\'SettlingMin\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'SettlingMax\'),\n            Strue.get(\'SettlingMax\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'Overshoot\'),\n            Strue.get(\'Overshoot\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'Undershoot\'),\n            Strue.get(\'Undershoot\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'Peak\'),\n            Strue.get(\'Peak\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'PeakTime\'),\n            Strue.get(\'PeakTime\'),\n            rtol=rtol)\n        np.testing.assert_allclose(\n            S.get(\'SteadyStateValue\'),\n            2.50,\n            rtol=rtol)\n\n    def test_impulse_response(self):\n        # Test SISO system\n        sys = self.siso_ss1\n        t = np.linspace(0, 1, 10)\n        youttrue = np.array([86., 70.1808, 57.3753, 46.9975, 38.5766, 31.7344,\n                             26.1668, 21.6292, 17.9245, 14.8945])\n        tout, yout = impulse_response(sys, T=t)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Play with arguments\n        tout, yout = impulse_response(sys, T=t, X0=0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        X0 = np.array([0, 0])\n        tout, yout = impulse_response(sys, T=t, X0=X0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        tout, yout, xout = impulse_response(sys, T=t, X0=0, return_x=True)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Test MIMO system, which contains ``siso_ss1`` twice\n        sys = self.mimo_ss1\n        _t, y_00 = impulse_response(sys, T=t, input=0, output=0)\n        _t, y_11 = impulse_response(sys, T=t, input=1, output=1)\n        np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n        # Test MIMO system, as mimo, and don\'t trim outputs\n        sys = self.mimo_ss1\n        _t, yy = impulse_response(sys, T=t, input=0)\n        np.testing.assert_array_almost_equal(\n            yy, np.vstack((youttrue, np.zeros_like(youttrue))), decimal=4)\n\n    def test_initial_response(self):\n        # Test SISO system\n        sys = self.siso_ss1\n        t = np.linspace(0, 1, 10)\n        x0 = np.array([[0.5], [1]])\n        youttrue = np.array([11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                             1.1508, 0.5833, 0.1645, -0.1391])\n        tout, yout = initial_response(sys, T=t, X0=x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Play with arguments\n        tout, yout, xout = initial_response(sys, T=t, X0=x0, return_x=True)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n\n        # Test MIMO system, which contains ``siso_ss1`` twice\n        sys = self.mimo_ss1\n        x0 = np.matrix("".5; 1.; .5; 1."")\n        _t, y_00 = initial_response(sys, T=t, X0=x0, input=0, output=0)\n        _t, y_11 = initial_response(sys, T=t, X0=x0, input=1, output=1)\n        np.testing.assert_array_almost_equal(y_00, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(y_11, youttrue, decimal=4)\n\n    def test_initial_response_no_trim(self):\n        # test MIMO system without trimming\n        t = np.linspace(0, 1, 10)\n        x0 = np.matrix("".5; 1.; .5; 1."")\n        youttrue = np.array([11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                             1.1508, 0.5833, 0.1645, -0.1391])\n        sys = self.mimo_ss1\n        _t, yy = initial_response(sys, T=t, X0=x0)\n        np.testing.assert_array_almost_equal(\n            yy, np.vstack((youttrue, youttrue)),\n            decimal=4)\n\n    def test_forced_response(self):\n        t = np.linspace(0, 1, 10)\n\n        # compute step response - test with state space, and transfer function\n        # objects\n        u = np.array([1., 1, 1, 1, 1, 1, 1, 1, 1, 1])\n        youttrue = np.array([9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                             42.3227, 44.9694, 47.1599, 48.9776])\n        tout, yout, _xout = forced_response(self.siso_ss1, t, u)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n        np.testing.assert_array_almost_equal(tout, t)\n        _t, yout, _xout = forced_response(self.siso_tf2, t, u)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n        # test with initial value and special algorithm for ``U=0``\n        u = 0\n        x0 = np.matrix("".5; 1."")\n        youttrue = np.array([11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                             1.1508, 0.5833, 0.1645, -0.1391])\n        _t, yout, _xout = forced_response(self.siso_ss1, t, u, x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n        # Test MIMO system, which contains ``siso_ss1`` twice\n        # first system: initial value, second system: step response\n        u = np.array([[0., 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                      [1., 1, 1, 1, 1, 1, 1, 1, 1, 1]])\n        x0 = np.array([[.5], [1], [0], [0]])\n        youttrue = np.array([[11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                              1.1508, 0.5833, 0.1645, -0.1391],\n                             [9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                              42.3227, 44.9694, 47.1599, 48.9776]])\n        _t, yout, _xout = forced_response(self.mimo_ss1, t, u, x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n        # Test discrete MIMO system to use correct convention for input\n        sysc = self.mimo_ss1\n        dt=t[1]-t[0]\n        sysd = c2d(sysc, dt)           # discrete time system\n        Tc, youtc, _xoutc = forced_response(sysc, t, u, x0)\n        Td, youtd, _xoutd = forced_response(sysd, t, u, x0)\n        np.testing.assert_array_equal(Tc.shape, Td.shape)\n        np.testing.assert_array_equal(youtc.shape, youtd.shape)\n        np.testing.assert_array_almost_equal(youtc, youtd, decimal=4)\n\n        # Test discrete MIMO system without default T argument\n        u = np.array([[0., 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                      [1., 1, 1, 1, 1, 1, 1, 1, 1, 1]])\n        x0 = np.array([[.5], [1], [0], [0]])\n        youttrue = np.array([[11., 8.1494, 5.9361, 4.2258, 2.9118, 1.9092,\n                              1.1508, 0.5833, 0.1645, -0.1391],\n                             [9., 17.6457, 24.7072, 30.4855, 35.2234, 39.1165,\n                              42.3227, 44.9694, 47.1599, 48.9776]])\n        _t, yout, _xout = forced_response(sysd, U=u, X0=x0)\n        np.testing.assert_array_almost_equal(yout, youttrue, decimal=4)\n\n    def test_lsim_double_integrator(self):\n        # Note: scipy.signal.lsim fails if A is not invertible\n        A = np.mat(""0. 1.;0. 0."")\n        B = np.mat(""0.; 1."")\n        C = np.mat(""1. 0."")\n        D = 0.\n        sys = StateSpace(A, B, C, D)\n\n        def check(u, x0, xtrue):\n            _t, yout, xout = forced_response(sys, t, u, x0)\n            np.testing.assert_array_almost_equal(xout, xtrue, decimal=6)\n            ytrue = np.squeeze(np.asarray(C.dot(xtrue)))\n            np.testing.assert_array_almost_equal(yout, ytrue, decimal=6)\n\n        # test with zero input\n        npts = 10\n        t = np.linspace(0, 1, npts)\n        u = np.zeros_like(t)\n        x0 = np.array([2., 3.])\n        xtrue = np.zeros((2, npts))\n        xtrue[0, :] = x0[0] + t * x0[1]\n        xtrue[1, :] = x0[1]\n        check(u, x0, xtrue)\n\n        # test with step input\n        u = np.ones_like(t)\n        xtrue = np.array([0.5 * t**2, t])\n        x0 = np.array([0., 0.])\n        check(u, x0, xtrue)\n\n        # test with linear input\n        u = t\n        xtrue = np.array([1./6. * t**3, 0.5 * t**2])\n        check(u, x0, xtrue)\n\n    def test_discrete_initial(self):\n        h1 = TransferFunction([1.], [1., 0.], 1.)\n        t, yout = impulse_response(h1, np.arange(4))\n        np.testing.assert_array_equal(yout, [0., 1., 0., 0.])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_step_robustness(self):\n        ""Unit test: https://github.com/python-control/python-control/issues/240""\n        # Create 2 input, 2 output system\n        num =  [ [[0], [1]],           [[1],   [0]] ]\n        \n        den1 = [ [[1], [1,1]],         [[1,4], [1]] ]\n        sys1 = TransferFunction(num, den1)\n\n        den2 = [ [[1], [1e-10, 1, 1]], [[1,4], [1]] ]   # slight perturbation\n        sys2 = TransferFunction(num, den2)\n\n        # Compute step response from input 1 to output 1, 2\n        t1, y1 = step_response(sys1, input=0)\n        t2, y2 = step_response(sys2, input=0)\n        np.testing.assert_array_almost_equal(y1, y2)\n\n    def test_time_vector(self):\n        ""Unit test: https://github.com/python-control/python-control/issues/239""\n        # Discrete time simulations with specified time vectors\n        Tin1 = np.arange(0, 5, 1)       # matches dtf1, dss1; multiple of 0.2\n        Tin2 = np.arange(0, 5, 0.2)     # matches dtf2, dss2\n        Tin3 = np.arange(0, 5, 0.5)     # incompatible with 0.2\n\n        # Initial conditions to use for the different systems\n        siso_x0 = [1, 2]\n        mimo_x0 = [1, 2, 3, 4]\n\n        #\n        # Easy cases: make sure that output sample time matches input\n        #\n        # No timebase in system => output should match input\n        #\n        # Initial response\n        tout, yout = initial_response(self.siso_dtf1, Tin2, siso_x0,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Impulse response\n        tout, yout = impulse_response(self.siso_dtf1, Tin2,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Step response\n        tout, yout = step_response(self.siso_dtf1, Tin2,\n                                   squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Forced response with specified time vector\n        tout, yout, xout = forced_response(self.siso_dtf1, Tin2, np.sin(Tin2),\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Forced response with no time vector, no sample time (should use 1)\n        tout, yout, xout = forced_response(self.siso_dtf1, None, np.sin(Tin1),\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        # MIMO forced response\n        tout, yout, xout = forced_response(self.mimo_dss1, Tin1, \n                                           (np.sin(Tin1), np.cos(Tin1)),\n                                           mimo_x0)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        self.assertEqual(np.shape(tout), np.shape(yout[1,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        # Matching timebase in system => output should match input\n        #\n        # Initial response\n        tout, yout = initial_response(self.siso_dtf2, Tin2, siso_x0,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Impulse response\n        tout, yout = impulse_response(self.siso_dtf2, Tin2,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Step response\n        tout, yout = step_response(self.siso_dtf2, Tin2,\n                                   squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Forced response\n        tout, yout, xout = forced_response(self.siso_dtf2, Tin2, np.sin(Tin2),\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Forced response with no time vector, use sample time\n        tout, yout, xout = forced_response(self.siso_dtf2, None, np.sin(Tin2),\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin2)\n\n        # Compatible timebase in system => output should match input\n        #\n        # Initial response\n        tout, yout = initial_response(self.siso_dtf2, Tin1, siso_x0,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        # Impulse response\n        tout, yout = impulse_response(self.siso_dtf2, Tin1,\n                                      squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        # Step response\n        tout, yout = step_response(self.siso_dtf2, Tin1,\n                                   squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        # Forced response\n        tout, yout, xout = forced_response(self.siso_dtf2, Tin1, np.sin(Tin1),\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        np.testing.assert_array_equal(tout, Tin1)\n\n        #\n        # Interpolation of the input (to match scipy.signal.dlsim)\n        #\n        # Initial response\n        tout, yout, xout = forced_response(self.siso_dtf2, Tin1,\n                                           np.sin(Tin1), interpolate=True,\n                                           squeeze=False)\n        self.assertEqual(np.shape(tout), np.shape(yout[0,:]))\n        self.assertTrue(np.allclose(tout[1:] - tout[:-1],  self.siso_dtf2.dt))\n\n        #\n        # Incompatible cases: make sure an error is thrown\n        #\n        # System timebase and given time vector are incompatible\n        #\n        # Initial response\n        with self.assertRaises(Exception) as context:\n            tout, yout = initial_response(self.siso_dtf2, Tin3, siso_x0,\n                                          squeeze=False)\n        self.assertTrue(isinstance(context.exception, ValueError))\n\n    def test_time_series_data_convention(self):\n        """"""Make sure time series data matches documentation conventions""""""\n        # SISO continuous time\n        t, y = step_response(self.siso_ss1)\n        self.assertTrue(isinstance(t, np.ndarray)\n                        and not isinstance(t, np.matrix))\n        self.assertTrue(len(t.shape) == 1)\n        self.assertTrue(len(y.shape) == 1) # SISO returns ""scalar"" output\n        self.assertTrue(len(t) == len(y))  # Allows direct plotting of output\n\n        # SISO discrete time\n        t, y = step_response(self.siso_dss1)\n        self.assertTrue(isinstance(t, np.ndarray)\n                        and not isinstance(t, np.matrix))\n        self.assertTrue(len(t.shape) == 1)\n        self.assertTrue(len(y.shape) == 1) # SISO returns ""scalar"" output\n        self.assertTrue(len(t) == len(y))  # Allows direct plotting of output\n\n        # MIMO continuous time\n        tin = np.linspace(0, 10, 100)\n        uin = [np.sin(tin), np.cos(tin)]\n        t, y, x = forced_response(self.mimo_ss1, tin, uin)\n        self.assertTrue(isinstance(t, np.ndarray)\n                        and not isinstance(t, np.matrix))\n        self.assertTrue(len(t.shape) == 1)\n        self.assertTrue(len(y[0].shape) == 1)\n        self.assertTrue(len(y[1].shape) == 1)\n        self.assertTrue(len(t) == len(y[0]))\n        self.assertTrue(len(t) == len(y[1]))\n\n        # MIMO discrete time\n        tin = np.linspace(0, 10, 100)\n        uin = [np.sin(tin), np.cos(tin)]\n        t, y, x = forced_response(self.mimo_dss1, tin, uin)\n        self.assertTrue(isinstance(t, np.ndarray)\n                        and not isinstance(t, np.matrix))\n        self.assertTrue(len(t.shape) == 1)\n        self.assertTrue(len(y[0].shape) == 1)\n        self.assertTrue(len(y[1].shape) == 1)\n        self.assertTrue(len(t) == len(y[0]))\n        self.assertTrue(len(t) == len(y[1]))\n\n        # Allow input time as 2D array (output should be 1D)\n        tin = np.array(np.linspace(0, 10, 100), ndmin=2)\n        t, y = step_response(self.siso_ss1, tin)\n        self.assertTrue(isinstance(t, np.ndarray)\n                        and not isinstance(t, np.matrix))\n        self.assertTrue(len(t.shape) == 1)\n        self.assertTrue(len(y.shape) == 1) # SISO returns ""scalar"" output\n        self.assertTrue(len(t) == len(y))  # Allows direct plotting of output\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestTimeresp)\n\nif __name__ == \'__main__\':\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/xferfcn_input_test.py,60,"b'#!/usr/bin/env python\n#\n# xferfcn_input_test.py - test inputs to TransferFunction class\n# jed-frey, 18 Feb 2017 (based on xferfcn_test.py)\n\nimport unittest\nimport numpy as np\n\nfrom numpy import int, int8, int16, int32, int64\nfrom numpy import float, float16, float32, float64, longdouble\nfrom numpy import all, ndarray, array\n\nfrom control.xferfcn import _clean_part\n\n\nclass TestXferFcnInput(unittest.TestCase):\n    """"""These are tests for functionality of cleaning and validating XferFcnInput.""""""\n\n    # Tests for raising exceptions.\n    def test_clean_part_bad_input_type(self):\n        """"""Give the part cleaner invalid input type.""""""\n\n        self.assertRaises(TypeError, _clean_part, [[0., 1.], [2., 3.]])\n\n    def test_clean_part_bad_input_type2(self):\n        """"""Give the part cleaner another invalid input type.""""""\n        self.assertRaises(TypeError, _clean_part, [1, ""a""])\n\n    def test_clean_part_scalar(self):\n        """"""Test single scalar value.""""""\n        num = 1\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_list_scalar(self):\n        """"""Test single scalar value in list.""""""\n        num = [1]\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_tuple_scalar(self):\n        """"""Test single scalar value in tuple.""""""\n        num = (1)\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_list(self):\n        """"""Test multiple values in a list.""""""\n        num = [1, 2]\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0, 2.0], dtype=float))\n\n    def test_clean_part_tuple(self):\n        """"""Test multiple values in tuple.""""""\n        num = (1, 2)\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0, 2.0], dtype=float))\n\n    def test_clean_part_all_scalar_types(self):\n        """"""Test single scalar value for all valid data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = dtype(1)\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_np_array(self):\n        """"""Test multiple values in numpy array.""""""\n        num = np.array([1, 2])\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0, 2.0], dtype=float))\n\n    def test_clean_part_all_np_array_types(self):\n        """"""Test scalar value in numpy array of ndim=0 for all data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = np.array(1, dtype=dtype)\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_all_np_array_types2(self):\n        """"""Test numpy array for all types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = np.array([1, 2], dtype=dtype)\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 2.0], dtype=float))\n\n    def test_clean_part_list_all_types(self):\n        """"""Test list of a single value for all data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = [dtype(1)]\n            num_ = _clean_part(num)\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_list_all_types2(self):\n        """"""List of list of numbers of all data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = [dtype(1), dtype(2)]\n            num_ = _clean_part(num)\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 2.0], dtype=float))\n\n    def test_clean_part_tuple_all_types(self):\n        """"""Test tuple of a single value for all data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = (dtype(1),)\n            num_ = _clean_part(num)\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_tuple_all_types2(self):\n        """"""Test tuple of a single value for all data types.""""""\n        for dtype in [int, int8, int16, int32, int64, float, float16, float32, float64, longdouble]:\n            num = (dtype(1), dtype(2))\n            num_ = _clean_part(num)\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1, 2], dtype=float))\n\n    def test_clean_part_list_list_list_int(self):\n        """""" Test an int in a list of a list of a list.""""""\n        num = [[[1]]]\n        num_ = _clean_part(num)\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_list_list_list_float(self):\n        """""" Test a float in a list of a list of a list.""""""\n        num = [[[1.0]]]\n        num_ = _clean_part(num)\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0], dtype=float))\n\n    def test_clean_part_list_list_list_ints(self):\n        """"""Test 2 lists of ints in a list in a list.""""""\n        num = [[[1, 1], [2, 2]]]\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n        np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_list_list_list_floats(self):\n        """"""Test 2 lists of ints in a list in a list.""""""\n        num = [[[1.0, 1.0], [2.0, 2.0]]]\n        num_ = _clean_part(num)\n\n        assert isinstance(num_, list)\n        assert np.all([isinstance(part, list) for part in num_])\n        np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n        np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_list_list_array(self):\n        """"""List of list of numpy arrays for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = [[array([1, 1], dtype=dtype), array([2, 2], dtype=dtype)]]\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_tuple_list_array(self):\n        """"""Tuple of list of numpy arrays for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = ([array([1, 1], dtype=dtype), array([2, 2], dtype=dtype)],)\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_list_tuple_array(self):\n        """"""List of tuple of numpy array for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = [(array([1, 1], dtype=dtype), array([2, 2], dtype=dtype))]\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_tuple_tuples_arrays(self):\n        """"""Tuple of tuples of numpy arrays for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = ((array([1, 1], dtype=dtype), array([2, 2], dtype=dtype)),\n                   (array([3, 4], dtype=dtype), array([4, 4], dtype=dtype)))\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_list_tuples_arrays(self):\n        """"""List of tuples of numpy arrays for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = [(array([1, 1], dtype=dtype), array([2, 2], dtype=dtype)),\n                   (array([3, 4], dtype=dtype), array([4, 4], dtype=dtype))]\n            num_ = _clean_part(num)\n\n            assert isinstance(num_, list)\n            assert np.all([isinstance(part, list) for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n\n    def test_clean_part_list_list_arrays(self):\n        """"""List of list of numpy arrays for all valid types.""""""\n        for dtype in int, int8, int16, int32, int64, float, float16, float32, float64, longdouble:\n            num = [[array([1, 1], dtype=dtype), array([2, 2], dtype=dtype)],\n                   [array([3, 3], dtype=dtype), array([4, 4], dtype=dtype)]]\n            num_ = _clean_part(num)\n\n            assert len(num_) == 2\n            assert np.all([isinstance(part, list) for part in num_])\n            assert np.all([len(part) == 2 for part in num_])\n            np.testing.assert_array_equal(num_[0][0], array([1.0, 1.0], dtype=float))\n            np.testing.assert_array_equal(num_[0][1], array([2.0, 2.0], dtype=float))\n            np.testing.assert_array_equal(num_[1][0], array([3.0, 3.0], dtype=float))\n            np.testing.assert_array_equal(num_[1][1], array([4.0, 4.0], dtype=float))\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestXferFcnInput)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
External_Libraries/python_control_master/control/tests/xferfcn_test.py,127,"b'#!/usr/bin/env python\n#\n# xferfcn_test.py - test TransferFunction class\n# RMM, 30 Mar 2011 (based on TestXferFcn from v0.4a)\n\nimport unittest\nimport sys as pysys\nimport numpy as np\nfrom control.statesp import StateSpace, _convertToStateSpace, rss\nfrom control.xferfcn import TransferFunction, _convert_to_transfer_function, \\\n    ss2tf\nfrom control.lti import evalfr\nfrom control.exception import slycot_check\nfrom control.lti import isctime, isdtime\nfrom control.dtime import sample_system\n\n\nclass TestXferFcn(unittest.TestCase):\n    """"""These are tests for functionality and correct reporting of the transfer\n    function class.  Throughout these tests, we will give different input\n    formats to the xTranferFunction constructor, to try to break it.  These\n    tests have been verified in MATLAB.""""""\n\n    # Tests for raising exceptions.\n\n    def test_constructor_bad_input_type(self):\n        """"""Give the constructor invalid input types.""""""\n\n        # MIMO requires lists of lists of vectors (not lists of vectors)\n        self.assertRaises(\n            TypeError,\n            TransferFunction, [[0., 1.], [2., 3.]], [[5., 2.], [3., 0.]])\n        TransferFunction([[ [0., 1.], [2., 3.] ]], [[ [5., 2.], [3., 0.] ]])\n\n        # Single argument of the wrong type\n        self.assertRaises(TypeError, TransferFunction, [1])\n\n        # Too many arguments\n        self.assertRaises(ValueError, TransferFunction, 1, 2, 3, 4)\n\n        # Different numbers of elements in numerator rows\n        self.assertRaises(\n            ValueError,\n            TransferFunction, [ [[0, 1], [2, 3]],\n                                [[4, 5]] ],\n                              [ [[6, 7], [4, 5]],\n                                [[2, 3], [0, 1]] ])\n        self.assertRaises(\n            ValueError,\n            TransferFunction, [ [[0, 1], [2, 3]],\n                                [[4, 5], [6, 7]] ],\n                              [ [[6, 7], [4, 5]],\n                                [[2, 3]] ])\n        TransferFunction(       # This version is OK\n            [ [[0, 1], [2, 3]], [[4, 5], [6, 7]] ],\n            [ [[6, 7], [4, 5]], [[2, 3], [0, 1]] ])\n\n    def test_constructor_inconsistent_dimension(self):\n        """"""Give constructor numerators, denominators of different sizes.""""""\n\n        self.assertRaises(ValueError, TransferFunction,\n            [[[1.]]], [[[1.], [2., 3.]]])\n        self.assertRaises(ValueError, TransferFunction,\n            [[[1.]]], [[[1.]], [[2., 3.]]])\n        self.assertRaises(ValueError, TransferFunction,\n            [[[1.]]], [[[1.], [1., 2.]], [[5., 2.], [2., 3.]]])\n\n    def test_constructor_inconsistent_columns(self):\n        """"""Give the constructor inputs that do not have the same number of\n        columns in each row.""""""\n\n        self.assertRaises(ValueError, TransferFunction,\n                          1., [[[1.]], [[2.], [3.]]])\n        self.assertRaises(ValueError, TransferFunction,\n                          [[[1.]], [[2.], [3.]]], 1.)\n\n    def test_constructor_zero_denominator(self):\n        """"""Give the constructor a transfer function with a zero denominator.""""""\n\n        self.assertRaises(ValueError, TransferFunction, 1., 0.)\n        self.assertRaises(ValueError, TransferFunction,\n                          [[[1.], [2., 3.]], [[-1., 4.], [3., 2.]]],\n                          [[[1., 0.], [0.]], [[0., 0.], [2.]]])\n\n    def test_add_inconsistent_dimension(self):\n        """"""Add two transfer function matrices of different sizes.""""""\n\n        sys1 = TransferFunction([[[1., 2.]]], [[[4., 5.]]])\n        sys2 = TransferFunction([[[4., 3.]], [[1., 2.]]],\n                                [[[1., 6.]], [[2., 4.]]])\n        self.assertRaises(ValueError, sys1.__add__, sys2)\n        self.assertRaises(ValueError, sys1.__sub__, sys2)\n        self.assertRaises(ValueError, sys1.__radd__, sys2)\n        self.assertRaises(ValueError, sys1.__rsub__, sys2)\n\n    def test_mul_inconsistent_dimension(self):\n        """"""Multiply two transfer function matrices of incompatible sizes.""""""\n\n        sys1 = TransferFunction([[[1., 2.], [4., 5.]], [[2., 5.], [4., 3.]]],\n                                [[[6., 2.], [4., 1.]], [[6., 7.], [2., 4.]]])\n        sys2 = TransferFunction([[[1.]], [[2.]], [[3.]]],\n                                [[[4.]], [[5.]], [[6.]]])\n        self.assertRaises(ValueError, sys1.__mul__, sys2)\n        self.assertRaises(ValueError, sys2.__mul__, sys1)\n        self.assertRaises(ValueError, sys1.__rmul__, sys2)\n        self.assertRaises(ValueError, sys2.__rmul__, sys1)\n\n    # Tests for TransferFunction._truncatecoeff\n\n    def test_truncate_coefficients_non_null_numerator(self):\n        """"""Remove extraneous zeros in polynomial representations.""""""\n\n        sys1 = TransferFunction([0., 0., 1., 2.], [[[0., 0., 0., 3., 2., 1.]]])\n\n        np.testing.assert_array_equal(sys1.num, [[[1., 2.]]])\n        np.testing.assert_array_equal(sys1.den, [[[3., 2., 1.]]])\n\n    def test_truncate_coefficients_null_numerator(self):\n        """"""Remove extraneous zeros in polynomial representations.""""""\n\n        sys1 = TransferFunction([0., 0., 0.], 1.)\n\n        np.testing.assert_array_equal(sys1.num, [[[0.]]])\n        np.testing.assert_array_equal(sys1.den, [[[1.]]])\n\n    # Tests for TransferFunction.__neg__\n\n    def test_reverse_sign_scalar(self):\n        """"""Negate a direct feedthrough system.""""""\n\n        sys1 = TransferFunction(2., np.array([-3.]))\n        sys2 = - sys1\n\n        np.testing.assert_array_equal(sys2.num, [[[-2.]]])\n        np.testing.assert_array_equal(sys2.den, [[[-3.]]])\n\n    def test_reverse_sign_siso(self):\n        """"""Negate a SISO system.""""""\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1.])\n        sys2 = - sys1\n\n        np.testing.assert_array_equal(sys2.num, [[[-1., -3., -5.]]])\n        np.testing.assert_array_equal(sys2.den, [[[1., 6., 2., -1.]]])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_reverse_sign_mimo(self):\n        """"""Negate a MIMO system.""""""\n\n        num1 = [[[1., 2.], [0., 3.], [2., -1.]],\n                [[1.], [4., 0.], [1., -4., 3.]]]\n        num3 = [[[-1., -2.], [0., -3.], [-2., 1.]],\n                [[-1.], [-4., 0.], [-1., 4., -3.]]]\n        den1 = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n                [[3., 0., .0], [2., -1., -1.], [1.]]]\n\n        sys1 = TransferFunction(num1, den1)\n        sys2 = - sys1\n        sys3 = TransferFunction(num3, den1)\n\n        for i in range(sys3.outputs):\n            for j in range(sys3.inputs):\n                np.testing.assert_array_equal(sys2.num[i][j], sys3.num[i][j])\n                np.testing.assert_array_equal(sys2.den[i][j], sys3.den[i][j])\n\n    # Tests for TransferFunction.__add__\n\n    def test_add_scalar(self):\n        """"""Add two direct feedthrough systems.""""""\n\n        sys1 = TransferFunction(1., [[[1.]]])\n        sys2 = TransferFunction(np.array([2.]), [1.])\n        sys3 = sys1 + sys2\n\n        np.testing.assert_array_equal(sys3.num, 3.)\n        np.testing.assert_array_equal(sys3.den, 1.)\n\n    def test_add_siso(self):\n        """"""Add two SISO systems.""""""\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        sys2 = TransferFunction([[np.array([-1., 3.])]], [[[1., 0., -1.]]])\n        sys3 = sys1 + sys2\n\n        # If sys3.num is [[[0., 20., 4., -8.]]], then this is wrong!\n        np.testing.assert_array_equal(sys3.num, [[[20., 4., -8]]])\n        np.testing.assert_array_equal(sys3.den, [[[1., 6., 1., -7., -2., 1.]]])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_add_mimo(self):\n        """"""Add two MIMO systems.""""""\n\n        num1 = [[[1., 2.], [0., 3.], [2., -1.]],\n                [[1.], [4., 0.], [1., -4., 3.]]]\n        den1 = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n                [[3., 0., .0], [2., -1., -1.], [1.]]]\n        num2 = [[[0., 0., -1], [2.], [-1., -1.]],\n                [[1., 2.], [-1., -2.], [4.]]]\n        den2 = [[[-1.], [1., 2., 3.], [-1., -1.]],\n                [[-4., -3., 2.], [0., 1.], [1., 0.]]]\n        num3 = [[[3., -3., -6], [5., 6., 9.], [-4., -2., 2]],\n                [[3., 2., -3., 2], [-2., -3., 7., 2.], [1., -4., 3., 4]]]\n        den3 = [[[3., -2., -4.], [1., 2., 3., 0., 0.], [-2., -1., 1.]],\n                [[-12., -9., 6., 0., 0.], [2., -1., -1.], [1., 0.]]]\n\n        sys1 = TransferFunction(num1, den1)\n        sys2 = TransferFunction(num2, den2)\n        sys3 = sys1 + sys2\n\n        for i in range(sys3.outputs):\n            for j in range(sys3.inputs):\n                np.testing.assert_array_equal(sys3.num[i][j], num3[i][j])\n                np.testing.assert_array_equal(sys3.den[i][j], den3[i][j])\n\n    # Tests for TransferFunction.__sub__\n\n    def test_subtract_scalar(self):\n        """"""Subtract two direct feedthrough systems.""""""\n\n        sys1 = TransferFunction(1., [[[1.]]])\n        sys2 = TransferFunction(np.array([2.]), [1.])\n        sys3 = sys1 - sys2\n\n        np.testing.assert_array_equal(sys3.num, -1.)\n        np.testing.assert_array_equal(sys3.den, 1.)\n\n    def test_subtract_siso(self):\n        """"""Subtract two SISO systems.""""""\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        sys2 = TransferFunction([[np.array([-1., 3.])]], [[[1., 0., -1.]]])\n        sys3 = sys1 - sys2\n        sys4 = sys2 - sys1\n\n        np.testing.assert_array_equal(sys3.num, [[[2., 6., -12., -10., -2.]]])\n        np.testing.assert_array_equal(sys3.den, [[[1., 6., 1., -7., -2., 1.]]])\n        np.testing.assert_array_equal(sys4.num, [[[-2., -6., 12., 10., 2.]]])\n        np.testing.assert_array_equal(sys4.den, [[[1., 6., 1., -7., -2., 1.]]])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_subtract_mimo(self):\n        """"""Subtract two MIMO systems.""""""\n\n        num1 = [[[1., 2.], [0., 3.], [2., -1.]],\n                [[1.], [4., 0.], [1., -4., 3.]]]\n        den1 = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n                [[3., 0., .0], [2., -1., -1.], [1.]]]\n        num2 = [[[0., 0., -1], [2.], [-1., -1.]],\n                [[1., 2.], [-1., -2.], [4.]]]\n        den2 = [[[-1.], [1., 2., 3.], [-1., -1.]],\n                [[-4., -3., 2.], [0., 1.], [1., 0.]]]\n        num3 = [[[-3., 1., 2.], [1., 6., 9.], [0.]],\n                [[-3., -10., -3., 2], [2., 3., 1., -2], [1., -4., 3., -4]]]\n        den3 = [[[3., -2., -4], [1., 2., 3., 0., 0.], [1]],\n                [[-12., -9., 6., 0., 0.], [2., -1., -1], [1., 0.]]]\n\n        sys1 = TransferFunction(num1, den1)\n        sys2 = TransferFunction(num2, den2)\n        sys3 = sys1 - sys2\n\n        for i in range(sys3.outputs):\n            for j in range(sys3.inputs):\n                np.testing.assert_array_equal(sys3.num[i][j], num3[i][j])\n                np.testing.assert_array_equal(sys3.den[i][j], den3[i][j])\n\n    # Tests for TransferFunction.__mul__\n\n    def test_multiply_scalar(self):\n        """"""Multiply two direct feedthrough systems.""""""\n\n        sys1 = TransferFunction(2., [1.])\n        sys2 = TransferFunction(1., 4.)\n        sys3 = sys1 * sys2\n        sys4 = sys1 * sys2\n\n        np.testing.assert_array_equal(sys3.num, [[[2.]]])\n        np.testing.assert_array_equal(sys3.den, [[[4.]]])\n        np.testing.assert_array_equal(sys3.num, sys4.num)\n        np.testing.assert_array_equal(sys3.den, sys4.den)\n\n    def test_multiply_siso(self):\n        """"""Multiply two SISO systems.""""""\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        sys2 = TransferFunction([[[-1., 3.]]], [[[1., 0., -1.]]])\n        sys3 = sys1 * sys2\n        sys4 = sys2 * sys1\n\n        np.testing.assert_array_equal(sys3.num, [[[-1., 0., 4., 15.]]])\n        np.testing.assert_array_equal(sys3.den, [[[1., 6., 1., -7., -2., 1.]]])\n        np.testing.assert_array_equal(sys3.num, sys4.num)\n        np.testing.assert_array_equal(sys3.den, sys4.den)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_multiply_mimo(self):\n        """"""Multiply two MIMO systems.""""""\n\n        num1 = [[[1., 2.], [0., 3.], [2., -1.]],\n                [[1.], [4., 0.], [1., -4., 3.]]]\n        den1 = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n                [[3., 0., .0], [2., -1., -1.], [1.]]]\n        num2 = [[[0., 1., 2.]],\n                [[1., -5.]],\n                [[-2., 1., 4.]]]\n        den2 = [[[1., 0., 0., 0.]],\n                [[-2., 1., 3.]],\n                [[4., -1., -1., 0.]]]\n        num3 = [[[-24., 52., -14., 245., -490., -115., 467., -95., -56., 12.,\n                  0., 0., 0.]],\n                [[24., -132., 138., 345., -768., -106., 510., 41., -79., -69.,\n                 -23., 17., 6., 0.]]]\n        den3 = [[[48., -92., -84., 183., 44., -97., -2., 12., 0., 0., 0., 0.,\n                  0., 0.]],\n                [[-48., 60., 84., -81., -45., 21., 9., 0., 0., 0., 0., 0., 0.]]]\n\n        sys1 = TransferFunction(num1, den1)\n        sys2 = TransferFunction(num2, den2)\n        sys3 = sys1 * sys2\n\n        for i in range(sys3.outputs):\n            for j in range(sys3.inputs):\n                np.testing.assert_array_equal(sys3.num[i][j], num3[i][j])\n                np.testing.assert_array_equal(sys3.den[i][j], den3[i][j])\n\n    # Tests for TransferFunction.__div__\n\n    def test_divide_scalar(self):\n        """"""Divide two direct feedthrough systems.""""""\n\n        sys1 = TransferFunction(np.array([3.]), -4.)\n        sys2 = TransferFunction(5., 2.)\n        sys3 = sys1 / sys2\n\n        np.testing.assert_array_equal(sys3.num, [[[6.]]])\n        np.testing.assert_array_equal(sys3.den, [[[-20.]]])\n\n    def test_divide_siso(self):\n        """"""Divide two SISO systems.""""""\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        sys2 = TransferFunction([[[-1., 3.]]], [[[1., 0., -1.]]])\n        sys3 = sys1 / sys2\n        sys4 = sys2 / sys1\n\n        np.testing.assert_array_equal(sys3.num, [[[1., 3., 4., -3., -5.]]])\n        np.testing.assert_array_equal(sys3.den, [[[-1., -3., 16., 7., -3.]]])\n        np.testing.assert_array_equal(sys4.num, sys3.den)\n        np.testing.assert_array_equal(sys4.den, sys3.num)\n\n    def test_div(self):\n        # Make sure that sampling times work correctly\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        sys2 = TransferFunction([[[-1., 3.]]], [[[1., 0., -1.]]], True)\n        sys3 = sys1 / sys2\n        self.assertEqual(sys3.dt, True)\n\n        sys2 = TransferFunction([[[-1., 3.]]], [[[1., 0., -1.]]], 0.5)\n        sys3 = sys1 / sys2\n        self.assertEqual(sys3.dt, 0.5)\n\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1], 0.1)\n        self.assertRaises(ValueError, TransferFunction.__truediv__, sys1, sys2)\n\n        sys1 = sample_system(rss(4, 1, 1), 0.5)\n        sys3 = TransferFunction.__rtruediv__(sys2, sys1)\n        self.assertEqual(sys3.dt, 0.5)\n\n    def test_pow(self):\n        sys1 = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n        self.assertRaises(ValueError, TransferFunction.__pow__, sys1, 0.5)\n\n    def test_slice(self):\n        sys = TransferFunction(\n            [ [   [1],    [2],    [3]], [   [3],    [4],    [5]] ],\n            [ [[1, 2], [1, 3], [1, 4]], [[1, 4], [1, 5], [1, 6]] ])\n        sys1 = sys[1:, 1:]\n        self.assertEqual((sys1.inputs, sys1.outputs), (2, 1))\n\n        sys2 = sys[:2, :2]\n        self.assertEqual((sys2.inputs, sys2.outputs), (2, 2))\n\n        sys = TransferFunction(\n            [ [   [1],    [2],    [3]], [   [3],    [4],    [5]] ],\n            [ [[1, 2], [1, 3], [1, 4]], [[1, 4], [1, 5], [1, 6]] ], 0.5)\n        sys1 = sys[1:, 1:]\n        self.assertEqual((sys1.inputs, sys1.outputs), (2, 1))\n        self.assertEqual(sys1.dt, 0.5)\n\n    def test_evalfr_siso(self):\n        """"""Evaluate the frequency response of a SISO system at one frequency.""""""\n\n        sys = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n\n        np.testing.assert_array_almost_equal(evalfr(sys, 1j),\n                                             np.array([[-0.5 - 0.5j]]))\n        np.testing.assert_array_almost_equal(\n            evalfr(sys, 32j),\n            np.array([[0.00281959302585077 - 0.030628473607392j]]))\n\n        # Test call version as well\n        np.testing.assert_almost_equal(sys(1.j), -0.5 - 0.5j)\n        np.testing.assert_almost_equal(\n            sys(32.j), 0.00281959302585077 - 0.030628473607392j)\n\n        # Test internal version (with real argument)\n        np.testing.assert_array_almost_equal(\n            sys._evalfr(1.), np.array([[-0.5 - 0.5j]]))\n        np.testing.assert_array_almost_equal(\n            sys._evalfr(32.),\n            np.array([[0.00281959302585077 - 0.030628473607392j]]))\n\n    # This test only works in Python 3 due to a conflict with the same\n    # warning type in other test modules (frd_test.py).  See\n    # https://bugs.python.org/issue4180 for more details\n    @unittest.skipIf(pysys.version_info < (3, 0), ""test requires Python 3+"")\n    def test_evalfr_deprecated(self):\n        sys = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n\n        # Deprecated version of the call (should generate warning)\n        import warnings\n        with warnings.catch_warnings():\n            # Make warnings generate an exception\n            warnings.simplefilter(\'error\')\n\n            # Make sure that we get a pending deprecation warning\n            self.assertRaises(PendingDeprecationWarning, sys.evalfr, 1.)\n\n    @unittest.skipIf(pysys.version_info < (3, 0), ""test requires Python 3+"")\n    def test_evalfr_dtime(self):\n        sys = TransferFunction([1., 3., 5], [1., 6., 2., -1], 0.1)\n        np.testing.assert_array_almost_equal(sys(1j), -0.5 - 0.5j)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_evalfr_mimo(self):\n        """"""Evaluate the frequency response of a MIMO system at one frequency.""""""\n\n        num = [[[1., 2.], [0., 3.], [2., -1.]],\n               [[1.], [4., 0.], [1., -4., 3.]]]\n        den = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n               [[3., 0., .0], [2., -1., -1.], [1.]]]\n        sys = TransferFunction(num, den)\n        resp = [[0.147058823529412 + 0.0882352941176471j, -0.75, 1.],\n                [-0.083333333333333, -0.188235294117647 - 0.847058823529412j,\n                 -1. - 8.j]]\n\n        np.testing.assert_array_almost_equal(sys._evalfr(2.), resp)\n\n        # Test call version as well\n        np.testing.assert_array_almost_equal(sys(2.j), resp)\n\n    def test_freqresp_siso(self):\n        """"""Evaluate the magnitude and phase of a SISO system at \n        multiple frequencies.""""""\n\n        sys = TransferFunction([1., 3., 5], [1., 6., 2., -1])\n\n        truemag = [[[4.63507337473906, 0.707106781186548, 0.0866592803995351]]]\n        truephase = [[[-2.89596891081488, -2.35619449019234,\n                       -1.32655885133871]]]\n        trueomega = [0.1, 1., 10.]\n\n        mag, phase, omega = sys.freqresp(trueomega)\n\n        np.testing.assert_array_almost_equal(mag, truemag)\n        np.testing.assert_array_almost_equal(phase, truephase)\n        np.testing.assert_array_almost_equal(omega, trueomega)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_freqresp_mimo(self):\n        """"""Evaluate the magnitude and phase of a MIMO system at \n        multiple frequencies.""""""\n\n        num = [[[1., 2.], [0., 3.], [2., -1.]],\n               [[1.], [4., 0.], [1., -4., 3.]]]\n        den = [[[-3., 2., 4.], [1., 0., 0.], [2., -1.]],\n               [[3., 0., .0], [2., -1., -1.], [1.]]]\n        sys = TransferFunction(num, den)\n\n        true_omega = [0.1, 1., 10.]\n        true_mag = [[[0.49628709, 0.30714755, 0.03347381],\n                    [300., 3., 0.03], [1., 1., 1.]],\n                    [[33.333333, 0.33333333, 0.00333333],\n                     [0.39028569, 1.26491106, 0.19875914],\n                    [3.01663720, 4.47213595, 104.92378186]]]\n        true_phase = [[[3.7128711e-4, 0.18534794,\n                        1.30770596], [-np.pi, -np.pi, -np.pi],\n                       [0., 0., 0.]],\n                      [[-np.pi, -np.pi, -np.pi],\n                       [-1.66852323, -1.89254688, -1.62050658],\n                       [-0.13298964, -1.10714871, -2.75046720]]]\n\n        mag, phase, omega = sys.freqresp(true_omega)\n\n        np.testing.assert_array_almost_equal(mag, true_mag)\n        np.testing.assert_array_almost_equal(phase, true_phase)\n        np.testing.assert_array_equal(omega, true_omega)\n\n    # Tests for TransferFunction.pole and TransferFunction.zero.\n    \n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_pole_mimo(self):\n        """"""Test for correct MIMO poles.""""""\n\n        sys = TransferFunction(\n            [[[1.], [1.]], [[1.], [1.]]],\n            [[[1., 2.], [1., 3.]], [[1., 4., 4.], [1., 9., 14.]]])\n        p = sys.pole()\n\n        np.testing.assert_array_almost_equal(p, [-2., -2., -7., -3., -2.])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_double_cancelling_poles_siso(self):\n        \n        H = TransferFunction([1, 1], [1, 2, 1])\n        p = H.pole()\n        np.testing.assert_array_almost_equal(p, [-1, -1])\n    \n    # Tests for TransferFunction.feedback\n    def test_feedback_siso(self):\n        """"""Test for correct SISO transfer function feedback.""""""\n\n        sys1 = TransferFunction([-1., 4.], [1., 3., 5.])\n        sys2 = TransferFunction([2., 3., 0.], [1., -3., 4., 0])\n\n        sys3 = sys1.feedback(sys2)\n        sys4 = sys1.feedback(sys2, 1)\n\n        np.testing.assert_array_equal(sys3.num, [[[-1., 7., -16., 16., 0.]]])\n        np.testing.assert_array_equal(sys3.den, [[[1., 0., -2., 2., 32., 0.]]])\n        np.testing.assert_array_equal(sys4.num, [[[-1., 7., -16., 16., 0.]]])\n        np.testing.assert_array_equal(sys4.den, [[[1., 0., 2., -8., 8., 0.]]])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_convert_to_transfer_function(self):\n        """"""Test for correct state space to transfer function conversion.""""""\n\n        A = [[1., -2.], [-3., 4.]]\n        B = [[6., 5.], [4., 3.]]\n        C = [[1., -2.], [3., -4.], [5., -6.]]\n        D = [[1., 0.], [0., 1.], [1., 0.]]\n        sys = StateSpace(A, B, C, D)\n\n        tfsys = _convert_to_transfer_function(sys)\n\n        num = [[np.array([1., -7., 10.]), np.array([-1., 10.])],\n               [np.array([2., -8.]), np.array([1., -2., -8.])],\n               [np.array([1., 1., -30.]), np.array([7., -22.])]]\n        den = [[np.array([1., -5., -2.]) for _ in range(sys.inputs)]\n               for _ in range(sys.outputs)]\n\n        for i in range(sys.outputs):\n            for j in range(sys.inputs):\n                np.testing.assert_array_almost_equal(tfsys.num[i][j], num[i][j])\n                np.testing.assert_array_almost_equal(tfsys.den[i][j], den[i][j])\n\n    def test_minreal(self):\n        """"""Try the minreal function, and also test easy entry by creation\n        of a Laplace variable s""""""\n        s = TransferFunction([1, 0], [1])\n        h = (s + 1) * (s + 2.00000000001) / (s + 2) / (s**2 + s + 1)\n        hm = h.minreal()\n        hr = (s + 1) / (s**2 + s + 1)\n        np.testing.assert_array_almost_equal(hm.num[0][0], hr.num[0][0])\n        np.testing.assert_array_almost_equal(hm.den[0][0], hr.den[0][0])\n        np.testing.assert_equal(hm.dt, hr.dt)\n\n    def test_minreal_2(self):\n        """"""This one gave a problem, due to poly([]) giving simply 1\n        instead of numpy.array([1])""""""\n        s = TransferFunction([1, 0], [1])\n        G = 6205/(s*(s**2 + 13*s + 1281))\n        Heq = G.feedback(1)\n        H1 = 1/(s+5)\n        H2a = Heq/H1\n        H2b = H2a.minreal()\n        hr = 6205/(s**2+8*s+1241)\n        np.testing.assert_array_almost_equal(H2b.num[0][0], hr.num[0][0])\n        np.testing.assert_array_almost_equal(H2b.den[0][0], hr.den[0][0])\n        np.testing.assert_equal(H2b.dt, hr.dt)\n\n    def test_minreal_3(self):\n        """"""Regression test for minreal of tf([1,1],[1,1])""""""\n        g = TransferFunction([1,1],[1,1]).minreal()\n        np.testing.assert_array_almost_equal(1.0, g.num[0][0])\n        np.testing.assert_array_almost_equal(1.0, g.den[0][0])\n        np.testing.assert_equal(None, g.dt)\n\n    def test_minreal_4(self):\n        """"""Check minreal on discrete TFs.""""""\n        T = 0.01\n        z = TransferFunction([1, 0], [1], T)\n        h = (z - 1.00000000001) * (z + 1.0000000001) / (z**2 - 1)\n        hm = h.minreal()\n        hr = TransferFunction([1], [1], T)\n        np.testing.assert_array_almost_equal(hm.num[0][0], hr.num[0][0])\n        np.testing.assert_equal(hr.dt, hm.dt)\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_state_space_conversion_mimo(self):\n        """"""Test conversion of a single input, two-output state-space\n        system against the same TF""""""\n        s = TransferFunction([1, 0], [1])\n        b0 = 0.2\n        b1 = 0.1\n        b2 = 0.5\n        a0 = 2.3\n        a1 = 6.3\n        a2 = 3.6\n        a3 = 1.0\n        h = (b0 + b1*s + b2*s**2)/(a0 + a1*s + a2*s**2 + a3*s**3)\n        H = TransferFunction([[h.num[0][0]], [(h*s).num[0][0]]],\n                             [[h.den[0][0]], [h.den[0][0]]])\n        sys = _convertToStateSpace(H)\n        H2 = _convert_to_transfer_function(sys)\n        np.testing.assert_array_almost_equal(H.num[0][0], H2.num[0][0])\n        np.testing.assert_array_almost_equal(H.den[0][0], H2.den[0][0])\n        np.testing.assert_array_almost_equal(H.num[1][0], H2.num[1][0])\n        np.testing.assert_array_almost_equal(H.den[1][0], H2.den[1][0])\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_indexing(self):\n        tm = ss2tf(rss(5, 3, 3))\n\n        # scalar indexing\n        sys01 = tm[0, 1]\n        np.testing.assert_array_almost_equal(sys01.num[0][0], tm.num[0][1])\n        np.testing.assert_array_almost_equal(sys01.den[0][0], tm.den[0][1])\n\n        # slice indexing\n        sys = tm[:2, 1:3]\n        np.testing.assert_array_almost_equal(sys.num[0][0], tm.num[0][1])\n        np.testing.assert_array_almost_equal(sys.den[0][0], tm.den[0][1])\n        np.testing.assert_array_almost_equal(sys.num[0][1], tm.num[0][2])\n        np.testing.assert_array_almost_equal(sys.den[0][1], tm.den[0][2])\n        np.testing.assert_array_almost_equal(sys.num[1][0], tm.num[1][1])\n        np.testing.assert_array_almost_equal(sys.den[1][0], tm.den[1][1])\n        np.testing.assert_array_almost_equal(sys.num[1][1], tm.num[1][2])\n        np.testing.assert_array_almost_equal(sys.den[1][1], tm.den[1][2])\n\n    def test_matrix_multiply(self):\n        """"""MIMO transfer functions should be multiplyable by constant\n        matrices""""""\n        s = TransferFunction([1, 0], [1])\n        b0 = 0.2\n        b1 = 0.1\n        b2 = 0.5\n        a0 = 2.3\n        a1 = 6.3\n        a2 = 3.6\n        a3 = 1.0\n        h = (b0 + b1*s + b2*s**2)/(a0 + a1*s + a2*s**2 + a3*s**3)\n        H = TransferFunction([[h.num[0][0]], [(h*s).num[0][0]]],\n                             [[h.den[0][0]], [h.den[0][0]]])\n        H1 = (np.matrix([[1.0, 0]])*H).minreal()\n        H2 = (np.matrix([[0, 1.0]])*H).minreal()\n        np.testing.assert_array_almost_equal(H.num[0][0], H1.num[0][0])\n        np.testing.assert_array_almost_equal(H.den[0][0], H1.den[0][0])\n        np.testing.assert_array_almost_equal(H.num[1][0], H2.num[0][0])\n        np.testing.assert_array_almost_equal(H.den[1][0], H2.den[0][0])\n\n    def test_dcgain_cont(self):\n        """"""Test DC gain for continuous-time transfer functions""""""\n        sys = TransferFunction(6, 3)\n        np.testing.assert_equal(sys.dcgain(), 2)\n\n        sys2 = TransferFunction(6, [1, 3])\n        np.testing.assert_equal(sys2.dcgain(), 2)\n\n        sys3 = TransferFunction(6, [1, 0])\n        np.testing.assert_equal(sys3.dcgain(), np.inf)\n\n        num = [[[15], [21], [33]], [[10], [14], [22]]]\n        den = [[[1, 3], [2, 3], [3, 3]], [[1, 5], [2, 7], [3, 11]]]\n        sys4 = TransferFunction(num, den)\n        expected = [[5, 7, 11], [2, 2, 2]]\n        np.testing.assert_array_equal(sys4.dcgain(), expected)\n\n    def test_dcgain_discr(self):\n        """"""Test DC gain for discrete-time transfer functions""""""\n        # static gain\n        sys = TransferFunction(6, 3, True)\n        np.testing.assert_equal(sys.dcgain(), 2)\n\n        # averaging filter\n        sys = TransferFunction(0.5, [1, -0.5], True)\n        np.testing.assert_almost_equal(sys.dcgain(), 1)\n\n        # differencer\n        sys = TransferFunction(1, [1, -1], True)\n        np.testing.assert_equal(sys.dcgain(), np.inf)\n\n        # summer\n        # causes a RuntimeWarning due to the divide by zero\n        sys = TransferFunction([1, -1], [1], True)\n        np.testing.assert_equal(sys.dcgain(), 0)\n\n    def test_ss2tf(self):\n        A = np.array([[-4, -1], [-1, -4]])\n        B = np.array([[1], [3]])\n        C = np.array([[3, 1]])\n        D = 0\n        sys = ss2tf(A, B, C, D)\n        true_sys = TransferFunction([6., 14.], [1., 8., 15.])\n        np.testing.assert_almost_equal(sys.num, true_sys.num)\n        np.testing.assert_almost_equal(sys.den, true_sys.den)\n\n    def test_class_constants(self):\n        # Make sure that the \'s\' variable is defined properly\n        s = TransferFunction.s\n        G = (s + 1)/(s**2 + 2*s + 1)\n        np.testing.assert_array_almost_equal(G.num, [[[1, 1]]])\n        np.testing.assert_array_almost_equal(G.den, [[[1, 2, 1]]])\n        self.assertTrue(isctime(G, strict=True))\n\n        # Make sure that the \'z\' variable is defined properly\n        z = TransferFunction.z\n        G = (z + 1)/(z**2 + 2*z + 1)\n        np.testing.assert_array_almost_equal(G.num, [[[1, 1]]])\n        np.testing.assert_array_almost_equal(G.den, [[[1, 2, 1]]])\n        self.assertTrue(isdtime(G, strict=True))\n\n    def test_printing(self):\n        # SISO, continuous time\n        sys = ss2tf(rss(4, 1, 1))\n        self.assertTrue(isinstance(str(sys), str))\n        self.assertTrue(isinstance(sys._repr_latex_(), str))\n\n        # SISO, discrete time\n        sys = sample_system(sys, 1)\n        self.assertTrue(isinstance(str(sys), str))\n        self.assertTrue(isinstance(sys._repr_latex_(), str))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_printing_mimo(self):\n        # MIMO, continuous time\n        sys = ss2tf(rss(4, 2, 3))\n        self.assertTrue(isinstance(str(sys), str))\n        self.assertTrue(isinstance(sys._repr_latex_(), str))\n\n    @unittest.skipIf(not slycot_check(), ""slycot not installed"")\n    def test_size_mismatch(self):\n        sys1 = ss2tf(rss(2, 2, 2))\n\n        # Different number of inputs\n        sys2 = ss2tf(rss(3, 1, 2))\n        self.assertRaises(ValueError, TransferFunction.__add__, sys1, sys2)\n\n        # Different number of outputs\n        sys2 = ss2tf(rss(3, 2, 1))\n        self.assertRaises(ValueError, TransferFunction.__add__, sys1, sys2)\n\n        # Inputs and outputs don\'t match\n        self.assertRaises(ValueError, TransferFunction.__mul__, sys2, sys1)\n\n        # Feedback mismatch (MIMO not implemented)\n        self.assertRaises(NotImplementedError,\n                          TransferFunction.feedback, sys2, sys1)\n\n\ndef suite():\n    return unittest.TestLoader().loadTestsFromTestCase(TestXferFcn)\n\n\nif __name__ == ""__main__"":\n    unittest.main()\n'"
