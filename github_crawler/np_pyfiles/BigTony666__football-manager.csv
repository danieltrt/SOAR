file_path,api_count,code
method1-2.py,2,"b'#!/usr/bin/env python\n# coding: utf-8\n\n# In[2]:\n\n\nfrom pyspark import SparkContext\nfrom pyspark.sql import SQLContext\nfrom pyspark.sql.types import StringType\nimport time\nimport numpy as np\n\nsc =SparkContext.getOrCreate()\nsqlContext = SQLContext(sc)\n\n\n# In[3]:\n\n\ndef readCSV(path):\n    \'\'\'\n    read csv file\n    return spark sql data frame\n    \'\'\'\n    return sqlContext.read.format(""csv"").options(header=""true"")    .load(path)\n\n\n# In[4]:\n\n\nteam_df = readCSV(""/Users/peggy/Desktop/footballManager/team_feat.csv"")\n\n\n# In[5]:\n\n\n\nplayer_df = readCSV(""/Users/peggy/Desktop/footballManager/data_clean.csv"")\n\n\n# In[6]:\n\n\ndef playerSimilarity(p1, p2):\n    \'\'\'\n    length of p2 times cosine of p1 & p2\n    \'\'\'\n    cosine = np.dot(p1,p2)/(np.linalg.norm(p1)*(np.linalg.norm(p2)))\n    r =  np.sqrt(sum([i ** 2 for i in p1]))\n    return r * cosine\n\n\n# In[7]:\n\n\ndef findTopK(playerList, K, player, sort_type):\n    playerList.append(player)\n    playerList.sort(key=lambda p: sort_type * p[1])\n    if(len(playerList) > K):\n        return playerList[:K]\n    return playerList\n\n\ndef mergeTopK(pList1, pList2, K, sort_type):\n    result = pList1 + pList2\n    result.sort(key=lambda p:sort_type*p[1])\n    if(len(result) > K):\n        return result[:K]\n    return result\n\n\n# In[22]:\n\n\ndef findSimilarPlayer(df, name, topK):\n    \'\'\'\n    given dataset and target player name\n    return top K most similar players data frame of target player\n    \'\'\'\n    player_df = df.select([""ID""] + df.columns[44:73]).where(df.Name == name)\n    if player_df == None:\n        raise NameError(""No Player Found!"")\n    playerInfo = player_df.rdd.map(list)        .map(lambda l:(l[0], [int(l[i]) for i in range(1, len(l))])).collect()[0]\n    (playerId, playerList) = playerInfo[0], playerInfo[1]\n    mat = df.select([""ID""] + df.columns[44:73]).rdd.map(list)        .map(lambda l:(l[0], [int(l[i]) for i in range(1, len(l))]))        .filter(lambda kv: kv[0] != playerId)        .mapValues(lambda l: playerSimilarity(l, playerList))\n\n    res = mat.aggregate([], lambda inp1, inp2: findTopK(inp1, topK, inp2, -1), lambda inp1, inp2: mergeTopK(inp1, inp2, topK, -1))\n    res = [id for id, score in res]\n    id_df = sqlContext.createDataFrame(res, StringType()).toDF(""ID"")\n    res = df.join(id_df, ""ID"", ""inner"").select(""Name"", ""Age"", ""Nationality"", ""Club"", ""Height(cm)"", ""Weight(lbs)"")\n    return res\n    \ntime1 = time.time()\nfindSimilarPlayer(player_df, ""L. Messi"", 10)\nrun_time = time.time() - time1\nprint(""run time: "" + str(run_time))\n    \n\n\n# In[17]:\n\n\ndef findBestReplicate(teamName, playerId, df, topK, weightVector):\n    \'\'\'\n    return list of [(player_id, replace_id, improve score)]\n    \'\'\'\n    player_info = df.select(df.columns[44:73]).where(df.ID == playerId).rdd.map(list)            .map(lambda l: [float(i) for i in l]).collect()[0] # list\n    candidatePlayers = df.select([""ID""] + df.columns[44:73]).where(df.Club != teamName).rdd.map(list)        .map(lambda l:(l[0], [float(l[i]) for i in range(1, len(l))]))        .mapValues(lambda vals: improve(vals, player_info, weightVector)) # rdd\n    res = candidatePlayers.aggregate([], lambda inp1, inp2: findTopK(inp1, topK, inp2, -1), lambda inp1, inp2: mergeTopK(inp1, inp2, topK, -1))\n    res = [(playerId, id, score) for id, score in res]\n    return res\n\ndef improve(l1, l2, weight):\n    improve = 0\n    for i in range(len(l1)):\n        improve += (l1[i] - l2[i]) * weight[i]\n    return improve\n\n\n# In[21]:\n\n\ndef featureThreshold(l):\n    temp = sorted(l)\n    return temp[int(len(l) / 4)]\n\n\ndef findWorstFeatures(teamName, team_df):\n    \'\'\'\n    take the team name and team dataframe and return list of index of weak features start from 0 = Crossing\n    \'\'\'\n    targ_df = team_df.select(\'*\').where(team_df.Club == teamName).rdd.map(list)            .map(lambda l: (l[0], [float(l[i]) for i in range(1, len(l))]))            .mapValues(lambda l: (featureThreshold(l), l))            .mapValues(lambda tup: [index for index, val in enumerate(tup[1]) if val < tup[0]])\n    feature_indexes = targ_df.collect()[0][1]\n    return feature_indexes\n    \n    \ndef createWeightVector(feature_indexes):\n    \'\'\'\n    take list of weak features and return weight list of size 29\n    \'\'\'\n    norm = float(10 / (29 + len(feature_indexes)))\n    weightVector = [2.0 * norm if index in feature_indexes else norm for index in range(29)]\n    return weightVector\n     \n    \ndef findWorstPlayers(teamName, player_df, feature_indexes):\n    \'\'\'\n    take team name, player dataframe, weak features index list\n    return list of worst players id\n    \'\'\'\n    worst_players = player_df.select([""ID""] + player_df.columns[44:73]).where(player_df.Club == teamName).rdd.map(list)            .map(lambda l: (l[0], [float(i) for i in l[1:]]))            .mapValues(lambda l: [l[i] for i in range(len(l)) if i in feature_indexes])            .mapValues(lambda l: sum(l)).collect()\n    worst_players.sort(key = lambda t: t[1], reverse=True)\n    return [id for id, index in worst_players][:10]\n\n\n    \ndef replaceModeRecommendation(player_df, team_df, teamName, topK):\n    feature_indexes = findWorstFeatures(teamName, team_df)\n#     print([team_df.columns[i + 1] for i in feature_indexes])\n    weight_vector = createWeightVector(feature_indexes)\n#     print(weight_vector)\n    worst_players = findWorstPlayers(teamName, player_df, feature_indexes)\n    res = []\n    for player_id in worst_players:\n        res += findBestReplicate(teamName, player_id, player_df, topK, weight_vector)\n    res.sort(key = lambda l: l[2], reverse=True)\n    return res[:topK]\n    \n\n\ndef printPlayerInfo(player_df, playerId):\n    player_info = player_df.select(""ID"", \'Name\', ""Age"", ""Nationality"", ""Overall"", ""Club"", ""Position"")            .where(player_df.ID == playerId).show()\n\n\n\n# team_name = \'FC Barcelona\'\ntime1 = time.time()\nteam_name = \'LA Galaxy\'\nres = replaceModeRecommendation(player_df, team_df, team_name, 3)\nprint(""run time: "" + str(time.time() - time1))\n# for i in res:\n#     print(""player:"" + i[0] +"" replacement:"" + i[1] + "" improvement:"" + str(i[2]))\n\n\n# In[ ]:\n\n\n\n\n\n# In[ ]:\n\n\n\n\n'"
read_csv.py,6,"b'#!/usr/bin/env python\n# coding: utf-8\n\n# In[2]:\n\n\nfrom collections import defaultdict\nimport csv\nimport numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# ## read data to numpy(not in use)\n\n# In[385]:\n\n\n# def readCsvToNumpy(file_name, feat_num):\n#     util_mat = []\n#     with open(file_name, newline=\'\', encoding=\'utf-8\') as csvfile:\n#         next(csvfile, None)\n#         rd = csv.reader(csvfile, delimiter=\' \', quotechar=\'|\')\n#         for idx, row in enumerate(rd):\n#             row = (\' \'.join(row))\n#             row = row.split(\',\')\n#             if len(row) == feat_num:\n#                 util_mat.append(row)\n                \n#     # convert 2d list to 2d numpy array\n#     for idx, row in enumerate(util_mat):\n#         util_mat[idx] = np.asarray(row)\n#     util_mat = np.asarray(util_mat)\n    \n#     return util_mat\n\n\n# def getPlayerMatrix(util_mat, left_idx, right_idx):\n#     player_mat = util_mat[:, left_idx:right_idx]\n#     player_mat = player_mat.astype(int)\n#     return player_mat\n    \n    \n\n# def getTeamMatrix(util_mat, player_mat, team_idx):\n#     hashmap = defaultdict(list)\n#     for idx, item in enumerate(util_mat):\n#         hashmap[util_mat[idx, team_idx]].append(player_mat[idx, :])\n\n#     team_mat = []\n# #     print(\'Team number\', len(hashmap))\n#     for key, value in hashmap.items():\n#         team_avr = [sum(x)/len(value) for x in zip(*value)]\n#         team_mat.append(team_avr)\n#     #     team_mat.append((key, temp))\n# #     for idx, item in enumerate(team_mat):\n# #         if item[0] == \'Arsenal\':\n# #             print(idx, item)\n\n#     # convert team feature matrix to numpy matrix\n#     for idx, row in enumerate(team_mat):\n#         team_mat[idx] = np.asarray(row, dtype=int)\n#     team_mat = np.asarray(team_mat, dtype=int);\n    \n#     return team_mat\n    \n\n\n    \n# if __name__ == ""__main__"":\n#     util_mat = readCsvToNumpy(\'data_clean.csv\', 74)\n#     # print(util_mat.shape, util_mat)\n#     player_mat = getPlayerMatrix(util_mat, 44, 73)\n#     # print(player_mat.shape, player_mat)\n#     team_mat = getTeamMatrix(util_mat, player_mat, 6)\n\n# #     print(team_mat[0, :])\n\n#     res = np.dot(player_mat, np.transpose(team_mat))\n# #     # print(hashmap[\'FC Barcelona\'])\n\n# #     print(res[0,:])\n\n\n# ## read data to pandas Data frame\n\n# In[3]:\n\n\n\nutil_df = pd.read_csv(\'data_clean.csv\', na_filter=False)\n# print(util_df)\nplayer_df = util_df.iloc[:, 44:73]\n# print(player_df)\nteam_df = util_df.groupby(\'Club\', sort=False).mean()\n# print(team_df)\nteam_df = team_df.iloc[:, 37:66]\n# print(team_df)\n\nres = np.dot(player_df, np.transpose(team_df))\n\n\n# In[ ]:\n\n\nutil_df.iloc[:,1]\n\n\n# In[54]:\n\n\n\n# util_df.describe()\nplayer_characteristics = [\'Crossing\',\'Finishing\', \'HeadingAccuracy\', \n                          \'ShortPassing\', \'Volleys\', \'Dribbling\', \'Curve\',\n                          \'FKAccuracy\', \'LongPassing\', \'BallControl\', \n                          \'Acceleration\', \'SprintSpeed\', \'Agility\', \'Reactions\', \n                          \'Balance\', \'ShotPower\', \'Jumping\', \'Stamina\', \n                          \'Strength\', \'LongShots\', \'Aggression\',\n                          \'Interceptions\', \'Positioning\', \'Vision\', \n                          \'Penalties\', \'Composure\', \'Marking\', \'StandingTackle\', \n                          \'SlidingTackle\']\n\nplt.figure(figsize= (25, 16))\n\n\nhm=sns.heatmap(util_df.loc[:, player_characteristics + [\'Overall\']].corr(), annot = True, linewidths=.5, cmap=\'Reds\')\nhm.set_title(label=\'Heatmap of dataset\', fontsize=20)\nhm;\n\n# corr_matrix = util_df.corr()\n# corr_matrix.loc[player_characteristics, \'LB\'].sort_values(ascending=False).head()\n\n'"
recommendation-system.py,0,"b'#!/usr/bin/env python\n# coding: utf-8\n\n# In[41]:\n\n\nfrom pyspark import SparkContext\nfrom pyspark.sql import SQLContext\nfrom pyspark.sql import SparkSession\nfrom pyspark.sql.types import *\nfrom pyspark.sql.functions import udf\nfrom pyspark.ml.stat import Correlation\nfrom pyspark.ml.linalg import Vectors\nimport numpy as np\nimport pandas as pd\nfrom collections import Counter\nimport re\nimport time\nfrom pathos.pools import ProcessPool as Pool\n\nnum_partitions = 10\nnum_cores = 2\n\nspark = SparkSession.builder.appName(\'FootballManager\').getOrCreate()\n\n\n# In[42]:\n\n\ndef readCSV(path):\n    return spark.read.format(""csv"").options(header=""true"", inferSchema=""true"")    .load(path)\n\nteams_df = readCSV(""./team_feat.csv"")\nplayers_df = readCSV(""./data_clean.csv"")\n_teams_df = pd.read_csv(\'./team_feat.csv\')\n_players_df = pd.read_csv(\'./data_clean.csv\')\n\n\n# In[43]:\n\n\ndef single_workflow(features):\n    def foo(teams_df, input):\n        """"""\n        Get 3 features-teams matrixs , transfer the features\' score into weights(use Reciprocal Function) and thus we have 3 weighted-teams matrixs.\n\n        :param: input, a dic of features vectors\n        :return a tuple of weighted-teams matrixs\n        """"""\n        features = input\n\n        teams_columns = dict(zip(range(0,teams_df[\'Club\'].size), teams_df[\'Club\']))\n\n        features_teams = teams_df.loc[:, features].T\n        features_teams = features_teams.rename(columns=teams_columns)\n\n        weights_teams = features_teams.applymap(lambda x: 1./float(x))\n\n        return weights_teams\n\n    def getPlayersTeamsMatrix_parallel(players_df, teams_df, input):\n        """"""\n        Create three sections, each section has a m*n and n*k matrix,\n        where m is the number of players, n is the number of features\' weights,\n        and k is the number of teams. For all these three pairs of matrices,\n        do the matrix multiplication. Then we can get 3 MxK matrices for DEF, MID and ATK positions.\n\n        :params: input, a dict \n        : return: a tuple of three players_teams matrixs\n        """"""\n\n        features = input[\'features\']\n        weights_teams = input[\'weights_teams\']\n\n        players_rows = dict(zip(range(0, players_df[\'Name\'].size), players_df[\'Name\']))\n\n        # DEF\n        players_features = players_df.loc[:, features]\n        players_features = players_features.rename(index=players_rows)\n        players_teams = players_features.dot(weights_teams)\n\n        return players_teams\n\n    weights_teams = foo(\n      _teams_df,\n      features\n    )\n    players_teams = getPlayersTeamsMatrix_parallel(\n      _players_df,\n      _teams_df,\n      {\n          \'features\': features,\n          \'weights_teams\': weights_teams\n      }\n    )\n    return players_teams\n\n\n# In[44]:\n\n\nclass RecommendationEngine(object):\n    def __init__(self, players_df, teams_df, _players_df, _teams_df):\n        self.players_df = players_df\n        self.teams_df = teams_df\n        self._teams_df = _teams_df\n        self._players_df = _players_df\n        self.result = {}\n    \n    def readCSVToSparksql(self, path):\n        return spark.read.format(""csv"").options(header=""true"", inferSchema=""true"")            .load(path)\n\n    def __convertDFtoRDD(self, df):\n        rdd = df.rdd\n        return rdd\n    \n#     def __groupPosition(self, players_df):\n#         """"""\n#         Function to group the players\' positions into three main groups: DEF, MID, FWD\n        \n#         :param: players_df\n#         :return: Dataframe\n#         """"""\n        \n#         def _classify(position):\n#             """"""\n#             Classify Position\n            \n#             :param: position\n#             :return: string\n#             """"""\n#             # Regex to group\n#             defs = r\'\\w*B$\'\n#             mids = r\'\\w*M$\'\n#             fwds = r\'\\w*[FSTW]$\'\n            \n#             if re.match(defs, position):\n#                 return ""DEF""\n#             elif re.match(mids, position):\n#                 return ""MID""\n#             elif re.match(fwds, position):\n#                 return ""FWD""\n#             else:\n#                 return None\n        \n#         # Write an UDF for withColumn\n#         _classify_udf = udf(_classify, StringType())\n        \n#         # groupPosition list\n#         return players_df\\\n#           .withColumn(\'GroupPosition\', _classify_udf(players_df[\'Position\']))\n\n    def __groupPosition(self, players_df):\n        # Regex to group\n        defs = r\'\\w*B$\'\n        mids = r\'\\w*M$\'\n        fwds = r\'\\w*[FSTW]$\'\n\n        # groupPosition list\n        groupPositions = []\n        for index, row in players_df.iterrows():\n            position = row[\'Position\']\n            if re.match(defs, position):\n                groupPositions.append(\'DEF\')\n            if re.match(mids, position):\n                groupPositions.append(\'MID\')\n            if re.match(fwds, position):\n                groupPositions.append(\'FWD\')\n        series = pd.Series(groupPositions)\n        players_df[\'GroupPosition\'] = series\n        return players_df\n        \n    def __findTopRelatedPosition(self, players_df):\n        """"""\n        Calculate the Pearson Correlation between each specific position,\n        and specific featuresFind out top characteristics for different position\n        \n        :param: players_df, Pandas Dataframe\n        :return: \n        """"""\n        player_characteristics = [\'Crossing\',\'Finishing\', \'HeadingAccuracy\', \n                                  \'ShortPassing\', \'Volleys\', \'Dribbling\', \'Curve\',\n                                  \'FKAccuracy\', \'LongPassing\', \'BallControl\', \n                                  \'Acceleration\', \'SprintSpeed\', \'Agility\', \'Reactions\', \n                                  \'Balance\', \'ShotPower\', \'Jumping\', \'Stamina\', \n                                  \'Strength\', \'LongShots\', \'Aggression\',\n                                  \'Interceptions\', \'Positioning\', \'Vision\', \n                                  \'Penalties\', \'Composure\', \'Marking\', \'StandingTackle\', \n                                  \'SlidingTackle\']\n\n        ## Top characteristics for  positions\n        corr_matrix = players_df.corr() # default is pearson\n        counter_DEF = Counter()\n        counter_MID = Counter()\n        counter_ATK = Counter()\n        defs = r\'\\w*B$\'\n        mids = r\'\\w*M$\'\n        fwds = r\'\\w*[FSTW]$\'\n        for index, row in corr_matrix.loc[player_characteristics, ""LS"":""RB""].T.iterrows():\n\n            largests = tuple(row.nlargest(12).index)\n        #     print(\'Position {}: {}, {}, {}, {}, {}, {}, {}, {}\'.format(index, *tuple(row.nlargest(8).index)))\n\n            if re.match(defs, index): # DEF\n                for feature in largests:\n                    counter_DEF[feature] += 1\n            if re.match(mids, index): # MID\n                for feature in largests:\n                    counter_MID[feature] += 1\n            if re.match(fwds, index): # FWD\n                for feature in largests:\n                    counter_ATK[feature] += 1\n\n        # 3. Group all positions together into only three, ATK, MID and DEF, thus we get the three 1 * 8 vector for three main groups.\n        features_DEF = [kv[0] for kv in counter_DEF.most_common(12)]\n        features_MID = [kv[0] for kv in counter_MID.most_common(12)]\n        features_ATK = [kv[0] for kv in counter_ATK.most_common(12)]\n        \n        return features_DEF, features_MID, features_ATK\n    \n    def _getWeightedMatrix(self, teams_df, input):\n        """"""\n        Get 3 features-teams matrixs , transfer the features\' score into weights(use Reciprocal Function) and thus we have 3 weighted-teams matrixs.\n        \n        :param: input, a dic of features vectors\n        :return a tuple of weighted-teams matrixs\n        """"""\n        features_DEF = input[\'features_DEF\']\n        features_MID = input[\'features_MID\']\n        features_ATK = input[\'features_ATK\']\n                \n        teams_columns = dict(zip(range(0,teams_df[\'Club\'].size), teams_df[\'Club\']))\n\n        features_teams_DEF = teams_df.loc[:, features_DEF].T\n        features_teams_DEF = features_teams_DEF.rename(columns=teams_columns)\n        features_teams_MID = teams_df.loc[:, features_MID].T\n        features_teams_MID = features_teams_MID.rename(columns=teams_columns)\n        features_teams_ATK = teams_df.loc[:, features_ATK].T\n        features_teams_ATK = features_teams_ATK.rename(columns=teams_columns)\n        \n        weights_teams_DEF = features_teams_DEF.applymap(lambda x: 1./float(x))\n        weights_teams_MID = features_teams_MID.applymap(lambda x: 1./float(x))\n        weights_teams_ATK = features_teams_ATK.applymap(lambda x: 1./float(x))\n        \n        return weights_teams_DEF, weights_teams_MID, weights_teams_ATK\n        \n    def _getPlayersTeamsMatrix(self, players_df, teams_df, input):\n        """"""\n        Create three sections, each section has a m*n and n*k matrix,\n        where m is the number of players, n is the number of features\' weights,\n        and k is the number of teams. For all these three pairs of matrices,\n        do the matrix multiplication. Then we can get 3 MxK matrices for DEF, MID and ATK positions.\n        \n        :params: input, a dict \n        : return: a tuple of three players_teams matrixs\n        """"""\n        \n        features_DEF = input[\'features_DEF\']\n        features_MID = input[\'features_MID\']\n        features_ATK = input[\'features_ATK\']\n        weights_teams_DEF = input[\'weights_teams_DEF\']\n        weights_teams_MID = input[\'weights_teams_MID\']\n        weights_teams_ATK = input[\'weights_teams_ATK\']\n        \n        players_rows = dict(zip(range(0, players_df[\'Name\'].size), players_df[\'Name\']))\n\n        # DEF\n        players_features_DEF = players_df.loc[:, features_DEF]\n        players_features_DEF = players_features_DEF.rename(index=players_rows)\n        players_teams_DEF = players_features_DEF.dot(weights_teams_DEF)\n\n        # MID\n        players_features_MID = players_df.loc[:, features_MID]\n        players_features_MID = players_features_MID.rename(index=players_rows)\n        players_teams_MID = players_features_MID.dot(weights_teams_MID)\n\n        # ATK\n        players_features_ATK = players_df.loc[:, features_ATK]\n        players_features_ATK = players_features_ATK.rename(index=players_rows)\n        players_teams_ATK = players_features_ATK.dot(weights_teams_ATK)\n        \n        return players_teams_DEF, players_teams_MID, players_teams_ATK\n\n    def _run(self):\n        """"""\n        Run the recommendation engine\n        \n        :return: a tuple of three players_teams matrixs\n        """"""\n        start=time.time()\n        self._players_df = self.__groupPosition(self._players_df)\n        features_DEF, features_MID, features_ATK = self.__findTopRelatedPosition(self._players_df)\n        weights_teams_DEF, weights_teams_MID, weights_teams_ATK = self._getWeightedMatrix(\n            self._teams_df,\n            {\'features_DEF\': features_DEF,\n             \'features_MID\': features_MID,\n             \'features_ATK\': features_ATK\n            }\n        )\n        players_teams_DEF, players_teams_MID, players_teams_ATK = self._getPlayersTeamsMatrix(\n            self._players_df,\n            self._teams_df,\n            {\'features_DEF\': features_DEF,\n             \'features_MID\': features_MID,\n             \'features_ATK\': features_ATK,\n             \'weights_teams_DEF\': weights_teams_DEF,\n             \'weights_teams_MID\': weights_teams_MID,\n             \'weights_teams_ATK\': weights_teams_ATK\n            }\n        )\n        end=time.time()\n        print(""The recommendation running time is: {:.2f} seconds in Serial Mode"".format(end-start))\n        return players_teams_DEF, players_teams_MID, players_teams_ATK\n    \n    def _run_parallel(self):\n        """"""\n        Run the recommendation engine\n        \n        :return: a tuple of three players_teams matrixs\n        """"""\n        \n        start=time.time()\n        with Pool(num_cores) as pool:\n            self._players_df = self.__groupPosition(self._players_df)\n            features_array = list(self.__findTopRelatedPosition(self._players_df))\n            players_teams_array = pool.map(single_workflow, features_array)\n            pool.close()\n            pool.join()\n        end=time.time()\n        \n        print(""The recommendation running time is: {:.2f} seconds in Parallel mode"".format(end-start))\n        players_teams_DEF = players_teams_array[0]\n        players_teams_MID = players_teams_array[1]\n        players_teams_ATK = players_teams_array[2]\n        return players_teams_DEF, players_teams_MID, players_teams_ATK\n    \n    def getRecommendation(self, mode=1):\n        """"""\n        Get the recommendation result, use lazy load mode\n        \n        :param: mode, 0 means serial, 1 means parallel, defualt is 0\n        :return: a tuple of three players_teams matrixs\n        """"""\n        if len(self.result) == 0:\n            if mode == 1:\n                players_teams_DEF, players_teams_MID, players_teams_ATK = self._run_parallel()\n            else:\n                players_teams_DEF, players_teams_MID, players_teams_ATK = self._run()\n            self.result[\'players_teams_DEF\'] = players_teams_DEF\n            self.result[\'players_teams_MID\'] = players_teams_MID\n            self.result[\'players_teams_ATK\'] = players_teams_ATK\n        return self.result\n\nclass RecommendationSystem(object):\n    def __init__(self, recommendation_engine, players_df, teams_df, _players_df, _teams_df):\n        self.players_df = players_df\n        self.teams_df = teams_df\n        self._teams_df = _teams_df\n        self._players_df = _players_df\n        self._recommendation_engine = recommendation_engine\n        self.players_teams_matrixs = self._recommendation_engine.getRecommendation()\n    \n    def getMVPForTeam(self, team, position, K, isReverse=False):\n        """"""\n        To recommend K Most Valued People in specific position for specific team if ascending is False,\n        otherwise show Worst Valued People if ascending is True\n        \n        :param: team\n        :param: position\n        :param: K\n        :param: isReverse, default False\n        :return: players -> List[]\n        """"""\n        if position == \'DEF\':\n            players = self.players_teams_matrixs[\'players_teams_DEF\'][team]                       .sort_values(ascending=isReverse)                       .head(K)\n            return players\n        elif position == \'MID\':\n            players = self.players_teams_matrixs[\'players_teams_MID\'][team]                       .sort_values(ascending=isReverse)                       .head(K)\n            return players\n        elif position == \'ATK\':\n            players = self.players_teams_matrixs[\'players_teams_ATK\'][team]                       .sort_values(ascending=isReverse)                       .head(K)\n            return players\n        else:\n            raise RuntimeError(\'Invalid position argument\')\n    \n    def getMVTForPlayer(self, player, position, K, isReverse=False):\n        """"""\n        To recommend Most Valued Teams in specific position for specific palyer if ascending is False,\n        otherwise show Worst Valued Teams if ascending is True\n        \n        :param: player\n        :param: position\n        :param: K\n        :param: isReverse, default False\n        :return: teams -> List[]\n        """"""\n        if position == \'DEF\':\n            teams = self.players_teams_matrixs[\'players_teams_DEF\']                       .loc[player, :]                       .sort_values(ascending=isReverse)                       .head(K)\n            return teams\n        elif position == \'MID\':\n            teams = self.players_teams_matrixs[\'players_teams_MID\']                       .loc[player, :]                       .sort_values(ascending=isReverse)                       .head(K)\n            return teams\n        elif position == \'ATK\':\n            teams = self.players_teams_matrixs[\'players_teams_ATK\']                       .loc[player, :]                       .sort_values(ascending=isReverse)                       .head(K)\n            return teams\n        else:\n            raise RuntimeError(\'Invalid position argument\')\n    \n    def searchWorstPlayersInPosByTeam(self, position, team):\n        """"""\n        To find out the Least Valued Players in specific position for specific team,\n        thus in the future we can replace them with better players.\n        \n        :params: position\n        :params: team\n        :return:\n        """"""\n        players_df = self._players_df\n        players_teams_matrix = None\n        if position == \'DEF\':\n            players_teams_matrix = self.players_teams_matrixs[\'players_teams_DEF\']\n        elif position == \'MID\':\n            players_teams_matrix = self.players_teams_matrixs[\'players_teams_MID\']\n        elif position == \'ATK\':\n            players_teams_matrix = self.players_teams_matrixs[\'players_teams_ATK\']\n        else:\n            raise RuntimeError(\'Invalid position argument\')\n        for index, value in players_teams_matrix[team].sort_values(ascending=True).iteritems():\n            if players_df.loc[(players_df.loc[:, \'Name\'] == index), :][\'Club\'].values[0] == team and players_df.loc[(players_df.loc[:, \'Name\'] == index), :][\'GroupPosition\'].values[0] == position:\n                print(""{}\\t\\t{}"".format(index, value))\n        \nclass FootballManager(object):\n    def __init__(self, recommendation_system):\n        self.players_df = self.readCSVToSparksql(""./data_clean.csv"")\n        self.teams_df = self.readCSVToSparksql(""./team_feat.csv"")\n        self._teams_df = pd.read_csv(\'./team_feat.csv\')\n        self._players_df = pd.read_csv(\'./data_clean.csv\')\n        self.recommendation_system = recommendation_system\n    \n    def readCSVToSparksql(self, path):\n        return spark.read.format(""csv"").options(header=""true"", inferSchema=""true"")            .load(path)\n\n    def matrix_weighted_recommandation(self, input_player=None, input_team=None):\n        if input_player is None and input_team is None:\n            raise RuntimeError(\'No player or team is found, please at least offer one argument\')\n        \n\n\n# In[45]:\n\n\nrecommendation_engine = RecommendationEngine(players_df, teams_df, _players_df, _teams_df)\n\n\n# In[46]:\n\n\nrecommendationSystem = RecommendationSystem(recommendation_engine, players_df, teams_df, _players_df, _teams_df)\n\n\n# In[47]:\n\n\nplayers = recommendationSystem.getMVPForTeam(\'LA Galaxy\', \'DEF\', 10)\nprint(players)\nteams = recommendationSystem.getMVTForPlayer(\'L. Messi\', \'DEF\', 10)\nprint(teams)\nrecommendationSystem.searchWorstPlayersInPosByTeam(\'DEF\', \'LA Galaxy\')\n\n\n# In[ ]:\n\n\n\n\n'"
