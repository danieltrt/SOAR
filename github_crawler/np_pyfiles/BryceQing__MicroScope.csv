file_path,api_count,code
Joint.py,2,"b""import cv2\nimport glob\nimport numpy as np\n\n\nclass Joint:\n    def __init__(self, input_path, output_path):\n        \n        imgFiles = glob.glob(input_path)\n        dicImage = {}\n        row, col = 0, 0\n        \n        for imgFile in imgFiles:\n            fileName = imgFile.replace('.jpg', '')\n            x, y = self.getPos(fileName[fileName.rfind('\\\\') + 1:])\n            row, col = max(row, y), max(col, x)\n            img = cv2.imread(imgFile)\n            dicImage[(x, y)] = img\n        \n        self.Merge(dicImage, row, col, output_path)\n            \n    \n\n    \n    def getPos(self, fileName):\n        x, y = fileName.split('x')\n        return map(int, (x, y))\n    \n    def Merge(self, dicImage, row, col, output_path):\n        \n        resImg = None\n        dicCol = {}\n        for i in range(col + 1):\n            tempImg = None\n            for j in range(row + 1):\n                if tempImg is not None:\n                    tempImg = np.vstack([tempImg, dicImage[i, j]])\n                else:\n                    tempImg = dicImage[(i, j)]\n                dicCol[i] = tempImg\n            \n        for i in range(len(dicCol)):\n            if resImg is not None:\n                resImg = np.hstack([resImg, dicCol[i]])\n            else:\n                resImg = dicCol[i]\n\n        cv2.imwrite(output_path, resImg)\n        \nif __name__ == '__main__':\n    category = 'SpinalCord'\n    input_path = 'Specimens/'+ category + '/' + '*.jpg'\n    output_path = 'JointPhoto/' + category + '.jpg'\n    joint = Joint(input_path, output_path)\n    \n\n\n\n\n\n    \n    # processImg = cv2.resize(img, (newImgH, newImgW), interpolation = cv2.INTER_AREA)\n    # cv2.imwrite('SpecimensProcessed/' + fileName, processImg )\n        """
MicroScope.py,3,"b'import cv2\nimport cv2.aruco as aruco\nimport numpy as np\nimport glob\nimport sys\n\n__author__ =  \'Qing Bryce\'\n__version__ = \'0.1 beta\'\n\n\n\nclass MicroScope:\n\n    def __init__(self, micro_w, micro_h, micro_posX, micro_posY, dic_specimen_id ):\n        """"""[Init the microscope \xe5\x88\x9d\xe5\xa7\x8b\xe5\x8c\x96\xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe5\xaf\xb9\xe8\xb1\xa1]\n        \n        Arguments:\n            micro_w {[Number]} -- [The width of microscope \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3\xe5\xae\xbd\xe5\xba\xa6]\n            micro_h {[Number]} -- [The height of microsocpe \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3\xe9\xab\x98\xe5\xba\xa6]\n            micro_posX {[Number]} -- [The x postion of microscope \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3x\xe5\x9d\x90\xe6\xa0\x87]\n            micro_posY {[Number]} -- [The y position of microscope \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3y\xe5\x9d\x90\xe6\xa0\x87]\n            dic_specimen_id {[dict]} -- [The key-value : id: specimen \xe9\x94\xae\xe5\x80\xbc\xe5\xaf\xb9: \xe5\x9b\xbe\xe7\x89\x87id\xe5\x92\x8c\xe6\xa0\x87\xe6\x9c\xac\xe8\xb7\xaf\xe5\xbe\x84]\n        \n        """""" \n        \n        # Init opencv configuration \xe9\x85\x8d\xe7\xbd\xaeopencv\xe7\x9b\xb8\xe5\x85\xb3\xe4\xbf\xa1\xe6\x81\xaf\n        self.cap = cv2.VideoCapture(0)\n        \n        # Detect the id and show the correspongding specimen photo \xe6\xa3\x80\xe6\xb5\x8bmark id\xe5\xb9\xb6\xe6\x98\xbe\xe7\xa4\xba\xe5\xaf\xb9\xe5\xba\x94\xe6\xa0\x87\xe6\x9c\xac\xe5\x9b\xbe\xe7\x89\x87\n        self.dic_specimen_id = dic_specimen_id\n                \n        # The size of viewport of microscope. \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3\xe5\xa4\xa7\xe5\xb0\x8f\n        self.microscope_w, self.microscope_h = micro_w, micro_h\n        # Setting the name of window \xe8\xae\xbe\xe7\xbd\xae\xe7\xaa\x97\xe5\x8f\xa3\xe5\x90\x8d\xe7\xa7\xb0\n        cv2.namedWindow(\'MicroScope\', cv2.WINDOW_NORMAL)\n        # Setting the window size \xe8\xae\xbe\xe7\xbd\xae\xe7\xaa\x97\xe5\x8f\xa3\xe5\xa4\xa7\xe5\xb0\x8f\n        cv2.resizeWindow(\'MicroScope\', self.microscope_w, self.microscope_h)\n        # Setting the window position \xe8\xae\xbe\xe7\xbd\xae\xe7\xaa\x97\xe5\x8f\xa3\xe4\xbd\x8d\xe7\xbd\xae\n        cv2.moveWindow(\'MicroScope\', micro_posX, micro_posY)\n        \n        \n        # self.initViewPort()\n        \n    \n    def loadImage(self, specimen_id):\n        """"""[Load the speciment \xe5\x8a\xa0\xe8\xbd\xbd\xe6\xa0\x87\xe6\x9c\xac]\n        \n        Arguments:\n            specimen_id {[Number]} -- [Specimen id]\n        """"""\n        \n        self.originImg = cv2.imread(self.dic_specimen_id[specimen_id])\n        self.specimen_id = specimen_id\n        self.imgHeight, self.imgWidth = self.originImg.shape[:2]\n        self.initViewPort()\n        \n    \n    \n    def initViewPort(self):\n        """"""[Init microscope viewport configuration \xe9\x85\x8d\xe7\xbd\xae\xe6\x98\xbe\xe7\xa4\xba\xe8\xa7\x86\xe5\x8f\xa3\xe7\x9b\xb8\xe5\x85\xb3\xe4\xbf\xa1\xe6\x81\xaf]\n        """"""\n        # self.imgTopX, self.imgTopY = 0, 0  # Original image top-left position. \xe5\x8e\x9f\xe5\xa7\x8b\xe5\x9b\xbe\xe7\x89\x87\xe5\xb7\xa6\xe4\xb8\x8a\xe8\xa7\x92\xe5\x9d\x90\xe6\xa0\x87\n        # self.imgBottomX, self.imgBottomY = self.imgWidth, self.imgHeight # Original image bottom-right position. \xe5\x8e\x9f\xe5\xa7\x8b\xe5\x9b\xbe\xe7\x89\x87\xe5\x8f\xb3\xe4\xb8\x8b\xe8\xa7\x92\xe5\x9d\x90\xe6\xa0\x87\n        self.viewTopX, self.viewTopY, self.viewBottomX, self.viewBottomY = None, None, None, None\n        self.viewWidth, self.viewHeight = None, None  # Now viewport size. \xe5\xbd\x93\xe5\x89\x8d\xe8\xa7\x86\xe5\x8f\xa3\xe5\xa4\xa7\xe5\xb0\x8f\n\n        if self.imgWidth > self.imgHeight:\n            img_viewport_scale = self.microscope_w / self.imgWidth\n            self.viewTopX, self.viewTopY = 0, (self.microscope_h - int(self.imgHeight * img_viewport_scale)) // 2\n            self.viewBottomX, self.viewBottomY = self.microscope_w, ( self.microscope_h + int(self.imgHeight * img_viewport_scale)) // 2\n            self.viewWidth, self.viewHeight = self.microscope_w // 2, self.imgHeight * (self.microscope_w // 2) / self.imgWidth\n        else:\n            img_viewport_scale = self.microscope_h / self.imgHeight\n            self.viewTopX, self.viewTopY = (self.microscope_w - int(self.imgWidth * img_viewport_scale)) // 2, 0\n            self.viewBottomX, self.viewBottomY = ( self.microscope_w + int(self.imgWidth * img_viewport_scale)) // 2, self.microscope_h\n            self.viewWidth, self.viewHeight = self.imgWidth *  (self.microscope_h // 2) / self.imgHeight, self.microscope_h // 2\n\n\n        self.result_img = np.zeros((self.microscope_w, self.microscope_h, 3), np.uint8) + 255\n        self.update, self.First = False, True\n        self.nowScale = 0\n\n    def FindMark(self, img, marktype = aruco.DICT_6X6_250):\n        \n        """"""[Find mark corners]\n\n        Arguments:\n            img {[numpy.array]} -- [The input image \xe6\x91\x84\xe5\x83\x8f\xe5\xa4\xb4\xe8\xbe\x93\xe5\x85\xa5\xe5\x9b\xbe\xe5\x83\x8f]\n            marktype {[any]} -- [The dict of aurco mark Aruco mark\xe7\x9a\x84\xe5\xad\x97\xe5\x85\xb8\xe5\x8f\x82\xe6\x95\xb0]\n        Returns:\n            (centerX, centerY) {[tuple]} --[The center position of mark \xe6\xa0\x87\xe8\xae\xb0mark\xe4\xb8\xad\xe5\xbf\x83\xe4\xbd\x8d\xe7\xbd\xae]\n            markId {[Number]} --[id of mark \xe6\xa0\x87\xe8\xae\xb0Mark\xe7\x9a\x84id]\n            isFind {[Boolean]} --[Wheather find the mark \xe6\x98\xaf\xe5\x90\xa6\xe6\x89\xbe\xe5\x88\xb0mark]\n\n        """"""\n\n        aruco_dict = aruco.Dictionary_get(marktype)\n        parameters = aruco.DetectorParameters_create()\n        parameters.adaptiveThreshConstant = True\n\n        \n        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)\n        corners, ids, rejectedImgPoints = aruco.detectMarkers(gray, aruco_dict, parameters = parameters)\n        centerX, centerY, markId, isFind = None, None, None, False\n        if ids is not None and corners is not None:\n            ids = ids.flatten()\n            for i in range(len(ids)):\n                if ids[i] in self.dic_specimen_id:\n                    aruco.drawDetectedMarkers(img, corners)\n                    centerX = int(corners[i][0][0][0] + corners[i][0][1][0] + corners[i][0][3][0] + corners[i][0][2][0]) / 4\n                    centerY = int(corners[i][0][0][1] + corners[i][0][1][1] + corners[i][0][3][1] + corners[i][0][2][1]) / 4\n                    markId, isFind = ids[i], True\n        cv2.imshow(\'Find mark image:\', img)\n        return (centerX, centerY), markId, isFind\n\n\n    # FIXME Calibrate the mark detection rate\n    def drawSpeimens(self, imgId, *offset, scale):\n        """"""[Draw the viewport of microscope \xe7\x94\xbb\xe5\x87\xba\xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe6\x98\xbe\xe7\xa4\xba\xe7\x9a\x84\xe5\x9b\xbe\xe5\x83\x8f]\n        \n        Arguments:\n            imgId {[Number]} -- [The id of marker \xe6\xa0\x87\xe8\xae\xb0\xe7\x9a\x84id]\n            *offset{[tuple]} -- [The offset of mark Mark\xe7\xa7\xbb\xe5\x8a\xa8\xe4\xbd\x8d\xe7\xa7\xbb]\n            scale {[Number]} -- [Scale time \xe6\x94\xbe\xe7\xbc\xa9\xe7\x9a\x84\xe5\x80\x8d\xe6\x95\xb0]\n        """"""\n        \n        imgTopX, imgTopY, imgBottomX, imgBottomY = 0, 0, self.imgWidth, self.imgHeight\n        \n        # Fault tolerance rate\xef\xbc\x8c when the mark idle, it always has litte offset, so we should\xe2\x80\x98t update viewport.\n        # \xe5\xae\xb9\xe9\x94\x99\xe7\x8e\x87 \xe5\xbd\x93\xe5\x9b\xbe\xe7\x89\x87\xe9\x9d\x99\xe6\xad\xa2\xe4\xb8\x8d\xe5\x8a\xa8\xe7\x9a\x84\xe6\x97\xb6\xe5\x80\x99\xe8\xaf\x86\xe5\x88\xabmark\xe4\xbe\x9d\xe7\x84\xb6\xe4\xbc\x9a\xe5\x87\xba\xe7\x8e\xb0\xe5\xbe\xae\xe5\xb0\x8f\xe7\xa7\xbb\xe5\x8a\xa8\xef\xbc\x8c \xe6\x89\x80\xe4\xbb\xa5\xe4\xb8\x8d\xe8\xbf\x9b\xe8\xa1\x8c\xe6\x9b\xb4\xe6\x96\xb0.\n        if abs(offset[0]) > 4.0 or abs(offset[1]) > 4.0:\n            self.update = True\n        else:\n            self.update = False\n\n        if self.First:\n            self.First, self.update = False, True\n\n        self.viewTopX -= offset[0]  # offsetX\n        self.viewBottomX -= offset[0]  # offsetX\n        self.viewTopY -= offset[1]  # offsetY\n        self.viewBottomY -= offset[1]  # offsetY\n\n        # Scale the image, note: You can only shrink to 1 scale . \xe8\xbf\x9b\xe8\xa1\x8c\xe6\x94\xbe\xe7\xbc\xa9 \xe6\xb3\xa8\xe6\x84\x8f\xe5\x9b\xbe\xe7\x89\x87\xe4\xb8\x8d\xe8\x83\xbd\xe6\x97\xa0\xe9\x99\x90\xe5\x88\xb6\xe7\xbc\xa9\xe5\xb0\x8f\xef\xbc\x8c\xe4\xbb\x85\xe8\x83\xbd\xe7\xbc\xa9\xe5\xb0\x8f\xe5\x88\xb0\xe6\x9c\x80\xe5\xbc\x80\xe5\xa7\x8b\xe5\x9b\xbe\xe5\x83\x8f\n        if scale != 0 and self.nowScale + scale >= 0:\n            self.nowScale += scale\n            self.viewTopX -= scale * self.viewWidth\n            self.viewBottomX += scale * self.viewWidth\n            self.viewTopY -= scale * self.viewHeight\n            self.viewBottomY += scale * self.viewHeight\n            self.update = True\n\n        showTopX, showTopY, showBottomX, showBottomY = map(int, (self.viewTopX, self.viewTopY, self.viewBottomX, self.viewBottomY))\n\n        if self.imgWidth > self.imgHeight:\n            view_port_scale = self.imgWidth / (self.viewBottomX - self.viewTopX)\n        else:\n            view_port_scale = self.imgHeight / (self.viewBottomY - self.viewTopY)\n\n        if self.viewTopX < 0:\n            imgTopX = int(abs(self.viewTopX) * view_port_scale)\n            showTopX = 0\n        if self.viewTopY < 0:\n            imgTopY = int(abs(self.viewTopY) * view_port_scale)\n            showTopY = 0\n        if self.viewBottomX >= self.microscope_w:\n            imgBottomX -= int((self.viewBottomX - self.microscope_w) * view_port_scale)\n            showBottomX = self.microscope_w\n        if self.viewBottomY >= self.microscope_h:\n            imgBottomY -= int((self.viewBottomY - self.microscope_h) * view_port_scale)\n            showBottomY = self.microscope_h\n\n        if self.update:\n            # Get the region of original image\n            roi = self.originImg[imgTopY: imgBottomY, imgTopX: imgBottomX]\n            # Resize to view_port size\n            try:\n                view_roi = cv2.resize(roi, (showBottomX - showTopX, showBottomY - showTopY))\n                self.result_img = np.zeros((self.microscope_w, self.microscope_h, 3), np.uint8) + 255\n                self.result_img[showTopY: showBottomY, showTopX: showBottomX] = view_roi\n            except:\n                pass\n            finally:\n                cv2.imshow(\'MicroScope\', self.result_img)\n\n\n\n    def run(self, dic_scale_scope):\n        """"""[Loop \xe8\xbf\x90\xe8\xa1\x8c]\n        \n        Arguments:\n            dic_scale_scope {[dict]]} -- [key-value of keyboard \xe9\x94\xae\xe7\x9b\x98\xe6\x93\x8d\xe4\xbd\x9c\xe9\x94\xae\xe5\x80\xbc\xe5\xaf\xb9]\n        """"""\n        \n        lastCenter = None  # Center position of mark \xe8\xae\xb0\xe5\xbd\x95\xe6\x89\xbe\xe5\x88\xb0mark\xe4\xb8\xad\xe5\xbf\x83\xe4\xbd\x8d\xe7\xbd\xae\n        Confirm = False  # Confirm mark position \xe7\xa1\xae\xe5\xae\x9amark\xe4\xb8\xad\xe5\xbf\x83\xe4\xbd\x8d\xe7\xbd\xae\xe4\xb8\xba\xe5\xbd\x93\xe5\x89\x8d\xe4\xbd\x8d\xe7\xbd\xae\n        loadedImg = False # Wheather the image has been loaded \xe5\x9b\xbe\xe7\x89\x87\xe6\x98\xaf\xe5\x90\xa6\xe5\xb7\xb2\xe7\xbb\x8f\xe8\xa2\xab\xe5\x8a\xa0\xe8\xbd\xbd\n        \n        while True:\n            _, frame = self.cap.read()\n            center, tempIds, isFind = self.FindMark(frame)\n            keyBoard = cv2.waitKey(5)\n            if keyBoard == dic_scale_scope[\'confirm\'] and not Confirm:\n                Confirm = True  # Confim. \xe7\xa1\xae\xe5\xae\x9a\xe5\xbd\x93\xe5\x89\x8d\xe4\xbd\x8d\xe7\xbd\xae\xe4\xb8\xbamark\xe7\x9a\x84\xe8\xb5\xb7\xe5\xa7\x8b\xe4\xbd\x8d\xe7\xbd\xae\n                lastCenter = center  # Record. \xe8\xae\xb0\xe5\xbd\x95\xe5\xbd\x93\xe5\x89\x8dmark\xe4\xb8\xad\xe5\xbf\x83\xe4\xbd\x8d\xe7\xbd\xae\n                print(\'Confirm the mark\')\n                self.loadImage(tempIds)\n                loadedImg = True\n            if Confirm and isFind and loadedImg:\n                # When you confirm the mark and the mark is found in current frame you can move and scale the scope.\n                # \xe5\xa6\x82\xe6\x9e\x9c\xe4\xbd\xa0\xe5\xb7\xb2\xe7\xbb\x8f\xe7\xa1\xae\xe5\xae\x9amark\xe5\x88\x9d\xe5\xa7\x8b\xe4\xbd\x8d\xe7\xbd\xae\xe8\x80\x8c\xe4\xb8\x94\xe5\xbd\x93\xe5\x89\x8d\xe5\xb8\xa7\xe4\xb9\x9f\xe8\xa6\x81\xe6\x89\xbe\xe5\x88\xb0mark\xe5\x88\x99\xe8\xbf\x9b\xe8\xa1\x8c\xe7\xa7\xbb\xe5\x8a\xa8\xe3\x80\x81\xe6\x94\xbe\xe7\xbc\xa9\xe6\x93\x8d\xe4\xbd\x9c\n                if keyBoard in dic_scale_scope:  # If you press scale key. \xe6\x8c\x89\xe4\xb8\x8b\xe7\xbc\xa9\xe6\x94\xbe\xe9\x94\xae\xe8\xbf\x9b\xe8\xa1\x8c\xe7\xbc\xa9\xe6\x94\xbe\n                    self.drawSpeimens(tempIds, lastCenter[0] - center[0], lastCenter[1] - center[1], scale=dic_scale_scope[keyBoard])\n                else:\n                    self.drawSpeimens(tempIds, lastCenter[0] - center[0], lastCenter[1] - center[1], scale=0)\n                lastCenter = center\n            if keyBoard == dic_scale_scope[\'quit\']:\n                self.reload()\n                break\n    \n    def reload(self):\n        clear_img = np.zeros((self.microscope_w, self.microscope_h, 3), np.uint8) + 255\n        cv2.imshow(\'MicroScope\', clear_img)\n        \n        \n    def release(self):\n        self.cap.release()\n        cv2.destroyAllWindows()\n        \n        \n        \n        \n\n\n\n\n\nif __name__ == \'__main__\':\n    \n    dic_scale_scope = {  # The key-value scale of microscope \xe8\xb0\x83\xe8\x8a\x82\xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe7\x9a\x84\xe9\x94\xae\xe5\x80\xbc\xe5\xaf\xb9\n        \'confirm\': ord(\'=\'), # Confirm mark \xe7\xa1\xae\xe8\xae\xa4mark\xe4\xbd\x8d\xe7\xbd\xae\n        \'quit\': ord(\'q\'), # quit the program \xe9\x80\x80\xe5\x87\xba \xe7\xa8\x8b\xe5\xba\x8f\n        ord(\'w\'): 1, # magnify 1 time \xe8\xa7\x86\xe9\x87\x8e\xe6\x94\xbe\xe5\xa4\xa7\xe4\xb8\x80\xe5\x80\x8d\n        ord(\'s\'): -1,# shrink 1 time \xe8\xa7\x86\xe9\x87\x8e\xe7\xbc\xa9\xe5\xb0\x8f\xe4\xb8\x80\xe5\x80\x8d\n        ord(\'e\'): 4, # magnify 4 time \xe8\xa7\x86\xe9\x87\x8e\xe6\x94\xbe\xe5\xa4\xa7\xe5\x9b\x9b\xe5\x80\x8d\n        ord(\'d\'): -4,# shrink 4 time \xe8\xa7\x86\xe9\x87\x8e\xe7\xbc\xa9\xe5\xb0\x8f\xe5\x9b\x9b\xe5\x80\x8d\n        ord(\'r\'): 10,# magnify 10 time \xe8\xa7\x86\xe9\x87\x8e\xe6\x94\xbe\xe5\xa4\xa7\xe5\x8d\x81\xe5\x80\x8d\n        ord(\'f\'): -10,# shrink 10 time \xe8\xa7\x86\xe9\x87\x8e\xe7\xbc\xa9\xe5\xb0\x8f\xe5\x8d\x81\xe5\x80\x8d\n        \n    }\n\n    micro_w, micro_h = 240, 240 # The width and height of microscope \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3\xe5\xae\xbd\xe5\xba\xa6\xe5\x92\x8c\xe9\xab\x98\xe5\xba\xa6\n    micro_posX, micro_posY  = 500, 500 # The x postion of microscope \xe6\x98\xbe\xe5\xbe\xae\xe9\x95\x9c\xe8\xa7\x86\xe5\x8f\xa3x\xe3\x80\x81y\xe5\x9d\x90\xe6\xa0\x87\n    \n    dic_specimen_id = { # The key-value : id - specimen photo \xe7\xb4\xa2\xe5\xbc\x95\xe5\x92\x8c\xe6\xa0\x87\xe6\x9c\xac\xe5\xaf\xb9\xe5\xba\x94\n        1 : \'JointPhoto/Onion.jpg\', # Onion \xe6\xb4\x8b\xe8\x91\xb1\xe5\x88\x87\xe7\x89\x87\n        2 : \'JointPhoto/Paramecium.jpg\', # Paramecium.jpg \xe8\x8d\x89\xe5\xb1\xa5\xe8\x99\xab\xe6\xa0\x87\xe6\x9c\xac\n        3 : \'JointPhoto/SpinalCord.jpg\' # SpinalCord.jpg \xe8\x84\x8a\xe9\xab\x93\xe5\x88\x87\xe7\x89\x87\n    }\n    microScope =  MicroScope(micro_w, micro_h, micro_posX, micro_posY, dic_specimen_id)\n    while True:    \n        microScope.run(dic_scale_scope)\n    microScope.release()\n    del microScope\n'"
.vscode/.ropeproject/config.py,0,"b'# The default ``config.py``\n# flake8: noqa\n\n\ndef set_prefs(prefs):\n    """"""This function is called before opening the project""""""\n\n    # Specify which files and folders to ignore in the project.\n    # Changes to ignored resources are not added to the history and\n    # VCSs.  Also they are not returned in `Project.get_files()`.\n    # Note that ``?`` and ``*`` match all characters but slashes.\n    # \'*.pyc\': matches \'test.pyc\' and \'pkg/test.pyc\'\n    # \'mod*.pyc\': matches \'test/mod1.pyc\' but not \'mod/1.pyc\'\n    # \'.svn\': matches \'pkg/.svn\' and all of its children\n    # \'build/*.o\': matches \'build/lib.o\' but not \'build/sub/lib.o\'\n    # \'build//*.o\': matches \'build/lib.o\' and \'build/sub/lib.o\'\n    prefs[\'ignored_resources\'] = [\'*.pyc\', \'*~\', \'.ropeproject\',\n                                  \'.hg\', \'.svn\', \'_svn\', \'.git\', \'.tox\']\n\n    # Specifies which files should be considered python files.  It is\n    # useful when you have scripts inside your project.  Only files\n    # ending with ``.py`` are considered to be python files by\n    # default.\n    # prefs[\'python_files\'] = [\'*.py\']\n\n    # Custom source folders:  By default rope searches the project\n    # for finding source folders (folders that should be searched\n    # for finding modules).  You can add paths to that list.  Note\n    # that rope guesses project source folders correctly most of the\n    # time; use this if you have any problems.\n    # The folders should be relative to project root and use \'/\' for\n    # separating folders regardless of the platform rope is running on.\n    # \'src/my_source_folder\' for instance.\n    # prefs.add(\'source_folders\', \'src\')\n\n    # You can extend python path for looking up modules\n    # prefs.add(\'python_path\', \'~/python/\')\n\n    # Should rope save object information or not.\n    prefs[\'save_objectdb\'] = True\n    prefs[\'compress_objectdb\'] = False\n\n    # If `True`, rope analyzes each module when it is being saved.\n    prefs[\'automatic_soa\'] = True\n    # The depth of calls to follow in static object analysis\n    prefs[\'soa_followed_calls\'] = 0\n\n    # If `False` when running modules or unit tests ""dynamic object\n    # analysis"" is turned off.  This makes them much faster.\n    prefs[\'perform_doa\'] = True\n\n    # Rope can check the validity of its object DB when running.\n    prefs[\'validate_objectdb\'] = True\n\n    # How many undos to hold?\n    prefs[\'max_history_items\'] = 32\n\n    # Shows whether to save history across sessions.\n    prefs[\'save_history\'] = True\n    prefs[\'compress_history\'] = False\n\n    # Set the number spaces used for indenting.  According to\n    # :PEP:`8`, it is best to use 4 spaces.  Since most of rope\'s\n    # unit-tests use 4 spaces it is more reliable, too.\n    prefs[\'indent_size\'] = 4\n\n    # Builtin and c-extension modules that are allowed to be imported\n    # and inspected by rope.\n    prefs[\'extension_modules\'] = []\n\n    # Add all standard c-extensions to extension_modules list.\n    prefs[\'import_dynload_stdmods\'] = True\n\n    # If `True` modules with syntax errors are considered to be empty.\n    # The default value is `False`; When `False` syntax errors raise\n    # `rope.base.exceptions.ModuleSyntaxError` exception.\n    prefs[\'ignore_syntax_errors\'] = False\n\n    # If `True`, rope ignores unresolvable imports.  Otherwise, they\n    # appear in the importing namespace.\n    prefs[\'ignore_bad_imports\'] = False\n\n    # If `True`, rope will insert new module imports as\n    # `from <package> import <module>` by default.\n    prefs[\'prefer_module_from_imports\'] = False\n\n    # If `True`, rope will transform a comma list of imports into\n    # multiple separate import statements when organizing\n    # imports.\n    prefs[\'split_imports\'] = False\n\n    # If `True`, rope will remove all top-level import statements and\n    # reinsert them at the top of the module when making changes.\n    prefs[\'pull_imports_to_top\'] = True\n\n    # If `True`, rope will sort imports alphabetically by module name instead\n    # of alphabetically by import statement, with from imports after normal\n    # imports.\n    prefs[\'sort_imports_alphabetically\'] = False\n\n    # Location of implementation of\n    # rope.base.oi.type_hinting.interfaces.ITypeHintingFactory In general\n    # case, you don\'t have to change this value, unless you\'re an rope expert.\n    # Change this value to inject you own implementations of interfaces\n    # listed in module rope.base.oi.type_hinting.providers.interfaces\n    # For example, you can add you own providers for Django Models, or disable\n    # the search type-hinting in a class hierarchy, etc.\n    prefs[\'type_hinting_factory\'] = (\n        \'rope.base.oi.type_hinting.factory.default_type_hinting_factory\')\n\n\ndef project_opened(project):\n    """"""This function is called after opening the project""""""\n    # Do whatever you like here!\n'"
