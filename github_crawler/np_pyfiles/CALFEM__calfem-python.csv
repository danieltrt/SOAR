file_path,api_count,code
setup.py,0,"b'""""""A setuptools based setup module.\n\nSee:\nhttps://github.com/CALFEM/calfem-python\n""""""\n\n# Always prefer setuptools over distutils\nfrom setuptools import setup, find_packages\n# To use a consistent encoding\nfrom codecs import open\nfrom os import path\nimport os, glob, sys\n\nhere = path.abspath(path.dirname(__file__))\n\n# Get the long description from the README file\nwith open(path.join(here, \'README.rst\'), encoding=\'utf-8\') as f:\n    long_description = f.read()\n\ndef gen_data_files(*dirs):\n    results = []\n\n    for src_dir in dirs:\n        for root,dirs,files in os.walk(src_dir):\n            results.append((root, map(lambda f:root + ""/"" + f, files)))\n    return results    \n\nsetup(\n    name=\'calfem-python\',\n\n    # Versions should comply with PEP440.  For a discussion on single-sourcing\n    # the version across setup.py and the project code, see\n    # https://packaging.python.org/en/latest/single_source_version.html\n    version=\'3.5.3\',\n\n    description=\'CALFEM for Python\',\n    long_description=\'The computer program CALFEM is written for the software MATLAB and is an interactive tool for  learning the finite element method. CALFEM is an abbreviation of ""Computer Aided Learning of the Finite Element  Method"" and been developed by the Division of Structural Mechanics at Lund University since the late 70s.\',\n\n    # The project\'s main homepage.\n    url=\'https://github.com/CALFEM/calfem-python\',\n\n    # Author details\n    author=\'Jonas Lindemann, et al\',\n    author_email=\'jonas.lindemann@byggmek.lth.se\',\n\n    # Choose your license\n    license=\'MIT\',\n\n    # See https://pypi.python.org/pypi?%3Aaction=list_classifiers\n    classifiers=[\n        # How mature is this project? Common values are\n        #   3 - Alpha\n        #   4 - Beta\n        #   5 - Production/Stable\n        \'Development Status :: 4 - Beta\',\n\n        # Indicate who your project is intended for\n        \'Intended Audience :: Developers\',\n        \'Topic :: Software Development :: Build Tools\',\n\n        # Pick your license as you wish (should match ""license"" above)\n        \'License :: OSI Approved :: MIT License\',\n\n        # Specify the Python versions you support here. In particular, ensure\n        # that you indicate whether you support Python 2, Python 3 or both.\n        \'Programming Language :: Python :: 3\',\n        \'Programming Language :: Python :: 3.3\',\n        \'Programming Language :: Python :: 3.4\',\n        \'Programming Language :: Python :: 3.5\',\n        \'Programming Language :: Python :: 3.6\',\n        \'Programming Language :: Python :: 3.7\',\n        \'Programming Language :: Python :: 3.8\',\n    ],\n\n    # What does your project relate to?\n    keywords=\'finite element, math, numerics\',\n\n    # You can just specify the packages manually here if your project is\n    # simple. Or you can use find_packages().\n    #packages=find_packages(exclude=[\'contrib\', \'docs\', \'tests\']),\n    #packages=find_packages(exclude=[\'docs\', \'old\', \'examples\', \'examplegeo\']),\n    packages=[\'calfem\',], \n\n    # Alternatively, if you want to distribute just a my_module.py, uncomment\n    # this:\n    #   py_modules=[""my_module""],\n\n    # List run-time dependencies here.  These will be installed by pip when\n    # your project is installed. For an analysis of ""install_requires"" vs pip\'s\n    # requirements files see:\n    # https://packaging.python.org/en/latest/requirements.html\n    install_requires=[\'numpy\', \'visvis\', \'pyvtk\', \'matplotlib\'],\n    include_package_data=True\n    #package_data={\'calfem\': [\'examples/*\']}\n    \n    #data_files=gen_data_files(""examples"", ""doc"")\n    \n    #package_data={\n    #    \'calfem\': [\'examples/*.py\', \'examples/*.ui\']\n    #}\n\n    # List additional groups of dependencies here (e.g. development\n    # dependencies). You can install these using the following syntax,\n    # for example:\n    # $ pip install -e .[dev,test]\n    #extras_require={\n    #    \'dev\': [\'check-manifest\'],\n    #    \'test\': [\'coverage\'],\n    #},\n\n    # If there are data files included in your packages that need to be\n    # installed, specify them here.  If using Python 2.6 or less, then these\n    # have to be included in MANIFEST.in as well.\n)\n'"
calfem/__init__.py,0,b''
calfem/classes_qt4.py,0,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\nfrom PyQt import QtGui, QtCore, QtOpenGL\n\nimport colorsys\n\ndef drawBitmapText(text, font=GLUT_BITMAP_TIMES_ROMAN_24):\n    for c in text:\n        glutBitmapCharacter(font, ord(c))\n\ndef floatRgb(mag, cmin, cmax):\n    """"""\n    Return a tuple of floats between 0 and 1 for the red, green and\n    blue amplitudes.\n    """"""\n    \n    try:\n           # normalize to [0,1]\n           x = float(mag-cmin)/float(cmax-cmin)\n    except:\n           # cmax = cmin\n           x = 0.5\n           \n    red, green, blue = colorsys.hsv_to_rgb(x*240./360, 1.0, 1.0)\n    return (red, green, blue)\n\nclass OpenGLFrame(QtOpenGL.QGLWidget):\n    def __init__(self, parent = None):\n        super(OpenGLFrame, self).__init__(parent)\n\n    def paintGL(self):\n        self.onDraw()\n\n    def resizeGL(self, w, h):\n        self.onReshape(w, h)\n\n    def initializeGL(self):\n        self.onInitGL()\n        \n    def Show(self):\n        self.show()\n        \n    def SwapBuffers(self):\n        pass\n        \n    #\n    # GLFrame OpenGL Event Handlers\n\n    def onInitGL(self):\n        """"""Initialize OpenGL for use in the window.""""""\n        glClearColor(1, 1, 1, 1)\n        glDisable(GL_DEPTH_TEST)\n\n    def onReshape(self, width, height):\n        """"""Reshape the OpenGL viewport based on the dimensions of the window.""""""\n        glViewport(0, 0, width, height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(-0.5, 0.5, -0.5, 0.5, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def onDraw(self):\n        ""Draw the window.""\n        glClear(GL_COLOR_BUFFER_BIT)\n\n        # Drawing an example triangle in the middle of the screen\n        glBegin(GL_TRIANGLES)\n        glColor(1, 0, 0)\n        glVertex(-.25, -.25)\n        glColor(0, 1, 0)\n        glVertex(.25, -.25)\n        glColor(0, 0, 1)\n        glVertex(0, .25)\n        glEnd()\n        \n        \nclass ElementView(OpenGLFrame):\n    def __init__(self, parent = None, a = 0, b = 0):\n        super(ElementView, self).__init__(parent)\n        self._initView()\n        \n    def _initView(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        self._nodeLimits = [1e300, -1e300]\n        self._maxNodeValue = -1e300\n        self._minNodeValue = 1e300\n        self._maxElementValue = -1e300\n        self._minElementValue = 1e300\n        self._ex = None\n        self._ey = None\n        self._ed = None\n        self._ev = None\n        self._magnfac = 0.1\n        self._elementNodes = 3\n        self._dofsPerNode = 1\n        self._showDimension = 1\n        self._width = 100\n        self._height = 100\n        self._showMesh = True\n        self._showNodalValues = True\n        self._showDisplacements = False\n        self._showElementValues = False\n        \n        self.drawAnnotations = None\n        self.drawCustom = None\n        \n    def calcLimits(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        \n        if not (self._ex is None) and not (self._ey is None):\n            for elCoords in self._ex:\n                xmin = min(elCoords)\n                xmax = max(elCoords)\n                \n                if xmin<self._limits[0]:\n                    self._limits[0]=xmin\n                if xmax>self._limits[2]:\n                    self._limits[2]=xmax\n\n            for elCoords in self._ey:\n                ymin = min(elCoords)\n                ymax = max(elCoords)\n                \n                if ymin<self._limits[1]:\n                    self._limits[1]=ymin\n                if ymax>self._limits[3]:\n                    self._limits[3]=ymax\n                    \n    def calcNodeLimits(self):\n        if self.dofsPerNode == 1:\n            self._maxNodeValue = self._ed.max()\n            self._minNodeValue = self._ed.min()\n        else:\n            self._maxNodeValue = abs(self._ed).max()\n            \n    def calcElementLimits(self):\n        self._maxElementValue = self._ev.max()\n        self._minElementValue = self._ev.min()\n    \n    def calcScaling(self):\n\n        self._k = 0.8\n        \n        factor1 = self._k*self._width/(self._limits[2]-self._limits[0])\n        factor2 = self._k*self._height/(self._limits[3]-self._limits[1])\n        \n        self._scaleFactor = 1.0\n        \n        if factor1<factor2:\n            self._scaleFactor = factor1\n        else:\n            self._scaleFactor = factor2\n            \n        self._x0 = -self._scaleFactor*self._limits[0] + (1-self._k)*self._width/2.0\n        self._y0 = self._height - self._scaleFactor*self._limits[1] - (1-self._k)*self._height/2.0\n\n    def worldToScreen(self, x, y):\n        return (int(self._x0 + self._scaleFactor*x), int(self._y0 - self._scaleFactor*y))\n        \n    def drawMesh(self):\n             \n        # Draw elements\n                              \n        glBegin(GL_LINES)\n              \n        for elx, ely in zip(self._ex, self._ey):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                \n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n                \n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n\n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n            \n        glEnd()\n        \n    def drawNodalValues(self):\n                \n        # Draw nodal values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2], self._maxNodeValue, self._minNodeValue)\n                else:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glColor3f(c2[0], c2[1], c2[2])\n                glVertex(sx2,sy2)\n                glColor3f(c3[0], c3[1], c3[2])\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawElementValues(self):\n                \n        # Draw element values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, elv in zip(self._ex, self._ey, self._ev):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                else:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawDisplacements(self):\n        \n        # Draw elements\n        \n        scl = self._magnfac*self.modelWidth/self._maxNodeValue\n        \n        glBegin(GL_LINES)\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n                (sx3, sy3) = self.worldToScreen(elx[2]+scl*eld[4], ely[2]+scl*eld[5])\n                                           \n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n\n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n\n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n\n        glEnd()\n\n            \n    def onReshape(self, width, height):\n        """"""\n        Reshape the OpenGL viewport based on the dimensions of the window.\n        """"""\n        glViewport(0, 0, width, height)\n        \n        self._width = width\n        self._height = height\n        \n        self.calcScaling()\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0.0, width, height, 0.0, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        \n        glEnable(GL_POINT_SMOOTH)\n        glEnable(GL_LINE_SMOOTH)\n        glEnable(GL_POLYGON_SMOOTH)\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST)\n        glLineWidth(1.0)\n        glDisable(GL_DEPTH_TEST)\n        glDisable(GL_LIGHTING)\n\n    def onDraw(self, *args, **kwargs):\n        """"""\n        Draw the window.\n        """"""\n              \n        glClear(GL_COLOR_BUFFER_BIT)\n        \n        if self._showElementValues:\n            self.drawElementValues()\n        if self._showNodalValues:\n            self.drawNodalValues()\n        if self._showMesh:\n            self.drawMesh()\n        if self._showDisplacements:\n            self.drawDisplacements()\n            \n        if self.drawCustom!=None:\n            self.drawCustom(self, self._width, self._height)\n            \n        if self.drawAnnotations!=None:\n            self.drawAnnotations(self, self._width, self._height)\n            \n        self.SwapBuffers()\n        \n    def getModelHeight(self):\n        return self._ey.max() - self._ey.min()\n        \n    def getModelWidth(self):\n        return self._ex.max() - self._ex.min()\n\n    def setEx(self, ex):\n        self._ex = ex\n        self._elementNodes = self._ex.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEx(self):\n        return self._ex\n    \n    def setEy(self, ey):\n        self._ey = ey\n        self._elementNodes = self._ey.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEy(self):\n        return self._ey\n    \n    def setEd(self, ed):\n        self._ed = ed\n        self.calcNodeLimits()\n        \n    def getEd(self):\n        return self._ed\n    \n    def setShowMesh(self, showMesh):\n        self._showMesh = showMesh\n        \n    def getShowMesh(self):\n        return self._showMesh\n    \n    def setShowNodalValues(self, showNodalValues):\n        self._showNodalValues = showNodalValues\n        \n    def getShowNodalValues(self):\n        return self._showNodalValues\n    \n    def setShowElementValues(self, showElementValues):\n        self._showElementValues = showElementValues\n        \n    def getShowElementValues(self):\n        return self._showElementValues\n\n    def setShowDisplacements(self, showDisplacements):\n        self._showDisplacements = showDisplacements\n        \n    def getShowDisplacements(self):\n        return self._showDisplacements\n    \n    def setDofsPerNode(self, dofsPerNode):\n        self._dofsPerNode = dofsPerNode\n        \n    def getDofsPerNode(self):\n        return self._dofsPerNode\n    \n    def setElementNodes(self, elementNodes):\n        self._elementNodes = elementNodes\n        \n    def getElementNodes(self):\n        return self._elementNodes\n    \n    def setMagnFac(self, magnfac):\n        self._magnfac = magnfac\n        \n    def getMagnFac(self):\n        return self._magnfac\n    \n    def getEv(self):\n        return self._ev\n    \n    def setEv(self, value):\n        self._ev = value\n        self.calcElementLimits()\n    \n    ex = property(getEx, setEx)\n    ey = property(getEy, setEy)\n    ed = property(getEd, setEd)\n    ev = property(getEv, setEv)\n    dofsPerNode = property(getDofsPerNode, setDofsPerNode)\n    elementNodes = property(getElementNodes, setElementNodes)\n    modelWidth = property(getModelWidth)\n    modelHeight = property(getModelHeight)\n    magnfac = property(getMagnFac, setMagnFac)\n    showMesh = property(getShowMesh, setShowMesh)\n    showNodalValues = property(getShowNodalValues, setShowNodalValues)\n    showDisplacements = property(getShowDisplacements, setShowDisplacements)\n    showElementValues = property(getShowElementValues, setShowElementValues)        \n        \n\n'"
calfem/classes_wx.py,0,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nimport wx\n\nfrom wx import glcanvas\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\n\nimport colorsys\n\ndef drawBitmapText(text, font=GLUT_BITMAP_TIMES_ROMAN_24):\n    for c in text:\n        glutBitmapCharacter(font, ord(c))\n\ndef floatRgb(mag, cmin, cmax):\n    """"""\n    Return a tuple of floats between 0 and 1 for the red, green and\n    blue amplitudes.\n    """"""\n    \n    try:\n           # normalize to [0,1]\n           x = float(mag-cmin)/float(cmax-cmin)\n    except:\n           # cmax = cmin\n           x = 0.5\n           \n    red, green, blue = colorsys.hsv_to_rgb(x*240./360, 1.0, 1.0)\n    return (red, green, blue)\n\nclass OpenGLFrame(wx.Frame):\n    def __init__(self, *args, **kwds):\n        kwds[""style""] = wx.DEFAULT_FRAME_STYLE\n        wx.Frame.__init__(self, *args, **kwds)\n        \n        self.GLinitialized = False\n        attribList = (glcanvas.WX_GL_RGBA, # RGBA\n                      glcanvas.WX_GL_DOUBLEBUFFER, # Double Buffered\n                      glcanvas.WX_GL_DEPTH_SIZE, 24) # 24 bit\n\n        # Create the canvas\n\n        self.canvas = glcanvas.GLCanvas(self, attribList=attribList)\n\n        # Set the event handlers.\n\n        self.canvas.Bind(wx.EVT_ERASE_BACKGROUND, self._doEraseBackground)\n        self.canvas.Bind(wx.EVT_SIZE, self._doSize)\n        self.canvas.Bind(wx.EVT_PAINT, self._doPaint)\n\n    # Canvas Proxy Methods\n\n    def GetGLExtents(self):\n        """"""Get the extents of the OpenGL canvas.""""""\n        return self.canvas.GetClientSize()\n\n    def SwapBuffers(self):\n        """"""Swap the OpenGL buffers.""""""\n        self.canvas.SwapBuffers()\n\n    # wxPython Window Handlers\n\n    def _doEraseBackground(self, event):\n        """"""Process the erase background event.""""""\n        pass # Do nothing, to avoid flashing on MSWin\n\n    def _doSize(self, event):\n        """"""Process the resize event.""""""\n        if self.canvas.GetContext():\n            # Make sure the frame is shown before calling SetCurrent.\n            self.Show()\n            self.canvas.SetCurrent()\n\n            size = self.GetGLExtents()\n            self.onReshape(size.width, size.height)\n            self.canvas.Refresh(False)\n        event.Skip()\n\n    def _doPaint(self, event):\n        """"""Process the drawing event.""""""\n        self.canvas.SetCurrent()\n\n        # This is a \'perfect\' time to initialize OpenGL ... only if we need to\n        \n        if not self.GLinitialized:\n            self.onInitGL()\n            self.GLinitialized = True\n\n        self.onDraw()\n        event.Skip()\n        \n    def drawStrokeText(self, text, x=0.0, y=0.0, fontSize=1.0, color=[0.0, 0.0, 0.0], font=GLUT_STROKE_ROMAN):\n        glPushMatrix()\n        glTranslate(x, y, 0)\n        glPushMatrix()\n        glColor(color)\n        glScalef(fontSize/119.05, -fontSize/119.05, 0.0)\n        glTranslate(0.0, -fontSize/119.05, 0.0)\n        \n        for c in text:\n            glutStrokeCharacter(font, ord(c))\n    \n        glPopMatrix()\n        glPopMatrix()\n\n\n    #\n    # GLFrame OpenGL Event Handlers\n\n    def onInitGL(self):\n        """"""Initialize OpenGL for use in the window.""""""\n        glClearColor(1, 1, 1, 1)\n        glDisable(GL_DEPTH_TEST)\n\n    def onReshape(self, width, height):\n        """"""Reshape the OpenGL viewport based on the dimensions of the window.""""""\n        glViewport(0, 0, width, height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(-0.5, 0.5, -0.5, 0.5, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def onDraw(self, *args, **kwargs):\n        ""Draw the window.""\n        glClear(GL_COLOR_BUFFER_BIT)\n\n        # Drawing an example triangle in the middle of the screen\n        glBegin(GL_TRIANGLES)\n        glColor(1, 0, 0)\n        glVertex(-.25, -.25)\n        glColor(0, 1, 0)\n        glVertex(.25, -.25)\n        glColor(0, 0, 1)\n        glVertex(0, .25)\n        glEnd()\n\n        self.SwapBuffers()      \n\nclass ElementView(OpenGLFrame):\n    def __init__(self, *args, **kwds):\n        # begin wxGlade: ResultWindow.__init__\n        kwds[""style""] = wx.DEFAULT_FRAME_STYLE\n        OpenGLFrame.__init__(self, *args, **kwds)\n\n        self.__set_properties()\n        self.__do_layout()\n        # end wxGlade\n        \n        self._initView()\n\n    def __set_properties(self):\n        # begin wxGlade: ResultWindow.__set_properties\n        self.SetTitle(""Result view"")\n        # end wxGlade\n\n    def __do_layout(self):\n        # begin wxGlade: ResultWindow.__do_layout\n        self.Layout()\n        # end wxGlade\n        \n    def _initView(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        self._nodeLimits = [1e300, -1e300]\n        self._maxNodeValue = -1e300\n        self._minNodeValue = 1e300\n        self._maxElementValue = -1e300\n        self._minElementValue = 1e300\n        self._ex = None\n        self._ey = None\n        self._ed = None\n        self._ev = None\n        self._magnfac = 0.1\n        self._elementNodes = 3\n        self._dofsPerNode = 1\n        self._showDimension = 1\n        self._width = 100\n        self._height = 100\n        self._showMesh = True\n        self._showNodalValues = True\n        self._showDisplacements = False\n        self._showElementValues = False\n        \n        self.drawAnnotations = None\n        self.drawCustom = None\n        \n    def calcLimits(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        \n        if self._ex!=None and self._ey!=None:\n            for elCoords in self._ex:\n                xmin = min(elCoords)\n                xmax = max(elCoords)\n                \n                if xmin<self._limits[0]:\n                    self._limits[0]=xmin\n                if xmax>self._limits[2]:\n                    self._limits[2]=xmax\n\n            for elCoords in self._ey:\n                ymin = min(elCoords)\n                ymax = max(elCoords)\n                \n                if ymin<self._limits[1]:\n                    self._limits[1]=ymin\n                if ymax>self._limits[3]:\n                    self._limits[3]=ymax\n                    \n    def calcNodeLimits(self):\n        if self.dofsPerNode == 1:\n            self._maxNodeValue = self._ed.max()\n            self._minNodeValue = self._ed.min()\n        else:\n            self._maxNodeValue = abs(self._ed).max()\n            \n    def calcElementLimits(self):\n        self._maxElementValue = self._ev.max()\n        self._minElementValue = self._ev.min()\n    \n    def calcScaling(self):\n\n        self._k = 0.8\n        \n        factor1 = self._k*self._width/(self._limits[2]-self._limits[0])\n        factor2 = self._k*self._height/(self._limits[3]-self._limits[1])\n        \n        self._scaleFactor = 1.0\n        \n        if factor1<factor2:\n            self._scaleFactor = factor1\n        else:\n            self._scaleFactor = factor2\n            \n        self._x0 = -self._scaleFactor*self._limits[0] + (1-self._k)*self._width/2.0\n        self._y0 = self._height - self._scaleFactor*self._limits[1] - (1-self._k)*self._height/2.0\n\n    def worldToScreen(self, x, y):\n        return (int(self._x0 + self._scaleFactor*x), int(self._y0 - self._scaleFactor*y))\n        \n    def drawMesh(self):\n             \n        # Draw elements\n                              \n        glBegin(GL_LINES)\n              \n        for elx, ely in zip(self._ex, self._ey):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                \n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n                \n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n\n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n            \n        glEnd()\n        \n    def drawNodalValues(self):\n                \n        # Draw nodal values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2], self._maxNodeValue, self._minNodeValue)\n                else:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glColor3f(c2[0], c2[1], c2[2])\n                glVertex(sx2,sy2)\n                glColor3f(c3[0], c3[1], c3[2])\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawElementValues(self):\n                \n        # Draw element values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, elv in zip(self._ex, self._ey, self._ev):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                else:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawDisplacements(self):\n        \n        # Draw elements\n        \n        scl = self._magnfac*self.modelWidth/self._maxNodeValue\n        \n        glBegin(GL_LINES)\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n                (sx3, sy3) = self.worldToScreen(elx[2]+scl*eld[4], ely[2]+scl*eld[5])\n                                           \n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n\n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n\n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n\n        glEnd()\n\n            \n    def onReshape(self, width, height):\n        """"""\n        Reshape the OpenGL viewport based on the dimensions of the window.\n        """"""\n        glViewport(0, 0, width, height)\n        \n        self._width = width\n        self._height = height\n        \n        self.calcScaling()\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0.0, width, height, 0.0, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        \n        glEnable(GL_POINT_SMOOTH)\n        glEnable(GL_LINE_SMOOTH)\n        glEnable(GL_POLYGON_SMOOTH)\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST)\n        glLineWidth(1.0)\n        glDisable(GL_DEPTH_TEST)\n        glDisable(GL_LIGHTING)\n\n    def onDraw(self, *args, **kwargs):\n        """"""\n        Draw the window.\n        """"""\n              \n        glClear(GL_COLOR_BUFFER_BIT)\n        \n        if self._showElementValues:\n            self.drawElementValues()\n        if self._showNodalValues:\n            self.drawNodalValues()\n        if self._showMesh:\n            self.drawMesh()\n        if self._showDisplacements:\n            self.drawDisplacements()\n            \n        if self.drawCustom!=None:\n            self.drawCustom(self, self._width, self._height)\n            \n        if self.drawAnnotations!=None:\n            self.drawAnnotations(self, self._width, self._height)\n            \n        self.SwapBuffers()\n        \n    def getModelHeight(self):\n        return self._ey.max() - self._ey.min()\n        \n    def getModelWidth(self):\n        return self._ex.max() - self._ex.min()\n\n    def setEx(self, ex):\n        self._ex = ex\n        self._elementNodes = self._ex.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEx(self):\n        return self._ex\n    \n    def setEy(self, ey):\n        self._ey = ey\n        self._elementNodes = self._ey.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEy(self):\n        return self._ey\n    \n    def setEd(self, ed):\n        self._ed = ed\n        self.calcNodeLimits()\n        \n    def getEd(self):\n        return self._ed\n    \n    def setShowMesh(self, showMesh):\n        self._showMesh = showMesh\n        \n    def getShowMesh(self):\n        return self._showMesh\n    \n    def setShowNodalValues(self, showNodalValues):\n        self._showNodalValues = showNodalValues\n        \n    def getShowNodalValues(self):\n        return self._showNodalValues\n    \n    def setShowElementValues(self, showElementValues):\n        self._showElementValues = showElementValues\n        \n    def getShowElementValues(self):\n        return self._showElementValues\n\n    def setShowDisplacements(self, showDisplacements):\n        self._showDisplacements = showDisplacements\n        \n    def getShowDisplacements(self):\n        return self._showDisplacements\n    \n    def setDofsPerNode(self, dofsPerNode):\n        self._dofsPerNode = dofsPerNode\n        \n    def getDofsPerNode(self):\n        return self._dofsPerNode\n    \n    def setElementNodes(self, elementNodes):\n        self._elementNodes = elementNodes\n        \n    def getElementNodes(self):\n        return self._elementNodes\n    \n    def setMagnFac(self, magnfac):\n        self._magnfac = magnfac\n        \n    def getMagnFac(self):\n        return self._magnfac\n    \n    def getEv(self):\n        return self._ev\n    \n    def setEv(self, value):\n        self._ev = value\n        self.calcElementLimits()\n    \n    ex = property(getEx, setEx)\n    ey = property(getEy, setEy)\n    ed = property(getEd, setEd)\n    ev = property(getEv, setEv)\n    dofsPerNode = property(getDofsPerNode, setDofsPerNode)\n    elementNodes = property(getElementNodes, setElementNodes)\n    modelWidth = property(getModelWidth)\n    modelHeight = property(getModelHeight)\n    magnfac = property(getMagnFac, setMagnFac)\n    showMesh = property(getShowMesh, setShowMesh)\n    showNodalValues = property(getShowNodalValues, setShowNodalValues)\n    showDisplacements = property(getShowDisplacements, setShowDisplacements)\n    showElementValues = property(getShowElementValues, setShowElementValues)\n    \n'"
calfem/core.py,658,"b'# -*- coding: iso-8859-15 -*-\n""""""\nCALFEM Core module\n\nContains all the functions implementing CALFEM standard functionality\n""""""\n\nfrom scipy.sparse.linalg import dsolve\nimport numpy as np\nimport logging as cflog\n\ndef error(msg):\n    """"""Write ``msg`` to error log.""""""\n    cflog.error("" calfem.core: ""+msg)\n\ndef info(msg):\n    """"""Write ``msg`` to info log.""""""\n    cflog.info("" calfem.core: ""+msg)\n\ndef spring1e(ep):\n    """"""\n    Compute element stiffness matrix for spring element.\n    \n    :param float ep: spring stiffness or analog quantity (ep = k).\n    :return mat Ke: stiffness matrix, dim(Ke)= 2 x 2\n    """"""\n    k = ep\n    return np.mat([[k,-k],[-k,k]],\'d\')\n\ndef spring1s(ep,ed):\n    """"""\n    Compute element force in spring element (spring1e).\n    \n    :param float ep: spring stiffness or analog quantity\n    :param list ed: element displacements [d0, d1]\n    :return float es: element force [N]\n    """"""\n    k = ep\n    return k*(ed[1]-ed[0]);   \n\ndef bar1e(ep):\n    """"""\n    Compute element stiffness matrix for spring element.\n    \n    :param ep float: spring stiffness or analog quantity\n    :return mat Ke: stiffness matrix, dim(Ke)= 2 x 2\n    """"""\n    k = ep\n    return np.mat([[k,-k],[-k,k]],\'d\')\n\ndef bar1s(ep,ed):\n    """"""\n    Compute element force in spring element (spring1e).\n    \n    :param float ep: spring stiffness or analog quantity\n    :param list ed: element displacements [d0, d1]\n    :return float es: element force\n    """"""\n    k = ep\n    return k*(ed[1]-ed[0]);   \n\ndef bar2e(ex,ey,ep):\n    """"""\n    Compute the element stiffness matrix for two dimensional bar element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ep: [E, A]: E - Young\'s modulus, A - Cross section area\n    :return mat Ke: stiffness matrix, [4 x 4]\n    """"""\n    E=ep[0]\n    A=ep[1]\n    \n    b = np.mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = np.asscalar(np.sqrt(b.T*b))\n    \n    Kle = np.mat([[1.,-1.],[-1.,1.]])*E*A/L\n    \n    n = np.asarray(b.T/L).reshape(2,)\n    \n    G = np.mat([\n        [n[0],n[1],0.,0.],\n        [0.,0.,n[0],n[1]]\n    ])\n    \n    return G.T*Kle*G\n\ndef bar2g(ex,ey,ep,N):\n    """"""\n    Compute element stiffness matrix for two dimensional geometric\n    nonlinear bar element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ep: element properties [E, A], E - Young\'s modulus, A - Cross section area\n    :param float N: normal force\n    :return mat Ke: stiffness matrix [4 x 4]\n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    \n    n = np.asarray(b.T/L).reshape(2,)\n\n    G = np.mat([\n        [ n[0], n[1], 0.,   0.  ],\n        [-n[1], n[0], 0.,   0.  ],\n        [ 0.,   0.,   n[0], n[1]],\n        [ 0.,   0.,  -n[1], n[0]]\n    ])\n    \n    Kle = E*A/L*np.mat([\n        [ 1, 0,-1, 0],\n        [ 0, 0, 0, 0],\n        [-1, 0, 1, 0],\n        [ 0, 0, 0, 0]\n    ])+N/L*np.mat([\n        [ 0, 0, 0, 0],\n        [ 0, 1, 0,-1],\n        [ 0, 0, 0, 0],\n        [ 0,-1, 0, 1]\n    ])\n\n    return G.T*Kle*G\n\ndef bar2s(ex,ey,ep,ed):\n    """"""\n    Compute normal force in two dimensional bar element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ep: element properties [E, A], E - Young\'s modulus, A - Cross section area\n    :param list ed: element displacements [u1, u2, u3, u4]    \n    :return float N: element foce [N]    \n    """"""\n    E=ep[0]\n    A=ep[1]\n    \n    b = np.mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = np.asscalar(np.sqrt(b.T*b))\n    \n    #Kle = np.mat([[1.,-1.],[-1.,1.]])*E*A/L\n    \n    n = np.asarray(b.T/L).reshape(2,) \n    \n    G = np.mat([\n        [n[0],n[1],0.,0.],\n        [0.,0.,n[0],n[1]]\n    ])\n    \n    u=np.asmatrix(ed).T\n    N=E*A/L*np.mat([[-1.,1.]])*G*u\n    return np.asscalar(N)\n    \ndef bar3e(ex,ey,ez,ep):\n    """"""\n    Compute element stiffness matrix for three dimensional bar element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ez: element z coordinates [z1, z2]\n    :param list ep: element properties [E, A], E - Young\'s modulus, A - Cross section area\n    :return mat Ke: stiffness matrix, [6 x 6]\n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    \n    n = np.asarray(b.T/L).reshape(3)\n\n    G = np.mat([\n        [ n[0], n[1], n[2], 0.,   0.,   0.  ],\n        [ 0.,   0.,   0.,   n[0], n[1], n[2]]\n    ])\n    \n    Kle = E*A/L*np.mat([\n        [ 1,-1],\n        [-1, 1]\n    ])\n\n    return G.T*Kle*G\n\ndef bar3s(ex,ey,ez,ep,ed):\n    """"""\n    Compute normal force in three dimensional bar element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ez: element z coordinates [z1, z2]\n    :param list ep: element properties [E, A], E - Young\'s modulus, A - Cross section area   \n    :param list ed: element displacements [u1, ..., u6]\n    :return float N: normal force\n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    \n    n = np.asarray(b.T/L).reshape(3)\n\n    G = np.mat([\n        [ n[0], n[1], n[2], 0.  , 0.  , 0.  ],\n        [ 0.  , 0.  , 0.  , n[0], n[1], n[2]]\n    ])\n    \n    #Kle = E*A/L*np.mat([\n    #    [ 1,-1],\n    #    [-1, 1]\n    #])\n\n    u = np.asmatrix(ed).T\n    N = E*A/L*np.mat([[-1.,1.]])*G*u\n\n    return np.asscalar(N)\n\ndef beam2e(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional beam element.\n    \n    :param list ex: element x coordinates [x1, x2]\n    :param list ey: element y coordinates [y1, y2]\n    :param list ep: element properties [E, A, I], E - Young\'s modulus, A - Cross section area, I - Moment of inertia   \n    :param list eq: distributed loads, local directions [qx, qy]\n    :return mat Ke: element stiffness matrix [6 x 6]\n    :return mat fe: element stiffness matrix [6 x 1] (if eq!=None)\n    """"""\n\n    b=np.mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b.T/L).reshape(2,) \n    \n    E=ep[0]\n    A=ep[1]\n    I=ep[2]\n    \n    qx=0.\n    qy=0.\n    if not eq is None:\n        qx=eq[0]\n        qy=eq[1]\n        \n    Kle = np.mat([\n        [E*A/L,      0.,          0.,    -E*A/L,    0.,        0.      ],\n        [  0.,    12*E*I/L**3., 6*E*I/L**2.,    0., -12*E*I/L**3., 6*E*I/L**2. ],\n        [  0.,    6*E*I/L**2.,  4*E*I/L,      0., -6*E*I/L**2.,  2*E*I/L   ],\n        [-E*A/L,     0.,          0.,     E*A/L,    0.,        0.      ],\n        [  0.,   -12*E*I/L**3.,-6*E*I/L**2.,    0.,  12*E*I/L**3.,-6*E*I/L**2. ],\n        [  0.,    6*E*I/L**2.,  2*E*I/L,      0.,  -6*E*I/L**2., 4*E*I/L   ]\n    ])\n     \n    fle=L*np.mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n     \n    G=np.mat([\n        [ n[0], n[1],  0.,    0.,    0.,   0.],\n        [-n[1], n[0],  0.,    0.,    0.,   0.],\n        [0.,    0.,    1.,    0.,    0.,   0.],\n        [0.,    0.,    0.,   n[0],  n[1],  0.],\n        [0.,    0.,    0.,  -n[1],  n[0],  0.],\n        [0.,    0.,    0.,    0.,    0.,   1.]\n    ])\n    \n    Ke=G.T*Kle*G\n    fe=G.T*fle\n    \n    if eq is None:\n        return Ke\n    else:\n        return Ke,fe\n    \ndef beam2s(ex,ey,ep,ed,eq=None,nep=None):\n    """"""\n    Compute section forces in two dimensional beam element (beam2e).\n    \n    Parameters:\n \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n\n        ep = [E A I]        element properties,\n                            E:  Young\'s modulus\n                            A:  cross section area\n                            I:  moment of inertia\n\n        ed = [u1 ... u6]    element displacements\n\n        eq = [qx qy]        distributed loads, local directions \n\n        nep                 number of evaluation points ( default=2 )\n        \n    Returns:\n          \n        es = [ N1 V1 M1     section forces, local directions, in \n               N2 V2 M2     n points along the beam, dim(es)= n x 3\n               .........]  \n           \n        edi = [ u1 v1       element displacements, local directions,\n                u2 v2       in n points along the beam, dim(es)= n x 2\n                .......]    \n\n            eci = [ x1      local x-coordinates of the evaluation \n                    x2      points, (x1=0 and xn=L)\n                    ...]\n    \n    """"""\n    EA=ep[0]*ep[1]\n    EI=ep[0]*ep[2]\n    b=np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    \n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b.T/L).reshape(2,)\n    \n    qx=0.\n    qy=0.\n    \n    if not eq is None:\n        qx=eq[0]\n        qy=eq[1] \n      \n    ne=2\n    \n    if nep!=None:\n        ne = nep\n        \n    C=np.mat([\n        [0.,   0.,   0.,    1.,   0.,   0.],\n        [0.,   0.,   0.,    0.,   0.,   1.],\n        [0.,   0.,   0.,    0.,   1.,   0.],\n        [L,   0.,   0.,    1.,   0.,   0.],\n        [0.,   L**3, L**2,   0.,   L,    1.],\n        [0., 3*L**2, 2*L,   0.,   1.,   0.]\n    ])\n   \n    G=np.mat([\n        [ n[0], n[1],  0.,    0.,    0.,   0.],\n        [-n[1], n[0],  0.,    0.,    0.,   0.],\n        [0.,    0.,    1.,    0.,    0.,   0.],\n        [0.,    0.,    0.,   n[0],  n[1],  0.],\n        [0.,    0.,    0.,  -n[1],  n[0],  0.],\n        [0.,    0.,    0.,    0.,    0.,   1.]\n    ])\n    \n    M=np.ravel(C.I*(G*np.asmatrix(ed).T-np.matrix([0., 0., 0., -qx*L**2/(2*EA), qy*L**4/(24*EI), qy*L**3/(6*EI)]).T))\n    A=np.matrix([M[0],M[3]]).T\n    B=np.matrix([M[1],M[2],M[4],M[5]]).T\n    \n    x=np.asmatrix(np.arange(0.,L+L/(ne-1),L/(ne-1))).T\n    zero=np.asmatrix(np.zeros([len(x)])).T\n    one=np.asmatrix(np.ones([len(x)])).T\n    \n    u=np.concatenate((x,one),1)*A-np.power(x,2)*qx/(2*EA)\n    du=np.concatenate((one,zero),1)*A-x*qx/EA\n    v=np.concatenate((np.power(x,3),np.power(x,2),x,one),1)*B+np.power(x,4)*qy/(24*EI)\n    d2v=np.concatenate((6*x,2*one,zero,zero),1)*B+np.power(x,2)*qy/(2*EI)\n    d3v=np.concatenate((6*one,zero,zero,zero),1)*B+x*qy/EI\n    \n    N=EA*du\n    M=EI*d2v\n    V=-EI*d3v\n    edi=np.concatenate((u,v),1)\n    eci=x\n    es=np.concatenate((N,V,M),1)\n    \n    return (es,edi,eci)\n\ndef beam2t(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional elastic\n    Timoshenko beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n    \n        ep = [E G A I ks]   element properties\n                              E: Young\'s modulus\n                              G: Shear modulus\n                              A: Cross section area\n                              I: Moment of inertia\n                             ks: Shear correction factor\n    \n        eq = [qx qy]        distributed loads, local directions\n        \n    Returns:\n     \n        Ke                  element stiffness matrix (6 x 6)\n    \n        fe                  element load vector (6 x 1)\n    \n    """"""\n\n    b = np.mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b.T/L).reshape(2)\n    \n    E = ep[0]\n    Gm = ep[1]\n    A = ep[2]\n    I = ep[3]\n    ks = ep[4]\n        \n    qx = 0.\n    qy = 0.\n    if eq != None:\n        qx = eq[0]\n        qy = eq[1]\n    \n    m = (12/L**2)*(E*I/(Gm*A*ks))\n    \n    Kle = E/(1+m)*np.mat([\n        [A*(1+m)/L,      0.,         0.,        -A*(1+m)/L,     0.,          0.      ],\n        [0.,         12*I/L**3., 6*I/L**2.,         0.,    -12*I/L**3., 6*I/L**2.    ],\n        [0.,         6*I/L**2.,  4*I*(1+m/4.)/L,    0.,    -6*I/L**2.,  2*I*(1-m/2)/L],\n        [-A*(1+m)/L,     0.,         0.,         A*(1+m)/L,     0.,          0.      ],\n        [0.,        -12*I/L**3.,-6*I/L**2.,         0.,     12*I/L**3.,-6*I/L**2.    ],\n        [0.,         6*I/L**2.,  2*I*(1-m/2)/L,     0.,    -6*I/L**2.,  4*I*(1+m/4)/L]\n    ])\n\n    fle = L*np.mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n    \n    G = np.mat([\n        [ n[0], n[1],  0.,   0.,   0.,   0.],\n        [-n[1], n[0],  0.,   0.,   0.,   0.],\n        [  0.,   0.,   1.,   0.,   0.,   0.],\n        [  0.,   0.,   0.,  n[0], n[1],  0.],\n        [  0.,   0.,   0., -n[1], n[0],  0.],\n        [  0.,   0.,   0.,   0.,   0.,   1.]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef beam2ts(ex,ey,ep,ed,eq=None,np=None):\n    """"""\n    Compute section forces in two dimensional beam element (beam2e).\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]       element node coordinates\n\n        ep = [E,G,A,I,ks]   element properties,\n                              E:  Young\'s modulus\n                              G:  shear modulus\n                              A:  cross section area\n                              I:  moment of inertia\n\n        ed = [u1, ... ,u6]  element displacements\n\n        eq = [qx, qy]       distributed loads, local directions \n\n        n                   number of evaluation points ( default=2 )\n        \n    Returns:\n          \n        es = [[N1,V1,M1],   section forces, local directions, in \n              [N2,V2,M2],   n points along the beam, dim(es)= n x 3\n              ..........]  \n    \n        edi = [[u1,v1,teta1],   element displacements, local directions,\n               [u2,v2,teta2],   and rotation of cross section at\n               .............]   in n points along the beam, dim(es)= n x 2\n    \n    (Note! Rotation of the cross section is not equal to dv/dx for Timoshenko beam element)\n    \n        eci = [[x1],    local x-coordinates of the evaluation \n               [x2],    points, (x1=0 and xn=L)\n               ....]\n    \n    """"""\n    EA = ep[0]*ep[2]\n    EI = ep[0]*ep[3]\n    GAK = ep[1]*ep[2]*ep[4]\n    alfa = EI/GAK\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b.T/L).reshape(2)\n    \n    qx = 0.\n    qy = 0.\n    if eq != None:\n        qx = eq[0]\n        qy = eq[1] \n      \n    ne = 2\n    \n    if np != None:\n        ne = np\n        \n    C = np.mat([\n        [ 0., 0.,              0.,   1., 0., 0.],\n        [ 0., 0.,              0.,   0., 0., 1.],\n        [ 0., 6*alfa,          0.,   0., 1., 0.],\n        [ L,  0.,              0.,   1., 0., 0.],\n        [ 0., L**3,            L**2, 0., L,  1.],\n        [ 0., 3*(L**2+2*alfa), 2*L,  0., 1., 0.]\n    ])\n   \n    G = np.mat([\n        [ n[0], n[1], 0., 0.,   0.,   0.],\n        [-n[1], n[0], 0., 0.,   0.,   0.],\n        [ 0.,   0.,   1., 0.,   0.,   0.],\n        [ 0.,   0.,   0., n[0], n[1], 0.],\n        [ 0.,   0.,   0.,-n[1], n[0], 0.],\n        [ 0.,   0.,   0., 0.,   0.,   1.]\n    ])\n    \n    M = np.ravel(C.I*(G*np.asmatrix(ed).T-np.mat([0., 0., 0., -qx*L**2/(2*EA), qy*L**4/(24*EI)-qy*L**2/(2*GAK), qy*L**3/(6*EI)]).T))\n    C2 = np.mat([M[0], M[3]]).T\n    C4 = np.mat([M[1], M[2], M[4], M[5]]).T\n    \n    x = np.asmatrix(np.arange(0., L+L/(ne-1), L/(ne-1))).T\n    zero = np.asmatrix(np.zeros([len(x)])).T\n    one = np.asmatrix(np.ones([len(x)])).T\n    \n    u = np.concatenate((x,one),1)*C2-qx/(2*EA)*np.power(x,2)\n    du = np.concatenate((one,zero),1)*C2-qx*x/EA\n    \n    v = np.concatenate((np.power(x,3),np.power(x,2),x,one),1)*C4+qy/(24*EI)*np.np.power(x,4)-qy/(2*GAK)*np.power(x,2)\n    dv = np.concatenate((3*np.power(x,2),2*x,one,zero),1)*C4+qy*np.power(x,3)/(6*EI)-qy*x/GAK\n    \n    teta = np.concatenate((3*(np.power(x,2)+2*alfa*one),2*x,one,zero),1)*C4+qy*np.power(x,3)/(6*EI)\n    dteta = np.concatenate((6*x,2*one,zero,zero),1)*C4+qy*np.power(x,2)/(2*EI)\n    \n    N = EA*du\n    M = EI*dteta\n    V = GAK*(dv-teta)\n    \n    es = np.concatenate((N,V,M),1)\n    edi = np.concatenate((u,v,teta),1)\n    eci = x\n\n    if np != None:\n        return es,edi,eci\n    else:\n        return es\n\ndef beam2w(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional beam element\n    on elastic foundation.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]       element node coordinates\n\n        ep = [E,A,I,ka,kt]  element properties,\n                              E:  Young\'s modulus\n                              A:  cross section area\n                              I:  moment of inertia\n                             ka:  axial foundation stiffness\n                             kt:  transversal foundation stiffness\n\n        eq = [qx, qy]       distributed loads, local directions\n\n    Returns:\n\n        Ke                  beam stiffness matrix (6 x 6)\n        \n        fe                  element load vector (6 x 1)\n    """"""\n    b = np.mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b/L).reshape(2)\n    \n    E,A,I,ka,kt = ep\n    \n    qx = 0\n    qy = 0\n    if eq != None:\n        qx,qy = eq\n    \n    K1 = np.mat([\n        [ E*A/L,  0,           0,         -E*A/L, 0,           0         ],\n        [ 0,      12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,      6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L,  0,           0,          E*A/L, 0,           0         ],\n        [ 0,     -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,      6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n        ])\n    \n    K2 = L/420*np.mat([\n        [ 140*ka, 0,       0,         70*ka,  0,       0        ],\n        [ 0,      156*kt,  22*kt*L,   0,      54*kt,  -13*kt*L  ],\n        [ 0,      22*kt*L, 4*kt*L**2, 0,      13*kt*L,-3*kt*L**2],\n        [ 70*ka,  0,       0,         140*ka, 0,       0        ],\n        [ 0,      54*kt,   13*kt*L,   0,      156*kt, -22*kt*L  ],\n        [ 0,     -13*kt*L,-3*kt*L**2, 0,     -22*kt*L, 4*kt*L**2]\n    ])\n    \n    Kle = K1+K2\n    fle = L*np.mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n\n    G = np.mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq != None:\n        return Ke,fe\n    else:\n        return Ke\n    \ndef beam2ws(ex,ey,ep,ed,eq=None):\n    """"""\n    Compute section forces in a two dimensional beam element\n    on elastic foundation.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I,ka,kt]      element properties,\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n                                 ka:  axial foundation stiffness\n                                 kt:  transversal foundation stiffness\n\n        ed = [u1, ... ,u6]      element displacement vector\n\n        eq = [qx, qy]           distributed loads, local directions\n\n    Returns:\n\n        es = [[N1, V1, M1],\n              [N2, V2, M2]]     element forces, local direction\n    """"""\n    if np.asmatrix(ed).shape[0] > 1:\n        cferror(""Only one row is allowed in the ed matrix !!!"")\n        return\n\n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b/L).reshape(2,)\n    \n    E,A,I,ka,kt = ep\n    \n    qx = 0\n    qy = 0\n    if eq != None:\n        qx,qy = eq\n    \n    K1 = np.mat([\n        [ E*A/L, 0,           0,         -E*A/L, 0,           0         ],\n        [ 0,     12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L, 0,           0,          E*A/L, 0,           0         ],\n        [ 0,    -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n        ])\n    \n    K2 = L/420*np.mat([\n        [ 140*ka, 0,       0,         70*ka,  0,       0        ],\n        [ 0,      156*kt,  22*kt*L,   0,      54*kt,  -13*kt*L  ],\n        [ 0,      22*kt*L, 4*kt*L**2, 0,      13*kt*L,-3*kt*L**2],\n        [ 70*ka,  0,       0,         140*ka, 0,       0        ],\n        [ 0,      54*kt,   13*kt*L,   0,      156*kt, -22*kt*L  ],\n        [ 0,     -13*kt*L,-3*kt*L**2, 0,     -22*kt*L, 4*kt*L**2]\n    ])\n    \n    Kle = K1+K2\n    fle = L*np.mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n    \n    G = np.mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n\n    P = Kle*G*np.asmatrix(ed).T-fle\n\n    es = np.mat([\n        [-P[0,0],-P[1,0],-P[2,0]],\n        [ P[3,0], P[4,0], P[5,0]]\n    ])\n    \n    return es\n\ndef beam2g(ex,ey,ep,N,eq=None):\n    """"""\n    Compute the element stiffness matrix for a two dimensional\n    beam element with respect to geometric nonlinearity.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I]            element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n\n        N                       axial force in the beam\n\n        eq                      distributed transverse load\n\n    Returns:\n\n        Ke                      element stiffness matrix (6 x 6)\n        \n        fe                      element load vector (6 x 1)\n    """"""\n    if eq != None:\n        if np.size(eq) > 1:\n            cferror(""eq should be a scalar !!!"")\n            return\n        else:\n            q = eq[0]\n    else:\n        q = 0\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b/L).reshape(2,)\n    \n    E,A,I = ep\n    \n    rho = -N*L**2/(np.pi**2*E*I)\n    \n    kL = np.pi*np.sqrt(abs(rho))+np.finfo(float).eps\n\n    if rho > 0:\n        f1 = (kL/2)/np.tan(kL/2)\n        f2 = (1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = 6*(2/kL**2-(1+np.cos(kL))/(kL*np.sin(kL)))\n    elif rho < 0:\n        f1 = (kL/2)/np.tanh(kL/2)\n        f2 = -(1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = -6*(2/kL**2-(1+np.cosh(kL))/(kL*np.sinh(kL)))\n    else:\n        f1 = f2 = f3 = f4 = f5 = h = 1\n\n    Kle = np.mat([\n        [ E*A/L, 0.,              0.,            -E*A/L, 0.,              0.            ],\n        [ 0.,    12*E*I*f5/L**3., 6*E*I*f2/L**2., 0.,   -12*E*I*f5/L**3., 6*E*I*f2/L**2.],\n        [ 0.,    6*E*I*f2/L**2.,  4*E*I*f3/L,     0.,   -6*E*I*f2/L**2.,  2*E*I*f4/L    ],\n        [-E*A/L, 0.,              0.,             E*A/L, 0.,              0.            ],\n        [ 0.,   -12*E*I*f5/L**3.,-6*E*I*f2/L**2., 0.,    12*E*I*f5/L**3.,-6*E*I*f2/L**2.],\n        [ 0.,    6*E*I*f2/L**2.,  2*E*I*f4/L,     0.,   -6*E*I*f2/L**2.,  4*E*I*f3/L    ]\n    ])\n\n    fle = q*L*np.mat([0.,1/2.,L*h/12,0.,1/2.,-L*h/12]).T\n    \n    G = np.mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n\n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq != None:\n        return Ke,fe\n    else:\n        return Ke\n    \ndef beam2gs(ex,ey,ep,ed,N,eq=None):\n    """"""\n    Calculate section forces in a two dimensional nonlinear\n    beam element.\n\n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I]            element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n\n        ed = [u1, ... ,u6]      element displacement vector\n\n        N                       axial force\n\n        eq = [qy]               distributed transverse load\n\n    Returns:\n\n        es = [[N1,V1,M1],       element forces, local directions\n              [N2,V2,M2]]\n    """"""\n    if eq != None:\n        eq = eq[0]\n    else:\n        eq = 0\n    \n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b/L).reshape(2,)\n    \n    E,A,I = ep\n    \n    rho = -N*L**2/(np.pi**2*E*I)\n    \n    eps = 2.2204e-16\n    kL = np.pi*np.sqrt(abs(rho))+eps\n\n    if rho > 0:\n        f1 = (kL/2)/np.tan(kL/2)\n        f2 = (1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = 6*(2/kL**2-(1+np.cos(kL))/(kL*np.sin(kL)))\n    elif rho < 0:\n        f1 = (kL/2)/np.tanh(kL/2)\n        f2 = -(1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = -6*(2/kL**2-(1+np.cosh(kL))/(kL*np.sinh(kL)))\n    else:\n        f1 = f2 = f3 = f4 = f5 = h = 1\n    \n    Kle = np.mat([\n        [ E*A/L, 0,              0,            -E*A/L, 0,              0            ],\n        [ 0,     12*E*I*f5/L**3, 6*E*I*f2/L**2, 0,    -12*E*I*f5/L**3, 6*E*I*f2/L**2],\n        [ 0,     6*E*I*f2/L**2,  4*E*I*f3/L,    0,    -6*E*I*f2/L**2,  2*E*I*f4/L   ],\n        [-E*A/L, 0,              0,             E*A/L, 0,              0            ],\n        [ 0,    -12*E*I*f5/L**3,-6*E*I*f2/L**2, 0,     12*E*I*f5/L**3,-6*E*I*f2/L**2],\n        [ 0,     6*E*I*f2/L**2,  2*E*I*f4/L,    0,    -6*E*I*f2/L**2,  4*E*I*f3/L   ]\n    ])\n\n    fle = eq*L*np.mat([0,1/2.,L*h/12,0,1/2.,-L*h/12]).T\n    \n    G = np.mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    u = np.asmatrix(ed).T\n    P = Kle*G*u-fle\n\n    es = np.mat([\n        [-P[0,0],-P[1,0],-P[2,0]],\n        [ P[3,0], P[4,0], P[5,0]]\n    ])\n    \n    return es\n\ndef beam2d(ex,ey,ep):\n    """"""\n    Calculate the stiffness matrix Ke, the mass matrix Me\n    and the damping matrix Ce for a 2D elastic Bernoulli\n    beam element.\n\n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I,m,(a,b)]    element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n                                  m:  mass per unit length\n                                a,b:  damping coefficients,\n                                      Ce=aMe+bKe\n\n    Returns:\n\n        Ke                      element stiffness matrix (6 x 6)\n        Me                      element mass martix\n        Ce                      element damping matrix, optional\n    """"""\n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n = np.asarray(b/L).reshape(2,)\n    \n    a = 0\n    b = 0\n    if np.size(ep) == 4:\n        E,A,I,m = ep\n    elif np.size(ep) == 6:\n        E,A,I,m,a,b = ep\n    \n    Kle = np.mat([\n        [ E*A/L, 0,           0,         -E*A/L, 0,           0         ],\n        [ 0,     12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L, 0,           0,          E*A/L, 0,           0         ],\n        [ 0,    -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n    ])\n\n    Mle = m*L/420*np.mat([\n        [ 140, 0,    0,      70,  0,    0     ],\n        [ 0,   156,  22*L,   0,   54,  -13*L  ],\n        [ 0,   22*L, 4*L**2, 0,   13*L,-3*L**2],\n        [ 70,  0,    0,      140, 0,    0     ],\n        [ 0,   54,   13*L,   0,   156, -22*L  ],\n        [ 0,  -13*L,-3*L**2, 0,  -22*L, 4*L**2]\n    ])\n    \n    Cle = a*Mle+b*Kle\n\n    G = np.mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    Ke = G.T*Kle*G\n    Me = G.T*Mle*G\n    Ce = G.T*Cle*G\n    \n    if np.size(ep) == 4:\n        return Ke,Me\n    elif np.size(ep) == 6:\n        return Ke,Me,Ce\n\ndef beam3e(ex,ey,ez,eo,ep,eq=None):\n    """"""\n    Calculate the stiffness matrix for a 3D elastic Bernoulli\n    beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]\n        ey = [y1 y2]\n        ez = [z1 z2]            element node coordinates\n        \n        eo = [xz yz zz]         orientation of local z axis\n        \n        ep = [E G A Iy Iz Kv]   element properties\n                                  E: Young\'s modulus\n                                  G: Shear modulus\n                                  A: Cross section area\n                                 Iy: Moment of inertia, local y-axis\n                                 Iz: Moment of inertia, local z-axis\n                                 Kv: Saint-Venant\'s torsion constant\n    \n        eq = [qx qy qz qw]      distributed loads\n\n    Returns:\n\n        Ke                      beam stiffness matrix (12 x 12)\n\n        fe                      equivalent nodal forces (12 x 1)\n\n    """"""\n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n        ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n1 = np.asarray(b.T/L).reshape(3,)\n    \n    eo = np.asmatrix(eo)\n    lc = np.asscalar(np.sqrt(eo*eo.T))\n    n3 = np.asarray(eo/lc).reshape(3,)\n    \n    E,Gs,A,Iy,Iz,Kv = ep\n\n    qx = 0.\n    qy = 0.\n    qz = 0.\n    qw = 0.\n    if eq != None:\n        qx,qy,qz,qw = eq\n\n    a = E*A/L\n    b = 12*E*Iz/L**3\n    c = 6*E*Iz/L**2\n    d = 12*E*Iy/L**3\n    e = 6*E*Iy/L**2\n    f = Gs*Kv/L\n    g = 2*E*Iy/L\n    h = 2*E*Iz/L\n\n    Kle = np.mat([\n        [ a, 0, 0, 0, 0,   0,  -a, 0, 0, 0, 0,   0  ],\n        [ 0, b, 0, 0, 0,   c,   0,-b, 0, 0, 0,   c  ],\n        [ 0, 0, d, 0,-e,   0,   0, 0,-d, 0,-e,   0  ],\n        [ 0, 0, 0, f, 0,   0,   0, 0, 0,-f, 0,   0  ],\n        [ 0, 0,-e, 0, 2*g, 0,   0, 0, e, 0, g,   0  ],\n        [ 0, c, 0, 0, 0,   2*h, 0,-c, 0, 0, 0,   h  ],\n        [-a, 0, 0, 0, 0,   0,   a, 0, 0, 0, 0,   0  ],\n        [ 0,-b, 0, 0, 0,  -c,   0, b, 0, 0, 0,  -c  ],\n        [ 0, 0,-d, 0, e,   0,   0, 0, d, 0, e,   0  ],\n        [ 0, 0, 0,-f, 0,   0,   0, 0, 0, f, 0,   0  ],\n        [ 0, 0,-e, 0, g,   0,   0, 0, e, 0, 2*g, 0  ],\n        [ 0, c, 0, 0, 0,   h,   0,-c, 0, 0, 0,   2*h]\n    ])\n\n    fle = L/2*np.mat([qx, qy, qz, qw, -qz*L/6, qy*L/6, qx, qy, qz, qw, qz*L/6, -qy*L/6]).T\n\n    n2 = np.array([0.,0.,0.])\n    n2[0] = n3[1]*n1[2]-n3[2]*n1[1]\n    n2[1] = -n1[2]*n3[0]+n1[0]*n3[2]\n    n2[2] = n3[0]*n1[1]-n1[0]*n3[1]\n\n    #An = np.append([n1,n2],[n3],0)\n\n    G = np.mat([\n        [ n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2]]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef beam3s(ex,ey,ez,eo,ep,ed,eq=None,n=None):\n    """"""\n    Calculate the variation of the section forces and displacements\n    along a three-dimensional beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]                element node coordinates\n        ey = [y1 y2]\n        ez = [z1 z2]\n\n        eo = [xz yz zz]             orientation of local z axis\n        \n        ep = [E G A Iy Iz Kv]       element properties\n                                      E: Young\'s modulus\n                                      G: Shear modulus\n                                      A: Cross section area\n                                     Iy: Moment of inertia, local y-axis\n                                     Iz: Moment of inertia, local z-axis\n                                     Kv: Saint-Venant\'s torsion constant\n\n        ed                          the element displacement vector from the\n                                    global coordinate system\n    \n        eq = [qx qy qz qw]          the disibuted axial, transversal and\n                                    torsional loads\n\n        n                           the number of point in which displacements\n                                    and section forces are to be computed\n\n    Returns:\n\n        es = [[N1,Vy1,Vz1,T1,My1,Mz1],  section forces in n points along\n              [N2,Vy2,Vz2,T2,My2,Mz2],  the local x-axis\n              [..,...,...,..,...,...],\n              [Nn,Vyn,Vzn,Tn,Myn,Mzn]]\n\n        edi = [[u1,v1,w1,fi1],          displacements in n points along\n               [u2,v2,w2,fi2],          the local x-axis\n               [..,..,..,...],\n               [un,vn,wn,fin]]\n\n        eci = [[x1],                    local x-coordinates of the evaluation\n               [x2],                    points\n               [..],\n               [xn]]\n\n    """"""\n    b = np.mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = np.asscalar(np.sqrt(b.T*b))\n    n1 = np.asarray(b.T/L).reshape(3,)\n    \n    eo = np.asmatrix(eo)\n    lc = np.asscalar(np.sqrt(eo*eo.T))\n    n3 = np.asarray(eo/lc).reshape(3,)\n\n    EA = ep[0]*ep[2]\n    EIy = ep[0]*ep[3]\n    EIz = ep[0]*ep[4]\n    GKv = ep[1]*ep[5]\n\n    qx = 0.\n    qy = 0.\n    qz = 0.\n    qw = 0.\n    if eq != None:\n        qx,qy,qz,qw = eq\n\n    ne = 2\n    if n != None:\n        ne = n\n        \n    n2 = np.array([0.,0.,0.])\n    n2[0] = n3[1]*n1[2]-n3[2]*n1[1]\n    n2[1] = -n1[2]*n3[0]+n1[0]*n3[2]\n    n2[2] = n3[0]*n1[1]-n1[0]*n3[1]\n\n    G = np.mat([\n        [ n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2]]\n    ])\n\n    u = G*np.asmatrix(ed).T-np.array([    # u is the local element displacement\n        [ 0               ],        # vector minus the particular solution\n        [ 0               ],        # to the beam\'s diff.eq:s\n        [ 0               ],\n        [ 0               ],\n        [ 0               ],\n        [ 0               ],\n        [-qx*L**2/(2*EA)  ],\n        [ qy*L**4/(24*EIz)],\n        [ qz*L**4/(24*EIy)],\n        [-qw*L**2/(2*GKv) ],\n        [-qz*L**3/(6*EIy) ],\n        [ qy*L**3/(6*EIz) ]\n    ])\n\n    C = np.mat([\n        [ 0, 1, 0,      0,    0, 0, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 1, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 1, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 0, 0, 1],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,   -1, 0, 0, 0],\n        [ 0, 0, 0,      0,    1, 0, 0,      0,    0, 0, 0, 0],\n        [ L, 1, 0,      0,    0, 0, 0,      0,    0, 0, 0, 0,],\n        [ 0, 0, L**3,   L**2, L, 1, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, L**3,   L**2, L, 1, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 0, L, 1],\n        [ 0, 0, 0,      0,    0, 0,-3*L**2,-2*L, -1, 0, 0, 0],\n        [ 0, 0, 3*L**2, 2*L,  1, 0, 0,      0,    0, 0, 0, 0],\n    ])\n\n    m = np.linalg.inv(C)*u\n    eci = np.zeros((ne,1))\n    es = np.zeros((ne,6))\n    edi = np.zeros((ne,4))\n    for i in np.arange(ne):\n        x = i*L/(ne-1)\n        eci[i,0] = x\n        es[i,:] = (np.mat([\n            [ EA, 0, 0,       0,     0, 0, 0,       0,     0, 0, 0,   0],\n            [ 0,  0,-6*EIz,   0,     0, 0, 0,       0,     0, 0, 0,   0],\n            [ 0,  0, 0,       0,     0, 0,-6*EIy,   0,     0, 0, 0,   0],\n            [ 0,  0, 0,       0,     0, 0, 0,       0,     0, 0, GKv, 0],\n            [ 0,  0, 0,       0,     0, 0,-6*EIy*x,-2*EIy, 0, 0, 0,   0],\n            [ 0,  0, 6*EIz*x, 2*EIz, 0, 0, 0,       0,     0, 0, 0,   0]\n        ])*m+np.array([-qx*x,-qy*x,-qz*x,-qw*x,-qz*x**2/2,qy*x**2/2]).reshape(6,1)).T\n\n        edi[i,:] = (np.mat([\n            [ x, 1, 0,    0,    0, 0, 0,    0,    0, 0, 0, 0],\n            [ 0, 0, x**3, x**2, x, 1, 0,    0,    0, 0, 0, 0],\n            [ 0, 0, 0,    0,    0, 0, x**3, x**2, x, 1, 0, 0],\n            [ 0, 0, 0,    0,    0, 0, 0,    0,    0, 0, x, 1]\n        ])*m+np.array([-qx*x**2/(2*EA),qy*x**4/(24*EIz),qz*x**4/(24*EIy),-qw*x**2/(2*GKv)]).reshape(4,1)).T\n    \n    if n == None:\n        return es\n    else:\n        return es,edi,eci\n    \ndef flw2te(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity) matrix for a triangular field element.\n    \n    Parameters:\n    \n        ex = [x1 x2 x3]\n        ey = [y1 y2 y3]     element coordinates\n    \n        ep = [t]            element thickness    \n\n        D = [kxx kxy;\n             kyx kyy]       constitutive matrix\n    \n             eq             heat supply per unit volume\n             \n    Returns:\n    \n        Ke                  element \'stiffness\' matrix (3 x 3)\n\n        fe                  element load vector (3 x 1)\n    \n    """"""\n    t=ep[0];\n    if eq==None:\n        eq=0.\n    \n    exm = np.asmatrix(ex)\n    eym = np.asmatrix(ey)\n    C=np.asmatrix(np.hstack([np.ones((3,1)),exm.T,eym.T]))\n    B=np.matrix([\n        [0.,1.,0.],\n        [0.,0.,1.]\n    ])*C.I\n    A=0.5*np.linalg.det(C)\n  \n    Ke=B.T*D*B*t*A\n    fe=np.matrix([[1.,1.,1.]]).T*eq*A*t/3\n       \n    if eq==0.:\n        return Ke\n    else:\n        return Ke, fe\n    \ndef flw2ts(ex,ey,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the triangular field element.\n    \n    Parameters:\n    \n        ex = [x1 x2 x3]\n        ey = [y1 y2 y3]         element coordinates\n                                 \n             D = [kxx kxy\n                  kyx kyy]      constitutive matrix\n    \n             ed =[u1 u2 u3]     u1,u2,u3: nodal values\n                  .. .. ..;\n                  \n    Returns:\n    \n        es=[ qx qy ] \n             ... ..]                element flows\n    \n        et=[ gx gy ]\n             ... ..]                element gradients\n    \n    """"""\n\n    if len(ex.shape)>1:\n        qs = np.zeros([ex.shape[0],2])\n        qt = np.zeros([ex.shape[0],2])\n        row = 0\n        for exr, eyr, edr in zip(ex, ey, ed):\n            exm = np.asmatrix(exr)\n            eym = np.asmatrix(eyr)\n            edm = np.asmatrix(edr)\n            C=np.asmatrix(np.hstack([np.ones((3,1)),exm.T,eym.T]))\n            B=np.matrix([\n                [0.,1.,0.],\n                [0.,0.,1.]\n            ])*C.I\n\n            qs[row,:]=(-D*B*edm.T).T\n            qt[row,:]=(B*edm.T).T\n            row += 1\n\n        return qs, qt\n    else:\n        exm = np.asmatrix(ex)\n        eym = np.asmatrix(ey)\n        edm = np.asmatrix(ed)\n        C=np.asmatrix(np.hstack([np.ones((3,1)),exm.T,eym.T]))\n        B=np.matrix([\n            [0.,1.,0.],\n            [0.,0.,1.]\n        ])*C.I\n\n        qs=-D*B*edm.T\n        qt=B*edm.T\n    \n        return qs.T, qt.T\n\ndef flw2qe(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity) matrix for a triangular field element.\n    \n    Parameters:\n    \n        ex = [x1, x2, x3, x4]\n        ey = [y1, y2, y3, y4]   element coordinates\n    \n        ep = [t]                element thickness    \n\n        D = [[kxx, kxy],\n             [kyx, kyy]]        constitutive matrix\n    \n        eq                      heat supply per unit volume\n             \n    Returns:\n    \n        Ke                      element \'stiffness\' matrix (4 x 4)\n\n        fe                      element load vector (4 x 1)\n    \n    """"""\n    xc = sum(ex)/4.\n    yc = sum(ey)/4.\n\n    K = np.zeros((5,5))\n    f = np.zeros((5,1))\n    \n    if eq == None:\n        k1 = flw2te([ex[0],ex[1],xc],[ey[0],ey[1],yc],ep,D)\n        K = assem(np.array([1,2,5]),K,k1)\n        k1 = flw2te([ex[1],ex[2],xc],[ey[1],ey[2],yc],ep,D)\n        K = assem(np.array([2,3,5]),K,k1)\n        k1 = flw2te([ex[2],ex[3],xc],[ey[2],ey[3],yc],ep,D)\n        K = assem(np.array([3,4,5]),K,k1)\n        k1 = flw2te([ex[3],ex[0],xc],[ey[3],ey[0],yc],ep,D)\n        K = assem(np.array([4,1,5]),K,k1)\n    else:\n        k1,f1 = flw2te([ex[0],ex[1],xc],[ey[0],ey[1],yc],ep,D,eq)    \n        K,f = assem(np.array([1,2,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[1],ex[2],xc],[ey[1],ey[2],yc],ep,D,eq)\n        K,f = assem(np.array([2,3,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[2],ex[3],xc],[ey[2],ey[3],yc],ep,D,eq)\n        K,f = assem(np.array([3,4,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[3],ex[0],xc],[ey[3],ey[0],yc],ep,D,eq)\n        K,f = assem(np.array([4,1,5]),K,k1,f,f1)\n    Ke1,fe1 = statcon(K,f,np.array([5]));\n\n    Ke = Ke1\n    fe = fe1\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef flw2qs(ex,ey,ep,D,ed,eq=None):\n    """"""\n    Compute flows or corresponding quantities in the\n    quadrilateral field element.\n    \n    Parameters:\n    \n        ex = [x1, x2, x3, x4]\n        ey = [y1, y2, y3, y4]      element coordinates\n    \n        ep = [t]                   element thickness    \n\n        D = [[kxx, kxy],\n             [kyx, kyy]]           constitutive matrix\n\n        ed = [[u1, u2, u3, u4],\n              [.., .., .., ..]]    u1,u2,u3,u4: nodal values\n    \n        eq                         heat supply per unit volume\n             \n    Returns:\n    \n        es = [[qx, qy],\n              [.., ..]]            element flows\n\n        et = [[gx, gy],\n              [.., ..]]            element gradients\n    \n    """"""\n    K = np.zeros((5,5))\n    f = np.zeros((5,1))\n    \n    xm = sum(ex)/4\n    ym = sum(ey)/4\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n    \n    En = np.array([\n        [1,2,5],\n        [2,3,5],\n        [3,4,5],\n        [4,1,5]\n    ])\n    ex1 = np.array([ex[0],ex[1],xm])\n    ey1 = np.array([ey[0],ey[1],ym])\n    ex2 = np.array([ex[1],ex[2],xm])\n    ey2 = np.array([ey[1],ey[2],ym])\n    ex3 = np.array([ex[2],ex[3],xm])\n    ey3 = np.array([ey[2],ey[3],ym])\n    ex4 = np.array([ex[3],ex[0],xm])\n    ey4 = np.array([ey[3],ey[0],ym])\n    \n    if eq == None:\n        k1 = flw2te(ex1,ey1,ep,D)\n        K = assem(En[0],K,k1)\n        k1 = flw2te(ex2,ey2,ep,D)\n        K = assem(En[1],K,k1)\n        k1 = flw2te(ex3,ey3,ep,D)\n        K = assem(En[2],K,k1)\n        k1 = flw2te(ex4,ey4,ep,D)\n        K = assem(En[3],K,k1)\n    else:\n        k1,f1 = flw2te(ex1,ey1,ep,D,q)\n        K,f = assem(En[0],K,k1,f,f1)\n        k1,f1 = flw2te(ex2,ey2,ep,D,q)\n        K,f = assem(En[1],K,k1,f,f1)\n        k1,f1 = flw2te(ex3,ey3,ep,D,q)\n        K,f = assem(En[2],K,k1,f,f1)\n        k1,f1 = flw2te(ex4,ey4,ep,D,q)\n        K,f = assem(En[3],K,k1,f,f1)\n    \n    if ed.ndim==1:\n        ed = np.array([ed])\n    \n    ni,nj = np.shape(ed)\n\n    a = np.zeros((5,ni))\n    for i in range(ni):\n        a[np.ix_(range(5),[i])],r = np.asarray(solveq(K,f,np.arange(1,5),ed[i]))\n\n    s1,t1 = flw2ts(ex1,ey1,D,a[np.ix_(En[0,:]-1,np.arange(ni))].T)\n    s2,t2 = flw2ts(ex2,ey2,D,a[np.ix_(En[1,:]-1,np.arange(ni))].T)\n    s3,t3 = flw2ts(ex3,ey3,D,a[np.ix_(En[2,:]-1,np.arange(ni))].T)\n    s4,t4 = flw2ts(ex4,ey4,D,a[np.ix_(En[3,:]-1,np.arange(ni))].T)\n    \n    es = (s1+s2+s3+s4)/4.\n    et = (t1+t2+t3+t4)/4.\n    \n    return es,et\n\ndef flw2i4e(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 4 node isoparametric field element\n\n    Parameters:\n        \n        ex = [x1 x2 x3 x4]  element coordinates\n        ey = [y1 y2 y3 y4]\n\n        ep = [t ir]         thickness and integration rule\n\n        D  = [[kxx kxy],\n              [kyx kyy]]    constitutive matrix\n\n        eq                  heat supply per unit volume\n\n    Returns:\n        Ke                  element \'stiffness\' matrix (4 x 4)\n        fe                  element load vector (4 x 1)\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = np.mat([g1,g1])\n        w = np.mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n    wp = np.multiply(w[:,0],w[:,1])\n    \n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = np.multiply((1-xsi),(1-eta))/4.\n    N = np.append(N,np.multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = np.mat(np.zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n    Ke1 = np.mat(np.zeros((4,4)))\n    fe1 = np.mat(np.zeros((4,1)))\n    JT = dNr*np.mat([ex,ey]).T\n\n    for i in range(ngp):\n        indx = np.array([2*(i+1)-1,2*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobi determinant == 0"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*np.asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n\n    if eq == None:\n        return Ke1*t\n    else:\n        return Ke1*t,fe1*t*eq\n\ndef flw2i4s(ex,ey,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    4 node isoparametric element.\n    \n    Parameters:\n        \n        ex = [x1 x2 x3 x4]         element coordinates\n        ey = [y1 y2 y3 y4]\n\n        ep = [t ir]                thickness and integration rule\n\n        D  = [[kxx kxy],\n              [kyx kyy]]           constitutive matrix\n\n        ed = [u1, u2, u3, u4]      u1,u2,u3,u4: nodal values\n\n    Returns:\n        es = [[qx, qy],\n              [.., ..]]             element flows\n\n        et = [[qx, qy],\n              [... ..]]             element gradients\n\n        eci=[[ix1, iy1],            Gauss point location vector\n             [...  ...],            nint: number of integration points\n             [ix(nint), iy(nint)]\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = np.mat([g1,g1])\n        w = np.mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n    wp = np.multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = np.multiply((1-xsi),(1-eta))/4.\n    N = np.append(N,np.multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = np.mat(np.zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n    eci = N*np.mat([ex,ey]).T\n    if ed.ndim == 1:\n        ed = np.array([ed])\n        \n    red,ced = np.shape(ed)\n    JT = dNr*np.mat([ex,ey]).T\n    \n    es = np.mat(np.zeros((ngp*red,2)))\n    et = np.mat(np.zeros((ngp*red,2)))\n    for i in range(ngp):\n        indx = np.array([2*(i+1)-1,2*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobi determinatn == 0"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n    \n    return es,et,eci\n\ndef flw2i8e(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 8 node isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1, ..., x8]      element coordinates\n        ey = [y1, ..., y8]\n        \n        ep = [t, ir]            thickness and integration rule\n\n        D = [[kxx, kxy],\n             [kyx, kyy]]        constitutive matrix\n\n        eq                      heat supply per unit volume\n\n    Returns:\n    \n        Ke                      element \'stiffness\' matrix (8 x 8)\n        fe                      element load vector (8 x 1)\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if eq == None:\n        q = 0\n    else:\n        q = eq\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = np.mat([g1,g1])\n        w = np.mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n    wp = np.multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = np.multiply(np.multiply(-(1-xsi),(1-eta)),(1+xsi+eta))/4.\n    N = np.append(N,np.multiply(np.multiply(-(1+xsi),(1-eta)),(1-xsi+eta))/4.,axis=1)\n    N = np.append(N,np.multiply(np.multiply(-(1+xsi),(1+eta)),(1-xsi-eta))/4.,axis=1)\n    N = np.append(N,np.multiply(np.multiply(-(1-xsi),(1+eta)),(1+xsi-eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1-np.multiply(xsi,xsi)),(1-eta))/2.,axis=1)\n    N = np.append(N,np.multiply((1+xsi),(1-np.multiply(eta,eta)))/2.,axis=1)\n    N = np.append(N,np.multiply((1-np.multiply(xsi,xsi)),(1+eta))/2.,axis=1)\n    N = np.append(N,np.multiply((1-xsi),(1-np.multiply(eta,eta)))/2.,axis=1)\n\n    dNr = np.mat(np.zeros((r2,8)))\n    dNr[0:r2:2,0] = -(-np.multiply((1-eta),(1+xsi+eta))+np.multiply((1-xsi),(1-eta)))/4.\n    dNr[0:r2:2,1] = -(np.multiply((1-eta),(1-xsi+eta))-np.multiply((1+xsi),(1-eta)))/4.\n    dNr[0:r2:2,2] = -(np.multiply((1+eta),(1-xsi-eta))-np.multiply((1+xsi),(1+eta)))/4.\n    dNr[0:r2:2,3] = -(-np.multiply((1+eta),(1+xsi-eta))+np.multiply((1-xsi),(1+eta)))/4.\n    dNr[0:r2:2,4] = -np.multiply(xsi,(1-eta))\n    dNr[0:r2:2,5] = (1-np.multiply(eta,eta))/2.\n    dNr[0:r2:2,6] = -np.multiply(xsi,(1+eta))\n    dNr[0:r2:2,7] = -(1-np.multiply(eta,eta))/2.\n    dNr[1:r2+1:2,0] = -(-np.multiply((1-xsi),(1+xsi+eta))+np.multiply((1-xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,1] = -(-np.multiply((1+xsi),(1-xsi+eta))+np.multiply((1+xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,2] = -(np.multiply((1+xsi),(1-xsi-eta))-np.multiply((1+xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,3] = -(np.multiply((1-xsi),(1+xsi-eta))-np.multiply((1-xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,4] = -(1-np.multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,5] = -np.multiply(eta,(1+xsi))\n    dNr[1:r2+1:2,6] = (1-np.multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,7] = -np.multiply(eta,(1-xsi))\n\n    Ke1 = np.mat(np.zeros((8,8)))\n    fe1 = np.mat(np.zeros((8,1)))\n    JT = dNr*np.mat([ex,ey]).T\n\n    for i in range(ngp):\n        indx = np.array([2*(i+1)-1,2*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobideterminanten lika med noll!"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*np.asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n    \n    if eq != None:\n        return Ke1*t,fe1*t*q\n    else:\n        return Ke1*t\n\ndef flw2i8s(ex,ey,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    8 node isoparametric element.\n    \n    Parameters:\n        \n        ex = [x1,x2,x3....,x8]     element coordinates\n        ey = [y1,y2,y3....,y8]\n\n        ep = [t,ir]                thickness and integration rule\n\n        D  = [[kxx,kxy],\n              [kyx,kyy]]           constitutive matrix\n\n        ed = [u1,....,u8]          u1,....,u8: nodal values\n\n    Returns:\n        es = [[qx,qy],\n              [..,..]]             element flows\n\n        et = [[qx,qy],\n              [..,..]]             element gradients\n\n        eci=[[ix1,iy1],            Gauss point location vector\n             [...,...],            nint: number of integration points\n             [ix(nint),iy(nint)]]\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = np.mat([g1,g1])\n        w = np.mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = np.mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n    wp = np.multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = np.multiply(np.multiply(-(1-xsi),(1-eta)),(1+xsi+eta))/4.\n    N = np.append(N,np.multiply(np.multiply(-(1+xsi),(1-eta)),(1-xsi+eta))/4.,axis=1)\n    N = np.append(N,np.multiply(np.multiply(-(1+xsi),(1+eta)),(1-xsi-eta))/4.,axis=1)\n    N = np.append(N,np.multiply(np.multiply(-(1-xsi),(1+eta)),(1+xsi-eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1-np.multiply(xsi,xsi)),(1-eta))/2.,axis=1)\n    N = np.append(N,np.multiply((1+xsi),(1-np.multiply(eta,eta)))/2.,axis=1)\n    N = np.append(N,np.multiply((1-np.multiply(xsi,xsi)),(1+eta))/2.,axis=1)\n    N = np.append(N,np.multiply((1-xsi),(1-np.multiply(eta,eta)))/2.,axis=1)\n\n    dNr = np.mat(np.zeros((r2,8)))\n    dNr[0:r2:2,0] = -(-np.multiply((1-eta),(1+xsi+eta))+np.multiply((1-xsi),(1-eta)))/4.\n    dNr[0:r2:2,1] = -(np.multiply((1-eta),(1-xsi+eta))-np.multiply((1+xsi),(1-eta)))/4.\n    dNr[0:r2:2,2] = -(np.multiply((1+eta),(1-xsi-eta))-np.multiply((1+xsi),(1+eta)))/4.\n    dNr[0:r2:2,3] = -(-np.multiply((1+eta),(1+xsi-eta))+np.multiply((1-xsi),(1+eta)))/4.\n    dNr[0:r2:2,4] = -np.multiply(xsi,(1-eta))\n    dNr[0:r2:2,5] = (1-np.multiply(eta,eta))/2.\n    dNr[0:r2:2,6] = -np.multiply(xsi,(1+eta))\n    dNr[0:r2:2,7] = -(1-np.multiply(eta,eta))/2.\n    dNr[1:r2+1:2,0] = -(-np.multiply((1-xsi),(1+xsi+eta))+np.multiply((1-xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,1] = -(-np.multiply((1+xsi),(1-xsi+eta))+np.multiply((1+xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,2] = -(np.multiply((1+xsi),(1-xsi-eta))-np.multiply((1+xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,3] = -(np.multiply((1-xsi),(1+xsi-eta))-np.multiply((1-xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,4] = -(1-np.multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,5] = -np.multiply(eta,(1+xsi))\n    dNr[1:r2+1:2,6] = (1-np.multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,7] = -np.multiply(eta,(1-xsi))\n\n    eci = N*np.mat([ex,ey]).T\n    if ed.ndim == 1:\n        ed = np.array([ed])\n    red,ced = np.shape(ed)\n    JT = dNr*np.mat([ex,ey]).T\n    \n    es = np.mat(np.zeros((ngp*red,2)))\n    et = np.mat(np.zeros((ngp*red,2)))\n\n    for i in range(ngp):\n        indx = np.array([2*(i+1)-1,2*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobi determinant == 0"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n\n    return es,et,eci\n\ndef flw3i8e(ex,ey,ez,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 8 node isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3,...,x8]\n        ey = [y1,y2,y3,...,y8]      element coordinates\n        ez = [z1,z2,z3,...,z8]\n\n        ep = [ir]                   Ir: Integration rule\n\n        D = [[kxx,kxy,kxz],\n             [kyx,kyy,kyz],\n             [kzx,kzy,kzz]]         constitutive matrix\n\n        eq                          heat supply per unit volume\n\n    Output:\n\n        Ke                          element \'stiffness\' matrix (8 x 8)\n        fe                          element load vector (8 x 1)\n\n    """"""\n    ir = ep[0]\n    ngp = ir*ir*ir\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n    \n    if ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-1,-1,-1],\n            [ 1,-1,-1],\n            [ 1, 1,-1],\n            [-1, 1,-1],\n            [-1,-1, 1],\n            [ 1,-1, 1],\n            [ 1, 1, 1],\n            [-1, 1, 1]\n        ])*g1\n        w = np.mat(np.ones((8,3)))*w1\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat(np.zeros((27,3)))\n        w = np.mat(np.zeros((27,3)))\n        I1 = np.array([-1,0,1,-1,0,1,-1,0,1])\n        I2 = np.array([0,-1,0,0,1,0,0,1,0])\n        gp[:,0] = np.mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,0] = np.mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,0]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,0] = np.mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,0] = np.mat([I2,I2,I2]).reshape(27,1)*w2+w[:,0]\n        I1 = np.array([-1,-1,-1,0,0,0,1,1,1])\n        I2 = np.array([0,0,0,1,1,1,0,0,0])\n        gp[:,1] = np.mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,1] = np.mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,1]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,1] = np.mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,1] = np.mat([I2,I2,I2]).reshape(27,1)*w2+w[:,1]\n        I1 = np.array([-1,-1,-1,-1,-1,-1,-1,-1,-1])\n        I2 = np.array([0,0,0,0,0,0,0,0,0])\n        I3 = abs(I1)\n        gp[:,2] = np.mat([I1,I2,I3]).reshape(27,1)*g1\n        gp[:,2] = np.mat([I2,I3,I2]).reshape(27,1)*g2+gp[:,2]\n        w[:,2] = np.mat([I3,I2,I3]).reshape(27,1)*w1\n        w[:,2] = np.mat([I2,I3,I2]).reshape(27,1)*w2+w[:,2]\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n        return\n\n    wp = np.multiply(np.multiply(w[:,0],w[:,1]),w[:,2])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    zet = gp[:,2]\n    r2 = ngp*3\n    \n    N = np.multiply(np.multiply((1-xsi),(1-eta)),(1-zet))/8.\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1-eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1+eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1+eta)),(1+zet))/8.,axis=1)\n    \n    dNr = np.mat(np.zeros((r2,8)))\n    dNr[0:r2:3,0]= np.multiply(-(1-eta),(1-zet))\n    dNr[0:r2:3,1]= np.multiply((1-eta),(1-zet))\n    dNr[0:r2:3,2]= np.multiply((1+eta),(1-zet))\n    dNr[0:r2:3,3]= np.multiply(-(1+eta),(1-zet))\n    dNr[0:r2:3,4]= np.multiply(-(1-eta),(1+zet))\n    dNr[0:r2:3,5]= np.multiply((1-eta),(1+zet))\n    dNr[0:r2:3,6]= np.multiply((1+eta),(1+zet))\n    dNr[0:r2:3,7]= np.multiply(-(1+eta),(1+zet))\n    dNr[1:r2+1:3,0] = np.multiply(-(1-xsi),(1-zet))\n    dNr[1:r2+1:3,1] = np.multiply(-(1+xsi),(1-zet))\n    dNr[1:r2+1:3,2] = np.multiply((1+xsi),(1-zet))\n    dNr[1:r2+1:3,3] = np.multiply((1-xsi),(1-zet))\n    dNr[1:r2+1:3,4] = np.multiply(-(1-xsi),(1+zet))\n    dNr[1:r2+1:3,5] = np.multiply(-(1+xsi),(1+zet))\n    dNr[1:r2+1:3,6] = np.multiply((1+xsi),(1+zet))\n    dNr[1:r2+1:3,7] = np.multiply((1-xsi),(1+zet))\n    dNr[2:r2+2:3,0] = np.multiply(-(1-xsi),(1-eta))\n    dNr[2:r2+2:3,1] = np.multiply(-(1+xsi),(1-eta))\n    dNr[2:r2+2:3,2] = np.multiply(-(1+xsi),(1+eta))\n    dNr[2:r2+2:3,3] = np.multiply(-(1-xsi),(1+eta))\n    dNr[2:r2+2:3,4] = np.multiply((1-xsi),(1-eta))\n    dNr[2:r2+2:3,5] = np.multiply((1+xsi),(1-eta))\n    dNr[2:r2+2:3,6] = np.multiply((1+xsi),(1+eta))\n    dNr[2:r2+2:3,7] = np.multiply((1-xsi),(1+eta))\n    dNr = dNr/8.\n\n    Ke1 = np.mat(np.zeros((8,8)))\n    fe1 = np.mat(np.zeros((8,1)))\n    JT = dNr*np.mat([ex,ey,ez]).T\n    \n    for i in range(ngp):\n        indx = np.array([3*(i+1)-2,3*(i+1)-1,3*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobi determinant == 0"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*np.asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n\n    if eq != None:\n        return Ke1,fe1*q\n    else:\n        return Ke1\n\ndef flw3i8s(ex,ey,ez,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    8 node (3-dim) isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3,...,x8]\n        ey = [y1,y2,y3,...,y8]              element coordinates\n        ez = [z1,z2,z3,...,z8]\n\n        ep = [ir]                           Ir: Integration rule\n\n        D = [[kxx,kxy,kxz],\n             [kyx,kyy,kyz],\n             [kzx,kzy,kzz]]                 constitutive matrix\n\n        ed = [[u1,....,u8],                 element nodal values\n              [..,....,..]]\n\n    Output:\n\n        es = [[qx,qy,qz],\n              [..,..,..]]                   element flows(s)\n\n        et = [[qx,qy,qz],                   element gradients(s)\n              [..,..,..]]\n\n        eci = [[ix1,ix1,iz1],               location vector\n               [...,...,...],               nint: number of integration points\n               [ix(nint),iy(nint),iz(nint)]]\n\n    """"""\n    ir = ep[0]\n    ngp = ir*ir*ir\n    \n    if ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-1,-1,-1],\n            [ 1,-1,-1],\n            [ 1, 1,-1],\n            [-1, 1,-1],\n            [-1,-1, 1],\n            [ 1,-1, 1],\n            [ 1, 1, 1],\n            [-1, 1, 1]\n        ])*g1\n        w = np.mat(np.ones((8,3)))*w1\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat(np.zeros((27,3)))\n        w = np.mat(np.zeros((27,3)))\n        I1 = np.array([-1,0,1,-1,0,1,-1,0,1])\n        I2 = np.array([0,-1,0,0,1,0,0,1,0])\n        gp[:,0] = np.mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,0] = np.mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,0]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,0] = np.mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,0] = np.mat([I2,I2,I2]).reshape(27,1)*w2+w[:,0]\n        I1 = np.array([-1,-1,-1,0,0,0,1,1,1])\n        I2 = np.array([0,0,0,1,1,1,0,0,0])\n        gp[:,1] = np.mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,1] = np.mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,1]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,1] = np.mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,1] = np.mat([I2,I2,I2]).reshape(27,1)*w2+w[:,1]\n        I1 = np.array([-1,-1,-1,-1,-1,-1,-1,-1,-1])\n        I2 = np.array([0,0,0,0,0,0,0,0,0])\n        I3 = abs(I1)\n        gp[:,2] = np.mat([I1,I2,I3]).reshape(27,1)*g1\n        gp[:,2] = np.mat([I2,I3,I2]).reshape(27,1)*g2+gp[:,2]\n        w[:,2] = np.mat([I3,I2,I3]).reshape(27,1)*w1\n        w[:,2] = np.mat([I2,I3,I2]).reshape(27,1)*w2+w[:,2]\n    else:\n        cfinfo(""Used number of integration points not implemented"")\n        return\n\n    wp = np.multiply(np.multiply(w[:,0],w[:,1]),w[:,2])\n    \n    xsi = gp[:,0]\n    eta = gp[:,1]\n    zet = gp[:,2]\n    r2 = ngp*3\n    \n    N = np.multiply(np.multiply((1-xsi),(1-eta)),(1-zet))/8.\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1-eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1+xsi),(1+eta)),(1+zet))/8.,axis=1)\n    N = np.append(N,np.multiply(np.multiply((1-xsi),(1+eta)),(1+zet))/8.,axis=1)\n    \n    dNr = np.mat(np.zeros((r2,8)))\n    dNr[0:r2:3,0]= np.multiply(-(1-eta),(1-zet))\n    dNr[0:r2:3,1]= np.multiply((1-eta),(1-zet))\n    dNr[0:r2:3,2]= np.multiply((1+eta),(1-zet))\n    dNr[0:r2:3,3]= np.multiply(-(1+eta),(1-zet))\n    dNr[0:r2:3,4]= np.multiply(-(1-eta),(1+zet))\n    dNr[0:r2:3,5]= np.multiply((1-eta),(1+zet))\n    dNr[0:r2:3,6]= np.multiply((1+eta),(1+zet))\n    dNr[0:r2:3,7]= np.multiply(-(1+eta),(1+zet))\n    dNr[1:r2+1:3,0] = np.multiply(-(1-xsi),(1-zet))\n    dNr[1:r2+1:3,1] = np.multiply(-(1+xsi),(1-zet))\n    dNr[1:r2+1:3,2] = np.multiply((1+xsi),(1-zet))\n    dNr[1:r2+1:3,3] = np.multiply((1-xsi),(1-zet))\n    dNr[1:r2+1:3,4] = np.multiply(-(1-xsi),(1+zet))\n    dNr[1:r2+1:3,5] = np.multiply(-(1+xsi),(1+zet))\n    dNr[1:r2+1:3,6] = np.multiply((1+xsi),(1+zet))\n    dNr[1:r2+1:3,7] = np.multiply((1-xsi),(1+zet))\n    dNr[2:r2+2:3,0] = np.multiply(-(1-xsi),(1-eta))\n    dNr[2:r2+2:3,1] = np.multiply(-(1+xsi),(1-eta))\n    dNr[2:r2+2:3,2] = np.multiply(-(1+xsi),(1+eta))\n    dNr[2:r2+2:3,3] = np.multiply(-(1-xsi),(1+eta))\n    dNr[2:r2+2:3,4] = np.multiply((1-xsi),(1-eta))\n    dNr[2:r2+2:3,5] = np.multiply((1+xsi),(1-eta))\n    dNr[2:r2+2:3,6] = np.multiply((1+xsi),(1+eta))\n    dNr[2:r2+2:3,7] = np.multiply((1-xsi),(1+eta))\n    dNr = dNr/8.\n\n    eci = N*np.mat([ex,ey,ez]).T\n    if ed.ndim == 1:\n        ed = np.array([ed])\n        red,ced = np.shape(ed)\n    JT = dNr*np.mat([ex,ey,ez]).T\n\n    es = np.mat(np.zeros((ngp*red,3)))\n    et = np.mat(np.zeros((ngp*red,3)))\n    for i in range(ngp):\n        indx = np.array([3*(i+1)-2,3*(i+1)-1,3*(i+1)])\n        detJ = np.linalg.det(JT[indx-1,:])\n        if detJ < 10*np.finfo(float).eps:\n            cfinfo(""Jacobideterminanten lika med noll!"")\n        JTinv = np.linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n\n    return es,et,eci\n\ndef plante(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a triangular plane stress or plane strain element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3]         element coordinates\n        ey = [y1,y2,y3]\n     \n        ep = [ptype,t]          ptype: analysis type\n                                t: thickness\n     \n        D                       constitutive matrix\n    \n        eq = [[bx],               bx: body force x-dir\n              [by]]               by: body force y-dir\n              \n    Returns:\n    \n        Ke                      element stiffness matrix (6 x 6)\n        fe                      equivalent nodal forces (6 x 1) (if eq is given)\n\n    """"""\n\n    ptype,t = ep\n    \n    bx = 0.0\n    by = 0.0\n    \n    if not eq is None:\n        bx = eq[0]\n        by = eq[1]\n        \n    C = np.mat([\n        [1, ex[0], ey[0], 0,     0,     0], \n        [0,     0,     0, 1, ex[0], ey[0]],\n        [1, ex[1], ey[1], 0,     0,     0],\n        [0,     0,     0, 1, ex[1], ey[1]],\n        [1, ex[2], ey[2], 0,     0,     0],\n        [0,     0,     0, 1, ex[2], ey[2]]\n        ])\n    \n    A = 0.5*np.linalg.det(np.mat([\n        [1, ex[0], ey[0]],\n        [1, ex[1], ey[1]],\n        [1, ex[2], ey[2]]\n        ]))\n    \n    # --------- plane stress --------------------------------------\n    \n    if ptype == 1:\n        B = np.mat([\n            [0, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1],\n            [0, 0, 1, 0, 1, 0]\n            ])*np.linalg.inv(C)\n        \n        colD = D.shape[1]\n        \n        if colD > 3:\n            Cm = np.linalg.inv(D)\n            Dm = np.linalg.inv(Cm[np.ix_((0,1,3),(0,1,3))])\n        else:\n            Dm = D\n            \n        Ke = B.T*Dm*B*A*t\n        fe = A/3*np.mat([bx,by,bx,by,bx,by]).T*t\n        \n        if eq is None:\n            return Ke\n        else:\n            return Ke,fe.T\n       \n    #--------- plane strain --------------------------------------       \n    \n    elif ptype == 2:\n        B = np.mat([\n            [0, 1, 0, 0, 0, 0,],\n            [0, 0, 0, 0, 0, 1,],\n            [0, 0, 1, 0, 1, 0,]\n            ])*np.linalg.inv(C)\n\n        colD = D.shape[1]\n        \n        if colD > 3:\n            Dm = D[np.ix_((0,1,3),(0,1,3))]\n        else:\n            Dm = D\n\n        Ke = B.T*Dm*B*A*t\n        fe = A/3*np.mat([bx,by,bx,by,bx,by]).T*t\n        \n        if eq == None:\n            return Ke\n        else:\n            return Ke,fe.T\n\n    else:\n        cfinfo(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        if eq == None:\n            return None\n        else:\n            return None,None\n\ndef plants(ex,ey,ep,D,ed):\n    """"""\n    Calculate element normal and shear stress for a\n    triangular plane stress or plane strain element.\n    \n    INPUT:  ex = [x1 x2 x3]         element coordinates\n           ey = [y1 y2 y3]\n    \n           ep = [ptype t ]         ptype: analysis type\n                                   t: thickness\n    \n           D                       constitutive matrix\n    \n           ed =[u1 u2 ...u6        element displacement vector\n                ......     ]       one row for each element\n    \n    OUTPUT: es = [ sigx sigy [sigz] tauxy   element stress matrix\n                 ......                 ]  one row for each element\n    \n           et = [ epsx epsy [epsz] gamxy   element strain matrix\n                 ......                 ]  one row for each element\n    """"""\n\n    ptype=ep[0]\n    \n    if np.ndim(ex) == 1:\n        ex = np.array([ex])\n    if np.ndim(ey) == 1:\n        ey = np.array([ey])\n    if np.ndim(ed) == 1:\n        ed = np.array([ed])\n\n    rowed=ed.shape[0]\n    rowex=ex.shape[0]\n    \n    # --------- plane stress --------------------------------------\n    \n    if ptype==1:\n        \n        colD = D.shape[1]\n\n        if colD>3:\n            Cm = np.linalg.inv(D)\n            Dm = np.linalg.inv(Cm[np.ix_((0,1,3),(0,1,3))])\n        else:\n            Dm = D\n            \n        incie=0\n\n        if rowex==1:\n            incie=0\n        else:\n            incie=1\n      \n        et=np.zeros([rowed,colD])\n        es=np.zeros([rowed,colD])\n        \n        ie=0\n        \n        for i in range(rowed):\n            C = np.matrix(\n                [[1, ex[ie,0], ey[ie,0], 0, 0, 0 ], \n                 [0, 0, 0, 1, ex[ie,0], ey[ie,0] ],\n                 [1, ex[ie,1], ey[ie,1], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,1], ey[ie,1] ],\n                 [1, ex[ie,2], ey[ie,2], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,2], ey[ie,2] ]]\n                )\n            \n            B = np.matrix([\n                [0,1,0,0,0,0],\n                [0,0,0,0,0,1],\n                [0,0,1,0,1,0]])*np.linalg.inv(C)\n            \n            ee=B*np.asmatrix(ed[ie,:]).T\n\n            if colD>3:\n                ss=np.zeros([colD,1])\n                ss[[0,1,3]]=Dm*ee\n                ee=Cm*ss\n            else:\n                ss=Dm*ee\n    \n            et[ie,:] = ee.T\n            es[ie,:] = ss.T\n    \n            ie = ie + incie\n                    \n        return es, et\n        \n    # --------- plane strain --------------------------------------\n    elif ptype == 2:   #Implementation by LAPM\n        colD = D.shape[1]\n        incie=0\n\n        if rowex==1:\n            incie=0\n        else:\n            incie=1\n      \n        et=np.zeros([rowed,colD])\n        es=np.zeros([rowed,colD])\n        \n        ie=0\n        \n        ee=np.zeros([colD,1])\n\n        for i in range(rowed):\n            C = np.matrix(\n                [[1, ex[ie,0], ey[ie,0], 0, 0, 0 ], \n                 [0, 0, 0, 1, ex[ie,0], ey[ie,0] ],\n                 [1, ex[ie,1], ey[ie,1], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,1], ey[ie,1] ],\n                 [1, ex[ie,2], ey[ie,2], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,2], ey[ie,2] ]]\n                )\n            \n            B = np.matrix([\n                [0,1,0,0,0,0],\n                [0,0,0,0,0,1],\n                [0,0,1,0,1,0]])*np.linalg.inv(C)\n            \n            e=B*np.asmatrix(ed[ie,:]).T\n\n            if colD>3:\n                ee[[0,1,3]]=e\n            else:\n                ee=e\n\n            et[ie,:] = ee.T\n            es[ie,:] = (D*ee).T\n    \n            ie = ie + incie\n                \n        return es, et\n\n    else:\n        print(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        return None\n    \ndef plantf(ex,ey,ep,es):\n    """"""\n    Compute internal element force vector in a triangular element\n    in plane stress or plane strain. \n\n    Parameters:\n\n        ex = [x1,x2,x3]                 node coordinates\n        ey = [y1,y2,y3]\n\n        ep = [ptype,t]                  ptype: analysis type\n                                        t: thickness\n\n        es = [[sigx,sigy,[sigz],tauxy]  element stress matrix\n              [  ......              ]] one row for each element\n\n    OUTPUT:\n\n        fe = [[f1],[f2],...,[f8]]       internal force vector\n\n    """"""\n\n    ptype,t = ep\n\n    colD = es.shape[1]\n\n    #--------- plane stress --------------------------------------\n\n    if ptype == 1:\n\n        C = np.mat([\n            [ 1, ex[0], ey[0], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[2], ey[2]]\n        ])\n\n        A = 0.5*np.linalg.det(np.mat([\n            [ 1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2]]\n        ]))\n\n        B = np.mat([\n            [ 0, 1, 0, 0, 0, 0],\n            [ 0, 0, 0, 0, 0, 1],\n            [ 0, 0, 1, 0, 1, 0]\n        ])*np.linalg.inv(C)\n    \n        if colD > 3:\n            stress = np.asmatrix(es[np.ix_((0,1,3))])\n        else:\n            stress = np.asmatrix(es)\n\n        ef = (A*t*B.T*stress.T).T\n        \n        return np.reshape(np.asarray(ef),6)\n\n    #--------- plane strain --------------------------------------\n    \n    elif ptype == 2:\n\n        C = np.mat([\n            [ 1, ex[0], ey[0], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[2], ey[2]]\n        ])\n\n        A = 0.5*np.linalg.det(np.mat([\n            [ 1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2]]\n        ]))\n\n        B = np.mat([\n            [ 0, 1, 0, 0, 0, 0],\n            [ 0, 0, 0, 0, 0, 1],\n            [ 0, 0, 1, 0, 1, 0]\n        ])*np.linalg.inv(C)\n\n        if colD > 3:\n            stress = np.asmatrix(es[np.ix_((1,2,4))])\n        else:\n            stress = np.asmatrix(es)\n\n        ef = (A*t*B.T*stress.T).T\n        \n        return np.reshape(np.asarray(ef),6)\n  \n    else:\n        cfinfo(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        return None\n\ndef platre(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a rectangular plate element.\n    NOTE! Element sides must be parallel to the coordinate axis.\n    \n    Parameters:\n\n        ex = [x1,x2,x3,x4]          element coordinates\n        ey = [y1,y2,y3,y4]\n\n        ep = [t]                    thicknes\n\n        D                           constitutive matrix for\n                                    plane stress         \n\n        eq = [qz]                   load/unit area\n    Returns:\n\n        Ke                          element stiffness matrix (12 x 12)\n        fe                          equivalent nodal forces (12 x 1)\n\n    """"""\n    Lx = (ex[2]-ex[0]).astype(float)\n    Ly = (ey[2]-ey[0]).astype(float)\n    t = ep[0]\n\n    D = t**3/12.*D\n\n    A1 = Ly/(Lx**3)\n    A2 = Lx/(Ly**3)\n    A3 = 1/Lx/Ly\n    A4 = Ly/(Lx**2)\n    A5 = Lx/(Ly**2)\n    A6 = 1/Lx\n    A7 = 1/Ly\n    A8 = Ly/Lx\n    A9 = Lx/Ly\n\n    C1 = 4*A1*D[0,0]+4*A2*D[1,1]+2*A3*D[0,1]+5.6*A3*D[2,2]\n    C2 = -4*A1*D[0,0]+2*A2*D[1,1]-2*A3*D[0,1]-5.6*A3*D[2,2]\n    C3 = 2*A1*D[0,0]-4*A2*D[1,1]-2*A3*D[0,1]-5.6*A3*D[2,2]\n    C4 = -2*A1*D[0,0]-2*A2*D[1,1]+2*A3*D[0,1]+5.6*A3*D[2,2]\n    C5 = 2*A5*D[1,1]+A6*D[0,1]+0.4*A6*D[2,2]\n    C6 = 2*A4*D[0,0]+A7*D[0,1]+0.4*A7*D[2,2]\n    \n    C7 = 2*A5*D[1,1]+0.4*A6*D[2,2]\n    C8 = 2*A4*D[0,0]+0.4*A7*D[2,2]\n    C9 = A5*D[1,1]-A6*D[0,1]-0.4*A6*D[2,2]\n    C10 = A4*D[0,0]-A7*D[0,1]-0.4*A7*D[2,2]\n    C11 = A5*D[1,1]-0.4*A6*D[2,2]\n    C12 = A4*D[0,0]-0.4*A7*D[2,2]\n    \n    C13 = 4/3.*A9*D[1,1]+8/15.*A8*D[2,2]\n    C14 = 4/3.*A8*D[0,0]+8/15.*A9*D[2,2]\n    C15 = 2/3.*A9*D[1,1]-8/15.*A8*D[2,2]\n    C16 = 2/3.*A8*D[0,0]-8/15.*A9*D[2,2]\n    C17 = 2/3.*A9*D[1,1]-2/15.*A8*D[2,2]\n    C18 = 2/3.*A8*D[0,0]-2/15.*A9*D[2,2]\n    C19 = 1/3.*A9*D[1,1]+2/15.*A8*D[2,2]\n    C20 = 1/3.*A8*D[0,0]+2/15.*A9*D[2,2]\n    C21 = D[0,1]\n\n    Keq = np.mat(np.zeros((12,12)))\n    Keq[0,0:13] = C1,C5,-C6,C2,C9,-C8,C4,C11,-C12,C3,C7,-C10\n    Keq[1,1:13] = C13,-C21,C9,C15,0,-C11,C19,0,-C7,C17,0\n    Keq[2,2:13] = C14,C8,0,C18,C12,0,C20,-C10,0,C16\n    Keq[3,3:13] = C1,C5,C6,C3,C7,C10,C4,C11,C12\n    Keq[4,4:13] = C13,C21,-C7,C17,0,-C11,C19,0\n    Keq[5,5:13] = C14,C10,0,C16,-C12,0,C20\n    Keq[6,6:13] = C1,-C5,C6,C2,-C9,C8\n    Keq[7,7:13] = C13,-C21,-C9,C15,0\n    Keq[8,8:13] = C14,-C8,0,C18\n    Keq[9,9:13] = C1,-C5,-C6\n    Keq[10,10:13] = C13,C21\n    Keq[11,11] = C14\n    Keq = Keq.T+Keq-np.diag(np.diag(Keq))\n\n    if eq != None:\n        q = eq\n        R1 = q*Lx*Ly/4\n        R2 = q*Lx*Ly**2/24\n        R3 = q*Ly*Lx**2/24\n\n        feq = np.mat([R1,R2,-R3,R1,R2,R3,R1,-R2,R3,R1,-R2,-R3])\n\n    if eq != None:\n        return Keq,feq\n    else:\n        return Keq\n\ndef planqe(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a quadrilateral\n    plane stress or plane strain element.\n\n    Parameters:\n        ex=[x1 x2 x3 x4]    element coordinates\n        ey=[y1 y2 y3 y4]\n                                \n        ep = [ptype, t]     ptype: analysis type\n                            t: element thickness \n\n        D                   constitutive matrix\n\n        eq = [bx;           bx: body force in x direction\n              by]           by: body force in y direction\n\n    OUTPUT: Ke :  element stiffness matrix (8 x 8)\n            fe : equivalent nodal forces (row array)\n    """"""\n    K=np.zeros((10,10))\n    f=np.zeros((10,1))\n    \n    xm=sum(ex)/4.\n    ym=sum(ey)/4.\n    \n    b1 = eq if eq is not None else np.array([[0],[0]])\n    \n    ke1, fe1 = plante(np.array([ex[0], ex[1], xm]), np.array([ey[0], ey[1], ym]), ep, D, b1)\n    K, f = assem(np.array([1, 2, 3, 4, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(np.array([ex[1], ex[2], xm]), np.array([ey[1], ey[2], ym]), ep, D, b1)\n    K, f = assem(np.array([3, 4, 5, 6, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(np.array([ex[2], ex[3], xm]), np.array([ey[2], ey[3], ym]), ep, D, b1)\n    K, f = assem(np.array([5, 6, 7, 8, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(np.array([ex[3], ex[0], xm]), np.array([ey[3], ey[0], ym]), ep, D, b1)\n    K, f = assem(np.array([7, 8, 1, 2, 9, 10]), K, ke1, f, fe1)\n    Ke, fe = statcon(K, f, np.array([[9],[10]]))\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n        \n\ndef planqs(ex,ey,ep,D,ed,eq=None):\n    """"""\n    Calculate element normal and shear stress for a quadrilateral \n    plane stress or plane strain element.\n    \n    Parameters:\n            ex = [x1 x2 x3 x4]      element coordinates\n            ey = [y1 y2 y3 y4]\n    \n            ep = [ptype, t]         ptype: analysis type\n                                    t:  thickness\n                                   \n            D                       constitutive matrix\n    \n            ed = [u1 u2 ..u8]       element displacement vector\n    \n            eq = [[bx]               bx: body force in x direction\n                  [by]]              by: body force in y direction\n    \n    OUTPUT: es = [ sigx sigy (sigz) tauxy]    element stress array\n            et = [ epsx epsy (epsz) gamxy]    element strain array\n    """"""\n    \n    if ex.shape != (4,) or ey.shape != (4,) or ed.shape != (8,):\n        raise ValueError(\'Error ! PLANQS: only one element at the time (ex, ey, ed must be a row arrays)\')\n\n    K = np.zeros((10,10))\n    f = np.zeros((10,1))\n    \n    xm = sum(ex)/4.\n    ym = sum(ey)/4.\n        \n    b1 = eq if eq is not None else np.array([[0],[0]])\n    \n    ex1 = np.array([ex[0], ex[1], xm]) \n    ey1 = np.array([ey[0], ey[1], ym])\n    ex2 = np.array([ex[1], ex[2], xm]) \n    ey2 = np.array([ey[1], ey[2], ym])\n    ex3 = np.array([ex[2], ex[3], xm]) \n    ey3 = np.array([ey[2], ey[3], ym])\n    ex4 = np.array([ex[3], ex[0], xm]) \n    ey4 = np.array([ey[3], ey[0], ym])\n    \n    ke1, fe1 = plante(ex1, ey1, ep, D, b1)\n    K, f = assem(np.array([1, 2, 3, 4, 9, 10]), K, ke1, f, fe1)\n    ke1,fe1 = plante(ex2, ey2, ep, D, b1)\n    K, f = assem(np.array([3, 4, 5, 6, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(ex3, ey3, ep, D, b1)\n    K, f = assem(np.array([5, 6, 7, 8, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(ex4, ey4, ep, D, b1)\n    K, f = assem(np.array([7, 8, 1, 2, 9, 10]), K, ke1, f, fe1)\n    \n    A1 = 0.5 * np.linalg.det( np.hstack([np.ones((3,1)), np.mat(ex1).T, np.mat(ey1).T]) )\n    A2 = 0.5 * np.linalg.det( np.hstack([np.ones((3,1)), np.mat(ex2).T, np.mat(ey2).T]) )\n    A3 = 0.5 * np.linalg.det( np.hstack([np.ones((3,1)), np.mat(ex3).T, np.mat(ey3).T]) )\n    A4 = 0.5 * np.linalg.det( np.hstack([np.ones((3,1)), np.mat(ex4).T, np.mat(ey4).T]) )\n    Atot = A1+A2+A3+A4;\n    \n    \n    a, _ = solveq(K, f, np.array(range(1,9)), ed)\n        \n#    ni = ed.shape[0]\n#    a = np.mat(empty((10,ni)))\n#    for i in range(ni):\n#        a[:,i] = solveq(K, f, np.array(range(1,9)), ed[i,:])[0]\n#        #a = np.hstack([a, solveq(K, f, np.hstack([matrix(range(1,9)).T, ed[i,:].T]) ) ])\n    \n    s1, t1 = plants(ex1, ey1, ep, D, np.hstack([a[[0, 1, 2, 3, 8, 9], :].T]) );\n    s2, t2 = plants(ex2, ey2, ep, D, np.hstack([a[[2, 3, 4, 5, 8, 9], :].T]) );\n    s3, t3 = plants(ex3, ey3, ep, D, np.hstack([a[[4, 5, 6, 7, 8, 9], :].T]) );\n    s4, t4 = plants(ex4, ey4, ep, D, np.hstack([a[[6, 7, 0, 1, 8, 9], :].T]) );\n    \n    es = (s1*A1+s2*A2+s3*A3+s4*A4)/Atot;\n    et = (t1*A1+t2*A2+t3*A3+t4*A4)/Atot;\n    \n    return es[0], et[0] #[0] because these are 1-by-3 arrays and we want row arrays out.\n\n\ndef plani4e(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a 4 node isoparametric\n    element in plane strain or plane stress.\n    \n    Parameters:\n        ex = [x1 ...   x4]  element coordinates. Row array\n        ey = [y1 ...   y4]\n                                \n        ep =[ptype, t, ir]  ptype: analysis type\n                            t : thickness\n                            ir: integration rule\n    \n        D                   constitutive matrix\n    \n        eq = [bx; by]       bx: body force in x direction\n                            by: body force in y direction\n                                Any array with 2 elements acceptable\n    \n    Returns:\n        Ke : element stiffness matrix (8 x 8)\n        fe : equivalent nodal forces (8 x 1)\n    """"""\n    ptype=ep[0] \n    t=ep[1]  \n    ir=ep[2]  \n    ngp=ir*ir\n    if eq == None:\n        q = np.zeros((2,1))\n    else:\n        q = np.reshape(eq, (2,1))\n#--------- gauss points --------------------------------------    \n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = np.mat([g1,g1])\n        w = np.mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = np.mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]])\n        w = np.mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = np.mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]])\n        w = np.mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]])\n    else:\n        cfinfo(""Used number of integrat     ion points not implemented"")\n    wp = np.multiply(w[:,0],w[:,1])\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n    # Shape Functions\n    N = np.multiply((1-xsi),(1-eta))/4.\n    N = np.append(N,np.multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = np.append(N,np.multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = np.mat(np.zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n#\n    Ke1 = np.mat(np.zeros((8,8)))\n    fe1 = np.mat(np.zeros((8,1)))\n    JT = dNr*np.mat([ex,ey]).T \n    # --------- plane stress --------------------------------------\n    if ptype==1:\n        colD=np.shape(D)[0]\n        if colD>3:\n            Cm=np.linalg.inv(D)\n            Dm=np.linalg.inv(Cm[ np.ix_([0,1,3],[0,1,3]) ])\n        else:\n            Dm=D          \n#\n        B=np.matrix(np.zeros((3,8)))\n        N2=np.matrix(np.zeros((2,8)))\n        for i in range(ngp):\n            indx = np.array([2*(i+1)-1,2*(i+1)])\n            detJ = np.linalg.det(JT[indx-1,:])\n            if detJ < 10*np.finfo(float).eps:\n                cfinfo(""Jacobi determinant equal or less than zero!"")\n            JTinv = np.linalg.inv(JT[indx-1,:])  \n            dNx=JTinv*dNr[indx-1,:]\n#   \n            index_array_even=np.array([0,2,4,6])\n            index_array_odd=np.array([1,3,5,7])\n#    \n            counter=0    \n            for index in index_array_even:      \n                B[0,index] = dNx[0,counter]\n                B[2,index] = dNx[1,counter]\n                N2[0,index]=N[i,counter]\n                counter=counter+1\n#\n            counter=0    \n            for index in index_array_odd:\n                B[1,index]   = dNx[1,counter]\n                B[2,index]   = dNx[0,counter]\n                N2[1,index]  =N[i,counter]\n                counter=counter+1\n#   \n            Ke1 = Ke1+B.T*Dm*B*detJ*np.asscalar(wp[i])*t\n            fe1 = fe1 + N2.T * q * detJ * np.asscalar(wp[i]) * t\n\n        return Ke1,fe1\n#--------- plane strain --------------------------------------\n    elif ptype==2:\n#      \n        colD=np.shape(D)[0]\n        if colD>3:\n            Dm = D[np.ix_([0,1,3],[0,1,3])]\n        else:\n            Dm = D\n#\n        B=np.matrix(np.zeros((3,8)))\n        N2=np.matrix(np.zeros((2,8)))\n        for i in range(ngp):\n            indx = np.array([2*(i+1)-1,2*(i+1)])\n            detJ = np.linalg.det(JT[indx-1,:])\n            if detJ < 10*np.finfo(float).eps:\n                cfinfo(""Jacobideterminant equal or less than zero!"")\n            JTinv = np.linalg.inv(JT[indx-1,:])  \n            dNx=JTinv*dNr[indx-1,:]\n#   \n            index_array_even=np.array([0,2,4,6])\n            index_array_odd=np.array([1,3,5,7])\n#    \n            counter=0    \n            for index in index_array_even:\n#\n                B[0,index] = dNx[0,counter]\n                B[2,index] = dNx[1,counter]\n                N2[0,index]=N[i,counter]\n#\n                counter=counter+1\n#\n            counter=0    \n            for index in index_array_odd:\n                B[1,index]   = dNx[1,counter]\n                B[2,index]   = dNx[0,counter]\n                N2[1,index]  =N[i,counter]\n                counter=counter+1\n#   \n            Ke1 = Ke1 + B.T * Dm * B * detJ * np.asscalar(wp[i]) * t\n            fe1 = fe1+N2.T*q*detJ*np.asscalar(wp[i])*t\n        return Ke1,fe1\n    else:\n        cfinfo(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        \n \ndef assem(edof,K,Ke,f=None,fe=None):\n    """"""\n    Assemble element matrices Ke ( and fe ) into the global\n    stiffness matrix K ( and the global force vector f )\n    according to the topology matrix edof.\n    \n    Parameters:\n    \n        edof        dof topology array\n        K           the global stiffness matrix\n        Ke          element stiffness matrix\n        f           the global force vector\n        fe          element force vector\n        \n    Output parameters:\n    \n        K           the new global stiffness matrix\n        f           the new global force vector\n        fe          element force vector\n    \n    """"""\n    \n    if edof.ndim == 1:\n        idx = edof-1\n        K[np.ix_(idx,idx)] = K[np.ix_(idx,idx)] + Ke\n        if (not f is None) and (not fe is None):\n            f[np.ix_(idx)] = f[np.ix_(idx)] + fe\n    else:\n        for row in edof:\n            idx = row-1\n            K[np.ix_(idx,idx)] = K[np.ix_(idx,idx)] + Ke\n            if (not f is None) and (not fe is None):\n                f[np.ix_(idx)] = f[np.ix_(idx)] + fe\n            \n    if f is None:\n        return K\n    else:\n        return K,f\n            \ndef solveq(K,f,bcPrescr,bcVal=None):\n    """"""\n    Solve static FE-equations considering boundary conditions.\n    \n    Parameters:\n    \n        K           global stiffness matrix, dim(K)= nd x nd\n        f           global load vector, dim(f)= nd x 1\n    \n        bcPrescr    1-dim integer array containing prescribed dofs.\n        bcVal       1-dim float array containing prescribed values.\n                    If not given all prescribed dofs are assumed 0.\n        \n    Returns:\n    \n        a           solution including boundary values\n        Q           reaction force vector\n                    dim(a)=dim(Q)= nd x 1, nd : number of dof\'s\n    \n    """"""    \n    \n    nDofs = K.shape[0]\n    nPdofs = bcPrescr.shape[0]\n    \n    if bcVal is None:\n        bcVal = np.zeros([nPdofs],\'d\')\n    \n    bc = np.ones(nDofs, \'bool\')    \n    bcDofs = np.arange(nDofs)\n    \n    bc[np.ix_(bcPrescr-1)] = False\n    bcDofs = bcDofs[bc]\n    \n    fsys = f[bcDofs]-K[np.ix_((bcDofs),(bcPrescr-1))]*np.asmatrix(bcVal).reshape(nPdofs,1)\n    asys = np.linalg.solve(K[np.ix_((bcDofs),(bcDofs))], fsys);\n    \n    a = np.zeros([nDofs,1])\n    a[np.ix_(bcPrescr-1)] = np.asmatrix(bcVal).reshape(nPdofs,1)\n    a[np.ix_(bcDofs)] = asys\n    \n    Q=K*np.asmatrix(a)-f\n    \n    return (np.asmatrix(a),Q)\n    \ndef spsolveq(K,f,bcPrescr,bcVal=None):\n    """"""\n    Solve static FE-equations considering boundary conditions.\n    \n    Parameters:\n    \n        K           global stiffness matrix, dim(K)= nd x nd\n        f           global load vector, dim(f)= nd x 1\n    \n        bcPrescr    1-dim integer array containing prescribed dofs.\n        bcVal       1-dim float array containing prescribed values.\n                    If not given all prescribed dofs are assumed 0.\n        \n    Returns:\n    \n        a           solution including boundary values\n        Q           reaction force vector\n                    dim(a)=dim(Q)= nd x 1, nd : number of dof\'s\n    \n    """"""    \n    \n    nDofs = K.shape[0]\n    nPdofs = bcPrescr.shape[0]\n    \n    if bcVal is None:\n        bcVal = np.zeros([nPdofs],\'d\')\n    \n    bc = np.ones(nDofs, \'bool\')    \n    bcDofs = np.arange(nDofs)\n    \n    bc[np.ix_(bcPrescr-1)] = False\n    bcDofs = bcDofs[bc]\n    \n    bcVal_m = np.asmatrix(bcVal).reshape(nPdofs,1)\n    \n    info(""Preparing system matrix..."")\n    \n    mask = np.ones(K.shape[0], dtype=bool)\n    mask[bcDofs] = False\n    \n    info(""step 1... converting K->CSR"")\n    Kcsr = K.asformat(""csr"")    \n    info(""step 2... Kt"")\n    #Kt1 = K[bcDofs]\n    #Kt = Kt1[:,bcPrescr]\n    Kt = K[np.ix_((bcDofs),(bcPrescr-1))]\n    info(""step 3... fsys"")\n    fsys = f[bcDofs]-Kt*bcVal_m\n    info(""step 4... Ksys"")\n    Ksys1 = Kcsr[bcDofs]\n    Ksys = Ksys1[:,bcDofs]\n    #Ksys = Kcsr[np.ix_((bcDofs),(bcDofs))]\n    info (""done..."")\n    \n    info(""Solving system..."")\n    asys = dsolve.spsolve(Ksys, fsys);\n    \n    info(""Reconstructing full a..."")\n    a = np.zeros([nDofs,1])\n    a[np.ix_(bcPrescr-1)] = bcVal_m\n    a[np.ix_(bcDofs)] = np.asmatrix(asys).transpose()\n    \n    a_m = np.asmatrix(a)\n    Q=K*a_m-f\n    info(""done..."")\n    return (a_m,Q)\n\ndef extractEldisp(edof,a):\n    """"""\n    Extract element displacements from the global displacement\n    vector according to the topology matrix edof.\n    \n    Parameters:\n    \n        a           the global displacement vector\n        edof        dof topology array\n    \n    Returns:\n    \n        ed:     element displacement array\n    \n    """"""\n\n    ed = None\n    \n    if edof.ndim==1:\n        nDofs = len(edof)\n        ed = np.zeros([nDofs])\n        idx = edof-1\n        ed[:] = a[np.ix_(idx)].T\n    else:\n        nElements = edof.shape[0]\n        nDofs = edof.shape[1]\n        ed = np.zeros([nElements,nDofs])\n        i=0\n        for row in edof:\n            idx = row-1\n            ed[i,:]=a[np.ix_(idx)].T\n            i+=1\n        \n    return ed\n\nextract_eldisp = extractEldisp\n\ndef statcon(K,f,cd):\n    """"""\n    Condensation of static FE-equations according to the vector cd.\n\n    Parameters:\n    \n        K                       global stiffness matrix, dim(K) = nd x nd\n        f                       global load vector, dim(f)= nd x 1\n\n        cd                      vector containing dof\'s to be eliminated\n                                dim(cd)= nc x 1, nc: number of condensed dof\'s\n    Returns:\n    \n        K1                      condensed stiffness matrix,\n                                dim(K1)= (nd-nc) x (nd-nc)\n        f1                      condensed load vector, dim(f1)= (nd-nc) x 1\n    """"""\n    nd,nd = np.shape(K)\n    cd = (cd-1).flatten()\n  \n    aindx = np.arange(nd)\n    aindx = np.delete(aindx,cd,0)\n    bindx = cd\n\n    Kaa = np.mat(K[np.ix_(aindx,aindx)])\n    Kab = np.mat(K[np.ix_(aindx,bindx)])\n    Kbb = np.mat(K[np.ix_(bindx,bindx)])\n\n    fa = np.mat(f[aindx])\n    fb = np.mat(f[bindx])\n    \n    K1 = Kaa-Kab*Kbb.I*Kab.T\n    f1 = fa-Kab*Kbb.I*fb\n    \n    return K1,f1\n\ndef c_mul(a, b):\n    return eval(hex((np.long(a) * b) & 0xFFFFFFFF)[:-1])\n\ndef dofHash(dof):\n    if len(dof)==1:\n        return dof[0]\n    value = 0x345678\n    for item in dof:\n        value = c_mul(1000003, value) ^ hash(item)\n    value = value ^ len(dof)\n    if value == -1:\n        value = -2\n    return value\n\ndef createdofs(nCoords,nDof):\n    """"""\n    Create dof array [nCoords x nDof]\n    """"""\n    return np.arange(nCoords*nDof).reshape(nCoords,nDof)+1\n\ndef coordxtr(edof,coords,dofs):\n    """"""\n    Create element coordinate matrices ex, ey, ez from edof\n    coord and dofs matrices.\n    \n    Parameters:\n    \n        edof            [nel x (nen * nnd)], nnd = number of node dofs\n        coords          [ncoords x ndims],   ndims = node dimensions\n        dofs            [ncoords x nnd]\n        \n    Returns:\n    \n        ex              if ndims = 1\n        ex, ey          if ndims = 2\n        ex, ey, ez      if ndims = 3\n    """"""\n    \n    # Create dictionary with dof indices\n    \n    dofDict = {}\n    nDofs = np.size(dofs,1)\n    nElements = np.size(edof,0)\n    nDimensions = np.size(coords,1)\n    nElementDofs = np.size(edof,1)\n    \n    nElementNodes = int(nElementDofs/nDofs)\n    \n    idx = 0\n    for dof in dofs:\n        dofDict[dofHash(dof)] = idx\n        idx += 1\n              \n    # Loop over edof and extract element coords\n    \n    ex = np.zeros((nElements,nElementNodes))\n    ey = np.zeros((nElements,nElementNodes))\n    ez = np.zeros((nElements,nElementNodes))\n    \n    elementIdx = 0\n    for etopo in edof:\n        for i in range(nElementNodes):\n            i0 = i*nDofs\n            i1 = i*nDofs+nDofs-1\n            dof = []\n            if i0==i1:\n                dof = [etopo[i*nDofs]]\n            else:\n                dof = etopo[i*nDofs:(i*nDofs+nDofs)]\n            \n            nodeCoord = coords[dofDict[dofHash(dof)]]\n            \n            if nDimensions>=1:\n                ex[elementIdx,i] = nodeCoord[0]\n            if nDimensions>=2:\n                ey[elementIdx,i] = nodeCoord[1]\n            if nDimensions>=3:\n                ez[elementIdx,i] = nodeCoord[2]\n            \n        elementIdx += 1\n        \n    if nDimensions==1:\n        return ex\n    \n    if nDimensions==2:\n        return ex, ey\n    \n    if nDimensions==3:\n        return ex, ey, ez\n\ndef hooke(ptype,E,v):\n    """"""\n    Calculate the material matrix for a linear\n    elastic and isotropic material.\n    \n    Parameters:\n    \n        ptype=  1:  plane stress\n                2:  plane strain\n                3:  axisymmetry\n                4:  three dimensional\n    \n        E           Young\'s modulus\n        v           Poissons const.\n        \n    Returns:\n    \n        D           material matrix\n    \n    """"""\n   \n    if ptype == 1:\n        D = E*np.matrix(\n            [[1, v, 0],\n             [v, 1, 0],\n             [0, 0, (1-v)/2]]\n            )/(1-v**2);\n    elif ptype == 2:\n        D = E/(1+v)*np.matrix(\n            [[1-v, v, v, 0],\n             [v, 1-v, v, 0],\n             [v, v, 1-v, 0],\n             [0, 0, 0, (1-2*v)/2]]\n            )/(1-2*v)\n    elif ptype == 3:\n        D = E/(1+v)*np.matrix(\n            [[1-v, v, v, 0],\n             [v, 1-v, v, 0],\n             [v, v, 1-v, 0],\n             [0, 0, 0, (1-2*v)/2]]\n            )/(1-2*v)\n    elif ptype == 4:\n        D = E*np.matrix(\n            [[1-v, v, v, 0, 0, 0],\n             [v, 1-v, v, 0, 0, 0],\n             [v, v, 1-v, 0, 0, 0],\n             [0, 0, 0, (1-2*v)/2, 0, 0],\n             [0, 0, 0, 0, (1-2*v)/2, 0],\n             [0, 0, 0, 0, 0, (1-2*v)/2]]\n            )/(1+v)/(1-2*v)\n    else:\n        cfinfo(""ptype not supported."")\n        \n    return D\n\ndef effmises(es,ptype):\n    """"""\n    Calculate effective von mises stresses.\n    \n    Parameters:\n        \n        es\n    \n        ptype=  1:  plane stress\n                2:  plane strain\n                3:  axisymmetry\n                4:  three dimensional\n    \n       es = [[sigx,sigy,[sigz],tauxy]  element stress matrix\n              [  ......              ]] one row for each element\n              \n    Returns:\n    \n        eseff  = [eseff_0 .. eseff_nel-1]\n    \n    """"""\n    \n    nel = np.size(es,0)\n    escomps = np.size(es, 1)\n    \n    eseff = np.zeros([nel])\n     \n    if ptype == 1:\n        sigxx = es[:,0]\n        sigyy = es[:,1]\n        sigxy = es[:,2]\n        eseff = np.sqrt(sigxx*sigxx+sigyy*sigyy-sigxx*sigyy+3*sigxy*sigxy)\n        return eseff\n    \ndef stress2nodal(eseff, edof):\n    """"""\n    Convert element effective stresses to nodal effective\n    stresses.\n    \n    Parameters:\n        \n        eseff  = [eseff_0 .. eseff_nel-1] \n        edof   = [dof topology array]\n    \n    Returns:\n    \n        ev:     element value array [[ev_0_0 ev_0_1 ev_0_nen-1 ]\n                                      ..\n                                      ev_nel-1_0 ev_nel-1_1 ev_nel-1_nen-1]\n                      \n    """"""\n    \n    values = np.zeros(edof.max())\n    elnodes = int(np.size(edof,1) / 2)\n    \n    for etopo, eleseff in zip(edof, eseff):\n        values[etopo-1] = values[etopo-1] + eleseff / elnodes\n        \n    evtemp = extractEldisp(edof,values)\n    ev = evtemp[:,range(0,elnodes*2,2)]\n                     \n    return ev\n'"
calfem/geometry.py,0,"b'# TODO: Consider adding more checks whether entities exist.\n\nimport numpy as np\n\n\nclass Geometry:\n    \'\'\'\n    Instances of GeoData can hold geometric data and be passed to \n    GmshMesher in pycalfem_Mesh to mesh the geometry.\n    \'\'\'\n\n    def __init__(self):\n        self.points = {}  # dict of [[x, y, z], elSize, marker]\n        # dict of [curvTypestring, [p1, p2, ... pn], marker, elementsOnCurve, distributionString, distributionVal]\n        self.curves = {}\n        # dict of [SurfaceTypeString, [c1, c2 ... cn], [[c1, c2 ... cm], ... [c1, ... ck]], ID, marker, is_structured]. c means curve-ID.\n        self.surfaces = {}\n        # dict of [[s1, s2 ..], [[s1,s2...],[s1,s2..],..], ID, marker, is_structured]\n        self.volumes = {}\n        # This is automatically set to True if a 3D point is added.\n        self.is3D = False\n        self._pointIDspecified = False\n        self._nextPointID = 0\n        self._curveIDspecified = False\n        self._nextcurveID = 0\n        self._surfaceIDspecified = False\n        self._nextsurfaceID = 0\n        self._volumeIDspecified = False\n        self._nextvolumeID = 0\n\n    def removePoint(self, ID):\n        \'\'\'Removes the point with this ID\'\'\'\n        self.points.pop(ID)\n\n    def removeCurve(self, ID):\n        \'\'\'Removes the curve with this ID\'\'\'\n        self.curve.pop(ID)\n\n    def removeSurface(self, ID):\n        \'\'\'Removes the surface with this ID\'\'\'\n        self.surfaces.pop(ID)\n\n    def removeVolume(self, ID):\n        \'\'\'Removes the volume with this ID\'\'\'\n        self.volumes.pop(ID)\n\n    def getPointCoords(self, IDs=None):\n        \'\'\'\n        Returns an N-by-3 list of point coordinates if the parameter is\n        a list of IDs. If the parameter is just a single integer then \n        a single coordinate (simple 3-element list) is returned.\n        If the parameter is undefined (or None) all point coords will be returned\n        \'\'\'\n        if IDs == None:\n            return [p[0] for p in self.points.values()]\n        try:\n            pointCoords = [self.points[pID][0] for pID in IDs]\n        except TypeError:  # IDs was not iterable. Probably just a single ID.\n            pointCoords = self.points[IDs][0]\n        return pointCoords\n\n    def pointsOnCurves(self, IDs):\n        \'\'\'\n        Returns a list of all geometric points (not nodes) on the curves\n        specified in IDs. IDs may be an integer or a list of integers.\n        \'\'\'\n        return self._subentitiesOnEntities(IDs, self.curves, 1)\n\n    def stuffOnSurfaces(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points and curves on the surfaces\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        curveSet = self._subentitiesOnEntities(\n            IDs, self.surfaces, 1)  # Curves on the outer edges\n        curveSet.update(self._subentityHolesOnEntities(\n            IDs, self.surfaces, 2))  # Curves on the holes\n        # Points on the curves of these surfaces.\n        pointList = self.pointsOnCurves(curveSet)\n        return pointList, list(curveSet)\n\n    def stuffOnVolumes(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points, curves, and surfaces on the volumes\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        surfaceSet = self._subentitiesOnEntities(IDs, self.surfaces, 0)\n        surfaceSet.update(self._subentitiesOnEntities(IDs, self.surfaces, 1))\n        pointList, curveList = self.stuffOnSurfaces(surfaceSet)\n        return pointList, curveList, list(surfaceSet)\n\n    def _subentitiesOnEntities(self, IDs, entityDict, index):\n        \'\'\'\n        Duplicate code. Gets the IDs of the subentities that\n        make up an entity, i.e. the points that define a curve or\n        the curves that define a surface. Note that only the outer\n        subentities of surfaces and volumes can be extracted with\n        this function. For holes use _subentityHolesOnEntities().\n        \'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                theSet.update(entityDict[ID][index])\n        except TypeError:  # IDs is not iterable, so it is probably a single ID\n            theSet.update(entityDict[IDs][index])\n        return theSet\n\n    def _subentityHolesOnEntities(self, IDs, entityDict, index):\n        \'\'\'Duplicate code. Does the same thing as _subentitiesOnEntities(), but for holes\'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                for hole in entityDict[ID][index]:\n                    theSet.update(hole)\n        except TypeError:  # IDs is not iterable, so it is probably a single ID\n            for hole in entityDict[IDs][index]:\n                theSet.update(hole)\n        return theSet\n\n    def addPoints(self, points, markers=None, ids=None, elSizes=None):\n        \'\'\'\n        Add points from a numpy-array\n        \'\'\'\n        nPoints, dims = points.shape\n\n        if dims == 2:\n            for row in points:\n                self.addPoint(row.tolist())\n        elif dims == 3:\n            for row in points:\n                self.addPoint(row.tolist())\n\n    def addPoint(self, coord, ID=None, marker=0, el_size=1):\n        \'\'\'\n        Adds a point.\n\n        Parameters:\n        coord     - [x, y] or [x, y, z].\n                    List, not array.\n\n        ID        - Positive integer ID of this point. If left unspecified the\n                    point will be assigned the smallest unused point-ID.\n                    It is recommended to specify all point-IDs or none.\n\n        marker    - Marker applied to this point. Default 0.\n                    It is not a good idea to apply non-zero markers to points\n                    that are control points on B-splines or center points on \n                    circles/ellipses, since this can lead to ""loose"" nodes\n                    that are not part of any elements.\n\n        elSize    - The size of elements at this point. Default 1. Use to make\n                    a mesh denser or sparser here. Only affects unstructured\n                    meshes\n        \'\'\'\n        if len(coord) == 3:  # A 3D point is inserted.\n            self.is3D = True\n        else:  # The point is in 2D (we assume)\n            # Pad with a 0. (we store points as 3D points for consistency\'s sake)\n            coord = coord+[0]\n\n        if ID == None:  # ID is not specified. Get an ID for this point:\n            ID = self._getNewPointID()\n        else:\n            self._pointIDspecified = True\n\n        self.points[ID] = [coord, el_size, marker]\n\n    def bounding_box_2d(self):\n        """"""Calculate bounding box geometry""""""\n\n        min_x = 1e300\n        max_x = -1e300\n        min_y = 1e300\n        max_y = -1e300\n\n        for point_id in self.points.keys():\n            p = self.points[point_id]\n            if p[0][0] > max_x:\n                max_x = p[0][0]\n            if p[0][0] < min_x:\n                min_x = p[0][0]\n            if p[0][1] > max_y:\n                max_y = p[0][1]\n            if p[0][1] < min_y:\n                min_y = p[0][1]\n\n        return min_x, max_x, min_y, max_y\n\n    def addSplines(self, points):\n        \'\'\'\n        Add splines from numpy array\n        \'\'\'\n        nPoints, dims = points.shape\n\n        if dims == 2:\n            for row in points:\n                self.addSpline(row.tolist())\n        elif dims == 3:\n            for row in points:\n                splineDef = row.tolist()\n                self.addSpline(splineDef[:-1], marker=splineDef[2])\n\n    def addSpline(self, points, ID=None, marker=0, el_on_curve=None, el_distrib_type=None, el_distrib_val=None):\n        \'\'\'\n        Adds a Spline curve\n\n        points    - List of indices of control points that make a Spline\n                    [p1, p2, ... , pn]\n\n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n\n        marker    - Integer. Marker applied to this curve. Default 0.\n\n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n\n        el_distrib_type -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and el_distrib_val must be be defined if this param\n                    is used.\n\n        el_distrib_val -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    el_distrib_type must be be defined if this param is used.\n\n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n\n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    el_distrib_val = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    el_distrib_val < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""Spline"", points, ID, marker, el_on_curve,\n                       el_distrib_type, el_distrib_val)\n\n    def addBSpline(self, points, ID=None, marker=0, el_on_curve=None,  el_distrib_type=None, el_distrib_val=None):\n        \'\'\'\n        Adds a B-Spline curve\n\n        points    - List of indices of control points that make a B-spline\n                    [p1, p2, ... , pn]\n\n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n\n        marker    - Integer. Marker applied to this curve. Default 0.\n\n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n\n        el_distrib_type -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and el_distrib_val must be be defined if this param\n                    is used.\n\n        el_distrib_val -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    el_distrib_type must be be defined if this param is used.\n\n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n\n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    el_distrib_val = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    el_distrib_val < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""BSpline"", points, ID, marker,\n                       el_on_curve, el_distrib_type, el_distrib_val)\n\n    def addCircle(self, points, ID=None, marker=0, el_on_curve=None, el_distrib_type=None, el_distrib_val=None):\n        \'\'\'\n        Adds a Circle arc curve.\n\n        points    - list of 3 indices of point that make a circle arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, endpoint]\n\n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n\n        marker    - Marker applied to this curve. Default 0.\n\n        elOnCurv  - Elements on curve.\n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes.\n\n        el_distrib_type -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and el_distrib_val must be be defined if this param\n                    is used.\n\n        el_distrib_val -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    el_distrib_type must be be defined if this param is used.\n\n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n\n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    el_distrib_val = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    el_distrib_val < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        if len(points) != 3:\n            raise IndexError(\n                ""Circle: points must be a list of 3 positive integers denoting point indices"")\n        self._addCurve(""Circle"", points, ID, marker, el_on_curve,\n                       el_distrib_type, el_distrib_type)\n\n    def addEllipse(self, points, ID=None, marker=0, el_on_curve=None, el_distrib_type=None, el_distrib_val=None):\n        \'\'\'\n        Adds a Ellipse arc curve.\n\n        points    - List of 4 indices of point that make a ellipse arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, mAxisPoint, endpoint]\n                    Startpoint is the starting point of the arc.\n                    Centerpoint is the point at the center of the ellipse.\n                    MAxisPoint is any point on the major axis of the ellipse.\n                    Endpoint is the end point of the arc.\n\n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n\n        marker    - Integer. Marker applied to this curve. Default 0.\n\n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n\n        el_distrib_type -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and el_distrib_val must be be defined if this param\n                    is used.\n\n        el_distrib_val -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    el_distrib_type must be be defined if this param is used.\n\n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n\n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    el_distrib_val = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    el_distrib_val < 1 makes each element smaller than the \n                    preceeding one.                      \n        \'\'\'\n        if len(points) != 4:\n            raise IndexError(\n                ""Ellipse: points must be a list of 4 positive integers denoting point indices"")\n        self._addCurve(""Ellipse"", points, ID, marker,\n                       el_on_curve, el_distrib_type, el_distrib_val)\n\n    def _addCurve(self, name, points, ID, marker, el_on_curve, el_distrib_type, el_distrib_val):\n        \'\'\'Duplicate code goes here!\'\'\'\n        if ID == None:\n            ID = self._getNewCurveID()\n        else:\n            self._curveIDspecified = True\n\n        if el_distrib_type != None:\n            # transform into lowercase except the first letter upper case.\n            el_distrib_type = el_distrib_type.lower().title()\n            if el_distrib_type not in [""Bump"", ""Progression""]:\n                raise ValueError(\n                    ""el_distrib_type must be a string, either \\""bump\\"" or \\""progression\\"". Curve with ID=%i was incorrect."" % ID)\n            if el_distrib_val == None:\n                raise ValueError(\n                    ""If el_distrib_type is defined then el_distrib_val must be given a (float) value"")\n\n        self.curves[ID] = [name, points, marker,\n                           el_on_curve, el_distrib_type, el_distrib_val]\n\n    def addSurface(self, outer_loop, holes=[], ID=None, marker=0):\n        \'\'\'\n        Adds a plane surface (flat).\n        Parameters:\n        outer_loop - List of curve IDs that make up the outer boundary of\n                    the surface. The curves must lie in the same plane.\n\n        holes     - List of lists of curve IDs that make up the inner\n                    boundaries of the surface. The curves must lie in the\n                    same plane. \n\n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n\n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        # TODO: Possibly check if outer_loop is an actual loop and if the holes are correct.\n        self._addSurf(""Plane Surface"", outer_loop, holes,\n                      ID, marker, is_structured=False)\n\n    def addRuledSurface(self, outer_loop, ID=None, marker=0):\n        \'\'\'\n        Adds a Ruled Surface (bent surface).\n        Parameters:\n        outer_loop - List of 3 or 4 curve IDs that make up the boundary of\n                    the surface.\n\n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n\n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        if len(outer_loop) not in [3, 4]:\n            raise IndexError(\n                ""Ruled Surface: outer_loop must be a list of 3 or 4 positive integers denoting curve indices"")\n        self._addSurf(""Ruled Surface"", outer_loop, [],\n                      ID, marker, is_structured=False)\n\n    def addStructuredSurface(self, outer_loop, ID=None, marker=0):\n        \'\'\'\n        Adds a Structured Surface.\n        Parameters:\n        outer_loop - List of 4 curve IDs that make up the boundary of\n                    the surface. The curves must be structured, i.e. their\n                    parameter \'elOnCurv\' must be defined.\n\n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n\n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        self._checkIfProperStructuredQuadBoundary(outer_loop, ID)\n        self._addSurf(""Ruled Surface"", outer_loop, [],\n                      ID, marker, is_structured=True)\n\n    def _addSurf(self, name, outer_loop, holes, ID, marker, is_structured):\n        \'\'\'For duplicate code\'\'\'\n        # TODO: check if the curves in outer_loop actually exist. Maybe print a warning.\n        if ID == None:\n            ID = self._getNewSurfaceID()\n        else:\n            self._surfaceIDspecified = True\n\n        # Catch the easy mistake of making holes a list of ints rather than a list of lists of ints.\n        for hole in holes:\n            try:\n                [h for h in hole]\n            except TypeError:\n                raise TypeError(\n                    ""Hole "" + str(hole) + "" is not iterable. Parameter holes must be a list of lists of integers"")\n\n        self.surfaces[ID] = [name, outer_loop,\n                             holes, ID, marker, is_structured]\n\n    def addVolume(self, outer_surfaces, holes=[], ID=None, marker=0):\n        \'\'\'Adds a Volume\n        Parameters:\n        outer_surfaces - List of surface IDs that make up the outer boundary of\n                        the volume.\n\n        holes         - List of lists of surface IDs that make up the inner\n                        boundaries of the volume.\n\n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n\n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        self._addVolume(outer_surfaces, holes, ID, marker, is_structured=False)\n\n    def addStructuredVolume(self, outer_surfaces, ID=None, marker=0):\n        \'\'\'Adds a Structured Volume\n        Parameters:\n        outer_surfaces - List of surface IDs that make up the outer boundary of\n                        the volume. The surfaces must be Structured Surfaces.\n\n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n\n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        # TODO: Check input. (see if surfaces are structured)\n        self._addVolume(outer_surfaces, [], ID, marker, is_structured=True)\n\n    def _addVolume(self,  outer_surfaces, holes, ID, marker, is_structured):\n        \'\'\'Duplicate code\'\'\'\n        # TODO: Check input (outer_surfaces and holes[i] must be closed surfaces)\n        if ID == None:\n            ID = self._getNewVolumeID()\n        else:\n            self._volumeIDspecified = True\n        self.volumes[ID] = [outer_surfaces, holes, ID, marker, is_structured]\n\n    def pointMarker(self, ID, marker):\n        self.setPointMarker(ID, marker)\n\n    def setPointMarker(self, ID, marker):\n        \'\'\'Sets the marker of the point with the ID\'\'\'\n        self.points[ID][2] = marker\n\n    def curveMarker(self, ID, marker):\n        self.setCurveMarker(ID, marker)\n\n    def setCurveMarker(self, ID, marker):\n        \'\'\'Sets the marker of the curve with the ID\'\'\'\n        self.curves[ID][2] = marker\n\n    def surfaceMarker(self, ID, marker):\n        self.setSurfaceMarker(ID, marker)\n\n    def setSurfaceMarker(self, ID, marker):\n        \'\'\'Sets the marker of the surface with the ID\'\'\'\n        self.surfaces[ID][4] = marker\n\n    def setVolumeMarker(self, ID, marker):\n        \'\'\'Sets the marker of the volume with the ID\'\'\'\n        self.volumes[ID][3] = marker\n\n    def _checkIfProperStructuredQuadBoundary(self, outer_loop, ID):\n        \'\'\'Checks if the four edges of a quad-shaped superelement exist and\n        are correct, i.e el_on_curve of opposite curves are equal.\'\'\'\n        if len(outer_loop) != 4:\n            raise IndexError(\n                ""Structured Surface: outer_loop must be a list of 4 positive integers denoting curve indices"")\n\n        try:\n            c0 = self.curves[outer_loop[0]]\n            c1 = self.curves[outer_loop[1]]\n            c2 = self.curves[outer_loop[2]]\n            c3 = self.curves[outer_loop[3]]\n        except KeyError:\n            raise KeyError(\n                ""Structured Surface: Attempted construction of StructuredSurface with ID=%s from a curve that does not exist"" % ID)\n\n        if None in [c0, c1, c2, c3]:\n            raise Exception(\n                ""Attempted to create structured surface from non-structured boundary curves."")\n\n        # Check if the number of elements on opposite curves match.\n        if(c0[-3] != c2[-3] or c1[-3] != c3[-3]):\n            raise Exception(""Structured Surface: The outer_loop of StructuredSurface %i is not properly "" +\n                            ""constructed. The reason could be that the number of elements (elOnCurv) on "" +\n                            ""opposite pairs of curves are different"")\n\n    def _getNewPointID(self):\n        if not self._pointIDspecified:\n            self._nextPointID += 1\n            return self._nextPointID - 1\n        else:\n            return self._smallestFreeKey(self.points)\n\n    def _getNewCurveID(self):\n        if not self._curveIDspecified:\n            self._nextcurveID += 1\n            return self._nextcurveID - 1\n        else:\n            return self._smallestFreeKey(self.curves)\n\n    def _getNewSurfaceID(self):\n        if not self._surfaceIDspecified:\n            self._nextsurfaceID += 1\n            return self._nextsurfaceID - 1\n        else:\n            return self._smallestFreeKey(self.surfaces)\n\n    def _getNewVolumeID(self):\n        if not self._volumeIDspecified:\n            self._nextvolumeID += 1\n            return self._nextvolumeID - 1\n        else:\n            return self._smallestFreeKey(self.volumes)\n\n    def _smallestFreeKey(self, dictionary):\n        \'\'\'Finds the smallest unused key in the dict.\'\'\'\n        sortedkeys = sorted(dictionary)\n        for i in range(len(dictionary)):\n            if sortedkeys[i] != i:\n                return i\n\n    point = addPoint\n    spline = addSpline\n    line = addSpline\n    bspline = addBSpline\n    circle = addCircle\n    ellipse = addEllipse\n    surface = addSurface\n    surf = addSurface\n    ruledSurface = addRuledSurface\n    ruled_surface = addRuledSurface\n    ruled_surf = addRuledSurface\n    structuredSurface = addStructuredSurface\n    structured_surface = addStructuredSurface\n    struct_surf = addStructuredSurface\n    volume = addVolume\n    structuredVolume = addStructuredVolume\n    structured_volume = addStructuredVolume\n    get_point_coords = getPointCoords\n    curve_marker = curveMarker\n\n\ndef geometry():\n    return Geometry()\n'"
calfem/intvis.py,0,"b'# -*- coding: utf-8 -*-\n\nimport sys\n\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtGui import *\n\nclass GuiWindow(QWidget):\n    def __init__(self, var_dict):\n        """"""MyWindow constructor""""""\n\n        super().__init__()\n\n        # Skapa gr\xc3\xa4nssnittskontroller\n\n        self.var_dict = var_dict\n\n        self.init_gui()\n\n    def __parse_variables(self, g):\n\n        # a_edit = 1\n        # b_slider = 2.0\n        # c_list = [1, 2, 3]\n        # d_check = True\n        # f_param = 42.0\n        # g_float = 84.0\n        # g_int = 34\n\n        row = 0\n\n        for key, value in self.var_dict.items():\n            if \'_edit\' in key:\n                var_label = QLabel(key)\n                var_edit = QLineEdit(str(value))\n\n                g.addWidget(var_label, row, 0)\n                g.addWidget(var_edit, row, 1)\n            elif \'_slider\' in key:\n                var_label = QLabel(key.split(""_"")[0])\n                var_edit = QSlider()\n\n\n    def init_gui(self):\n        """"""Initiera gr\xc3\xa4nssnitt""""""\n\n        self.setGeometry(300, 300, 600, 600)\n        self.setWindowTitle(""Parameter window"")\n\n        self.grid = QGridLayout(self)\n\n        row = 0\n\n        for key, value in self.var_dict.items():\n            var_label = QLabel(key)\n            var_edit = QLineEdit(str(value))\n\n            self.grid.addWidget(var_label, row, 0)\n            self.grid.addWidget(var_edit, row, 1)\n\n            row += 1\n\n        buttons = QHBoxLayout()\n\n        ok_button = QPushButton(""OK"")\n        cancel_button = QPushButton(""Cancel"")\n\n        buttons.addStretch()\n        buttons.addWidget(ok_button)\n        buttons.addWidget(cancel_button)\n        buttons.addStretch()\n\n        self.grid.setRowStretch(row, 10)\n\n        row += 1\n\n        self.grid.addLayout(buttons, row, 0, 1, 2)\n\n        # Visa f\xc3\xb6nster\n\n        self.show()\n\ndef create_window(var_dict):\n    w = GuiWindow(var_dict)\n\n    return w\n\ndef parse_variables(var_dict):\n    """"""Parse variables in current context""""""\n    valid_vars = {}\n\n    for key, value in var_dict.items():\n        if type(value) is int:\n            valid_vars[key] = value\n        if type(value) is float:\n            valid_vars[key] = value\n        if type(value) is list:\n            valid_vars[key] = value\n        if type(value) is bool:\n            valid_vars[key] = value\n\n    return valid_vars\n\ndef edit_params(var_dict):\n    """"""Run Qt event loop""""""\n\n    valid_vars = parse_variables(var_dict)\n    print(valid_vars)\n\n    app = QApplication(sys.argv)\n\n    # Skapa v\xc3\xa5rt MyWindow objekt\n\n    w = create_window(valid_vars)\n\n    # Starta h\xc3\xa4ndelseloop\n\n    app.exec_()\n\ndef edit_geometry(geometry):\n    pass'"
calfem/mesh.py,22,"b'import os\nimport sys\nimport tempfile\nimport shutil\nimport subprocess\nimport numpy as np\nfrom calfem.core import createdofs\nfrom calfem.utils import which\nimport calfem.core as cfc\n\nimport logging as cflog\n\n\ndef error(msg):\n    """"""Log error message""""""\n    cflog.error(msg)\n\n\ndef info(msg):\n    """"""Log information message""""""\n    cflog.info(msg)\n\n\ndef cmp(a, b):\n    return (a > b) ^ (a < b)\n\n# def dofsFromNodes(listOfNodes, dofs):\n#        D = []\n#        for node in listOfNodes:\n#            D.extend(dofs[node])\n#        return D\n\n\ndef _offsetIndices(lst, offset=0):\n    \'\'\'Shifts the indices by offset. \n    Positive offsets move the indices away from 0.\n    Negative offsets move the indices towards 0.\n    If an index is 0 the offset is added to it.\'\'\'\n    return [x + cmp(x, -0.5)*offset for x in lst]\n\n\ndef _formatList(lst, offset=0):\n    """"""\n    Turns a list of numbers into a corresponding string of comma-separated numbers.\n    The parameter offset is a number that is added to the numbers.\n    Can be used for turning a list of 0-based indices into a corresponding string\n    of comma-separated offset indices. Offsets depend on the sign, i.e. negative\n    numbers get the offset subtracted.\n    Do not use offsets on lists with negative float values. \n    """"""\n    # Increment the indices by 1. Join list-elements as strings separated by \', \'.\n    try:\n        return \', \'.join(map(str, _offsetIndices(lst, offset)))\n    except TypeError:\n        # If lst is not iterable (causes TypeError), then it is probably an integer.\n        return lst+offset\n\n\ndef _insertInSetDict(dictionary, key, values):\n    \'\'\'inserts values at key in dictionary containing sets. Values may be\n    a single value or iterable, in which case each value is inserted\'\'\'\n    if not key in dictionary:\n        dictionary[key] = set()\n    try:\n        for v in values:\n            dictionary[key].add(v)\n    # Exception if values is not an iterable - insert values itself instead.\n    except TypeError:\n        dictionary[key].add(values)\n\n\ndef _insertBoundaryElement(boundaryElements, elementType, marker, nodes):\n    """"""\n    Insert an element to the boundaryElements dict.\n\n    Parameters:\n\n        boundaryElements  Dictionary of boundary elements\n\n        elementType       \'elm-type\' according to GMSH\n\n        marker            Boundary marker\n\n        nodes             List of element nodes, order according to GMSH\n    """"""\n    if not marker in boundaryElements:\n        boundaryElements[marker] = []\n    boundaryElements[marker].append(\n        {\'elm-type\': elementType, \'node-number-list\': nodes})\n\n\ndef createGmshMesh(geometry, el_type=2, el_size_factor=1, dofs_per_node=1,\n                   gmsh_exec_path=None, clcurv=False,\n                   min_size=None, max_size=None, meshing_algorithm=None,\n                   additional_options=\'\'):\n\n    meshGen = GmshMeshGenerator(geometry, el_type, el_size_factor, dofs_per_node,\n                                gmsh_exec_path, clcurv, min_size, max_size, meshing_algorithm,\n                                additional_options)\n\n    return meshGen.create()\n\n\ncreateMesh = createGmshMesh\ncreate_mesh = createGmshMesh\nmesh = createGmshMesh\n\n\nclass GmshMeshGenerator:\n    \'\'\'\n    Meshes geometry in GeoData objects or geo-files by calling the Gmsh executable.\n    This is done when the function create() is called.\n    \'\'\'\n\n    def __init__(self, geometry, el_type=2, el_size_factor=1, dofs_per_node=1,\n                 gmsh_exec_path=None, clcurv=False,\n                 min_size=None, max_size=None, meshing_algorithm=None,\n                 additional_options=\'\', mesh_dir=\'\', return_boundary_elements=False):\n        \'\'\'        \n        Parameters:\n\n            geometry        GeoData instance or string containing path to .geo-file\n\n            el_type        Integer. Element type and order. \n                           See gmsh manual for details.\n\n            el_size_factor  Float. Factor by which the element sizes are multiplied.\n\n            dofs_per_node    Number of degrees of freedom per node.\n\n            gmsh_exec_path   File path to where the gmsh executable is located.\n\n            clcurv         Set to true to make elements smaller at high curvatures. \n                           (Experimental option according to the gmsh manual)\n\n            min_size        Minimum element size\n\n            max_size        Maximum element size\n\n            meshing_algorithm  String. Select mesh algorithm (\'meshadapt\', \'del2d\',\n                              \'front2d\',  \'del3d\', \'front3d\', ...). \n                              See the gmsh manual for more info.\n\n            return_boundary_elements  Flag for returning dictionary with boundary element\n                                    information. Useful for applying loads on boundary.\n\n            additional_options  String containing additional command line args for gmsh.\n                               Use this if a gmsh option is not covered by the above \n                               parameters (See section 3.3 in the gmsh manual for a \n                               list of options)):\n           \'\'\'\n        self.geometry = geometry\n        self.el_type = el_type\n        self.el_size_factor = el_size_factor\n        self.dofs_per_node = dofs_per_node\n        self.gmsh_exec_path = gmsh_exec_path\n        self.clcurv = clcurv\n        self.min_size = min_size\n        self.max_size = max_size\n        self.meshing_algorithm = meshing_algorithm\n        self.additional_options = additional_options\n        self.mesh_dir = mesh_dir\n        self.return_boundary_elements = return_boundary_elements\n\n        # gmsh elements that have rectangle faces\n        self._ElementsWithQuadFaces = [3, 5, 10, 12, 16, 17, 92, 93]\n        self._2ndOrderElms = [8,  9, 10, 11, 12,\n                              13, 14, 16, 17, 18,\n                              19]\n        self._2dOrderIncompleteElms = [9, 11, 13, 14,\n                                       16, 17, 18, 19]\n        # Apart from 16 the 2nd orders are totally untested. Only 16 (8-node quad)\n        # is implemented in pycalfem though, so it does not matter.\n\n    def create(self, is3D=False):\n        \'\'\'\n        Meshes a surface or volume defined by the geometry in geoData.\n        Parameters:\n        is3D - Optional parameter that only needs to be set if geometry\n               is loaded from a geo-file, i.e. if geoData is a path string.\n               Default False.\n\n        Returns:\n\n            coords          Node coordinates\n\n                            [[n0_x, n0_y, n0_z],\n                            [   ...           ],\n                            [nn_x, nn_y, nn_z]]\n\n            edof            Element topology\n\n                            [[el0_dof1, ..., el0_dofn],\n                            [          ...          ],\n                            [eln_dof1, ..., eln_dofn]]\n\n            dofs            Node dofs\n\n                            [[n0_dof1, ..., n0_dofn],\n                            [         ...         ],\n                            [nn_dof1, ..., nn_dofn]]\n\n            bdofs           Boundary dofs. Dictionary containing lists of dofs for\n                            each boundary marker. Dictionary key = marker id.\n\n            elementmarkers  List of integer markers. Row i contains the marker of\n                            element i. Markers are similar to boundary markers and\n                            can be used to identify in which region an element lies.\n\n            boundaryElements  (optional) returned if self.return_boundary_elements is true.\n                              Contains dictionary with boundary elements. The keys are markers\n                              and the values are lists of elements for that marker.\n\n        Running this function also creates object variables:\n\n            nodesOnCurve    Dictionary containing lists of node-indices. Key is a \n                            curve-ID and the value is a list of indices of all nodes\n                            on that curve, including its end points.\n\n            nodesOnSurface  Dictionary containing lists of node-indices. Key is a\n                            surface-ID and the value is a list of indices of the nodes\n                            on that surface, including its boundary.\n\n            nodesOnVolume   Dictionary containing lists of node-indices. Key is a\n                            volume-ID and the value is a list of indices of the nodes\n                            in that volume, including its surface. \n        \'\'\'\n        # Nodes per element for different element types:\n        # (taken from Chapter 9, page 89 of the gmsh manual)\n        nodesPerElmDict = {1: 2,   2: 3,   3: 4,   4: 4,   5: 8,\n                           6: 6,   7: 5,   8: 3,   9: 6,  10: 9,\n                           11: 10, 12: 27, 13: 18, 14: 14, 15: 1,\n                           16: 8,  17: 20, 18: 15, 19: 13, 20: 9,\n                           21: 10, 22: 12, 23: 15, 24: 15, 25: 21,\n                           26: 4,  27: 5,  28: 6,  29: 20, 30: 35,\n                           31: 56, 92: 64, 93: 125}\n        nodesPerElement = nodesPerElmDict[self.el_type]\n\n        # Check for GMSH executable [NOTE]Mostly copied from trimesh2d(). TODO: Test on different systems\n        gmshExe = self.gmsh_exec_path\n        if gmshExe == None:\n            gmshExe = """"\n            if sys.platform == ""win32"":\n                gmshExe = which(""gmsh.exe"")\n            else:\n                gmshExe = which(""gmsh"")\n        else:\n            if not os.path.exists(gmshExe):\n                gmshExe = os.path.join(\n                    os.getcwd(), self.gmsh_exec_path)  # Try relative path\n                if not os.path.exists(gmshExe):\n                    gmshExe = None  # Relative path didnt work either\n\n        if gmshExe == None:\n            raise IOError(\n                ""Error: Could not find GMSH. Please make sure that the \\GMSH executable is available on the search path (PATH)."")\n\n        # Create a temporary directory for GMSH\n\n        oldStyleTempDir = False\n\n        if self.mesh_dir != """":\n            tempMeshDir = self.mesh_dir\n            if not os.path.exists(tempMeshDir):\n                os.mkdir(tempMeshDir)\n        else:\n            tempMeshDir = tempfile.mkdtemp()\n\n        # If geometry data is given as a .geo file we will just pass it on to gmsh later.\n        if type(self.geometry) is str:\n            geoFilePath = self.geometry\n            # In this case geoData is a path string, so the dimension must be supplied by the user.\n            dim = 3 if is3D else 2\n            if not os.path.exists(geoFilePath):\n                geoFilePath = os.path.join(\n                    os.getcwd(), geoFilePath)  # Try relative path\n                if not os.path.exists(geoFilePath):\n                    raise IOError(\n                        ""Error: Could not find geo-file "" + geoFilePath)\n        else:\n            # Get the dimension of the model from geoData.\n            dim = 3 if self.geometry.is3D else 2\n\n            if oldStyleTempDir:\n                if not os.path.exists(""./gmshMeshTemp""):\n                    os.mkdir(""./gmshMeshTemp"")\n                geoFilePath = os.path.normpath(os.path.join(\n                    os.getcwd(), ""gmshMeshTemp/tempGeometry.geo""))  # ""gmshMeshTemp/tempGeometry.geo""\n            else:\n                geoFilePath = os.path.normpath(\n                    os.path.join(tempMeshDir, \'tempGeometry.geo\'))\n\n            self.geofile = open(geoFilePath, ""w"")  # Create temp geometry file\n            self._writeGeoFile()  # Write geoData to file\n            self.geofile.close()\n\n        if oldStyleTempDir:\n            # Filepath to the msh-file that will be generated.\n            mshFileName = os.path.normpath(os.path.join(\n                os.getcwd(), \'gmshMeshTemp/meshFile.msh\'))\n        else:\n            mshFileName = os.path.normpath(\n                os.path.join(tempMeshDir, \'meshFile.msh\'))\n\n        # construct options string:\n\n        options = """"\n        options += \' -\' + str(dim)\n        options += \' -clscale \' + str(self.el_size_factor)  # scale factor\n        options += \' -o \\""%s\\""\' % mshFileName\n        options += \' -clcurv\' if self.clcurv else \'\'\n        options += \' -clmin \' + \\\n            str(self.min_size) if self.min_size is not None else \'\'\n        options += \' -clmax \' + \\\n            str(self.max_size) if self.max_size is not None else \'\'\n        options += \' -algo \' + self.meshing_algorithm if self.meshing_algorithm is not None else \'\'\n        options += \' -order 2\' if self.el_type in self._2ndOrderElms else \'\'\n        options += \' -format msh22\'\n        options += \' \' + self.additional_options\n\n        # Execute gmsh\n\n        gmshExe = os.path.normpath(gmshExe)\n        info(""GMSH binary: ""+gmshExe)\n        #print(\'""""%s"" ""%s"" %s""\' % (gmshExe, geoFilePath, options))\n        #os.system(\'""""%s"" ""%s"" %s""\' % (gmshExe, geoFilePath, options))\n        #retval = os.system(r\'""%s"" ""%s"" %s\' % (gmshExe, geoFilePath, options))\n\n        output = subprocess.Popen(r\'""%s"" ""%s"" %s\' % (\n            gmshExe, geoFilePath, options), shell=True, stdout=subprocess.PIPE).stdout.read()\n\n        # Read generated msh file:\n        # print(""Opening msh file "" + mshFileName)#TEMP\n\n        mshFile = open(mshFileName, \'r\')\n        info(""Mesh file  : ""+mshFileName)\n\n        # print(""Reading msh file..."")#TEMP\n        ln = mshFile.readline()\n        while(ln != \'$Nodes\\n\'):  # Read until we find the nodes\n            ln = mshFile.readline()\n        nbrNodes = int(mshFile.readline())\n        allNodes = np.zeros([nbrNodes, dim], \'d\')\n        for i in range(nbrNodes):\n            line = list(map(float, mshFile.readline().split()))\n            # Grab the coordinates (1:3 if 2D, 1:4 if 3D)\n            allNodes[i, :] = line[1:dim+1]\n\n        while(mshFile.readline() != \'$Elements\\n\'):  # Read until we find the elements\n            pass\n        # The nbr of elements (including marker elements).\n        nbrElements = int(mshFile.readline())\n        elements = []\n        elementmarkers = []\n        # temp dictionary of sets. Key:MarkerID. Value:Set. The sets will be converted to lists.\n        bdofs = {}\n        boundaryElements = {}\n        # nodeOnPoint = {}  #dictionary pointID : nodeNumber\n        self.nodesOnCurve = {}  # dictionary lineID  : set of [nodeNumber]\n        self.nodesOnSurface = {}  # dictionary surfID  : set of [nodeNumber]\n        self.nodesOnVolume = {}  # dictionary volID   : set of [nodeNumber]\n        # Read all elements (points, surfaces, etc):\n        for i in range(nbrElements):\n            line = list(map(int, mshFile.readline().split()))\n            eType = line[1]  # second int is the element type.\n            nbrTags = line[2]  # Third int is the nbr of tags on this element.\n            marker = line[3]  # Fourth int (first tag) is the marker.\n            # Fifth int  is the ID of the geometric entity (points, curves, etc) that the element belongs to\n            entityID = line[4]\n            # The rest after tags are node indices.\n            nodes = line[3+nbrTags: len(line)]\n\n            # If the element type is the kind of element we are looking for:\n            if(eType == self.el_type):\n                # Add the nodes of the elements to the list.\n                elements.append(nodes)\n                # Add element marker. It is used for keeping track of elements (thickness, heat-production and such)\n                elementmarkers.append(marker)\n            else:  # If the element is not a ""real"" element we store its node at marker in bdof instead:\n                _insertInSetDict(bdofs, marker, nodes)\n\n                # We also store the full information as \'boundary elements\'\n                _insertBoundaryElement(boundaryElements, eType, marker, nodes)\n\n            # if eType == 15: #If point. Commmented away because points only make elements if they have non-zero markers, so nodeOnPoint is not very useful.\n            #    nodeOnPoint[entityID-1] = nodes[0] #insert node into nodeOnPoint. (ID-1 because we want 0-based indices)\n\n            if eType in [1, 8, 26, 27, 28]:  # If line\n                # insert nodes into nodesOnCurve\n                _insertInSetDict(self.nodesOnCurve, entityID -\n                                 1, _offsetIndices(nodes, -1))\n            elif eType in [2, 3, 9, 10, 16, 20, 21, 22, 23, 24, 25]:  # If surfaceelement\n                # insert nodes into nodesOnSurface\n                _insertInSetDict(self.nodesOnSurface, entityID -\n                                 1, _offsetIndices(nodes, -1))\n            else:  # if volume element.\n                _insertInSetDict(self.nodesOnVolume, entityID -\n                                 1, _offsetIndices(nodes, -1))\n\n        elements = np.array(elements)\n        for key in bdofs.keys():  # Convert the sets of boundary nodes to lists.\n            bdofs[key] = list(bdofs[key])\n        for key in self.nodesOnCurve.keys():  # Convert set to list\n            self.nodesOnCurve[key] = list(self.nodesOnCurve[key])\n        for key in self.nodesOnSurface.keys():  # Convert set to list\n            self.nodesOnSurface[key] = list(self.nodesOnSurface[key])\n        for key in self.nodesOnVolume.keys():  # Convert set to list\n            self.nodesOnVolume[key] = list(self.nodesOnVolume[key])\n\n        mshFile.close()\n\n        # Remove temporary mesh directory if not explicetly specified.\n\n        if self.mesh_dir == """":\n            shutil.rmtree(tempMeshDir)\n\n        dofs = createdofs(np.size(allNodes, 0), self.dofs_per_node)\n\n        if self.dofs_per_node > 1:  # This if-chunk copied from pycalfem_utils.py\n            self.topo = elements\n            expandedElements = np.zeros(\n                (np.size(elements, 0), nodesPerElement*self.dofs_per_node), \'i\')\n            elIdx = 0\n            for elementTopo in elements:\n                for i in range(nodesPerElement):\n                    expandedElements[elIdx, i*self.dofs_per_node:(\n                        i*self.dofs_per_node+self.dofs_per_node)] = dofs[elementTopo[i]-1, :]\n                elIdx += 1\n\n            for keyID in bdofs.keys():\n                bVerts = bdofs[keyID]\n                bVertsNew = []\n                for i in range(len(bVerts)):\n                    for j in range(self.dofs_per_node):\n                        bVertsNew.append(dofs[bVerts[i]-1][j])\n                bdofs[keyID] = bVertsNew\n\n            if self.return_boundary_elements:\n                return allNodes, np.asarray(expandedElements), dofs, bdofs, elementmarkers, boundaryElements\n            return allNodes, np.asarray(expandedElements), dofs, bdofs, elementmarkers\n\n        if self.return_boundary_elements:\n            return allNodes, elements, dofs, bdofs, elementmarkers, boundaryElements\n        return allNodes, elements, dofs, bdofs, elementmarkers\n\n    def _writeGeoFile(self):\n        # key is marker, value is a list of point indices (0-based) with that marker\n        pointMarkers = {}\n        curveMarkers = {}\n        surfaceMarkers = {}\n        volumeMarkers = {}\n\n        # WRITE POINTS:\n        for ID, [coords, elSize, marker] in self.geometry.points.items():\n            self.geofile.write(""Point(%i) = {%s};\\n"" % (\n                ID+1, _formatList(coords + [elSize])))\n            _insertInSetDict(pointMarkers, marker, ID)\n\n        # WRITE CURVES:\n        for ID, [curveName, points, marker, elOnCurve, distributionString, distributionVal] in self.geometry.curves.items():\n            self.geofile.write(""%s(%i) = {%s};\\n"" % (\n                curveName, ID+1, _formatList(points, 1)))\n\n            # Transfinite Line{2} = 20 Using Bump 0.05;\n            if elOnCurve != None:\n                distribution = """" if distributionString == None else ""Using %s %f"" % (\n                    distributionString, distributionVal)\n                self.geofile.write(""Transfinite Line{%i} = %i %s;\\n"" % (\n                    ID+1, elOnCurve+1, distribution))\n                # +1 on elOnCurve because gmsh actually takes the number of nodes on the curve, not elements on the curve.\n            _insertInSetDict(curveMarkers, marker, ID)\n\n        # WRITE SURFACES:\n        for ID, [surfName, outerLoop, holes, ID, marker, isStructured] in self.geometry.surfaces.items():\n            # First we write line loops for the surface edge and holes (if there are any holes):\n            self._writeLineLoop(outerLoop, ID+1)\n            holeIDs = []\n            for hole, i in zip(holes, range(len(holes))):\n                # Create a hopefully unique ID-number for the line loop: Like 10015 or 1540035\n                # (If gmsh uses 32-bit integers for IDs then IDs over 214\'748 will break)\n                holeID = 10000 * (ID+1) + 10 * i + 5\n                self._writeLineLoop(hole, holeID)\n                holeIDs.append(holeID)\n            # Second, we write the surface itself:\n            # If we have hole we want to include them in the surface.\n            holeString = """" if not holeIDs else "", "" + _formatList(holeIDs)\n            # Like ""Plane Surface(2) = {4, 2, 6, 8}\n            self.geofile.write(""%s(%i) = {%s%s};\\n"" % (\n                surfName, ID+1, ID+1, holeString))\n            # Lastly, we make the surface transfinite if it is a structured surface:\n            if isStructured:\n                cornerPoints = set()\n                # Find the corner points. This is possibly unnecessary since Gmsh can do this automatically.\n                for c in outerLoop:\n                    curvePoints = self.geometry.curves[c][1]\n                    cornerPoints.add(curvePoints[0])\n                    cornerPoints.add(curvePoints[-1])\n                cornerPoints = list(cornerPoints)\n                self.geofile.write(""Transfinite Surface{%i} = {%s};\\n"" % (\n                    ID+1, _formatList(cornerPoints, 1)))  # Like Transfinite Surface{1} = {1,2,3,4};\n                # Transfinite Surface has an optional argument (about triangle orientation) that is not implemented here.\n            _insertInSetDict(surfaceMarkers, marker, ID)\n\n        # WRITE VOLUMES:\n        for ID, [outerLoop, holes, ID, marker, isStructured] in self.geometry.volumes.items():\n            # Surface loops for the volume boundary and holes (if any):\n            self._writeSurfaceLoop(outerLoop, ID+1)\n            holeIDs = []\n            for hole, i in zip(holes, range(len(holes))):\n                # ID-number for the hole surface loop\n                holeID = 10000 * (ID+1) + 10 * i + 7\n                self._writeSurfaceLoop(hole, holeID)\n                holeIDs.append(holeID)\n            # Write the volume itself:\n            # If we have hole we want to include them in the surface.\n            holeString = """" if not holeIDs else "" , "" + _formatList(holeIDs)\n            # Like ""Plane Surface(2) = {4, 2, 6, 8}\n            self.geofile.write(\n                ""Volume(%i) = {%s%s};\\n"" % (ID+1, ID+1, holeString))\n            # Lastly, we make the volume transfinite if it is a structured volume:\n            if isStructured:\n                self.geofile.write(""Transfinite Volume{%i} = {};\\n"" % (ID+1))\n                # We don\'t find the corner points of the structured volume like we did with the surfaces. Gmsh can actually\n                # find the corners automatically.\n            _insertInSetDict(volumeMarkers, marker, ID)\n\n        # MAYBE MAKE QUADS:\n        if(self.el_type in self._ElementsWithQuadFaces):  # If we have quads surfaces on the elements\n            self.geofile.write(""Mesh.RecombineAll = 1;\\n"")\n\n        # WRITE POINT MARKERS:\n        for marker, IDlist in pointMarkers.items():\n            if marker != 0:\n                self.geofile.write(""Physical Point(%i) = {%s};\\n"" % (\n                    marker, _formatList(IDlist, 1)))\n\n        # WRITE CURVE MARKERS:\n        for marker, IDlist in curveMarkers.items():\n            self.geofile.write(""Physical Line(%i) = {%s};\\n"" % (\n                marker, _formatList(IDlist, 1)))\n\n        # WRITE SURFACE MARKERS:\n        for marker, IDlist in surfaceMarkers.items():\n            self.geofile.write(""Physical Surface(%i) = {%s};\\n"" % (\n                marker, _formatList(IDlist, 1)))\n\n        # WRITE SURFACE MARKERS:\n        for marker, IDlist in volumeMarkers.items():\n            self.geofile.write(""Physical Volume(%i) = {%s};\\n"" % (\n                marker, _formatList(IDlist, 1)))\n\n        # If the element type is of an incomplete second order type\n        # (i.e it is an 2nd order element without nodes in the middle of the element face),\n        # then we need to specify this in the geo-file:\n        if self.el_type in self._2dOrderIncompleteElms:\n            self.geofile.write(""Mesh.SecondOrderIncomplete=1;\\n"")\n\n    def _writeLineLoop(self, lineIndices, loopID):\n        # endPoints is used to keep track of at which points the curves start and end (i.e the direction of the curves)\n        endPoints = []\n        # lineIndices is a list of curve indices (0-based here, but 1-based later in the method)\n        for i in lineIndices:\n            curvePoints = self.geometry.curves[i][1]\n            endPoints.append([curvePoints[0], curvePoints[-1]])\n\n        # We need the indices to be 1-based rather than 0-based in the next loop. (Some indices will be preceded by a minus-sign)\n        lineIndices = _offsetIndices(lineIndices, 1)\n        isFirstLine = True\n        nbrLinesinLoop = len(lineIndices)\n        # In this loop we reverse the direction of some lines in the LineLoop to make them conform to the format that Gmsh expects.\n        for k in range(nbrLinesinLoop):\n            if isFirstLine and nbrLinesinLoop > 1:\n                isFirstLine = False\n                # If last point of the first line exists in the endpoints of the second line... Do nothing\n                if endPoints[0][1] in endPoints[1]:\n                    pass\n                # Else if the first point in the first line exists in the endpoints of the second line:\n                elif endPoints[0][0] in endPoints[1]:\n                    endPoints[0].reverse()\n                    lineIndices[0] *= -1  # Reverse the direction of the line\n                else:\n                    raise Exception(\n                        ""ERROR: The first curve of line-loop %i does not link up to the subsequent curve"" % loopID)\n            elif endPoints[k][0] == endPoints[k-1][1]:\n                pass\n            elif endPoints[k][1] == endPoints[k-1][1]:\n                endPoints[k].reverse()\n                lineIndices[k] *= -1  # Reverse the direction of the line\n            else:\n                raise Exception(\n                    ""ERROR: The %i th curve (starting from 0) of a line-loop %i does not link up with the preceding curve"" % (k, loopID))\n            if k == nbrLinesinLoop-1 and endPoints[k][1] != endPoints[0][0]:\n                # If last line AND the last point of the last curve not equal the first point of the first curve:\n                raise Exception(\n                    ""ERROR: The last curve of a line-loop %i does not join up with the first curve"" % loopID)\n\n        # If the model is in 2D we need to make all line loops counter-clockwise so surface normals point in the positive z-direction.\n        if not self.geometry.is3D:\n            lineIndices = self._makeCounterClockwise(lineIndices)\n\n        self.geofile.write(""Line Loop(%i) = {%s};\\n"" % (loopID, _formatList(\n            lineIndices)))  # (lineIndices are alreay 1-based here)\n\n    def _makeCounterClockwise(self, lineIndices):\n        \'\'\'If the lineIndices describe a line loop that is not counterclockwise,\n        this function will return a counterclockwise version of lineIndices\n        (i.e. all indices multiplied by -1).\n        lineIndices is a list of integers (1-based line indices) that may be negative, but not 0\'\'\'\n        # Method described at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order\n        summa = 0.0  # Counter-clockwise if the sum ends up negative.\n        for index in lineIndices:\n            sign = -1 if index < 0 else 1\n            # Make a copy of the line index that is positive and 0-based.\n            realIndex = sign*index - 1\n            curveType = self.geometry.curves[realIndex][0]\n            pointIDs = self.geometry.curves[realIndex][1]\n            if curveType in [\'Spline\', \'BSpline\']:\n                points = [self.geometry.points[ID][0]\n                          for ID in pointIDs]  # [[x,y,z], [x,y,z], ...]\n                # Reverse the order of the points if the curve direction is reversed.\n                points = points if sign == 1 else points[::-1]\n                # For every point along the curve except the last:\n                for i in range(len(pointIDs)-1):\n                    # (x2-x1)(y2+y1).\n                    summa += (points[i+1][0] - points[i][0]) * \\\n                        (points[i+1][1] + points[i][1])\n            elif curveType == \'Circle\':\n                # We will find a point \'d\' on the middle of the circle arc, and use a-d-c as approximation of the arc.\n                # 3-by-3 array. The rows are start-center-end points and columns are x,y,z.\n                points = np.array([self.geometry.points[ID][0]\n                                   for ID in pointIDs])\n                # Reverse the order of the points if the curve direction is reversed.\n                points = points if sign == 1 else points[::-1]\n                a = points[0, :]  # start\n                b = points[1, :]  # center\n                c = points[2, :]  # end\n                r = np.linalg.norm(a-b)  # radius\n                d = b + r * (a + 2*b + c) / np.linalg.norm(a + 2*b + c)\n                approxArc = np.vstack((a, d, c))\n                for i in range(len(approxArc)-1):\n                    # (x2-x1)(y2+y1).\n                    summa += (approxArc[i+1, 0] - approxArc[i, 0]) * \\\n                        (approxArc[i+1, 1] + approxArc[i, 1])\n            elif curveType == \'Ellipse\':\n                # We will find a point \'d\' near the middle of the circle arc, and use a-d-c as approximation of the arc.\n                # The only difference from the circle above, is that the radius at d is approximated as the mean distance between\n                # the center and the two other points.\n                # 4-by-3 array. The rows are start-center-majAxis-end points and columns are x,y,z.\n                points = np.array([self.geometry.points[ID][0]\n                                   for ID in pointIDs])\n                # skip the major axis point (row 2)\n                points = points[[0, 1, 3], :]\n                # Reverse the order of the points if the curve direction is reversed.\n                points = points if sign == 1 else points[::-1]\n                a = points[0, :]  # start\n                b = points[1, :]  # center\n                c = points[2, :]  # end\n                r = (np.linalg.norm(a-b) + np.linalg.norm(c-b)) / \\\n                    2  # approximate radius\n                d = b + r * (a + 2*b + c) / np.linalg.norm(a + 2*b + c)\n                approxArc = np.vstack((a, d, c))\n                for i in range(len(approxArc)-1):\n                    # (x2-x1)(y2+y1).\n                    summa += (approxArc[i+1, 0] - approxArc[i, 0]) * \\\n                        (approxArc[i+1, 1] + approxArc[i, 1])\n        # If the sum is positive the loop (closed polygon) is clockwise, so reverse the direction of all curves:\n        if summa > 0:\n            lineIndices = [-x for x in lineIndices]\n        return lineIndices\n\n    def _writeSurfaceLoop(self, outerLoop, ID):\n        self.geofile.write(""Surface Loop(%i) = {%s};\\n"" % (\n            ID, _formatList(outerLoop, 1)))\n\n    # --- Compatibility properties\n\n    @property\n    def elType(self):\n        return self.el_type\n\n    @elType.setter\n    def elType(self, value):\n        self.el_type = value\n\n    @property\n    def elSizeFactor(self):\n        return self.el_size_factor\n\n    @elSizeFactor.setter\n    def elSizeFactor(self, value):\n        self.el_size_factor = value\n\n    @property\n    def dofsPerNode(self):\n        return self.dofs_per_node\n\n    @dofsPerNode.setter\n    def dofsPerNode(self, value):\n        self.dofs_per_node = value\n\n    @property\n    def gmshExecPath(self):\n        return self.gmsh_exec_path\n\n    @gmshExecPath.setter\n    def gmshExecPath(self, value):\n        self.gmsh_exec_path = value\n\n    @property\n    def minSize(self):\n        return self.min_size\n\n    @minSize.setter\n    def minSize(self, value):\n        self.min_size = value\n\n    @property\n    def maxSize(self):\n        return self.max_size\n\n    @maxSize.setter\n    def maxSize(self, value):\n        self.max_size = value\n\n    @property\n    def meshingAlgorithm(self):\n        return self.meshing_algorithm\n\n    @meshingAlgorithm.setter\n    def meshingAlgorithm(self, value):\n        self.meshing_algorithm = value\n\n    @property\n    def additionalOptions(self):\n        return self.additional_options\n\n    @additionalOptions.setter\n    def additionalOptions(self, value):\n        self.additional_options = value\n\n    @property\n    def meshDir(self):\n        return self.mesh_dir\n\n    @meshDir.setter\n    def meshDir(self, value):\n        self.mesh_dir = value\n\n    @property\n    def returnBoundaryElements(self):\n        return self.return_boundary_elements\n\n    @returnBoundaryElements.setter\n    def returnBoundaryElements(self, value):\n        self.return_boundary_elements = value\n\n\nGmshMesh = GmshMeshGenerator\n\n\ndef trimesh2d(vertices, segments=None, holes=None, maxArea=None, quality=True, dofs_per_node=1, logFilename=""tri.log"", triangleExecutablePath=None):\n    """"""\n    Triangulates an area described by a number vertices (vertices) and a set\n    of segments that describes a closed polygon. \n\n    Parameters:\n\n        vertices            array [nVertices x 2] with vertices describing the geometry.\n\n                            [[v0_x, v0_y],\n                             [   ...    ],\n                             [vn_x, vn_y]]\n\n        segments            array [nSegments x 3] with segments describing the geometry.\n\n                            [[s0_v0, s0_v1,marker],\n                             [        ...        ],\n                             [sn_v0, sn_v1,marker]]\n\n        holes               [Not currently used]\n\n        maxArea             Maximum area for triangle. (None)\n\n        quality             If true, triangles are prevented having angles < 30 degrees. (True)\n\n        dofs_per_node         Number of degrees of freedom per node.\n\n        logFilename         Filename for triangle output (""tri.log"")\n\n    Returns:\n\n        coords              Node coordinates\n\n                            [[n0_x, n0_y],\n                             [   ...    ],\n                             [nn_x, nn_y]]\n\n        edof                Element topology\n\n                            [[el0_dof1, ..., el0_dofn],\n                             [          ...          ],\n                             [eln_dof1, ..., eln_dofn]]\n\n        dofs                Node dofs\n\n                            [[n0_dof1, ..., n0_dofn],\n                             [         ...         ],\n                             [nn_dof1, ..., nn_dofn]]\n\n        bdofs               Boundary dofs. Dictionary containing lists of dofs for\n                            each boundary marker. Dictionary key = marker id.\n\n    """"""\n\n    # Check for triangle executable\n\n    triangleExecutable = triangleExecutablePath\n\n    if triangleExecutable == None:\n        triangleExecutable = """"\n        if sys.platform == ""win32"":\n            triangleExecutable = which(""triangle.exe"")\n        else:\n            triangleExecutable = which(""triangle"")\n    else:\n        if not os.path.exists(triangleExecutable):\n            triangleExecutable = None\n\n    if triangleExecutable == None:\n        error(""Error: Could not find triangle. Please make sure that the \\ntriangle executable is available on the search path (PATH)."")\n        return None, None, None, None\n\n    # Create triangle options\n\n    options = """"\n\n    if maxArea != None:\n        options += ""-a%f "" % maxArea + "" ""\n    if quality:\n        options += ""-q""\n\n    # Set initial variables\n\n    nSegments = 0\n    nHoles = 0\n    nAttribs = 0\n    nBoundaryMarkers = 1\n    nVertices = len(vertices)\n\n    # All files are created as temporary files\n\n    if not os.path.exists(""./trimesh.temp""):\n        os.mkdir(""./trimesh.temp"")\n\n    filename = ""./trimesh.temp/polyfile.poly""\n\n    if not segments is None:\n        nSegments = len(segments)\n\n    if not holes is None:\n        nHoles = len(holes)\n\n    # Create a .poly file\n\n    polyFile = open(filename, ""w"")\n    polyFile.write(""%d 2 %d \\n"" % (nVertices, nAttribs))\n\n    i = 0\n\n    for vertex in vertices:\n        polyFile.write(""%d %g %g\\n"" % (i, vertex[0], vertex[1]))\n        i = i + 1\n\n    polyFile.write(""%d %d \\n"" % (nSegments, nBoundaryMarkers))\n\n    i = 0\n\n    for segment in segments:\n        polyFile.write(""%d %d %d %d\\n"" %\n                       (i, segment[0], segment[1], segment[2]))\n        i = i + 1\n\n    polyFile.write(""0\\n"")\n\n    polyFile.close()\n\n    # Execute triangle\n\n    os.system(""%s %s %s > tri.log"" % (triangleExecutable, options, filename))\n\n    # Read results from triangle\n\n    strippedName = os.path.splitext(filename)[0]\n\n    nodeFilename = ""%s.1.node"" % strippedName\n    elementFilename = ""%s.1.ele"" % strippedName\n    polyFilename = ""%s.1.poly"" % strippedName\n\n    # Read vertices\n\n    allVertices = None\n    boundaryVertices = {}\n\n    if os.path.exists(nodeFilename):\n        nodeFile = open(nodeFilename, ""r"")\n        nodeInfo = list(map(int, nodeFile.readline().split()))\n\n        nNodes = nodeInfo[0]\n\n        allVertices = np.zeros([nNodes, 2], \'d\')\n\n        for i in range(nNodes):\n            vertexRow = list(map(float, nodeFile.readline().split()))\n\n            boundaryMarker = int(vertexRow[3])\n\n            if not (boundaryMarker in boundaryVertices):\n                boundaryVertices[boundaryMarker] = []\n\n            allVertices[i, :] = [vertexRow[1], vertexRow[2]]\n            boundaryVertices[boundaryMarker].append(i+1)\n\n        nodeFile.close()\n\n    # Read elements\n\n    elements = []\n\n    if os.path.exists(elementFilename):\n        elementFile = open(elementFilename, ""r"")\n        elementInfo = list(map(int, elementFile.readline().split()))\n\n        nElements = elementInfo[0]\n\n        elements = np.zeros([nElements, 3], \'i\')\n\n        for i in range(nElements):\n            elementRow = list(map(int, elementFile.readline().split()))\n            elements[i, :] = [elementRow[1]+1,\n                              elementRow[2]+1, elementRow[3]+1]\n\n        elementFile.close()\n\n    # Clean up\n\n    try:\n        pass\n        # os.remove(filename)\n        # os.remove(nodeFilename)\n        # os.remove(elementFilename)\n        # os.remove(polyFilename)\n    except:\n        pass\n\n    # Add dofs in edof and bcVerts\n\n    dofs = cfc.createdofs(np.size(allVertices, 0), dofs_per_node)\n\n    if dofs_per_node > 1:\n        expandedElements = np.zeros(\n            (np.size(elements, 0), 3*dofs_per_node), \'i\')\n        dofs = cfc.createdofs(np.size(allVertices, 0), dofs_per_node)\n\n        elIdx = 0\n\n        for elementTopo in elements:\n            for i in range(3):\n                expandedElements[elIdx, i*dofs_per_node:(\n                    i*dofs_per_node+dofs_per_node)] = dofs[elementTopo[i]-1, :]\n            elIdx += 1\n\n        for bVertIdx in boundaryVertices.keys():\n            bVert = boundaryVertices[bVertIdx]\n            bVertNew = []\n            for i in range(len(bVert)):\n                for j in range(dofs_per_node):\n                    bVertNew.append(dofs[bVert[i]-1][j])\n\n            boundaryVertices[bVertIdx] = bVertNew\n\n        return allVertices, np.asarray(expandedElements), dofs, boundaryVertices\n\n    return allVertices, elements, dofs, boundaryVertices\n'"
calfem/misc.py,0,"b'def mlscalar2d(coords, edof, a):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])\n    ascalar = reshape(asarray(a),[size(a)])\n\n    mlab.triangular_mesh(x, y, z, edof-1, scalars=ascalar, representation=""surface"")\n\ndef mlflux2d(coords, vf, scalefactor=None, displaymode=""2darrow""):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])\n    u = reshape(vf[:,0],[size(vf[:,0])])\n    v = reshape(vf[:,1],[size(vf[:,1])])\n    w = zeros([size(vf[:,0])])\n\n    if scalefactor == None:\n        mlab.quiver3d(x, y, z, u, v, w, mode=displaymode)\n    else:\n        mlab.quiver3d(x, y, z, u, v, w, mode=displaymode, scale_factor=scalefactor)\n\n\ndef mlwireframe2d(coords, edof):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])+1\n    scalars = ones([size(coords[:,0])])\n\n    mlab.triangular_mesh(x, y, z, edof-1, scalars=scalars, representation=""mesh"", colormap=""bone"", line_width=20.0)\n    \n\ndef eldisp2(ex,ey,ed,rat=0.2):\n    nen = -1\n    if ex.shape != ey.shape:\n        print(""ex and ey shapes do not match."")\n        return 1.0\n    \n    dlmax = 0.\n    edmax = 1.\n    \n    print(rank(ex))\n\n    if rank(ex)==1:\n        nen = ex.shape[0]\n        nel = 1\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n    else:\n        nen = ex.shape[1]\n        nel = ex.shape[0]\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n        \n    k = rat\n    return k*dlmax/edmax\n'"
calfem/qt5.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Apr 12 23:17:26 2017\n\n@author: jonas_000\n""""""\n\nfrom PyQt5.QtCore import pyqtSlot, pyqtSignal, QMetaObject\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtGui import QPixmap\nfrom PyQt5.uic import loadUi\n'"
calfem/shapes.py,0,"b'import numpy as np\nimport calfem.core as cfc\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\nimport logging as cflog\n\ndef error(msg):\n    cflog.error(""calfem.shapes: ""+msg)\n\ndef info(msg):\n    cflog.info(""calfem.shapes: ""+msg)\n\n\nclass Shape:\n    """"""Base class for shapes""""""\n\n    def __init__(self, element_type = 3, dofs_per_node = 1, max_area = 1.0):\n        self.max_area = max_area\n        self.element_type = element_type\n        self.dofs_per_node = dofs_per_node\n\n    def geometry(self):\n        """"""Return geometry of shape""""""\n        return None\n\n\n\nclass Rectangle(Shape):\n    """"""Rectangle geometry""""""\n    \n    def __init__(self, width=1.0, height=1.0, element_type = 3, dofs_per_node = 1, max_area = -1):\n        Shape.__init__(self, element_type, dofs_per_node, max_area)\n        self.width = width\n        self.height = height\n    \n        if (max_area<0):\n            self.max_area = self.width * self.height * 0.05\n        else:\n            self.max_area = max_area\n        \n        self.left_id = 101\n        self.right_id = 102\n        self.top_id = 103\n        self.bottom_id = 104\n\n    def geometry(self):\n        """"""Return geometry of shape""""""\n        self.g = cfg.Geometry()\n\n        w = self.width\n        h = self.height\n\n        self.g.point([0, 0])\n        self.g.point([w, 0])\n        self.g.point([w, h])\n        self.g.point([0, h])\n\n        self.g.spline([0, 1], marker=self.bottom_id)\n        self.g.spline([1, 2], marker=self.right_id)\n        self.g.spline([2, 3], marker=self.top_id)\n        self.g.spline([3, 0], marker=self.left_id)\n\n        self.g.surface([0,1,2,3])\n\n        return self.g\n\nclass RectangleWithHole(Rectangle):\n    def __init__(self, width=1.0, height=1.0, element_type = 3, dofs_per_node = 1, max_area = -1):\n        super().__init__(self, width, height, element_type, dofs_per_node, max_area)\n\nclass ShapeMesh:\n    """"""Mesh generator for shapes""""""\n    def __init__(self, shape):\n        """"""Initialise mesh generator""""""\n        self.shape = shape\n\n        self.create()\n\n    def create(self):\n        meshGen = cfm.GmshMeshGenerator(self.shape.geometry())\n        meshGen.el_type = self.shape.element_type\n        meshGen.el_size_factor = self.shape.max_area\n        meshGen.dofs_per_node = self.shape.dofs_per_node\n\n        self.coords, self.edof, self.dofs, self.bdofs, self.markers = meshGen.create()\n\n        # --- Ber\xe2\x94\x9c\xc3\xb1kna element koordinater\n\n        self.ex, self.ey = cfc.coordxtr(self.edof, self.coords, self.dofs)\n        self.pointDofs = self.dofs[list(self.shape.g.points.keys()),:]\n\nif __name__ == ""__main__"":\n\n\n    print(""Creating rectangle"")\n    rect = Rectangle(5.0, 1.0, element_type=3, dofs_per_node=2, max_area=0.05)\n\n    print(""Creating mesh..."")\n\n    mesh = ShapeMesh(rect)\n\n    print(mesh.edof)\n    print(mesh.dofs)\n    print(mesh.bdofs[rect.left_id])\n    print(mesh.bdofs[rect.right_id])\n    print(mesh.bdofs[rect.top_id])\n    print(mesh.bdofs[rect.bottom_id])\n    print(mesh.pointDofs)\n'"
calfem/solver.py,8,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Thu Sep 29 23:22:20 2016\n\n@author: jonas_000\n""""""\n\nimport calfem.core as cfc\nimport calfem.utils as cfu\nimport logging as cflog\n\nimport numpy as np\nfrom scipy.sparse import lil_matrix\n\ndef error(msg):\n    cflog.error("" calfem.solver: ""+msg)\n\ndef info(msg):\n    cflog.info("" calfem.solver: ""+msg)\n\n\nclass Results:\n    pass\n\nclass Solver:\n    def __init__(self, mesh):\n        self.results = Results()\n        self.mesh = mesh\n        self.n_dofs = np.size(mesh.dofs)\n        self.n_elements = np.size(self.mesh.edof,0)\n\n        self.bc = np.array([],\'i\')\n        self.bc_val = np.array([],\'i\')\n        self.f = np.zeros([self.n_dofs,1])\n        \n        self.results.el_forces = np.zeros([self.n_elements, self.on_query_el_force_size()])\n        \n    def on_query_el_force_size(self):\n        return 1\n                       \n    def execute(self):\n        info(""Assembling K... (""+str(self.n_dofs)+"")"")\n        self.assem()\n        \n        info(""Solving system..."")        \n        self.results.a, self.results.r = cfc.spsolveq(self.K, self.f, self.bc, self.bc_val)\n        \n        info(""Extracting ed..."")        \n        self.results.ed = cfc.extractEldisp(self.mesh.edof, self.results.a)\n        \n        info(""Element forces... "")\n        self.calc_element_forces()\n        \n        return self.results\n        \n    def assem(self):\n        self.K = lil_matrix((self.n_dofs, self.n_dofs))\n        for eltopo, elx, ely in zip(self.mesh.edof, self.mesh.ex, self.mesh.ey):\n            Ke = self.on_create_Ke(elx, ely, self.mesh.shape.element_type)                \n            cfc.assem(eltopo, self.K, Ke)\n            \n    def addBC(self, marker, value=0.0, dimension=0):\n        self.bc, self.bc_val = cfu.applybc(self.mesh.bdofs, self.bc, self.bc_val, marker, value, dimension)\n        \n    def addForceTotal(self, marker, value=0.0, dimension=0):\n        cfu.applyforcetotal(self.mesh.bdofs, self.f, self.mesh.shape.top_id, value, dimension)\n          \n    def addForce(self, marker, value=0.0, dimension=0):\n        cfu.applyforce(self.mesh.bdofs, self.f, self.mesh.shape.top_id, value, dimension)\n        \n    def addForceNode(self, node, value = 0.0, dimension=0):\n        cfu.applyforcenode(node, value, dimension)\n        \n    def addBCNode(self, node, value = 0.0, dimension = 0):\n        self.bc, self.bc_val = cfu.applybcnode(node, value, dimension)\n\n    def applyBCs(self):\n        self.bc, self.bc_val = self.on_apply_bcs(self.mesh, self.bc, self.bcVal)\n                \n    def calc_element_forces(self):\n        for i in range(self.mesh.edof.shape[0]):\n            el_force = self.on_calc_el_force(self.mesh.ex[i,:], self.mesh.ey[i,:], self.results.ed[i,:], self.mesh.shape.element_type)\n            if el_force!=None:\n                self.results.el_forces[i,:] = el_force\n            else:\n                pass\n            \n            \n    def on_calc_el_force(self, ex, ey, ed, element_type):\n        pass\n\n    def on_create_Ke(self, elx, ely, element_type):\n        pass\n    \n    def on_apply_bcs(self, mesh, bc, bcVal):        \n        pass\n        \n    def on_apply_loads(self, mesh, f):\n        pass\n        \nclass Plan2DSolver(Solver):\n        \n    def on_create_Ke(self, elx, ely, element_type):\n        Ke = None\n        if self.mesh.shape.element_type == 2:\n            Ke = cfc.plante(elx, ely, self.mesh.shape.ep, self.mesh.shape.D)\n        else:\n            Ke = cfc.planqe(elx, ely, self.mesh.shape.ep, self.mesh.shape.D)\n            \n        return Ke\n                    \n    def on_calc_el_force(self, ex, ey, ed, element_type):\n        if element_type == 2: \n            es, et = cfc.plants(ex, ey, self.mesh.shape.ep, self.mesh.shape.D, ed)\n            elMises = np.math.sqrt( pow(es[0,0],2) - es[0,0]*es[0,1] + pow(es[0,1],2) + 3*pow(es[0,2],2) )\n        else:\n            es, et = cfc.planqs(ex, ey, self.mesh.shape.ep, self.mesh.shape.D, ed)\n            elMises = np.math.sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*pow(es[2],2) )\n        \n        return elMises\n\nclass Flow2DSolver(Solver):\n        \n    def on_create_Ke(self, elx, ely, element_type):\n        Ke = None\n        if self.mesh.shape.element_type == 2:\n            Ke = cfc.flw2te(elx, ely, self.mesh.shape.ep, self.mesh.shape.D)\n        else:\n            Ke = cfc.flw2i4e(elx, ely, self.mesh.shape.ep, self.mesh.shape.D)\n            \n        return Ke\n                    \n    def on_calc_el_force(self, ex, ey, ed, element_type):\n        es = None\n        et = None\n        if element_type == 2: \n            es, et = cfc.flw2ts(ex, ey, self.mesh.shape.D, ed)\n        else:\n            es, et, temp = cfc.flw2i4s(ex, ey, self.mesh.shape.ep, self.mesh.shape.D, ed)\n        \n        return [es, et]\n'"
calfem/ui.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Apr 11 09:44:29 2016\n\n@author: lindemann\n""""""\n\nimport os, sys\n\nprint(""------------------------------------"")\nprint(""CALFEM/Python ui module initialising"")\nprint(""------------------------------------"")\nprint()\n\nfrom PyQt5.QtCore import pyqtSlot, pyqtSignal\nfrom PyQt5.QtWidgets import QApplication, QDialog, QWidget, QMainWindow\nfrom PyQt5.QtGui import QPixmap\nfrom PyQt5.uic import loadUi\n\n#from PyQt import QtGui, QtCore, uic\n\n\ng_inSpyder = False\n\nif any(\'SPYDER\' in name for name in os.environ):\n    print(\'Running in Spyder...\')\n    g_inSpyder = True\n    \ng_haveVisVis = True\n\ntry:\n    import visvis as vv\nexcept:\n    g_haveVisVis = False\n        \nif g_haveVisVis:\n    print(""VisVis installed..."")\nelse:\n    print(""VisVis not installed..."")\n    \ndef loadUiWidget(uifilename, parent=None):\n    """"""Load user interface file and return object model""""""\n    ui = loadUi(uifilename, parent)\n    return ui    \n        \ndef appInstance(useVisVis=True):\n    """"""Create a suitable application instance""""""\n    print(""Creating application instance..."")\n    \n    global g_haveVisVis\n    \n    app = None\n    \n    if g_haveVisVis and useVisVis:\n        print(""Using VisVis application instance..."")\n        app = vv.use()\n        app.Create()\n    else:\n        print(""Trying Qt application instance..."") \n        app = QtGui.QApplication.instance()\n        if app is None:\n            print(""Creating new Qt application instance..."")\n            app = QtGui.QApplication(sys.argv)\n        else:\n            print(""Reusing existing Qt application instance..."")\n        \n        if app!=None:\n            app.Run = app.exec_\n            \n    if app is None:\n        print(""No application instance found. Exiting..."")\n        sys.exit(-1)\n\n    return app    '"
calfem/utils.py,35,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nimport os, sys\n\nimport numpy as np\nimport calfem.core as cfc\nimport logging as cflog\n\nhave_pyvtk = True\n\ntry:\n    import pyvtk as vtk\nexcept:\n    have_pyvtk = False\n    pass\n\nhaveMatplotLib = True\nhaveMlab = True\n\ndef error(msg):\n    cflog.error("" ""+msg)\n\ndef info(msg):\n    cflog.info("" ""+msg)\n\n#haveWx = True\n#haveQt = True\n    \n#globalWxApp = None\n#globalQtApp = None\n#globalWindows = []\n#\n#try:\n#    from PyQt import QtGui\n#    from PyQt.QtOpenGL import *\n#    from calfem.classes_qt4 import ElementView\n#    globalQtApp = QtGui.QApplication([""PyCalfem""])\n#except:\n#    haveQt = False    \n#      \n#if not haveQt:\n#    try:\n#        import wx\n#        from calfem.classes_wx import ElementView\n#        globalWxApp = wx.App(0)\n#    except: \n#        haveWx = False\n\nclass ElementProperties(object):\n    def __init__(self):\n        self.ep = {}\n        self.attributes = {}\n        \n    def add(self, markerId, ep=[]):\n        if not markerId in self.ep:\n            self.ep[markerId] = ep\n            \n    def addAttribute(self, markerId, name, value):\n        if not markerId in self.attributes:\n            self.attributes[markerId] = {}\n            self.attributes[markerId][name] = value\n\ndef enableLogging(def_level=cflog.INFO):\n    cflog.basicConfig(format=\'%(asctime)s:%(levelname)s:%(message)s\', level=def_level)\n    \ndef disableLogging():\n    cflog.basicConfig(format=\'%(asctime)s:%(levelname)s:%(message)s\', level=cflog.NOTSET)\n    \n\n\ndef readInt(f):\n    """"""\n    Read a row from file, f, and return a list of integers.\n    """"""\n    return list(map(int, f.readline().split()))\n    \ndef readFloat(f):\n    """"""\n    Read a row from file, f, and return a list of floats.\n    """"""\n    return list(map(float, f.readline().split()))\n    \ndef readSingleInt(f):\n    """"""\n    Read a single integer from a row in file f. All other values on row are discarded.\n    """"""\n    return readInt(f)[0] \n\ndef readSingleFloat(f):\n    """"""\n    Read a single float from a row in file f. All other values on row are discarded.\n    """"""\n    return readFloat(f)[0]\n    \ndef writeSingleFloat(f, floatValue):\n    f.write(""%g\\n"" % floatValue)\n    \ndef writeSingleInt(f, intValue):\n    f.write(""%d\\n"" % intValue)\n\ndef writeFloatList(f, floatList):\n    for floatValue in floatList:\n        f.write(""%g "" % floatValue)\n    f.write(""\\n"")\n    \ndef writeIntList(f, intList):\n    for intValue in intList:\n        f.write(""%d "" % intValue)\n    f.write(""\\n"")\n    \ndef which(filename):\n    """"""\n    Return complete path to executable given by filename.\n    """"""\n    if not (\'PATH\' in os.environ) or os.environ[\'PATH\'] == \'\':\n        p = os.defpath\n    else:\n        p = os.environ[\'PATH\']\n                \n    pathlist = p.split (os.pathsep)\n    pathlist.insert(0,""."")\n    pathlist.insert(0,""/bin"")\n    pathlist.insert(0,""/usr/bin"")\n    pathlist.insert(0,""/opt/local/bin"")\n    pathlist.insert(0,""/usr/local/bin"")\n    pathlist.insert(0,""/Applications/Gmsh.app/Contents/MacOS"")\n    \n    for path in pathlist:\n        f = os.path.join(path, filename)\n        if os.access(f, os.X_OK):\n            return f\n\n    return None\n\ndef applybc(boundaryDofs, bcPrescr, bcVal, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary condition to bcPresc and bcVal matrices. For 2D problems\n    with 2 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        bcPresc             1-dim integer array containing prescribed dofs.\n        bcVal               1-dim float array containing prescribed values.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply bc. 0 - all, 1 - x, 2 - y\n\n    Returns:\n\n        bcPresc             Updated 1-dim integer array containing prescribed dofs.\n        bcVal               Updated 1-dim float array containing prescribed values.\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if (dimension==0):\n            bcAdd = np.array(boundaryDofs[marker])\n            bcAddVal = np.ones([np.size(bcAdd)])*value\n        elif dimension in [1,2]:\n            bcAdd = boundaryDofs[marker][(dimension-1)::2]\n            bcAddVal = np.ones([np.size(bcAdd)])*value\n        else:\n            print(""Error: wrong dimension, "", dimension)\n\n                              \n        newBcPrescr, prescrIdx = np.unique(np.hstack([bcPrescr,bcAdd]), return_index=True)\n        newBcVal = np.hstack([bcVal,bcAddVal])[prescrIdx]\n         \n        return newBcPrescr, newBcVal                     \n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n        \ndef applybc3D(boundaryDofs, bcPrescr, bcVal, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary condition to bcPresc and bcVal matrices. For 3D problems\n    with 3 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        bcPresc             1-dim integer array containing prescribed dofs.\n        bcVal               1-dim float array containing prescribed values.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply bc. 0 - all, 1 - x, 2 - y,\n                            3 - z\n\n    Returns:\n\n        bcPresc             Updated 1-dim integer array containing prescribed dofs.\n        bcVal               Updated 1-dim float array containing prescribed values.\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if (dimension==0):\n            bcAdd = np.array(boundaryDofs[marker])\n            bcAddVal = np.ones([np.size(bcAdd)])*value\n        elif dimension in [1,2,3]:\n            bcAdd = boundaryDofs[marker][(dimension-1)::3]\n            bcAddVal = np.ones([np.size(bcAdd)])*value\n        else:\n            print(""Error: wrong dimension, "", dimension)\n\n                              \n        newBcPrescr, prescrIdx = np.unique(np.hstack([bcPrescr,bcAdd]), return_index=True)\n        newBcVal = np.hstack([bcVal,bcAddVal])[prescrIdx]\n         \n        return newBcPrescr, newBcVal                     \n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n        \ndef applybcnode(nodeIdx, dofs, bcPrescr, bcVal, value=0.0, dimension=0):\n    \n    if (dimension==0):\n        bcAdd = np.asarray(dofs[nodeIdx])\n        bcAddVal = np.ones([np.size(bcAdd)])*value\n    elif dimension in [1,2,3]:\n        bcAdd = np.asarray(dofs[nodeIdx,dimension-1])\n        bcAddVal = np.ones([np.size(bcAdd)])*value\n    else:\n        print(""Error: wrong dimension, "", dimension)\n\n    return np.hstack([bcPrescr,bcAdd]), np.hstack([bcVal,bcAddVal])\n    \n\ndef applyforcenode(nodeIdx, dofs, f, value=0.0, dimension=0):\n\n    if (dimension==0):\n        f[dofs[nodeIdx]]+=value\n    elif (dimension==1):\n        f[dofs[nodeIdx,dimension-1]]+=value\n    else:\n        f[dofs[nodeIdx,dimension-1]]+=value\n        \ndef applyforce(boundaryDofs, f, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary force to f matrix. The value is\n    added to all boundaryDofs defined by marker. Applicable\n    to 2D problems with 2 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        f                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply force. 0 - all, 1 - x, 2 - y\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if dimension == 0:\n            f[np.asarray(boundaryDofs[marker])-1] += value\n        elif dimension in [1,2]:\n            f[np.asarray(boundaryDofs[marker][(dimension-1)::2])-1] += value  \n        else:\n            print(""Error: The dimension, "", dimension,"", is invalid"")\n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n\n\ndef applyTractionLinearElement(boundaryElements, coords, dofs, F, marker, q):\n    """"""\n    Apply traction on part of boundarty with marker.\n    q is added to all boundaryDofs defined by marker. Applicable\n    to 2D problems with 2 dofs per node. The function works with linear\n    line elements. (elm-type 1 in GMSH).\n\n    Parameters:\n\n        boundaryElements    Dictionary with boundary elements, the key is a marker and the values are lists of elements.\n        coords              Coordinates matrix\n        dofs                Dofs matrix\n        F                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        q                   Value to assign boundary condition.\n                            shape = [qx qy] in global coordinates\n\n    """"""\n    if marker not in boundaryElements:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n        return\n    for element in boundaryElements[marker]:\n        if element[\'elm-type\'] != 1:\n            print(""Error: Wrong element type."")\n            return\n\n    q = np.matrix(q).T\n\n    # Integration points and weights:\n    Xi = [-1/np.sqrt(3), 1/np.sqrt(3)]\n    W = [1, 1]\n\n    # Shape functions:\n    N1 = lambda x: 1-(1+x)/2\n    N2 = lambda x: (1+x)/2\n\n    for element in boundaryElements[marker]:\n        # Loop through integration points:\n        f = np.zeros([4, 1])\n        for xi, w in zip(Xi,W):\n            N = np.matrix([[N1(xi),      0,  N2(xi),       0],\n                           [     0, N1(xi),        0, N2(xi)]] )\n            coord = coords[ np.array(element[\'node-number-list\'])-1] # The minus one is since the nodes in node-number-list start at 1...\n            v1 = coord[0, :]\n            v2 = coord[1, :]\n            J = np.linalg.norm(v1-v2) / 2\n            f += w * N.T * q * J\n\n        idx = dofs[np.array(element[\'node-number-list\'])-1,:].flatten()-1 # Minus one since dofs start at 1...\n        F[idx] += f\n\n\ndef applyforce3D(boundaryDofs, f, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary force to f matrix. The value is\n    added to all boundaryDofs defined by marker. Applicable\n    to 3D problems with 3 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        f                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply force. 0 - all, 1 - x, 2 - y, \n                            3 - z\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if dimension == 0:\n            f[np.asarray(boundaryDofs[marker])-1] += value\n        elif dimension in [1,2,3]:\n            f[np.asarray(boundaryDofs[marker][(dimension-1)::3])-1] += value  \n        else:\n            print(""Error: The dimension, "", dimension,"", is invalid"")\n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n\ndef applyforcetotal(boundaryDofs, f, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary force to f matrix. Total force, value, is\n    distributed over all boundaryDofs defined by marker. Applicable\n    to 2D problems with 2 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        f                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        value               Total force value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply force. 0 - all, 1 - x, 2 - y\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if dimension == 0:\n            nDofs = len(boundaryDofs[marker])\n            valuePerDof = value / nDofs\n            f[np.asarray(boundaryDofs[marker])-1] += valuePerDof\n        elif dimension in [1,2]:\n            nDofs = len(boundaryDofs[marker][(dimension-1)::2])\n            valuePerDof = value / nDofs\n            f[np.asarray(boundaryDofs[marker][(dimension-1)::2])-1] += valuePerDof\n        else:\n            print(""Error: The dimension, "", dimension,"", is invalid"")\n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n\ndef applyforcetotal3D(boundaryDofs, f, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary force to f matrix. Total force, value, is\n    distributed over all boundaryDofs defined by marker. Applicable\n    to 3D problems with 3 dofs per node.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        f                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        value               Total force value to assign boundary condition.\n                            If not given 0.0 is assigned.\n        dimension           dimension to apply force. 0 - all, 1 - x, 2 - y,\n                            3 - z\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if dimension == 0:\n            nDofs = len(boundaryDofs[marker])\n            valuePerDof = value / nDofs\n            f[np.asarray(boundaryDofs[marker])-1] += valuePerDof\n        elif dimension in [1,2,3]:\n            nDofs = len(boundaryDofs[marker][(dimension-1)::3])\n            valuePerDof = value / nDofs\n            f[np.asarray(boundaryDofs[marker][(dimension-1)::3])-1] += valuePerDof\n        else:\n            print(""Error: The dimension, "", dimension,"", is invalid"")\n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n\ndef export_vtk_stress(filename, coords, topo, a=None, el_scalar=None, el_vec1=None, el_vec2=None):\n    """"""\n    Export mesh and results for a 2D stress problem.\n    \n    Parameters:\n    \n        filename            Filename of vtk-file\n        coords              Element coordinates (np.array)\n        topo                Element topology (not dof topology). mesh.topo. (np.array)\n        a                   Element displacements 2-dof (np.array)\n        el_scalar           Scalar values for each element (list)\n        el_vec1             Vector value for each element (list)\n        el_vec2             Vector value for each element (list)\n    """"""\n\n    points = coords.tolist()\n    polygons = (topo-1).tolist()\n\n    displ = []\n\n    point_data = None\n    scalars = None\n    vectors1 = None\n    vectors2 = None\n    cell_data = None\n\n    if a is not None:\n        for i in range(0,len(a),2):\n            displ.append([np.asscalar(a[i]), np.asscalar(a[i+1]), 0.0])\n                    \n        point_data = vtk.PointData(vtk.Vectors(displ, name=""displacements""))\n\n    if el_scalar is not None:\n        scalars = vtk.Scalars(el_scalar, name=""scalar"")\n    if el_vec1 is not None:\n        vectors1 = vtk.Vectors(el_vec1, name=""principal1"")\n    if el_vec2 is not None:\n        vectors2 = vtk.Vectors(el_vec2, name=""principal2"")\n\n    if el_scalar is not None and el_vec1 is None and el_vec2 is None:\n        cell_data = vtk.CellData(scalars)\n    if el_scalar is not None and el_vec1 is None and el_vec2 is not None:\n        cell_data = vtk.CellData(scalars, vectors2)\n    if el_scalar is not None and el_vec1 is not None and el_vec2 is None:\n        cell_data = vtk.CellData(scalars, vectors1)\n    if el_scalar is not None and el_vec1 is not None and el_vec2 is None:\n        cell_data = vtk.CellData(scalars, vectors1, vectors2)\n    if el_scalar is None and el_vec1 is None and el_vec2 is not None:\n        cell_data = vtk.CellData(vectors2)\n    if el_scalar is None and el_vec1 is not None and el_vec2 is None:\n        cell_data = vtk.CellData(vectors1)\n    if el_scalar is None and el_vec1 is not None and el_vec2 is None:\n        cell_data = vtk.CellData(vectors1, vectors2)\n\n    structure = vtk.PolyData(points = points, polygons = polygons)\n\n    if cell_data is not None and point_data is not None:\n        vtk_data = vtk.VtkData(structure, cell_data, point_data)\n    if cell_data is None and point_data is not None:\n        vtk_data = vtk.VtkData(structure, point_data)\n    if cell_data is None and point_data is None:\n        vtk_data = vtk.VtkData(structure)\n\n    vtk_data.tofile(""exm6.vtk"", ""ascii"")\n               \ndef scalfact2(ex,ey,ed,rat=0.2):\n    """"""\n    Determine scale factor for drawing computational results, such as \n    displacements, section forces or flux.\n    \n    Parameters:\n    \n        ex, ey      element node coordinates\n                       \n        ed          element displacement matrix or section force matrix\n    \n        rat         relation between illustrated quantity and element size. \n                    If not specified, 0.2 is used.\n        \n    """"""\n\n    nen = -1\n    if ex.shape != ey.shape:\n        print(""ex and ey shapes do not match."")\n        return 1.0\n    \n    dlmax = 0.\n    edmax = 1.\n    \n    if np.rank(ex)==1:\n        nen = ex.shape[0]\n        nel = 1\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n    else:\n        nen = ex.shape[1]\n        nel = ex.shape[0]\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n        \n    k = rat\n    return k*dlmax/edmax\n'"
calfem/vis.py,51,"b'# -*- coding: utf-8 -*-\n\nimport visvis as vv\n\nfrom visvis.wibjects.colorWibjects import Colorbar\nfrom visvis import Colormapable\nfrom visvis.wobjects.textures import minmax\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport OpenGL.GL as gl #@UnresolvedImport\n\nfrom numpy import sin, cos, pi\nfrom math import atan2\n\nimport logging as cflog\n\nglobalWindows = [] # For supporting ElementView:s for eldraw ...\n\nglobal globalVisVisApp\n\nglobal visApp\nvisApp = vv.use(\'qt5\') # use qt4\n\n\ndef error(msg):\n    """"""Log error message""""""\n    cflog.error(msg)\n\ndef info(msg):\n    """"""Log information message""""""\n    cflog.info(msg)\n\ndef figure_class():\n    """"""Return visvis Figure class.""""""\n    global visApp\n    return visApp.GetFigureClass()\n\nfigureClass = figure_class\n\ndef figure(figure=None, show=True):\n    """"""Create a visvis figure with extras.""""""\n    f = None\n    \n    if figure == None:\n        f = vv.figure()\n    else:\n        try:\n            f = vv.figure(figure)\n        except:\n            f = vv.figure() \n\n    if show:\n        f._widget.show()\n        f._widget.raise_()\n        \n    return f\n\ndef close_all():\n    """"""Close all visvis windows.""""""\n    vv.closeAll()\n    \ncloseAll = close_all\n    \ndef clf():\n    """"""Clear visvis figure""""""\n    vv.clf()\n    \ndef gca():\n    """"""Get current axis of the current visvis figure.""""""\n    return vv.gca()\n    \ndef subplot(*args):\n    """"""Create a visvis subplot.""""""\n    return vv.subplot(*args)\n    \ndef camera3d():\n    """"""Get visvis 3D camera.""""""\n    return vv.cameras.ThreeDCamera()\n\ndef show_grid(flag = True):\n    """"""Show grid.""""""\n    vv.gca().axis.showGrid = flag    \n    \nshowGrid = show_grid\n        \ndef show_and_wait():\n    """"""Show visvis windows and enter application loop.""""""\n    global globalVisVisApp\n    globalVisVisApp = vv.use()\n    globalVisVisApp.Create()\n    globalVisVisApp.Run()\n    \nshowAndWait = show_and_wait\n    \ndef show_and_wait_mpl():\n    plt.show()\n    \nshowAndWaitMpl = show_and_wait_mpl\n\ndef get_color_bar(axes=None):\n    \'\'\'\n    Returns the Colorbar.\n    If axes is None the colorbar in the current axes will be found.\n    If several colorbars exists in the axes the first found will be returned\n    If no colorbar is found None is returned.\n    \'\'\'\n    #An ugly solution, but visvis seems to have no other way of getting the colorbar,\n    #or most other entities that exist in the axes. \n    if axes is None:\n        axes = vv.gca()\n    for obj in axes.children: \n        if type(obj) == Colorbar:\n            return obj  \n    return None\n\ngetColorbar = get_color_bar\n    \ndef color_bar(axes=None):\n    """"""Short form of getColorbar""""""\n    return getColorbar(axes)\n\ncolorBar = color_bar\n    \n\ndef _makeColorBar(text, axes=None):\n    \'\'\'\n    Convenience function that finds the current colorbar in the axes\n    or creates a new one if one does not exist.\n    The reason is that colorbars can not be deleted without clearing \n    the whole figure, and several colorbars can exist simultaneously. \n    This should be avoided.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    colBar = getColorbar(axes)\n    if colBar is None:\n        vv.colorbar(axes).SetLabel(text) #Creates a colorbar and sets the label.\n    else:\n        colBar.SetLabel(text)# A colorbar already exists, Change label.\n\ndef add_label(text, pos, angle=0, font_name=None, font_size=9, color=\'k\', bgcolor=None, axes=None):\n    \'\'\'\n    Adds a label inside the axes. Returns the Label object.\n    Parameters:\n    text    - String. The text of the label\n    pos     - Tuple with two numbers. The (x,y) position of the label with origin\n              at the upper left corner.\n    angle   - Float or int. The rotation of the label in degrees.\n    font_name- String. Either \'mono\', \'sans\' or \'serif\'.\n    font_size- Int. Size of the text. Default 9.\n    color   - A 3-tuple or a character in \'rgbycmkw\', etc that defines text color.\n              Default \'k\' (black).\n    bgcolor - Background color. See color. Default None.\n    axes    - Axes wherein the label is placed. If None then the current axes is\n              chosen.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    label = vv.Label(axes, text, font_name, font_size, color)\n    label.position = pos\n    label.bgcolor = bgcolor\n    label.textAngle = angle\n    return label\n\naddLabel = add_label\n\ndef label(text, pos, angle=0, font_name=None, font_size=9, color=\'k\', bgcolor=None, axes=None):\n    return addLabel(text, pos, angle, font_name, font_size, color, bgcolor, axes)    \n\ndef add_text(text, pos, angle=0, font_name=None, font_size=9, color=\'k\', bgcolor=None, axes=None):\n    \'\'\'\n    Adds a text in the world space. Returns the Text object.\n    Parameters:\n    text    - String. The text of the label\n    pos     - Tuple with two or three numbers. The (x,y,z) position of the text in\n              world space.\n    angle   - Float or int. The rotation of the label in degrees.\n    font_name- String. Either \'mono\', \'sans\' or \'serif\'.\n    font_size- Int. Size of the text. Default 9.\n    color   - A 3-tuple or a character in \'rgbycmkw\', etc that defines text color.\n              Default \'k\' (black).\n    bgcolor - Background color. See color. Default None.\n    axes    - Axes wherein the label is placed. If None then the current axes is \n              chosen.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    text = vv.Text(axes, text, *pos, fontName=font_name, fontSize=font_size, color=color)\n    text.bgcolor = bgcolor\n    text.textAngle = angle\n    return text\n\naddText = add_text\n\ndef text(txt, pos, angle=0, font_name=None, font_size=9, color=\'k\', bgcolor=None, axes=None):\n    return addText(txt, pos, angle, font_name, font_size, color, bgcolor, axes)   \n\ndef draw_mesh(coords, edof, dofs_per_node, el_type, axes=None, axes_adjust=True, \n             title=None, color=(0,0,0), face_color=(1,1,1), filled=False):\n    \'\'\'\n    Draws wire mesh of model in 2D or 3D. Returns the Mesh object that represents\n    the mesh.\n    Parameters:\n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofs_per_node - Integer. Dofs per node.\n    el_type      - Integer. Element Type. See Gmsh manual for details. Usually 2\n                  for triangles or 3 for quadrangles.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axes_adjust  - Boolean. True if the view should be changed to show the whole\n                  model. Default True.\n    title       - String. Changes title of the figure. Default ""Mesh"".\n    color       - 3-tuple or char. Color of the wire. Defaults to black (0,0,0).\n                  Can also be given as a character in \'rgbycmkw\'.\n    face_color   - 3-tuple or char. Color of the faces. Defaults to white (1,1,1).\n                  Parameter filled must be True or faces will not be drawn at all.\n    filled      - Boolean. Faces will be drawn if True. Otherwise only the wire is\n                  drawn. Default False.\n    \'\'\'\n    #Prep:\n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofs_per_node, el_type)\n    #Create mesh:\n    m = vv.Mesh(parent=axes, vertices=verts, faces=faces, values=color, verticesPerFace=verticesPerFace)\n    #Settings:\n    fShade = \'plain\' if filled else None\n    m.faceShading, m.edgeShading = (fShade, \'plain\')\n    m.edgeColor = color\n    m.face_color = face_color\n    m.specular = 0 \n    #Adjust axes:\n    if axes_adjust:\n        _adjustaxes(axes, is3D)\n    #Set title and return:\n    vv.title(title, axes)\n    return m\n    \ndrawMesh = draw_mesh\n    \ndef draw_nodal_values(node_vals, coords, edof, dofs_per_node, el_type, clim=None, axes=None, axes_adjust=True, draw_elements=True, title=None):\n    \'\'\'\n    Draws scalar nodal values in 2D or 3D. Returns the Mesh object that represents\n    the mesh.\n    Parameters:\n    node_vals    - An N-by-1 array or a list of scalars. The Scalar values at the\n                  nodes. node_vals[i] should be the value of node i \n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements \n                  and L is the number of dofs per element)\n    dofs_per_node - Integer. Dofs per node.\n    el_type      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set to\n                  min/max of node_vals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axes_adjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    draw_elements  - Boolean. True if mesh wire should be drawn. Default True.\n    title       - String. Changes title of the figure. Default ""Node Values"".\n    \'\'\'    \n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofs_per_node, el_type)\n    m = vv.Mesh(parent=axes, vertices=verts, faces=faces, values=node_vals, verticesPerFace=verticesPerFace)\n    \n    if clim != None: #Set colorbar limits.\n        m.clim = clim\n        setClim = False\n    else:\n        setClim = True\n    \n    edgeSh = \'plain\' if draw_elements else None\n    m.faceShading, m.edgeShading = (\'smooth\', edgeSh)#NOTE: It seems colormap coloring breaks when faceshading=\'plain\'. \'smooth\' must be used.\n    m.ambient = 1\n    m.diffuse = 0\n    m.specular = 0 #Disable specular. \n    m.SetValues(node_vals, setClim) #Set the values again, because it doesn\'t work in the constructor for unknown reasons\n    \n    axes.light0.ambient = 1.0\n    axes.light0.diffuse = 0.0  #Only ambient light to avoid shadows\n    \n    m.colormap = vv.colormaps[\'jet\']\n    _makeColorBar(""Node values"", axes)\n        \n    # Adjust axes:\n    if axes_adjust:\n        _adjustaxes(axes, is3D)\n    \n    vv.title(title, axes)\n    return m\n\ndrawNodalValues = draw_nodal_values\n    \ndef draw_element_values(ev, coords, edof, dofs_per_node, el_type, displacements=None, clim=None, axes=None, \n                      axes_adjust=True, draw_elements=True, draw_undisplaced_mesh=False, magnfac=1.0, title=None):\n    \'\'\'\n    Draws scalar element values in 2D or 3D. Returns the world object \n    elementsWobject that represents the mesh.\n    Parameters:\n    ev          - An N-by-1 array or a list of scalars. The Scalar values of the\n                  elements. ev[i] should be the value of element i. \n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofs_per_node - Integer. Dofs per node.\n    el_type      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    displacements - An N-by-2 or N-by-3 array. Row i contains the x,y,z \n                    displacements of node i.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set to\n                  min/max of node_vals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axes_adjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    draw_elements  - Boolean. True if mesh wire should be drawn. Default True.\n    draw_undisplaced_mesh - Boolean. True if the wire of the undisplaced mesh \n                  should be drawn on top of the displaced mesh. Default False. \n                  Use only if displacements != None.\n    magnfac     - Float. Magnification factor. Displacements are multiplied by\n                  this value. Use this to make small displacements more visible.\n    title       - String. Changes title of the figure. Default ""Element Values"".\n    \'\'\'\n    #Since vis.Mesh does not allow setting different colours for different faces, we need\n    # a custom world object (WObject) for this function. \n    # http://code.google.com/p/visvis/wiki/example_customWobject\n    # http://code.google.com/p/visvis/wiki/creatingWibjectsAndWobjects\n    \n\n    if draw_undisplaced_mesh:\n        drawMesh(coords, edof, dofs_per_node, el_type, axes, axes_adjust, color=(0.5, 0.5, 0.5))\n    \n    if displacements is not None:\n        if displacements.shape[1] != coords.shape[1]:\n            displacements = np.reshape(displacements, (-1, coords.shape[1]))\n            coords = np.asarray(coords + magnfac * displacements)\n    \n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofs_per_node, el_type)\n    \n    \n    #This is done because 3D elements are made up of several faces.\n    #TODO: Discard inner faces that are not visible.\n    fPerElms = { 1:0,   2:1,   3:1,   4:4,   5:6} #TODO: Extend with more element types\n    facesPerElement = fPerElms[el_type]\n    #Repeat the element values so that we get the value of each face:\n    faceVals = np.repeat(ev, facesPerElement, axis=0) \n\n    c = _elementsWobject(axes, faceVals, verts, faces, verticesPerFace, draw_elements, clim) #Creates the world object that gets drawn on screen.\n    \n    _makeColorBar(""Element values"", axes) #Finds or creates colorbar and sets the label.\n    \n    # Adjust axes\n    if axes_adjust:\n        _adjustaxes(axes, is3D)\n    \n    vv.title(title, axes)\n    return c\n\ndrawElementValues = draw_element_values\n    \ndef draw_displacements(displacements, coords, edof, dofs_per_node, el_type, node_vals=None, clim=None, axes=None, \n                      axes_adjust=True, draw_undisplaced_mesh=True, magnfac=1.0,  title=None):\n    \'\'\'\n    Draws mesh with displacements in 2D or 3D. Scalar nodal values can also be \n    drawn on the mesh. Returns the displaced Mesh object.\n    Parameters:\n    displacements-An N-by-1 array (or matrix). Row i contains the displacement of\n                  dof i. \n                  N-by-2 or N-by-3 arrays are also accepted, in which case row i \n                  contains the x,y,z displacements of node i.\n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofs_per_node - Integer. Dofs per node.\n    el_type      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    node_vals    - An N-by-1 array or a list of scalars. The Scalar values at the\n                  nodes. node_vals[i] should be the value of node i.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set \n                  to min/max of node_vals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axes_adjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    draw_elements  - Boolean. True if mesh wire should be drawn. Default True.\n    magnfac     - Float. Magnification factor. Displacements are multiplied by\n                  this value. Use this to make small displacements more visible.\n    title       - String. Changes title of the figure. Default None (in which case\n                  title depends on other parameters).\n    \'\'\'\n    \n    if displacements.shape[1] != coords.shape[1]:\n        displacements = np.reshape(displacements, (-1, coords.shape[1]))\n    displaced = np.asarray(coords + magnfac * displacements)\n       \n    if draw_undisplaced_mesh:\n        drawMesh(coords, edof, dofs_per_node, el_type, axes, axes_adjust, title=title, color=(0.5, 0.5, 0.5), filled=False)\n    \n    if node_vals != None:\n        m = drawNodalValues(node_vals, displaced, edof, dofs_per_node, el_type, clim=clim, axes=axes, axes_adjust=axes_adjust, draw_elements=True, title=title)\n    else:\n        m = drawMesh(displaced, edof, dofs_per_node, el_type, axes, axes_adjust, title=title) \n    \n    if title != None:\n        vv.title(title, axes)\n    return m\n\ndrawDisplacements = draw_displacements\n    \ndef draw_geometry(geoData, axes=None, axes_adjust=True, draw_points=True, label_points=True, label_curves=True, title=None, font_size=11, N=20):\n    \'\'\'\n    Draws the geometry (points and curves) in geoData\n    Parameters:\n    geoData    - GeoData object. Geodata contains geometric information of the \n                 model.\n    axes       - Visvis Axes. The Axes where the model will be drawn. \n                 If unspecified the current Axes will be used, or a new Axes will\n                 be created if none exist.\n    axes_adjust - Boolean. If True the view will be changed to show the whole \n                 model. Default True.\n    draw_points - Boolean. If True points will be drawn.\n    label_points- Boolean. If True Points will be labeled. The format is:\n                 ID[marker]. If a point has marker==0 only the ID is written. \n    label_curves- Boolean. If True Curves will be labeled. The format is: \n                 ID(elementsOnCurve)[marker].\n    font_size   - Integer. Size of the text in the text labels. Default 11. \n    N          - Integer. The number of discrete points per curve segment. \n                 Default 20. Increase for smoother curves. Decrease for better \n                 performance.\n    \'\'\'\n    \n    if axes is None:\n        axes = vv.gca()\n    axes.bgcolor = (0.7, 0.7, 0.7)\n    \n    if draw_points:\n        P = np.array(geoData.getPointCoords()) #M-by-3 list of M points.\n        plotArgs = {\'mc\':\'r\', \'mw\':5, \'lw\':0, \'ms\':\'o\', \'axes_adjust\':False, \'axes\':axes}\n        if geoData.is3D: \n            vv.plot(P[:,0], P[:,1], P[:,2], **plotArgs)\n        else:\n            vv.plot(P[:,0], P[:,1], **plotArgs)           \n        \n        if label_points: #Write text label at the points:\n            for (ID, (xyz, el_size, marker)) in geoData.points.items(): #[[x, y, z], el_size, marker]\n                text = ""  "" + str(ID) + (""[%s]""%marker if marker is not 0 else \'\')\n                addText(text, xyz, font_size=font_size-1, color=(0.5,0,0.5), axes=axes)  \n    \n    for(ID, (curveName, pointIDs, marker, elementsOnCurve, _, _)) in geoData.curves.items():\n        points = geoData.getPointCoords(pointIDs)\n        if curveName == ""Spline"":\n            P = _catmullspline(points, N)\n        if curveName == ""BSpline"":\n            P = _bspline(points, N)\n        if curveName == ""Circle"":\n            P = _circleArc(*points, pointsOnCurve=N)\n        if curveName == ""Ellipse"":\n            P = _ellipseArc(*points, pointsOnCurve=N)\n        plotArgs = {\'lc\':\'k\', \'ms\':None, \'axes_adjust\':False, \'axes\':axes} #Args for plot style. Black lines with no symbols at points.\n        if geoData.is3D:\n            vv.plot(P[:,0], P[:,1], P[:,2], **plotArgs)\n        else:\n            vv.plot(P[:,0], P[:,1], **plotArgs)\n        \n        if label_curves:\n            midP = P[int(P.shape[0]*7.0/12), :].tolist() # Sort of midpoint along the curve. Where the text goes.\n            #Create the text for the curve. Includes ID, elementsOnCurve, and marker:\n            text = "" ""+str(ID)\n            text += ""(%s)""%(elementsOnCurve) if elementsOnCurve is not None else \'\'\n            text += ""[%s]""%(marker) if marker is not 0 else \'\' #Something like ""4(5)[8]""\n            addText(text, midP, font_size=font_size, axes=axes)\n        \n    if title != None:\n        vv.title(title, axes)\n    \n    if axes_adjust:\n        _adjustaxes(axes, geoData.is3D)\n    axes.daspectAuto = False\n    axes.daspect = (1,1,1)\n    \ndrawGeometry = draw_geometry\n\ndef _preMeshDrawPrep(axes, coords, edof, dofs_per_node, el_type):\n    \'\'\'Duplicate code. Extracts verts, faces and verticesPerFace from input.\'\'\'\n    if axes is None:\n        axes = vv.gca() #Gets current Axis or creates a new one if none exists.\n    \n    if np.shape(coords)[1] == 2:\n        is3D = False\n        verts = np.hstack((coords, np.zeros([np.shape(coords)[0],1]))) #pad with zeros to make 3D\n    elif np.shape(coords)[1] == 3:\n        is3D = True\n        verts = coords\n    else:\n        raise ValueError(\'coords must be N-by-2 or N-by-3 array\')\n    \n    if el_type in [2, 4]: #elements with triangular faces    \n        verticesPerFace = 3\n    elif el_type in [3,5,16]: #elements with rectangular faces\n        verticesPerFace = 4\n    else:   #[NOTE] This covers all element types available in CALFEM plus tetrahedrons. If more element types are added it is necessary to include them here and below.\n        raise ValueError(\'element type not implemented\')\n    \n    faces = (edof[:,0::dofs_per_node]-1)/dofs_per_node  \n\t#\'faces\' here are actually lists of nodes in elements, not in faces necessarily if the elements are in 3D. This case is handled below.   \n    \n    if el_type in [4,5]: #if hexahedrons or tetrahedrons:\n        if  el_type == 5:\n            G = np.array([[0,3,2,1],\n                       [0,1,5,4],\n                       [4,5,6,7],\n                       [2,6,5,1],\n                       [2,3,7,6],\n                       [0,4,7,3]]) #G is an array that is used to decomposes hexahedrons into its component faces.\n\t\t\t\t\t   #The numbers are from the node orders (see p94 in the Gmsh manual) and each row makes one face.\n        elif el_type == 4:\n            G = np.array([[0,1,2],\n                       [0,3,2],\n                       [1,3,2],\n                       [0,3,1]]) #This G decomposes tetrahedrons into faces\n        faces = np.vstack([ faces[i, G] for i in range(faces.shape[0]) ])\n    elif el_type == 16: #if 8-node-quads:\n        faces = faces[:, 0:4] #The first 4 nodes are the corners of the high order quad.\n        \n    axes.bgcolor = (0.7, 0.7, 0.7) #background colour.\n    return axes, verts, faces, verticesPerFace, is3D\n\n\ndef _adjustaxes(axes, is3D):\n    if axes.daspectAuto is None:\n            axes.daspectAuto = False\n    axes.cameraType = \'3d\' if is3D else \'2d\'\n    axes.SetLimits(margin=0.1)\n\n\ndef _catmullspline(controlPoints, pointsOnEachSegment=10):\n    """"""\n    Returns points on a Catmull-Rom spline that interpolated the control points.\n    Inital/end tangents are created by mirroring the second/second-to-last)\n    control points in the first/last points.\n    \n    Params:\n    controlPoints - Numpy array containing the control points of the spline. \n                    Each row should contain the x,y,(z) values.\n                    [[x1, y2],\n                     [x2, y2],\n                        ...    \n                     [xn, yn]]\n                     \n    pointsOnEachSegment - The number of points on each segment of the curve.\n                        If there are n control points and k samplesPerSegment, \n                        then there will be (n+1)*k numeric points on the curve.\n    """"""\n    controlPoints = np.asarray(controlPoints) #Convert to array if input is a list.\n    if (controlPoints[0,:] == controlPoints[-1,:]).all():\n        #If the curve is closed we extend each opposite endpoint to the other side  \n        CPs = np.asmatrix(np.vstack((controlPoints[-2,:],\n                                controlPoints,\n                                controlPoints[1,:])))\n    else: #Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0,:] - controlPoints[1,:],\n                                controlPoints,\n                                2*controlPoints[-1,:] - controlPoints[-2,:])))\n    M = 0.5 * np.matrix([[ 0,  2,  0,  0],[-1,  0,  1,  0],[ 2, -5,  4, -1],[-1,  3, -3,  1]])\n    t = np.linspace(0, 1, pointsOnEachSegment)\n    T = np.matrix([[1, s, pow(s,2), pow(s,3)] for s in t])\n    return np.asarray( np.vstack( T * M * CPs[j-1:j+3,:] for j in range( 1, len(CPs)-2 ) ) )\n\n\ndef _bspline(controlPoints, pointsOnCurve=20):\n    \'\'\'\n    Uniform cubic B-spline.\n    \n    Params:\n    controlPoints - Control points. Numpy array. One coordinate per row.\n    pointsOnCurve - number of sub points per segment\n    \n    Mirrored start- and end-points are added if the curve is not closed.\n    If the curve is closed some points are duplicated to make the closed \n    spline continuous. \n    (See http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve-closed.html)\n    \n    Based on descriptions on:\n    http://www.siggraph.org/education/materials/HyperGraph/modeling/splines/b_spline.htm\n    http://en.wikipedia.org/wiki/B-spline#Uniform_cubic_B-splines\n    \'\'\'\n    controlPoints = np.asarray(controlPoints) #Convert to array if input is a list.\n    if (controlPoints[0,:] == controlPoints[-1,:]).all():\n        #If the curve is closed we extend each opposite endpoint to the other side  \n        CPs = np.asmatrix(np.vstack((controlPoints[-2,:],\n                                controlPoints,\n                                controlPoints[1,:])))\n    else:#Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0,:] - controlPoints[1,:],\n                                controlPoints,\n                                2*controlPoints[-1,:] - controlPoints[-2,:])))\n    M = (1.0/6) * np.matrix([[-1,  3, -3, 1],\n                          [ 3, -6,  3, 0],\n                          [-3,  0,  3, 0],\n                          [ 1,  4,  1, 0]])\n    t = np.linspace(0, 1, pointsOnCurve)\n    T = np.matrix([[pow(s,3), pow(s,2), s, 1] for s in t])\n    return np.asarray( np.vstack( T * M * CPs[i-1 : i+3, :] for i in range( 1, len(CPs)-2 ) ) )\n\ndef _circleArc(start, center, end, pointsOnCurve=20):\n    return _ellipseArc(start, center, start, end, pointsOnCurve)\n\ndef _ellipseArc(start, center, majAxP, end, pointsOnCurve=20):\n    \'\'\'Input are 3D 1-by-3 numpy arrays or vectors\'\'\'\n    #First part is to find a similarity transform in 3D that transform the ellipse to\n    #the XY-plane with the center at the origin and the major axis of the ellipse along the X-axis.\n    \n    #convert to arrays in case inputs are lists:\n    start, center, majAxP, end, = np.asarray(start), np.asarray(center), np.asarray(majAxP), np.asarray(end)\n    \n    zPrim = np.cross(start-center, end-center)\n    zPrim = zPrim / np.linalg.norm(zPrim)\n    xPrim = (majAxP-center) / np.linalg.norm(majAxP-center)\n    yPrim = np.cross(zPrim, xPrim)\n    \n    R = np.vstack((xPrim, yPrim, zPrim)).T #Rotation matrix from ordinary coords to system where ellipse is in the XY-plane. (Actually hstack)\n    T = np.hstack((R, np.asmatrix(center).T))   #Building Transformation matrix. -center is translation vector from ellipse center to origin.\n    T = np.mat( np.vstack((T, [0,0,0,1])) ) #Transformation matrix for homogenous coordinates.\n    \n    startHC = np.vstack((np.matrix(start).T, [1])) #\n    endHC = np.vstack((np.matrix(end).T, [1]))     # start and end points as column vectors in homogenous coordinates\n    \n    s = np.linalg.inv(T) * startHC #\n    e = np.linalg.inv(T) * endHC   # start and end points in the new coordinate system\n    \n    xs, ys = s[0,0], s[1,0] #\n    xe, ye = e[0,0], e[1,0] # Just extract x & y from the new start and endpoints  \n    \n    a = np.sqrt( (pow(ye*xs,2) - pow(xe*ys,2)) / (pow(ye,2) - pow(ys,2)) )\n    b = np.sqrt( (pow(ye*xs,2) - pow(xe*ys,2)) / ( (pow(ye,2) - pow(ys,2)) * ((pow(xe,2) - pow(xs,2)) / (pow(ys,2) - pow(ye,2)) ) ) )\n    \n    ts = atan2(ys/b, xs/a) #atan2 is a function that goes from -pi to pi. It gives the signed angle from the X-axis to point (y,x)\n    te = atan2(ye/b, xe/a) #We can\'t use the (transformed) start- and endpoints directly, but we divide x and y by the\n    # ellipse minor&major axes to get the parameter t that corresponds to the point on the ellipse. \n    # See ellipse formula: x = a * cos (t), y = b * sin(t). \n    # So ts and te are the parameter values of the start- and endpoints (in the transformed coordinate system).\n    \n    if ts > te:\n        ts, te = te, ts #swap if the start point comes before the endpoint in the parametric parameter that goes around the ellipse.\n    if te - ts < np.pi:\n        times = np.linspace(ts, te, pointsOnCurve) #parameter of ellipse curve. NOT angle to point on curve (like it could be for a circle).\n    else: #the shortest parameter distance between start- and end-point stradles the discontinuity that jumps from pi to -pi.  \n        ps1 = round(pointsOnCurve * (pi-te)/(2*pi-te+ts)) #number of points on the first length.\n        ps2 = round(pointsOnCurve * (ts+pi)/(2*pi-te+ts)) #number of points on the first length.\n        times = np.concatenate((np.linspace(te, pi, ps1), np.linspace(-pi, ts, ps2)))\n    \n    ellArc = np.array([[a*cos(t), b*sin(t)] for t in times]).T #points on arc (in 2D)\n    ellArc = np.vstack((ellArc, np.repeat(np.matrix([[0],[1]]), ellArc.shape[1], 1))) #Make 3D homogenous coords by adding rows of 0s and 1s.\n    ellArc = T * ellArc #Transform back to the original coordinate system   \n    return np.asarray(ellArc.T[:,0:3]) #return points as an N-by-3 array. \n\nclass _elementsWobject(vv.Wobject, Colormapable):\n    \'\'\'\n    Custom wobject for drawing element values.  \n    Based on example http://code.google.com/p/visvis/wiki/example_customWobject\n    \'\'\'\n    #TODO: Find a way to make rendering faster. (Dump internal faces, cull backfaces, \n    #TODO: Don\'t draw lines separately, pass array to GL instead of looping, etc?)\n    def __init__(self, parent, fVals, verts, faces, verticesPerFace, draw_elements, clim=None):\n        vv.Wobject.__init__(self, parent)\n        self._fVals = fVals # N-by-1 array?            values of N faces (not elements if 3D)\n        self._verts = verts # M-by-3 array             coordinates of M vertices  \n        self._faces = faces # N-by-3 or N-by-4 array   verts that make up N faces\n        self.verticesPerFace = verticesPerFace #3 or 4. Either we have triangle faces or quads.\n        self.draw_elements = draw_elements\n        self._valMin = np.amin(fVals)\n        self._valMax = np.amax(fVals)\n        Colormapable.__init__(self)\n        self._texture = None\n        self.clim = minmax(self._fVals) if clim is None else clim\n        self.colormap = vv.colormaps[\'jet\']\n    \n    def _drawFaces(self, how):\n        for (value, faceVerts) in zip(self._fVals, self._faces):\n            valueIndex = int( 255 * (value-self.clim.min)/(self.clim.max-self.clim.min) ) #Turn the value into an index between 0 and 255\n            if valueIndex > 255:\n                valueIndex = 255\n            elif valueIndex < 0:\n                valueIndex = 0\n            color = self.mapData[valueIndex, :] #get colour from value\n            coords = self._verts[faceVerts.astype(int), :] #get coordinates of the vertices of the face.\n            gl.glColor(*color)\n            gl.glBegin(how)\n            for (x,y,z) in coords:\n                gl.glVertex(x,y,z)\n            gl.glEnd()\n            \n    def _drawLines(self, how=gl.GL_LINE_LOOP, color=(0,0,0)):\n        for faceVerts in self._faces:\n            coords = self._verts[faceVerts.astype(int), :] #get coordinates of the vertices of the face.\n            gl.glColor(*color)\n            gl.glBegin(how)\n            for (x,y,z) in coords:\n                gl.glVertex(x,y,z)\n            gl.glEnd()\n            \n    def _GetLimits(self):\n        """""" Tell the axes how big this object is.\n        """""" \n        # Get limits\n        x1, x2 = minmax(self._verts[:,0])\n        y1, y2 = minmax(self._verts[:,1])\n        z1, z2 = minmax(self._verts[:,2])\n        return vv.Wobject._GetLimits(self, x1, x2, y1, y2, z1, z2)\n    \n    def OnDraw(self):\n        """""" To draw the object.\n        """""" \n        if self.draw_elements:\n            gl.glDisable(gl.GL_LINE_SMOOTH)\n            #gl.glEnable(gl.GL_BLEND)\n            gl.glLineWidth(1)\n            self._drawLines(gl.GL_LINE_LOOP, (0,0,0))\n        if self.verticesPerFace == 3:\n            self._drawFaces(gl.GL_TRIANGLES)\n        elif self.verticesPerFace == 4:\n            self._drawFaces(gl.GL_QUADS)\n    \n    def OnDrawShape(self, clr):\n        """""" To draw the shape of the object.\n        Only necessary if you want to be able to ""pick"" this object\n        """"""\n        self._drawFaces(gl.GL_TRIANGLES, clr)\n    \n    def OnDrawScreen(self):\n        """""" If the object also needs to draw in screen coordinates.\n        Text needs this for instance.\n        """"""\n        pass\n    \n    def OnDestroyGl(self):\n        """""" To clean up any OpenGl resources such as textures or shaders.\n        """"""\n        pass\n    \n    def OnDestroy(self):\n        """""" To clean up any other resources.\n        """"""\n        pass\n    \n    #Overload _SetColormap get-setter so that we can change self.mapData, which we use \n    #to map values to colours without calling self._colormap.GetData() every draw call.\n    def _SetColormap(self, value):\n        self._colormap.SetMap(value)\n        self.mapData = self._colormap.GetData()\n        \ndef eldraw2(ex, ey, plotpar=[1, 2, 1], elnum=[]):\n    """"""\n    eldraw2(ex,ey,plotpar,elnum)\n    eldraw2(ex,ey,plotpar)\n    eldraw2(ex,ey)\n    \n     PURPOSE \n       Draw the undeformed 2D mesh for a number of elements of \n       the same type. Supported elements are:\n    \n       1) -> bar element              2) -> beam el.  \n       3) -> triangular 3 node el.    4) -> quadrilateral 4 node el. \n       5) -> 8-node isopar. elemen\n    \n     INPUT  \n        ex,ey:.......... nen:   number of element nodes\n                         nel:   number of elements\n        plotpar=[ linetype, linecolor, nodemark]\n    \n                 linetype=1 -> solid    linecolor=1 -> black\n                          2 -> dashed             2 -> blue\n                          3 -> dotted             3 -> magenta\n                                                  4 -> red\n    \n                 nodemark=1 -> circle       \n                          2 -> star              \n                          0 -> no mark \n                   \n        elnum=edof(:,1) ; i.e. the first column in the topology matrix\n             \n        Rem. Default is solid white lines with circles at nodes.\n    """"""    \n    \n    line_type = plotpar[0]\n    line_color = plotpar[1]\n    node_mark = plotpar[2]\n    \n    # Translate CALFEM plotpar to visvis\n    \n    vv_line_type = \'-\'\n    vv_line_color = \'b\'\n    vv_node_mark = \'o\'\n    \n    if line_type == 1:\n        vv_line_type = \'-\'\n    elif line_type == 2:\n        vv_line_type = \'--\'\n    elif line_type == 3:\n        vv_line_type = \':\'\n        \n    if line_color == 1:\n        vv_line_color = \'k\'\n    elif line_color == 2:\n        vv_line_color = \'b\'\n    elif line_color == 3:\n        vv_line_color = \'m\'\n    elif line_color == 4:\n        vv_line_color = \'r\'\n        \n    if node_mark == 1:\n        vv_node_mark = \'o\'\n    elif node_mark == 2:\n        vv_node_mark = \'x\'\n    elif node_mark == 0:\n        vv_node_mark = \'\'\n        \n    vv_marker_color = vv_line_color\n\n    vv.axis(\'equal\')\n    \n    draw_element_numbers = False\n    \n    if len(elnum) == ex.shape[0]:\n        draw_element_numbers = True\n\n    i = 0\n\n    for elx, ely in zip(ex, ey):\n        x = elx.tolist()\n        x.append(elx[0])\n        y = ely.tolist()\n        y.append(ely[0])\n        \n        xm = sum(x)/len(x)\n        ym = sum(y)/len(y)\n        \n        vv.plot(x, y, ls=vv_line_type, lc = vv_line_color, ms = vv_node_mark, mc = vv_marker_color)\n        \n        if draw_element_numbers:\n            text(str(elnum[i]), [xm, ym])\n            i += 1\n            \ndef eldraw2_mpl(ex, ey, plotpar=[1, 2, 1], elnum=[]):\n    """"""\n    eldraw2(ex,ey,plotpar,elnum)\n    eldraw2(ex,ey,plotpar)\n    eldraw2(ex,ey)\n    \n     PURPOSE \n       Draw the undeformed 2D mesh for a number of elements of \n       the same type. Supported elements are:\n    \n       1) -> bar element              2) -> beam el.  \n       3) -> triangular 3 node el.    4) -> quadrilateral 4 node el. \n       5) -> 8-node isopar. elemen\n    \n     INPUT  \n        ex,ey:.......... nen:   number of element nodes\n                         nel:   number of elements\n        plotpar=[ linetype, linecolor, nodemark]\n    \n                 linetype=1 -> solid    linecolor=1 -> black\n                          2 -> dashed             2 -> blue\n                          3 -> dotted             3 -> magenta\n                                                  4 -> red\n    \n                 nodemark=1 -> circle       \n                          2 -> star              \n                          0 -> no mark \n                   \n        elnum=edof(:,1) ; i.e. the first column in the topology matrix\n             \n        Rem. Default is solid white lines with circles at nodes.\n    """"""    \n    \n    line_type = plotpar[0]\n    line_color = plotpar[1]\n    node_mark = plotpar[2]\n    \n    # Translate CALFEM plotpar to visvis\n    \n    vv_line_type = \'-\'\n    vv_line_color = \'b\'\n    vv_node_mark = \'o\'\n    \n    if line_type == 1:\n        vv_line_type = \'-\'\n    elif line_type == 2:\n        vv_line_type = \'--\'\n    elif line_type == 3:\n        vv_line_type = \':\'\n        \n    if line_color == 1:\n        vv_line_color = \'k\'\n    elif line_color == 2:\n        vv_line_color = \'b\'\n    elif line_color == 3:\n        vv_line_color = \'m\'\n    elif line_color == 4:\n        vv_line_color = \'r\'\n        \n    if node_mark == 1:\n        vv_node_mark = \'o\'\n    elif node_mark == 2:\n        vv_node_mark = \'x\'\n    elif node_mark == 0:\n        vv_node_mark = \'\'\n        \n    vv_marker_color = vv_line_color\n\n    plt.axis(\'equal\')\n    \n    draw_element_numbers = False\n    \n    if len(elnum) == ex.shape[0]:\n        draw_element_numbers = True\n\n    i = 0\n\n    for elx, ely in zip(ex, ey):\n        x = elx.tolist()\n        x.append(elx[0])\n        y = ely.tolist()\n        y.append(ely[0])\n        \n        xm = sum(x)/len(x)\n        ym = sum(y)/len(y)\n        \n        plt.plot(x, y, vv_line_color + vv_node_mark + vv_line_type)\n        #vv.plot(x, y, ls=vv_line_type, lc = vv_line_color, ms = vv_node_mark, mc = vv_marker_color)\n        \n        #if draw_element_numbers:\n        #    text(str(elnum[i]), [xm, ym])\n        #    i += 1          \n            \ndef eliso2_mpl(ex, ey, ed):\n\n    plt.axis(\'equal\')\n    \n    print(np.shape(ex))    \n    print(np.shape(ey))\n    print(np.shape(ed))\n    \n    gx = []\n    gy = []\n    gz = []\n\n\n    for elx, ely, scl in zip(ex, ey, ed):\n        for x in elx:\n           gx.append(x) \n        for y in ely:\n           gy.append(y) \n        for z in ely:\n           gz.append(y) \n\n    plt.tricontour(gx, gy, gz, 5)\n        \ndef eldraw2_old(ex, ey):\n    """"""\n    Draw elements in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    #class ElDispApp(wx.App):\n    #    def OnInit(self):\n    #        wx.InitAllImageHandlers()\n    #        mainWindow = ElementView(None, -1, """")\n    #        mainWindow.ex = ex\n    #        mainWindow.ey = ey\n    #        mainWindow.showNodalValues = False\n    #        self.SetTopWindow(mainWindow)\n    #        mainWindow.Show()\n    #        return 1\n    #\n    #app = ElDispApp(0)\n    #app.MainLoop()\n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.showNodalValues = False\n    mainWindow.Show()   \n    globalWindows.append(mainWindow)\n    \ndef eliso2_old(ex, ey, ed, showMesh=False):\n    """"""\n    Draw nodal values in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        ed              Element nodal values\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    #class ElDispApp(wx.App):\n    #    def OnInit(self):\n    #        wx.InitAllImageHandlers()\n    #        mainWindow = ElementView(None, -1, """")\n    #        mainWindow.ex = ex\n    #        mainWindow.ey = ey\n    #        mainWindow.ed = ed\n    #        mainWindow.showMesh = showMesh\n    #        mainWindow.showNodalValues = True\n    #        self.SetTopWindow(mainWindow)\n    #        mainWindow.Show()\n    #        return 1   \n    #\n    #app = ElDispApp(0)\n    #app.MainLoop()\n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ed = ed\n    mainWindow.showMesh = showMesh\n    mainWindow.showNodalValues = True\n    mainWindow.Show()\n    globalWindows.append(mainWindow)\n    \ndef elval2(ex, ey, ev, showMesh=False):\n    """"""\n    Draw elements values in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        ev              Element values (scalar)\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ev = ev\n    mainWindow.showMesh = showMesh\n    mainWindow.showElementValues = True\n    mainWindow.showNodalValues = False\n    mainWindow.Show()\n    globalWindows.append(mainWindow)\n    \ndef eldisp2(ex, ey, ed, magnfac=0.1, showMesh=True):\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n        \n    mainWindow = ElementView(None, -1, """")\n    mainWindow.dofs_per_node = 2\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ed = ed\n    mainWindow.showMesh = showMesh\n    mainWindow.showNodalValues = False\n    mainWindow.showDisplacements = True\n    mainWindow.magnfac = magnfac\n    mainWindow.Show()    \n    globalWindows.append(mainWindow)\n    \ndef waitDisplayNative():\n    if haveQt:\n        globalQtApp.exec_()        \n    else:\n        globalWxApp.MainLoop()\n        \n\ndef showAndWaitNative():\n    if haveQt:\n        globalQtApp.exec_()\n    else:\n        globalWxApp.MainLoop()\n\nif __name__ == ""__main__"":\n    print(""Testing"")\n'"
calfem/vis_mpl.py,72,"b'# -*- coding: utf-8 -*-\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.collections\nimport matplotlib.path as mpp\nimport matplotlib.patches as patches\nimport matplotlib as mpl\nimport matplotlib.tri as tri\n\ntry:\n    from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\n    from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar\nexcept:\n    print(""Could not import Matplotlib backends. Probarbly due to missing Qt."")\n\nfrom numpy import sin, cos, pi\nfrom math import atan2\n\nimport logging as cflog\n\n\ndef error(msg):\n    """"""Log error message""""""\n    cflog.error(msg)\n\n\ndef info(msg):\n    """"""Log information message""""""\n    cflog.info(msg)\n\n\ndef figure_class():\n    """"""Return visvis Figure class.""""""\n    return None\n\n\nfigureClass = figure_class\n\ncfv_def_mappable = None\n\n\ndef set_mappable(mappable):\n    global cfv_def_mappable\n    cfv_def_mappable = mappable\n\n\ndef colorbar(**kwargs):\n    """"""Add a colorbar to current figure""""""\n    global cfv_def_mappable\n    if cfv_def_mappable != None:\n        cbar = plt.colorbar(mappable=cfv_def_mappable, ax=plt.gca(), **kwargs)\n        cfv_def_mappable = None\n        return cbar\n    else:\n        return plt.colorbar(**kwargs)\n\n\ndef figure(figure=None, show=True, fig_size=(4, 3)):\n    """"""Create a visvis figure with extras.""""""\n    f = None\n\n    if figure == None:\n        f = plt.figure(figsize=fig_size)\n    else:\n        try:\n            f = plt.figure(figure)\n        except:\n            f = plt.figure(figsize=fig_size)\n\n    return f\n\n\ndef figure_widget(fig, parent=None):\n    widget = FigureCanvas(fig)\n    if parent != None:\n        widget.setParent(parent)\n    toolbar = NavigationToolbar(widget, widget)\n    return widget\n\n\ndef close_all():\n    """"""Close all visvis windows.""""""\n    plt.close(\'all\')\n\n\ncloseAll = close_all\n\n\ndef clf():\n    """"""Clear visvis figure""""""\n    plt.clf()\n\n\ndef gca():\n    """"""Get current axis of the current visvis figure.""""""\n    return plt.gca()\n\n\ndef gcf():\n    return plt.gcf()\n\n\ndef subplot(*args):\n    """"""Create a visvis subplot.""""""\n    return plt.subplot(*args)\n\n\ndef camera3d():\n    """"""Get visvis 3D camera.""""""\n    return None\n\n\ndef show_and_wait():\n    """"""Wait for plot to show""""""\n    plt.show()\n\n\nshowAndWait = show_and_wait\n\n\ndef show_and_wait_mpl():\n    """"""Wait for plot to show""""""\n    plt.show()\n\n\nshowAndWaitMpl = show_and_wait_mpl\n\n\ndef set_figure_dpi(dpi):\n    mpl.rcParams[\'figure.dpi\'] = dpi\n\n\ndef text(text, pos, angle=0, **kwargs):\n    return plt.text(pos[0], pos[1], text, **kwargs)\n\n\nadd_text = text\naddText = text\nlabel = text\n\n\ndef ce2vf(coords, edof, dofs_per_node, el_type):\n    \'\'\'Duplicate code. Extracts verts, faces and verticesPerFace from input.\'\'\'\n\n    if np.shape(coords)[1] == 2:\n        is_3d = False\n        # pad with zeros to make 3D\n        verts = np.hstack((coords, np.zeros([np.shape(coords)[0], 1])))\n    elif np.shape(coords)[1] == 3:\n        is_3d = True\n        verts = coords\n    else:\n        raise ValueError(\'coords must be N-by-2 or N-by-3 array\')\n\n    if el_type in [2, 4]:  # elements with triangular faces\n        vertices_per_face = 3\n    elif el_type in [3, 5, 16]:  # elements with rectangular faces\n        vertices_per_face = 4\n    else:  # [NOTE] This covers all element types available in CALFEM plus tetrahedrons. If more element types are added it is necessary to include them here and below.\n        raise ValueError(\'element type not implemented\')\n\n    faces = (edof[:, 0::dofs_per_node]-1)/dofs_per_node\n    # \'faces\' here are actually lists of nodes in elements, not in faces necessarily if the elements are in 3D. This case is handled below.\n\n    if el_type in [4, 5]:  # if hexahedrons or tetrahedrons:\n        if el_type == 5:\n            G = np.array([[0, 3, 2, 1],\n                          [0, 1, 5, 4],\n                          [4, 5, 6, 7],\n                          [2, 6, 5, 1],\n                          [2, 3, 7, 6],\n                          [0, 4, 7, 3]])  # G is an array that is used to decomposes hexahedrons into its component faces.\n           # The numbers are from the node orders (see p94 in the Gmsh manual) and each row makes one face.\n        elif el_type == 4:\n            G = np.array([[0, 1, 2],\n                          [0, 3, 2],\n                          [1, 3, 2],\n                          [0, 3, 1]])  # This G decomposes tetrahedrons into faces\n        faces = np.vstack([faces[i, G] for i in range(faces.shape[0])])\n    elif el_type == 16:  # if 8-node-quads:\n        # The first 4 nodes are the corners of the high order quad.\n        faces = faces[:, 0:4]\n\n    return verts, np.asarray(faces, dtype=int), vertices_per_face, is_3d\n\n\ndef draw_mesh(coords, edof, dofs_per_node, el_type, title=None, color=(0, 0, 0), face_color=(0.8, 0.8, 0.8), node_color=(0, 0, 0), filled=False, show_nodes=False):\n    \'\'\'\n    Draws wire mesh of model in 2D or 3D. Returns the Mesh object that represents\n    the mesh.\n    Args:\n        coords:\n            An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates of node i.\n        edof:\n            An E-by-L array. Element topology. (E is the number of elements and L is the number of dofs per element)\n        dofs_per_nodes:\n            Integer. Dofs per node.\n        el_type:\n            Integer. Element Type. See Gmsh manual for details. Usually 2 for triangles or 3 for quadrangles.\n        axes:\n            Matplotlib Axes. The Axes where the model will be drawn. If unspecified the current Axes will be used, or a new Axes will be created if none exist.\n        axes_adjust:\n            Boolean. True if the view should be changed to show the whole model. Default True.\n        title:\n            String. Changes title of the figure. Default ""Mesh"".\n        color: \n            3-tuple or char. Color of the wire. Defaults to black (0,0,0). Can also be given as a character in \'rgbycmkw\'.\n        face_color:\n            3-tuple or char. Color of the faces. Defaults to white (1,1,1). Parameter filled must be True or faces will not be drawn at all.\n        filled:\n            Boolean. Faces will be drawn if True. Otherwise only the wire is drawn. Default False.\n    \'\'\'\n\n    verts, faces, vertices_per_face, is_3d = ce2vf(\n        coords, edof, dofs_per_node, el_type)\n\n    y = verts[:, 0]\n    z = verts[:, 1]\n\n    values = np.zeros(faces.shape[0], float)\n\n    def quatplot(y, z, quatrangles, values=[], ax=None, **kwargs):\n\n        if not ax:\n            ax = plt.gca()\n        yz = np.c_[y, z]\n        v = yz[quatrangles]\n        if filled:\n            pc = matplotlib.collections.PolyCollection(\n                v, facecolor=face_color, **kwargs)\n        else:\n            pc = matplotlib.collections.PolyCollection(\n                v, facecolor=\'none\', **kwargs)\n\n        ax.add_collection(pc)\n        ax.autoscale()\n        return pc\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    pc = quatplot(y, z, faces, values, ax=ax, edgecolor=color)\n\n    if show_nodes:\n        ax.plot(y, z, marker=""o"", ls="""", color=node_color)\n\n    if title != None:\n        ax.set(title=title)\n\n\ndrawMesh = draw_mesh\n\n\ndef draw_element_values(values, coords, edof, dofs_per_node, el_type, displacements=None, draw_elements=True, draw_undisplaced_mesh=False, magnfac=1.0, title=None, color=(0, 0, 0), node_color=(0, 0, 0)):\n    \'\'\'\n    Draws scalar element values in 2D or 3D. \n\n    Args:\n        ev: \n            An N-by-1 array or a list of scalars. The Scalar values of the elements. ev[i] should be the value of element i.\n    \n        coords:\n            An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates of node i.\n\n        edof:\n            An E-by-L array. Element topology. (E is the number of elements and L is the number of dofs per element)\n\n        dofs_per_node:\n            Integer. Dofs per node.\n\n        el_type: \n            Integer. Element Type. See Gmsh manual for details. Usually 2 for triangles or 3 for quadrangles.\n    \n        displacements:\n            An N-by-2 or N-by-3 array. Row i contains the x,y,z displacements of node i.\n    \n        draw_mesh:\n            Boolean. True if mesh wire should be drawn. Default True.\n\n        draw_undisplaced_mesh: \n            Boolean. True if the wire of the undisplaced mesh should be drawn on top of the displaced mesh. Default False. Use only if displacements != None.\n\n        magnfac: \n            Float. Magnification factor. Displacements are multiplied by this value. Use this to make small displacements more visible.\n\n        title: \n            String. Changes title of the figure. Default ""Element Values"".\n    \'\'\'\n\n    if draw_undisplaced_mesh:\n        draw_mesh(coords, edof, dofs_per_node, el_type, color=(0.5, 0.5, 0.5))\n\n    if displacements is not None:\n        if displacements.shape[1] != coords.shape[1]:\n            displacements = np.reshape(displacements, (-1, coords.shape[1]))\n            coords = np.asarray(coords + magnfac * displacements)\n\n    verts, faces, vertices_per_face, is_3d = ce2vf(\n        coords, edof, dofs_per_node, el_type)\n\n    y = verts[:, 0]\n    z = verts[:, 1]\n\n    def quatplot(y, z, quatrangles, values=[], ax=None, **kwargs):\n\n        if not ax:\n            ax = plt.gca()\n        yz = np.c_[y, z]\n        v = yz[quatrangles]\n        pc = matplotlib.collections.PolyCollection(\n            v, **kwargs)\n\n        pc.set_array(np.asarray(values))\n        ax.add_collection(pc)\n        ax.autoscale()\n        return pc\n\n    fig = plt.gcf()\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    if draw_elements:\n        pc = quatplot(y, z, faces, values, ax=ax,\n                      edgecolor=color)\n    else:\n        pc = quatplot(y, z, faces, values, ax=ax,\n                      edgecolor=None)\n\n    # pc = quatplot(y,z, np.asarray(edof-1), values, ax=ax,\n    #         edgecolor=""crimson"", cmap=""rainbow"")\n\n    set_mappable(pc)\n\n    if title != None:\n        ax.set(title=title)\n\n\ndef draw_displacements(a, coords, edof, dofs_per_node, el_type, draw_undisplaced_mesh=False, magnfac=-1.0, magscale=0.25, title=None, color=(0, 0, 0), node_color=(0, 0, 0)):\n    \'\'\'\n    Draws scalar element values in 2D or 3D. Returns the world object\n    elementsWobject that represents the mesh.\n\n    Args:\n        ev: \n            An N-by-1 array or a list of scalars. The Scalar values of the elements. ev[i] should be the value of element i.\n        coords: \n            An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates of node i.\n        edof: \n            An E-by-L array. Element topology. (E is the number of elements and L is the number of dofs per element)\n        dofs_per_node: \n            Integer. Dofs per node.\n        el_type: \n            Integer. Element Type. See Gmsh manual for details. Usually 2 for triangles or 3 for quadrangles.\n        displacements:  \n            An N-by-2 or N-by-3 array. Row i contains the x,y,z  displacements of node i.\n        axes: \n            Matlotlib Axes. The Axes where the model will be drawn. If unspecified the current Axes will be used, or a new Axes will be created if none exist.\n        draw_undisplaced_mesh:\n            Boolean. True if the wire of the undisplaced mesh should be drawn on top of the displaced mesh. Default False. Use only if displacements != None.\n        magnfac:        \n            Float. Magnification factor. Displacements are multiplied by this value. Use this to make small displacements more visible.\n        title:          \n            String. Changes title of the figure. Default ""Element Values"".\n    \'\'\'\n\n    if draw_undisplaced_mesh:\n        draw_mesh(coords, edof, dofs_per_node, el_type, color=(0.8, 0.8, 0.8))\n\n    if a is not None:\n        if a.shape[1] != coords.shape[1]:\n            a = np.reshape(a, (-1, coords.shape[1]))\n\n            x_max = np.max(coords[:, 0])\n            x_min = np.min(coords[:, 0])\n\n            y_max = np.max(coords[:, 1])\n            y_min = np.min(coords[:, 1])\n\n            x_size = x_max - x_min\n            y_size = y_max - y_min\n\n            if x_size > y_size:\n                max_size = x_size\n            else:\n                max_size = y_size\n\n            if magnfac < 0:\n                magnfac = 0.25*max_size\n\n            coords = np.asarray(coords + magnfac * a)\n\n    verts, faces, vertices_per_face, is_3d = ce2vf(\n        coords, edof, dofs_per_node, el_type)\n\n    y = verts[:, 0]\n    z = verts[:, 1]\n\n    values = []\n\n    def quatplot(y, z, quatrangles, values=[], ax=None, **kwargs):\n\n        if not ax:\n            ax = plt.gca()\n        yz = np.c_[y, z]\n        v = yz[quatrangles]\n        pc = matplotlib.collections.PolyCollection(\n            v, **kwargs)\n\n        ax.add_collection(pc)\n        ax.autoscale()\n        return pc\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    pc = quatplot(y, z, faces, values, ax=ax, edgecolor=(\n        0.3, 0.3, 0.3), facecolor=\'none\')\n\n    if title != None:\n        ax.set(title=title)\n\n\ndef create_ordered_polys(geom, N=10):\n    """"""Creates ordered polygons from the geometry definition""""""\n\n    N = 10\n\n    o_polys = []\n\n    for (id, (surf_name, curve_ids, holes, _, _, _)) in geom.surfaces.items():\n\n        polygon = np.empty((0, 3), float)\n\n        polys = []\n\n        for curve_id in curve_ids:\n\n            curve_name, curve_points, _, _, _, _ = geom.curves[curve_id]\n            points = geom.get_point_coords(curve_points)\n\n            if curve_name == ""Spline"":\n                P = _catmullspline(points, N)\n            if curve_name == ""BSpline"":\n                P = _bspline(points, N)\n            if curve_name == ""Circle"":\n                P = _circleArc(*points, pointsOnCurve=N)\n            if curve_name == ""Ellipse"":\n                P = _ellipseArc(*points, pointsOnCurve=N)\n\n            polys.append(P)\n\n        ordered_polys = []\n\n        ordered_polys.append(polys.pop())\n\n        while len(polys) != 0:\n            p0 = ordered_polys[-1]\n            for p in polys:\n                if np.allclose(p0[-1], p[0]):\n                    ordered_polys.append(polys.pop())\n                    break\n                elif np.allclose(p0[-1], p[-1]):\n                    ordered_polys.append(np.flipud(polys.pop()))\n                    break\n\n        for p in ordered_polys:\n            polygon = np.concatenate((polygon, p))\n\n        o_polys.append(polygon)\n\n    return o_polys\n\n\ndef draw_ordered_polys(o_polys):\n\n    for poly in o_polys:\n\n        ax = plt.gca()\n        path = mpp.Path(poly[:, 0:2])\n        patch = patches.PathPatch(path, facecolor=\'orange\', lw=1)\n        ax.add_patch(patch)\n\n\ndef point_in_geometry(o_polys, point):\n\n    for poly in o_polys:\n\n        path = mpp.Path(poly[:, 0:2])\n        inside = path.contains_points([point])\n\n        if inside:\n            return True\n\n    return False\n\n\ndef topo_to_tri(edof):\n    """"""Converts 2d element topology to triangle topology to be used\n    with the matplotlib functions tricontour and tripcolor.""""""\n\n    if edof.shape[1] == 3:\n        return edof\n    elif edof.shape[1] == 4:\n        new_edof = np.zeros((edof.shape[0]*2, 3), int)\n        new_edof[0::2, 0] = edof[:, 0]\n        new_edof[0::2, 1] = edof[:, 1]\n        new_edof[0::2, 2] = edof[:, 2]\n        new_edof[1::2, 0] = edof[:, 2]\n        new_edof[1::2, 1] = edof[:, 3]\n        new_edof[1::2, 2] = edof[:, 0]\n        return new_edof\n    elif edof.shape[1] == 8:\n        new_edof = np.zeros((edof.shape[0]*6, 3), int)\n        new_edof[0::6, 0] = edof[:, 0]\n        new_edof[0::6, 1] = edof[:, 4]\n        new_edof[0::6, 2] = edof[:, 7]\n        new_edof[1::6, 0] = edof[:, 4]\n        new_edof[1::6, 1] = edof[:, 1]\n        new_edof[1::6, 2] = edof[:, 5]\n        new_edof[2::6, 0] = edof[:, 5]\n        new_edof[2::6, 1] = edof[:, 2]\n        new_edof[2::6, 2] = edof[:, 6]\n        new_edof[3::6, 0] = edof[:, 6]\n        new_edof[3::6, 1] = edof[:, 3]\n        new_edof[3::6, 2] = edof[:, 7]\n        new_edof[4::6, 0] = edof[:, 4]\n        new_edof[4::6, 1] = edof[:, 6]\n        new_edof[4::6, 2] = edof[:, 7]\n        new_edof[5::6, 0] = edof[:, 4]\n        new_edof[5::6, 1] = edof[:, 5]\n        new_edof[5::6, 2] = edof[:, 6]\n        return new_edof\n    else:\n        error(""Element topology not supported."")\n\n\ndef draw_nodal_values_contourf(values, coords, edof, levels=12, title=None, dofs_per_node=None, el_type=None, draw_elements=False):\n    """"""Draws element nodal values as filled contours. Element topologies\n    supported are triangles, 4-node quads and 8-node quads.""""""\n\n    edof_tri = topo_to_tri(edof)\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    x, y = coords.T\n    v = np.asarray(values)\n    plt.tricontourf(x, y, edof_tri - 1, v.ravel(), levels)\n\n    if draw_elements:\n        if dofs_per_node != None and el_type != None:\n            draw_mesh(coords, edof, dofs_per_node,\n                      el_type, color=(0.2, 0.2, 0.2))\n        else:\n            info(""dofs_per_node and el_type must be specified to draw the mesh."")\n\n    if title != None:\n        ax.set(title=title)\n\n\ndef draw_nodal_values_contour(values, coords, edof, levels=12, title=None, dofs_per_node=None, el_type=None, draw_elements=False):\n    """"""Draws element nodal values as filled contours. Element topologies\n    supported are triangles, 4-node quads and 8-node quads.""""""\n\n    edof_tri = topo_to_tri(edof)\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    x, y = coords.T\n    v = np.asarray(values)\n    plt.tricontour(x, y, edof_tri - 1, v.ravel(), levels)\n\n    if draw_elements:\n        if dofs_per_node != None and el_type != None:\n            draw_mesh(coords, edof, dofs_per_node,\n                      el_type, color=(0.2, 0.2, 0.2))\n        else:\n            info(""dofs_per_node and el_type must be specified to draw the mesh."")\n\n    if title != None:\n        ax.set(title=title)\n\n\ndef draw_nodal_values_shaded(values, coords, edof, title=None, dofs_per_node=None, el_type=None, draw_elements=False):\n    """"""Draws element nodal values as shaded triangles. Element topologies\n    supported are triangles, 4-node quads and 8-node quads.""""""\n\n    edof_tri = topo_to_tri(edof)\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n\n    x, y = coords.T\n    v = np.asarray(values)\n    plt.tripcolor(x, y, edof_tri - 1, v.ravel(), shading=""gouraud"")\n\n    if draw_elements:\n        if dofs_per_node != None and el_type != None:\n            draw_mesh(coords, edof, dofs_per_node,\n                      el_type, color=(0.2, 0.2, 0.2))\n        else:\n            info(""dofs_per_node and el_type must be specified to draw the mesh."")\n\n    if title != None:\n        ax.set(title=title)\n\n\ndraw_nodal_values = draw_nodal_values_contourf\n\n\ndef draw_geometry(geometry, draw_points=True, label_points=True, label_curves=True, title=None, font_size=11, N=20, rel_margin=0.05, draw_axis=False):\n    \'\'\'\n    Draws the geometry (points and curves) in geoData\n    Args:\n        geoData:\n            GeoData object. Geodata contains geometric information of the model.\n        axes:\n            Matplotlib Axes. The Axes where the model will be drawn. If unspecified the current Axes will be used, or a new Axes will be created if none exist.\n        axes_adjust:\n            Boolean. If True the view will be changed to show the whole model. Default True.\n        draw_points: \n            Boolean. If True points will be drawn.\n        label_points:\n            Boolean. If True Points will be labeled. The format is: ID[marker]. If a point has marker==0 only the ID is written.\n        label_curves:\n            Boolean. If True Curves will be labeled. The format is: ID(elementsOnCurve)[marker].\n        font_size:\n            Integer. Size of the text in the text labels. Default 11.\n        N:\n            Integer. The number of discrete points per curve segment. Default 20. Increase for smoother curves. Decrease for better performance.\n        rel_margin:\n            Extra spacing between geometry and axis\n    \'\'\'\n\n    ax = plt.gca()\n    ax.set_aspect(\'equal\')\n    ax.set_frame_on(draw_axis)\n\n    if draw_points:\n        P = np.array(geometry.getPointCoords())  # M-by-3 list of M points.\n        #plotArgs = {\'mc\':\'r\', \'mw\':5, \'lw\':0, \'ms\':\'o\', \'axesAdjust\':False, \'axes\':axes}\n        plotArgs = {""marker"": ""o"", ""ls"": """"}\n        if geometry.is3D:\n            plt.plot(P[:, 0], P[:, 1], P[:, 2], **plotArgs)\n        else:\n            plt.plot(P[:, 0], P[:, 1], **plotArgs)\n\n        if label_points:  # Write text label at the points:\n           # [[x, y, z], elSize, marker]\n            for (ID, (xyz, el_size, marker)) in geometry.points.items():\n                text = ""  "" + str(ID) + (""[%s]"" %\n                                         marker if marker is not 0 else \'\')\n                plt.text(xyz[0], xyz[1], text,\n                         fontsize=font_size, color=(0.5, 0, 0.5))\n\n    for(ID, (curveName, pointIDs, marker, elementsOnCurve, _, _)) in geometry.curves.items():\n        points = geometry.getPointCoords(pointIDs)\n        if curveName == ""Spline"":\n            P = _catmullspline(points, N)\n        if curveName == ""BSpline"":\n            P = _bspline(points, N)\n        if curveName == ""Circle"":\n            P = _circleArc(*points, pointsOnCurve=N)\n        if curveName == ""Ellipse"":\n            P = _ellipseArc(*points, pointsOnCurve=N)\n        # plotArgs = {\'lc\':\'k\', \'ms\':None, \'axesAdjust\':False, \'axes\':axes} #Args for plot style. Black lines with no symbols at points.\n\n        # Args for plot style. Black lines with no symbols at points.\n        plotArgs = {""color"": ""black""}\n\n        if geometry.is3D:\n            plt.plot(P[:, 0], P[:, 1], P[:, 2], **plotArgs)\n        else:\n            plt.plot(P[:, 0], P[:, 1], **plotArgs)\n\n        if label_curves:\n            # Sort of midpoint along the curve. Where the text goes.\n            midP = P[int(P.shape[0]*7.0/12), :].tolist()\n            # Create the text for the curve. Includes ID, elementsOnCurve, and marker:\n            text = "" ""+str(ID)\n            text += ""(%s)"" % (elementsOnCurve) if elementsOnCurve is not None else \'\'\n            # Something like ""4(5)[8]""\n            text += ""[%s]"" % (marker) if marker is not 0 else \'\'\n            plt.text(midP[0], midP[1], text, fontsize=font_size)\n\n    if title != None:\n        plt.title(title)\n\n    min_x, max_x, min_y, max_y = geometry.bounding_box_2d()\n\n    g_width = max_x - min_x\n    g_height = max_y - min_y\n\n    if g_width > g_height:\n        margin = rel_margin*g_width\n    else:\n        margin = rel_margin*g_height\n\n    bottom, top = ax.get_ylim()\n    left, right = ax.get_xlim()\n    ax.set_ylim(bottom-margin, top+margin)\n    ax.set_xlim(left-margin, right+margin)\n\n    # if axesAdjust:\n    #    _adjustaxes(axes, geoData.is3D)\n    #axes.daspectAuto = False\n    #axes.daspect = (1,1,1)\n\n# drawGeometry = draw_geometry\n\n\ndef _catmullspline(controlPoints, pointsOnEachSegment=10):\n    """"""\n    Returns points on a Catmull-Rom spline that interpolated the control points.\n    Inital/end tangents are created by mirroring the second/second-to-last)\n    control points in the first/last points.\n\n    Params:\n    controlPoints - Numpy array containing the control points of the spline.\n                    Each row should contain the x,y,(z) values.\n                    [[x1, y2],\n                     [x2, y2],\n                        ...\n                     [xn, yn]]\n\n    pointsOnEachSegment - The number of points on each segment of the curve.\n                        If there are n control points and k samplesPerSegment,\n                        then there will be (n+1)*k numeric points on the curve.\n    """"""\n    controlPoints = np.asarray(\n        controlPoints)  # Convert to array if input is a list.\n    if (controlPoints[0, :] == controlPoints[-1, :]).all():\n        # If the curve is closed we extend each opposite endpoint to the other side\n        CPs = np.asmatrix(np.vstack((controlPoints[-2, :],\n                                     controlPoints,\n                                     controlPoints[1, :])))\n    else:  # Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0, :] - controlPoints[1, :],\n                                     controlPoints,\n                                     2*controlPoints[-1, :] - controlPoints[-2, :])))\n    M = 0.5 * np.matrix([[0,  2,  0,  0], [-1,  0,  1,  0],\n                         [2, -5,  4, -1], [-1,  3, -3,  1]])\n    t = np.linspace(0, 1, pointsOnEachSegment)\n    T = np.matrix([[1, s, pow(s, 2), pow(s, 3)] for s in t])\n    return np.asarray(np.vstack([T * M * CPs[j-1:j+3, :] for j in range(1, len(CPs)-2)]))\n\n\ndef _bspline(controlPoints, pointsOnCurve=20):\n    \'\'\'\n    Uniform cubic B-spline.\n\n    Params:\n    controlPoints - Control points. Numpy array. One coordinate per row.\n    pointsOnCurve - number of sub points per segment\n\n    Mirrored start- and end-points are added if the curve is not closed.\n    If the curve is closed some points are duplicated to make the closed\n    spline continuous.\n    (See http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve-closed.html)\n\n    Based on descriptions on:\n    http://www.siggraph.org/education/materials/HyperGraph/modeling/splines/b_spline.htm\n    http://en.wikipedia.org/wiki/B-spline#Uniform_cubic_B-splines\n    \'\'\'\n    controlPoints = np.asarray(\n        controlPoints)  # Convert to array if input is a list.\n    if (controlPoints[0, :] == controlPoints[-1, :]).all():\n        # If the curve is closed we extend each opposite endpoint to the other side\n        CPs = np.asmatrix(np.vstack((controlPoints[-2, :],\n                                     controlPoints,\n                                     controlPoints[1, :])))\n    else:  # Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0, :] - controlPoints[1, :],\n                                     controlPoints,\n                                     2*controlPoints[-1, :] - controlPoints[-2, :])))\n    M = (1.0/6) * np.matrix([[-1,  3, -3, 1],\n                             [3, -6,  3, 0],\n                             [-3,  0,  3, 0],\n                             [1,  4,  1, 0]])\n    t = np.linspace(0, 1, pointsOnCurve)\n    T = np.matrix([[pow(s, 3), pow(s, 2), s, 1] for s in t])\n\n    return np.asarray(np.vstack([T * M * CPs[i-1: i+3, :] for i in range(1, len(CPs)-2)]))\n\n\ndef _circleArc(start, center, end, pointsOnCurve=20):\n    return _ellipseArc(start, center, start, end, pointsOnCurve)\n\n\ndef _ellipseArc(start, center, majAxP, end, pointsOnCurve=20):\n    \'\'\'Input are 3D 1-by-3 numpy arrays or vectors\'\'\'\n    # First part is to find a similarity transform in 3D that transform the ellipse to\n    # the XY-plane with the center at the origin and the major axis of the ellipse along the X-axis.\n\n    # convert to arrays in case inputs are lists:\n    start, center, majAxP, end, = np.asarray(start), np.asarray(\n        center), np.asarray(majAxP), np.asarray(end)\n\n    zPrim = np.cross(start-center, end-center)\n    zPrim = zPrim / np.linalg.norm(zPrim)\n    xPrim = (majAxP-center) / np.linalg.norm(majAxP-center)\n    yPrim = np.cross(zPrim, xPrim)\n\n    # Rotation matrix from ordinary coords to system where ellipse is in the XY-plane. (Actually hstack)\n    R = np.vstack((xPrim, yPrim, zPrim)).T\n    # Building Transformation matrix. -center is translation vector from ellipse center to origin.\n    T = np.hstack((R, np.asmatrix(center).T))\n    # Transformation matrix for homogenous coordinates.\n    T = np.mat(np.vstack((T, [0, 0, 0, 1])))\n\n    startHC = np.vstack((np.matrix(start).T, [1]))\n    # start and end points as column vectors in homogenous coordinates\n    endHC = np.vstack((np.matrix(end).T, [1]))\n\n    s = np.linalg.inv(T) * startHC\n    # start and end points in the new coordinate system\n    e = np.linalg.inv(T) * endHC\n\n    xs, ys = s[0, 0], s[1, 0]\n    # Just extract x & y from the new start and endpoints\n    xe, ye = e[0, 0], e[1, 0]\n\n    a = np.sqrt((pow(ye*xs, 2) - pow(xe*ys, 2)) / (pow(ye, 2) - pow(ys, 2)))\n    b = np.sqrt((pow(ye*xs, 2) - pow(xe*ys, 2)) / ((pow(ye, 2) - pow(ys, 2))\n                                                   * ((pow(xe, 2) - pow(xs, 2)) / (pow(ys, 2) - pow(ye, 2)))))\n\n    # atan2 is a function that goes from -pi to pi. It gives the signed angle from the X-axis to point (y,x)\n    ts = atan2(ys/b, xs/a)\n    # We can\'t use the (transformed) start- and endpoints directly, but we divide x and y by the\n    te = atan2(ye/b, xe/a)\n    # ellipse minor&major axes to get the parameter t that corresponds to the point on the ellipse.\n    # See ellipse formula: x = a * cos (t), y = b * sin(t).\n    # So ts and te are the parameter values of the start- and endpoints (in the transformed coordinate system).\n\n    if ts > te:\n        # swap if the start point comes before the endpoint in the parametric parameter that goes around the ellipse.\n        ts, te = te, ts\n    if te - ts < np.pi:\n        # parameter of ellipse curve. NOT angle to point on curve (like it could be for a circle).\n        times = np.linspace(ts, te, pointsOnCurve)\n    # the shortest parameter distance between start- and end-point stradles the discontinuity that jumps from pi to -pi.\n    else:\n        # number of points on the first length.\n        ps1 = round(pointsOnCurve * (pi-te)/(2*pi-te+ts))\n        # number of points on the first length.\n        ps2 = round(pointsOnCurve * (ts+pi)/(2*pi-te+ts))\n        times = np.concatenate(\n            (np.linspace(te, pi, ps1), np.linspace(-pi, ts, ps2)))\n\n    ellArc = np.array([[a*cos(t), b*sin(t)]\n                       for t in times]).T  # points on arc (in 2D)\n    # Make 3D homogenous coords by adding rows of 0s and 1s.\n    ellArc = np.vstack(\n        (ellArc, np.repeat(np.matrix([[0], [1]]), ellArc.shape[1], 1)))\n    ellArc = T * ellArc  # Transform back to the original coordinate system\n    return np.asarray(ellArc.T[:, 0:3])  # return points as an N-by-3 array.\n\n\ndef eldraw2(ex, ey, plotpar=[1, 2, 1], elnum=[]):\n    """"""\n    eldraw2(ex,ey,plotpar,elnum)\n    eldraw2(ex,ey,plotpar)\n    eldraw2(ex,ey)\n\n     PURPOSE\n       Draw the undeformed 2D mesh for a number of elements of\n       the same type. Supported elements are:\n\n       1) -> bar element              2) -> beam el.\n       3) -> triangular 3 node el.    4) -> quadrilateral 4 node el.\n       5) -> 8-node isopar. elemen\n\n     INPUT\n        ex,ey:.......... nen:   number of element nodes\n                         nel:   number of elements\n        plotpar=[ linetype, linecolor, nodemark]\n\n                 linetype=1 -> solid    linecolor=1 -> black\n                          2 -> dashed             2 -> blue\n                          3 -> dotted             3 -> magenta\n                                                  4 -> red\n\n                 nodemark=1 -> circle\n                          2 -> star\n                          0 -> no mark\n\n        elnum=edof(:,1) ; i.e. the first column in the topology matrix\n\n        Rem. Default is solid white lines with circles at nodes.\n    """"""\n\n    line_type = plotpar[0]\n    line_color = plotpar[1]\n    node_mark = plotpar[2]\n\n    # Translate CALFEM plotpar to visvis\n\n    vv_line_type = \'-\'\n    vv_line_color = \'b\'\n    vv_node_mark = \'o\'\n\n    if line_type == 1:\n        vv_line_type = \'-\'\n    elif line_type == 2:\n        vv_line_type = \'--\'\n    elif line_type == 3:\n        vv_line_type = \':\'\n\n    if line_color == 1:\n        vv_line_color = \'k\'\n    elif line_color == 2:\n        vv_line_color = \'b\'\n    elif line_color == 3:\n        vv_line_color = \'m\'\n    elif line_color == 4:\n        vv_line_color = \'r\'\n\n    if node_mark == 1:\n        vv_node_mark = \'o\'\n    elif node_mark == 2:\n        vv_node_mark = \'x\'\n    elif node_mark == 0:\n        vv_node_mark = \'\'\n\n    vv_marker_color = vv_line_color\n\n    plt.axis(\'equal\')\n\n    draw_element_numbers = False\n\n    if len(elnum) == ex.shape[0]:\n        draw_element_numbers = True\n\n    i = 0\n\n    for elx, ely in zip(ex, ey):\n        x = elx.tolist()\n        x.append(elx[0])\n        y = ely.tolist()\n        y.append(ely[0])\n\n        xm = sum(x)/len(x)\n        ym = sum(y)/len(y)\n\n        plt.plot(x, y, vv_line_color + vv_node_mark + vv_line_type)\n\n\ndef eliso2_mpl(ex, ey, ed):\n\n    plt.axis(\'equal\')\n\n    print(np.shape(ex))\n    print(np.shape(ey))\n    print(np.shape(ed))\n\n    gx = []\n    gy = []\n    gz = []\n\n    for elx, ely, scl in zip(ex, ey, ed):\n        for x in elx:\n            gx.append(x)\n        for y in ely:\n            gy.append(y)\n        for z in ely:\n            gz.append(y)\n\n    plt.tricontour(gx, gy, gz, 5)\n'"
examples/exm1.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 01\n\nShows how to create simple geometry from splines and ellipse arcs, and how to mesh a quad mesh in GmshMesher.\nAlso demonstrates drawGeometry(), drawMesh, and drawing texts and labels in a figure.\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry() #Create a GeoData object that holds the geometry.\n\n# Add points:\n#  The first parameter is the coordinates. These can be in 2D or 3D.\n#  The other parameters are not defined in this example. These parameters are\n#  ID, marker, and elSize.\n#  Since we do not specify an ID the points are automatically assigned IDs, \n#  starting from 0.\n\ng.point([0, 0])\ng.point([2, 0])\ng.point([2, 1])\ng.point([0, 1])\ng.point([0.5, 0.3])\ng.point([0.3, 0.7])\ng.point([0.7, 0.7])\ng.point([0.8, 0.5])\ng.point([1.7, 0.5])\ng.point([1.5, 0.5])\ng.point([1.7, 0.7])\n\n# Add curves:\n#  There are four types of curves. In this example we create an ellipse arc \n#  and some splines. The first parameter is a list of point IDs that define \n#  the curve. Curves can have have IDs and markers. In this example the IDs \n#  are undefined so the curves are automatically assigned IDs. The markers can \n#  be used for identifying regions/boundaries in the model.\n\n\ng.ellipse([7,8,9,10], marker=50)      # 0 - An ellipse arc. Read the function \n                                      #     doc for more information. The four \n                                      #     points are \n                                      #     [start, center, majorAxis, end]\ng.spline([0, 1], marker=80)           # 1 - A spline. Splines pass through the \n                                      #     points in the first parameter.\ng.spline([2, 1])                      # 2\ng.spline([3, 2])                      # 3\ng.spline([0, 3])                      # 4\ng.spline([7, 9], marker=50)           # 5\ng.spline([10, 9])                     # 6\ng.spline([4, 5, 6, 4])                # 7 - This is a closed spline. \n                                      # The start and end points are the same \n\n# Add a surface:\n#  Surfaces are defined by its curve boundaries.\n#  The first parameter is a list of curve IDs that specify the outer boundary \n#  of the surface. The second parameter is a list of lists of curve IDs that \n#  specify holes in the surface. In this example there are two holes. The \n#  boundaries and holes must be closed paths. We can see that [7] is closed \n#  because curve 7 is a closed spline. addSurface creates a flat surface, so \n#  all curves must lie on the same plane.\n\ng.surface([4,3,2,1], [[7], [5,6,0]])\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 3 is quad. \n# (2 is triangle. See user manual for more element types)\n\nmesh.el_type = 3 \nmesh.dofs_per_node = 1 # Degrees of freedom per node. \nmesh.el_size_factor = 0.05 # Factor that changes element sizes.\n# mesh.mesh_dir = ""./mesh_files""\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\n# Mesh the geometry:\n#\n# The first four return values are the same as those that trimesh2d() returns.\n# coords is as list of node coordinates. edof is the element topology \n# (element degrees of freedom). dofs is a lists of all degrees of freedom\n# bdofs is a dictionary of boundary dofs (dofs of geometric entities with\n# markers). elementmarkers is a list of markers, and is used for finding the\n# marker of a given element (index).\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# To render correctly on high dpi screeen uncomment command below.\n\n# cfv.set_figure_dpi(300)\n\n# Draw the geometry. Note that surfaces and volumes are not drawn at all by \n# this function.\n\ncfv.draw_geometry(g)\n\n# New figure window\n\ncfv.figure() \n\n# Draw the mesh.\n\ncfv.draw_mesh(\n    coords=coords, \n    edof=edof, \n    dofs_per_node=mesh.dofs_per_node, \n    el_type=mesh.el_type, \n    filled=True, \n    title=""Example 01""\n    ) \n\ncfv.addText(""This is a Text"", pos=(1, -0.3), angle=45)  #Adds a text in world space\n\nourLabel = cfv.label(""This is a Label"", pos=(100,200), angle=-45) #Adds a label in the screen space\nourLabel.text = ""Label, changed."" #We can change the attributes of labels and texts, such as color, text, and position.\nourLabel.textColor = \'r\'  #Make it red. (1,0,0) would also have worked.\nourLabel.position = (20,30)\n\n# Enter main loop:\n\ncfv.showAndWait()'"
examples/exm10.py,6,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport numpy as np\n\nfrom scipy.sparse import lil_matrix\n\ncfu.enableLogging()\n\n# ---- General parameters ---------------------------------------------------\n\nt = 0.2\nv = 0.35\nE1 = 2e9\nE2 = 0.2e9\nptype = 1\nep = [ptype,t]\nD1 = cfc.hooke(ptype, E1, v)\nD2 = cfc.hooke(ptype, E2, v)\n\n# Define marker constants instead of using numbers in the code\n\nmark_E1 = 55\nmark_E2 = 66\nmark_fixed = 70\nmark_load = 90\n\n# Create dictionary for the different element properties\n\nelprop = {}\nelprop[mark_E1] = [ep, D1]\nelprop[mark_E2] = [ep, D2]\n\n# Parameters controlling mesh\n\nel_size_factor = 0.05    # Element size factor\nel_type = 3             # Triangle element\ndofs_per_node = 2        # Dof per node\n\n# ---- Create Geometry ------------------------------------------------------\n\n# Create a Geometry object that holds the geometry.\n\ng = cfg.Geometry() \n\n# Add points:\n\ng.point([0, 0])\t\t#0\ng.point([1, 0])\t\t#1\ng.point([1, 1])\t\t#2\ng.point([0, 1])\t\t#3\ng.point([0.2, 0.2])\t#4\ng.point([0.8, 0.2])\t#5\ng.point([0.8, 0.8])\t#6\ng.point([0.2, 0.8])\t#7\n\n# Add curves:\n\ng.spline([0, 1], marker = mark_fixed) #0\ng.spline([2, 1])                     #1\ng.spline([3, 2], marker = mark_load)  #2\ng.spline([0, 3])                     #3\ng.spline([4, 5])                     #4\ng.spline([5, 6])                     #5\ng.spline([6, 7])                     #6\ng.spline([7, 4])                     #7\n\n# Add surfaces:\n\ng.surface([0,1,2,3], holes = [[4,5,6,7]], marker = mark_E1)\ng.surface([4,5,6,7], marker = mark_E2)\n\n# ---- Create Mesh ----------------------------------------------------------\n\nmesh = cfm.GmshMeshGenerator(g)\nmesh.el_size_factor = el_size_factor\nmesh.el_type = el_type  \nmesh.dofs_per_node = dofs_per_node\n\n# Mesh the geometry:\n#  The first four return values are the same as those that trimesh2d() returns.\n#  value elementmarkers is a list of markers, and is used for finding the \n#  marker of a given element (index).\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\nnDofs = np.size(dofs)\nK = lil_matrix((nDofs,nDofs))\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\ncfu.info(""Assembling K... (""+str(nDofs)+"")"")\n\nfor eltopo, elx, ely, elMarker in zip(edof, ex, ey, elementmarkers):\n\n    if el_type == 2:\n        Ke = cfc.plante(elx, ely, elprop[elMarker][0], elprop[elMarker][1])\n    else:\n        Ke = cfc.planqe(elx, ely, elprop[elMarker][0], elprop[elMarker][1])\n        \n    cfc.assem(eltopo, K, Ke)\n    \ncfu.info(""Applying bc and loads..."")\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'i\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, mark_fixed, 0.0)\n\nf = np.zeros([nDofs,1])\n\ncfu.applyforcetotal(bdofs, f, mark_load, value = -10e5, dimension=2)\n\ncfu.info(""Solving system..."")\n\na,r = cfc.spsolveq(K, f, bc, bcVal)\n\ncfu.info(""Extracting ed..."")\n\ned = cfc.extractEldisp(edof, a)\nvon_mises = []\n\n# ---- Calculate elementr stresses and strains ------------------------------\n\ncfu.info(""Element forces... "")\n\nfor i in range(edof.shape[0]):\n    \n    # Handle triangle elements\n        \n    if el_type == 2: \n        es, et = cfc.plants(ex[i,:], ey[i,:], \n                        elprop[elementmarkers[i]][0], \n                        elprop[elementmarkers[i]][1], \n                        ed[i,:])\n        \n        von_mises.append( np.math.sqrt( pow(es[0,0],2) - es[0,0]*es[0,1] + pow(es[0,1],2) + 3*pow(es[0,2],2) ) )\n\n    else:\n        \n        # Handle quad elements\n        \n        es, et = cfc.planqs(ex[i,:], ey[i,:], \n                        elprop[elementmarkers[i]][0], \n                        elprop[elementmarkers[i]][1], \n                        ed[i,:])\n        \n        von_mises.append( np.math.sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*pow(es[2],2) ) )\n        \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.draw_geometry(g, title=""Geometry"")\n\ncfv.figure() \ncfv.draw_mesh(coords=coords, edof=edof, dofs_per_node=dofs_per_node, el_type=el_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure()\ncfv.draw_displacements(a, coords, edof, dofs_per_node, el_type, \n                      draw_undisplaced_mesh=False, title=""Displacements"", \n                      magnfac=25.0)\n\ncfv.figure()\ncfv.draw_element_values(von_mises, coords, edof, dofs_per_node, el_type, a, \n                      draw_elements=True, draw_undisplaced_mesh=False, \n                      title=""Effective Stress"", magnfac=25.0)\n\ncfv.get_color_bar().SetLabel(""Effective Stress"")\n\ncfu.info(""Done drawing..."")\n\ncfv.showAndWait()'"
examples/exm10_mpl.py,6,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport numpy as np\n\nfrom scipy.sparse import lil_matrix\n\ncfu.enableLogging()\n\n# ---- General parameters ---------------------------------------------------\n\nt = 0.2\nv = 0.35\nE1 = 2e9\nE2 = 0.2e9\nptype = 1\nep = [ptype,t]\nD1 = cfc.hooke(ptype, E1, v)\nD2 = cfc.hooke(ptype, E2, v)\n\n# Define marker constants instead of using numbers in the code\n\nmark_E1 = 55\nmark_E2 = 66\nmark_fixed = 70\nmark_load = 90\n\n# Create dictionary for the different element properties\n\nelprop = {}\nelprop[mark_E1] = [ep, D1]\nelprop[mark_E2] = [ep, D2]\n\n# Parameters controlling mesh\n\nel_size_factor = 0.05    # Element size factor\nel_type = 3             # Triangle element\ndofs_per_node = 2        # Dof per node\n\n# ---- Create Geometry ------------------------------------------------------\n\n# Create a Geometry object that holds the geometry.\n\ng = cfg.Geometry() \n\n# Add points:\n\ng.point([0, 0])\t\t#0\ng.point([1, 0])\t\t#1\ng.point([1, 1])\t\t#2\ng.point([0, 1])\t\t#3\ng.point([0.2, 0.2])\t#4\ng.point([0.8, 0.2])\t#5\ng.point([0.8, 0.8])\t#6\ng.point([0.2, 0.8])\t#7\n\n# Add curves:\n\ng.spline([0, 1], marker = mark_fixed) #0\ng.spline([2, 1])                     #1\ng.spline([3, 2], marker = mark_load)  #2\ng.spline([0, 3])                     #3\ng.spline([4, 5])                     #4\ng.spline([5, 6])                     #5\ng.spline([6, 7])                     #6\ng.spline([7, 4])                     #7\n\n# Add surfaces:\n\ng.surface([0,1,2,3], holes = [[4,5,6,7]], marker = mark_E1)\ng.surface([4,5,6,7], marker = mark_E2)\n\n# ---- Create Mesh ----------------------------------------------------------\n\nmesh = cfm.GmshMeshGenerator(g)\nmesh.el_size_factor = el_size_factor\nmesh.el_type = el_type  \nmesh.dofs_per_node = dofs_per_node\n\n# Mesh the geometry:\n#  The first four return values are the same as those that trimesh2d() returns.\n#  value elementmarkers is a list of markers, and is used for finding the \n#  marker of a given element (index).\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\nnDofs = np.size(dofs)\nK = lil_matrix((nDofs,nDofs))\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\ncfu.info(""Assembling K... (""+str(nDofs)+"")"")\n\nfor eltopo, elx, ely, elMarker in zip(edof, ex, ey, elementmarkers):\n\n    if el_type == 2:\n        Ke = cfc.plante(elx, ely, elprop[elMarker][0], elprop[elMarker][1])\n    else:\n        Ke = cfc.planqe(elx, ely, elprop[elMarker][0], elprop[elMarker][1])\n        \n    cfc.assem(eltopo, K, Ke)\n    \ncfu.info(""Applying bc and loads..."")\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'i\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, mark_fixed, 0.0)\n\nf = np.zeros([nDofs,1])\n\ncfu.applyforcetotal(bdofs, f, mark_load, value = -10e5, dimension=2)\n\ncfu.info(""Solving system..."")\n\na,r = cfc.spsolveq(K, f, bc, bcVal)\n\ncfu.info(""Extracting ed..."")\n\ned = cfc.extractEldisp(edof, a)\nvon_mises = []\n\n# ---- Calculate elementr stresses and strains ------------------------------\n\ncfu.info(""Element forces... "")\n\nfor i in range(edof.shape[0]):\n    \n    # Handle triangle elements\n        \n    if el_type == 2: \n        es, et = cfc.plants(ex[i,:], ey[i,:], \n                        elprop[elementmarkers[i]][0], \n                        elprop[elementmarkers[i]][1], \n                        ed[i,:])\n        \n        von_mises.append( np.math.sqrt( pow(es[0,0],2) - es[0,0]*es[0,1] + pow(es[0,1],2) + 3*pow(es[0,2],2) ) )\n\n    else:\n        \n        # Handle quad elements\n        \n        es, et = cfc.planqs(ex[i,:], ey[i,:], \n                        elprop[elementmarkers[i]][0], \n                        elprop[elementmarkers[i]][1], \n                        ed[i,:])\n        \n        von_mises.append( np.math.sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*pow(es[2],2) ) )\n        \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.draw_geometry(g, title=""Geometry"")\n\ncfv.figure() \ncfv.draw_mesh(coords=coords, edof=edof, dofs_per_node=dofs_per_node, el_type=el_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure()\ncfv.draw_displacements(a, coords, edof, dofs_per_node, el_type, \n                      draw_undisplaced_mesh=False, title=""Displacements"", \n                      magnfac=25.0)\n\ncfv.figure()\ncfv.draw_element_values(von_mises, coords, edof, dofs_per_node, el_type, a, \n                      draw_elements=True, draw_undisplaced_mesh=False, \n                      title=""Effective Stress"", magnfac=25.0)\n\ncfv.colorbar()\n\ncfu.info(""Done drawing..."")\n\ncfv.showAndWait()'"
examples/exm13_mpl.py,7,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 01\n\nShows how to create simple geometry from splines and ellipse arcs, and how to mesh a quad mesh in GmshMesher.\nAlso demonstrates drawGeometry(), drawMesh, and drawing texts and labels in a figure.\n\'\'\'\n\nimport numpy as np\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.core as cfc\nimport calfem.utils as cfu\n\ncfu.enableLogging()\n\n# ---- Problem constants ----------------------------------------------------\n\nkx1 = 100\nky1 = 100\nt = 1.0\n\n# Gauss points or integration points\n\nn = 2\nep = [t, n]\n\nD = np.matrix([\n    [kx1, 0.],\n    [0., ky1]\n])\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()  # Create a GeoData object that holds the geometry.\n\ng.point([0, 0])\ng.point([2, 0])\ng.point([2, 1])\ng.point([0, 1])\ng.point([0.5, 0.3])\ng.point([0.3, 0.7])\ng.point([0.7, 0.7])\ng.point([0.8, 0.5])\ng.point([1.7, 0.5])\ng.point([1.5, 0.5])\ng.point([1.7, 0.7])\n\nid_hole1 = 50\nid_hole2 = 60\nid_outer = 80\n\ng.ellipse([7, 8, 9, 10], marker=id_hole1)\ng.spline([0, 1], marker=id_outer)\ng.spline([2, 1], marker=id_outer)\ng.spline([3, 2], marker=id_outer)\ng.spline([0, 3], marker=id_outer)\ng.spline([7, 9], marker=id_hole1)\ng.spline([10, 9], marker=id_hole1)\ng.spline([4, 5, 6, 4], marker=id_hole2)\n\ng.surface([4, 3, 2, 1], [[7], [5, 6, 0]])\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\nmesh.el_type = 16\nmesh.dofs_per_node = 1  # Degrees of freedom per node.\nmesh.el_size_factor = 0.05  # Factor that changes element sizes.\n\ncoords, edof, dofs, bdofs, element_markers = mesh.create()\n\nprint(edof)\n\n# ---- Solve problem --------------------------------------------------------\n\nprint(""Assembling system matrix..."")\n\nn_dofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\nK = np.zeros([n_dofs, n_dofs])\n\nfor el_topo, elx, ely, marker in zip(edof, ex, ey, element_markers):\n\n    # Calc element stiffness matrix: Conductivity matrix D is taken\n    # from Ddict and depends on which region (which marker) the element is in.\n\n    if mesh.el_type == 2:\n        Ke = cfc.flw2te(elx, ely, ep, D)\n    elif mesh.el_type == 3:\n        Ke = cfc.flw2i4e(elx, ely, ep, D)\n    elif mesh.el_type == 16:\n        Ke = cfc.flw2i8e(elx, ely, ep, D)\n    else:\n        print(""Element type not supported"")\n\n    cfc.assem(el_topo, K, Ke)\n\nprint(""Solving equation system..."")\n\nf = np.zeros([n_dofs, 1])\n\nbc = np.array([], \'i\')\nbc_val = np.array([], \'f\')\n\nbc, bc_val = cfu.applybc(bdofs, bc, bc_val, id_outer, 30.0)\nbc, bc_val = cfu.applybc(bdofs, bc, bc_val, id_hole1, 300.0)\nbc, bc_val = cfu.applybc(bdofs, bc, bc_val, id_hole2, 400.0)\n\na, r = cfc.solveq(K, f, bc, bc_val)\n\n# ---- Compute element forces -----------------------------------------------\n\nprint(""Computing element forces..."")\n\ned = cfc.extract_eldisp(edof, a)\n\nfor i in range(np.shape(ex)[0]):\n    if mesh.el_type == 2:\n        es, et = cfc.flw2ts(ex[i, :], ey[i, :], D, ed[i, :])\n    elif mesh.el_type == 3:\n        es, et, eci = cfc.flw2i4s(ex[i, :], ey[i, :], ep, D, ed[i, :])\n    elif mesh.el_type == 16:\n        es, et, eci = cfc.flw2i8s(ex[i, :], ey[i, :], ep, D, ed[i, :])\n    else:\n        print(""Element type not supported."")\n\n    # Do something with es, et, eci here.\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry. Note that surfaces and volumes are not drawn at all by\n# this function.\n\ncfv.draw_geometry(g)\n\n# New figure window\n\ncfv.figure()\n\n# Draw the mesh.\n\ncfv.draw_mesh(\n    coords=coords,\n    edof=edof,\n    dofs_per_node=mesh.dofs_per_node,\n    el_type=mesh.el_type,\n    filled=True,\n    title=""Example 01""\n)\n\ncfv.figure()\ncfv.draw_nodal_values_shaded(a, coords, edof, title=""Temperature"")\ncfv.colorbar()\n\ncfv.figure()\ncfv.draw_nodal_values_contourf(a, coords, edof, title=""Temperature"", dofs_per_node=mesh.dofs_per_node, el_type=mesh.el_type, draw_elements=True)\ncfv.colorbar()\n\ncfv.figure()\ncfv.draw_nodal_values_contour(a, coords, edof)\ncfv.colorbar()\n\n# cfv.addText(""This is a Text"", pos=(1, -0.3), angle=45)  #Adds a text in world space\n\n# ourLabel = cfv.label(""This is a Label"", pos=(100,200), angle=-45) #Adds a label in the screen space\n# ourLabel.text = ""Label, changed."" #We can change the attributes of labels and texts, such as color, text, and position.\n# ourLabel.textColor = \'r\'  #Make it red. (1,0,0) would also have worked.\n#ourLabel.position = (20,30)\n\n# Enter main loop:\n\ncfv.showAndWait()\n'"
examples/exm1_mpl.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 01\n\nShows how to create simple geometry from splines and ellipse arcs, and how to mesh a quad mesh in GmshMesher.\nAlso demonstrates drawGeometry(), drawMesh, and drawing texts and labels in a figure.\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()  # Create a GeoData object that holds the geometry.\n\n# Add points:\n#  The first parameter is the coordinates. These can be in 2D or 3D.\n#  The other parameters are not defined in this example. These parameters are\n#  ID, marker, and elSize.\n#  Since we do not specify an ID the points are automatically assigned IDs,\n#  starting from 0.\n\ng.point([0, 0])\ng.point([2, 0])\ng.point([2, 1])\ng.point([0, 1])\ng.point([0.5, 0.3])\ng.point([0.3, 0.7])\ng.point([0.7, 0.7])\ng.point([0.8, 0.5])\ng.point([1.7, 0.5])\ng.point([1.5, 0.5])\ng.point([1.7, 0.7])\n\n# Add curves:\n#  There are four types of curves. In this example we create an ellipse arc\n#  and some splines. The first parameter is a list of point IDs that define\n#  the curve. Curves can have have IDs and markers. In this example the IDs\n#  are undefined so the curves are automatically assigned IDs. The markers can\n#  be used for identifying regions/boundaries in the model.\n\n\n# 0 - An ellipse arc. Read the function\n#     doc for more information. The four\n#     points are\n#     [start, center, majorAxis, end]\n\ng.ellipse([7, 8, 9, 10], marker=50)\n\ng.spline([0, 1], marker=80)           # 1 - A spline. Splines pass through the\n                                      #     points in the first parameter.\ng.spline([2, 1])                      # 2\ng.spline([3, 2])                      # 3\ng.spline([0, 3])                      # 4\ng.spline([7, 9], marker=50)           # 5\ng.spline([10, 9])                     # 6\ng.spline([4, 5, 6, 4])                # 7 - This is a closed spline.\n                                      #     The start and end points are the same\n\n# Add a surface:\n#  Surfaces are defined by its curve boundaries.\n#  The first parameter is a list of curve IDs that specify the outer boundary\n#  of the surface. The second parameter is a list of lists of curve IDs that\n#  specify holes in the surface. In this example there are two holes. The\n#  boundaries and holes must be closed paths. We can see that [7] is closed\n#  because curve 7 is a closed spline. addSurface creates a flat surface, so\n#  all curves must lie on the same plane.\n\ng.surface([4, 3, 2, 1], [[7], [5, 6, 0]])\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 3 is quad.\n# (2 is triangle. See user manual for more element types)\n\nmesh.el_type = 3\nmesh.dofs_per_node = 1  # Degrees of freedom per node.\nmesh.el_size_factor = 0.05  # Factor that changes element sizes.\n# mesh.mesh_dir = ""./mesh_files""\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\n# Mesh the geometry:\n#\n# The first four return values are the same as those that trimesh2d() returns.\n# coords is as list of node coordinates. edof is the element topology\n# (element degrees of freedom). dofs is a lists of all degrees of freedom\n# bdofs is a dictionary of boundary dofs (dofs of geometric entities with\n# markers). elementmarkers is a list of markers, and is used for finding the\n# marker of a given element (index).\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry. Note that surfaces and volumes are not drawn at all by\n# this function.\n\ncfv.draw_geometry(g)\n\n# New figure window\n\ncfv.figure()\n\n# Draw the mesh.\n\ncfv.draw_mesh(\n    coords=coords,\n    edof=edof,\n    dofs_per_node=mesh.dofs_per_node,\n    el_type=mesh.el_type,\n    filled=True,\n    title=""Example 01""\n)\n\n# Adds a text in world space\n\ncfv.text(""This is a Text"", pos=(1, -0.3), rotation=45)\n\n# Adds a label in the screen space\n\nour_label = cfv.label(""This is a Label"", pos=(1, 0.3), rotation=-45)\n\n# We can change the attributes of labels and texts, such as color, text, and position.\n\nour_label.set_text(""Label, changed."")\nour_label.set_color(\'r\')  # Make it red. (1,0,0) would also have worked.\nour_label.set_position((1, 0.3))\n\n# Enter main loop:\n\ncfv.showAndWait()\n'"
examples/exm2.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'\nExample 02\nCreating geometry from B-Splines and circle arcs.\nAlso shows how to set ID numbers for geometry entities and how to specify element density. \n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()\n\n# Add points:\n#  In this example we set the IDs manually.\n\ng.point([ -2,  0], ID=0)\ng.point([  0,  1], ID=1, el_size=5) # el_size determines the size of the elements near this point.\ng.point([  1,  0], 2, el_size=5)    #  el_size is 1 by default. Larger number means less dense mesh.\ng.point([  0, -2], 3)              #  Size means the length of the sides of the elements.\ng.point([  0,  0], 4, el_size=5)\ng.point([ .5, .2], 5)\ng.point([-.5, .5], 6)\ng.point([-.7,-.5], 7)\n\n# Add curves:\n\n# The 3 points that define the circle arc are [start, center, end]. \n# The arc must be smaller than Pi.\n\ng.circle([1, 4, 2], 2) \n\n# BSplines are similar to Splines, but do not necessarily pass through the \n# control points.\n\ng.bspline([5,6,7,5], 5) \ng.bspline([1,0,3,2], 4)\n\n# Add surface:\n\ng.surface([4,2], [[5]])\n\n# Markers do not have to be set when the curve is created. It can be done afterwards.\n#  Set marker=80 for curves 2 and 4:\n\nfor curveID in [2, 4]:\n    g.curveMarker(curveID, 80)\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 2 is triangle. (3 is quad. See user manual for more element types)\n\nmesh.el_type = 2\n\n# Degrees of freedom per node.\n\nmesh.dofs_per_node = 2\nmesh.el_size_factor = 0.05\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry.\n\ncfv.draw_geometry(g, label_curves=True)\n\n# New figure window\n\ncfv.figure()\n\n# Draws the mesh. \n\ncfv.draw_mesh(\n    coords=coords, \n    edof=edof, \n    dofs_per_node = mesh.dofs_per_node, \n    el_type=mesh.el_type, \n    filled=True, \n    title=""Example 02""\n    ) \n\n# Show grid\n\ncfv.show_grid()\n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm2_mpl.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'\nExample 02\nCreating geometry from B-Splines and circle arcs.\nAlso shows how to set ID numbers for geometry entities and how to specify element density. \n\'\'\'\n\nimport matplotlib.pyplot as plt\nimport matplotlib.collections\nimport numpy as np\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()\n\n# Add points:\n#  In this example we set the IDs manually.\n\ng.point([-2,  0], ID=0)\n# el_size determines the size of the elements near this point.\ng.point([0,  1], ID=1, el_size=5)\n# el_size is 1 by default. Larger number means less dense mesh.\ng.point([1,  0], 2, el_size=5)\ng.point([0, -2], 3)  # Size means the length of the sides of the elements.\ng.point([0,  0], 4, el_size=5)\ng.point([.5, .2], 5)\ng.point([-.5, .5], 6)\ng.point([-.7, -.5], 7)\n\n# Add curves:\n\n# The 3 points that define the circle arc are [start, center, end].\n# The arc must be smaller than Pi.\n\ng.circle([1, 4, 2], 2)\n\n# BSplines are similar to Splines, but do not necessarily pass through the\n# control points.\n\ng.bspline([5, 6, 7, 5], 5)\ng.bspline([1, 0, 3, 2], 4)\n\n# Add surface:\n\ng.surface([4, 2], [[5]])\n\n# Markers do not have to be set when the curve is created. It can be done afterwards.\n#  Set marker=80 for curves 2 and 4:\n\nfor curveID in [2, 4]:\n    g.curveMarker(curveID, 80)\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 2 is triangle. (3 is quad. See user manual for more element types)\n\nmesh.el_type = 3\n\n# Degrees of freedom per node.\n\nmesh.dofs_per_node = 2\nmesh.el_size_factor = 0.05\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry.\n\ncfv.draw_geometry(\n    g,\n    label_curves=True,\n    title=""Example 2 - Geometry""\n)\n\n# New figure window\n\ncfv.figure()\n\n# Draws the mesh.\n\ncfv.draw_mesh(\n    coords=coords,\n    edof=edof,\n    dofs_per_node=mesh.dofs_per_node,\n    el_type=mesh.el_type,\n    filled=True,\n    title=""Example 2 - Mesh""\n)\n\n# Enter main loop\n\ncfv.show_and_wait()\n'"
examples/exm3.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 03\n\nShows structured meshing in 2D.\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()\n\n# Add Points:\n\ng.point([0,0])\ng.point([1.2, 0])\ng.point([1, 1.3])\ng.point([0, 1])\ng.point([2, 0.5])\n\n# Add Splines:\n# The first four curves are structured curves, i.e the number of nodes along \n# the curves is pre-determined. Parameter el_on_curve states how many elements \n# are placed along the curve. Parameters el_distrib_type and el_distrib_val are \n# optional parameters that specify how elements are distributed.\n#   ""bump"" means elements are bunched up at the ends or the middle of the curve.\n#       In this case el_distrib_val is smaller than 1, so elements crowd at the edges.\n#   ""progression"" means each element along the curve is larger/smaller than the previous one.\n#       A larger el_distrib_val makes the elements larger at the end of the curves. \n\ng.spline([0,1], el_on_curve=10, el_distrib_type=""bump"", el_distrib_val=0.2)\ng.spline([1,2], el_on_curve=20, el_distrib_type=""progression"", el_distrib_val=1.1)\ng.spline([2,3], el_on_curve=10, el_distrib_type=""bump"", el_distrib_val=0.2)\ng.spline([0,3], el_on_curve=20, el_distrib_type=""progression"", el_distrib_val=1.1) #Change order of points to reverse progression distribution\ng.spline([2, 4, 1])\n\n# Add Surfaces:\n#  A structured surface must contain 4 curves that have the parameter \'el_on_curve\' \n#  defined. The number of elements on two opposite curves must be the same \n#  (In this case, curves 0 & 2 and 1 & 3).\n\ng.structuredSurface([0,1,2,3]) \ng.surface([4,1])\n\n# ---- Create mesh ----------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 3 is quad. (2 is triangle. See user manual for more element types)\n\nmesh.el_type = 3 \n\n# Degrees of freedom per node.\n\nmesh.dofs_per_node = 1 \n\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Draw geometry\n\ncfv.draw_geometry(g)\n\n# Draw mesh\n\ncfv.figure()\ncfv.draw_mesh(coords, edof, dofs_per_node=mesh.dofs_per_node, el_type=mesh.el_type, filled=True)\n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm3_mpl.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 03\n\nShows structured meshing in 2D.\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()\n\n# Add Points:\n\ng.point([0,0])\ng.point([1.2, 0])\ng.point([1, 1.3])\ng.point([0, 1])\ng.point([2, 0.5])\n\n# Add Splines:\n# The first four curves are structured curves, i.e the number of nodes along \n# the curves is pre-determined. Parameter el_on_curve states how many elements \n# are placed along the curve. Parameters el_distrib_type and el_distrib_val are \n# optional parameters that specify how elements are distributed.\n#   ""bump"" means elements are bunched up at the ends or the middle of the curve.\n#       In this case el_distrib_val is smaller than 1, so elements crowd at the edges.\n#   ""progression"" means each element along the curve is larger/smaller than the previous one.\n#       A larger el_distrib_val makes the elements larger at the end of the curves. \n\ng.spline([0,1], el_on_curve=10, el_distrib_type=""bump"", el_distrib_val=0.2)\ng.spline([1,2], el_on_curve=20, el_distrib_type=""progression"", el_distrib_val=1.1)\ng.spline([2,3], el_on_curve=10, el_distrib_type=""bump"", el_distrib_val=0.2)\ng.spline([0,3], el_on_curve=20, el_distrib_type=""progression"", el_distrib_val=1.1) #Change order of points to reverse progression distribution\ng.spline([2, 4, 1])\n\n# Add Surfaces:\n#  A structured surface must contain 4 curves that have the parameter \'el_on_curve\' \n#  defined. The number of elements on two opposite curves must be the same \n#  (In this case, curves 0 & 2 and 1 & 3).\n\ng.structuredSurface([0,1,2,3]) \ng.surface([4,1])\n\n# ---- Create mesh ----------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 3 is quad. (2 is triangle. See user manual for more element types)\n\nmesh.el_type = 3 \n\n# Degrees of freedom per node.\n\nmesh.dofs_per_node = 1 \nmesh.el_size_factor = 0.01\n\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Draw geometry\n\ncfv.draw_geometry(g)\n\n# Draw mesh\n\ncfv.figure()\ncfv.draw_mesh(coords, edof, dofs_per_node=mesh.dofs_per_node, el_type=mesh.el_type, filled=True)\n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm4.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 04.\n\nStructured 3D meshing. Adding texts and labels to figures. Altering axis properties.\n\'\'\' \n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\n# Add Points\n\ng.point([0, 0, 0], ID=0)\ng.point([0.5, -0.3, -0.3], 1)\ng.point([1, 0, 0], 2)\ng.point([1, 1, 0], 3)\ng.point([0, 1, 0], 4, marker = 11) # Set some markers no reason.\ng.point([0, 0, 1], 5, marker = 11) # (markers can be given to points as well\n                                      # as curves and surfaces)\ng.point([1, 0, 1], 6, marker = 11)\ng.point([1, 1, 1], 7)\ng.point([0, 1, 1], 8)\n\n# Add splines\n\ng.spline([0, 1, 2], 0, marker = 33, el_on_curve = 5)\ng.spline([2, 3], 1, marker = 23, el_on_curve = 5)\ng.spline([3, 4], 2, marker = 23, el_on_curve = 5)\ng.spline([4, 0], 3, el_on_curve = 5)\ng.spline([0, 5], 4, el_on_curve = 5)\ng.spline([2, 6], 5, el_on_curve = 5)\ng.spline([3, 7], 6, el_on_curve = 5)\ng.spline([4, 8], 7, el_on_curve = 5)\ng.spline([5, 6], 8, el_on_curve = 5)\ng.spline([6, 7], 9, el_on_curve = 5)\ng.spline([7, 8], 10, el_on_curve = 5)\ng.spline([8, 5], 11, el_on_curve = 5)\n\n# Add surfaces\n\ng.structuredSurface([0, 1, 2, 3], 0, marker=45)\ng.structuredSurface([8, 9, 10, 11], 1)\ng.structuredSurface([0, 4, 8, 5], 2, marker=55)\ng.structuredSurface([1, 5, 9, 6], 3, marker=55)\ng.structuredSurface([2, 6, 10, 7], 4)\ng.structuredSurface([3, 4, 11, 7], 5)\n\n# Add Volume:\n#  addStructuredVolume() takes three args. The first is a list of surface IDs \n#  (structured surfaces). The surfaces should make a hexahedron \n#  (i.e. 6 surfaces). Other kinds of structured volumes than hexahedra will\n#  not work for hexahedral elements, which is the only type of 3D element that \n#  CALFEM handles. The two optional parameters are the volume ID and \n#  volume marker.\n\ng.structuredVolume([0,1,2,3,4,5], 0, marker=90)\n\n# ---- Create mesh ----------------------------------------------------------\n\n# Element type 5 is hexahedron. (See user manual for more element types)\n\nel_type = 5 \n\n# Degrees of freedom per node.\n\ndofs_per_node = 1 \n\n# Create mesh\n\ncoords, edof, dofs, bdofs, _ = cfm.mesh(g, el_type, dofs_per_node)\n\n#coords, edof, dofs, bdofs, _ = cfm.mesh(\n#        g, el_type, dofs_per_node, gmsh_exec_path=""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe"")\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold Left Mouse button to rotate.\n# Hold right mouse button to zoom.\n# Hold SHIFT and left mouse button to pan.\n# Hold SHIFT and right mouse button to change the field of view.\n# Hold Ctrl and left mouse button to roll the camera. \n\n# Draw geometry\n\ncfv.draw_geometry(g, draw_points=False)\n\n# Draw mesh\n\ncfv.figure()\ncfv.draw_mesh(coords=coords, edof=edof, dofs_per_node=dofs_per_node, el_type=el_type, filled=True)\n\n# Add a text in world space\n\ncfv.add_text(""This is a Text"", pos=(1, 0.5, 0.5), angle=45)  \n\n# Add a label in the screen space\n\nour_label = cfv.add_label(""This is a Label"", pos=(20,30), angle=-45) \n\n# We can change the attributes of labels and texts, such as color and position.\n\nour_label.text = ""Label, changed."" \n\n# Make it red. (1,0,0) would also have worked.\n\nour_label.textColor = \'r\'  \n\n# Matlab style axes (three axes in the background instead of a cube)\n\ncfv.gca().axis.showBox = 0 \n\n#Change the limits of the axes.\n\ncfv.gca().SetLimits(rangeX=(0,2), rangeY=(-1,1.5), rangeZ=(-0.5,2), margin=0.02) \n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm4_mpl.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 04.\n\nStructured 3D meshing. Adding texts and labels to figures. Altering axis properties.\n\'\'\' \n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\n# Add Points\n\ng.point([0, 0, 0], ID=0)\ng.point([0.5, -0.3, -0.3], 1)\ng.point([1, 0, 0], 2)\ng.point([1, 1, 0], 3)\ng.point([0, 1, 0], 4, marker = 11) # Set some markers no reason.\ng.point([0, 0, 1], 5, marker = 11) # (markers can be given to points as well\n                                      # as curves and surfaces)\ng.point([1, 0, 1], 6, marker = 11)\ng.point([1, 1, 1], 7)\ng.point([0, 1, 1], 8)\n\n# Add splines\n\ng.spline([0, 1, 2], 0, marker = 33, el_on_curve = 5)\ng.spline([2, 3], 1, marker = 23, el_on_curve = 5)\ng.spline([3, 4], 2, marker = 23, el_on_curve = 5)\ng.spline([4, 0], 3, el_on_curve = 5)\ng.spline([0, 5], 4, el_on_curve = 5)\ng.spline([2, 6], 5, el_on_curve = 5)\ng.spline([3, 7], 6, el_on_curve = 5)\ng.spline([4, 8], 7, el_on_curve = 5)\ng.spline([5, 6], 8, el_on_curve = 5)\ng.spline([6, 7], 9, el_on_curve = 5)\ng.spline([7, 8], 10, el_on_curve = 5)\ng.spline([8, 5], 11, el_on_curve = 5)\n\n# Add surfaces\n\ng.structuredSurface([0, 1, 2, 3], 0, marker=45)\ng.structuredSurface([8, 9, 10, 11], 1)\ng.structuredSurface([0, 4, 8, 5], 2, marker=55)\ng.structuredSurface([1, 5, 9, 6], 3, marker=55)\ng.structuredSurface([2, 6, 10, 7], 4)\ng.structuredSurface([3, 4, 11, 7], 5)\n\n# Add Volume:\n#  addStructuredVolume() takes three args. The first is a list of surface IDs \n#  (structured surfaces). The surfaces should make a hexahedron \n#  (i.e. 6 surfaces). Other kinds of structured volumes than hexahedra will\n#  not work for hexahedral elements, which is the only type of 3D element that \n#  CALFEM handles. The two optional parameters are the volume ID and \n#  volume marker.\n\ng.structuredVolume([0,1,2,3,4,5], 0, marker=90)\n\n# ---- Create mesh ----------------------------------------------------------\n\n# Element type 5 is hexahedron. (See user manual for more element types)\n\nel_type = 5 \n\n# Degrees of freedom per node.\n\ndofs_per_node = 1 \n\n# Create mesh\n\ncoords, edof, dofs, bdofs, _ = cfm.mesh(g, el_type, dofs_per_node)\n\n#coords, edof, dofs, bdofs, _ = cfm.mesh(\n#        g, el_type, dofs_per_node, gmsh_exec_path=""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe"")\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold Left Mouse button to rotate.\n# Hold right mouse button to zoom.\n# Hold SHIFT and left mouse button to pan.\n# Hold SHIFT and right mouse button to change the field of view.\n# Hold Ctrl and left mouse button to roll the camera. \n\n# Draw geometry\n\ncfv.draw_geometry(g, draw_points=False)\n\n# Draw mesh\n\ncfv.figure()\ncfv.draw_mesh(coords=coords, edof=edof, dofs_per_node=dofs_per_node, el_type=el_type, filled=True)\n\n# Add a text in world space\n\n#cfv.add_text(""This is a Text"", pos=(1, 0.5, 0.5), angle=45)  \n\n# Add a label in the screen space\n\n#our_label = cfv.add_label(""This is a Label"", pos=(20,30), angle=-45) \n\n# We can change the attributes of labels and texts, such as color and position.\n\n#our_label.text = ""Label, changed."" \n\n# Make it red. (1,0,0) would also have worked.\n\n#our_label.textColor = \'r\'  \n\n# Matlab style axes (three axes in the background instead of a cube)\n\n#cfv.gca().axis.showBox = 0 \n\n#Change the limits of the axes.\n\n#cfv.gca().SetLimits(rangeX=(0,2), rangeY=(-1,1.5), rangeZ=(-0.5,2), margin=0.02) \n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm5.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 05\n\nThis example shows how to make an unstructured 3D mesh (tetrahedron elements, which calfem cant actually use).\nIt also demonstrates how to do subplots and create two axes that are viewed from the same camera.\n\'\'\' \n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\ng.point([0, 0, 0],      0)\ng.point([1, 0, 0],      1)\ng.point([0, 1, 0],      2)\ng.point([0, 1, 1],      3, el_size=0.1)\ng.point([0.5, -0.3, 0], 4)\ng.point([-0.3, 0.5, 0], 5)\ng.point([0.75, 0.75, 0],6)\n\ng.spline([0,4,1])\ng.spline([1,6,2])\ng.spline([2,5,0])\ng.spline([0,3])\ng.spline([3,2])\ng.spline([3,1])\n\ng.ruledSurface([0,1,2])\ng.ruledSurface([0,5,3])\ng.ruledSurface([1,5,4])\ng.ruledSurface([2,3,4])\n\ng.volume([0,1,2,3])\n\n# ---- Create mesh ----------------------------------------------------------\n\n# Element type 4 is tetrahedron. (See user manual for more element types).\n\nel_type = 4 \n\n# Degrees of freedom per node.\n\ndofs_per_node = 1 \n\n# Create mesh\n\ncoords, edof, dofs, bdofs, elementmarkers = cfm.mesh(g, el_type, 0.3, dofs_per_node)\n\n#coords, edof, dofs, bdofs, _ = cfm.mesh(\n#        g, el_type, 0.3, dofs_per_node, gmsh_exec_path=""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe"")\n\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Create two axes that are viewed from the same camera:\n\ncfv.figure()\na1 = cfv.subplot(121)\na2 = cfv.subplot(122)\ncam = cfv.camera3d()\na1.camera = a2.camera = cam\n\n# Draw geometry and mesh\n\ncfv.draw_geometry(g, axes=a1)\ncfv.draw_mesh(coords=coords, edof=edof, dofs_per_node=dofs_per_node, el_type=el_type, filled=False, axes=a2)\n\n# Enter main loop\n\ncfv.show_and_wait()'"
examples/exm6.py,5,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 06\n\nSolves a plane stress 2D problem using a structured mesh.\nShows how to draw von Mises effective stress as an element value with \ndrawElementValues(). Shows use of GmshMesher attribute \'nodesOnCurve\' \n(dictionary that says which nodes are on a given geometry curve)\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\nimport numpy as np\n\nfrom math import sqrt\n\ncfu.enableLogging()\n\n# ---- Define problem variables ---------------------------------------------\n\nt = 0.2\nv = 0.35\nE = 2.1e9\nptype = 1\nep = [ptype,t]\nD=cfc.hooke(ptype, E, v)\n\n# ---- Define geometry ------------------------------------------------------\n\ncfu.info(""Creating geometry..."")\n\ng = cfg.geometry()\n\n# Just a shorthand. We use this to make the circle arcs.\n\ns2 = 1/sqrt(2) \n\npoints = [[0, 3], [2.5, 3], [3, 3], [4-s2, 3-s2], [4, 2],     #0-4\n          [4+s2, 3-s2], [5, 3], [5.5, 3], [8,3], [0, 1.5],    #5-9\n          [2.5, 1.5], [4, 1.5], [5.5, 1.5], [8, 1.5], [0, 0], #10-14\n          [2.5, 0], [3, 0], [4-s2, s2], [4, 1], [4+s2, s2],   #15-19\n          [5, 0], [5.5, 0], [8,0], [4,3], [4,0]]              #20-24\n          \nfor xp, yp in points:\n    g.point([xp*0.1, yp*0.1])\n\nsplines = [[0,1], [1,2], [6,7], [7,8], [8,13],          #0-4\n           [13,22], [22,21], [21,20], [16,15], [15,14], #5-9\n           [14,9], [9,0], [9,10], [10,1], [10, 15],     #10-14\n           [10,11], [11,4], [11,18], [11,12], [12,7],   #15-19\n           [12,21], [12,13], [3,10], [5,12], [10,17],   #20-24\n           [12,19]]                                     #25\n           \nfor s in splines:\n    g.spline(s, el_on_curve=10)\n    \ng.curveMarker(ID=4,  marker=7) #Assign marker 7 to the splines on the right.\ng.curveMarker(ID=5,  marker=7) # We will apply a force on nodes with marker 7.\ng.curveMarker(ID=10, marker=5) #Assign marker 5 to the splines on the left.\ng.curveMarker(ID=11, marker=5) # The nodes with marker 5 will be locked in place.\n\n# Points in circle arcs are [start, center, end]\n\ncirclearcs = [[2, 23, 3], [3, 23, 4], [4, 23, 5], [5, 23, 6],           #26-29\n              [16, 24, 17], [17, 24, 18], [18, 24, 19], [19, 24, 20]]   #30-33\n              \nfor c in circlearcs:\n    g.circle(c, el_on_curve=10)\n\ng.structuredSurface([11,12,13,0]) #0\ng.structuredSurface([14, 12, 10, 9])\ng.structuredSurface([8, 30, 24, 14])\ng.structuredSurface([24, 31, 17, 15])\ng.structuredSurface([15, 16, 27, 22]) #4\ng.structuredSurface([22, 26, 1, 13]) \ng.structuredSurface([16, 18, 23, 28])\ng.structuredSurface([19, 2, 29, 23])\ng.structuredSurface([19, 21, 4, 3]) #8\ng.structuredSurface([20, 6, 5, 21])\ng.structuredSurface([25, 20, 7, 33])\ng.structuredSurface([32, 17, 18, 25]) #11\n\n# ---- Create mesh ----------------------------------------------------------\n\ncfu.info(""Meshing geometry..."")\n\n# Create mesh\n\nmesh = cfm.GmshMesh(geometry = g)\nmesh.el_type = 3\nmesh.dofs_per_node = 2\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\ncfu.info(""Assembling system matrix..."")\n\nnDofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\nK = np.zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = cfc.planqe(elx, ely, ep, D)\n    cfc.assem(eltopo, K, Ke)\n\ncfu.info(""Solving equation system..."")\n\nf = np.zeros([nDofs,1])\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'f\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, 5, 0.0, 0)\n\ncfu.applyforce(bdofs, f, 7, 10e5, 1)\n\na,r = cfc.solveq(K,f,bc,bcVal)\n\ncfu.info(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\nvonMises = []\n\n# For each element:\n\nfor i in range(edof.shape[0]): \n\n    # Determine element stresses and strains in the element.\n    \n    es, et = cfc.planqs(ex[i,:], ey[i,:], ep, D, ed[i,:]) \n\n    # Calc and append effective stress to list.    \n    \n    vonMises.append( sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*es[2] ) ) \n\n    ## es: [sigx sigy tauxy]\n\n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Visualising..."")\n\ncfv.drawGeometry(g, draw_points=False, label_curves=True)\n\ncfv.figure()\ncfv.draw_element_values(vonMises, coords, edof, mesh.dofs_per_node, mesh.el_type, a, draw_elements=True, draw_undisplaced_mesh=False, title=""Example 06 effective stress"")\n\ncfv.figure()\ncfv.draw_displacements(a, coords, edof, mesh.dofs_per_node, mesh.el_type, draw_undisplaced_mesh=True, title=""Example 06"")\n\n# Make use of attribute \'nodesOnCurve\' in GmshMesher to draw some arrows on \n# the right hand side of the mesh:\n\nrightSideNodes = set()\n\n# 4 and 5 are the IDs of the curves where we applied the forces.\n\nfor curveID in [4,5]: \n\n    # Get the nodes, without duplicates.\n\n    rightSideNodes = rightSideNodes.union(set(mesh.nodesOnCurve[curveID])) \n    \nfor i in rightSideNodes:\n\n    # Position of the node with displacements.\n\n    x = coords[i,0] + a[i*2, 0]     \n    y = coords[i,1] + a[i*2+1, 0]\n    \n    # A poor man\'s force indicator. Could also use vv.plot()    \n    \n    cfv.addText(""\\rightarrow"", (x, y), font_size=20, color=\'g\') \n\n# Enter main loop\n\ncfv.show_and_wait()\n\nprint(""Done."")\n'"
examples/exm6_mpl.py,5,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 06\n\nSolves a plane stress 2D problem using a structured mesh.\nShows how to draw von Mises effective stress as an element value with \ndrawElementValues(). Shows use of GmshMesher attribute \'nodesOnCurve\' \n(dictionary that says which nodes are on a given geometry curve)\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\nimport numpy as np\n\nfrom math import sqrt\n\ncfu.enableLogging()\n\n# ---- Define problem variables ---------------------------------------------\n\nt = 0.2\nv = 0.35\nE = 2.1e9\nptype = 1\nep = [ptype,t]\nD=cfc.hooke(ptype, E, v)\n\n# ---- Define geometry ------------------------------------------------------\n\ncfu.info(""Creating geometry..."")\n\ng = cfg.geometry()\n\n# Just a shorthand. We use this to make the circle arcs.\n\ns2 = 1/sqrt(2) \n\npoints = [[0, 3], [2.5, 3], [3, 3], [4-s2, 3-s2], [4, 2],     #0-4\n          [4+s2, 3-s2], [5, 3], [5.5, 3], [8,3], [0, 1.5],    #5-9\n          [2.5, 1.5], [4, 1.5], [5.5, 1.5], [8, 1.5], [0, 0], #10-14\n          [2.5, 0], [3, 0], [4-s2, s2], [4, 1], [4+s2, s2],   #15-19\n          [5, 0], [5.5, 0], [8,0], [4,3], [4,0]]              #20-24\n          \nfor xp, yp in points:\n    g.point([xp*0.1, yp*0.1])\n\nsplines = [[0,1], [1,2], [6,7], [7,8], [8,13],          #0-4\n           [13,22], [22,21], [21,20], [16,15], [15,14], #5-9\n           [14,9], [9,0], [9,10], [10,1], [10, 15],     #10-14\n           [10,11], [11,4], [11,18], [11,12], [12,7],   #15-19\n           [12,21], [12,13], [3,10], [5,12], [10,17],   #20-24\n           [12,19]]                                     #25\n           \nfor s in splines:\n    g.spline(s, el_on_curve=10)\n    \ng.curveMarker(ID=4,  marker=7) #Assign marker 7 to the splines on the right.\ng.curveMarker(ID=5,  marker=7) # We will apply a force on nodes with marker 7.\ng.curveMarker(ID=10, marker=5) #Assign marker 5 to the splines on the left.\ng.curveMarker(ID=11, marker=5) # The nodes with marker 5 will be locked in place.\n\n# Points in circle arcs are [start, center, end]\n\ncirclearcs = [[2, 23, 3], [3, 23, 4], [4, 23, 5], [5, 23, 6],           #26-29\n              [16, 24, 17], [17, 24, 18], [18, 24, 19], [19, 24, 20]]   #30-33\n              \nfor c in circlearcs:\n    g.circle(c, el_on_curve=10)\n\ng.structuredSurface([11,12,13,0]) #0\ng.structuredSurface([14, 12, 10, 9])\ng.structuredSurface([8, 30, 24, 14])\ng.structuredSurface([24, 31, 17, 15])\ng.structuredSurface([15, 16, 27, 22]) #4\ng.structuredSurface([22, 26, 1, 13]) \ng.structuredSurface([16, 18, 23, 28])\ng.structuredSurface([19, 2, 29, 23])\ng.structuredSurface([19, 21, 4, 3]) #8\ng.structuredSurface([20, 6, 5, 21])\ng.structuredSurface([25, 20, 7, 33])\ng.structuredSurface([32, 17, 18, 25]) #11\n\n# ---- Create mesh ----------------------------------------------------------\n\ncfu.info(""Meshing geometry..."")\n\n# Create mesh\n\nmesh = cfm.GmshMesh(geometry = g)\nmesh.el_type = 3\nmesh.dofs_per_node = 2\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\ncfu.info(""Assembling system matrix..."")\n\nnDofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\nK = np.zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = cfc.planqe(elx, ely, ep, D)\n    cfc.assem(eltopo, K, Ke)\n\ncfu.info(""Solving equation system..."")\n\nf = np.zeros([nDofs,1])\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'f\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, 5, 0.0, 0)\n\ncfu.applyforce(bdofs, f, 7, 10e5, 1)\n\na,r = cfc.solveq(K,f,bc,bcVal)\n\ncfu.info(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\nvonMises = []\n\n# For each element:\n\nfor i in range(edof.shape[0]): \n\n    # Determine element stresses and strains in the element.\n    \n    es, et = cfc.planqs(ex[i,:], ey[i,:], ep, D, ed[i,:]) \n\n    # Calc and append effective stress to list.    \n    \n    vonMises.append( sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*es[2] ) ) \n\n    ## es: [sigx sigy tauxy]\n\n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Visualising..."")\n\ncfv.figure()\ncfv.draw_geometry(g, draw_points=True, label_curves=True, label_points=True)\n\ncfv.figure()\ncfv.draw_mesh(coords, edof, dofs_per_node=mesh.dofs_per_node, el_type=mesh.el_type)\n\ncfv.figure()\ncfv.draw_element_values(vonMises, coords, edof, mesh.dofs_per_node, mesh.el_type, None, draw_elements=False, draw_undisplaced_mesh=False, title=""Example 6 - Effective stress"")\n\ncfv.figure()\ncfv.draw_displacements(a, coords, edof, mesh.dofs_per_node, mesh.el_type, draw_undisplaced_mesh=True, title=""Example 06 - Displacements"")\n\n# Make use of attribute \'nodesOnCurve\' in GmshMesher to draw some arrows on \n# the right hand side of the mesh:\n\nrightSideNodes = set()\n\n# 4 and 5 are the IDs of the curves where we applied the forces.\n\nfor curveID in [4,5]: \n\n    # Get the nodes, without duplicates.\n\n    rightSideNodes = rightSideNodes.union(set(mesh.nodesOnCurve[curveID])) \n    \nfor i in rightSideNodes:\n\n    # Position of the node with displacements.\n\n    x = coords[i,0] + a[i*2, 0]     \n    y = coords[i,1] + a[i*2+1, 0]\n    \n    # A poor man\'s force indicator. Could also use vv.plot()    \n    \n    #cfv.addText(""\\rightarrow"", (x, y), fontSize=20, color=\'g\') \n\n# Enter main loop\n\ncfv.show_and_wait()\n\nprint(""Done."")\n'"
examples/exm6_vtk.py,10,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 06\n\nSolves a plane stress 2D problem using a structured mesh.\nShows how to draw von Mises effective stress as an element value with \ndrawElementValues(). Shows use of GmshMesher attribute \'nodesOnCurve\' \n(dictionary that says which nodes are on a given geometry curve)\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\nimport numpy as np\n\nfrom math import sqrt\n\ncfu.enableLogging()\n\n# ---- Define problem variables ---------------------------------------------\n\nt = 0.2\nv = 0.35\nE = 2.1e9\nptype = 1\nep = [ptype,t]\nD=cfc.hooke(ptype, E, v)\n\n# ---- Define geometry ------------------------------------------------------\n\ncfu.info(""Creating geometry..."")\n\ng = cfg.geometry()\n\n# Just a shorthand. We use this to make the circle arcs.\n\ns2 = 1/sqrt(2) \n\npoints = [[0, 3], [2.5, 3], [3, 3], [4-s2, 3-s2], [4, 2],     #0-4\n          [4+s2, 3-s2], [5, 3], [5.5, 3], [8,3], [0, 1.5],    #5-9\n          [2.5, 1.5], [4, 1.5], [5.5, 1.5], [8, 1.5], [0, 0], #10-14\n          [2.5, 0], [3, 0], [4-s2, s2], [4, 1], [4+s2, s2],   #15-19\n          [5, 0], [5.5, 0], [8,0], [4,3], [4,0]]              #20-24\n          \nfor xp, yp in points:\n    g.point([xp*0.1, yp*0.1])\n\nsplines = [[0,1], [1,2], [6,7], [7,8], [8,13],          #0-4\n           [13,22], [22,21], [21,20], [16,15], [15,14], #5-9\n           [14,9], [9,0], [9,10], [10,1], [10, 15],     #10-14\n           [10,11], [11,4], [11,18], [11,12], [12,7],   #15-19\n           [12,21], [12,13], [3,10], [5,12], [10,17],   #20-24\n           [12,19]]                                     #25\n           \nfor s in splines:\n    g.spline(s, el_on_curve=10)\n    \ng.curveMarker(ID=4,  marker=7) #Assign marker 7 to the splines on the right.\ng.curveMarker(ID=5,  marker=7) # We will apply a force on nodes with marker 7.\ng.curveMarker(ID=10, marker=5) #Assign marker 5 to the splines on the left.\ng.curveMarker(ID=11, marker=5) # The nodes with marker 5 will be locked in place.\n\n# Points in circle arcs are [start, center, end]\n\ncirclearcs = [[2, 23, 3], [3, 23, 4], [4, 23, 5], [5, 23, 6],           #26-29\n              [16, 24, 17], [17, 24, 18], [18, 24, 19], [19, 24, 20]]   #30-33\n              \nfor c in circlearcs:\n    g.circle(c, el_on_curve=10)\n\ng.structuredSurface([11,12,13,0]) #0\ng.structuredSurface([14, 12, 10, 9])\ng.structuredSurface([8, 30, 24, 14])\ng.structuredSurface([24, 31, 17, 15])\ng.structuredSurface([15, 16, 27, 22]) #4\ng.structuredSurface([22, 26, 1, 13]) \ng.structuredSurface([16, 18, 23, 28])\ng.structuredSurface([19, 2, 29, 23])\ng.structuredSurface([19, 21, 4, 3]) #8\ng.structuredSurface([20, 6, 5, 21])\ng.structuredSurface([25, 20, 7, 33])\ng.structuredSurface([32, 17, 18, 25]) #11\n\n# ---- Create mesh ----------------------------------------------------------\n\ncfu.info(""Meshing geometry..."")\n\n# Create mesh\n\nmesh = cfm.GmshMesh(geometry = g)\nmesh.el_type = 3\nmesh.dofs_per_node = 2\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\ntopo = mesh.topo\n\n# ---- Solve problem --------------------------------------------------------\n\ncfu.info(""Assembling system matrix..."")\n\nnDofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\nK = np.zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = cfc.planqe(elx, ely, ep, D)\n    cfc.assem(eltopo, K, Ke)\n\ncfu.info(""Solving equation system..."")\n\nf = np.zeros([nDofs,1])\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'f\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, 5, 0.0, 0)\n\ncfu.applyforcetotal(bdofs, f, 7, 10e5, 1)\n\na,r = cfc.solveq(K,f,bc,bcVal)\n\ncfu.info(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\nvon_mises = []\nprincipal1 = []\nprincipal2 = []\n\n# For each element:\n\nfor i in range(edof.shape[0]): \n\n    # Determine element stresses and strains in the element.\n    \n    es, et = cfc.planqs(ex[i,:], ey[i,:], ep, D, ed[i,:]) \n\n    # Calc and append effective stress to list.    \n    \n    von_mises.append( sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*es[2] ) ) \n\n    theta = np.arctan2(2*es[2], es[0]-es[1])*0.5\n    sigma1 = 0.5*(es[0]+es[1])+np.sqrt(np.power(0.5*(es[0]-es[1]),2)+np.power(es[2],2))\n    sigma2 = 0.5*(es[0]+es[1])-np.sqrt(np.power(0.5*(es[0]-es[1]),2)+np.power(es[2],2))\n    s1v = [sigma1*np.cos(theta), sigma1*np.sin(theta), 0.0]\n    s2v = [sigma2*np.cos(theta+0.5*np.pi), sigma2*np.sin(theta+0.5*np.pi), 0.0]\n    principal1.append(s1v)\n    principal2.append(s2v)\n\n# ---- Export to VTK --------------------------------------------------------\n\ncfu.export_vtk_stress(""exm6.vtk"", coords, mesh.topo-1, a, von_mises, principal1, principal2)\n'"
examples/exm7.py,8,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 07\n\nMeshing 8-node-isoparametric elements (second order incomplete quads).\nShows use of surfacemarkers/elementmarkers to apply different properties to \nelements in different regions. \n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\nimport numpy as np\n\n# ---- Problem constants ----------------------------------------------------\n\nkx1 = 100\nky1 = 100\nkx2 = 10\nky2 = 10\nt = 1.0\n\n# Gauss points or integration points \n\nn = 2 \nep = [t, n]\n\nD1 = np.matrix([\n    [kx1, 0.],\n    [0., ky1]\n])\nD2 = np.matrix([\n    [kx2, 0.],\n    [0., ky2]\n])\n\n# markers 10 & 11 will be used to specify different regions with different \n# conductivity.\n\nDdict = {10 : D1, 11 : D2} \n\n# ---- Create Geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\n# Add Points:\n\npoints = [\n    [0,0], \n    [0,100], \n    [0,150], \n    [100,0], \n    [150,0], \n    [100,-100], \n    [150,-100]\n]\n\nfor p in points:\n    g.point(p)\n\n# Add Splines:\n\ng.spline([1,2], marker=2, el_on_curve=4)\ng.spline([3,4], el_on_curve=4)\ng.circle([1,0,3], el_on_curve = 10)\ng.circle([2,0,4], el_on_curve = 10)\ng.spline([3,5], el_on_curve = 6)\ng.spline([5,6], marker=3, el_on_curve = 4)\ng.spline([6,4], el_on_curve = 6)\n\n# Add Surfaces:\n#\n# When we set markers for surfaces, and have 2D elements, we can find which \n# region an element is in via the list \'elementmarkers\', which is returned by \n# GmshMesher.create()\n\ng.structuredSurface([0,2,1,3], marker = 10)\ng.structuredSurface([1,4,5,6], marker = 11)\n\n# Element type 16 is 8-node-quad. (See gmsh manual for more element types)\n\nel_type = 16 \n\n#Degrees of freedom per node.\n\ndofs_per_node = 1 \n\n# ---- Generate mesh --------------------------------------------------------\n\n# gmshExecPath = Path to gmsh.exe. \n# If None then the system PATH variable is queried. \n# Relative and absolute paths work.\n\nmesh = cfm.GmshMeshGenerator(g, el_type, dofs_per_node) \n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\nprint(""Assembling system matrix..."")\n\nn_dofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\nK = np.zeros([n_dofs,n_dofs])\n\nfor eltopo, elx, ely, elMarker in zip(edof, ex, ey, elementmarkers):\n\n    # Calc element stiffness matrix: Conductivity matrix D is taken \n    # from Ddict and depends on which region (which marker) the element is in.\n\n    Ke = cfc.flw2i8e(elx, ely, ep, Ddict[elMarker]) \n    cfc.assem(eltopo, K, Ke)\n\nprint(""Solving equation system..."")\n\nf = np.zeros([n_dofs,1])\n\nbc = np.array([],\'i\')\nbc_val = np.array([],\'i\')\n\nbc, bc_val = cfu.applybc(bdofs,bc,bc_val,2,30.0)\nbc, bc_val = cfu.applybc(bdofs,bc,bc_val,3,0.0)\n\na,r = cfc.solveq(K,f,bc,bc_val)\n\n# ---- Compute element forces -----------------------------------------------\n\nprint(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\n\nfor i in range(np.shape(ex)[0]):\n    es, et, eci = cfc.flw2i8s(ex[i,:], ey[i,:], ep, Ddict[elementmarkers[i]], ed[i,:])\n\n    # Do something with es, et, eci here.\n   \n# ---- Visualise results ----------------------------------------------------\n\nprint(""Visualising..."")\n\ncfv.drawGeometry(g, title=""Geometry"")\n\ncfv.figure()\n\n# 8-node quads are drawn as simple quads.\n\ncfv.drawMesh(coords, edof, dofs_per_node, el_type, filled=False)\n\ncfv.figure()\ncfv.draw_nodal_values(a, coords, edof, dofs_per_node, el_type, title=""Example 7"")\ncfv.get_color_bar().SetLabel(""Temperature"")\ncfv.add_text(""The bend has high conductivity"", (125,125))\ncfv.add_text(""This part has low conductivity"", (160,-50))\n\n# Enter main loop\n\ncfv.show_and_wait()\n\nprint(""Done."")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'"
examples/exm7_mpl.py,8,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 07\n\nMeshing 8-node-isoparametric elements (second order incomplete quads).\nShows use of surfacemarkers/elementmarkers to apply different properties to \nelements in different regions. \n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.tri as tri\n\nimport numpy as np\n\n# ---- Problem constants ----------------------------------------------------\n\nkx1 = 100\nky1 = 100\nkx2 = 10\nky2 = 10\nt = 1.0\n\n# Gauss points or integration points \n\nn = 2 \nep = [t, n]\n\nD1 = np.matrix([\n    [kx1, 0.],\n    [0., ky1]\n])\nD2 = np.matrix([\n    [kx2, 0.],\n    [0., ky2]\n])\n\n# markers 10 & 11 will be used to specify different regions with different \n# conductivity.\n\nDdict = {10 : D1, 11 : D2} \n\n# ---- Create Geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\n# Add Points:\n\npoints = [\n    [0,0], \n    [0,100], \n    [0,150], \n    [100,0], \n    [150,0], \n    [100,-100], \n    [150,-100]\n]\n\nfor p in points:\n    g.point(p)\n\n# Add Splines:\n\ng.spline([1,2], marker=2, el_on_curve=4)\ng.spline([3,4], el_on_curve=4)\ng.circle([1,0,3], el_on_curve = 10)\ng.circle([2,0,4], el_on_curve = 10)\ng.spline([3,5], el_on_curve = 6)\ng.spline([5,6], marker=3, el_on_curve = 4)\ng.spline([6,4], el_on_curve = 6)\n\n# Add Surfaces:\n#\n# When we set markers for surfaces, and have 2D elements, we can find which \n# region an element is in via the list \'elementmarkers\', which is returned by \n# GmshMesher.create()\n\ng.structuredSurface([0,2,1,3], marker = 10)\ng.structuredSurface([1,4,5,6], marker = 11)\n\n# Element type 16 is 8-node-quad. (See gmsh manual for more element types)\n\nel_type = 16 \n\n#Degrees of freedom per node.\n\ndofs_per_node = 1 \n\n# ---- Generate mesh --------------------------------------------------------\n\n# gmshExecPath = Path to gmsh.exe. \n# If None then the system PATH variable is queried. \n# Relative and absolute paths work.\n\nmesh = cfm.GmshMeshGenerator(g, el_type, dofs_per_node) \n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Solve problem --------------------------------------------------------\n\nprint(""Assembling system matrix..."")\n\nn_dofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\nK = np.zeros([n_dofs,n_dofs])\n\nfor eltopo, elx, ely, elMarker in zip(edof, ex, ey, elementmarkers):\n\n    # Calc element stiffness matrix: Conductivity matrix D is taken \n    # from Ddict and depends on which region (which marker) the element is in.\n\n    Ke = cfc.flw2i8e(elx, ely, ep, Ddict[elMarker]) \n    cfc.assem(eltopo, K, Ke)\n\nprint(""Solving equation system..."")\n\nf = np.zeros([n_dofs,1])\n\nbc = np.array([],\'i\')\nbc_val = np.array([],\'i\')\n\nbc, bc_val = cfu.applybc(bdofs,bc,bc_val,2,30.0)\nbc, bc_val = cfu.applybc(bdofs,bc,bc_val,3,0.0)\n\na,r = cfc.solveq(K,f,bc,bc_val)\n\n# ---- Compute element forces -----------------------------------------------\n\nprint(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\n\nfor i in range(np.shape(ex)[0]):\n    es, et, eci = cfc.flw2i8s(ex[i,:], ey[i,:], ep, Ddict[elementmarkers[i]], ed[i,:])\n\n    # Do something with es, et, eci here.\n   \n# ---- Visualise results ----------------------------------------------------\n\nprint(""Visualising..."")\n\ncfv.set_figure_dpi(100)\n\ncfv.draw_geometry(g, title=""Geometry"")\n\n# 8-node quads are drawn as simple quads.\n\ncfv.figure()\ncfv.draw_mesh(coords, edof, dofs_per_node, el_type, filled=False)\n\ncfv.figure()\ncfv.draw_nodal_values_shaded(a, coords, edof, title=""Temperature"", dofs_per_node=mesh.dofs_per_node, el_type=mesh.el_type, draw_elements=True)\ncbar = cfv.colorbar(orientation=""horizontal"")\ncbar.set_label(""Temperature"")\n\n\ncfv.text(""The bend has high conductivity"", (125,125))\ncfv.text(""This part has low conductivity"", (160,-50))\n\n# Enter main loop\n\ncfv.show_and_wait()\n\nprint(""Done."")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n'"
examples/exmqt1.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Mar  1 16:23:37 2017\n\n@author: Jonas Lindemann\n""""""\n\nimport sys\nimport time\n\nfrom calfem.qt5 import *\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()\n\n        # Load user interface from UI-file\n\n        loadUi(\'exmqt1.ui\', self)\n        \n        Figure = cfv.figureClass()\n        \n        self.fig1 = Figure(self)\n        self.fig2 = Figure(self)\n        \n        self.gridLayout.addWidget(self.fig1._widget, 0, 0)\n        self.gridLayout.addWidget(self.fig2._widget, 0, 1)\n        \n        print(self.fig1._widget)\n        \n      \n    @pyqtSlot()\n    def on_executeButton_clicked(self):\n        self.solveProblem()        \n        self.drawGeometry()\n        self.drawMesh()\n        \n        \n    def solveProblem(self):\n                \n        g = cfg.Geometry() #Create a GeoData object that holds the geometry.\n\n        g.point([0, 0])\n        g.point([2, 0])\n        g.point([2, 1])\n        g.point([0, 1])\n        g.point([0.5, 0.3])\n        g.point([0.3, 0.7])\n        g.point([0.7, 0.7])\n        g.point([0.8, 0.5])\n        g.point([1.7, 0.5])\n        g.point([1.5, 0.5])\n        g.point([1.7, 0.7])\n\n        g.ellipse([7,8,9,10], marker=50)      # 0 - An ellipse arc. Read the function \n        g.spline([0, 1], marker=80)           # 1 - A spline. Splines pass through the \n        g.spline([2, 1])                      # 2\n        g.spline([3, 2])                      # 3\n        g.spline([0, 3])                      # 4\n        g.spline([7, 9], marker=50)           # 5\n        g.spline([10, 9])                     # 6\n        g.spline([4, 5, 6, 4])                # 7 - This is a closed spline. \n\n        g.surface([4,3,2,1], [[7], [5,6,0]])\n        \n        meshGen = cfm.GmshMeshGenerator(g)\n              \n        meshGen.elType = 3 # Degrees of freedom per node.\n        meshGen.dofsPerNode = 1 # Factor that changes element sizes.\n        meshGen.elSizeFactor = 0.05     \n                \n        self.coords, self.edof, self.dofs, self.bdofs, self.elementmarkers = meshGen.create()\n        self.meshGen = meshGen       \n        self.g = g\n               \n    def drawGeometry(self):\n        cfv.figure(self.fig1.nr) \n        cfv.clf()\n        cfv.drawGeometry(self.g)\n    \n    def drawMesh(self):\n        cfv.figure(self.fig2.nr) \n        cfv.clf()\n        cfv.draw_mesh(\n            coords=self.coords, \n            edof=self.edof, \n            dofs_per_node=self.meshGen.dofsPerNode, \n            el_type=self.meshGen.elType, \n            filled=True, \n            title=""Example 01""\n            ) \n        \n        cfv.addText(""This is a Text"", pos=(1, -0.3), angle=45)  #Adds a text in world space\n        \n        ourLabel = cfv.label(""This is a Label"", pos=(100,200), angle=-45) #Adds a label in the screen space\n        ourLabel.text = ""Label, changed."" #We can change the attributes of labels and texts, such as color, text, and position.\n        ourLabel.textColor = \'r\'  #Make it red. (1,0,0) would also have worked.\n        ourLabel.position = (20,30)\n        \n        \nif __name__ == ""__main__"":\n    \n    app = QApplication(sys.argv)\n    widget = MainWindow()\n    widget.show()\n    sys.exit(app.exec_())  \n'"
examples/exmqt11.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 11\n\nSimple example illustrating how to integrate calfem for Python in \na complex Qt user interface.\n\'\'\'\n\nimport sys\n\nfrom calfem.qt5 import *\n\nimport calfem.core as cfc\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.shapes as cfs\nimport calfem.solver as cfslv\n\nclass PlaneStress2DProblem(object):\n    def __init__(self, width=5.0, height=1.0, t=1.0, v=0.2, E=2e9, maxArea=0.08):\n        """"""Init model parameters""""""\n        self.w = width\n        self.h = height\n        self.t = t\n        self.v = v\n        self.E = E\n        self.maxArea = 0.08\n        \n    def updateGeometry(self):\n        """"""Update geometry from set parameters""""""        \n        rect = cfs.Rectangle(self.w, self.h, elementType=3, dofsPerNode=2, maxArea=self.maxArea)\n        rect.t = self.t\n        rect.v = self.v\n        rect.E = self.E\n\n        rect.ptype = 1\n        rect.ep = [rect.ptype, rect.t]\n        rect.D = cfc.hooke(rect.ptype, rect.E, rect.v)\n        \n        self.rect = rect\n        \n    def updateMesh(self):\n        """"""Generate mesh""""""\n        self.updateGeometry()\n        self.mesh = cfs.ShapeMesh(self.rect)    \n        \n    def solve(self):\n        """"""Solve problem""""""\n        \n        cfu.enableLogging()\n        \n        solver = cfslv.Plan2DSolver(self.mesh)\n        \n        solver.addBC(self.rect.leftId, 0.0)\n        solver.addForceTotal(self.rect.topId, -10e5, dimension=2)\n        \n        self.results = solver.execute()       \n        \n        cfu.disableLogging()\n\n        \n    def drawGeometry(self, figGeometry):\n        """"""Draw geometry in provided figure""""""\n        cfv.figure(figGeometry.nr) \n        cfv.clf()\n        cfv.draw_geometry(self.rect.geometry(), title=""Geometry"")\n        \n    def drawMesh(self, figMesh):\n        """"""Draw mesh in provided figure""""""\n        cfv.figure(figMesh.nr)\n        cfv.clf()\n        cfv.draw_mesh(self.mesh.coords, self.mesh.edof, self.rect.dofsPerNode, self.rect.elementType, \n                     filled=True, title=""Mesh"") #Draws the mesh.\n        \n    def drawDisplacements(self, figDisplacements):\n        """"""Draw displacements in provided figure""""""\n        cfv.figure(figDisplacements.nr)\n        cfv.clf()\n        cfv.draw_displacements(self.results.a, self.mesh.coords, self.mesh.edof, self.rect.dofsPerNode, self.rect.elementType, draw_undisplaced_mesh=False, title=""Displacements"", magnfac=1)\n        \n    def drawElementValues(self, figElementValues):\n        """"""Draw element values in provided figure""""""\n        cfv.figure(figElementValues.nr)\n        cfv.clf()\n        cfv.draw_element_values(self.results.elForces, self.mesh.coords, self.mesh.edof, self.rect.dofsPerNode, self.rect.elementType, self.results.a, draw_elements=True, draw_undisplaced_mesh=False, title=""Effective Stress"", magnfac=1)\n                      \n\nclass MainWindow(QMainWindow):\n    """"""Main window class of our UI""""""\n    def __init__(self):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()\n\n        # Load user interface from UI-file\n\n        loadUi(\'exmqt11.ui\', self)\n\n        # Query for figure class name\n\n        Figure = cfv.figureClass()\n\n        # Create figure widgets to insert in UI\n\n        self.figGeometry = Figure(self)\n        self.figMesh = Figure(self)\n        self.figElementValues = Figure(self)\n        self.figDisplacements = Figure(self)\n\n        # Insert widgets in gridLayout\n\n        self.middleLayout.addWidget(self.figGeometry._widget, 20)\n        self.middleLayout.addWidget(self.figMesh._widget, 20)\n        self.resultLayout.addWidget(self.figElementValues._widget, 20)\n        self.resultLayout.addWidget(self.figDisplacements._widget, 20)\n        #self.gridLayout.addWidget(self.figElementValues._widget, 0, 1)\n        #self.gridLayout.addWidget(self.figDisplacements._widget, 1, 0)\n\n        # Create our problem instance\n\n        self.problem = PlaneStress2DProblem()\n        self.updateView()\n        \n    def updateView(self):\n        """"""Update controls with values from problem""""""\n        self.lengthEdit.setText(str(self.problem.w))\n        self.heightEdit.setText(str(self.problem.h))\n        self.thicknessEdit.setText(str(self.problem.t))\n        self.elasticModulusEdit.setText(str(self.problem.E))\n        self.youngEdit.setText(str(self.problem.v))\n        self.maxAreaEdit.setText(str(self.problem.maxArea))\n        \n    def updateProblem(self):\n        """"""Update problem with values from controls""""""\n        self.problem.w = float(self.lengthEdit.text())\n        self.problem.h = float(self.heightEdit.text())\n        self.problem.t = float(self.thicknessEdit.text())\n        self.problem.E = float(self.elasticModulusEdit.text())\n        self.problem.v = float(self.youngEdit.text())\n        self.problem.maxArea = float(self.maxAreaEdit.text())\n        \n    @pyqtSlot()\n    def on_updateButton_clicked(self):\n        """"""Update geometry""""""\n\n        self.updateProblem()        \n        self.problem.updateMesh()\n\n        # Draw geometry\n\n        self.problem.drawGeometry(self.figGeometry)\n        \n        # Draw mesh\n        \n        self.problem.drawMesh(self.figMesh)\n        \n    @pyqtSlot(int)\n    def on_tabWidget_currentChanged(self, tabIndex):\n        """"""Handle tab change""""""\n\n        if tabIndex == 1:        \n            \n            # Only calculate when on tab 1 (results)\n       \n            self.updateProblem()        \n            self.problem.updateMesh()\n            self.problem.solve()\n            \n            # Draw geometry\n    \n            self.problem.drawGeometry(self.figGeometry)\n            \n            # Draw mesh\n            \n            self.problem.drawMesh(self.figMesh)\n            \n            # Draw results\n            \n            self.problem.drawElementValues(self.figElementValues)\n            self.problem.drawDisplacements(self.figDisplacements)\n\nif __name__ == ""__main__"":\n\n    app = QApplication(sys.argv)\n    widget = MainWindow()\n    widget.show()\n    sys.exit(app.exec_())\n'"
examples/exmqt6.py,5,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 06\n\nSolves a plane stress 2D problem using a structured mesh.\nShows how to draw von Mises effective stress as an element value with\ndrawElementValues(). Shows use of GmshMesher attribute \'nodesOnCurve\'\n(dictionary that says which nodes are on a given geometry curve)\n\'\'\'\n\nimport sys\nfrom math import sqrt\n\nfrom calfem.qt5 import *\n\nimport numpy as np\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\n\n#cfu.enableLogging()\n\nclass PlaneStress2DProblem(object):\n    """"""Encapsulates our plane stress problem in a single class""""""\n    def __init__(self, t=0.2, v=0.35, E=2.1e9, ptype=1):\n        """"""Setup intial problem values""""""\n        self.t = t\n        self.v = v\n        self.E = E\n        self.ptype = ptype\n\n    def updateGeometry(self):\n        """"""Update geometry""""""\n\n        cfu.info(""Creating geometry..."")\n\n        self.g = cfg.geometry()\n        g = self.g\n\n        # Just a shorthand. We use this to make the circle arcs.\n\n        s2 = 1/sqrt(2)\n\n        points = [[0, 3], [2.5, 3], [3, 3], [4-s2, 3-s2], [4, 2],     #0-4\n                  [4+s2, 3-s2], [5, 3], [5.5, 3], [8, 3], [0, 1.5],    #5-9\n                  [2.5, 1.5], [4, 1.5], [5.5, 1.5], [8, 1.5], [0, 0], #10-14\n                  [2.5, 0], [3, 0], [4-s2, s2], [4, 1], [4+s2, s2],   #15-19\n                  [5, 0], [5.5, 0], [8, 0], [4, 3], [4, 0]]              #20-24\n\n        for xp, yp in points:\n            g.point([xp*0.1, yp*0.1])\n\n        splines = [[0, 1], [1, 2], [6, 7], [7, 8], [8, 13],          #0-4\n                   [13, 22], [22, 21], [21, 20], [16, 15], [15, 14], #5-9\n                   [14, 9], [9, 0], [9, 10], [10, 1], [10, 15],     #10-14\n                   [10, 11], [11, 4], [11, 18], [11, 12], [12, 7],   #15-19\n                   [12, 21], [12, 13], [3, 10], [5, 12], [10, 17],   #20-24\n                   [12, 19]]                                     #25\n\n        for s in splines:\n            g.spline(s, el_on_curve=5)\n\n        g.curveMarker(ID=4, marker=7) #Assign marker 7 to the splines on the right.\n        g.curveMarker(ID=5, marker=7) # We will apply a force on nodes with marker 7.\n        g.curveMarker(ID=10, marker=5) #Assign marker 5 to the splines on the left.\n        g.curveMarker(ID=11, marker=5) # The nodes with marker 5 will be locked in place.\n\n        # Points in circle arcs are [start, center, end]\n\n        circlearcs = [[2, 23, 3], [3, 23, 4], [4, 23, 5], [5, 23, 6],           #26-29\n                      [16, 24, 17], [17, 24, 18], [18, 24, 19], [19, 24, 20]]   #30-33\n\n        for c in circlearcs:\n            g.circle(c, el_on_curve=5)\n\n        g.structuredSurface([11, 12, 13, 0]) #0\n        g.structuredSurface([14, 12, 10, 9])\n        g.structuredSurface([8, 30, 24, 14])\n        g.structuredSurface([24, 31, 17, 15])\n        g.structuredSurface([15, 16, 27, 22]) #4\n        g.structuredSurface([22, 26, 1, 13])\n        g.structuredSurface([16, 18, 23, 28])\n        g.structuredSurface([19, 2, 29, 23])\n        g.structuredSurface([19, 21, 4, 3]) #8\n        g.structuredSurface([20, 6, 5, 21])\n        g.structuredSurface([25, 20, 7, 33])\n        g.structuredSurface([32, 17, 18, 25]) #11\n\n    def updateMesh(self):\n        """"""Update mesh""""""\n\n        cfu.info(""Meshing geometry..."")\n\n        # 3 Quads\n\n        self.el_type = 3\n        self.dofs_per_node = 2\n\n        # Create mesh\n\n        self.mesh = cfm.GmshMeshGenerator(geometry=self.g)\n        self.mesh.el_type = self.el_type\n        self.mesh.dofs_per_node = self.dofs_per_node\n\n        self.coords, self.edof, self.dofs, self.bdofs, self.elementmarkers = self.mesh.create()\n\n    def solve(self):\n        """"""Solve problem""""""\n\n        self.updateGeometry()\n        self.updateMesh()\n\n        self.ep = [self.ptype, self.t]\n        self.D = cfc.hooke(self.ptype, self.E, self.v)\n\n        cfu.info(""Assembling system matrix..."")\n\n        nDofs = np.size(self.dofs)\n        ex, ey = cfc.coordxtr(self.edof, self.coords, self.dofs)\n        K = np.zeros([nDofs, nDofs])\n\n        for eltopo, elx, ely in zip(self.edof, ex, ey):\n            Ke = cfc.planqe(elx, ely, self.ep, self.D)\n            cfc.assem(eltopo, K, Ke)\n\n        cfu.info(""Solving equation system..."")\n\n        f = np.zeros([nDofs, 1])\n\n        bc = np.array([], \'i\')\n        bcVal = np.array([], \'i\')\n\n        bc, bcVal = cfu.applybc(self.bdofs, bc, bcVal, 5, 0.0, 0)\n\n        cfu.applyforce(self.bdofs, f, 7, 10e5, 1)\n\n        self.a, self.r = cfc.solveq(K, f, bc, bcVal)\n\n        cfu.info(""Computing element forces..."")\n\n        ed = cfc.extractEldisp(self.edof, self.a)\n        self.vonMises = []\n\n        # For each element:\n\n        for i in range(self.edof.shape[0]):\n\n            # Determine element stresses and strains in the element.\n\n            es, et = cfc.planqs(ex[i, :], ey[i, :], self.ep, self.D, ed[i, :])\n\n            # Calc and append effective stress to list.\n\n            self.vonMises.append(sqrt(pow(es[0], 2) - es[0]*es[1] + pow(es[1], 2) + 3*es[2]))\n\n            ## es: [sigx sigy tauxy]\n\n    def drawGeometry(self, figGeometry):\n        """"""Draws geometry in specified figure""""""\n        cfv.figure(figGeometry.nr)\n        cfv.clf()\n        cfv.draw_geometry(self.g, draw_points=False, label_curves=True)\n\n    def drawElementValues(self, figElementValues):\n        """"""Draws element values in specified figure""""""\n        cfv.figure(figElementValues.nr)\n        cfv.clf()\n        cfv.draw_element_values(self.vonMises, self.coords, self.edof,\n                              self.mesh.dofs_per_node, self.mesh.el_type,\n                              self.a, draw_elements=True,\n                              draw_undisplaced_mesh=False,\n                              title=""Example 06 effective stress"")\n\n    def drawDisplacements(self, figDisplacements):\n        """"""Draws displacements in specified figure""""""\n        cfv.figure(figDisplacements.nr)\n        cfv.clf()\n        cfv.draw_displacements(self.a, self.coords, self.edof,\n                              self.mesh.dofs_per_node, self.mesh.el_type,\n                              draw_undisplaced_mesh=True, title=""Example 06"")\n\n        # Make use of attribute \'nodesOnCurve\' in GmshMesher to draw some arrows on\n        # the right hand side of the mesh:\n\n        rightSideNodes = set()\n\n        # 4 and 5 are the IDs of the curves where we applied the forces.\n\n        for curveID in [4, 5]:\n\n            # Get the nodes, without duplicates.\n\n            rightSideNodes = rightSideNodes.union(set(self.mesh.nodesOnCurve[curveID]))\n\n        for i in rightSideNodes:\n\n            # Position of the node with displacements.\n\n            x = self.coords[i, 0] + self.a[i*2, 0]\n            y = self.coords[i, 1] + self.a[i*2+1, 0]\n\n            # A poor man\'s force indicator. Could also use vv.plot()\n\n            cfv.addText(""\\rightarrow"", (x, y), font_size=20, color=\'g\')\n\n\nclass MainWindow(QMainWindow):\n    """"""Main window class of our UI""""""\n    def __init__(self):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()\n\n        # Load user interface from UI-file\n\n        loadUi(\'exmqt6.ui\', self)\n\n        # Query for figure class name\n\n        Figure = cfv.figureClass()\n\n        # Create figure widgets to insert in UI\n\n        self.figGeometry = Figure(self)\n        self.figElementValues = Figure(self)\n        self.figDisplacements = Figure(self)\n\n        # Insert widgets in gridLayout\n\n        self.gridLayout.addWidget(self.figGeometry._widget, 0, 0)\n        self.gridLayout.addWidget(self.figElementValues._widget, 0, 1)\n        self.gridLayout.addWidget(self.figDisplacements._widget, 1, 0)\n\n        # Create our problem instance\n\n        self.problem = PlaneStress2DProblem()\n\n    @pyqtSlot()\n    def on_executeButton_clicked(self):\n        """"""Execute calculation""""""\n\n        # Solve problem\n\n        self.problem.solve()\n\n        # Draw results\n\n        self.problem.drawGeometry(self.figGeometry)\n        self.problem.drawElementValues(self.figElementValues)\n        self.problem.drawDisplacements(self.figDisplacements)\n\n\nif __name__ == ""__main__"":\n\n    app = QApplication(sys.argv)\n    widget = MainWindow()\n    widget.show()\n    sys.exit(app.exec_())\n'"
examples/exs1.py,4,"b'# example exs1 \n# ----------------------------------------------------------------\n# PURPOSE \n#     Linear elastic spring analysis. Introduction to the basic \n#     steps in the finite element method.\n# ----------------------------------------------------------------\n\n# REFERENCES\n#     P-E Austrell 1994-03-08 \n#     K-G Olsson 1995-09-28\n#     O Dahlblom 2004-09-06\n#     J Lindemann 2009-01-25\n# ----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\n\n# ----- Topology matrix Edof -------------------------------------\n\nEdof = np.array([\n    [1,2],\n    [2,3],\n    [2,3]\n])\n\n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.matrix(np.zeros((3,3)))\nf = np.matrix(np.zeros((3,1)))\n\n# ----- Element stiffness matrices  ------------------------------\n\nk = 1500.\nep1 = k\nep2 = 2.*k\nKe1 = cfc.spring1e(ep1)\nKe2 = cfc.spring1e(ep2)\n\n# ----- Assemble Ke into K ---------------------------------------\n\ncfc.assem(Edof[0,:], K, Ke2)\ncfc.assem(Edof[1,:], K, Ke1)\ncfc.assem(Edof[2,:], K, Ke2)\n\nprint(""Stiffness matrix K:"")\nprint(K)\n\n# ----- Solve the system of equations ----------------------------\n\nbc = np.array([1,3])\nf[1]=100\n\na, r = cfc.solveq(K, f, bc)\n\nprint(""Displacements a:"")\nprint(a)\n\nprint(""Reaction forces Q:"")\nprint(r)\n\n# ----- Element forces -------------------------------------------\n\ned1 = cfc.extractEldisp(Edof[0,:],a)\ned2 = cfc.extractEldisp(Edof[1,:],a)\ned3 = cfc.extractEldisp(Edof[2,:],a)\n\nes1 = cfc.spring1s(ep2,ed1)\nes2 = cfc.spring1s(ep1,ed2)\nes3 = cfc.spring1s(ep2,ed3)\n\nprint(""N1 = ""+str(es1))\nprint(""N2 = ""+str(es2))\nprint(""N3 = ""+str(es3))\n\n\n'"
examples/exs2.py,5,"b'# example exs2 \n# ----------------------------------------------------------------\n# PURPOSE \n#    Analysis of one dimensional heat flow.\n# ----------------------------------------------------------------\n\n# REFERENCES\n#     P-E Austrell 1994-03-08 \n#     K-G Olsson 1995-09-28\n#     O Dahlblom 2004-09-07\n#     J Lindemann 2009-01-25\n# ----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\n \n# ----- Topology matrix Edof -------------------------------------\n\nEdof = np.array([\n    [1,2],\n    [2,3],\n    [3,4],\n    [4,5],\n    [5,6]\n])\n\n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.mat(np.zeros((6,6)))\nf = np.mat(np.zeros((6,1)))\nf[3] = 10.0\n\n# ----- Element properties ---------------------------------------\n\nep1 = 25.0\nep2 = 24.3\nep3 = 0.4\nep4 = 17.0\nep5 = 7.7\n \n# ----- Element stiffness matrices  ------------------------------\n\nKe1 = cfc.spring1e(ep1)\nKe2 = cfc.spring1e(ep2)\nKe3 = cfc.spring1e(ep3)\nKe4 = cfc.spring1e(ep4)\nKe5 = cfc.spring1e(ep5)\n \n# ---- Assemble Ke into K ---------------------------------------\n\ncfc.assem(Edof[0,:], K, Ke1)\ncfc.assem(Edof[1,:], K, Ke2) \ncfc.assem(Edof[2,:], K, Ke3)\ncfc.assem(Edof[3,:], K, Ke4)\ncfc.assem(Edof[4,:], K, Ke5)\n\nprint(""Stiffness matrix K:"")\nprint(K)\n \n# ----- Solve the system of equations ----------------------------\n\nbc = np.array([1,6])\nbcVal = np.array([-17.0, 20.0])\na,r = cfc.solveq(K, f, bc, bcVal)\n\nprint(""Displacements a:"")\nprint(a)\n\nprint(""Reaction forces r:"")\nprint(r)\n\n# ----- Element flows -------------------------------------------\n\ned1 = cfc.extractEldisp(Edof[0,:], a)\ned2 = cfc.extractEldisp(Edof[1,:], a)\ned3 = cfc.extractEldisp(Edof[2,:], a)\ned4 = cfc.extractEldisp(Edof[3,:], a)\ned5 = cfc.extractEldisp(Edof[4,:], a)\n\nq1 = cfc.spring1s(ep1, ed1)\nq2 = cfc.spring1s(ep2, ed2)\nq3 = cfc.spring1s(ep3, ed3)\nq4 = cfc.spring1s(ep4, ed4)\nq5 = cfc.spring1s(ep5, ed5)\n\nprint(""q1 = ""+str(q1))\nprint(""q2 = ""+str(q2))\nprint(""q3 = ""+str(q3))\nprint(""q4 = ""+str(q4))\nprint(""q5 = ""+str(q5))\n'"
examples/exs3.py,10,"b'# example exs3 \n# ----------------------------------------------------------------\n# PURPOSE \n#    Analysis of a plane truss.\n# ----------------------------------------------------------------\n\n# REFERENCES\n#     Ola Dahlblom 2004-09-07\n#     Jonas Lindemann 2009-01-25\n# ----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\n\n# ----- Topology matrix Edof -------------------------------------\n\nEdof = np.array([\n    [1,2,5,6],\n    [5,6,7,8],\n    [3,4,5,6]\n])\n\n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.matrix(np.zeros((8,8)))\nf = np.matrix(np.zeros((8,1)))\n\n# ----- Element properties ---------------------------------------\n \nE = 2.0e11\nA1 = 6.0e-4\nA2 = 3.0e-4\nA3 = 10.0e-4\nep1 = [E,A1]\nep2 = [E,A2]\nep3 = [E,A3]\n \n#----- Element coordinates --------------------------------------\n\nex1 = np.array([0., 1.6])\nex2 = np.array([1.6, 1.6])\nex3 = np.array([0., 1.6])\n\ney1 = np.array([0., 0.])\ney2 = np.array([0., 1.2])\ney3 = np.array([1.2, 0.])\n \n#----- Element stiffness matrices  ------------------------------\n\nKe1 = cfc.bar2e(ex1,ey1,ep1)\t \nKe2 = cfc.bar2e(ex2,ey2,ep2)\nKe3 = cfc.bar2e(ex3,ey3,ep3)\t\n \n#----- Assemble Ke into K ---------------------------------------\n\ncfc.assem(Edof[0,:],K,Ke1)\ncfc.assem(Edof[1,:],K,Ke2)\ncfc.assem(Edof[2,:],K,Ke3)\n\nprint(""Stiffness matrix K:"")\nprint(K)\n \n#----- Solve the system of equations ----------------------------\n\nbc = np.array([1,2,3,4,7,8])\nf[5] = -80e3\na, r = cfc.solveq(K,f,bc)\n\nprint(""Displacements a:"")\nprint(a)\n\nprint(""Reaction forces r:"")\nprint(r)\n\n#----- Element forces -------------------------------------------\n\ned1 = cfc.extractEldisp(Edof[0,:],a);\nN1 = cfc.bar2s(ex1,ey1,ep1,ed1)\ned2 = cfc.extractEldisp(Edof[1,:],a);\nN2 = cfc.bar2s(ex2,ey2,ep2,ed2)\ned3 = cfc.extractEldisp(Edof[2,:],a);\t\nN3 = cfc.bar2s(ex3,ey3,ep3,ed3)\n\nprint(""N1 = ""+str(N1))\nprint(""N2 = ""+str(N2))\nprint(""N3 = ""+str(N3))\n \n'"
examples/exs4a.py,9,"b'# example exs4a \n# ----------------------------------------------------------------\n# PURPOSE \n#    Analysis of a plane truss using loops.\n# ----------------------------------------------------------------\n\n# REFERENCES\n#     P-E Austrell 1994-03-08 \n#     K-G Olsson 1995-09-28\n#     O Dahlblom 2004-08-31\n#     J Lindemann 2009-01-25\n# ----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\n\n# ----- Topology matrix Edof -------------------------------------\n\nEdof = np.array([\n    [1, 2, 5, 6],\n    [3, 4, 7, 8],\n    [5, 6, 9, 10],\n    [7, 8, 11, 12],\n    [7, 8, 5, 6],\n    [11, 12, 9, 10],\n    [3, 4, 5, 6],\n    [7, 8, 9, 10],\n    [1, 2, 7, 8],\n    [5, 6, 11, 12]\n])\n \n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.zeros([12,12])\nf = np.zeros([12,1])\nf[10] = 0.5e6*np.sin(np.pi/6)\nf[11] = -0.5e6*np.cos(np.pi/6)\n\n# ----- Element properties ---------------------------------------\n\nA = 25.0e-4\nE = 2.1e11\nep = [E,A]\n\n# ----- Element coordinates --------------------------------------\n\nex = np.array([\n    [0., 2.],\n    [0., 2.],\n    [2., 4.],\n    [2., 4.],\n    [2., 2.],\n    [4., 4.],\n    [0., 2.],\n    [2., 4.],\n    [0., 2.],\n    [2., 4.]\n])\n\ney = np.array([\n    [2., 2.],\n    [0., 0.],\n    [2., 2.],\n    [0., 0.],\n    [0., 2.],\n    [0., 2.],\n    [0., 2.],\n    [0., 2.],\n    [2., 0.],\n    [2., 0.]\n])\n \n# ----- Create element stiffness matrices Ke and assemble into K -\n\nfor elx, ely, eltopo in zip(ex, ey, Edof):\n    Ke = cfc.bar2e(elx, ely,ep)\n    cfc.assem(eltopo,K,Ke)\n   \nprint(""Stiffness matrix K:"")\nprint(K)\n\n# ----- Solve the system of equations ----------------------------\n\nbc = np.array([1,2,3,4])\na, r = cfc.solveq(K,f,bc)\n\nprint(""Displacements a:"")\nprint(a)\n\nprint(""Reaction forces r:"")\nprint(r)\n\n# ----- Element forces -------------------------------------------\n\ned = cfc.extractEldisp(Edof,a);\nN = np.zeros([Edof.shape[0]])\n\nprint(""Element forces:"")\n\ni = 0\nfor elx, ely, eld in zip(ex, ey, ed):\n    N[i] = cfc.bar2s(elx,ely,ep,eld);\n    print(""N%d = %g"" % (i+1,N[i]))\n    i+=1\n \n'"
examples/exs5.py,7,"b'# example exs5\n# ----------------------------------------------------------------\n# PURPOSE \n#    Analysis of a simply supported beam.\n# ----------------------------------------------------------------\n\n# REFERENCES\n#     G""oran Sandberg 94-03-08 \n#     Karl-Gunnar Olsson 95-09-28\n#     Ola Dahlblom 2004-09-21\n# ----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\n\n# ----- Topology -------------------------------------------------\n\nEdof = np.array([\n    [1, 2, 3, 4, 5, 6],\n    [4, 5, 6, 7, 8, 9],\n    [7, 8, 9, 10, 11, 12]\n])\n\n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.mat(np.zeros((12,12)))\nf = np.mat(np.zeros((12,1)))\nf[4] = -10000.\n\n# ----- Element stiffness matrices  ------------------------------\n\nE = 2.1e11\nA = 45.3e-4\nI = 2510e-8\nep = np.array([E,A,I])\nex = np.array([0.,3.])\ney = np.array([0.,0.])\n\nKe = cfc.beam2e(ex,ey,ep)\n\nprint(Ke)\n\n# ----- Assemble Ke into K ---------------------------------------\n\nK = cfc.assem(Edof,K,Ke);\n\n# ----- Solve the system of equations and compute support forces -\n\nbc = np.array([1,2,11])\n(a,r) = cfc.solveq(K,f,bc);\n\n# ----- Section forces -------------------------------------------\n\nEd=cfc.extractEldisp(Edof,a);\n\nes1, ed1, ec1 = cfc.beam2s(ex, ey, ep, Ed[0,:], nep=10)\nes2, ed2, ec2 = cfc.beam2s(ex, ey, ep, Ed[1,:], nep=10)\nes3, ed3, ec3 = cfc.beam2s(ex, ey, ep, Ed[2,:], nep=10)\n\n# ----- Results --------------------------------------------------\n\nprint(""a="")\nprint(a)\nprint(""r="")\nprint(r)\nprint(""es1="")\nprint(es1)\nprint(""es2="")\nprint(es2)\nprint(""es3="")\nprint(es3)\n\nprint(""ed1="")\nprint(ed1)\nprint(""ed2="")\nprint(ed2)\nprint(""ed3="")\nprint(ed3)'"
examples/exs6.py,17,"b'# example exs6 \n#----------------------------------------------------------------\n# PURPOSE \n#    Analysis of a plane frame.\n#----------------------------------------------------------------\n\n# REFERENCES\n#     G""oran Sandberg 94-03-08 \n#     Karl-Gunnar Olsson 95-09-28\n#     Anders Olsson 99-03-01\n#     Ola Dahlblom 2004-09-14\n#----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.core as cfc\nimport calfem.utils as cfu\nimport calfem.vis_mpl as cfv\n\n# ----- Topology -------------------------------------------------\n\nEdof = np.array([\n    [4,  5,  6, 1,  2,  3],\n    [7,  8,  9, 10, 11, 12],\n    [4,  5,  6,  7,  8,  9]      \n])\n\n# ----- Stiffness matrix K and load vector f ---------------------\n\nK = np.matrix(np.zeros((12,12)))\nf = np.matrix(np.zeros((12,1)))\nf[3] = 2e+3\n\n# ----- Element stiffness and element load matrices  -------------\n\nE = 200e9\nA1 = 2e-3\nA2 = 6e-3\nI1 = 1.6e-5\nI2 = 5.4e-5\n\nep1 = np.array([E, A1, I1])\nep3 = np.array([E, A2, I2])\nex1 = np.array([0, 0])\nex2 = np.array([6, 6])\nex3 = np.array([0, 6])\ney1 = np.array([4, 0])\ney2 = np.array([4, 0])\ney3 = np.array([4, 4])\neq1 = np.array([0, 0])\neq2 = np.array([0, 0])\neq3 = np.array([0, -10e+3])\n\nKe1 = cfc.beam2e(ex1, ey1, ep1)\nKe2 = cfc.beam2e(ex2, ey2, ep1)\nKe3, fe3 = cfc.beam2e(ex3, ey3, ep3, eq3)\n\n# ----- Assemble Ke into K ---------------------------------------\n\ncfc.assem(Edof[0,:], K, Ke1);\ncfc.assem(Edof[1,:], K, Ke2);\ncfc.assem(Edof[2,:], K, Ke3, f, fe3);\n\n# ----- Solve the system of equations and compute reactions ------\n\nbc = np.array([1,2,3,10,11])\na, r = cfc.solveq(K,f,bc)\n\nprint(""a = "")\nprint(a)\nprint(""r = "")\nprint(r)\n\n# ----- Section forces -------------------------------------------\n\nEd = cfc.extractEldisp(Edof,a);\n\nes1, ed1, ec1 = cfc.beam2s(ex1, ey1, ep1, Ed[0,:], eq1, nep=21)\nes2, ed2, ec2 = cfc.beam2s(ex2, ey2, ep1, Ed[1,:], eq2, nep=21)\nes3, ed3, ec3 = cfc.beam2s(ex3, ey3, ep3, Ed[2,:], eq3, nep=21)\n\nprint(""es1 = "")\nprint(es1)\nprint(""es2 = "")\nprint(es2)\nprint(""es3 = "")\nprint(es3)\n\n# ----- Draw deformed frame ---------------------------------------\n\nex = np.array([\n    ex1, ex2, ex3\n])\nprint(ex)\n\ney = np.array([\n    ey1, ey2, ey3\n])\nprint(ey)\n\ncfv.eldraw2(ex, ey)\n#cfv.eldisp2(ex, ey, Ed)\ncfv.showAndWait()\n\n#figure(1)\n#plotpar=[2 1 0];\n#eldraw2(ex1,ey1,plotpar);\n#eldraw2(ex2,ey2,plotpar);\n#eldraw2(ex3,ey3,plotpar);\n#sfac=scalfact2(ex3,ey3,Ed(3,:),0.1);\n#plotpar=[1 2 1];\n#eldisp2(ex1,ey1,Ed(1,:),plotpar,sfac);\n#eldisp2(ex2,ey2,Ed(2,:),plotpar,sfac);\n#eldisp2(ex3,ey3,Ed(3,:),plotpar,sfac);\n#axis([-1.5 7.5 -0.5 5.5]); \n#pltscalb2(sfac,[1e-2 0.5 0]);\n#axis([-1.5 7.5 -0.5 5.5]);\n#title(\'displacements\')\n \n#----- Draw normal force diagram --------------------------------\n \n#figure(2)\n#plotpar=[2 1];\n#sfac=scalfact2(ex1,ey1,es1(:,1),0.2);\n#eldia2(ex1,ey1,es1(:,1),plotpar,sfac);\n#eldia2(ex2,ey2,es2(:,1),plotpar,sfac);\n#eldia2(ex3,ey3,es3(:,1),plotpar,sfac);\n#axis([-1.5 7.5 -0.5 5.5]);\n#pltscalb2(sfac,[3e4 1.5 0]);\n#title(\'normal force\')\n\n#----- Draw shear force diagram ---------------------------------\n \n#figure(3)\n#plotpar=[2 1];\n#sfac=scalfact2(ex3,ey3,es3(:,2),0.2);\n#eldia2(ex1,ey1,es1(:,2),plotpar,sfac);\n#eldia2(ex2,ey2,es2(:,2),plotpar,sfac);\n#eldia2(ex3,ey3,es3(:,2),plotpar,sfac);\n#axis([-1.5 7.5 -0.5 5.5]);\n#pltscalb2(sfac,[3e4 0.5 0]);\n#title(\'shear force\') \n\n#----- Draw moment diagram --------------------------------------\n \n#figure(4)\n#plotpar=[2 1];\n#sfac=scalfact2(ex3,ey3,es3(:,3),0.2);\n#eldia2(ex1,ey1,es1(:,3),plotpar,sfac);\n#eldia2(ex2,ey2,es2(:,3),plotpar,sfac);\n#eldia2(ex3,ey3,es3(:,3),plotpar,sfac);\n#axis([-1.5 7.5 -0.5 5.5]);\n#pltscalb2(sfac,[3e4 0.5 0]);\n#title(\'moment\') \n\n'"
examples/exs8.py,10,"b""# -*- coding: utf-8 -*-\n\n# example exs8\n#----------------------------------------------------------------\n# PURPOSE \n#    Analysis of two dimensional diffusion\n#----------------------------------------------------------------\n\n# REFERENCES\n#     Karl-Gunnar Olsson 1995-10-08\n#     Ola Dahlblom 2004-09-14\n#----------------------------------------------------------------\n\nimport numpy as np\nimport calfem.vis_mpl as cfv\nimport calfem.core as cfc\n\n# ----- System matrices -----\n\nK = np.zeros((15,15))\nf = np.zeros((15,1))\nCoord = np.array([\n    [0,     0    ],[0.025, 0    ],\n    [0.05,  0    ],[0,     0.025],\n    [0.025, 0.025],[0.05,  0.025],\n    [0,     0.05 ],[0.025, 0.05 ],\n    [0.05,  0.05 ],[0,     0.075],\n    [0.025, 0.075],[0.05,  0.075],\n    [0,     0.1  ],[0.025, 0.1  ],\n    [0.05,  0.1  ]\n])\n\nDof = np.array([\n    [1 ],[2 ],[3 ],\n    [4 ],[5 ],[6 ],\n    [7 ],[8 ],[9 ],\n    [10],[11],[12],\n    [13],[14],[15]\n])\n\n# ----- Element properties, topology and coordinates -----\n\nep = np.array([1])\nD = np.array([\n    [1, 0],\n    [0, 1]\n])\nEdof = np.array([\n    [ 1, 2, 5, 4],\n    [ 2, 3, 6, 5],\n    [ 4, 5, 8, 7],\n    [ 5, 6, 9, 8],\n    [ 7, 8,11,10],\n    [ 8, 9,12,11],\n    [10,11,14,13],\n    [11,12,15,14],\n])\nEx,Ey = cfc.coordxtr(Edof,Coord,Dof)\n\n# ----- Generate FE-mesh -----\n\n#clf; eldraw2(Ex,Ey,[1 3 0],Edof(:,1));\n#disp('PRESS ENTER TO CONTINUE'); pause; clf;\n\n# ----- Create and assemble element matrices -----\n\nfor i in range(8):\n    Ke = cfc.flw2qe(Ex[i],Ey[i],ep,D)\n    K = cfc.assem(Edof[i],K,Ke)\n\n# ----- Solve equation system -----\n\nbcPrescr = np.array([1,2,3,4,7,10,13,14,15])\nbcVal = np.array([0,0,0,0,0,0,0.5e-3,1e-3,1e-3])\na,r = cfc.solveq(K,f,bcPrescr,bcVal)\n\n# ----- Compute element flux vector -----\n\nEd = cfc.extractEldisp(Edof,a)\nEs = np.zeros((8,2))\nfor i in range(8):\n    Es[i],Et = cfc.flw2qs(Ex[i],Ey[i],ep,D,Ed[i])\n\n# ----- Draw flux vectors and contourlines -----\n\nprint(Ex)\nprint(Ey)\nprint(a)\nprint(Ed)\n\ncfv.eldraw2(Ex, Ey, [1, 2, 1], range(1,Ex.shape[0]+1))\ncfv.eliso2_mpl(Ex,Ey,Ed);\ncfv.showAndWaitMpl()\n\n#cfv.showAndWait()\n#sfac=scalfact2(Ex,Ey,Es,0.5);\n#eldraw2(Ex,Ey); \n#elflux2(Ex,Ey,Es,[1,4],sfac); \n#pltscalb2(sfac,[2e-2 0.06 0.01],4);\n#disp('PRESS ENTER TO CONTINUE'); pause; clf;\n#eldraw2(Ex,Ey,[1,3,0]); \n#eliso2(Ex,Ey,Ed,5,[1,4]);\n#hold off; \n#echo off;\n\n# ----------------- End --------------------------------\n\n"""
examples/extri1.py,8,"b'#!/bin/env python\n\nimport numpy as np\nimport calfem.core as cfc\nimport calfem.utils as cfu\nimport calfem.vis as cfv\nimport calfem.mesh as cfm\n\n\n# ---- Problem constants\n\nkx = 50\nky = 50\nt = 1.0\nep = [t]\n\nD = np.matrix([\n    [kx, 0.],\n    [0., ky]\n])\n\n# ---- Problem geometry\n\nvertices = np.array([\n    [0.0, 0.0],\n    [200., 0.0],\n    [200., 70.0],\n    [120.0, 70.0],\n    [120.0, 20.0],\n    [80.0, 20.0],\n    [80.0, 70.0],\n    [0.0, 70.0]\n])\n\nsegments = np.array([\n    [0,1,1],\n    [1,2,1],\n    [2,3,2],\n    [3,4,1],\n    [4,5,1],\n    [5,6,1],\n    [6,7,3],\n    [7,0,1]\n])\n\n# ---- Create element mesh\n\nprint(""Creating element mesh..."")\n\ncoords, edof, dofs, bdofs = cfm.trimesh2d(vertices, segments, maxArea=20.0, dofs_per_node=1)\n\n# ---- Assemble system matrix\n\nprint(""Assemblig system matrix..."")\n\nnDofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\nK = np.zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = cfc.flw2te(elx, ely, ep, D)\n    cfc.assem(eltopo, K, Ke)\n\n# ---- Solving equation system\n\nprint(""Solving equation system..."")\n\nf = np.zeros([nDofs,1])\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'i\')\n\nbc, bcVal = cfu.applybc(bdofs,bc,bcVal,2,30.0)\nbc, bcVal = cfu.applybc(bdofs,bc,bcVal,3,0.0)\n\na, r = cfc.solveq(K,f,bc,bcVal)\n\n# ---- Compute element forces\n\nprint(""Computing element forces..."")\n\ned = cfc.extractEldisp(edof,a)\nqs, qt = cfc.flw2ts(ex, ey, D, ed)\n\n# ---- Visualise results\n\nprint(""Drawing element mesh..."")\n\ncfv.eliso2(ex,ey,ed)    \ncfv.eldraw2(ex,ey)\ncfv.showAndWait()\n\nprint(""Done."")\n\n\n\n\n'"
examples/extri2.py,0,"b'#!/bin/env python\n\nfrom calfem.core import *\nfrom calfem.utils import *\n\ndef drawCustom(self, width, height):\n    glPushMatrix()\n    glBegin(GL_LINES)\n    glColor(1.0, 0.0, 0.0, 1.0)\n    glVertex(50,50,0)\n    glVertex(100,100,0)\n    glPopMatrix()\n\n# ---- Problem constants\n\nt = 0.1\nv = 0.35\nE = 2.1e9\nptype = 1\nep = [ptype,t]\n\nD=hooke(ptype, E, v)\n\n# ---- Problem geometry\n\nl = 0.2\nw = 0.05\nh = 0.1\n\nvertices = array([\n    [0.0, h],\n    [l, h],\n    [l, 0.0],\n    [l-w, 0.0],\n    [l-w, h-w],\n    [0.0, h-w]\n])\n\nsegments = array([\n    [0,1,1],\n    [1,2,1],\n    [2,3,3],\n    [3,4,1],\n    [4,5,1],\n    [5,0,2]\n])\n\n# ---- Create element mesh\n\nprint(""Creating element mesh..."")\n\ncoords, edof, dofs, bdofs = trimesh2d(vertices, segments, maxArea=0.00005, dofsPerNode=2)\n\n# ---- Assemble system matrix\n\nprint(""Assemblig system matrix..."")\n\nnDofs = size(dofs)\nex, ey = coordxtr(edof, coords, dofs)\n\n#eldraw2(ex,ey)\n\nK = zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = plante(elx, ely, ep, D)\n    assem(eltopo, K, Ke)\n\n# ---- Solving equation system\n\nprint(""Solving equation system..."")\n\nf = zeros([nDofs,1])\n\nbc = array([],\'i\')\nbcVal = array([],\'i\')\n\nbc, bcVal = applybc(bdofs,bc,bcVal,2,0.0)\nbc, bcVal = applybcnode(0, dofs, bc, bcVal, 0.0, 1)\nbc, bcVal = applybcnode(0, dofs, bc, bcVal, 0.0, 2)\nbc, bcVal = applybcnode(5, dofs, bc, bcVal, 0.0, 1)\nbc, bcVal = applybcnode(5, dofs, bc, bcVal, 0.0, 2)\n\napplyforce(bdofs,f,3,-10e3,2)\n            \na,r = solveq(K,f,bc,bcVal)\n\n# ---- Compute element forces\n\nprint(""Computing element forces..."")\n\ned = extractEldisp(edof,a)\nes, et = plants(ex, ey, ep, D, ed)\nev = effmises(es, ptype)\nesnv = stress2nodal(ev, edof)\n\n# ---- Visualise results\n\nprint(""Drawing element mesh..."")\n\neldisp2(ex, ey, ed)\nelval2(ex, ey, ev)\neliso2(ex, ey, esnv)\n\nelementView = ElementView(None, -1, """")\nelementView.ex = ex\nelementView.ey = ey\nelementView.ev = ev\nelementView.showMesh = False\nelementView.showElementValues = True\nelementView.showNodalValues = False\nelementView.drawCustom = drawCustom\nelementView.Show()\n\nwaitDisplay()\n\nprint(""Done."")\n\n\n\n'"
examples/tut1.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sat Mar  3 22:08:29 2018\n\n@author: Jonas Lindemann\n""""""\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ----- Define geometry\n\ng = cfg.Geometry()\n\ng.point([0.0, 0.0]) # point 0\ng.point([5.0, 0.0], marker=20) # point 1\ng.point([2.5, 4.0]) # point 2\n\ng.spline([0, 1]) # line 0\ng.spline([1, 2]) # line 1\ng.spline([2, 0], marker=10) # line 2\n\ng.surface([0, 1, 2])\n\n# ----- Create mesh\n\nmesh = cfm.GmshMesh(g)\n\nmesh.elType = 2 # Degrees of freedom per node.\nmesh.dofsPerNode = 1 # Factor that changes element sizes.\nmesh.elSizeFactor = 0.15\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\nprint(bdofs)\n\ncfv.draw_geometry(g)\n\ncfv.figure() \n\n# ----- Draw the mesh.\n\ncfv.draw_mesh(\n    coords=coords, \n    edof=edof, \n    dofs_per_node=mesh.dofsPerNode, \n    el_type=mesh.elType, \n    filled=True, \n    title=""Example 01""\n    ) \n\ncfv.showAndWait()'"
examples/tut2.py,5,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Sat Mar  3 22:08:29 2018\n\n@author: Jonas Lindemann\n""""""\n\nimport calfem.core as cfc\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\n\nimport numpy as np\nfrom math import *\n\n# ----- Problem parameters\n\nl = 5.0\nh = 1.0\nt = 0.2\n\nv = 0.35\nE = 2.1e9\nptype = 1\nep = [ptype,t]\nD=cfc.hooke(ptype, E, v)\n\nleft_support = 10\nright_support = 20\ntop_line = 30\n\n# ----- Define geometry\n\ng = cfg.Geometry()\n\ng.point([0.0, 0.0], marker = left_support) # point 0\ng.point([l, 0.0], marker = right_support) # point 1\ng.point([l, h]) # point 2\ng.point([0.0, h]) # point 2\n\ng.spline([0, 1]) # line 0\ng.spline([1, 2]) # line 1\ng.spline([2, 3], marker = top_line) # line 2\ng.spline([3, 0]) # line 2\n\ng.surface([0, 1, 2, 3])\n\n# ----- Create mesh\n\nmesh = cfm.GmshMesh(g)\n\nmesh.elType = 3 # Degrees of freedom per node.\nmesh.dofsPerNode = 2 # Factor that changes element sizes.\nmesh.elSizeFactor = 0.10\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ----- Solve problem\n\nnDofs = np.size(dofs)\nex, ey = cfc.coordxtr(edof, coords, dofs)\n\nK = np.zeros([nDofs,nDofs])\n\nfor eltopo, elx, ely in zip(edof, ex, ey):\n    Ke = cfc.planqe(elx, ely, ep, D)\n    cfc.assem(eltopo, K, Ke)\n\nbc = np.array([],\'i\')\nbcVal = np.array([],\'f\')\n\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, left_support, 0.0, 0)\nbc, bcVal = cfu.applybc(bdofs, bc, bcVal, right_support, 0.0, 2)\n\nf = np.zeros([nDofs,1])\n\ncfu.applyforcetotal(bdofs, f, top_line, -10e5, 2)\n\na,r = cfc.solveq(K,f,bc,bcVal)\n\ned = cfc.extractEldisp(edof,a)\nvonMises = []\n\nfor i in range(edof.shape[0]): \n    es, et = cfc.planqs(ex[i,:], ey[i,:], ep, D, ed[i,:]) \n    vonMises.append( sqrt( pow(es[0],2) - es[0]*es[1] + pow(es[1],2) + 3*es[2] ) ) \n    \n# ----- Draw geometry\n\ncfv.draw_geometry(g)\n\n# ----- Draw the mesh.\n\ncfv.figure() \ncfv.draw_mesh(\n    coords=coords, \n    edof=edof, \n    dofs_per_node=mesh.dofsPerNode, \n    el_type=mesh.elType, \n    filled=True, \n    title=""Example 01""\n    ) \n\n# ----- Draw results\n\ncfv.figure()\ncfv.draw_element_values(vonMises, coords, edof, mesh.dofs_per_node, mesh.el_type, a, draw_elements=True, draw_undisplaced_mesh=False, title=""Example 06 effective stress"")\n\ncfv.figure()\ncfv.draw_displacements(a, coords, edof, mesh.dofs_per_node, mesh.el_type, draw_undisplaced_mesh=True, title=""Example 06"", magnfac=10.0)\n\ncfv.showAndWait()'"
old/QtVariant.py,0,"b'# -*- coding: iso-8859-1 -*-\n\nimport sys\nimport os\n\ndefault_variant = \'PySide\'\n\nenv_api = os.environ.get(\'QT_API\', \'pyqt\')\nif \'--pyside\' in sys.argv:\n    variant = \'PySide\'\nelif \'--pyqt4\' in sys.argv:\n    variant = \'PyQt4\'\nelif env_api == \'pyside\':\n    variant = \'PySide\'\nelif env_api == \'pyqt\':\n    variant = \'PyQt4\'\nelse:\n    variant = default_variant\n\nif variant == \'PySide\':\n    from PySide import QtGui, QtCore\n    # This will be passed on to new versions of matplotlib\n    os.environ[\'QT_API\'] = \'pyside\'\n    def QtLoadUI(uifile):\n        from PySide import QtUiTools\n        loader = QtUiTools.QUiLoader()\n        uif = QtCore.QFile(uifile)\n        uif.open(QtCore.QFile.ReadOnly)\n        result = loader.load(uif)\n        uif.close()\n        return result\nelif variant == \'PyQt4\':\n    #import sip\n    api2_classes = [\n            \'QData\', \'QDateTime\', \'QString\', \'QTextStream\',\n            \'QTime\', \'QUrl\', \'QVariant\',\n            ]\n    #for cl in api2_classes:\n    #    sip.setapi(cl, 2)\n    from PyQt4 import QtGui, QtCore\n    QtCore.Signal = QtCore.pyqtSignal\n    QtCore.QString = str\n    os.environ[\'QT_API\'] = \'pyqt\'\n    def QtLoadUI(uifile):\n        from PyQt4 import uic\n        return uic.loadUi(uifile)\nelse:\n    raise ImportError(""Python Variant not specified"")\n\n__all__ = [QtGui, QtCore, QtLoadUI, variant]'"
old/pycalfem.py,0,"b'# -*- coding: iso-8859-15 -*-\n\nfrom numpy import *\n\ndef spring1e(ep):\n    """"""\n    Compute element stiffness matrix for spring element.\n    \n    Parameters:\n    \n        ep = k          spring stiffness or analog quantity\n        \n    Returns:\n    \n        Ke              stiffness matrix, dim(Ke)= 2 x 2\n        \n    """"""\n    k = ep\n    return mat([[k,-k],[-k,k]],\'d\')\n\ndef spring1s(ep,ed):\n    """"""\n    Compute element force in spring element (spring1e).\n    \n    Parameters:\n    \n        ep = k          spring stiffness or analog quantity\n        ed = [u1 u2]    element displacements\n                        u1, u2: nodal displacements\n                        \n    Returns:\n    \n        es              element force [N]\n    """"""\n    k = ep\n    return k*(ed[1]-ed[0]);   \n\ndef bar1e(ep):\n    """"""\n    Compute element stiffness matrix for spring element.\n    \n    Parameters:\n    \n        ep = k          spring stiffness or analog quantity\n        \n    Returns:\n    \n        Ke              stiffness matrix, dim(Ke)= 2 x 2\n    \n    """"""\n    k = ep\n    return mat([[k,-k],[-k,k]],\'d\')\n\ndef bar1s(ep,ed):\n    """"""\n    Compute element force in spring element (spring1e).\n    \n    Parameters:\n    \n        ep = k          spring stiffness or analog quantity\n        ed = [u1 u2]    element displacements\n                        u1, u2: nodal displacements\n                        \n    Returns:\n    \n        es              element force [N]\n    \n    """"""\n    k = ep\n    return k*(ed[1]-ed[0]);   \n\ndef bar2e(ex,ey,ep):\n    """"""\n    Compute the element stiffness matrix for two dimensional bar element.\n    \n    Parameters:\n    \n        ex = [x1 x2]\n        ey = [y1 y2]    element node coordinates\n    \n        ep = [E A]      E: Young\'s modulus\n                        A: Cross section area\n                        \n    Returns:\n    \n        Ke              stiffness matrix, dim(Ke)= 4 x 4\n    \n    """"""\n    E=ep[0]\n    A=ep[1]\n    \n    b = mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = asscalar(sqrt(b.T*b))\n    \n    Kle = mat([[1.,-1.],[-1.,1.]])*E*A/L\n    \n    n = asarray(b.T/L).reshape(2,)\n    \n    G = mat([\n        [n[0],n[1],0.,0.],\n        [0.,0.,n[0],n[1]]\n    ])\n    \n    return G.T*Kle*G\n\ndef bar2g(ex,ey,ep,N):\n    """"""\n    Compute element stiffness matrix for two dimensional geometric\n    nonlinear bar element.\n    \n    Parameters:\n    \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n        \n        ep = [E A]          E: Young\'s modulus\n                            A: Cross sections area\n                            \n        N                   normal force\n        \n    Returns:\n    \n        Ke                  stiffness matrix, dim(Ke) = 4 x 4\n        \n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    \n    n = asarray(b.T/L).reshape(2,)\n\n    G = mat([\n        [ n[0], n[1], 0.,   0.  ],\n        [-n[1], n[0], 0.,   0.  ],\n        [ 0.,   0.,   n[0], n[1]],\n        [ 0.,   0.,  -n[1], n[0]]\n    ])\n    \n    Kle = E*A/L*mat([\n        [ 1, 0,-1, 0],\n        [ 0, 0, 0, 0],\n        [-1, 0, 1, 0],\n        [ 0, 0, 0, 0]\n    ])+N/L*mat([\n        [ 0, 0, 0, 0],\n        [ 0, 1, 0,-1],\n        [ 0, 0, 0, 0],\n        [ 0,-1, 0, 1]\n    ])\n\n    return G.T*Kle*G\n\ndef bar2s(ex,ey,ep,ed):\n    """"""\n    Compute normal force in two dimensional bar element.\n    \n    Parameters:\n    \n        ex = [x1 x2]\n        ey = [y1 y2]        element coordinates\n    \n        ep = [E A]          E : Young\'s modulus\n                            A : Cross section area\n    \n        ed = [u1 u2 u3 u4]  element displacement vector\n        \n    Returns:\n    \n        es                  element force [N]\n    \n    """"""\n    E=ep[0]\n    A=ep[1]\n    \n    b = mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = asscalar(sqrt(b.T*b))\n    \n    Kle = mat([[1.,-1.],[-1.,1.]])*E*A/L\n    \n    n = asarray(b.T/L).reshape(2,) \n    \n    G = mat([\n        [n[0],n[1],0.,0.],\n        [0.,0.,n[0],n[1]]\n    ])\n    \n    u=asmatrix(ed).T\n    N=E*A/L*mat([[-1.,1.]])*G*u\n    return asscalar(N)\n    \ndef bar3e(ex,ey,ez,ep):\n    """"""\n    Compute element stiffness matrix for three dimensional bar element.\n    \n    Parameters:\n    \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n        ez = [z1 z2]\n        \n        ep = [E A]          E: Young\'s modulus\n                            A: Cross sections area\n        \n    Returns:\n    \n        Ke                  stiffness matrix, dim(Ke) = 6 x 6\n        \n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    \n    n = asarray(b.T/L).reshape(3)\n\n    G = mat([\n        [ n[0], n[1], n[2], 0.,   0.,   0.  ],\n        [ 0.,   0.,   0.,   n[0], n[1], n[2]]\n    ])\n    \n    Kle = E*A/L*mat([\n        [ 1,-1],\n        [-1, 1]\n    ])\n\n    return G.T*Kle*G\n\ndef bar3s(ex,ey,ez,ep,ed):\n    """"""\n    Compute normal force in three dimensional bar element.\n    \n    Parameters:\n    \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n        ez = [z1 z2]\n        \n        ep = [E A]          E: Young\'s modulus\n                            A: Cross sections area\n        \n        ed = [u1 ... u6]    element displacements\n        \n    Returns:\n    \n        es = [N]            normal force\n\n    """"""\n    E = ep[0]\n    A = ep[1]\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    \n    n = asarray(b.T/L).reshape(3)\n\n    G = mat([\n        [ n[0], n[1], n[2], 0.  , 0.  , 0.  ],\n        [ 0.  , 0.  , 0.  , n[0], n[1], n[2]]\n    ])\n    \n    Kle = E*A/L*mat([\n        [ 1,-1],\n        [-1, 1]\n    ])\n\n    u = asmatrix(ed).T\n    N = E*A/L*mat([[-1.,1.]])*G*u\n\n    return asscalar(N)\n\ndef beam2e(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n    \n        ep = [E A I]        element properties\n                            E: Young\'s modulus\n                            A: Cross section area\n                            I: Moment of inertia\n    \n        eq = [qx qy]        distributed loads, local directions\n        \n    Returns:\n     \n        Ke                  element stiffness matrix (6 x 6)\n    \n        fe                  element load vector (6 x 1)\n    \n    """"""\n\n    b=mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b.T/L).reshape(2,) \n    \n    E=ep[0]\n    A=ep[1]\n    I=ep[2]\n    \n    qx=0.\n    qy=0.\n    if eq!=None:\n        qx=eq[0]\n        qy=eq[1]\n        \n    Kle = mat([\n        [E*A/L,      0.,          0.,    -E*A/L,    0.,        0.      ],\n        [  0.,    12*E*I/L**3., 6*E*I/L**2.,    0., -12*E*I/L**3., 6*E*I/L**2. ],\n        [  0.,    6*E*I/L**2.,  4*E*I/L,      0., -6*E*I/L**2.,  2*E*I/L   ],\n        [-E*A/L,     0.,          0.,     E*A/L,    0.,        0.      ],\n        [  0.,   -12*E*I/L**3.,-6*E*I/L**2.,    0.,  12*E*I/L**3.,-6*E*I/L**2. ],\n        [  0.,    6*E*I/L**2.,  2*E*I/L,      0.,  -6*E*I/L**2., 4*E*I/L   ]\n    ])\n     \n    fle=L*mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n     \n    G=mat([\n        [ n[0], n[1],  0.,    0.,    0.,   0.],\n        [-n[1], n[0],  0.,    0.,    0.,   0.],\n        [0.,    0.,    1.,    0.,    0.,   0.],\n        [0.,    0.,    0.,   n[0],  n[1],  0.],\n        [0.,    0.,    0.,  -n[1],  n[0],  0.],\n        [0.,    0.,    0.,    0.,    0.,   1.]\n    ])\n    \n    Ke=G.T*Kle*G\n    fe=G.T*fle\n    \n    if eq==None:\n        return Ke\n    else:\n        return Ke,fe\n    \ndef beam2s(ex,ey,ep,ed,eq=None,np=None):\n    """"""\n    Compute section forces in two dimensional beam element (beam2e).\n    \n    Parameters:\n \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n\n        ep = [E A I]        element properties,\n                            E:  Young\'s modulus\n                            A:  cross section area\n                            I:  moment of inertia\n\n        ed = [u1 ... u6]    element displacements\n\n        eq = [qx qy]        distributed loads, local directions \n\n        n                   number of evaluation points ( default=2 )\n        \n    Returns:\n          \n        es = [ N1 V1 M1     section forces, local directions, in \n               N2 V2 M2     n points along the beam, dim(es)= n x 3\n               .........]  \n           \n        edi = [ u1 v1       element displacements, local directions,\n                u2 v2       in n points along the beam, dim(es)= n x 2\n                .......]    \n\n            eci = [ x1      local x-coordinates of the evaluation \n                    x2      points, (x1=0 and xn=L)\n                    ...]\n    \n    """"""\n    EA=ep[0]*ep[1]\n    EI=ep[0]*ep[2]\n    b=mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    \n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b.T/L).reshape(2,)\n    \n    qx=0.\n    qy=0.\n    \n    if eq!=None:\n        qx=eq[0]\n        qy=eq[1] \n      \n    ne=2\n    \n    if np!=None:\n        ne = np\n        \n    C=mat([\n        [0.,   0.,   0.,    1.,   0.,   0.],\n        [0.,   0.,   0.,    0.,   0.,   1.],\n        [0.,   0.,   0.,    0.,   1.,   0.],\n        [L,   0.,   0.,    1.,   0.,   0.],\n        [0.,   L**3, L**2,   0.,   L,    1.],\n        [0., 3*L**2, 2*L,   0.,   1.,   0.]\n    ])\n   \n    G=mat([\n        [ n[0], n[1],  0.,    0.,    0.,   0.],\n        [-n[1], n[0],  0.,    0.,    0.,   0.],\n        [0.,    0.,    1.,    0.,    0.,   0.],\n        [0.,    0.,    0.,   n[0],  n[1],  0.],\n        [0.,    0.,    0.,  -n[1],  n[0],  0.],\n        [0.,    0.,    0.,    0.,    0.,   1.]\n    ])\n    \n    M=ravel(C.I*(G*asmatrix(ed).T-matrix([0., 0., 0., -qx*L**2/(2*EA), qy*L**4/(24*EI), qy*L**3/(6*EI)]).T))\n    A=matrix([M[0],M[3]]).T\n    B=matrix([M[1],M[2],M[4],M[5]]).T\n    \n    x=asmatrix(arange(0.,L+L/(ne-1),L/(ne-1))).T\n    zero=asmatrix(zeros([len(x)])).T\n    one=asmatrix(ones([len(x)])).T\n    \n    u=concatenate((x,one),1)*A-power(x,2)*qx/(2*EA)\n    du=concatenate((one,zero),1)*A-x*qx/EA\n    v=concatenate((power(x,3),power(x,2),x,one),1)*B+power(x,4)*qy/(24*EI)\n    d2v=concatenate((6*x,2*one,zero,zero),1)*B+power(x,2)*qy/(2*EI)\n    d3v=concatenate((6*one,zero,zero,zero),1)*B+x*qy/EI\n    \n    N=EA*du\n    M=EI*d2v\n    V=-EI*d3v\n    edi=concatenate((u,v),1)\n    eci=x\n    es=concatenate((N,V,M),1)\n    \n    return (es,edi,eci)\n\ndef beam2t(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional elastic\n    Timoshenko beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]\n        ey = [y1 y2]        element node coordinates\n    \n        ep = [E G A I ks]   element properties\n                              E: Young\'s modulus\n                              G: Shear modulus\n                              A: Cross section area\n                              I: Moment of inertia\n                             ks: Shear correction factor\n    \n        eq = [qx qy]        distributed loads, local directions\n        \n    Returns:\n     \n        Ke                  element stiffness matrix (6 x 6)\n    \n        fe                  element load vector (6 x 1)\n    \n    """"""\n\n    b = mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b.T/L).reshape(2)\n    \n    E = ep[0]\n    Gm = ep[1]\n    A = ep[2]\n    I = ep[3]\n    ks = ep[4]\n        \n    qx = 0.\n    qy = 0.\n    if eq != None:\n        qx = eq[0]\n        qy = eq[1]\n    \n    m = (12/L**2)*(E*I/(Gm*A*ks))\n    \n    Kle = E/(1+m)*mat([\n        [A*(1+m)/L,      0.,         0.,        -A*(1+m)/L,     0.,          0.      ],\n        [0.,         12*I/L**3., 6*I/L**2.,         0.,    -12*I/L**3., 6*I/L**2.    ],\n        [0.,         6*I/L**2.,  4*I*(1+m/4.)/L,    0.,    -6*I/L**2.,  2*I*(1-m/2)/L],\n        [-A*(1+m)/L,     0.,         0.,         A*(1+m)/L,     0.,          0.      ],\n        [0.,        -12*I/L**3.,-6*I/L**2.,         0.,     12*I/L**3.,-6*I/L**2.    ],\n        [0.,         6*I/L**2.,  2*I*(1-m/2)/L,     0.,    -6*I/L**2.,  4*I*(1+m/4)/L]\n    ])\n\n    fle = L*mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n    \n    G = mat([\n        [ n[0], n[1],  0.,   0.,   0.,   0.],\n        [-n[1], n[0],  0.,   0.,   0.,   0.],\n        [  0.,   0.,   1.,   0.,   0.,   0.],\n        [  0.,   0.,   0.,  n[0], n[1],  0.],\n        [  0.,   0.,   0., -n[1], n[0],  0.],\n        [  0.,   0.,   0.,   0.,   0.,   1.]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef beam2ts(ex,ey,ep,ed,eq=None,np=None):\n    """"""\n    Compute section forces in two dimensional beam element (beam2e).\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]       element node coordinates\n\n        ep = [E,G,A,I,ks]   element properties,\n                              E:  Young\'s modulus\n                              G:  shear modulus\n                              A:  cross section area\n                              I:  moment of inertia\n\n        ed = [u1, ... ,u6]  element displacements\n\n        eq = [qx, qy]       distributed loads, local directions \n\n        n                   number of evaluation points ( default=2 )\n        \n    Returns:\n          \n        es = [[N1,V1,M1],   section forces, local directions, in \n              [N2,V2,M2],   n points along the beam, dim(es)= n x 3\n              ..........]  \n    \n        edi = [[u1,v1,teta1],   element displacements, local directions,\n               [u2,v2,teta2],   and rotation of cross section at\n               .............]   in n points along the beam, dim(es)= n x 2\n    \n    (Note! Rotation of the cross section is not equal to dv/dx for Timoshenko beam element)\n    \n        eci = [[x1],    local x-coordinates of the evaluation \n               [x2],    points, (x1=0 and xn=L)\n               ....]\n    \n    """"""\n    EA = ep[0]*ep[2]\n    EI = ep[0]*ep[3]\n    GAK = ep[1]*ep[2]*ep[4]\n    alfa = EI/GAK\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b.T/L).reshape(2)\n    \n    qx = 0.\n    qy = 0.\n    if eq != None:\n        qx = eq[0]\n        qy = eq[1] \n      \n    ne = 2\n    \n    if np != None:\n        ne = np\n        \n    C = mat([\n        [ 0., 0.,              0.,   1., 0., 0.],\n        [ 0., 0.,              0.,   0., 0., 1.],\n        [ 0., 6*alfa,          0.,   0., 1., 0.],\n        [ L,  0.,              0.,   1., 0., 0.],\n        [ 0., L**3,            L**2, 0., L,  1.],\n        [ 0., 3*(L**2+2*alfa), 2*L,  0., 1., 0.]\n    ])\n   \n    G = mat([\n        [ n[0], n[1], 0., 0.,   0.,   0.],\n        [-n[1], n[0], 0., 0.,   0.,   0.],\n        [ 0.,   0.,   1., 0.,   0.,   0.],\n        [ 0.,   0.,   0., n[0], n[1], 0.],\n        [ 0.,   0.,   0.,-n[1], n[0], 0.],\n        [ 0.,   0.,   0., 0.,   0.,   1.]\n    ])\n    \n    M = ravel(C.I*(G*asmatrix(ed).T-mat([0., 0., 0., -qx*L**2/(2*EA), qy*L**4/(24*EI)-qy*L**2/(2*GAK), qy*L**3/(6*EI)]).T))\n    C2 = mat([M[0], M[3]]).T\n    C4 = mat([M[1], M[2], M[4], M[5]]).T\n    \n    x = asmatrix(arange(0., L+L/(ne-1), L/(ne-1))).T\n    zero = asmatrix(zeros([len(x)])).T\n    one = asmatrix(ones([len(x)])).T\n    \n    u = concatenate((x,one),1)*C2-qx/(2*EA)*power(x,2)\n    du = concatenate((one,zero),1)*C2-qx*x/EA\n    \n    v = concatenate((power(x,3),power(x,2),x,one),1)*C4+qy/(24*EI)*power(x,4)-qy/(2*GAK)*power(x,2)\n    dv = concatenate((3*power(x,2),2*x,one,zero),1)*C4+qy*power(x,3)/(6*EI)-qy*x/GAK\n    \n    teta = concatenate((3*(power(x,2)+2*alfa*one),2*x,one,zero),1)*C4+qy*power(x,3)/(6*EI)\n    dteta = concatenate((6*x,2*one,zero,zero),1)*C4+qy*power(x,2)/(2*EI)\n    \n    N = EA*du\n    M = EI*dteta\n    V = GAK*(dv-teta)\n    \n    es = concatenate((N,V,M),1)\n    edi = concatenate((u,v,teta),1)\n    eci = x\n\n    if np != None:\n        return es,edi,eci\n    else:\n        return es\n\ndef beam2w(ex,ey,ep,eq=None):\n    """"""\n    Compute the stiffness matrix for a two dimensional beam element\n    on elastic foundation.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]       element node coordinates\n\n        ep = [E,A,I,ka,kt]  element properties,\n                              E:  Young\'s modulus\n                              A:  cross section area\n                              I:  moment of inertia\n                             ka:  axial foundation stiffness\n                             kt:  transversal foundation stiffness\n\n        eq = [qx, qy]       distributed loads, local directions\n\n    Returns:\n\n        Ke                  beam stiffness matrix (6 x 6)\n        \n        fe                  element load vector (6 x 1)\n    """"""\n    b = mat([[ex[1]-ex[0]],[ey[1]-ey[0]]])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b/L).reshape(2)\n    \n    E,A,I,ka,kt = ep\n    \n    qx = 0\n    qy = 0\n    if eq != None:\n        qx,qy = eq\n    \n    K1 = mat([\n        [ E*A/L,  0,           0,         -E*A/L, 0,           0         ],\n        [ 0,      12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,      6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L,  0,           0,          E*A/L, 0,           0         ],\n        [ 0,     -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,      6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n        ])\n    \n    K2 = L/420*mat([\n        [ 140*ka, 0,       0,         70*ka,  0,       0        ],\n        [ 0,      156*kt,  22*kt*L,   0,      54*kt,  -13*kt*L  ],\n        [ 0,      22*kt*L, 4*kt*L**2, 0,      13*kt*L,-3*kt*L**2],\n        [ 70*ka,  0,       0,         140*ka, 0,       0        ],\n        [ 0,      54*kt,   13*kt*L,   0,      156*kt, -22*kt*L  ],\n        [ 0,     -13*kt*L,-3*kt*L**2, 0,     -22*kt*L, 4*kt*L**2]\n    ])\n    \n    Kle = K1+K2\n    fle = L*mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n\n    G = mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq != None:\n        return Ke,fe\n    else:\n        return Ke\n    \ndef beam2ws(ex,ey,ep,ed,eq=None):\n    """"""\n    Compute section forces in a two dimensional beam element\n    on elastic foundation.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I,ka,kt]      element properties,\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n                                 ka:  axial foundation stiffness\n                                 kt:  transversal foundation stiffness\n\n        ed = [u1, ... ,u6]      element displacement vector\n\n        eq = [qx, qy]           distributed loads, local directions\n\n    Returns:\n\n        es = [[N1, V1, M1],\n              [N2, V2, M2]]     element forces, local direction\n    """"""\n    if asmatrix(ed).shape[0] > 1:\n        print(""Only one row is allowed in the ed matrix !!!"")\n        return\n\n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b/L).reshape(2,)\n    \n    E,A,I,ka,kt = ep\n    \n    qx = 0\n    qy = 0\n    if eq != None:\n        qx,qy = eq\n    \n    K1 = mat([\n        [ E*A/L, 0,           0,         -E*A/L, 0,           0         ],\n        [ 0,     12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L, 0,           0,          E*A/L, 0,           0         ],\n        [ 0,    -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n        ])\n    \n    K2 = L/420*mat([\n        [ 140*ka, 0,       0,         70*ka,  0,       0        ],\n        [ 0,      156*kt,  22*kt*L,   0,      54*kt,  -13*kt*L  ],\n        [ 0,      22*kt*L, 4*kt*L**2, 0,      13*kt*L,-3*kt*L**2],\n        [ 70*ka,  0,       0,         140*ka, 0,       0        ],\n        [ 0,      54*kt,   13*kt*L,   0,      156*kt, -22*kt*L  ],\n        [ 0,     -13*kt*L,-3*kt*L**2, 0,     -22*kt*L, 4*kt*L**2]\n    ])\n    \n    Kle = K1+K2\n    fle = L*mat([qx/2, qy/2, qy*L/12, qx/2, qy/2, -qy*L/12]).T\n    \n    G = mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n\n    P = Kle*G*asmatrix(ed).T-fle\n\n    es = mat([\n        [-P[0,0],-P[1,0],-P[2,0]],\n        [ P[3,0], P[4,0], P[5,0]]\n    ])\n    \n    return es\n\ndef beam2g(ex,ey,ep,N,eq=None):\n    """"""\n    Compute the element stiffness matrix for a two dimensional\n    beam element with respect to geometric nonlinearity.\n    \n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I]            element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n\n        N                       axial force in the beam\n\n        eq                      distributed transverse load\n\n    Returns:\n\n        Ke                      element stiffness matrix (6 x 6)\n        \n        fe                      element load vector (6 x 1)\n    """"""\n    if eq != None:\n        if size(eq) > 1:\n            print(""eq should be a scalar !!!"")\n            return\n        else:\n            q = eq[0]\n    else:\n        q = 0\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b/L).reshape(2,)\n    \n    E,A,I = ep\n    \n    rho = -N*L**2/(pi**2*E*I)\n    \n    kL = pi*sqrt(abs(rho))+finfo(float).eps\n\n    if rho > 0:\n        f1 = (kL/2)/tan(kL/2)\n        f2 = (1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = 6*(2/kL**2-(1+cos(kL))/(kL*sin(kL)))\n    elif rho < 0:\n        f1 = (kL/2)/tanh(kL/2)\n        f2 = -(1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = -6*(2/kL**2-(1+cosh(kL))/(kL*sinh(kL)))\n    else:\n        f1 = f2 = f3 = f4 = f5 = h = 1\n\n    Kle = mat([\n        [ E*A/L, 0.,              0.,            -E*A/L, 0.,              0.            ],\n        [ 0.,    12*E*I*f5/L**3., 6*E*I*f2/L**2., 0.,   -12*E*I*f5/L**3., 6*E*I*f2/L**2.],\n        [ 0.,    6*E*I*f2/L**2.,  4*E*I*f3/L,     0.,   -6*E*I*f2/L**2.,  2*E*I*f4/L    ],\n        [-E*A/L, 0.,              0.,             E*A/L, 0.,              0.            ],\n        [ 0.,   -12*E*I*f5/L**3.,-6*E*I*f2/L**2., 0.,    12*E*I*f5/L**3.,-6*E*I*f2/L**2.],\n        [ 0.,    6*E*I*f2/L**2.,  2*E*I*f4/L,     0.,   -6*E*I*f2/L**2.,  4*E*I*f3/L    ]\n    ])\n\n    fle = q*L*mat([0.,1/2.,L*h/12,0.,1/2.,-L*h/12]).T\n    \n    G = mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n\n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq != None:\n        return Ke,fe\n    else:\n        return Ke\n    \ndef beam2gs(ex,ey,ep,ed,N,eq=None):\n    """"""\n    Calculate section forces in a two dimensional nonlinear\n    beam element.\n\n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I]            element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n\n        ed = [u1, ... ,u6]      element displacement vector\n\n        N                       axial force\n\n        eq = [qy]               distributed transverse load\n\n    Returns:\n\n        es = [[N1,V1,M1],       element forces, local directions\n              [N2,V2,M2]]\n    """"""\n    if eq != None:\n        eq = eq[0]\n    else:\n        eq = 0\n    \n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b/L).reshape(2,)\n    \n    E,A,I = ep\n    \n    rho = -N*L**2/(pi**2*E*I)\n    \n    eps = 2.2204e-16\n    kL = pi*sqrt(abs(rho))+eps\n\n    if rho > 0:\n        f1 = (kL/2)/tan(kL/2)\n        f2 = (1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = 6*(2/kL**2-(1+cos(kL))/(kL*sin(kL)))\n    elif rho < 0:\n        f1 = (kL/2)/tanh(kL/2)\n        f2 = -(1/12.)*kL**2/(1-f1)\n        f3 = f1/4+3*f2/4\n        f4 = -f1/2+3*f2/2\n        f5 = f1*f2\n        h = -6*(2/kL**2-(1+cosh(kL))/(kL*sinh(kL)))\n    else:\n        f1 = f2 = f3 = f4 = f5 = h = 1\n    \n    Kle = mat([\n        [ E*A/L, 0,              0,            -E*A/L, 0,              0            ],\n        [ 0,     12*E*I*f5/L**3, 6*E*I*f2/L**2, 0,    -12*E*I*f5/L**3, 6*E*I*f2/L**2],\n        [ 0,     6*E*I*f2/L**2,  4*E*I*f3/L,    0,    -6*E*I*f2/L**2,  2*E*I*f4/L   ],\n        [-E*A/L, 0,              0,             E*A/L, 0,              0            ],\n        [ 0,    -12*E*I*f5/L**3,-6*E*I*f2/L**2, 0,     12*E*I*f5/L**3,-6*E*I*f2/L**2],\n        [ 0,     6*E*I*f2/L**2,  2*E*I*f4/L,    0,    -6*E*I*f2/L**2,  4*E*I*f3/L   ]\n    ])\n\n    fle = eq*L*mat([0,1/2.,L*h/12,0,1/2.,-L*h/12]).T\n    \n    G = mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    u = asmatrix(ed).T\n    P = Kle*G*u-fle\n\n    es = mat([\n        [-P[0,0],-P[1,0],-P[2,0]],\n        [ P[3,0], P[4,0], P[5,0]]\n    ])\n    \n    return es\n\ndef beam2d(ex,ey,ep):\n    """"""\n    Calculate the stiffness matrix Ke, the mass matrix Me\n    and the damping matrix Ce for a 2D elastic Bernoulli\n    beam element.\n\n    Parameters:\n \n        ex = [x1, x2]\n        ey = [y1, y2]           element node coordinates\n\n        ep = [E,A,I,m,(a,b)]    element properties;\n                                  E:  Young\'s modulus\n                                  A:  cross section area\n                                  I:  moment of inertia\n                                  m:  mass per unit length\n                                a,b:  damping coefficients,\n                                      Ce=aMe+bKe\n\n    Returns:\n\n        Ke                      element stiffness matrix (6 x 6)\n        Me                      element mass martix\n        Ce                      element damping matrix, optional\n    """"""\n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n = asarray(b/L).reshape(2,)\n    \n    a = 0\n    b = 0\n    if size(ep) == 4:\n        E,A,I,m = ep\n    elif size(ep) == 6:\n        E,A,I,m,a,b = ep\n    \n    Kle = mat([\n        [ E*A/L, 0,           0,         -E*A/L, 0,           0         ],\n        [ 0,     12*E*I/L**3, 6*E*I/L**2, 0,    -12*E*I/L**3, 6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  4*E*I/L,    0,    -6*E*I/L**2,  2*E*I/L   ],\n        [-E*A/L, 0,           0,          E*A/L, 0,           0         ],\n        [ 0,    -12*E*I/L**3,-6*E*I/L**2, 0,     12*E*I/L**3,-6*E*I/L**2],\n        [ 0,     6*E*I/L**2,  2*E*I/L,    0,    -6*E*I/L**2,  4*E*I/L   ]\n    ])\n\n    Mle = m*L/420*mat([\n        [ 140, 0,    0,      70,  0,    0     ],\n        [ 0,   156,  22*L,   0,   54,  -13*L  ],\n        [ 0,   22*L, 4*L**2, 0,   13*L,-3*L**2],\n        [ 70,  0,    0,      140, 0,    0     ],\n        [ 0,   54,   13*L,   0,   156, -22*L  ],\n        [ 0,  -13*L,-3*L**2, 0,  -22*L, 4*L**2]\n    ])\n    \n    Cle = a*Mle+b*Kle\n\n    G = mat([\n        [ n[0], n[1], 0, 0,    0,    0],\n        [-n[1], n[0], 0, 0,    0,    0],\n        [ 0,    0,    1, 0,    0,    0],\n        [ 0,    0,    0, n[0], n[1], 0],\n        [ 0,    0,    0,-n[1], n[0], 0],\n        [ 0,    0,    0, 0,    0,    1]\n    ])\n    \n    Ke = G.T*Kle*G\n    Me = G.T*Mle*G\n    Ce = G.T*Cle*G\n    \n    if size(ep) == 4:\n        return Ke,Me\n    elif size(ep) == 6:\n        return Ke,Me,Ce\n\ndef beam3e(ex,ey,ez,eo,ep,eq=None):\n    """"""\n    Calculate the stiffness matrix for a 3D elastic Bernoulli\n    beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]\n        ey = [y1 y2]\n        ez = [z1 z2]            element node coordinates\n        \n        eo = [xz yz zz]         orientation of local z axis\n        \n        ep = [E G A Iy Iz Kv]   element properties\n                                  E: Young\'s modulus\n                                  G: Shear modulus\n                                  A: Cross section area\n                                 Iy: Moment of inertia, local y-axis\n                                 Iz: Moment of inertia, local z-axis\n                                 Kv: Saint-Venant\'s torsion constant\n    \n        eq = [qx qy qz qw]      distributed loads\n\n    Returns:\n\n        Ke                      beam stiffness matrix (12 x 12)\n\n        fe                      equivalent nodal forces (12 x 1)\n\n    """"""\n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n        ])\n    L = asscalar(sqrt(b.T*b))\n    n1 = asarray(b.T/L).reshape(3,)\n    \n    eo = asmatrix(eo)\n    lc = asscalar(sqrt(eo*eo.T))\n    n3 = asarray(eo/lc).reshape(3,)\n    \n    E,Gs,A,Iy,Iz,Kv = ep\n\n    qx = 0.\n    qy = 0.\n    qz = 0.\n    qw = 0.\n    if eq != None:\n        qx,qy,qz,qw = eq\n\n    a = E*A/L\n    b = 12*E*Iz/L**3\n    c = 6*E*Iz/L**2\n    d = 12*E*Iy/L**3\n    e = 6*E*Iy/L**2\n    f = Gs*Kv/L\n    g = 2*E*Iy/L\n    h = 2*E*Iz/L\n\n    Kle = mat([\n        [ a, 0, 0, 0, 0,   0,  -a, 0, 0, 0, 0,   0  ],\n        [ 0, b, 0, 0, 0,   c,   0,-b, 0, 0, 0,   c  ],\n        [ 0, 0, d, 0,-e,   0,   0, 0,-d, 0,-e,   0  ],\n        [ 0, 0, 0, f, 0,   0,   0, 0, 0,-f, 0,   0  ],\n        [ 0, 0,-e, 0, 2*g, 0,   0, 0, e, 0, g,   0  ],\n        [ 0, c, 0, 0, 0,   2*h, 0,-c, 0, 0, 0,   h  ],\n        [-a, 0, 0, 0, 0,   0,   a, 0, 0, 0, 0,   0  ],\n        [ 0,-b, 0, 0, 0,  -c,   0, b, 0, 0, 0,  -c  ],\n        [ 0, 0,-d, 0, e,   0,   0, 0, d, 0, e,   0  ],\n        [ 0, 0, 0,-f, 0,   0,   0, 0, 0, f, 0,   0  ],\n        [ 0, 0,-e, 0, g,   0,   0, 0, e, 0, 2*g, 0  ],\n        [ 0, c, 0, 0, 0,   h,   0,-c, 0, 0, 0,   2*h]\n    ])\n\n    fle = L/2*mat([qx, qy, qz, qw, -qz*L/6, qy*L/6, qx, qy, qz, qw, qz*L/6, -qy*L/6]).T\n\n    n2 = array([0.,0.,0.])\n    n2[0] = n3[1]*n1[2]-n3[2]*n1[1]\n    n2[1] = -n1[2]*n3[0]+n1[0]*n3[2]\n    n2[2] = n3[0]*n1[1]-n1[0]*n3[1]\n\n    #An = append([n1,n2],[n3],0)\n\n    G = mat([\n        [ n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2]]\n    ])\n    \n    Ke = G.T*Kle*G\n    fe = G.T*fle\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef beam3s(ex,ey,ez,eo,ep,ed,eq=None,n=None):\n    """"""\n    Calculate the variation of the section forces and displacements\n    along a three-dimensional beam element.\n    \n    Parameters:\n     \n        ex = [x1 x2]                element node coordinates\n        ey = [y1 y2]\n        ez = [z1 z2]\n\n        eo = [xz yz zz]             orientation of local z axis\n        \n        ep = [E G A Iy Iz Kv]       element properties\n                                      E: Young\'s modulus\n                                      G: Shear modulus\n                                      A: Cross section area\n                                     Iy: Moment of inertia, local y-axis\n                                     Iz: Moment of inertia, local z-axis\n                                     Kv: Saint-Venant\'s torsion constant\n\n        ed                          the element displacement vector from the\n                                    global coordinate system\n    \n        eq = [qx qy qz qw]          the disibuted axial, transversal and\n                                    torsional loads\n\n        n                           the number of point in which displacements\n                                    and section forces are to be computed\n\n    Returns:\n\n        es = [[N1,Vy1,Vz1,T1,My1,Mz1],  section forces in n points along\n              [N2,Vy2,Vz2,T2,My2,Mz2],  the local x-axis\n              [..,...,...,..,...,...],\n              [Nn,Vyn,Vzn,Tn,Myn,Mzn]]\n\n        edi = [[u1,v1,w1,fi1],          displacements in n points along\n               [u2,v2,w2,fi2],          the local x-axis\n               [..,..,..,...],\n               [un,vn,wn,fin]]\n\n        eci = [[x1],                    local x-coordinates of the evaluation\n               [x2],                    points\n               [..],\n               [xn]]\n\n    """"""\n    b = mat([\n        [ex[1]-ex[0]],\n        [ey[1]-ey[0]],\n        [ez[1]-ez[0]]\n    ])\n    L = asscalar(sqrt(b.T*b))\n    n1 = asarray(b.T/L).reshape(3,)\n    \n    eo = asmatrix(eo)\n    lc = asscalar(sqrt(eo*eo.T))\n    n3 = asarray(eo/lc).reshape(3,)\n\n    EA = ep[0]*ep[2]\n    EIy = ep[0]*ep[3]\n    EIz = ep[0]*ep[4]\n    GKv = ep[1]*ep[5]\n\n    qx = 0.\n    qy = 0.\n    qz = 0.\n    qw = 0.\n    if eq != None:\n        qx,qy,qz,qw = eq\n\n    ne = 2\n    if n != None:\n        ne = n\n        \n    n2 = array([0.,0.,0.])\n    n2[0] = n3[1]*n1[2]-n3[2]*n1[1]\n    n2[1] = -n1[2]*n3[0]+n1[0]*n3[2]\n    n2[2] = n3[0]*n1[1]-n1[0]*n3[1]\n\n    G = mat([\n        [ n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0,     0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2], 0,     0,     0    ],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n1[0], n1[1], n1[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n2[0], n2[1], n2[2]],\n        [ 0,     0,     0,     0,     0,     0,     0,     0,     0,     n3[0], n3[1], n3[2]]\n    ])\n\n    u = G*asmatrix(ed).T-array([    # u is the local element displacement\n        [ 0               ],        # vector minus the particular solution\n        [ 0               ],        # to the beam\'s diff.eq:s\n        [ 0               ],\n        [ 0               ],\n        [ 0               ],\n        [ 0               ],\n        [-qx*L**2/(2*EA)  ],\n        [ qy*L**4/(24*EIz)],\n        [ qz*L**4/(24*EIy)],\n        [-qw*L**2/(2*GKv) ],\n        [-qz*L**3/(6*EIy) ],\n        [ qy*L**3/(6*EIz) ]\n    ])\n\n    C = mat([\n        [ 0, 1, 0,      0,    0, 0, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 1, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 1, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 0, 0, 1],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,   -1, 0, 0, 0],\n        [ 0, 0, 0,      0,    1, 0, 0,      0,    0, 0, 0, 0],\n        [ L, 1, 0,      0,    0, 0, 0,      0,    0, 0, 0, 0,],\n        [ 0, 0, L**3,   L**2, L, 1, 0,      0,    0, 0, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, L**3,   L**2, L, 1, 0, 0],\n        [ 0, 0, 0,      0,    0, 0, 0,      0,    0, 0, L, 1],\n        [ 0, 0, 0,      0,    0, 0,-3*L**2,-2*L, -1, 0, 0, 0],\n        [ 0, 0, 3*L**2, 2*L,  1, 0, 0,      0,    0, 0, 0, 0],\n    ])\n\n    m = linalg.inv(C)*u\n    eci = zeros((ne,1))\n    es = zeros((ne,6))\n    edi = zeros((ne,4))\n    for i in arange(ne):\n        x = i*L/(ne-1)\n        eci[i,0] = x\n        es[i,:] = (mat([\n            [ EA, 0, 0,       0,     0, 0, 0,       0,     0, 0, 0,   0],\n            [ 0,  0,-6*EIz,   0,     0, 0, 0,       0,     0, 0, 0,   0],\n            [ 0,  0, 0,       0,     0, 0,-6*EIy,   0,     0, 0, 0,   0],\n            [ 0,  0, 0,       0,     0, 0, 0,       0,     0, 0, GKv, 0],\n            [ 0,  0, 0,       0,     0, 0,-6*EIy*x,-2*EIy, 0, 0, 0,   0],\n            [ 0,  0, 6*EIz*x, 2*EIz, 0, 0, 0,       0,     0, 0, 0,   0]\n        ])*m+array([-qx*x,-qy*x,-qz*x,-qw*x,-qz*x**2/2,qy*x**2/2]).reshape(6,1)).T\n\n        edi[i,:] = (mat([\n            [ x, 1, 0,    0,    0, 0, 0,    0,    0, 0, 0, 0],\n            [ 0, 0, x**3, x**2, x, 1, 0,    0,    0, 0, 0, 0],\n            [ 0, 0, 0,    0,    0, 0, x**3, x**2, x, 1, 0, 0],\n            [ 0, 0, 0,    0,    0, 0, 0,    0,    0, 0, x, 1]\n        ])*m+array([-qx*x**2/(2*EA),qy*x**4/(24*EIz),qz*x**4/(24*EIy),-qw*x**2/(2*GKv)]).reshape(4,1)).T\n    \n    if n == None:\n        return es\n    else:\n        return es,edi,eci\n    \ndef flw2te(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity) matrix for a triangular field element.\n    \n    Parameters:\n    \n        ex = [x1 x2 x3]\n        ey = [y1 y2 y3]     element coordinates\n    \n        ep = [t]            element thickness    \n\n        D = [kxx kxy;\n             kyx kyy]       constitutive matrix\n    \n             eq             heat supply per unit volume\n             \n    Returns:\n    \n        Ke                  element \'stiffness\' matrix (3 x 3)\n\n        fe                  element load vector (3 x 1)\n    \n    """"""\n    t=ep[0];\n    if eq==None:\n        eq=0.\n    \n    exm = asmatrix(ex)\n    eym = asmatrix(ey)\n    C=asmatrix(hstack([ones((3,1)),exm.T,eym.T]))\n    B=matrix([\n        [0.,1.,0.],\n        [0.,0.,1.]\n    ])*C.I\n    A=0.5*linalg.det(C)\n  \n    Ke=B.T*D*B*t*A\n    fe=matrix([[1.,1.,1.]]).T*eq*A*t/3\n       \n    if eq==0.:\n        return Ke\n    else:\n        return Ke, fe\n    \ndef flw2ts(ex,ey,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the triangular field element.\n    \n    Parameters:\n    \n        ex = [x1 x2 x3]\n        ey = [y1 y2 y3]         element coordinates\n                                 \n             D = [kxx kxy\n                  kyx kyy]      constitutive matrix\n    \n             ed =[u1 u2 u3]     u1,u2,u3: nodal values\n                  .. .. ..;\n                  \n    Returns:\n    \n        es=[ qx qy ] \n             ... ..]                element flows\n    \n        et=[ gx gy ]\n             ... ..]                element gradients\n    \n    """"""\n\n    if len(ex.shape)>1:\n        qs = zeros([ex.shape[0],2])\n        qt = zeros([ex.shape[0],2])\n        row = 0\n        for exr, eyr, edr in zip(ex, ey, ed):\n            exm = asmatrix(exr)\n            eym = asmatrix(eyr)\n            edm = asmatrix(edr)\n            C=asmatrix(hstack([ones((3,1)),exm.T,eym.T]))\n            B=matrix([\n                [0.,1.,0.],\n                [0.,0.,1.]\n            ])*C.I\n\n            qs[row,:]=(-D*B*edm.T).T\n            qt[row,:]=(B*edm.T).T\n            row += 1\n\n        return qs, qt\n    else:\n        exm = asmatrix(ex)\n        eym = asmatrix(ey)\n        edm = asmatrix(ed)\n        C=asmatrix(hstack([ones((3,1)),exm.T,eym.T]))\n        B=matrix([\n            [0.,1.,0.],\n            [0.,0.,1.]\n        ])*C.I\n\n        qs=-D*B*edm.T\n        qt=B*edm.T\n    \n        return qs.T, qt.T\n\ndef flw2qe(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity) matrix for a triangular field element.\n    \n    Parameters:\n    \n        ex = [x1, x2, x3, x4]\n        ey = [y1, y2, y3, y4]   element coordinates\n    \n        ep = [t]                element thickness    \n\n        D = [[kxx, kxy],\n             [kyx, kyy]]        constitutive matrix\n    \n        eq                      heat supply per unit volume\n             \n    Returns:\n    \n        Ke                      element \'stiffness\' matrix (4 x 4)\n\n        fe                      element load vector (4 x 1)\n    \n    """"""\n    xc = sum(ex)/4.\n    yc = sum(ey)/4.\n\n    K = zeros((5,5))\n    f = zeros((5,1))\n    \n    if eq == None:\n        k1 = flw2te([ex[0],ex[1],xc],[ey[0],ey[1],yc],ep,D)\n        K = assem(array([1,2,5]),K,k1)\n        k1 = flw2te([ex[1],ex[2],xc],[ey[1],ey[2],yc],ep,D)\n        K = assem(array([2,3,5]),K,k1)\n        k1 = flw2te([ex[2],ex[3],xc],[ey[2],ey[3],yc],ep,D)\n        K = assem(array([3,4,5]),K,k1)\n        k1 = flw2te([ex[3],ex[0],xc],[ey[3],ey[0],yc],ep,D)\n        K = assem(array([4,1,5]),K,k1)\n    else:\n        k1,f1 = flw2te([ex[0],ex[1],xc],[ey[0],ey[1],yc],ep,D,eq)    \n        K,f = assem(array([1,2,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[1],ex[2],xc],[ey[1],ey[2],yc],ep,D,eq)\n        K,f = assem(array([2,3,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[2],ex[3],xc],[ey[2],ey[3],yc],ep,D,eq)\n        K,f = assem(array([3,4,5]),K,k1,f,f1)\n        k1,f1 = flw2te([ex[3],ex[0],xc],[ey[3],ey[0],yc],ep,D,eq)\n        K,f = assem(array([4,1,5]),K,k1,f,f1)\n    Ke1,fe1 = statcon(K,f,array([5]));\n\n    Ke = Ke1\n    fe = fe1\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n\ndef flw2qs(ex,ey,ep,D,ed,eq=None):\n    """"""\n    Compute flows or corresponding quantities in the\n    quadrilateral field element.\n    \n    Parameters:\n    \n        ex = [x1, x2, x3, x4]\n        ey = [y1, y2, y3, y4]      element coordinates\n    \n        ep = [t]                   element thickness    \n\n        D = [[kxx, kxy],\n             [kyx, kyy]]           constitutive matrix\n\n        ed = [[u1, u2, u3, u4],\n              [.., .., .., ..]]    u1,u2,u3,u4: nodal values\n    \n        eq                         heat supply per unit volume\n             \n    Returns:\n    \n        es = [[qx, qy],\n              [.., ..]]            element flows\n\n        et = [[gx, gy],\n              [.., ..]]            element gradients\n    \n    """"""\n    K = zeros((5,5))\n    f = zeros((5,1))\n    \n    xm = sum(ex)/4\n    ym = sum(ey)/4\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n    \n    En = array([\n        [1,2,5],\n        [2,3,5],\n        [3,4,5],\n        [4,1,5]\n    ])\n    ex1 = array([ex[0],ex[1],xm])\n    ey1 = array([ey[0],ey[1],ym])\n    ex2 = array([ex[1],ex[2],xm])\n    ey2 = array([ey[1],ey[2],ym])\n    ex3 = array([ex[2],ex[3],xm])\n    ey3 = array([ey[2],ey[3],ym])\n    ex4 = array([ex[3],ex[0],xm])\n    ey4 = array([ey[3],ey[0],ym])\n    \n    if eq == None:\n        k1 = flw2te(ex1,ey1,ep,D)\n        K = assem(En[0],K,k1)\n        k1 = flw2te(ex2,ey2,ep,D)\n        K = assem(En[1],K,k1)\n        k1 = flw2te(ex3,ey3,ep,D)\n        K = assem(En[2],K,k1)\n        k1 = flw2te(ex4,ey4,ep,D)\n        K = assem(En[3],K,k1)\n    else:\n        k1,f1 = flw2te(ex1,ey1,ep,D,q)\n        K,f = assem(En[0],K,k1,f,f1)\n        k1,f1 = flw2te(ex2,ey2,ep,D,q)\n        K,f = assem(En[1],K,k1,f,f1)\n        k1,f1 = flw2te(ex3,ey3,ep,D,q)\n        K,f = assem(En[2],K,k1,f,f1)\n        k1,f1 = flw2te(ex4,ey4,ep,D,q)\n        K,f = assem(En[3],K,k1,f,f1)\n    \n    if rank(ed)==1:\n        ed = array([ed])\n    ni,nj = shape(ed)\n\n    a = zeros((5,ni))\n    for i in range(ni):\n        a[ix_(range(5),[i])],r = asarray(solveq(K,f,arange(1,5),ed[i]))\n\n    s1,t1 = flw2ts(ex1,ey1,D,a[ix_(En[0,:]-1,arange(ni))].T)\n    s2,t2 = flw2ts(ex2,ey2,D,a[ix_(En[1,:]-1,arange(ni))].T)\n    s3,t3 = flw2ts(ex3,ey3,D,a[ix_(En[2,:]-1,arange(ni))].T)\n    s4,t4 = flw2ts(ex4,ey4,D,a[ix_(En[3,:]-1,arange(ni))].T)\n    \n    es = (s1+s2+s3+s4)/4.\n    et = (t1+t2+t3+t4)/4.\n    \n    return es,et\n\ndef flw2i4e(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 4 node isoparametric field element\n\n    Parameters:\n        \n        ex = [x1 x2 x3 x4]  element coordinates\n        ey = [y1 y2 y3 y4]\n\n        ep = [t ir]         thickness and integration rule\n\n        D  = [[kxx kxy],\n              [kyx kyy]]    constitutive matrix\n\n        eq                  heat supply per unit volume\n\n    Returns:\n        Ke                  element \'stiffness\' matrix (4 x 4)\n        fe                  element load vector (4 x 1)\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = mat([g1,g1])\n        w = mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        print(""Used number of integration points not implemented"")\n    wp = multiply(w[:,0],w[:,1])\n    \n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = multiply((1-xsi),(1-eta))/4.\n    N = append(N,multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = append(N,multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = append(N,multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = mat(zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n    Ke1 = mat(zeros((4,4)))\n    fe1 = mat(zeros((4,1)))\n    JT = dNr*mat([ex,ey]).T\n\n    for i in range(ngp):\n        indx = array([2*(i+1)-1,2*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n\n    if eq == None:\n        return Ke1*t\n    else:\n        return Ke1*t,fe1*t*eq\n\ndef flw2i4s(ex,ey,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    4 node isoparametric element.\n    \n    Parameters:\n        \n        ex = [x1 x2 x3 x4]         element coordinates\n        ey = [y1 y2 y3 y4]\n\n        ep = [t ir]                thickness and integration rule\n\n        D  = [[kxx kxy],\n              [kyx kyy]]           constitutive matrix\n\n        ed = [u1, u2, u3, u4]      u1,u2,u3,u4: nodal values\n\n    Returns:\n        es = [[qx, qy],\n              [.., ..]]             element flows\n\n        et = [[qx, qy],\n              [... ..]]             element gradients\n\n        eci=[[ix1, iy1],            Gauss point location vector\n             [...  ...],            nint: number of integration points\n             [ix(nint), iy(nint)]\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = mat([g1,g1])\n        w = mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        print(""Used number of integration points not implemented"")\n    wp = multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = multiply((1-xsi),(1-eta))/4.\n    N = append(N,multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = append(N,multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = append(N,multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = mat(zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n    eci = N*mat([ex,ey]).T\n    if rank(ed) == 1:\n        ed = array([ed])\n    red,ced = shape(ed)\n    JT = dNr*mat([ex,ey]).T\n    \n    es = mat(zeros((ngp*red,2)))\n    et = mat(zeros((ngp*red,2)))\n    for i in range(ngp):\n        indx = array([2*(i+1)-1,2*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n    \n    return es,et,eci\n\ndef flw2i8e(ex,ey,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 8 node isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1, ..., x8]      element coordinates\n        ey = [y1, ..., y8]\n        \n        ep = [t, ir]            thickness and integration rule\n\n        D = [[kxx, kxy],\n             [kyx, kyy]]        constitutive matrix\n\n        eq                      heat supply per unit volume\n\n    Returns:\n    \n        Ke                      element \'stiffness\' matrix (8 x 8)\n        fe                      element load vector (8 x 1)\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if eq == None:\n        q = 0\n    else:\n        q = eq\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = mat([g1,g1])\n        w = mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        print(""Used number of integration points not implemented"")\n    wp = multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = multiply(multiply(-(1-xsi),(1-eta)),(1+xsi+eta))/4.\n    N = append(N,multiply(multiply(-(1+xsi),(1-eta)),(1-xsi+eta))/4.,axis=1)\n    N = append(N,multiply(multiply(-(1+xsi),(1+eta)),(1-xsi-eta))/4.,axis=1)\n    N = append(N,multiply(multiply(-(1-xsi),(1+eta)),(1+xsi-eta))/4.,axis=1)\n    N = append(N,multiply((1-multiply(xsi,xsi)),(1-eta))/2.,axis=1)\n    N = append(N,multiply((1+xsi),(1-multiply(eta,eta)))/2.,axis=1)\n    N = append(N,multiply((1-multiply(xsi,xsi)),(1+eta))/2.,axis=1)\n    N = append(N,multiply((1-xsi),(1-multiply(eta,eta)))/2.,axis=1)\n\n    dNr = mat(zeros((r2,8)))\n    dNr[0:r2:2,0] = -(-multiply((1-eta),(1+xsi+eta))+multiply((1-xsi),(1-eta)))/4.\n    dNr[0:r2:2,1] = -(multiply((1-eta),(1-xsi+eta))-multiply((1+xsi),(1-eta)))/4.\n    dNr[0:r2:2,2] = -(multiply((1+eta),(1-xsi-eta))-multiply((1+xsi),(1+eta)))/4.\n    dNr[0:r2:2,3] = -(-multiply((1+eta),(1+xsi-eta))+multiply((1-xsi),(1+eta)))/4.\n    dNr[0:r2:2,4] = -multiply(xsi,(1-eta))\n    dNr[0:r2:2,5] = (1-multiply(eta,eta))/2.\n    dNr[0:r2:2,6] = -multiply(xsi,(1+eta))\n    dNr[0:r2:2,7] = -(1-multiply(eta,eta))/2.\n    dNr[1:r2+1:2,0] = -(-multiply((1-xsi),(1+xsi+eta))+multiply((1-xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,1] = -(-multiply((1+xsi),(1-xsi+eta))+multiply((1+xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,2] = -(multiply((1+xsi),(1-xsi-eta))-multiply((1+xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,3] = -(multiply((1-xsi),(1+xsi-eta))-multiply((1-xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,4] = -(1-multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,5] = -multiply(eta,(1+xsi))\n    dNr[1:r2+1:2,6] = (1-multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,7] = -multiply(eta,(1-xsi))\n\n    Ke1 = mat(zeros((8,8)))\n    fe1 = mat(zeros((8,1)))\n    JT = dNr*mat([ex,ey]).T\n\n    for i in range(ngp):\n        indx = array([2*(i+1)-1,2*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n    \n    if eq != None:\n        return Ke1*t,fe1*t*q\n    else:\n        return Ke1*t\n\ndef flw2i8s(ex,ey,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    8 node isoparametric element.\n    \n    Parameters:\n        \n        ex = [x1,x2,x3....,x8]     element coordinates\n        ey = [y1,y2,y3....,y8]\n\n        ep = [t,ir]                thickness and integration rule\n\n        D  = [[kxx,kxy],\n              [kyx,kyy]]           constitutive matrix\n\n        ed = [u1,....,u8]          u1,....,u8: nodal values\n\n    Returns:\n        es = [[qx,qy],\n              [..,..]]             element flows\n\n        et = [[qx,qy],\n              [..,..]]             element gradients\n\n        eci=[[ix1,iy1],            Gauss point location vector\n             [...,...],            nint: number of integration points\n             [ix(nint),iy(nint)]]\n\n    """"""\n    t = ep[0]\n    ir = ep[1]\n    ngp = ir*ir\n\n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = mat([g1,g1])\n        w = mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]\n        ])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]\n        ])\n        w = mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]\n        ])\n    else:\n        print(""Used number of integration points not implemented"")\n    wp = multiply(w[:,0],w[:,1])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n\n    N = multiply(multiply(-(1-xsi),(1-eta)),(1+xsi+eta))/4.\n    N = append(N,multiply(multiply(-(1+xsi),(1-eta)),(1-xsi+eta))/4.,axis=1)\n    N = append(N,multiply(multiply(-(1+xsi),(1+eta)),(1-xsi-eta))/4.,axis=1)\n    N = append(N,multiply(multiply(-(1-xsi),(1+eta)),(1+xsi-eta))/4.,axis=1)\n    N = append(N,multiply((1-multiply(xsi,xsi)),(1-eta))/2.,axis=1)\n    N = append(N,multiply((1+xsi),(1-multiply(eta,eta)))/2.,axis=1)\n    N = append(N,multiply((1-multiply(xsi,xsi)),(1+eta))/2.,axis=1)\n    N = append(N,multiply((1-xsi),(1-multiply(eta,eta)))/2.,axis=1)\n\n    dNr = mat(zeros((r2,8)))\n    dNr[0:r2:2,0] = -(-multiply((1-eta),(1+xsi+eta))+multiply((1-xsi),(1-eta)))/4.\n    dNr[0:r2:2,1] = -(multiply((1-eta),(1-xsi+eta))-multiply((1+xsi),(1-eta)))/4.\n    dNr[0:r2:2,2] = -(multiply((1+eta),(1-xsi-eta))-multiply((1+xsi),(1+eta)))/4.\n    dNr[0:r2:2,3] = -(-multiply((1+eta),(1+xsi-eta))+multiply((1-xsi),(1+eta)))/4.\n    dNr[0:r2:2,4] = -multiply(xsi,(1-eta))\n    dNr[0:r2:2,5] = (1-multiply(eta,eta))/2.\n    dNr[0:r2:2,6] = -multiply(xsi,(1+eta))\n    dNr[0:r2:2,7] = -(1-multiply(eta,eta))/2.\n    dNr[1:r2+1:2,0] = -(-multiply((1-xsi),(1+xsi+eta))+multiply((1-xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,1] = -(-multiply((1+xsi),(1-xsi+eta))+multiply((1+xsi),(1-eta)))/4.\n    dNr[1:r2+1:2,2] = -(multiply((1+xsi),(1-xsi-eta))-multiply((1+xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,3] = -(multiply((1-xsi),(1+xsi-eta))-multiply((1-xsi),(1+eta)))/4.\n    dNr[1:r2+1:2,4] = -(1-multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,5] = -multiply(eta,(1+xsi))\n    dNr[1:r2+1:2,6] = (1-multiply(xsi,xsi))/2.\n    dNr[1:r2+1:2,7] = -multiply(eta,(1-xsi))\n\n    eci = N*mat([ex,ey]).T\n    if rank(ed) == 1:\n        ed = array([ed])\n    red,ced = shape(ed)\n    JT = dNr*mat([ex,ey]).T\n    \n    es = mat(zeros((ngp*red,2)))\n    et = mat(zeros((ngp*red,2)))\n    for i in range(ngp):\n        indx = array([2*(i+1)-1,2*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n\n    return es,et,eci\n\ndef flw3i8e(ex,ey,ez,ep,D,eq=None):\n    """"""\n    Compute element stiffness (conductivity)\n    matrix for 8 node isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3,...,x8]\n        ey = [y1,y2,y3,...,y8]      element coordinates\n        ez = [z1,z2,z3,...,z8]\n\n        ep = [ir]                   Ir: Integration rule\n\n        D = [[kxx,kxy,kxz],\n             [kyx,kyy,kyz],\n             [kzx,kzy,kzz]]         constitutive matrix\n\n        eq                          heat supply per unit volume\n\n    Output:\n\n        Ke                          element \'stiffness\' matrix (8 x 8)\n        fe                          element load vector (8 x 1)\n\n    """"""\n    ir = ep[0]\n    ngp = ir*ir*ir\n    \n    if eq == None:\n        q = 0\n    else:\n        q = eq\n    \n    if ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-1,-1,-1],\n            [ 1,-1,-1],\n            [ 1, 1,-1],\n            [-1, 1,-1],\n            [-1,-1, 1],\n            [ 1,-1, 1],\n            [ 1, 1, 1],\n            [-1, 1, 1]\n        ])*g1\n        w = mat(ones((8,3)))*w1\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat(zeros((27,3)))\n        w = mat(zeros((27,3)))\n        I1 = array([-1,0,1,-1,0,1,-1,0,1])\n        I2 = array([0,-1,0,0,1,0,0,1,0])\n        gp[:,0] = mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,0] = mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,0]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,0] = mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,0] = mat([I2,I2,I2]).reshape(27,1)*w2+w[:,0]\n        I1 = array([-1,-1,-1,0,0,0,1,1,1])\n        I2 = array([0,0,0,1,1,1,0,0,0])\n        gp[:,1] = mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,1] = mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,1]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,1] = mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,1] = mat([I2,I2,I2]).reshape(27,1)*w2+w[:,1]\n        I1 = array([-1,-1,-1,-1,-1,-1,-1,-1,-1])\n        I2 = array([0,0,0,0,0,0,0,0,0])\n        I3 = abs(I1)\n        gp[:,2] = mat([I1,I2,I3]).reshape(27,1)*g1\n        gp[:,2] = mat([I2,I3,I2]).reshape(27,1)*g2+gp[:,2]\n        w[:,2] = mat([I3,I2,I3]).reshape(27,1)*w1\n        w[:,2] = mat([I2,I3,I2]).reshape(27,1)*w2+w[:,2]\n    else:\n        print(""Used number of integration points not implemented"")\n        return\n\n    wp = multiply(multiply(w[:,0],w[:,1]),w[:,2])\n\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    zet = gp[:,2]\n    r2 = ngp*3\n    \n    N = multiply(multiply((1-xsi),(1-eta)),(1-zet))/8.\n    N = append(N,multiply(multiply((1+xsi),(1-eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1+eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1+eta)),(1+zet))/8.,axis=1)\n    \n    dNr = mat(zeros((r2,8)))\n    dNr[0:r2:3,0]= multiply(-(1-eta),(1-zet))\n    dNr[0:r2:3,1]= multiply((1-eta),(1-zet))\n    dNr[0:r2:3,2]= multiply((1+eta),(1-zet))\n    dNr[0:r2:3,3]= multiply(-(1+eta),(1-zet))\n    dNr[0:r2:3,4]= multiply(-(1-eta),(1+zet))\n    dNr[0:r2:3,5]= multiply((1-eta),(1+zet))\n    dNr[0:r2:3,6]= multiply((1+eta),(1+zet))\n    dNr[0:r2:3,7]= multiply(-(1+eta),(1+zet))\n    dNr[1:r2+1:3,0] = multiply(-(1-xsi),(1-zet))\n    dNr[1:r2+1:3,1] = multiply(-(1+xsi),(1-zet))\n    dNr[1:r2+1:3,2] = multiply((1+xsi),(1-zet))\n    dNr[1:r2+1:3,3] = multiply((1-xsi),(1-zet))\n    dNr[1:r2+1:3,4] = multiply(-(1-xsi),(1+zet))\n    dNr[1:r2+1:3,5] = multiply(-(1+xsi),(1+zet))\n    dNr[1:r2+1:3,6] = multiply((1+xsi),(1+zet))\n    dNr[1:r2+1:3,7] = multiply((1-xsi),(1+zet))\n    dNr[2:r2+2:3,0] = multiply(-(1-xsi),(1-eta))\n    dNr[2:r2+2:3,1] = multiply(-(1+xsi),(1-eta))\n    dNr[2:r2+2:3,2] = multiply(-(1+xsi),(1+eta))\n    dNr[2:r2+2:3,3] = multiply(-(1-xsi),(1+eta))\n    dNr[2:r2+2:3,4] = multiply((1-xsi),(1-eta))\n    dNr[2:r2+2:3,5] = multiply((1+xsi),(1-eta))\n    dNr[2:r2+2:3,6] = multiply((1+xsi),(1+eta))\n    dNr[2:r2+2:3,7] = multiply((1-xsi),(1+eta))\n    dNr = dNr/8.\n\n    Ke1 = mat(zeros((8,8)))\n    fe1 = mat(zeros((8,1)))\n    JT = dNr*mat([ex,ey,ez]).T\n    \n    for i in range(ngp):\n        indx = array([3*(i+1)-2,3*(i+1)-1,3*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        Ke1 = Ke1+B.T*D*B*detJ*asscalar(wp[i])\n        fe1 = fe1+N[i,:].T*detJ*wp[i]\n\n    if eq != None:\n        return Ke1,fe1*q\n    else:\n        return Ke1\n\ndef flw3i8s(ex,ey,ez,ep,D,ed):\n    """"""\n    Compute flows or corresponding quantities in the\n    8 node (3-dim) isoparametric field element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3,...,x8]\n        ey = [y1,y2,y3,...,y8]              element coordinates\n        ez = [z1,z2,z3,...,z8]\n\n        ep = [ir]                           Ir: Integration rule\n\n        D = [[kxx,kxy,kxz],\n             [kyx,kyy,kyz],\n             [kzx,kzy,kzz]]                 constitutive matrix\n\n        ed = [[u1,....,u8],                 element nodal values\n              [..,....,..]]\n\n    Output:\n\n        es = [[qx,qy,qz],\n              [..,..,..]]                   element flows(s)\n\n        et = [[qx,qy,qz],                   element gradients(s)\n              [..,..,..]]\n\n        eci = [[ix1,ix1,iz1],               location vector\n               [...,...,...],               nint: number of integration points\n               [ix(nint),iy(nint),iz(nint)]]\n\n    """"""\n    ir = ep[0]\n    ngp = ir*ir*ir\n    \n    if ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-1,-1,-1],\n            [ 1,-1,-1],\n            [ 1, 1,-1],\n            [-1, 1,-1],\n            [-1,-1, 1],\n            [ 1,-1, 1],\n            [ 1, 1, 1],\n            [-1, 1, 1]\n        ])*g1\n        w = mat(ones((8,3)))*w1\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat(zeros((27,3)))\n        w = mat(zeros((27,3)))\n        I1 = array([-1,0,1,-1,0,1,-1,0,1])\n        I2 = array([0,-1,0,0,1,0,0,1,0])\n        gp[:,0] = mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,0] = mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,0]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,0] = mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,0] = mat([I2,I2,I2]).reshape(27,1)*w2+w[:,0]\n        I1 = array([-1,-1,-1,0,0,0,1,1,1])\n        I2 = array([0,0,0,1,1,1,0,0,0])\n        gp[:,1] = mat([I1,I1,I1]).reshape(27,1)*g1\n        gp[:,1] = mat([I2,I2,I2]).reshape(27,1)*g2+gp[:,1]\n        I1 = abs(I1)\n        I2 = abs(I2)\n        w[:,1] = mat([I1,I1,I1]).reshape(27,1)*w1\n        w[:,1] = mat([I2,I2,I2]).reshape(27,1)*w2+w[:,1]\n        I1 = array([-1,-1,-1,-1,-1,-1,-1,-1,-1])\n        I2 = array([0,0,0,0,0,0,0,0,0])\n        I3 = abs(I1)\n        gp[:,2] = mat([I1,I2,I3]).reshape(27,1)*g1\n        gp[:,2] = mat([I2,I3,I2]).reshape(27,1)*g2+gp[:,2]\n        w[:,2] = mat([I3,I2,I3]).reshape(27,1)*w1\n        w[:,2] = mat([I2,I3,I2]).reshape(27,1)*w2+w[:,2]\n    else:\n        print(""Used number of integration points not implemented"")\n        return\n\n    wp = multiply(multiply(w[:,0],w[:,1]),w[:,2])\n    \n    xsi = gp[:,0]\n    eta = gp[:,1]\n    zet = gp[:,2]\n    r2 = ngp*3\n    \n    N = multiply(multiply((1-xsi),(1-eta)),(1-zet))/8.\n    N = append(N,multiply(multiply((1+xsi),(1-eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1+eta)),(1-zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1-eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1+xsi),(1+eta)),(1+zet))/8.,axis=1)\n    N = append(N,multiply(multiply((1-xsi),(1+eta)),(1+zet))/8.,axis=1)\n    \n    dNr = mat(zeros((r2,8)))\n    dNr[0:r2:3,0]= multiply(-(1-eta),(1-zet))\n    dNr[0:r2:3,1]= multiply((1-eta),(1-zet))\n    dNr[0:r2:3,2]= multiply((1+eta),(1-zet))\n    dNr[0:r2:3,3]= multiply(-(1+eta),(1-zet))\n    dNr[0:r2:3,4]= multiply(-(1-eta),(1+zet))\n    dNr[0:r2:3,5]= multiply((1-eta),(1+zet))\n    dNr[0:r2:3,6]= multiply((1+eta),(1+zet))\n    dNr[0:r2:3,7]= multiply(-(1+eta),(1+zet))\n    dNr[1:r2+1:3,0] = multiply(-(1-xsi),(1-zet))\n    dNr[1:r2+1:3,1] = multiply(-(1+xsi),(1-zet))\n    dNr[1:r2+1:3,2] = multiply((1+xsi),(1-zet))\n    dNr[1:r2+1:3,3] = multiply((1-xsi),(1-zet))\n    dNr[1:r2+1:3,4] = multiply(-(1-xsi),(1+zet))\n    dNr[1:r2+1:3,5] = multiply(-(1+xsi),(1+zet))\n    dNr[1:r2+1:3,6] = multiply((1+xsi),(1+zet))\n    dNr[1:r2+1:3,7] = multiply((1-xsi),(1+zet))\n    dNr[2:r2+2:3,0] = multiply(-(1-xsi),(1-eta))\n    dNr[2:r2+2:3,1] = multiply(-(1+xsi),(1-eta))\n    dNr[2:r2+2:3,2] = multiply(-(1+xsi),(1+eta))\n    dNr[2:r2+2:3,3] = multiply(-(1-xsi),(1+eta))\n    dNr[2:r2+2:3,4] = multiply((1-xsi),(1-eta))\n    dNr[2:r2+2:3,5] = multiply((1+xsi),(1-eta))\n    dNr[2:r2+2:3,6] = multiply((1+xsi),(1+eta))\n    dNr[2:r2+2:3,7] = multiply((1-xsi),(1+eta))\n    dNr = dNr/8.\n\n    eci = N*mat([ex,ey,ez]).T\n    if rank(ed) == 1:\n        ed = array([ed])\n        red,ced = shape(ed)\n    JT = dNr*mat([ex,ey,ez]).T\n\n    es = mat(zeros((ngp*red,3)))\n    et = mat(zeros((ngp*red,3)))\n    for i in range(ngp):\n        indx = array([3*(i+1)-2,3*(i+1)-1,3*(i+1)])\n        detJ = linalg.det(JT[indx-1,:])\n        if detJ < 10*finfo(float).eps:\n            print(""Jacobideterminanten lika med noll!"")\n        JTinv = linalg.inv(JT[indx-1,:])\n        B = JTinv*dNr[indx-1,:]\n        p1 = -D*B*ed.T\n        p2 = B*ed.T\n        es[i:ngp*red:ngp,:] = p1.T\n        et[i:ngp*red:ngp,:] = p2.T\n\n    return es,et,eci\n\ndef plante(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a triangular plane stress or plane strain element.\n    \n    Parameters:\n    \n        ex = [x1,x2,x3]         element coordinates\n        ey = [y1,y2,y3]\n     \n        ep = [ptype,t]          ptype: analysis type\n                                t: thickness\n     \n        D                       constitutive matrix\n    \n        eq = [[bx],               bx: body force x-dir\n              [by]]               by: body force y-dir\n              \n    Returns:\n    \n        Ke                      element stiffness matrix (6 x 6)\n        fe                      equivalent nodal forces (6 x 1) (if eq is given)\n\n    """"""\n\n    ptype,t = ep\n    \n    bx = 0.0\n    by = 0.0\n    \n    if not eq is None:\n        bx = eq[0]\n        by = eq[1]\n        \n    C = mat([\n        [1, ex[0], ey[0], 0,     0,     0], \n        [0,     0,     0, 1, ex[0], ey[0]],\n        [1, ex[1], ey[1], 0,     0,     0],\n        [0,     0,     0, 1, ex[1], ey[1]],\n        [1, ex[2], ey[2], 0,     0,     0],\n        [0,     0,     0, 1, ex[2], ey[2]]\n        ])\n    \n    A = 0.5*linalg.det(mat([\n        [1, ex[0], ey[0]],\n        [1, ex[1], ey[1]],\n        [1, ex[2], ey[2]]\n        ]))\n    \n    # --------- plane stress --------------------------------------\n    \n    if ptype == 1:\n        B = mat([\n            [0, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 0, 1],\n            [0, 0, 1, 0, 1, 0]\n            ])*linalg.inv(C)\n        \n        colD = D.shape[1]\n        \n        if colD > 3:\n            Cm = linalg.inv(D)\n            Dm = linalg.inv(Cm[ix_((0,1,3),(0,1,3))])\n        else:\n            Dm = D\n            \n        Ke = B.T*Dm*B*A*t\n        fe = A/3*mat([bx,by,bx,by,bx,by]).T*t\n        \n        if eq is None:\n            return Ke\n        else:\n            return Ke,fe.T\n       \n    #--------- plane strain --------------------------------------       \n    \n    elif ptype == 2:\n        B = mat([\n            [0, 1, 0, 0, 0, 0,],\n            [0, 0, 0, 0, 0, 1,],\n            [0, 0, 1, 0, 1, 0,]\n            ])*linalg.inv(C)\n\n        colD = D.shape[1]\n        \n        if colD > 3:\n            Dm = D[ix_((0,1,3),(0,1,3))]\n        else:\n            Dm = D\n\n        Ke = B.T*Dm*B*A*t\n        fe = A/3*mat([bx,by,bx,by,bx,by]).T*t\n        \n        if eq == None:\n            return Ke\n        else:\n            return Ke,fe.T\n\n    else:\n        print(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        if eq == None:\n            return None\n        else:\n            return None,None\n\ndef plants(ex,ey,ep,D,ed):\n    """"""\n    Calculate element normal and shear stress for a\n    triangular plane stress or plane strain element.\n    \n    INPUT:  ex = [x1 x2 x3]         element coordinates\n           ey = [y1 y2 y3]\n    \n           ep = [ptype t ]         ptype: analysis type\n                                   t: thickness\n    \n           D                       constitutive matrix\n    \n           ed =[u1 u2 ...u6        element displacement vector\n                ......     ]       one row for each element\n    \n    OUTPUT: es = [ sigx sigy [sigz] tauxy   element stress matrix\n                 ......                 ]  one row for each element\n    \n           et = [ epsx epsy [epsz] gamxy   element strain matrix\n                 ......                 ]  one row for each element\n    """"""\n\n    ptype=ep[0]\n    \n    if ndim(ex) == 1:\n        ex = array([ex])\n    if ndim(ey) == 1:\n        ey = array([ey])\n    if ndim(ed) == 1:\n        ed = array([ed])\n\n    rowed=ed.shape[0]\n    rowex=ex.shape[0]\n    \n    # --------- plane stress --------------------------------------\n    \n    if ptype==1:\n        \n        colD = D.shape[1]\n\n        if colD>3:\n            Cm = linalg.inv(D)\n            Dm = linalg.inv(Cm[ix_((0,1,3),(0,1,3))])\n        else:\n            Dm = D\n            \n        incie=0\n\n        if rowex==1:\n            incie=0\n        else:\n            incie=1\n      \n        et=zeros([rowed,colD])\n        es=zeros([rowed,colD])\n        \n        ie=0\n        \n        for i in range(rowed):\n            C = matrix(\n                [[1, ex[ie,0], ey[ie,0], 0, 0, 0 ], \n                 [0, 0, 0, 1, ex[ie,0], ey[ie,0] ],\n                 [1, ex[ie,1], ey[ie,1], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,1], ey[ie,1] ],\n                 [1, ex[ie,2], ey[ie,2], 0, 0, 0 ],\n                 [0, 0, 0, 1, ex[ie,2], ey[ie,2] ]]\n                )\n            \n            B = matrix([\n                [0,1,0,0,0,0],\n                [0,0,0,0,0,1],\n                [0,0,1,0,1,0]])*linalg.inv(C)\n            \n            ee=B*asmatrix(ed[ie,:]).T\n\n            if colD>3:\n                ss=zeros([colD,1])\n                ss[[0,1,3]]=Dm*ee\n                ee=Cm*ss\n            else:\n                ss=Dm*ee\n    \n            et[ie,:] = ee.T\n            es[ie,:] = ss.T\n    \n            ie = ie + incie\n            \n        return es, et\n    \ndef plantf(ex,ey,ep,es):\n    """"""\n    Compute internal element force vector in a triangular element\n    in plane stress or plane strain. \n\n    Parameters:\n\n        ex = [x1,x2,x3]                 node coordinates\n        ey = [y1,y2,y3]\n\n        ep = [ptype,t]                  ptype: analysis type\n                                        t: thickness\n\n        es = [[sigx,sigy,[sigz],tauxy]  element stress matrix\n              [  ......              ]] one row for each element\n\n    OUTPUT:\n\n        fe = [[f1],[f2],...,[f8]]       internal force vector\n\n    """"""\n\n    ptype,t = ep\n\n    colD = es.shape[1]\n\n    #--------- plane stress --------------------------------------\n\n    if ptype == 1:\n\n        C = mat([\n            [ 1, ex[0], ey[0], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[2], ey[2]]\n        ])\n\n        A = 0.5*linalg.det(mat([\n            [ 1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2]]\n        ]))\n\n        B = mat([\n            [ 0, 1, 0, 0, 0, 0],\n            [ 0, 0, 0, 0, 0, 1],\n            [ 0, 0, 1, 0, 1, 0]\n        ])*linalg.inv(C)\n    \n        if colD > 3:\n            stress = asmatrix(es[ix_((0,1,3))])\n        else:\n            stress = asmatrix(es)\n\n        ef = (A*t*B.T*stress.T).T\n        \n        return reshape(asarray(ef),6)\n\n    #--------- plane strain --------------------------------------\n    \n    elif ptype == 2:\n\n        C = mat([\n            [ 1, ex[0], ey[0], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2], 0, 0,     0    ],\n            [ 0, 0,     0,     1, ex[2], ey[2]]\n        ])\n\n        A = 0.5*linalg.det(mat([\n            [ 1, ex[0], ey[0]],\n            [ 1, ex[1], ey[1]],\n            [ 1, ex[2], ey[2]]\n        ]))\n\n        B = mat([\n            [ 0, 1, 0, 0, 0, 0],\n            [ 0, 0, 0, 0, 0, 1],\n            [ 0, 0, 1, 0, 1, 0]\n        ])*linalg.inv(C)\n\n        if colD > 3:\n            stress = asmatrix(es[ix_((1,2,4))])\n        else:\n            stress = asmatrix(es)\n\n        ef = (A*t*B.T*stress.T).T\n        \n        return reshape(asarray(ef),6)\n  \n    else:\n        print(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        return None\n\ndef platre(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a rectangular plate element.\n    NOTE! Element sides must be parallel to the coordinate axis.\n    \n    Parameters:\n\n        ex = [x1,x2,x3,x4]          element coordinates\n        ey = [y1,y2,y3,y4]\n\n        ep = [t]                    thicknes\n\n        D                           constitutive matrix for\n                                    plane stress         \n\n        eq = [qz]                   load/unit area\n    Returns:\n\n        Ke                          element stiffness matrix (12 x 12)\n        fe                          equivalent nodal forces (12 x 1)\n\n    """"""\n    Lx = (ex[2]-ex[0]).astype(float)\n    Ly = (ey[2]-ey[0]).astype(float)\n    t = ep[0]\n\n    D = t**3/12.*D\n\n    A1 = Ly/(Lx**3)\n    A2 = Lx/(Ly**3)\n    A3 = 1/Lx/Ly\n    A4 = Ly/(Lx**2)\n    A5 = Lx/(Ly**2)\n    A6 = 1/Lx\n    A7 = 1/Ly\n    A8 = Ly/Lx\n    A9 = Lx/Ly\n\n    C1 = 4*A1*D[0,0]+4*A2*D[1,1]+2*A3*D[0,1]+5.6*A3*D[2,2]\n    C2 = -4*A1*D[0,0]+2*A2*D[1,1]-2*A3*D[0,1]-5.6*A3*D[2,2]\n    C3 = 2*A1*D[0,0]-4*A2*D[1,1]-2*A3*D[0,1]-5.6*A3*D[2,2]\n    C4 = -2*A1*D[0,0]-2*A2*D[1,1]+2*A3*D[0,1]+5.6*A3*D[2,2]\n    C5 = 2*A5*D[1,1]+A6*D[0,1]+0.4*A6*D[2,2]\n    C6 = 2*A4*D[0,0]+A7*D[0,1]+0.4*A7*D[2,2]\n    \n    C7 = 2*A5*D[1,1]+0.4*A6*D[2,2]\n    C8 = 2*A4*D[0,0]+0.4*A7*D[2,2]\n    C9 = A5*D[1,1]-A6*D[0,1]-0.4*A6*D[2,2]\n    C10 = A4*D[0,0]-A7*D[0,1]-0.4*A7*D[2,2]\n    C11 = A5*D[1,1]-0.4*A6*D[2,2]\n    C12 = A4*D[0,0]-0.4*A7*D[2,2]\n    \n    C13 = 4/3.*A9*D[1,1]+8/15.*A8*D[2,2]\n    C14 = 4/3.*A8*D[0,0]+8/15.*A9*D[2,2]\n    C15 = 2/3.*A9*D[1,1]-8/15.*A8*D[2,2]\n    C16 = 2/3.*A8*D[0,0]-8/15.*A9*D[2,2]\n    C17 = 2/3.*A9*D[1,1]-2/15.*A8*D[2,2]\n    C18 = 2/3.*A8*D[0,0]-2/15.*A9*D[2,2]\n    C19 = 1/3.*A9*D[1,1]+2/15.*A8*D[2,2]\n    C20 = 1/3.*A8*D[0,0]+2/15.*A9*D[2,2]\n    C21 = D[0,1]\n\n    Keq = mat(zeros((12,12)))\n    Keq[0,0:13] = C1,C5,-C6,C2,C9,-C8,C4,C11,-C12,C3,C7,-C10\n    Keq[1,1:13] = C13,-C21,C9,C15,0,-C11,C19,0,-C7,C17,0\n    Keq[2,2:13] = C14,C8,0,C18,C12,0,C20,-C10,0,C16\n    Keq[3,3:13] = C1,C5,C6,C3,C7,C10,C4,C11,C12\n    Keq[4,4:13] = C13,C21,-C7,C17,0,-C11,C19,0\n    Keq[5,5:13] = C14,C10,0,C16,-C12,0,C20\n    Keq[6,6:13] = C1,-C5,C6,C2,-C9,C8\n    Keq[7,7:13] = C13,-C21,-C9,C15,0\n    Keq[8,8:13] = C14,-C8,0,C18\n    Keq[9,9:13] = C1,-C5,-C6\n    Keq[10,10:13] = C13,C21\n    Keq[11,11] = C14\n    Keq = Keq.T+Keq-diag(diag(Keq))\n\n    if eq != None:\n        q = eq\n        R1 = q*Lx*Ly/4\n        R2 = q*Lx*Ly**2/24\n        R3 = q*Ly*Lx**2/24\n\n        feq = mat([R1,R2,-R3,R1,R2,R3,R1,-R2,R3,R1,-R2,-R3])\n\n    if eq != None:\n        return Keq,feq\n    else:\n        return Keq\n\n        \ndef planqe(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a quadrilateral\n    plane stress or plane strain element.\n\n    Parameters:\n        ex=[x1 x2 x3 x4]    element coordinates\n        ey=[y1 y2 y3 y4]\n                                \n        ep = [ptype, t]     ptype: analysis type\n                            t: element thickness \n\n        D                   constitutive matrix\n\n        eq = [bx;           bx: body force in x direction\n              by]           by: body force in y direction\n\n    OUTPUT: Ke :  element stiffness matrix (8 x 8)\n            fe : equivalent nodal forces (row array)\n    """"""\n    K=zeros((10,10))\n    f=zeros((10,1))\n    \n    xm=sum(ex)/4.\n    ym=sum(ey)/4.\n    \n    b1 = eq if eq is not None else array([[0],[0]])\n    \n    ke1, fe1 = plante(array([ex[0], ex[1], xm]), array([ey[0], ey[1], ym]), ep, D, b1)\n    K, f = assem(array([1, 2, 3, 4, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(array([ex[1], ex[2], xm]), array([ey[1], ey[2], ym]), ep, D, b1)\n    K, f = assem(array([3, 4, 5, 6, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(array([ex[2], ex[3], xm]), array([ey[2], ey[3], ym]), ep, D, b1)\n    K, f = assem(array([5, 6, 7, 8, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(array([ex[3], ex[0], xm]), array([ey[3], ey[0], ym]), ep, D, b1)\n    K, f = assem(array([7, 8, 1, 2, 9, 10]), K, ke1, f, fe1)\n    Ke, fe = statcon(K, f, array([[9],[10]]))\n    \n    if eq == None:\n        return Ke\n    else:\n        return Ke,fe\n        \n\ndef planqs(ex,ey,ep,D,ed,eq=None):\n    """"""\n    Calculate element normal and shear stress for a quadrilateral \n    plane stress or plane strain element.\n    \n    Parameters:\n            ex = [x1 x2 x3 x4]      element coordinates\n            ey = [y1 y2 y3 y4]\n    \n            ep = [ptype, t]         ptype: analysis type\n                                    t:  thickness\n                                   \n            D                       constitutive matrix\n    \n            ed = [u1 u2 ..u8]       element displacement vector\n    \n            eq = [[bx]               bx: body force in x direction\n                  [by]]              by: body force in y direction\n    \n    OUTPUT: es = [ sigx sigy (sigz) tauxy]    element stress array\n            et = [ epsx epsy (epsz) gamxy]    element strain array\n    """"""\n    \n    if ex.shape != (4,) or ey.shape != (4,) or ed.shape != (8,):\n        raise ValueError(\'Error ! PLANQS: only one element at the time (ex, ey, ed must be a row arrays)\')\n\n    K = zeros((10,10))\n    f = zeros((10,1))\n    \n    xm = sum(ex)/4.\n    ym = sum(ey)/4.\n        \n    b1 = eq if eq is not None else array([[0],[0]])\n    \n    ex1 = array([ex[0], ex[1], xm]) \n    ey1 = array([ey[0], ey[1], ym])\n    ex2 = array([ex[1], ex[2], xm]) \n    ey2 = array([ey[1], ey[2], ym])\n    ex3 = array([ex[2], ex[3], xm]) \n    ey3 = array([ey[2], ey[3], ym])\n    ex4 = array([ex[3], ex[0], xm]) \n    ey4 = array([ey[3], ey[0], ym])\n    \n    ke1, fe1 = plante(ex1, ey1, ep, D, b1)\n    K, f = assem(array([1, 2, 3, 4, 9, 10]), K, ke1, f, fe1)\n    ke1,fe1 = plante(ex2, ey2, ep, D, b1)\n    K, f = assem(array([3, 4, 5, 6, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(ex3, ey3, ep, D, b1)\n    K, f = assem(array([5, 6, 7, 8, 9, 10]), K, ke1, f, fe1)\n    ke1, fe1 = plante(ex4, ey4, ep, D, b1)\n    K, f = assem(array([7, 8, 1, 2, 9, 10]), K, ke1, f, fe1)\n    \n    A1 = 0.5 * linalg.det( hstack([ones((3,1)), mat(ex1).T, mat(ey1).T]) )\n    A2 = 0.5 * linalg.det( hstack([ones((3,1)), mat(ex2).T, mat(ey2).T]) )\n    A3 = 0.5 * linalg.det( hstack([ones((3,1)), mat(ex3).T, mat(ey3).T]) )\n    A4 = 0.5 * linalg.det( hstack([ones((3,1)), mat(ex4).T, mat(ey4).T]) )\n    Atot = A1+A2+A3+A4;\n    \n    \n    a, _ = solveq(K, f, array(range(1,9)), ed)\n        \n#    ni = ed.shape[0]\n#    a = mat(empty((10,ni)))\n#    for i in range(ni):\n#        a[:,i] = solveq(K, f, array(range(1,9)), ed[i,:])[0]\n#        #a = hstack([a, solveq(K, f, hstack([matrix(range(1,9)).T, ed[i,:].T]) ) ])\n    \n    s1, t1 = plants(ex1, ey1, ep, D, hstack([a[[0, 1, 2, 3, 8, 9], :].T]) );\n    s2, t2 = plants(ex2, ey2, ep, D, hstack([a[[2, 3, 4, 5, 8, 9], :].T]) );\n    s3, t3 = plants(ex3, ey3, ep, D, hstack([a[[4, 5, 6, 7, 8, 9], :].T]) );\n    s4, t4 = plants(ex4, ey4, ep, D, hstack([a[[6, 7, 0, 1, 8, 9], :].T]) );\n    \n    es = (s1*A1+s2*A2+s3*A3+s4*A4)/Atot;\n    et = (t1*A1+t2*A2+t3*A3+t4*A4)/Atot;\n    \n    return es[0], et[0] #[0] because these are 1-by-3 arrays and we want row arrays out.\n\n\ndef plani4e(ex,ey,ep,D,eq=None):\n    """"""\n    Calculate the stiffness matrix for a 4 node isoparametric\n    element in plane strain or plane stress.\n    \n    Parameters:\n        ex = [x1 ...   x4]  element coordinates. Row array\n        ey = [y1 ...   y4]\n                                \n        ep =[ptype, t, ir]  ptype: analysis type\n                            t : thickness\n                            ir: integration rule\n    \n        D                   constitutive matrix\n    \n        eq = [bx; by]       bx: body force in x direction\n                            by: body force in y direction\n                                Any array with 2 elements acceptable\n    \n    Returns:\n        Ke : element stiffness matrix (8 x 8)\n        fe : equivalent nodal forces (8 x 1)\n    """"""\n    ptype=ep[0] \n    t=ep[1]  \n    ir=ep[2]  \n    ngp=ir*ir\n    if eq == None:\n        q = zeros((2,1))\n    else:\n        q = reshape(eq, (2,1))\n#--------- gauss points --------------------------------------    \n    if ir == 1:\n        g1 = 0.0\n        w1 = 2.0\n        gp = mat([g1,g1])\n        w = mat([w1,w1])\n    elif ir == 2:\n        g1 = 0.577350269189626\n        w1 = 1\n        gp = mat([\n            [-g1,-g1],\n            [ g1,-g1],\n            [-g1, g1],\n            [ g1, g1]])\n        w = mat([\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1],\n            [ w1, w1]])\n    elif ir == 3:\n        g1 = 0.774596669241483\n        g2 = 0.\n        w1 = 0.555555555555555\n        w2 = 0.888888888888888\n        gp = mat([\n            [-g1,-g1],\n            [-g2,-g1],\n            [ g1,-g1],\n            [-g1, g2],\n            [ g2, g2],\n            [ g1, g2],\n            [-g1, g1],\n            [ g2, g1],\n            [ g1, g1]])\n        w = mat([\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1],\n            [ w1, w2],\n            [ w2, w2],\n            [ w1, w2],\n            [ w1, w1],\n            [ w2, w1],\n            [ w1, w1]])\n    else:\n        print(""Used number of integration points not implemented"")\n    wp = multiply(w[:,0],w[:,1])\n    xsi = gp[:,0]\n    eta = gp[:,1]\n    r2 = ngp*2\n    # Shape Functions\n    N = multiply((1-xsi),(1-eta))/4.\n    N = append(N,multiply((1+xsi),(1-eta))/4.,axis=1)\n    N = append(N,multiply((1+xsi),(1+eta))/4.,axis=1)\n    N = append(N,multiply((1-xsi),(1+eta))/4.,axis=1)\n    \n    dNr = mat(zeros((r2,4)))\n    dNr[0:r2:2,0] = -(1-eta)/4.\n    dNr[0:r2:2,1] = (1-eta)/4.\n    dNr[0:r2:2,2] = (1+eta)/4.\n    dNr[0:r2:2,3] = -(1+eta)/4.\n    dNr[1:r2+1:2,0] = -(1-xsi)/4.\n    dNr[1:r2+1:2,1] = -(1+xsi)/4.\n    dNr[1:r2+1:2,2] = (1+xsi)/4.\n    dNr[1:r2+1:2,3] = (1-xsi)/4.\n\n#\n    Ke1 = mat(zeros((8,8)))\n    fe1 = mat(zeros((8,1)))\n    JT = dNr*mat([ex,ey]).T \n    # --------- plane stress --------------------------------------\n    if ptype==1:\n        colD=shape(D)[0]\n        if colD>3:\n            Cm=linalg.inv(D)\n            Dm=linalg.inv(Cm[ ix_([0,1,3],[0,1,3]) ])\n        else:\n            Dm=D          \n#\n        B=matrix(zeros((3,8)))\n        N2=matrix(zeros((2,8)))\n        for i in range(ngp):\n            indx = array([2*(i+1)-1,2*(i+1)])\n            detJ = linalg.det(JT[indx-1,:])\n            if detJ < 10*finfo(float).eps:\n                print(""Jacobideterminant equal or less than zero!"")\n            JTinv = linalg.inv(JT[indx-1,:])  \n            dNx=JTinv*dNr[indx-1,:]\n#   \n            index_array_even=array([0,2,4,6])\n            index_array_odd=array([1,3,5,7])\n#    \n            counter=0    \n            for index in index_array_even:      \n                B[0,index] = dNx[0,counter]\n                B[2,index] = dNx[1,counter]\n                N2[0,index]=N[i,counter]\n                counter=counter+1\n#\n            counter=0    \n            for index in index_array_odd:\n                B[1,index]   = dNx[1,counter]\n                B[2,index]   = dNx[0,counter]\n                N2[1,index]  =N[i,counter]\n                counter=counter+1\n#   \n            Ke1 = Ke1+B.T*Dm*B*detJ*asscalar(wp[i])*t\n            fe1 = fe1 + N2.T * q * detJ * asscalar(wp[i]) * t\n\n        return Ke1,fe1\n#--------- plane strain --------------------------------------\n    elif ptype==2:\n#      \n        colD=shape(D)[0]\n        if colD>3:\n            Dm = D[ix_([0,1,3],[0,1,3])]\n        else:\n            Dm = D\n#\n        B=matrix(zeros((3,8)))\n        N2=matrix(zeros((2,8)))\n        for i in range(ngp):\n            indx = array([2*(i+1)-1,2*(i+1)])\n            detJ = linalg.det(JT[indx-1,:])\n            if detJ < 10*finfo(float).eps:\n                print(""Jacobideterminant equal or less than zero!"")\n            JTinv = linalg.inv(JT[indx-1,:])  \n            dNx=JTinv*dNr[indx-1,:]\n#   \n            index_array_even=array([0,2,4,6])\n            index_array_odd=array([1,3,5,7])\n#    \n            counter=0    \n            for index in index_array_even:\n#\n                B[0,index] = dNx[0,counter]\n                B[2,index] = dNx[1,counter]\n                N2[0,index]=N[i,counter]\n#\n                counter=counter+1\n#\n            counter=0    \n            for index in index_array_odd:\n                B[1,index]   = dNx[1,counter]\n                B[2,index]   = dNx[0,counter]\n                N2[1,index]  =N[i,counter]\n                counter=counter+1\n#   \n            Ke1 = Ke1 + B.T * Dm * B * detJ * asscalar(wp[i]) * t\n            fe1 = fe1+N2.T*q*detJ*asscalar(wp[i])*t\n        return Ke1,fe1\n    else:\n        print(""Error ! Check first argument, ptype=1 or 2 allowed"")\n        \n        \ndef assem(edof,K,Ke,f=None,fe=None):\n    """"""\n    Assemble element matrices Ke ( and fe ) into the global\n    stiffness matrix K ( and the global force vector f )\n    according to the topology matrix edof.\n    \n    Parameters:\n    \n        edof        dof topology array\n        K           the global stiffness matrix\n        Ke          element stiffness matrix\n        f           the global force vector\n        fe          element force vector\n        \n    Output parameters:\n    \n        K           the new global stiffness matrix\n        f           the new global force vector\n        fe          element force vector\n    \n    """"""\n    \n    if rank(edof) == 1:\n        idx = edof-1\n        K[ix_(idx,idx)] = K[ix_(idx,idx)] + Ke\n        if (not f is None) and (not fe is None):\n            f[ix_(idx)] = f[ix_(idx)] + fe\n    else:\n        for row in edof:\n            idx = row-1\n            K[ix_(idx,idx)] = K[ix_(idx,idx)] + Ke\n            if (not f is None) and (not fe is None):\n                f[ix_(idx)] = f[ix_(idx)] + fe\n            \n    if f is None:\n        return K\n    else:\n        return K,f\n            \ndef solveq(K,f,bcPrescr,bcVal=None):\n    """"""\n    Solve static FE-equations considering boundary conditions.\n    \n    Parameters:\n    \n        K           global stiffness matrix, dim(K)= nd x nd\n        f           global load vector, dim(f)= nd x 1\n    \n        bcPrescr    1-dim integer array containing prescribed dofs.\n        bcVal       1-dim float array containing prescribed values.\n                    If not given all prescribed dofs are assumed 0.\n        \n    Returns:\n    \n        a           solution including boundary values\n        Q           reaction force vector\n                    dim(a)=dim(Q)= nd x 1, nd : number of dof\'s\n    \n    """"""    \n    \n    nDofs = K.shape[0]\n    nPdofs = bcPrescr.shape[0]\n    \n    if bcVal is None:\n        bcVal = zeros([nPdofs],\'d\')\n    \n    bc = ones(nDofs, \'bool\')    \n    bcDofs = arange(nDofs)\n    \n    bc[ix_(bcPrescr-1)] = False\n    bcDofs = bcDofs[bc]\n    \n    fsys = f[bcDofs]-K[ix_((bcDofs),(bcPrescr-1))]*asmatrix(bcVal).reshape(nPdofs,1)\n    asys = linalg.solve(K[ix_((bcDofs),(bcDofs))], fsys);\n    \n    a = zeros([nDofs,1])\n    a[ix_(bcPrescr-1)] = asmatrix(bcVal).reshape(nPdofs,1)\n    a[ix_(bcDofs)] = asys\n    \n    Q=K*asmatrix(a)-f\n    \n    return (asmatrix(a),Q)\n    \ndef extractEldisp(edof,a):\n    """"""\n    Extract element displacements from the global displacement\n    vector according to the topology matrix edof.\n    \n    Parameters:\n    \n        a           the global displacement vector\n        edof        dof topology array\n    \n    Returns:\n    \n        ed:     element displacement array\n    \n    """"""\n\n    ed = None\n    \n    if rank(edof)==1:\n        nDofs = len(edof)\n        ed = zeros([nDofs])\n        idx = edof-1\n        ed[:] = a[ix_(idx)].T\n    else:\n        nElements = edof.shape[0]\n        nDofs = edof.shape[1]\n        ed = zeros([nElements,nDofs])\n        i=0\n        for row in edof:\n            idx = row-1\n            ed[i,:]=a[ix_(idx)].T\n            i+=1\n        \n    return ed\n\ndef statcon(K,f,cd):\n    """"""\n    Condensation of static FE-equations according to the vector cd.\n\n    Parameters:\n    \n        K                       global stiffness matrix, dim(K) = nd x nd\n        f                       global load vector, dim(f)= nd x 1\n\n        cd                      vector containing dof\'s to be eliminated\n                                dim(cd)= nc x 1, nc: number of condensed dof\'s\n    Returns:\n    \n        K1                      condensed stiffness matrix,\n                                dim(K1)= (nd-nc) x (nd-nc)\n        f1                      condensed load vector, dim(f1)= (nd-nc) x 1\n    """"""\n    nd,nd = shape(K)\n    cd = (cd-1).flatten()\n  \n    aindx = arange(nd)\n    aindx = delete(aindx,cd,0)\n    bindx = cd\n\n    Kaa = mat(K[ix_(aindx,aindx)])\n    Kab = mat(K[ix_(aindx,bindx)])\n    Kbb = mat(K[ix_(bindx,bindx)])\n\n    fa = mat(f[aindx])\n    fb = mat(f[bindx])\n    \n    K1 = Kaa-Kab*Kbb.I*Kab.T\n    f1 = fa-Kab*Kbb.I*fb\n    \n    return K1,f1\n\ndef c_mul(a, b):\n    return eval(hex((long(a) * b) & 0xFFFFFFFF)[:-1])\n\ndef dofHash(dof):\n    if len(dof)==1:\n        return dof[0]\n    value = 0x345678\n    for item in dof:\n        value = c_mul(1000003, value) ^ hash(item)\n    value = value ^ len(dof)\n    if value == -1:\n        value = -2\n    return value\n\ndef createdofs(nCoords,nDof):\n    """"""\n    Create dof array [nCoords x nDof]\n    """"""\n    return arange(nCoords*nDof).reshape(nCoords,nDof)+1\n\ndef coordxtr(edof,coords,dofs):\n    """"""\n    Create element coordinate matrices ex, ey, ez from edof\n    coord and dofs matrices.\n    \n    Parameters:\n    \n        edof            [nel x (nen * nnd)], nnd = number of node dofs\n        coords          [ncoords x ndims],   ndims = node dimensions\n        dofs            [ncoords x nnd]\n        \n    Returns:\n    \n        ex              if ndims = 1\n        ex, ey          if ndims = 2\n        ex, ey, ez      if ndims = 3\n    """"""\n    \n    # Create dictionary with dof indices\n    \n    dofDict = {}\n    nDofs = size(dofs,1)\n    nElements = size(edof,0)\n    nDimensions = size(coords,1)\n    nElementDofs = size(edof,1)\n    \n    nElementNodes = int(nElementDofs/nDofs)\n    \n    idx = 0\n    for dof in dofs:\n        dofDict[dofHash(dof)] = idx\n        idx += 1\n              \n    # Loop over edof and extract element coords\n    \n    ex = zeros((nElements,nElementNodes))\n    ey = zeros((nElements,nElementNodes))\n    ez = zeros((nElements,nElementNodes))\n    \n    elementIdx = 0\n    for etopo in edof:\n        for i in range(nElementNodes):\n            i0 = i*nDofs\n            i1 = i*nDofs+nDofs-1\n            dof = []\n            if i0==i1:\n                dof = [etopo[i*nDofs]]\n            else:\n                dof = etopo[i*nDofs:(i*nDofs+nDofs)]\n            \n            nodeCoord = coords[dofDict[dofHash(dof)]]\n            \n            if nDimensions>=1:\n                ex[elementIdx,i] = nodeCoord[0]\n            if nDimensions>=2:\n                ey[elementIdx,i] = nodeCoord[1]\n            if nDimensions>=3:\n                ez[elementIdx,i] = nodeCoord[2]\n            \n        elementIdx += 1\n        \n    if nDimensions==1:\n        return ex\n    \n    if nDimensions==2:\n        return ex, ey\n    \n    if nDimensions==3:\n        return ex, ey, ez\n\ndef hooke(ptype,E,v):\n    """"""\n    Calculate the material matrix for a linear\n    elastic and isotropic material.\n    \n    Parameters:\n    \n        ptype=  1:  plane stress\n                2:  plane strain\n                3:  axisymmetry\n                4:  three dimensional\n    \n        E           Young\'s modulus\n        v           Poissons const.\n        \n    Returns:\n    \n        D           material matrix\n    \n    """"""\n   \n    if ptype == 1:\n        D = E*matrix(\n            [[1, v, 0],\n             [v, 1, 0],\n             [0, 0, (1-v)/2]]\n            )/(1-v**2);\n    elif ptype == 2:\n        D = E/(1+v)*matrix(\n            [[1-v, v, v, 0],\n             [v, 1-v, v, 0],\n             [v, v, 1-v, 0],\n             [0, 0, 0, (1-2*v)/2]]\n            )/(1-2*v)\n    elif ptype == 3:\n        D = E/(1+v)*matrix(\n            [[1-v, v, v, 0],\n             [v, 1-v, v, 0],\n             [v, v, 1-v, 0],\n             [0, 0, 0, (1-2*v)/2]]\n            )/(1-2*v)\n    elif ptype == 4:\n        D = E*matrix(\n            [[1-v, v, v, 0, 0, 0],\n             [v, 1-v, v, 0, 0, 0],\n             [v, v, 1-v, 0, 0, 0],\n             [0, 0, 0, (1-2*v)/2, 0, 0],\n             [0, 0, 0, 0, (1-2*v)/2, 0],\n             [0, 0, 0, 0, 0, (1-2*v)/2]]\n            )/(1+v)/(1-2*v)\n    else:\n        print(""ptype not supported."")\n        \n    return D\n\ndef effmises(es,ptype):\n    """"""\n    Calculate effective von mises stresses.\n    \n    Parameters:\n        \n        es\n    \n        ptype=  1:  plane stress\n                2:  plane strain\n                3:  axisymmetry\n                4:  three dimensional\n    \n       es = [[sigx,sigy,[sigz],tauxy]  element stress matrix\n              [  ......              ]] one row for each element\n              \n    Returns:\n    \n        eseff  = [eseff_0 .. eseff_nel-1]\n    \n    """"""\n    \n    nel = size(es,0)\n    escomps = size(es, 1)\n    \n    eseff = zeros([nel])\n     \n    if ptype == 1:\n        sigxx = es[:,0]\n        sigyy = es[:,1]\n        sigxy = es[:,2]\n        eseff = sqrt(sigxx*sigxx+sigyy*sigyy-sigxx*sigyy+3*sigxy*sigxy)\n        return eseff\n    \ndef stress2nodal(eseff, edof):\n    """"""\n    Convert element effective stresses to nodal effective\n    stresses.\n    \n    Parameters:\n        \n        eseff  = [eseff_0 .. eseff_nel-1] \n        edof   = [dof topology array]\n    \n    Returns:\n    \n        ev:     element value array [[ev_0_0 ev_0_1 ev_0_nen-1 ]\n                                      ..\n                                      ev_nel-1_0 ev_nel-1_1 ev_nel-1_nen-1]\n                      \n    """"""\n    \n    values = zeros(edof.max())\n    elnodes = size(edof,1) / 2\n    \n    for etopo, eleseff in zip(edof, eseff):\n        values[etopo-1] = values[etopo-1] + eleseff / elnodes\n        \n    evtemp = extractEldisp(edof,values)\n    ev = evtemp[:,range(0,elnodes*2,2)]\n                     \n    return ev'"
old/pycalfem_GeoData.py,0,"b'#TODO: Consider adding more checks whether entities exist.\n\nclass GeoData:\n    \'\'\'\n    Instances of GeoData can hold geometric data and be passed to \n    GmshMesher in pycalfem_Mesh to mesh the geometry.\n    \'\'\'\n\n    def __init__(self):\n        self.points = {}    #dict of [[x, y, z], elSize, marker]\n        self.curves = {}    #dict of [curvTypestring, [p1, p2, ... pn], marker, elementsOnCurve, distributionString, distributionVal]\n        self.surfaces = {}  #dict of [SurfaceTypeString, [c1, c2 ... cn], [[c1, c2 ... cm], ... [c1, ... ck]], ID, marker, isStructured]. c means curve-ID.\n        self.volumes = {}   #dict of [[s1, s2 ..], [[s1,s2...],[s1,s2..],..], ID, marker, isStructured]    \n        self.is3D = False   #This is automatically set to True if a 3D point is added.\n        self._pointIDspecified = False\n        self._nextPointID = 0\n        self._curveIDspecified = False\n        self._nextcurveID = 0\n        self._surfaceIDspecified = False\n        self._nextsurfaceID = 0\n        self._volumeIDspecified = False\n        self._nextvolumeID = 0\n    \n    \n    def removePoint(self, ID):\n        \'\'\'Removes the point with this ID\'\'\'\n        self.points.pop(ID)\n    \n    \n    def removeCurve(self, ID):\n        \'\'\'Removes the curve with this ID\'\'\'\n        self.curve.pop(ID)\n    \n    \n    def removeSurface(self, ID):\n        \'\'\'Removes the surface with this ID\'\'\'\n        self.surfaces.pop(ID)\n    \n    \n    def removeVolume(self, ID):\n        \'\'\'Removes the volume with this ID\'\'\'\n        self.volumes.pop(ID)\n    \n    \n    def getPointCoords(self, IDs=None):\n        \'\'\'\n        Returns an N-by-3 list of point coordinates if the parameter is\n        a list of IDs. If the parameter is just a single integer then \n        a single coordinate (simple 3-element list) is returned.\n        If the parameter is undefined (or None) all point coords will be returned\n        \'\'\'\n        if IDs == None:\n            return [p[0] for p in self.points.values()]\n        try:\n            pointCoords = [self.points[pID][0] for pID in IDs]\n        except TypeError: #IDs was not iterable. Probably just a single ID.\n            pointCoords = self.points[IDs][0]\n        return pointCoords\n    \n    \n    def pointsOnCurves(self, IDs):\n        \'\'\'\n        Returns a list of all geometric points (not nodes) on the curves\n        specified in IDs. IDs may be an integer or a list of integers.\n        \'\'\'\n        return self._subentitiesOnEntities(IDs, self.curves, 1)\n    \n    \n    def stuffOnSurfaces(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points and curves on the surfaces\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        curveSet = self._subentitiesOnEntities(IDs, self.surfaces, 1) #Curves on the outer edges\n        curveSet.update( self._subentityHolesOnEntities(IDs, self.surfaces, 2) ) #Curves on the holes\n        pointList = self.pointsOnCurves(curveSet) #Points on the curves of these surfaces.\n        return pointList, list(curveSet)\n        \n    def stuffOnVolumes(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points, curves, and surfaces on the volumes\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        surfaceSet = self._subentitiesOnEntities(IDs, self.surfaces, 0)\n        surfaceSet.update( self._subentitiesOnEntities(IDs, self.surfaces, 1) )\n        pointList, curveList = self.stuffOnSurfaces(surfaceSet)\n        return pointList, curveList, list(surfaceSet)\n    \n    def _subentitiesOnEntities(self, IDs, entityDict, index):\n        \'\'\'\n        Duplicate code. Gets the IDs of the subentities that\n        make up an entity, i.e. the points that define a curve or\n        the curves that define a surface. Note that only the outer\n        subentities of surfaces and volumes can be extracted with\n        this function. For holes use _subentityHolesOnEntities().\n        \'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                theSet.update(entityDict[ID][index])\n        except TypeError: #IDs is not iterable, so it is probably a single ID\n            theSet.update(entityDict[IDs][index])\n        return theSet\n    \n    def _subentityHolesOnEntities(self, IDs, entityDict, index):\n        \'\'\'Duplicate code. Does the same thing as _subentitiesOnEntities(), but for holes\'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                for hole in entityDict[ID][index]:\n                    theSet.update(hole)\n        except TypeError: #IDs is not iterable, so it is probably a single ID\n            for hole in entityDict[IDs][index]:\n                theSet.update(hole)\n        return theSet\n        \n    \n    def addPoint(self, coord, ID=None, marker=0, elSize=1):\n        \'\'\'\n        Adds a point.\n        \n        Parameters:\n        coord     - [x, y] or [x, y, z].\n                    List, not array.\n        \n        ID        - Positive integer ID of this point. If left unspecified the\n                    point will be assigned the smallest unused point-ID.\n                    It is recommended to specify all point-IDs or none.\n                    \n        marker    - Marker applied to this point. Default 0.\n                    It is not a good idea to apply non-zero markers to points\n                    that are control points on B-splines or center points on \n                    circles/ellipses, since this can lead to ""loose"" nodes\n                    that are not part of any elements.\n        \n        elSize    - The size of elements at this point. Default 1. Use to make\n                    a mesh denser or sparser here. Only affects unstructured\n                    meshes\n        \'\'\'\n        if len(coord)==3: #A 3D point is inserted.\n            self.is3D = True \n        else: #The point is in 2D (we assume)\n            coord = coord+[0] #Pad with a 0. (we store points as 3D points for consistency\'s sake)\n            \n        if ID==None: #ID is not specified. Get an ID for this point:\n            ID = self._getNewPointID()\n        else:\n            self._pointIDspecified = True\n            \n        self.points[ID] = [coord, elSize, marker]\n    \n    \n    def addSpline(self, points, ID=None, marker=0, elOnCurve=None, elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Spline curve\n        \n        points    - List of indices of control points that make a Spline\n                    [p1, p2, ... , pn]\n                    \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""Spline"", points, ID, marker, elOnCurve, elDistribType, elDistribVal)\n        \n        \n    def addBSpline(self, points, ID=None, marker=0, elOnCurve=None,  elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a B-Spline curve\n        \n        points    - List of indices of control points that make a B-spline\n                    [p1, p2, ... , pn]\n                    \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""BSpline"", points, ID, marker, elOnCurve,  elDistribType, elDistribVal)\n\n\n    def addCircle(self, points, ID=None, marker=0, elOnCurve=None,  elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Circle arc curve.\n        \n        points    - list of 3 indices of point that make a circle arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, endpoint]\n        \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Elements on curve.\n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes.\n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        if len(points) != 3:\n            raise IndexError(""Circle: points must be a list of 3 positive integers denoting point indices"")\n        self._addCurve(""Circle"", points, ID, marker, elOnCurve,  elDistribType, elDistribVal)\n        \n        \n    def addEllipse(self, points, ID=None, marker=0, elOnCurve=None, elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Ellipse arc curve.\n        \n        points    - List of 4 indices of point that make a ellipse arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, mAxisPoint, endpoint]\n                    Startpoint is the starting point of the arc.\n                    Centerpoint is the point at the center of the ellipse.\n                    MAxisPoint is any point on the major axis of the ellipse.\n                    Endpoint is the end point of the arc.\n        \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.                      \n        \'\'\'\n        if len(points) != 4:\n            raise IndexError(""Ellipse: points must be a list of 4 positive integers denoting point indices"")\n        self._addCurve(""Ellipse"", points, ID, marker, elOnCurve, elDistribType, elDistribVal)\n\n        \n    def _addCurve(self, name, points, ID, marker, elOnCurve, elDistribType, elDistribVal):\n        \'\'\'Duplicate code goes here!\'\'\'\n        if ID==None:\n            ID = self._getNewCurveID()\n        else:\n            self._curveIDspecified = True\n        \n        if elDistribType != None:\n            elDistribType = elDistribType.lower().title() #transform into lowercase except the first letter upper case.\n            if elDistribType not in [""Bump"", ""Progression""]:\n                raise ValueError(""elDistribType must be a string, either \\""bump\\"" or \\""progression\\"". Curve with ID=%i was incorrect."" %ID)\n            if elDistribVal == None:\n                raise ValueError(""If elDistribType is defined then elDistribVal must be given a (float) value"")\n        \n        self.curves[ID] = [name, points, marker, elOnCurve, elDistribType, elDistribVal]\n    \n    def addSurface(self, outerLoop, holes=[], ID=None, marker=0):\n        \'\'\'\n        Adds a plane surface (flat).\n        Parameters:\n        outerLoop - List of curve IDs that make up the outer boundary of\n                    the surface. The curves must lie in the same plane.\n        \n        holes     - List of lists of curve IDs that make up the inner\n                    boundaries of the surface. The curves must lie in the\n                    same plane. \n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        #TODO: Possibly check if outerLoop is an actual loop and if the holes are correct.\n        self._addSurf(""Plane Surface"", outerLoop, holes, ID, marker, isStructured=False)\n        \n        \n    def addRuledSurface(self, outerLoop, ID=None, marker=0):\n        \'\'\'\n        Adds a Ruled Surface (bent surface).\n        Parameters:\n        outerLoop - List of 3 or 4 curve IDs that make up the boundary of\n                    the surface.\n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        if len(outerLoop) not in [3, 4]:\n            raise IndexError(""Ruled Surface: outerloop must be a list of 3 or 4 positive integers denoting curve indices"")\n        self._addSurf(""Ruled Surface"", outerLoop, [], ID, marker, isStructured=False)\n    \n    \n    def addStructuredSurface(self, outerLoop, ID=None, marker=0):\n        \'\'\'\n        Adds a Structured Surface.\n        Parameters:\n        outerLoop - List of 4 curve IDs that make up the boundary of\n                    the surface. The curves must be structured, i.e. their\n                    parameter \'elOnCurv\' must be defined.\n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        self._checkIfProperStructuredQuadBoundary(outerLoop, ID)\n        self._addSurf(""Ruled Surface"", outerLoop, [], ID, marker, isStructured=True) \n    \n    \n    def _addSurf(self, name, outerLoop, holes, ID, marker, isStructured):\n        \'\'\'For duplicate code\'\'\'\n        #TODO: check if the curves in outerloop actually exist. Maybe print a warning.\n        if ID==None:\n            ID = self._getNewSurfaceID()\n        else:\n            self._surfaceIDspecified = True\n            \n        for hole in holes: #Catch the easy mistake of making holes a list of ints rather than a list of lists of ints.\n            try:\n                [h for h in hole]\n            except TypeError:\n                raise TypeError(""Hole "" + str(hole) + "" is not iterable. Parameter holes must be a list of lists of integers"")\n        \n        self.surfaces[ID] = [name, outerLoop, holes, ID, marker, isStructured]\n    \n    \n    def addVolume(self, outerSurfaces, holes=[], ID=None, marker=0):\n        \'\'\'Adds a Volume\n        Parameters:\n        outerSurfaces - List of surface IDs that make up the outer boundary of\n                        the volume.\n        \n        holes         - List of lists of surface IDs that make up the inner\n                        boundaries of the volume.\n                    \n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n                    \n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        self._addVolume(outerSurfaces, holes, ID, marker, isStructured=False)\n    \n    \n    def addStructuredVolume(self, outerSurfaces, ID=None, marker=0):\n        \'\'\'Adds a Structured Volume\n        Parameters:\n        outerSurfaces - List of surface IDs that make up the outer boundary of\n                        the volume. The surfaces must be Structured Surfaces.\n                    \n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n                    \n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        #TODO: Check input. (see if surfaces are structured)\n        self._addVolume(outerSurfaces, [], ID, marker, isStructured=True)\n    \n    \n    def _addVolume(self,  outerSurfaces, holes, ID, marker, isStructured):\n        \'\'\'Duplicate code\'\'\'\n        #TODO: Check input (outerSurfaces and holes[i] must be closed surfaces)\n        if ID==None:\n            ID = self._getNewVolumeID()\n        else:\n            self._volumeIDspecified = True\n        self.volumes[ID] = [outerSurfaces, holes, ID, marker, isStructured] \n        \n        \n    def setPointMarker(self, ID, marker):\n        \'\'\'Sets the marker of the point with the ID\'\'\'\n        self.points[ID][2] = marker\n    \n    \n    def setCurveMarker(self, ID, marker):\n        \'\'\'Sets the marker of the curve with the ID\'\'\'\n        self.curves[ID][2] = marker\n        \n        \n    def setSurfaceMarker(self, ID, marker):\n        \'\'\'Sets the marker of the surface with the ID\'\'\'\n        self.surfaces[ID][4] = marker\n        \n        \n    def setVolumeMarker(self, ID, marker):\n        \'\'\'Sets the marker of the volume with the ID\'\'\'\n        self.volumes[ID][3] = marker\n    \n    \n    def _checkIfProperStructuredQuadBoundary(self, outerLoop, ID):\n        \'\'\'Checks if the four edges of a quad-shaped superelement exist and\n        are correct, i.e elOnCurve of opposite curves are equal.\'\'\'\n        if len(outerLoop) != 4:\n            raise IndexError(""Structured Surface: outerloop must be a list of 4 positive integers denoting curve indices"")\n        \n        try:\n            c0 = self.curves[outerLoop[0]]\n            c1 = self.curves[outerLoop[1]]\n            c2 = self.curves[outerLoop[2]]\n            c3 = self.curves[outerLoop[3]]\n        except KeyError:\n            raise KeyError(""Structured Surface: Attempted construction of StructuredSurface with ID=%s from a curve that does not exist"" % ID)\n        \n        if None in [c0, c1, c2, c3]:\n            raise Exception(""Attempted to create structured surface from non-structured boundary curves."")\n        \n        if( c0[-3] != c2[-3] or c1[-3] != c3[-3] ): #Check if the number of elements on opposite curves match.\n            raise Exception(""Structured Surface: The outerLoop of StructuredSurface %i is not properly "" + \n                            ""constructed. The reason could be that the number of elements (elOnCurv) on "" + \n                            ""opposite pairs of curves are different"")\n\n\n    def _getNewPointID(self):\n        if not self._pointIDspecified:\n            self._nextPointID += 1\n            return self._nextPointID - 1\n        else:\n            return self._smallestFreeKey(self.points)\n        \n        \n    def _getNewCurveID(self):\n        if not self._curveIDspecified:\n            self._nextcurveID += 1\n            return self._nextcurveID - 1\n        else:\n            return self._smallestFreeKey(self.curves)\n        \n        \n    def _getNewSurfaceID(self):\n        if not self._surfaceIDspecified:\n            self._nextsurfaceID += 1\n            return self._nextsurfaceID - 1\n        else:\n            return self._smallestFreeKey(self.surfaces)\n        \n        \n    def _getNewVolumeID(self):\n        if not self._volumeIDspecified:\n            self._nextvolumeID += 1\n            return self._nextvolumeID - 1\n        else:\n            return self._smallestFreeKey(self.volumes)\n    \n    \n    def _smallestFreeKey(self, dictionary):\n        \'\'\'Finds the smallest unused key in the dict.\'\'\'\n        sortedkeys = sorted(dictionary)\n        for i in range(len(dictionary)):\n            if sortedkeys[i] != i:\n                return i\n'"
old/pycalfem_classes.py,0,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nimport wx\n\nfrom wx import glcanvas\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\n\nimport colorsys\n\ndef drawBitmapText(text, font=GLUT_BITMAP_TIMES_ROMAN_24):\n    for c in text:\n        glutBitmapCharacter(font, ord(c))\n\ndef floatRgb(mag, cmin, cmax):\n    """"""\n    Return a tuple of floats between 0 and 1 for the red, green and\n    blue amplitudes.\n    """"""\n    \n    try:\n           # normalize to [0,1]\n           x = float(mag-cmin)/float(cmax-cmin)\n    except:\n           # cmax = cmin\n           x = 0.5\n           \n    red, green, blue = colorsys.hsv_to_rgb(x*240./360, 1.0, 1.0)\n    return (red, green, blue)\n\nclass OpenGLFrame(wx.Frame):\n    def __init__(self, *args, **kwds):\n        kwds[""style""] = wx.DEFAULT_FRAME_STYLE\n        wx.Frame.__init__(self, *args, **kwds)\n        \n        self.GLinitialized = False\n        attribList = (glcanvas.WX_GL_RGBA, # RGBA\n                      glcanvas.WX_GL_DOUBLEBUFFER, # Double Buffered\n                      glcanvas.WX_GL_DEPTH_SIZE, 24) # 24 bit\n\n        # Create the canvas\n\n        self.canvas = glcanvas.GLCanvas(self, attribList=attribList)\n\n        # Set the event handlers.\n\n        self.canvas.Bind(wx.EVT_ERASE_BACKGROUND, self._doEraseBackground)\n        self.canvas.Bind(wx.EVT_SIZE, self._doSize)\n        self.canvas.Bind(wx.EVT_PAINT, self._doPaint)\n\n    # Canvas Proxy Methods\n\n    def GetGLExtents(self):\n        """"""Get the extents of the OpenGL canvas.""""""\n        return self.canvas.GetClientSize()\n\n    def SwapBuffers(self):\n        """"""Swap the OpenGL buffers.""""""\n        self.canvas.SwapBuffers()\n\n    # wxPython Window Handlers\n\n    def _doEraseBackground(self, event):\n        """"""Process the erase background event.""""""\n        pass # Do nothing, to avoid flashing on MSWin\n\n    def _doSize(self, event):\n        """"""Process the resize event.""""""\n        if self.canvas.GetContext():\n            # Make sure the frame is shown before calling SetCurrent.\n            self.Show()\n            self.canvas.SetCurrent()\n\n            size = self.GetGLExtents()\n            self.onReshape(size.width, size.height)\n            self.canvas.Refresh(False)\n        event.Skip()\n\n    def _doPaint(self, event):\n        """"""Process the drawing event.""""""\n        self.canvas.SetCurrent()\n\n        # This is a \'perfect\' time to initialize OpenGL ... only if we need to\n        \n        if not self.GLinitialized:\n            self.onInitGL()\n            self.GLinitialized = True\n\n        self.onDraw()\n        event.Skip()\n        \n    def drawStrokeText(self, text, x=0.0, y=0.0, fontSize=1.0, color=[0.0, 0.0, 0.0], font=GLUT_STROKE_ROMAN):\n        glPushMatrix()\n        glTranslate(x, y, 0)\n        glPushMatrix()\n        glColor(color)\n        glScalef(fontSize/119.05, -fontSize/119.05, 0.0)\n        glTranslate(0.0, -fontSize/119.05, 0.0)\n        \n        for c in text:\n            glutStrokeCharacter(font, ord(c))\n    \n        glPopMatrix()\n        glPopMatrix()\n\n\n    #\n    # GLFrame OpenGL Event Handlers\n\n    def onInitGL(self):\n        """"""Initialize OpenGL for use in the window.""""""\n        glClearColor(1, 1, 1, 1)\n        glDisable(GL_DEPTH_TEST)\n\n    def onReshape(self, width, height):\n        """"""Reshape the OpenGL viewport based on the dimensions of the window.""""""\n        glViewport(0, 0, width, height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(-0.5, 0.5, -0.5, 0.5, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def onDraw(self, *args, **kwargs):\n        ""Draw the window.""\n        glClear(GL_COLOR_BUFFER_BIT)\n\n        # Drawing an example triangle in the middle of the screen\n        glBegin(GL_TRIANGLES)\n        glColor(1, 0, 0)\n        glVertex(-.25, -.25)\n        glColor(0, 1, 0)\n        glVertex(.25, -.25)\n        glColor(0, 0, 1)\n        glVertex(0, .25)\n        glEnd()\n\n        self.SwapBuffers()      \n\nclass ElementView(OpenGLFrame):\n    def __init__(self, *args, **kwds):\n        # begin wxGlade: ResultWindow.__init__\n        kwds[""style""] = wx.DEFAULT_FRAME_STYLE\n        OpenGLFrame.__init__(self, *args, **kwds)\n\n        self.__set_properties()\n        self.__do_layout()\n        # end wxGlade\n        \n        self._initView()\n\n    def __set_properties(self):\n        # begin wxGlade: ResultWindow.__set_properties\n        self.SetTitle(""Result view"")\n        # end wxGlade\n\n    def __do_layout(self):\n        # begin wxGlade: ResultWindow.__do_layout\n        self.Layout()\n        # end wxGlade\n        \n    def _initView(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        self._nodeLimits = [1e300, -1e300]\n        self._maxNodeValue = -1e300\n        self._minNodeValue = 1e300\n        self._maxElementValue = -1e300\n        self._minElementValue = 1e300\n        self._ex = None\n        self._ey = None\n        self._ed = None\n        self._ev = None\n        self._magnfac = 0.1\n        self._elementNodes = 3\n        self._dofsPerNode = 1\n        self._showDimension = 1\n        self._width = 100\n        self._height = 100\n        self._showMesh = True\n        self._showNodalValues = True\n        self._showDisplacements = False\n        self._showElementValues = False\n        \n        self.drawAnnotations = None\n        self.drawCustom = None\n        \n    def calcLimits(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        \n        if self._ex!=None and self._ey!=None:\n            for elCoords in self._ex:\n                xmin = min(elCoords)\n                xmax = max(elCoords)\n                \n                if xmin<self._limits[0]:\n                    self._limits[0]=xmin\n                if xmax>self._limits[2]:\n                    self._limits[2]=xmax\n\n            for elCoords in self._ey:\n                ymin = min(elCoords)\n                ymax = max(elCoords)\n                \n                if ymin<self._limits[1]:\n                    self._limits[1]=ymin\n                if ymax>self._limits[3]:\n                    self._limits[3]=ymax\n                    \n    def calcNodeLimits(self):\n        if self.dofsPerNode == 1:\n            self._maxNodeValue = self._ed.max()\n            self._minNodeValue = self._ed.min()\n        else:\n            self._maxNodeValue = abs(self._ed).max()\n            \n    def calcElementLimits(self):\n        self._maxElementValue = self._ev.max()\n        self._minElementValue = self._ev.min()\n    \n    def calcScaling(self):\n\n        self._k = 0.8\n        \n        factor1 = self._k*self._width/(self._limits[2]-self._limits[0])\n        factor2 = self._k*self._height/(self._limits[3]-self._limits[1])\n        \n        self._scaleFactor = 1.0\n        \n        if factor1<factor2:\n            self._scaleFactor = factor1\n        else:\n            self._scaleFactor = factor2\n            \n        self._x0 = -self._scaleFactor*self._limits[0] + (1-self._k)*self._width/2.0\n        self._y0 = self._height - self._scaleFactor*self._limits[1] - (1-self._k)*self._height/2.0\n\n    def worldToScreen(self, x, y):\n        return (int(self._x0 + self._scaleFactor*x), int(self._y0 - self._scaleFactor*y))\n        \n    def drawMesh(self):\n             \n        # Draw elements\n                              \n        glBegin(GL_LINES)\n              \n        for elx, ely in zip(self._ex, self._ey):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                \n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n                \n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n\n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n            \n        glEnd()\n        \n    def drawNodalValues(self):\n                \n        # Draw nodal values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2], self._maxNodeValue, self._minNodeValue)\n                else:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glColor3f(c2[0], c2[1], c2[2])\n                glVertex(sx2,sy2)\n                glColor3f(c3[0], c3[1], c3[2])\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawElementValues(self):\n                \n        # Draw element values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, elv in zip(self._ex, self._ey, self._ev):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                else:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawDisplacements(self):\n        \n        # Draw elements\n        \n        scl = self._magnfac*self.modelWidth/self._maxNodeValue\n        \n        glBegin(GL_LINES)\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n                (sx3, sy3) = self.worldToScreen(elx[2]+scl*eld[4], ely[2]+scl*eld[5])\n                                           \n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n\n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n\n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n\n        glEnd()\n\n            \n    def onReshape(self, width, height):\n        """"""\n        Reshape the OpenGL viewport based on the dimensions of the window.\n        """"""\n        glViewport(0, 0, width, height)\n        \n        self._width = width\n        self._height = height\n        \n        self.calcScaling()\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0.0, width, height, 0.0, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        \n        glEnable(GL_POINT_SMOOTH)\n        glEnable(GL_LINE_SMOOTH)\n        glEnable(GL_POLYGON_SMOOTH)\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST)\n        glLineWidth(1.0)\n        glDisable(GL_DEPTH_TEST)\n        glDisable(GL_LIGHTING)\n\n    def onDraw(self, *args, **kwargs):\n        """"""\n        Draw the window.\n        """"""\n              \n        glClear(GL_COLOR_BUFFER_BIT)\n        \n        if self._showElementValues:\n            self.drawElementValues()\n        if self._showNodalValues:\n            self.drawNodalValues()\n        if self._showMesh:\n            self.drawMesh()\n        if self._showDisplacements:\n            self.drawDisplacements()\n            \n        if self.drawCustom!=None:\n            self.drawCustom(self, self._width, self._height)\n            \n        if self.drawAnnotations!=None:\n            self.drawAnnotations(self, self._width, self._height)\n            \n        self.SwapBuffers()\n        \n    def getModelHeight(self):\n        return self._ey.max() - self._ey.min()\n        \n    def getModelWidth(self):\n        return self._ex.max() - self._ex.min()\n\n    def setEx(self, ex):\n        self._ex = ex\n        self._elementNodes = self._ex.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEx(self):\n        return self._ex\n    \n    def setEy(self, ey):\n        self._ey = ey\n        self._elementNodes = self._ey.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEy(self):\n        return self._ey\n    \n    def setEd(self, ed):\n        self._ed = ed\n        self.calcNodeLimits()\n        \n    def getEd(self):\n        return self._ed\n    \n    def setShowMesh(self, showMesh):\n        self._showMesh = showMesh\n        \n    def getShowMesh(self):\n        return self._showMesh\n    \n    def setShowNodalValues(self, showNodalValues):\n        self._showNodalValues = showNodalValues\n        \n    def getShowNodalValues(self):\n        return self._showNodalValues\n    \n    def setShowElementValues(self, showElementValues):\n        self._showElementValues = showElementValues\n        \n    def getShowElementValues(self):\n        return self._showElementValues\n\n    def setShowDisplacements(self, showDisplacements):\n        self._showDisplacements = showDisplacements\n        \n    def getShowDisplacements(self):\n        return self._showDisplacements\n    \n    def setDofsPerNode(self, dofsPerNode):\n        self._dofsPerNode = dofsPerNode\n        \n    def getDofsPerNode(self):\n        return self._dofsPerNode\n    \n    def setElementNodes(self, elementNodes):\n        self._elementNodes = elementNodes\n        \n    def getElementNodes(self):\n        return self._elementNodes\n    \n    def setMagnFac(self, magnfac):\n        self._magnfac = magnfac\n        \n    def getMagnFac(self):\n        return self._magnfac\n    \n    def getEv(self):\n        return self._ev\n    \n    def setEv(self, value):\n        self._ev = value\n        self.calcElementLimits()\n    \n    ex = property(getEx, setEx)\n    ey = property(getEy, setEy)\n    ed = property(getEd, setEd)\n    ev = property(getEv, setEv)\n    dofsPerNode = property(getDofsPerNode, setDofsPerNode)\n    elementNodes = property(getElementNodes, setElementNodes)\n    modelWidth = property(getModelWidth)\n    modelHeight = property(getModelHeight)\n    magnfac = property(getMagnFac, setMagnFac)\n    showMesh = property(getShowMesh, setShowMesh)\n    showNodalValues = property(getShowNodalValues, setShowNodalValues)\n    showDisplacements = property(getShowDisplacements, setShowDisplacements)\n    showElementValues = property(getShowElementValues, setShowElementValues)\n    \n'"
old/pycalfem_classes_qt4.py,0,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nfrom OpenGL.GL import *\nfrom OpenGL.GLUT import *\nfrom PyQt4.QtOpenGL import *\n\nimport colorsys\n\ndef drawBitmapText(text, font=GLUT_BITMAP_TIMES_ROMAN_24):\n    for c in text:\n        glutBitmapCharacter(font, ord(c))\n\ndef floatRgb(mag, cmin, cmax):\n    """"""\n    Return a tuple of floats between 0 and 1 for the red, green and\n    blue amplitudes.\n    """"""\n    \n    try:\n           # normalize to [0,1]\n           x = float(mag-cmin)/float(cmax-cmin)\n    except:\n           # cmax = cmin\n           x = 0.5\n           \n    red, green, blue = colorsys.hsv_to_rgb(x*240./360, 1.0, 1.0)\n    return (red, green, blue)\n\nclass OpenGLFrame(QGLWidget):\n    def __init__(self, parent = None):\n        super(OpenGLFrame, self).__init__(parent)\n\n    def paintGL(self):\n        self.onDraw()\n\n    def resizeGL(self, w, h):\n        self.onReshape(w, h)\n\n    def initializeGL(self):\n        self.onInitGL()\n        \n    def Show(self):\n        self.show()\n        \n    def SwapBuffers(self):\n        pass\n        \n    #\n    # GLFrame OpenGL Event Handlers\n\n    def onInitGL(self):\n        """"""Initialize OpenGL for use in the window.""""""\n        glClearColor(1, 1, 1, 1)\n        glDisable(GL_DEPTH_TEST)\n\n    def onReshape(self, width, height):\n        """"""Reshape the OpenGL viewport based on the dimensions of the window.""""""\n        glViewport(0, 0, width, height)\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(-0.5, 0.5, -0.5, 0.5, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n\n    def onDraw(self):\n        ""Draw the window.""\n        glClear(GL_COLOR_BUFFER_BIT)\n\n        # Drawing an example triangle in the middle of the screen\n        glBegin(GL_TRIANGLES)\n        glColor(1, 0, 0)\n        glVertex(-.25, -.25)\n        glColor(0, 1, 0)\n        glVertex(.25, -.25)\n        glColor(0, 0, 1)\n        glVertex(0, .25)\n        glEnd()\n        \n        \nclass ElementView(OpenGLFrame):\n    def __init__(self, parent = None, a = 0, b = 0):\n        super(ElementView, self).__init__(parent)\n        self._initView()\n        \n    def _initView(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        self._nodeLimits = [1e300, -1e300]\n        self._maxNodeValue = -1e300\n        self._minNodeValue = 1e300\n        self._maxElementValue = -1e300\n        self._minElementValue = 1e300\n        self._ex = None\n        self._ey = None\n        self._ed = None\n        self._ev = None\n        self._magnfac = 0.1\n        self._elementNodes = 3\n        self._dofsPerNode = 1\n        self._showDimension = 1\n        self._width = 100\n        self._height = 100\n        self._showMesh = True\n        self._showNodalValues = True\n        self._showDisplacements = False\n        self._showElementValues = False\n        \n        self.drawAnnotations = None\n        self.drawCustom = None\n        \n    def calcLimits(self):\n        \n        self._limits = [1e300, 1e300, -1e300, -1e300]\n        \n        if not (self._ex is None) and not (self._ey is None):\n            for elCoords in self._ex:\n                xmin = min(elCoords)\n                xmax = max(elCoords)\n                \n                if xmin<self._limits[0]:\n                    self._limits[0]=xmin\n                if xmax>self._limits[2]:\n                    self._limits[2]=xmax\n\n            for elCoords in self._ey:\n                ymin = min(elCoords)\n                ymax = max(elCoords)\n                \n                if ymin<self._limits[1]:\n                    self._limits[1]=ymin\n                if ymax>self._limits[3]:\n                    self._limits[3]=ymax\n                    \n    def calcNodeLimits(self):\n        if self.dofsPerNode == 1:\n            self._maxNodeValue = self._ed.max()\n            self._minNodeValue = self._ed.min()\n        else:\n            self._maxNodeValue = abs(self._ed).max()\n            \n    def calcElementLimits(self):\n        self._maxElementValue = self._ev.max()\n        self._minElementValue = self._ev.min()\n    \n    def calcScaling(self):\n\n        self._k = 0.8\n        \n        factor1 = self._k*self._width/(self._limits[2]-self._limits[0])\n        factor2 = self._k*self._height/(self._limits[3]-self._limits[1])\n        \n        self._scaleFactor = 1.0\n        \n        if factor1<factor2:\n            self._scaleFactor = factor1\n        else:\n            self._scaleFactor = factor2\n            \n        self._x0 = -self._scaleFactor*self._limits[0] + (1-self._k)*self._width/2.0\n        self._y0 = self._height - self._scaleFactor*self._limits[1] - (1-self._k)*self._height/2.0\n\n    def worldToScreen(self, x, y):\n        return (int(self._x0 + self._scaleFactor*x), int(self._y0 - self._scaleFactor*y))\n        \n    def drawMesh(self):\n             \n        # Draw elements\n                              \n        glBegin(GL_LINES)\n              \n        for elx, ely in zip(self._ex, self._ey):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                \n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n                \n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n\n                glColor(0.5, 0.5, 0.5)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n            \n        glEnd()\n        \n    def drawNodalValues(self):\n                \n        # Draw nodal values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2], self._maxNodeValue, self._minNodeValue)\n                else:\n                    c1 = floatRgb(eld[0], self._maxNodeValue, self._minNodeValue)\n                    c2 = floatRgb(eld[1*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                    c3 = floatRgb(eld[2*self._dofsPerNode+(self._showDimension-1)], self._maxNodeValue, self._minNodeValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glColor3f(c2[0], c2[1], c2[2])\n                glVertex(sx2,sy2)\n                glColor3f(c3[0], c3[1], c3[2])\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawElementValues(self):\n                \n        # Draw element values\n        \n        if self._elementNodes == 3:\n            glBegin(GL_TRIANGLES)\n        else:\n            return\n        \n        for elx, ely, elv in zip(self._ex, self._ey, self._ev):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0], ely[0])\n                (sx2, sy2) = self.worldToScreen(elx[1], ely[1])\n                (sx3, sy3) = self.worldToScreen(elx[2], ely[2])\n                           \n                if self._dofsPerNode == 1:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                else:\n                    c1 = floatRgb(elv, self._maxElementValue, self._minElementValue)\n                        \n                glColor3f(c1[0], c1[1], c1[2])\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n            \n        glEnd()\n        \n    def drawDisplacements(self):\n        \n        # Draw elements\n        \n        scl = self._magnfac*self.modelWidth/self._maxNodeValue\n        \n        glBegin(GL_LINES)\n        \n        for elx, ely, eld in zip(self._ex, self._ey, self._ed):\n            \n            if self._elementNodes == 3:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n                (sx3, sy3) = self.worldToScreen(elx[2]+scl*eld[4], ely[2]+scl*eld[5])\n                                           \n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n                glVertex(sx2,sy2)\n                glVertex(sx3,sy3)\n                glVertex(sx3,sy3)\n                glVertex(sx1,sy1)\n\n            elif self._elementNodes == 2:\n            \n                (sx1, sy1) = self.worldToScreen(elx[0]+scl*eld[0], ely[0]+scl*eld[1])\n                (sx2, sy2) = self.worldToScreen(elx[1]+scl*eld[2], ely[1]+scl*eld[3])\n\n                glColor(0.3, 0.3, 0.3)\n                glVertex(sx1,sy1)\n                glVertex(sx2,sy2)\n\n        glEnd()\n\n            \n    def onReshape(self, width, height):\n        """"""\n        Reshape the OpenGL viewport based on the dimensions of the window.\n        """"""\n        glViewport(0, 0, width, height)\n        \n        self._width = width\n        self._height = height\n        \n        self.calcScaling()\n\n        glMatrixMode(GL_PROJECTION)\n        glLoadIdentity()\n        glOrtho(0.0, width, height, 0.0, -1, 1)\n\n        glMatrixMode(GL_MODELVIEW)\n        glLoadIdentity()\n        \n        glEnable(GL_POINT_SMOOTH)\n        glEnable(GL_LINE_SMOOTH)\n        glEnable(GL_POLYGON_SMOOTH)\n        glEnable(GL_BLEND)\n        glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA)\n        glHint(GL_LINE_SMOOTH_HINT,GL_NICEST)\n        glLineWidth(1.0)\n        glDisable(GL_DEPTH_TEST)\n        glDisable(GL_LIGHTING)\n\n    def onDraw(self, *args, **kwargs):\n        """"""\n        Draw the window.\n        """"""\n              \n        glClear(GL_COLOR_BUFFER_BIT)\n        \n        if self._showElementValues:\n            self.drawElementValues()\n        if self._showNodalValues:\n            self.drawNodalValues()\n        if self._showMesh:\n            self.drawMesh()\n        if self._showDisplacements:\n            self.drawDisplacements()\n            \n        if self.drawCustom!=None:\n            self.drawCustom(self, self._width, self._height)\n            \n        if self.drawAnnotations!=None:\n            self.drawAnnotations(self, self._width, self._height)\n            \n        self.SwapBuffers()\n        \n    def getModelHeight(self):\n        return self._ey.max() - self._ey.min()\n        \n    def getModelWidth(self):\n        return self._ex.max() - self._ex.min()\n\n    def setEx(self, ex):\n        self._ex = ex\n        self._elementNodes = self._ex.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEx(self):\n        return self._ex\n    \n    def setEy(self, ey):\n        self._ey = ey\n        self._elementNodes = self._ey.shape[1]\n        self.calcLimits()\n        self.calcScaling()\n        \n    def getEy(self):\n        return self._ey\n    \n    def setEd(self, ed):\n        self._ed = ed\n        self.calcNodeLimits()\n        \n    def getEd(self):\n        return self._ed\n    \n    def setShowMesh(self, showMesh):\n        self._showMesh = showMesh\n        \n    def getShowMesh(self):\n        return self._showMesh\n    \n    def setShowNodalValues(self, showNodalValues):\n        self._showNodalValues = showNodalValues\n        \n    def getShowNodalValues(self):\n        return self._showNodalValues\n    \n    def setShowElementValues(self, showElementValues):\n        self._showElementValues = showElementValues\n        \n    def getShowElementValues(self):\n        return self._showElementValues\n\n    def setShowDisplacements(self, showDisplacements):\n        self._showDisplacements = showDisplacements\n        \n    def getShowDisplacements(self):\n        return self._showDisplacements\n    \n    def setDofsPerNode(self, dofsPerNode):\n        self._dofsPerNode = dofsPerNode\n        \n    def getDofsPerNode(self):\n        return self._dofsPerNode\n    \n    def setElementNodes(self, elementNodes):\n        self._elementNodes = elementNodes\n        \n    def getElementNodes(self):\n        return self._elementNodes\n    \n    def setMagnFac(self, magnfac):\n        self._magnfac = magnfac\n        \n    def getMagnFac(self):\n        return self._magnfac\n    \n    def getEv(self):\n        return self._ev\n    \n    def setEv(self, value):\n        self._ev = value\n        self.calcElementLimits()\n    \n    ex = property(getEx, setEx)\n    ey = property(getEy, setEy)\n    ed = property(getEd, setEd)\n    ev = property(getEv, setEv)\n    dofsPerNode = property(getDofsPerNode, setDofsPerNode)\n    elementNodes = property(getElementNodes, setElementNodes)\n    modelWidth = property(getModelWidth)\n    modelHeight = property(getModelHeight)\n    magnfac = property(getMagnFac, setMagnFac)\n    showMesh = property(getShowMesh, setShowMesh)\n    showNodalValues = property(getShowNodalValues, setShowNodalValues)\n    showDisplacements = property(getShowDisplacements, setShowDisplacements)\n    showElementValues = property(getShowElementValues, setShowElementValues)        \n        \n\n'"
old/pycalfem_geometry.py,0,"b'#TODO: Consider adding more checks whether entities exist.\n\nclass Geometry:\n    \'\'\'\n    Instances of GeoData can hold geometric data and be passed to \n    GmshMesher in pycalfem_Mesh to mesh the geometry.\n    \'\'\'\n\n    def __init__(self):\n        self.points = {}    #dict of [[x, y, z], elSize, marker]\n        self.curves = {}    #dict of [curvTypestring, [p1, p2, ... pn], marker, elementsOnCurve, distributionString, distributionVal]\n        self.surfaces = {}  #dict of [SurfaceTypeString, [c1, c2 ... cn], [[c1, c2 ... cm], ... [c1, ... ck]], ID, marker, isStructured]. c means curve-ID.\n        self.volumes = {}   #dict of [[s1, s2 ..], [[s1,s2...],[s1,s2..],..], ID, marker, isStructured]    \n        self.is3D = False   #This is automatically set to True if a 3D point is added.\n        self._pointIDspecified = False\n        self._nextPointID = 0\n        self._curveIDspecified = False\n        self._nextcurveID = 0\n        self._surfaceIDspecified = False\n        self._nextsurfaceID = 0\n        self._volumeIDspecified = False\n        self._nextvolumeID = 0\n    \n    \n    def removePoint(self, ID):\n        \'\'\'Removes the point with this ID\'\'\'\n        self.points.pop(ID)\n    \n    \n    def removeCurve(self, ID):\n        \'\'\'Removes the curve with this ID\'\'\'\n        self.curve.pop(ID)\n    \n    \n    def removeSurface(self, ID):\n        \'\'\'Removes the surface with this ID\'\'\'\n        self.surfaces.pop(ID)\n    \n    \n    def removeVolume(self, ID):\n        \'\'\'Removes the volume with this ID\'\'\'\n        self.volumes.pop(ID)\n    \n    \n    def getPointCoords(self, IDs=None):\n        \'\'\'\n        Returns an N-by-3 list of point coordinates if the parameter is\n        a list of IDs. If the parameter is just a single integer then \n        a single coordinate (simple 3-element list) is returned.\n        If the parameter is undefined (or None) all point coords will be returned\n        \'\'\'\n        if IDs == None:\n            return [p[0] for p in self.points.values()]\n        try:\n            pointCoords = [self.points[pID][0] for pID in IDs]\n        except TypeError: #IDs was not iterable. Probably just a single ID.\n            pointCoords = self.points[IDs][0]\n        return pointCoords\n    \n    \n    def pointsOnCurves(self, IDs):\n        \'\'\'\n        Returns a list of all geometric points (not nodes) on the curves\n        specified in IDs. IDs may be an integer or a list of integers.\n        \'\'\'\n        return self._subentitiesOnEntities(IDs, self.curves, 1)\n    \n    \n    def stuffOnSurfaces(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points and curves on the surfaces\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        curveSet = self._subentitiesOnEntities(IDs, self.surfaces, 1) #Curves on the outer edges\n        curveSet.update( self._subentityHolesOnEntities(IDs, self.surfaces, 2) ) #Curves on the holes\n        pointList = self.pointsOnCurves(curveSet) #Points on the curves of these surfaces.\n        return pointList, list(curveSet)\n        \n    def stuffOnVolumes(self, IDs):\n        \'\'\'\n        Returns lists of all geometric points, curves, and surfaces on the volumes\n        specified in IDs. IDs may be an integer or a list of integers\n        \'\'\'\n        surfaceSet = self._subentitiesOnEntities(IDs, self.surfaces, 0)\n        surfaceSet.update( self._subentitiesOnEntities(IDs, self.surfaces, 1) )\n        pointList, curveList = self.stuffOnSurfaces(surfaceSet)\n        return pointList, curveList, list(surfaceSet)\n    \n    def _subentitiesOnEntities(self, IDs, entityDict, index):\n        \'\'\'\n        Duplicate code. Gets the IDs of the subentities that\n        make up an entity, i.e. the points that define a curve or\n        the curves that define a surface. Note that only the outer\n        subentities of surfaces and volumes can be extracted with\n        this function. For holes use _subentityHolesOnEntities().\n        \'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                theSet.update(entityDict[ID][index])\n        except TypeError: #IDs is not iterable, so it is probably a single ID\n            theSet.update(entityDict[IDs][index])\n        return theSet\n    \n    def _subentityHolesOnEntities(self, IDs, entityDict, index):\n        \'\'\'Duplicate code. Does the same thing as _subentitiesOnEntities(), but for holes\'\'\'\n        theSet = set()\n        try:\n            for ID in IDs:\n                for hole in entityDict[ID][index]:\n                    theSet.update(hole)\n        except TypeError: #IDs is not iterable, so it is probably a single ID\n            for hole in entityDict[IDs][index]:\n                theSet.update(hole)\n        return theSet\n        \n    \n    def addPoint(self, coord, ID=None, marker=0, elSize=1):\n        \'\'\'\n        Adds a point.\n        \n        Parameters:\n        coord     - [x, y] or [x, y, z].\n                    List, not array.\n        \n        ID        - Positive integer ID of this point. If left unspecified the\n                    point will be assigned the smallest unused point-ID.\n                    It is recommended to specify all point-IDs or none.\n                    \n        marker    - Marker applied to this point. Default 0.\n                    It is not a good idea to apply non-zero markers to points\n                    that are control points on B-splines or center points on \n                    circles/ellipses, since this can lead to ""loose"" nodes\n                    that are not part of any elements.\n        \n        elSize    - The size of elements at this point. Default 1. Use to make\n                    a mesh denser or sparser here. Only affects unstructured\n                    meshes\n        \'\'\'\n        if len(coord)==3: #A 3D point is inserted.\n            self.is3D = True \n        else: #The point is in 2D (we assume)\n            coord = coord+[0] #Pad with a 0. (we store points as 3D points for consistency\'s sake)\n            \n        if ID==None: #ID is not specified. Get an ID for this point:\n            ID = self._getNewPointID()\n        else:\n            self._pointIDspecified = True\n            \n        self.points[ID] = [coord, elSize, marker]\n    \n    \n    def addSpline(self, points, ID=None, marker=0, elOnCurve=None, elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Spline curve\n        \n        points    - List of indices of control points that make a Spline\n                    [p1, p2, ... , pn]\n                    \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""Spline"", points, ID, marker, elOnCurve, elDistribType, elDistribVal)\n        \n        \n    def addBSpline(self, points, ID=None, marker=0, elOnCurve=None,  elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a B-Spline curve\n        \n        points    - List of indices of control points that make a B-spline\n                    [p1, p2, ... , pn]\n                    \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        self._addCurve(""BSpline"", points, ID, marker, elOnCurve,  elDistribType, elDistribVal)\n\n\n    def addCircle(self, points, ID=None, marker=0, elOnCurve=None,  elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Circle arc curve.\n        \n        points    - list of 3 indices of point that make a circle arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, endpoint]\n        \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Elements on curve.\n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes.\n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.\n        \'\'\'\n        if len(points) != 3:\n            raise IndexError(""Circle: points must be a list of 3 positive integers denoting point indices"")\n        self._addCurve(""Circle"", points, ID, marker, elOnCurve,  elDistribType, elDistribVal)\n        \n        \n    def addEllipse(self, points, ID=None, marker=0, elOnCurve=None, elDistribType=None, elDistribVal=None):\n        \'\'\'\n        Adds a Ellipse arc curve.\n        \n        points    - List of 4 indices of point that make a ellipse arc smaller\n                    than Pi.\n                    [startpoint, centerpoint, mAxisPoint, endpoint]\n                    Startpoint is the starting point of the arc.\n                    Centerpoint is the point at the center of the ellipse.\n                    MAxisPoint is any point on the major axis of the ellipse.\n                    Endpoint is the end point of the arc.\n        \n        ID        - Positive integer ID of this curve. If left unspecified the\n                    curve will be assigned the smallest unused curve-ID.\n                    It is recommended to specify all curve-IDs or none.\n                    \n        marker    - Integer. Marker applied to this curve. Default 0.\n                    \n        elOnCurv  - Positive integer. Elements on curve. \n                    The number of element edges that will be distributed\n                    along this curve. Only works for structured meshes. \n                    \n        elDistribType -\n                    String. Either ""bump"" or ""progression"". \n                    Determines how the density of elements vary along the curve\n                    for structured meshes. Only works for structured meshes.\n                    elOnCurv and elDistribVal must be be defined if this param\n                    is used.\n                                        \n        elDistribVal -\n                    Float. Determines how severe the element distribution is.\n                    Only works for structured meshes. elOnCurv and \n                    elDistribType must be be defined if this param is used.\n                    \n                        bump:\n                    Smaller value means elements are bunched up at the edges\n                    of the curve, larger means bunched in the middle.\n                    \n                        progression:\n                    The edge of each element along this curve (from starting\n                    point to end) will be larger than the preceding one by \n                    this factor.\n                    elDistribVal = 2 meaning for example that each line element \n                    in the series will be twice as long as the preceding one.\n                    elDistribVal < 1 makes each element smaller than the \n                    preceeding one.                      \n        \'\'\'\n        if len(points) != 4:\n            raise IndexError(""Ellipse: points must be a list of 4 positive integers denoting point indices"")\n        self._addCurve(""Ellipse"", points, ID, marker, elOnCurve, elDistribType, elDistribVal)\n\n        \n    def _addCurve(self, name, points, ID, marker, elOnCurve, elDistribType, elDistribVal):\n        \'\'\'Duplicate code goes here!\'\'\'\n        if ID==None:\n            ID = self._getNewCurveID()\n        else:\n            self._curveIDspecified = True\n        \n        if elDistribType != None:\n            elDistribType = elDistribType.lower().title() #transform into lowercase except the first letter upper case.\n            if elDistribType not in [""Bump"", ""Progression""]:\n                raise ValueError(""elDistribType must be a string, either \\""bump\\"" or \\""progression\\"". Curve with ID=%i was incorrect."" %ID)\n            if elDistribVal == None:\n                raise ValueError(""If elDistribType is defined then elDistribVal must be given a (float) value"")\n        \n        self.curves[ID] = [name, points, marker, elOnCurve, elDistribType, elDistribVal]\n    \n    def addSurface(self, outerLoop, holes=[], ID=None, marker=0):\n        \'\'\'\n        Adds a plane surface (flat).\n        Parameters:\n        outerLoop - List of curve IDs that make up the outer boundary of\n                    the surface. The curves must lie in the same plane.\n        \n        holes     - List of lists of curve IDs that make up the inner\n                    boundaries of the surface. The curves must lie in the\n                    same plane. \n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        #TODO: Possibly check if outerLoop is an actual loop and if the holes are correct.\n        self._addSurf(""Plane Surface"", outerLoop, holes, ID, marker, isStructured=False)\n        \n        \n    def addRuledSurface(self, outerLoop, ID=None, marker=0):\n        \'\'\'\n        Adds a Ruled Surface (bent surface).\n        Parameters:\n        outerLoop - List of 3 or 4 curve IDs that make up the boundary of\n                    the surface.\n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        if len(outerLoop) not in [3, 4]:\n            raise IndexError(""Ruled Surface: outerloop must be a list of 3 or 4 positive integers denoting curve indices"")\n        self._addSurf(""Ruled Surface"", outerLoop, [], ID, marker, isStructured=False)\n    \n    \n    def addStructuredSurface(self, outerLoop, ID=None, marker=0):\n        \'\'\'\n        Adds a Structured Surface.\n        Parameters:\n        outerLoop - List of 4 curve IDs that make up the boundary of\n                    the surface. The curves must be structured, i.e. their\n                    parameter \'elOnCurv\' must be defined.\n                    \n        ID        - Positive integer ID of this surface. If left unspecified\n                    the surface will be assigned the smallest unused surface-ID.\n                    It is recommended to specify all surface-IDs or none.\n                    \n        marker    - Integer. Marker applied to this surface. Default 0.\n        \'\'\'\n        self._checkIfProperStructuredQuadBoundary(outerLoop, ID)\n        self._addSurf(""Ruled Surface"", outerLoop, [], ID, marker, isStructured=True) \n    \n    \n    def _addSurf(self, name, outerLoop, holes, ID, marker, isStructured):\n        \'\'\'For duplicate code\'\'\'\n        #TODO: check if the curves in outerloop actually exist. Maybe print a warning.\n        if ID==None:\n            ID = self._getNewSurfaceID()\n        else:\n            self._surfaceIDspecified = True\n            \n        for hole in holes: #Catch the easy mistake of making holes a list of ints rather than a list of lists of ints.\n            try:\n                [h for h in hole]\n            except TypeError:\n                raise TypeError(""Hole "" + str(hole) + "" is not iterable. Parameter holes must be a list of lists of integers"")\n        \n        self.surfaces[ID] = [name, outerLoop, holes, ID, marker, isStructured]\n    \n    \n    def addVolume(self, outerSurfaces, holes=[], ID=None, marker=0):\n        \'\'\'Adds a Volume\n        Parameters:\n        outerSurfaces - List of surface IDs that make up the outer boundary of\n                        the volume.\n        \n        holes         - List of lists of surface IDs that make up the inner\n                        boundaries of the volume.\n                    \n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n                    \n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        self._addVolume(outerSurfaces, holes, ID, marker, isStructured=False)\n    \n    \n    def addStructuredVolume(self, outerSurfaces, ID=None, marker=0):\n        \'\'\'Adds a Structured Volume\n        Parameters:\n        outerSurfaces - List of surface IDs that make up the outer boundary of\n                        the volume. The surfaces must be Structured Surfaces.\n                    \n        ID            - Positive integer ID of this volume. If left unspecified\n                        the volume will be assigned the smallest unused volume-ID.\n                        It is recommended to specify all volume-IDs or none.\n                    \n        marker        - Integer. Marker applied to this volume. Default 0.\'\'\'\n        #TODO: Check input. (see if surfaces are structured)\n        self._addVolume(outerSurfaces, [], ID, marker, isStructured=True)\n    \n    \n    def _addVolume(self,  outerSurfaces, holes, ID, marker, isStructured):\n        \'\'\'Duplicate code\'\'\'\n        #TODO: Check input (outerSurfaces and holes[i] must be closed surfaces)\n        if ID==None:\n            ID = self._getNewVolumeID()\n        else:\n            self._volumeIDspecified = True\n        self.volumes[ID] = [outerSurfaces, holes, ID, marker, isStructured] \n        \n        \n    def setPointMarker(self, ID, marker):\n        \'\'\'Sets the marker of the point with the ID\'\'\'\n        self.points[ID][2] = marker\n    \n    \n    def setCurveMarker(self, ID, marker):\n        \'\'\'Sets the marker of the curve with the ID\'\'\'\n        self.curves[ID][2] = marker\n        \n        \n    def setSurfaceMarker(self, ID, marker):\n        \'\'\'Sets the marker of the surface with the ID\'\'\'\n        self.surfaces[ID][4] = marker\n        \n        \n    def setVolumeMarker(self, ID, marker):\n        \'\'\'Sets the marker of the volume with the ID\'\'\'\n        self.volumes[ID][3] = marker\n    \n    \n    def _checkIfProperStructuredQuadBoundary(self, outerLoop, ID):\n        \'\'\'Checks if the four edges of a quad-shaped superelement exist and\n        are correct, i.e elOnCurve of opposite curves are equal.\'\'\'\n        if len(outerLoop) != 4:\n            raise IndexError(""Structured Surface: outerloop must be a list of 4 positive integers denoting curve indices"")\n        \n        try:\n            c0 = self.curves[outerLoop[0]]\n            c1 = self.curves[outerLoop[1]]\n            c2 = self.curves[outerLoop[2]]\n            c3 = self.curves[outerLoop[3]]\n        except KeyError:\n            raise KeyError(""Structured Surface: Attempted construction of StructuredSurface with ID=%s from a curve that does not exist"" % ID)\n        \n        if None in [c0, c1, c2, c3]:\n            raise Exception(""Attempted to create structured surface from non-structured boundary curves."")\n        \n        if( c0[-3] != c2[-3] or c1[-3] != c3[-3] ): #Check if the number of elements on opposite curves match.\n            raise Exception(""Structured Surface: The outerLoop of StructuredSurface %i is not properly "" + \n                            ""constructed. The reason could be that the number of elements (elOnCurv) on "" + \n                            ""opposite pairs of curves are different"")\n\n\n    def _getNewPointID(self):\n        if not self._pointIDspecified:\n            self._nextPointID += 1\n            return self._nextPointID - 1\n        else:\n            return self._smallestFreeKey(self.points)\n        \n        \n    def _getNewCurveID(self):\n        if not self._curveIDspecified:\n            self._nextcurveID += 1\n            return self._nextcurveID - 1\n        else:\n            return self._smallestFreeKey(self.curves)\n        \n        \n    def _getNewSurfaceID(self):\n        if not self._surfaceIDspecified:\n            self._nextsurfaceID += 1\n            return self._nextsurfaceID - 1\n        else:\n            return self._smallestFreeKey(self.surfaces)\n        \n        \n    def _getNewVolumeID(self):\n        if not self._volumeIDspecified:\n            self._nextvolumeID += 1\n            return self._nextvolumeID - 1\n        else:\n            return self._smallestFreeKey(self.volumes)\n    \n    \n    def _smallestFreeKey(self, dictionary):\n        \'\'\'Finds the smallest unused key in the dict.\'\'\'\n        sortedkeys = sorted(dictionary)\n        for i in range(len(dictionary)):\n            if sortedkeys[i] != i:\n                return i\n'"
old/pycalfem_mesh.py,13,"b'import os, sys\nimport numpy as np\nfrom pycalfem import createdofs\nfrom pycalfem_utils import which\n\ndef cmp(a, b):\n    return (a > b) - (a < b)  \n\n#def dofsFromNodes(listOfNodes, dofs):\n#        D = []\n#        for node in listOfNodes:\n#            D.extend(dofs[node])\n#        return D\n                \ndef _offsetIndices(lst, offset=0):\n    \'\'\'Shifts the indices by offset. \n    Positive offsets move the indices away from 0.\n    Negative offsets move the indices towards 0.\n    If an index is 0 the offset is added to it.\'\'\'\n    return [x + cmp(x, -0.5)*offset for x in lst]\n    \n    \n    \ndef _formatList(lst, offset=0):\n    """"""\n    Turns a list of numbers into a corresponding string of comma-separated numbers.\n    The parameter offset is a number that is added to the numbers.\n    Can be used for turning a list of 0-based indices into a corresponding string\n    of comma-separated offset indices. Offsets depend on the sign, i.e. negative\n    numbers get the offset subtracted.\n    Do not use offsets on lists with negative float values. \n    """"""\n    #Increment the indices by 1. Join list-elements as strings separated by \', \'. \n    try:\n        return \', \'.join(map(str, _offsetIndices(lst, offset) ))\n    except TypeError:\n        return lst+offset #If lst is not iterable (causes TypeError), then it is probably an integer.\n\n\ndef _insertInSetDict(dictionary, key, values):\n    \'\'\'inserts values at key in dictionary containing sets. Values may be\n    a single value or iterable, in which case each value is inserted\'\'\'\n    if not key in dictionary:\n        dictionary[key] = set()\n    try:\n        for v in values:\n            dictionary[key].add(v)\n    except TypeError: #Exception if values is not an iterable - insert values itself instead.\n        dictionary[key].add(values)\n    \n    \nclass GmshMeshGenerator:\n    \'\'\'\n    Meshes geometry in GeoData objects or geo-files by calling the Gmsh executable.\n    This is done when the function create() is called.\n    \'\'\'\n    \n    def __init__(self, geometry, elType=2, elSizeFactor=1, dofsPerNode=1, \n                gmshExecPath=None, clcurv=False,\n                minSize = None, maxSize = None, meshingAlgorithm = None,\n                additionalOptions = \'\'):       \n        \'\'\'        \n        Parameters:\n        \n            geometry        GeoData instance or string containing path to .geo-file\n                            \n            elType        Integer. Element type and order. \n                           See gmsh manual for details.\n            \n            elSizeFactor  Float. Factor by which the element sizes are multiplied.\n            \n            dofsPerNode    Number of degrees of freedom per node.\n            \n            gmshExecPath   File path to where the gmsh executable is located.\n            \n            clcurv         Set to true to make elements smaller at high curvatures. \n                           (Experimental option according to the gmsh manual)\n            \n            minSize        Minimum element size\n            \n            maxSize        Maximum element size\n            \n            meshingAlgorithm  String. Select mesh algorithm (\'meshadapt\', \'del2d\',\n                              \'front2d\',  \'del3d\', \'front3d\', ...). \n                              See the gmsh manual for more info.\n            \n            additionalOptions  String containing additional command line args for gmsh.\n                               Use this if a gmsh option is not covered by the above \n                               parameters (See section 3.3 in the gmsh manual for a \n                               list of options)):\n           \'\'\'\n        self.geometry = geometry\n        self.elType = elType\n        self.elSizeFactor = elSizeFactor\n        self.dofsPerNode = dofsPerNode\n        self.gmshExecPath = gmshExecPath\n        self.clcurv = clcurv\n        self.minSize = minSize\n        self.maxSize = maxSize\n        self.meshingAlgorithm = meshingAlgorithm\n        self.additionalOptions = additionalOptions\n        \n        self._ElementsWithQuadFaces = [3, 5, 10, 12, 16, 17, 92, 93] #gmsh elements that have rectangle faces\n        self._2ndOrderElms = [ 8,  9, 10, 11, 12,\n                              13, 14, 16, 17, 18,\n                              19]\n        self._2dOrderIncompleteElms = [9, 11, 13, 14, \n                                       16, 17, 18, 19]\n        #Apart from 16 the 2nd orders are totally untested. Only 16 (8-node quad)\n        #is implemented in pycalfem though, so it does not matter.\n        \n    def create(self, is3D=False):\n        \'\'\'\n        Meshes a surface or volume defined by the geometry in geoData.\n        Parameters:\n        is3D - Optional parameter that only needs to be set if geometry\n               is loaded from a geo-file, i.e. if geoData is a path string.\n               Default False.\n        \n        Returns:\n        \n            coords          Node coordinates\n            \n                            [[n0_x, n0_y, n0_z],\n                            [   ...           ],\n                            [nn_x, nn_y, nn_z]]\n                            \n            edof            Element topology\n                            \n                            [[el0_dof1, ..., el0_dofn],\n                            [          ...          ],\n                            [eln_dof1, ..., eln_dofn]]\n                                 \n            dofs            Node dofs\n            \n                            [[n0_dof1, ..., n0_dofn],\n                            [         ...         ],\n                            [nn_dof1, ..., nn_dofn]]\n                                 \n            bdofs           Boundary dofs. Dictionary containing lists of dofs for\n                            each boundary marker. Dictionary key = marker id.\n                            \n            elementmarkers  List of integer markers. Row i contains the marker of\n                            element i. Markers are similar to boundary markers and\n                            can be used to identify in which region an element lies.\n                            \n    Running this function also creates object variables:\n            \n            nodesOnCurve    Dictionary containing lists of node-indices. Key is a \n                            curve-ID and the value is a list of indices of all nodes\n                            on that curve, including its end points.\n            \n            nodesOnSurface  Dictionary containing lists of node-indices. Key is a\n                            surface-ID and the value is a list of indices of the nodes\n                            on that surface, including its boundary.\n            \n            nodesOnVolume   Dictionary containing lists of node-indices. Key is a\n                            volume-ID and the value is a list of indices of the nodes\n                            in that volume, including its surface. \n        \'\'\'\n        #Nodes per element for different element types:\n        #(taken from Chapter 9, page 89 of the gmsh manual)\n        nodesPerElmDict = { 1:2,   2:3,   3:4,   4:4,   5:8,\n                            6:6,   7:5,   8:3,   9:6,  10:9,\n                           11:10, 12:27, 13:18, 14:14, 15:1,\n                           16:8,  17:20, 18:15, 19:13, 20:9,\n                           21:10, 22:12, 23:15, 24:15, 25:21,\n                           26:4,  27:5,  28:6,  29:20, 30:35,\n                           31:56, 92:64, 93:125}\n        nodesPerElement = nodesPerElmDict[self.elType]        \n        \n        # Check for GMSH executable [NOTE]Mostly copied from trimesh2d(). TODO: Test on different systems\n        gmshExe = self.gmshExecPath\n        if gmshExe == None:    \n            gmshExe = """"\n            if sys.platform == ""win32"":\n                gmshExe = which(""gmsh.exe"")\n            else:\n                gmshExe = which(""gmsh"")\n        else:\n            if not os.path.exists(gmshExe):\n                gmshExe = os.path.join(os.getcwd(), self.gmshExecPath) #Try relative path\n                if not os.path.exists(gmshExe):\n                    gmshExe = None #Relative path didnt work either\n              \n        if gmshExe==None:\n            raise IOError(""Error: Could not find GMSH. Please make sure that the \\GMSH executable is available on the search path (PATH)."")\n        \n        if type(self.geometry) is str: #If geometry data is given as a .geo file we will just pass it on to gmsh later.\n            geoFilePath = self.geometry\n            dim = 3 if is3D else 2 #In this case geoData is a path string, so the dimension must be supplied by the user.\n            if not os.path.exists(geoFilePath):\n                geoFilePath = os.path.join(os.getcwd(), geoFilePath) #Try relative path\n                if not os.path.exists(geoFilePath):\n                    raise IOError(""Error: Could not find geo-file "" + geoFilePath)\n        else:\n            dim = 3 if self.geometry.is3D else 2   #Get the dimension of the model from geoData.\n            if not os.path.exists(""./gmshMeshTemp""):\n                os.mkdir(""./gmshMeshTemp"")\n            geoFilePath = os.path.normpath(os.path.join(os.getcwd(), ""gmshMeshTemp/tempGeometry.geo""))#""gmshMeshTemp/tempGeometry.geo""\n            self.geofile = open(geoFilePath, ""w"") #Create temp geometry file\n            self._writeGeoFile()#Write geoData to file            \n            self.geofile.close()\n        \n        mshFileName = os.path.normpath(os.path.join(os.getcwd(), \'gmshMeshTemp/meshFile.msh\')) #Filepath to the msh-file that will be generated.\n        #construct options string:\n        options = """"\n        options += \' -\' + str(dim)\n        options += \' -clscale \' + str(self.elSizeFactor) #scale factor\n        options += \' -o \\""%s\\""\' % mshFileName\n        options += \' -clcurv\' if self.clcurv else \'\'\n        options += \' -clmin \' + str(self.minSize) if self.minSize is not None else \'\'\n        options += \' -clmax \' + str(self.maxSize) if self.maxSize is not None else \'\'\n        options += \' -algo \' + self.meshingAlgorithm if self.meshingAlgorithm is not None else \'\'\n        options += \' -order 2\' if self.elType in self._2ndOrderElms else \'\'\n        options += \' \' + self.additionalOptions\n        \n        #Execute gmsh\n        gmshExe = os.path.normpath(gmshExe)\n        os.system(""%s \\""%s\\"" %s"" % (gmshExe, geoFilePath, options))\n        \n        #Read generated msh file:\n        #print(""Opening msh file "" + mshFileName)#TEMP\n        \n        mshFile = open(mshFileName, \'r\')\n        \n        #print(""Reading msh file..."")#TEMP\n        ln = mshFile.readline()\n        while(ln != \'$Nodes\\n\'): #Read until we find the nodes\n            ln = mshFile.readline()\n        nbrNodes = int(mshFile.readline())\n        allNodes = np.zeros([nbrNodes,dim], \'d\')\n        for i in range(nbrNodes):\n            line = list(map(float, mshFile.readline().split()))\n            allNodes[i,:] = line[1:dim+1] #Grab the coordinates (1:3 if 2D, 1:4 if 3D)\n            \n        while(mshFile.readline() != \'$Elements\\n\'): #Read until we find the elements\n            pass\n        nbrElements = int(mshFile.readline()) #The nbr of elements (including marker elements).\n        elements = []\n        elementmarkers = []\n        bdofs = {} #temp dictionary of sets. Key:MarkerID. Value:Set. The sets will be converted to lists.\n        #nodeOnPoint = {}  #dictionary pointID : nodeNumber\n        self.nodesOnCurve = {}    #dictionary lineID  : set of [nodeNumber]\n        self.nodesOnSurface = {}   #dictionary surfID  : set of [nodeNumber]\n        self.nodesOnVolume = {}    #dictionary volID   : set of [nodeNumber]\n        for i in range(nbrElements): #Read all elements (points, surfaces, etc):\n            line = list(map(int, mshFile.readline().split()))\n            eType = line[1] #second int is the element type.\n            nbrTags = line[2] #Third int is the nbr of tags on this element.\n            marker = line[3]  #Fourth int (first tag) is the marker.\n            entityID = line[4] #Fifth int  is the ID of the geometric entity (points, curves, etc) that the element belongs to\n            nodes = line[3+nbrTags : len(line)] #The rest after tags are node indices.\n            \n            if(eType == self.elType): #If the element type is the kind of element we are looking for:\n                elements.append(nodes) #Add the nodes of the elements to the list.\n                elementmarkers.append(marker)#Add element marker. It is used for keeping track of elements (thickness, heat-production and such)\n            else: #If the element is not a ""real"" element we store its node at marker in bdof instead:\n                _insertInSetDict(bdofs, marker, nodes)\n                    \n            #if eType == 15: #If point. Commmented away because points only make elements if they have non-zero markers, so nodeOnPoint is not very useful.\n            #    nodeOnPoint[entityID-1] = nodes[0] #insert node into nodeOnPoint. (ID-1 because we want 0-based indices)\n            if eType in [1,8,26,27,28]: #If line\n                _insertInSetDict(self.nodesOnCurve, entityID-1, _offsetIndices(nodes,-1)) #insert nodes into nodesOnCurve\n            elif eType in [2,3,9,10,16,20,21,22,23,24,25]: #If surfaceelement\n                _insertInSetDict(self.nodesOnSurface, entityID-1, _offsetIndices(nodes,-1)) #insert nodes into nodesOnSurface\n            else: #if volume element.\n                _insertInSetDict(self.nodesOnVolume, entityID-1, _offsetIndices(nodes,-1))\n                \n        elements = np.array(elements) \n        for key in bdofs.keys(): #Convert the sets of boundary nodes to lists.\n                bdofs[key] = list(bdofs[key])\n        for key in self.nodesOnCurve.keys(): #Convert set to list\n                self.nodesOnCurve[key] = list(self.nodesOnCurve[key])\n        for key in self.nodesOnSurface.keys(): #Convert set to list\n                self.nodesOnSurface[key] = list(self.nodesOnSurface[key])\n        for key in self.nodesOnVolume.keys(): #Convert set to list\n                self.nodesOnVolume[key] = list(self.nodesOnVolume[key])\n                \n        #print(""Closing msh file..."")#TEMP        \n        mshFile.close()\n        \n        dofs = createdofs(np.size(allNodes,0), self.dofsPerNode)\n        \n        if self.dofsPerNode>1: #This if-chunk copied from pycalfem_utils.py\n            expandedElements = np.zeros((np.size(elements,0),nodesPerElement*self.dofsPerNode),\'i\')\n            elIdx = 0\n            for elementTopo in elements:        \n                for i in range(nodesPerElement):\n                    expandedElements[elIdx,i*self.dofsPerNode:(i*self.dofsPerNode+self.dofsPerNode)] = dofs[elementTopo[i]-1,:]\n                elIdx += 1\n                \n            for keyID in bdofs.keys():\n                bVerts = bdofs[keyID]\n                bVertsNew = []\n                for i in range(len(bVerts)):\n                    for j in range(self.dofsPerNode):\n                        bVertsNew.append(dofs[bVerts[i]-1][j])\n                bdofs[keyID] = bVertsNew\n                \n            return allNodes, np.asarray(expandedElements), dofs, bdofs, elementmarkers\n        \n        return allNodes, elements, dofs, bdofs, elementmarkers\n        \n        \n        \n    def _writeGeoFile(self):\n        pointMarkers = {} #key is marker, value is a list of point indices (0-based) with that marker\n        curveMarkers = {}\n        surfaceMarkers = {}\n        volumeMarkers = {}    \n        \n        # WRITE POINTS:\n        for ID, [coords, elSize, marker] in self.geometry.points.items(): \n            self.geofile.write(""Point(%i) = {%s};\\n"" % (ID+1, _formatList(coords + [elSize]) ))\n            _insertInSetDict(pointMarkers, marker, ID)\n        \n        # WRITE CURVES:\n        for ID, [curveName, points, marker, elOnCurve, distributionString, distributionVal] in self.geometry.curves.items():\n            self.geofile.write(""%s(%i) = {%s};\\n"" %  (curveName, ID+1, _formatList(points, 1) ))\n            \n            #Transfinite Line{2} = 20 Using Bump 0.05;\n            if elOnCurve != None:\n                distribution = """" if distributionString==None else ""Using %s %f"" % (distributionString, distributionVal) \n                self.geofile.write(""Transfinite Line{%i} = %i %s;\\n"" % (ID+1, elOnCurve+1, distribution) ) \n                #+1 on elOnCurve because gmsh actually takes the number of nodes on the curve, not elements on the curve.\n            _insertInSetDict(curveMarkers, marker, ID)\n        \n        # WRITE SURFACES:\n        for ID, [surfName, outerLoop, holes, ID, marker, isStructured] in self.geometry.surfaces.items():\n            #First we write line loops for the surface edge and holes (if there are any holes):\n            self._writeLineLoop(outerLoop, ID+1)\n            holeIDs = []\n            for hole, i in zip(holes, range(len(holes))):\n                #Create a hopefully unique ID-number for the line loop: Like 10015 or 1540035\n                holeID = 10000 * (ID+1) + 10 * i + 5 #(If gmsh uses 32-bit integers for IDs then IDs over 214\'748 will break)\n                self._writeLineLoop(hole, holeID)\n                holeIDs.append(holeID)\n            #Second, we write the surface itself: \n            holeString = """" if not holeIDs else "", "" + _formatList(holeIDs) #If we have hole we want to include them in the surface.\n            self.geofile.write(""%s(%i) = {%s%s};\\n"" % (surfName, ID+1, ID+1, holeString)) #Like ""Plane Surface(2) = {4, 2, 6, 8}\n            #Lastly, we make the surface transfinite if it is a structured surface: \n            if isStructured:\n                cornerPoints = set() \n                for c in outerLoop:#Find the corner points. This is possibly unnecessary since Gmsh can do this automatically.\n                    curvePoints = self.geometry.curves[c][1]\n                    cornerPoints.add(curvePoints[0])\n                    cornerPoints.add(curvePoints[-1])\n                cornerPoints = list(cornerPoints)\n                self.geofile.write(""Transfinite Surface{%i} = {%s};\\n"" % (ID+1, _formatList(cornerPoints, 1)))#Like Transfinite Surface{1} = {1,2,3,4};\n                #Transfinite Surface has an optional argument (about triangle orientation) that is not implemented here.\n            _insertInSetDict(surfaceMarkers, marker, ID)\n        \n        # WRITE VOLUMES:\n        for ID, [outerLoop, holes, ID, marker, isStructured] in self.geometry.volumes.items():\n            #Surface loops for the volume boundary and holes (if any):\n            self._writeSurfaceLoop(outerLoop, ID+1)\n            holeIDs = []\n            for hole, i in zip(holes, range(len(holes))):\n                holeID = 10000 * (ID+1) + 10 * i + 7 # ID-number for the hole surface loop\n                self._writeSurfaceLoop(hole, holeID)\n                holeIDs.append(holeID)\n            #Write the volume itself: \n            holeString = """" if not holeIDs else "" , "" + _formatList(holeIDs) #If we have hole we want to include them in the surface.\n            self.geofile.write(""Volume(%i) = {%s%s};\\n"" % (ID+1, ID+1, holeString)) #Like ""Plane Surface(2) = {4, 2, 6, 8}\n            #Lastly, we make the volume transfinite if it is a structured volume: \n            if isStructured:\n                self.geofile.write(""Transfinite Volume{%i} = {};\\n"" % (ID+1))\n                #We don\'t find the corner points of the structured volume like we did with the surfaces. Gmsh can actually\n                #find the corners automatically.\n            _insertInSetDict(volumeMarkers, marker, ID)\n        \n        # MAYBE MAKE QUADS:\n        if(self.elType in self._ElementsWithQuadFaces):#If we have quads surfaces on the elements\n            self.geofile.write(""Mesh.RecombineAll = 1;\\n"")\n        \n        # WRITE POINT MARKERS:\n        for marker, IDlist in pointMarkers.items():\n            if marker != 0:\n                self.geofile.write(""Physical Point(%i) = {%s};\\n"" % (marker, _formatList(IDlist, 1) ))\n        \n        # WRITE CURVE MARKERS:\n        for marker, IDlist in curveMarkers.items():\n            self.geofile.write(""Physical Line(%i) = {%s};\\n"" % (marker, _formatList(IDlist, 1) ))\n            \n        # WRITE SURFACE MARKERS:\n        for marker, IDlist in surfaceMarkers.items():\n            self.geofile.write(""Physical Surface(%i) = {%s};\\n"" % (marker, _formatList(IDlist, 1) ))\n            \n        # WRITE SURFACE MARKERS:\n        for marker, IDlist in volumeMarkers.items():\n            self.geofile.write(""Physical Volume(%i) = {%s};\\n"" % (marker, _formatList(IDlist, 1) ))\n            \n        # If the element type is of an incomplete second order type\n        # (i.e it is an 2nd order element without nodes in the middle of the element face),\n        # then we need to specify this in the geo-file:\n        if self.elType in self._2dOrderIncompleteElms:\n            self.geofile.write(""Mesh.SecondOrderIncomplete=1;\\n"")\n\n       \n    def _writeLineLoop(self, lineIndices, loopID): \n        endPoints = [] #endPoints is used to keep track of at which points the curves start and end (i.e the direction of the curves)\n        for i in lineIndices: #lineIndices is a list of curve indices (0-based here, but 1-based later in the method)\n            curvePoints = self.geometry.curves[i][1]\n            endPoints.append([curvePoints[0], curvePoints[-1]])\n        \n        lineIndices = _offsetIndices(lineIndices, 1) #We need the indices to be 1-based rather than 0-based in the next loop. (Some indices will be preceded by a minus-sign)\n        isFirstLine = True\n        nbrLinesinLoop = len(lineIndices)\n        for k in range(nbrLinesinLoop): # In this loop we reverse the direction of some lines in the LineLoop to make them conform to the format that Gmsh expects.\n            if isFirstLine and nbrLinesinLoop>1:\n                isFirstLine = False\n                if endPoints[0][1] in endPoints[1]: #If last point of the first line exists in the endpoints of the second line... Do nothing\n                    pass\n                elif endPoints[0][0] in endPoints[1]: #Else if the first point in the first line exists in the endpoints of the second line:\n                    endPoints[0].reverse()\n                    lineIndices[0] *= -1 #Reverse the direction of the line\n                else:\n                    raise Exception(""ERROR: The first curve of line-loop %i does not link up to the subsequent curve"" % loopID)\n            elif endPoints[k][0] == endPoints[k-1][1]:\n                pass\n            elif endPoints[k][1] == endPoints[k-1][1]:\n                endPoints[k].reverse()\n                lineIndices[k] *= -1 #Reverse the direction of the line\n            else:\n                raise Exception(""ERROR: The %i th curve (starting from 0) of a line-loop %i does not link up with the preceding curve"" % (k, loopID))\n            if k==nbrLinesinLoop-1 and endPoints[k][1] != endPoints[0][0]: \n                #If last line AND the last point of the last curve not equal the first point of the first curve:\n                raise Exception(""ERROR: The last curve of a line-loop %i does not join up with the first curve"" % loopID)\n        \n        if not self.geometry.is3D: #If the model is in 2D we need to make all line loops counter-clockwise so surface normals point in the positive z-direction.\n            lineIndices = self._makeCounterClockwise(lineIndices)\n        \n        self.geofile.write(""Line Loop(%i) = {%s};\\n"" % (loopID, _formatList(lineIndices))) #(lineIndices are alreay 1-based here)\n        \n    def _makeCounterClockwise(self, lineIndices):\n        \'\'\'If the lineIndices describe a line loop that is not counterclockwise,\n        this function will return a counterclockwise version of lineIndices\n        (i.e. all indices multiplied by -1).\n        lineIndices is a list of integers (1-based line indices) that may be negative, but not 0\'\'\'\n        #Method described at http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order\n        summa = 0.0 #Counter-clockwise if the sum ends up negative.\n        for index in lineIndices:\n            sign = -1 if index < 0 else 1\n            realIndex = sign*index - 1 #Make a copy of the line index that is positive and 0-based.\n            curveType = self.geometry.curves[realIndex][0]\n            pointIDs = self.geometry.curves[realIndex][1]\n            if curveType in [\'Spline\', \'BSpline\']:\n                points = [self.geometry.points[ID][0] for ID in pointIDs] # [[x,y,z], [x,y,z], ...]\n                points = points if sign==1 else points[::-1] #Reverse the order of the points if the curve direction is reversed.\n                for i in range(len(pointIDs)-1): #For every point along the curve except the last:\n                    summa += (points[i+1][0] - points[i][0]) * (points[i+1][1] + points[i][1])   #(x2-x1)(y2+y1).\n            elif curveType == \'Circle\':\n                #We will find a point \'d\' on the middle of the circle arc, and use a-d-c as approximation of the arc.\n                points = np.array([self.geometry.points[ID][0] for ID in pointIDs]) # 3-by-3 array. The rows are start-center-end points and columns are x,y,z.\n                points = points if sign==1 else points[::-1] #Reverse the order of the points if the curve direction is reversed.\n                a = points[0,:] #start\n                b = points[1,:] #center\n                c = points[2,:] #end\n                r = np.linalg.norm(a-b) #radius\n                d = b + r * (a + 2*b + c) / np.linalg.norm(a + 2*b +c)\n                approxArc = np.vstack((a, d, c))\n                for i in range(len(approxArc)-1):\n                    summa += (approxArc[i+1, 0] - approxArc[i, 0]) * (approxArc[i+1, 1] + approxArc[i, 1])   #(x2-x1)(y2+y1).\n            elif curveType == \'Ellipse\':\n                #We will find a point \'d\' near the middle of the circle arc, and use a-d-c as approximation of the arc.\n                # The only difference from the circle above, is that the radius at d is approximated as the mean distance between\n                # the center and the two other points.  \n                points = np.array([self.geometry.points[ID][0] for ID in pointIDs]) # 4-by-3 array. The rows are start-center-majAxis-end points and columns are x,y,z.\n                points = points[[0,1,3],:] #skip the major axis point (row 2)\n                points = points if sign==1 else points[::-1] #Reverse the order of the points if the curve direction is reversed.\n                a = points[0,:] #start\n                b = points[1,:] #center\n                c = points[2,:] #end\n                r = (np.linalg.norm(a-b) + np.linalg.norm(c-b)) / 2 #approximate radius\n                d = b + r * (a + 2*b + c) / np.linalg.norm(a + 2*b +c)\n                approxArc = np.vstack((a, d, c))\n                for i in range(len(approxArc)-1):\n                    summa += (approxArc[i+1, 0] - approxArc[i, 0]) * (approxArc[i+1, 1] + approxArc[i, 1])   #(x2-x1)(y2+y1).\n        if summa > 0: #If the sum is positive the loop (closed polygon) is clockwise, so reverse the direction of all curves:\n            lineIndices = [-x for x in lineIndices]\n        return lineIndices\n                \n             \n        \n    def _writeSurfaceLoop(self, outerLoop, ID):\n        self.geofile.write(""Surface Loop(%i) = {%s};\\n"" % (ID, _formatList(outerLoop, 1)))\n       \n'"
old/pycalfem_misc.py,0,"b'def mlscalar2d(coords, edof, a):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])\n    ascalar = reshape(asarray(a),[size(a)])\n\n    mlab.triangular_mesh(x, y, z, edof-1, scalars=ascalar, representation=""surface"")\n\ndef mlflux2d(coords, vf, scalefactor=None, displaymode=""2darrow""):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])\n    u = reshape(vf[:,0],[size(vf[:,0])])\n    v = reshape(vf[:,1],[size(vf[:,1])])\n    w = zeros([size(vf[:,0])])\n\n    if scalefactor == None:\n        mlab.quiver3d(x, y, z, u, v, w, mode=displaymode)\n    else:\n        mlab.quiver3d(x, y, z, u, v, w, mode=displaymode, scale_factor=scalefactor)\n\n\ndef mlwireframe2d(coords, edof):\n    if not haveMlab:\n        return\n\n    x = reshape(coords[:,0],[size(coords[:,0])])\n    y = reshape(coords[:,1],[size(coords[:,1])])\n    z = zeros([size(coords[:,0])])+1\n    scalars = ones([size(coords[:,0])])\n\n    mlab.triangular_mesh(x, y, z, edof-1, scalars=scalars, representation=""mesh"", colormap=""bone"", line_width=20.0)\n    \n\ndef eldisp2(ex,ey,ed,rat=0.2):\n    nen = -1\n    if ex.shape != ey.shape:\n        print ""ex and ey shapes do not match.""\n        return 1.0\n    \n    dlmax = 0.\n    edmax = 1.\n    \n    print rank(ex)\n\n    if rank(ex)==1:\n        nen = ex.shape[0]\n        nel = 1\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n    else:\n        nen = ex.shape[1]\n        nel = ex.shape[0]\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n        \n    k = rat\n    return k*dlmax/edmax\n'"
old/pycalfem_utils.py,0,"b'#!/bin/env python\n# -*- coding: iso-8859-15 -*-\n\nimport os, sys\n\nhaveMatplotLib = True\nhaveMlab = True\nhaveWx = True\nhaveQt = True\n    \nglobalWxApp = None\nglobalQtApp = None\nglobalWindows = []\n\ntry:\n    from PyQt4 import QtGui\n    from PyQt4.QtOpenGL import *\n    from pycalfem_classes_qt4 import ElementView\n    globalQtApp = QtGui.QApplication([""PyCalfem""])\nexcept:\n    haveQt = False    \n      \nif not haveQt:\n    try:\n        import wx\n        from pycalfem_classes import ElementView\n        globalWxApp = wx.App(0)\n    except: \n        haveWx = False\n      \nfrom pycalfem import *\n\ndef readInt(f):\n    """"""\n    Read a row from file, f, and return a list of integers.\n    """"""\n    return list(map(int, f.readline().split()))\n    \ndef readFloat(f):\n    """"""\n    Read a row from file, f, and return a list of floats.\n    """"""\n    return list(map(float, f.readline().split()))\n    \ndef readSingleInt(f):\n    """"""\n    Read a single integer from a row in file f. All other values on row are discarded.\n    """"""\n    return readInt(f)[0] \n\ndef readSingleFloat(f):\n    """"""\n    Read a single float from a row in file f. All other values on row are discarded.\n    """"""\n    return readFloat(f)[0]\n    \ndef writeSingleFloat(f, floatValue):\n    f.write(""%g\\n"" % floatValue)\n    \ndef writeSingleInt(f, intValue):\n    f.write(""%d\\n"" % intValue)\n\ndef writeFloatList(f, floatList):\n    for floatValue in floatList:\n        f.write(""%g "" % floatValue)\n    f.write(""\\n"")\n    \ndef writeIntList(f, intList):\n    for intValue in intList:\n        f.write(""%d "" % intValue)\n    f.write(""\\n"")\n    \n    \n\ndef which(filename):\n    """"""\n    Return complete path to executable given by filename.\n    """"""\n    if not (\'PATH\' in os.environ) or os.environ[\'PATH\'] == \'\':\n        p = os.defpath\n    else:\n        p = os.environ[\'PATH\']\n                \n    pathlist = p.split (os.pathsep)\n    pathlist.append(""."")\n    \n    for path in pathlist:\n        f = os.path.join(path, filename)\n        if os.access(f, os.X_OK):\n            return f\n    return None\n\ndef applybc(boundaryDofs, bcPrescr, bcVal, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary condition to bcPresc and bcVal matrices.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        bcPresc             1-dim integer array containing prescribed dofs.\n        bcVal               1-dim float array containing prescribed values.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not giben 0.0 is assigned.\n        dimension           dimension to apply bc. 0 - all, 1 - x, 2 - y\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if (dimension==0):\n            bcAdd = array(boundaryDofs[marker])\n            bcAddVal = ones([size(bcAdd)])*value\n        elif (dimension==1):\n            bcAdd = boundaryDofs[marker][(dimension-1)::2]\n            bcAddVal = ones([size(bcAdd)])*value\n        else:\n            bcAdd = boundaryDofs[marker][(dimension-1)::2]\n            bcAddVal = ones([size(bcAdd)])*value\n\n        return hstack([bcPrescr,bcAdd]), hstack([bcVal,bcAddVal])\n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n        \ndef applybcnode(nodeIdx, dofs, bcPrescr, bcVal, value=0.0, dimension=0):\n    \n    if (dimension==0):\n        bcAdd = asarray(dofs[nodeIdx])\n        bcAddVal = ones([size(bcAdd)])*value\n    elif (dimension==1):\n        bcAdd = asarray(dofs[nodeIdx,dimension-1])\n        bcAddVal = ones([size(bcAdd)])*value\n    else:\n        bcAdd = asarray(dofs[nodeIdx,dimension-1])\n        bcAddVal = ones([size(bcAdd)])*value\n\n    return hstack([bcPrescr,bcAdd]), hstack([bcVal,bcAddVal])\n    \n\ndef applyforcenode(nodeIdx, dofs, f, value=0.0, dimension=0):\n\n    if (dimension==0):\n        f[dofs[nodeIdx]]+=value\n    elif (dimension==1):\n        f[dofs[nodeIdx,dimension-1]]+=value\n    else:\n        f[dofs[nodeIdx,dimension-1]]+=value\n        \ndef applyforce(boundaryDofs, f, marker, value=0.0, dimension=0):\n    """"""\n    Apply boundary condition to bcPresc and bcVal matrices.\n    \n    Parameters:\n    \n        boundaryDofs        Dictionary with boundary dofs.\n        f                   force matrix.\n        marker              Boundary marker to assign boundary condition.\n        value               Value to assign boundary condition.\n                            If not giben 0.0 is assigned.\n        dimension           dimension to apply force. 0 - all, 1 - x, 2 - y\n                            \n    """"""\n\n    if marker in boundaryDofs:\n        if dimension == 0:\n            f[asarray(boundaryDofs[marker])-1] += value\n        elif dimension == 1:\n            f[asarray(boundaryDofs[marker][(dimension-1)::2])-1] += value\n        elif dimension == 2:\n            f[asarray(boundaryDofs[marker][(dimension-1)::2])-1] += value            \n    else:\n        print(""Error: Boundary marker"", marker, ""does not exist."")\n    \n\ndef trimesh2d(vertices, segments = None, holes = None, maxArea=None, quality=True, dofsPerNode=1, logFilename=""tri.log"", triangleExecutablePath=None):\n    """"""\n    Triangulates an area described by a number vertices (vertices) and a set\n    of segments that describes a closed polygon. \n    \n    Parameters:\n    \n        vertices            array [nVertices x 2] with vertices describing the geometry.\n        \n                            [[v0_x, v0_y],\n                             [   ...    ],\n                             [vn_x, vn_y]]\n                             \n        segments            array [nSegments x 3] with segments describing the geometry.\n                            \n                            [[s0_v0, s0_v1,marker],\n                             [        ...        ],\n                             [sn_v0, sn_v1,marker]]\n                             \n        holes               [Not currently used]\n        \n        maxArea             Maximum area for triangle. (None)\n        \n        quality             If true, triangles are prevented having angles < 30 degrees. (True)\n        \n        dofsPerNode         Number of degrees of freedom per node.\n        \n        logFilename         Filename for triangle output (""tri.log"")\n        \n    Returns:\n    \n        coords              Node coordinates\n        \n                            [[n0_x, n0_y],\n                             [   ...    ],\n                             [nn_x, nn_y]]\n                             \n        edof                Element topology\n        \n                            [[el0_dof1, ..., el0_dofn],\n                             [          ...          ],\n                             [eln_dof1, ..., eln_dofn]]\n                             \n        dofs                Node dofs\n        \n                            [[n0_dof1, ..., n0_dofn],\n                             [         ...         ],\n                             [nn_dof1, ..., nn_dofn]]\n                             \n        bdofs               Boundary dofs. Dictionary containing lists of dofs for\n                            each boundary marker. Dictionary key = marker id.\n        \n    """"""\n    \n    # Check for triangle executable\n    \n    triangleExecutable = triangleExecutablePath\n    \n    if triangleExecutable == None:    \n        triangleExecutable = """"\n        if sys.platform == ""win32"":\n            triangleExecutable = which(""triangle.exe"")\n        else:\n            triangleExecutable = which(""triangle"")\n    else:\n        if not os.path.exists(triangleExecutable):\n            triangleExecutable = None\n            \n    if triangleExecutable==None:\n        print(""Error: Could not find triangle. Please make sure that the \\ntriangle executable is available on the search path (PATH)."")\n        return None, None, None, None\n    \n    # Create triangle options\n    \n    options = """"\n    \n    if maxArea!=None:\n        options += ""-a%f "" % maxArea + "" ""\n    if quality:\n        options += ""-q""\n        \n    # Set initial variables\n    \n    nSegments = 0\n    nHoles = 0\n    nAttribs = 0\n    nBoundaryMarkers = 1\n    nVertices = len(vertices)\n    \n    # All files are created as temporary files\n    \n    if not os.path.exists(""./trimesh.temp""):\n        os.mkdir(""./trimesh.temp"")\n        \n    filename = ""./trimesh.temp/polyfile.poly""\n    \n    if not segments is None:\n        nSegments = len(segments)\n    \n    if not holes is None:\n        nHoles = len(holes)\n    \n    # Create a .poly file\n    \n    polyFile = open(filename, ""w"")\n    polyFile.write(""%d 2 %d \\n"" % (nVertices, nAttribs))\n    \n    i = 0\n    \n    for vertex in vertices:\n        polyFile.write(""%d %g %g\\n"" % (i, vertex[0], vertex[1])) \n        i = i + 1\n        \n    polyFile.write(""%d %d \\n"" % (nSegments, nBoundaryMarkers))\n        \n    i = 0\n        \n    for segment in segments:\n        polyFile.write(""%d %d %d %d\\n"" % (i, segment[0], segment[1], segment[2]))\n        i = i + 1\n        \n    polyFile.write(""0\\n"")\n    \n    polyFile.close()\n\n    # Execute triangle\n    \n    os.system(""%s %s %s > tri.log"" % (triangleExecutable, options, filename))\n    \n    # Read results from triangle\n    \n    strippedName = os.path.splitext(filename)[0]\n    \n    nodeFilename = ""%s.1.node"" % strippedName\n    elementFilename = ""%s.1.ele"" % strippedName\n    polyFilename = ""%s.1.poly"" % strippedName\n    \n    # Read vertices\n    \n    allVertices = None\n    boundaryVertices = {}\n    \n    if os.path.exists(nodeFilename):\n        nodeFile = open(nodeFilename, ""r"")\n        nodeInfo = list(map(int, nodeFile.readline().split()))\n        \n        nNodes = nodeInfo[0]\n        \n        allVertices = zeros([nNodes,2], \'d\')\n        \n        for i in range(nNodes):\n            vertexRow = list(map(float, nodeFile.readline().split()))\n            \n            boundaryMarker = int(vertexRow[3])\n            \n            if not (boundaryMarker in boundaryVertices):\n                boundaryVertices[boundaryMarker] = []\n            \n            allVertices[i,:] = [vertexRow[1], vertexRow[2]]\n            boundaryVertices[boundaryMarker].append(i+1)\n            \n        nodeFile.close()\n               \n    # Read elements\n            \n    elements = []\n        \n    if os.path.exists(elementFilename):\n        elementFile = open(elementFilename, ""r"")\n        elementInfo = list(map(int, elementFile.readline().split()))\n        \n        nElements = elementInfo[0]\n        \n        elements = zeros([nElements,3],\'i\')\n        \n        for i in range(nElements):\n            elementRow = list(map(int, elementFile.readline().split()))\n            elements[i,:] = [elementRow[1]+1, elementRow[2]+1, elementRow[3]+1]\n            \n        elementFile.close()\n            \n    # Clean up\n    \n    try:\n        pass\n        #os.remove(filename)\n        #os.remove(nodeFilename)\n        #os.remove(elementFilename)\n        #os.remove(polyFilename)\n    except:\n        pass\n    \n    # Add dofs in edof and bcVerts\n    \n    dofs = createdofs(size(allVertices,0),dofsPerNode)\n    \n    if dofsPerNode>1:\n        expandedElements = zeros((size(elements,0),3*dofsPerNode),\'i\')\n        dofs = createdofs(size(allVertices,0),dofsPerNode)\n        \n        elIdx = 0\n        \n        for elementTopo in elements:        \n            for i in range(3):\n                expandedElements[elIdx,i*dofsPerNode:(i*dofsPerNode+dofsPerNode)] = dofs[elementTopo[i]-1,:]\n            elIdx += 1\n            \n        for bVertIdx in boundaryVertices.keys():\n            bVert = boundaryVertices[bVertIdx]\n            bVertNew = []\n            for i in range(len(bVert)):\n                for j in range(dofsPerNode):\n                    bVertNew.append(dofs[bVert[i]-1][j])\n                    \n            boundaryVertices[bVertIdx] = bVertNew\n            \n        return allVertices, asarray(expandedElements), dofs, boundaryVertices\n        \n    \n    return allVertices, elements, dofs, boundaryVertices\n\ndef eldraw2(ex, ey):\n    """"""\n    Draw elements in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    #class ElDispApp(wx.App):\n    #    def OnInit(self):\n    #        wx.InitAllImageHandlers()\n    #        mainWindow = ElementView(None, -1, """")\n    #        mainWindow.ex = ex\n    #        mainWindow.ey = ey\n    #        mainWindow.showNodalValues = False\n    #        self.SetTopWindow(mainWindow)\n    #        mainWindow.Show()\n    #        return 1\n    #\n    #app = ElDispApp(0)\n    #app.MainLoop()\n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.showNodalValues = False\n    mainWindow.Show()   \n    globalWindows.append(mainWindow)\n    \ndef eliso2(ex, ey, ed, showMesh=False):\n    """"""\n    Draw nodal values in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        ed              Element nodal values\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    #class ElDispApp(wx.App):\n    #    def OnInit(self):\n    #        wx.InitAllImageHandlers()\n    #        mainWindow = ElementView(None, -1, """")\n    #        mainWindow.ex = ex\n    #        mainWindow.ey = ey\n    #        mainWindow.ed = ed\n    #        mainWindow.showMesh = showMesh\n    #        mainWindow.showNodalValues = True\n    #        self.SetTopWindow(mainWindow)\n    #        mainWindow.Show()\n    #        return 1   \n    #\n    #app = ElDispApp(0)\n    #app.MainLoop()\n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ed = ed\n    mainWindow.showMesh = showMesh\n    mainWindow.showNodalValues = True\n    mainWindow.Show()\n    globalWindows.append(mainWindow)\n    \ndef elval2(ex, ey, ev, showMesh=False):\n    """"""\n    Draw elements values in 2d.\n    \n    Parameters:\n    \n        ex, ey          Element coordinates\n        ev              Element values (scalar)\n        plotpar         (not implemented yet)\n    \n    """"""\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n    \n    mainWindow = ElementView(None, -1, """")\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ev = ev\n    mainWindow.showMesh = showMesh\n    mainWindow.showElementValues = True\n    mainWindow.showNodalValues = False\n    mainWindow.Show()\n    globalWindows.append(mainWindow)\n    \ndef eldisp2(ex, ey, ed, magnfac=0.1, showMesh=True):\n    #if not haveWx:\n    #    print(""wxPython not installed."")\n    #    return\n        \n    mainWindow = ElementView(None, -1, """")\n    mainWindow.dofsPerNode = 2\n    mainWindow.ex = ex\n    mainWindow.ey = ey\n    mainWindow.ed = ed\n    mainWindow.showMesh = showMesh\n    mainWindow.showNodalValues = False\n    mainWindow.showDisplacements = True\n    mainWindow.magnfac = magnfac\n    mainWindow.Show()    \n    globalWindows.append(mainWindow)\n           \ndef waitDisplay():\n    if haveQt:\n        globalQtApp.exec_()        \n    else:\n        globalWxApp.MainLoop()\n        \n\ndef show():\n    if haveQt:\n        globalQtApp.exec_()\n    else:\n        globalWxApp.MainLoop()\n\ndef elmargin(scale=0.2):\n    a = gca()\n    xlim = a.get_xlim()\n    ylim = a.get_ylim()\n    xs = xlim[1]-xlim[0]\n    ys = ylim[1]-ylim[0]\n    a.set_xlim([xlim[0]-xs*scale,xlim[1]+xs*scale])\n    a.set_ylim([ylim[0]-ys*scale,ylim[1]+ys*scale])\n    \ndef scalfact2(ex,ey,ed,rat=0.2):\n    """"""\n    Determine scale factor for drawing computational results, such as \n    displacements, section forces or flux.\n    \n    Parameters:\n    \n        ex, ey      element node coordinates\n                       \n        ed          element displacement matrix or section force matrix\n    \n        rat         relation between illustrated quantity and element size. \n                    If not specified, 0.2 is used.\n        \n    """"""\n\n    nen = -1\n    if ex.shape != ey.shape:\n        print(""ex and ey shapes do not match."")\n        return 1.0\n    \n    dlmax = 0.\n    edmax = 1.\n    \n    if rank(ex)==1:\n        nen = ex.shape[0]\n        nel = 1\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n    else:\n        nen = ex.shape[1]\n        nel = ex.shape[0]\n        dxmax=ex.T.max()-ex.T.min()\n        dymax=ey.T.max()-ey.T.min()\n        dlmax=max(dxmax,dymax);\n        edmax=abs(ed).max();\n        \n    k = rat\n    return k*dlmax/edmax\n\ndef elcenter2d(ex, ey):\n    exm = reshape(ex.sum(1)/ex.shape[1],[ex.shape[0],1])\n    eym = reshape(ey.sum(1)/ey.shape[1],[ey.shape[0],1])\n\n    return hstack([exm,eym])\n'"
old/pycalfem_vis.py,48,"b'import visvis as vv\nfrom visvis.wibjects.colorWibjects import Colorbar\nfrom visvis import Colormapable\nfrom visvis.wobjects.textures import minmax\nimport numpy as np\nfrom numpy import sin, cos, pi\nfrom math import atan2\nimport OpenGL.GL as gl #@UnresolvedImport\n\n\ndef getColorbar(axes=None):\n    \'\'\'\n    Returns the Colorbar.\n    If axes is None the colorbar in the current axes will be found.\n    If several colorbars exists in the axes the first found will be returned\n    If no colorbar is found None is returned.\n    \'\'\'\n    #An ugly solution, but visvis seems to have no other way of getting the colorbar,\n    #or most other entities that exist in the axes. \n    if axes is None:\n        axes = vv.gca()\n    for obj in axes.children: \n        if type(obj) == Colorbar:\n            return obj  \n    return None\n    \ndef colorBar(axes=None):\n    return getColorbar(axes)\n    \n\ndef _makeColorBar(text, axes=None):\n    \'\'\'\n    Convenience function that finds the current colorbar in the axes\n    or creates a new one if one does not exist.\n    The reason is that colorbars can not be deleted without clearing \n    the whole figure, and several colorbars can exist simultaneously. \n    This should be avoided.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    colBar = getColorbar(axes)\n    if colBar is None:\n        vv.colorbar(axes).SetLabel(text) #Creates a colorbar and sets the label.\n    else:\n        colBar.SetLabel(text)# A colorbar already exists, Change label.\n\ndef addLabel(text, pos, angle=0, fontName=None, fontSize=9, color=\'k\', bgcolor=None, axes=None):\n    \'\'\'\n    Adds a label inside the axes. Returns the Label object.\n    Parameters:\n    text    - String. The text of the label\n    pos     - Tuple with two numbers. The (x,y) position of the label with origin\n              at the upper left corner.\n    angle   - Float or int. The rotation of the label in degrees.\n    fontname- String. Either \'mono\', \'sans\' or \'serif\'.\n    fontSize- Int. Size of the text. Default 9.\n    color   - A 3-tuple or a character in \'rgbycmkw\', etc that defines text color.\n              Default \'k\' (black).\n    bgcolor - Background color. See color. Default None.\n    axes    - Axes wherein the label is placed. If None then the current axes is\n              chosen.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    label = vv.Label(axes, text, fontName, fontSize, color)\n    label.position = pos\n    label.bgcolor = bgcolor\n    label.textAngle = angle\n    return label\n    \ndef addText(text, pos, angle=0, fontName=None, fontSize=9, color=\'k\', bgcolor=None, axes=None):\n    \'\'\'\n    Adds a text in the world space. Returns the Text object.\n    Parameters:\n    text    - String. The text of the label\n    pos     - Tuple with two or three numbers. The (x,y,z) position of the text in\n              world space.\n    angle   - Float or int. The rotation of the label in degrees.\n    fontname- String. Either \'mono\', \'sans\' or \'serif\'.\n    fontSize- Int. Size of the text. Default 9.\n    color   - A 3-tuple or a character in \'rgbycmkw\', etc that defines text color.\n              Default \'k\' (black).\n    bgcolor - Background color. See color. Default None.\n    axes    - Axes wherein the label is placed. If None then the current axes is \n              chosen.\n    \'\'\'\n    if axes is None:\n        axes = vv.gca()\n    text = vv.Text(axes, text, *pos, fontName=fontName, fontSize=fontSize, color=color)\n    text.bgcolor = bgcolor\n    text.textAngle = angle\n    return text\n\n\ndef drawMesh(coords, edof, dofsPerNode, elType, axes=None, axesAdjust=True, \n             title=None, color=(0,0,0), faceColor=(1,1,1), filled=False):\n    \'\'\'\n    Draws wire mesh of model in 2D or 3D. Returns the Mesh object that represents\n    the mesh.\n    Parameters:\n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofsPerNode - Integer. Dofs per node.\n    elType      - Integer. Element Type. See Gmsh manual for details. Usually 2\n                  for triangles or 3 for quadrangles.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axesAdjust  - Boolean. True if the view should be changed to show the whole\n                  model. Default True.\n    title       - String. Changes title of the figure. Default ""Mesh"".\n    color       - 3-tuple or char. Color of the wire. Defaults to black (0,0,0).\n                  Can also be given as a character in \'rgbycmkw\'.\n    faceColor   - 3-tuple or char. Color of the faces. Defaults to white (1,1,1).\n                  Parameter filled must be True or faces will not be drawn at all.\n    filled      - Boolean. Faces will be drawn if True. Otherwise only the wire is\n                  drawn. Default False.\n    \'\'\'\n    #Prep:\n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofsPerNode, elType)\n    #Create mesh:\n    m = vv.Mesh(parent=axes, vertices=verts, faces=faces, values=color, verticesPerFace=verticesPerFace)\n    #Settings:\n    fShade = \'plain\' if filled else None\n    m.faceShading, m.edgeShading = (fShade, \'plain\')\n    m.edgeColor = color\n    m.faceColor = faceColor\n    m.specular = 0 \n    #Adjust axes:\n    if axesAdjust:\n        _adjustaxes(axes, is3D)\n    #Set title and return:\n    vv.title(title, axes)\n    return m\n    \n    \ndef drawNodalValues(nodeVals, coords, edof, dofsPerNode, elType, clim=None, axes=None, axesAdjust=True, doDrawMesh=True, title=None):\n    \'\'\'\n    Draws scalar nodal values in 2D or 3D. Returns the Mesh object that represents\n    the mesh.\n    Parameters:\n    nodeVals    - An N-by-1 array or a list of scalars. The Scalar values at the\n                  nodes. nodeVals[i] should be the value of node i \n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements \n                  and L is the number of dofs per element)\n    dofsPerNode - Integer. Dofs per node.\n    elType      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set to\n                  min/max of nodeVals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axesAdjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    doDrawMesh  - Boolean. True if mesh wire should be drawn. Default True.\n    title       - String. Changes title of the figure. Default ""Node Values"".\n    \'\'\'    \n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofsPerNode, elType)\n    m = vv.Mesh(parent=axes, vertices=verts, faces=faces, values=nodeVals, verticesPerFace=verticesPerFace)\n    \n    if clim != None: #Set colorbar limits.\n        m.clim = clim\n        setClim = False\n    else:\n        setClim = True\n    \n    edgeSh = \'plain\' if doDrawMesh else None\n    m.faceShading, m.edgeShading = (\'smooth\', edgeSh)#NOTE: It seems colormap coloring breaks when faceshading=\'plain\'. \'smooth\' must be used.\n    m.ambient = 1\n    m.diffuse = 0\n    m.specular = 0 #Disable specular. \n    m.SetValues(nodeVals, setClim) #Set the values again, because it doesn\'t work in the constructor for unknown reasons\n    \n    axes.light0.ambient = 1.0\n    axes.light0.diffuse = 0.0  #Only ambient light to avoid shadows\n    \n    m.colormap = vv.colormaps[\'jet\']\n    _makeColorBar(""Node values"", axes)\n        \n    # Adjust axes:\n    if axesAdjust:\n        _adjustaxes(axes, is3D)\n    \n    vv.title(title, axes)\n    return m\n    \ndef drawElementValues(ev, coords, edof, dofsPerNode, elType, displacements=None, clim=None, axes=None, \n                      axesAdjust=True, doDrawMesh=True, doDrawUndisplacedMesh=False, magnfac=1.0, title=None):\n    \'\'\'\n    Draws scalar element values in 2D or 3D. Returns the world object \n    elementsWobject that represents the mesh.\n    Parameters:\n    ev          - An N-by-1 array or a list of scalars. The Scalar values of the\n                  elements. ev[i] should be the value of element i. \n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofsPerNode - Integer. Dofs per node.\n    elType      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    displacements - An N-by-2 or N-by-3 array. Row i contains the x,y,z \n                    displacements of node i.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set to\n                  min/max of nodeVals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axesAdjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    doDrawMesh  - Boolean. True if mesh wire should be drawn. Default True.\n    doDrawUndisplacedMesh - Boolean. True if the wire of the undisplaced mesh \n                  should be drawn on top of the displaced mesh. Default False. \n                  Use only if displacements != None.\n    magnfac     - Float. Magnification factor. Displacements are multiplied by\n                  this value. Use this to make small displacements more visible.\n    title       - String. Changes title of the figure. Default ""Element Values"".\n    \'\'\'\n    #Since vis.Mesh does not allow setting different colours for different faces, we need\n    # a custom world object (WObject) for this function. \n    # http://code.google.com/p/visvis/wiki/example_customWobject\n    # http://code.google.com/p/visvis/wiki/creatingWibjectsAndWobjects\n    \n\n    if doDrawUndisplacedMesh:\n        drawMesh(coords, edof, dofsPerNode, elType, axes, axesAdjust, color=(0.5, 0.5, 0.5))\n    \n    if displacements is not None:\n        if displacements.shape[1] != coords.shape[1]:\n            displacements = np.reshape(displacements, (-1, coords.shape[1]))\n            coords = np.asarray(coords + magnfac * displacements)\n    \n    axes, verts, faces, verticesPerFace, is3D = _preMeshDrawPrep(axes, coords, edof, dofsPerNode, elType)\n    \n    \n    #This is done because 3D elements are made up of several faces.\n    #TODO: Discard inner faces that are not visible.\n    fPerElms = { 1:0,   2:1,   3:1,   4:4,   5:6} #TODO: Extend with more element types\n    facesPerElement = fPerElms[elType]\n    #Repeat the element values so that we get the value of each face:\n    faceVals = np.repeat(ev, facesPerElement, axis=0) \n\n    c = _elementsWobject(axes, faceVals, verts, faces, verticesPerFace, doDrawMesh, clim) #Creates the world object that gets drawn on screen.\n    \n    _makeColorBar(""Element values"", axes) #Finds or creates colorbar and sets the label.\n    \n    # Adjust axes\n    if axesAdjust:\n        _adjustaxes(axes, is3D)\n    \n    vv.title(title, axes)\n    return c\n    \ndef drawDisplacements(displacements, coords, edof, dofsPerNode, elType, nodeVals=None, clim=None, axes=None, \n                      axesAdjust=True, doDrawUndisplacedMesh=True, magnfac=1.0,  title=None):\n    \'\'\'\n    Draws mesh with displacements in 2D or 3D. Scalar nodal values can also be \n    drawn on the mesh. Returns the displaced Mesh object.\n    Parameters:\n    displacements-An N-by-1 array (or matrix). Row i contains the displacement of\n                  dof i. \n                  N-by-2 or N-by-3 arrays are also accepted, in which case row i \n                  contains the x,y,z displacements of node i.\n    coords      - An N-by-2 or N-by-3 array. Row i contains the x,y,z coordinates\n                  of node i.\n    edof        - An E-by-L array. Element topology. (E is the number of elements\n                  and L is the number of dofs per element)\n    dofsPerNode - Integer. Dofs per node.\n    elType      - Integer. Element Type. See Gmsh manual for details. Usually 2 \n                  for triangles or 3 for quadrangles.\n    nodeVals    - An N-by-1 array or a list of scalars. The Scalar values at the\n                  nodes. nodeVals[i] should be the value of node i.\n    clim        - 2-tuple. Colorbar limits (min, max). Defines the value range of\n                  the colorbar. Defaults to None, in which case min/max are set \n                  to min/max of nodeVals.\n    axes        - Visvis Axes. The Axes where the model will be drawn. \n                  If unspecified the current Axes will be used, or a new Axes will\n                  be created if none exist.\n    axesAdjust  - Boolean. True if the view should be changed to show the whole \n                  model. Default True.\n    doDrawMesh  - Boolean. True if mesh wire should be drawn. Default True.\n    magnfac     - Float. Magnification factor. Displacements are multiplied by\n                  this value. Use this to make small displacements more visible.\n    title       - String. Changes title of the figure. Default None (in which case\n                  title depends on other parameters).\n    \'\'\'\n    \n    if displacements.shape[1] != coords.shape[1]:\n        displacements = np.reshape(displacements, (-1, coords.shape[1]))\n    displaced = np.asarray(coords + magnfac * displacements)\n       \n    if doDrawUndisplacedMesh:\n        drawMesh(coords, edof, dofsPerNode, elType, axes, axesAdjust, title=title, color=(0.5, 0.5, 0.5), filled=False)\n    \n    if nodeVals != None:\n        m = drawNodalValues(nodeVals, displaced, edof, dofsPerNode, elType, clim=clim, axes=axes, axesAdjust=axesAdjust, doDrawMesh=True, title=title)\n    else:\n        m = drawMesh(displaced, edof, dofsPerNode, elType, axes, axesAdjust, title=title) \n    \n    if title != None:\n        vv.title(title, axes)\n    return m\n    \ndef drawGeometry(geoData, axes=None, axesAdjust=True, drawPoints=True, labelPoints=True, labelCurves=True, title=None, fontSize=11, N=20):\n    \'\'\'\n    Draws the geometry (points and curves) in geoData\n    Parameters:\n    geoData    - GeoData object. Geodata contains geometric information of the \n                 model.\n    axes       - Visvis Axes. The Axes where the model will be drawn. \n                 If unspecified the current Axes will be used, or a new Axes will\n                 be created if none exist.\n    axesAdjust - Boolean. If True the view will be changed to show the whole \n                 model. Default True.\n    drawPoints - Boolean. If True points will be drawn.\n    labelPoints- Boolean. If True Points will be labeled. The format is:\n                 ID[marker]. If a point has marker==0 only the ID is written. \n    labelCurves- Boolean. If True Curves will be labeled. The format is: \n                 ID(elementsOnCurve)[marker].\n    fontSize   - Integer. Size of the text in the text labels. Default 11. \n    N          - Integer. The number of discrete points per curve segment. \n                 Default 20. Increase for smoother curves. Decrease for better \n                 performance.\n    \'\'\'\n    \n    if axes is None:\n        axes = vv.gca()\n    axes.bgcolor = (0.7, 0.7, 0.7)\n    \n    if drawPoints:\n        P = np.array(geoData.getPointCoords()) #M-by-3 list of M points.\n        plotArgs = {\'mc\':\'r\', \'mw\':5, \'lw\':0, \'ms\':\'o\', \'axesAdjust\':False, \'axes\':axes}\n        if geoData.is3D: \n            vv.plot(P[:,0], P[:,1], P[:,2], **plotArgs)\n        else:\n            vv.plot(P[:,0], P[:,1], **plotArgs)           \n        \n        if labelPoints: #Write text label at the points:\n            for (ID, (xyz, elSize, marker)) in geoData.points.items(): #[[x, y, z], elSize, marker]\n                text = ""  "" + str(ID) + (""[%s]""%marker if marker is not 0 else \'\')\n                addText(text, xyz, fontSize=fontSize-1, color=(0.5,0,0.5), axes=axes)  \n    \n    for(ID, (curveName, pointIDs, marker, elementsOnCurve, _, _)) in geoData.curves.items():\n        points = geoData.getPointCoords(pointIDs)\n        if curveName == ""Spline"":\n            P = _catmullspline(points, N)\n        if curveName == ""BSpline"":\n            P = _bspline(points, N)\n        if curveName == ""Circle"":\n            P = _circleArc(*points, pointsOnCurve=N)\n        if curveName == ""Ellipse"":\n            P = _ellipseArc(*points, pointsOnCurve=N)\n        plotArgs = {\'lc\':\'k\', \'ms\':None, \'axesAdjust\':False, \'axes\':axes} #Args for plot style. Black lines with no symbols at points.\n        if geoData.is3D:\n            vv.plot(P[:,0], P[:,1], P[:,2], **plotArgs)\n        else:\n            vv.plot(P[:,0], P[:,1], **plotArgs)\n        \n        if labelCurves:\n            midP = P[int(P.shape[0]*7.0/12), :].tolist() # Sort of midpoint along the curve. Where the text goes.\n            #Create the text for the curve. Includes ID, elementsOnCurve, and marker:\n            text = "" ""+str(ID)\n            text += ""(%s)""%(elementsOnCurve) if elementsOnCurve is not None else \'\'\n            text += ""[%s]""%(marker) if marker is not 0 else \'\' #Something like ""4(5)[8]""\n            addText(text, midP, fontSize=fontSize, axes=axes)\n        \n    if title != None:\n        vv.title(title, axes)\n    \n    if axesAdjust:\n        _adjustaxes(axes, geoData.is3D)\n    axes.daspectAuto = False\n    axes.daspect = (1,1,1)\n\n\ndef _preMeshDrawPrep(axes, coords, edof, dofsPerNode, elType):\n    \'\'\'Duplicate code. Extracts verts, faces and verticesPerFace from input.\'\'\'\n    if axes is None:\n        axes = vv.gca() #Gets current Axis or creates a new one if none exists.\n    \n    if np.shape(coords)[1] == 2:\n        is3D = False\n        verts = np.hstack((coords, np.zeros([np.shape(coords)[0],1]))) #pad with zeros to make 3D\n    elif np.shape(coords)[1] == 3:\n        is3D = True\n        verts = coords\n    else:\n        raise ValueError(\'coords must be N-by-2 or N-by-3 array\')\n    \n    if elType in [2, 4]: #elements with triangular faces    \n        verticesPerFace = 3\n    elif elType in [3,5,16]: #elements with rectangular faces\n        verticesPerFace = 4\n    else:   #[NOTE] This covers all element types available in CALFEM plus tetrahedrons. If more element types are added it is necessary to include them here and below.\n        raise ValueError(\'element type not implemented\')\n    \n    faces = (edof[:,0::dofsPerNode]-1)/dofsPerNode  \n\t#\'faces\' here are actually lists of nodes in elements, not in faces necessarily if the elements are in 3D. This case is handled below.   \n    \n    if elType in [4,5]: #if hexahedrons or tetrahedrons:\n        if  elType == 5:\n            G = np.array([[0,3,2,1],\n                       [0,1,5,4],\n                       [4,5,6,7],\n                       [2,6,5,1],\n                       [2,3,7,6],\n                       [0,4,7,3]]) #G is an array that is used to decomposes hexahedrons into its component faces.\n\t\t\t\t\t   #The numbers are from the node orders (see p94 in the Gmsh manual) and each row makes one face.\n        elif elType == 4:\n            G = np.array([[0,1,2],\n                       [0,3,2],\n                       [1,3,2],\n                       [0,3,1]]) #This G decomposes tetrahedrons into faces\n        faces = np.vstack([ faces[i, G] for i in range(faces.shape[0]) ])\n    elif elType == 16: #if 8-node-quads:\n        faces = faces[:, 0:4] #The first 4 nodes are the corners of the high order quad.\n        \n    axes.bgcolor = (0.7, 0.7, 0.7) #background colour.\n    return axes, verts, faces, verticesPerFace, is3D\n\n\ndef _adjustaxes(axes, is3D):\n    if axes.daspectAuto is None:\n            axes.daspectAuto = False\n    axes.cameraType = \'3d\' if is3D else \'2d\'\n    axes.SetLimits(margin=0.1)\n\n\ndef _catmullspline(controlPoints, pointsOnEachSegment=10):\n    """"""\n    Returns points on a Catmull-Rom spline that interpolated the control points.\n    Inital/end tangents are created by mirroring the second/second-to-last)\n    control points in the first/last points.\n    \n    Params:\n    controlPoints - Numpy array containing the control points of the spline. \n                    Each row should contain the x,y,(z) values.\n                    [[x1, y2],\n                     [x2, y2],\n                        ...    \n                     [xn, yn]]\n                     \n    pointsOnEachSegment - The number of points on each segment of the curve.\n                        If there are n control points and k samplesPerSegment, \n                        then there will be (n+1)*k numeric points on the curve.\n    """"""\n    controlPoints = np.asarray(controlPoints) #Convert to array if input is a list.\n    if (controlPoints[0,:] == controlPoints[-1,:]).all():\n        #If the curve is closed we extend each opposite endpoint to the other side  \n        CPs = np.asmatrix(np.vstack((controlPoints[-2,:],\n                                controlPoints,\n                                controlPoints[1,:])))\n    else: #Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0,:] - controlPoints[1,:],\n                                controlPoints,\n                                2*controlPoints[-1,:] - controlPoints[-2,:])))\n    M = 0.5 * np.matrix([[ 0,  2,  0,  0],[-1,  0,  1,  0],[ 2, -5,  4, -1],[-1,  3, -3,  1]])\n    t = np.linspace(0, 1, pointsOnEachSegment)\n    T = np.matrix([[1, s, pow(s,2), pow(s,3)] for s in t])\n    return np.asarray( np.vstack( T * M * CPs[j-1:j+3,:] for j in range( 1, len(CPs)-2 ) ) )\n\n\ndef _bspline(controlPoints, pointsOnCurve=20):\n    \'\'\'\n    Uniform cubic B-spline.\n    \n    Params:\n    controlPoints - Control points. Numpy array. One coordinate per row.\n    pointsOnCurve - number of sub points per segment\n    \n    Mirrored start- and end-points are added if the curve is not closed.\n    If the curve is closed some points are duplicated to make the closed \n    spline continuous. \n    (See http://www.cs.mtu.edu/~shene/COURSES/cs3621/NOTES/spline/B-spline/bspline-curve-closed.html)\n    \n    Based on descriptions on:\n    http://www.siggraph.org/education/materials/HyperGraph/modeling/splines/b_spline.htm\n    http://en.wikipedia.org/wiki/B-spline#Uniform_cubic_B-splines\n    \'\'\'\n    controlPoints = np.asarray(controlPoints) #Convert to array if input is a list.\n    if (controlPoints[0,:] == controlPoints[-1,:]).all():\n        #If the curve is closed we extend each opposite endpoint to the other side  \n        CPs = np.asmatrix(np.vstack((controlPoints[-2,:],\n                                controlPoints,\n                                controlPoints[1,:])))\n    else:#Else make mirrored endpoints:\n        CPs = np.asmatrix(np.vstack((2*controlPoints[0,:] - controlPoints[1,:],\n                                controlPoints,\n                                2*controlPoints[-1,:] - controlPoints[-2,:])))\n    M = (1.0/6) * np.matrix([[-1,  3, -3, 1],\n                          [ 3, -6,  3, 0],\n                          [-3,  0,  3, 0],\n                          [ 1,  4,  1, 0]])\n    t = np.linspace(0, 1, pointsOnCurve)\n    T = np.matrix([[pow(s,3), pow(s,2), s, 1] for s in t])\n    return np.asarray( np.vstack( T * M * CPs[i-1 : i+3, :] for i in range( 1, len(CPs)-2 ) ) )\n\ndef _circleArc(start, center, end, pointsOnCurve=20):\n    return _ellipseArc(start, center, start, end, pointsOnCurve)\n\ndef _ellipseArc(start, center, majAxP, end, pointsOnCurve=20):\n    \'\'\'Input are 3D 1-by-3 numpy arrays or vectors\'\'\'\n    #First part is to find a similarity transform in 3D that transform the ellipse to\n    #the XY-plane with the center at the origin and the major axis of the ellipse along the X-axis.\n    \n    #convert to arrays in case inputs are lists:\n    start, center, majAxP, end, = np.asarray(start), np.asarray(center), np.asarray(majAxP), np.asarray(end)\n    \n    zPrim = np.cross(start-center, end-center)\n    zPrim = zPrim / np.linalg.norm(zPrim)\n    xPrim = (majAxP-center) / np.linalg.norm(majAxP-center)\n    yPrim = np.cross(zPrim, xPrim)\n    \n    R = np.vstack((xPrim, yPrim, zPrim)).T #Rotation matrix from ordinary coords to system where ellipse is in the XY-plane. (Actually hstack)\n    T = np.hstack((R, np.asmatrix(center).T))   #Building Transformation matrix. -center is translation vector from ellipse center to origin.\n    T = np.mat( np.vstack((T, [0,0,0,1])) ) #Transformation matrix for homogenous coordinates.\n    \n    startHC = np.vstack((np.matrix(start).T, [1])) #\n    endHC = np.vstack((np.matrix(end).T, [1]))     # start and end points as column vectors in homogenous coordinates\n    \n    s = np.linalg.inv(T) * startHC #\n    e = np.linalg.inv(T) * endHC   # start and end points in the new coordinate system\n    \n    xs, ys = s[0,0], s[1,0] #\n    xe, ye = e[0,0], e[1,0] # Just extract x & y from the new start and endpoints  \n    \n    a = np.sqrt( (pow(ye*xs,2) - pow(xe*ys,2)) / (pow(ye,2) - pow(ys,2)) )\n    b = np.sqrt( (pow(ye*xs,2) - pow(xe*ys,2)) / ( (pow(ye,2) - pow(ys,2)) * ((pow(xe,2) - pow(xs,2)) / (pow(ys,2) - pow(ye,2)) ) ) )\n    \n    ts = atan2(ys/b, xs/a) #atan2 is a function that goes from -pi to pi. It gives the signed angle from the X-axis to point (y,x)\n    te = atan2(ye/b, xe/a) #We can\'t use the (transformed) start- and endpoints directly, but we divide x and y by the\n    # ellipse minor&major axes to get the parameter t that corresponds to the point on the ellipse. \n    # See ellipse formula: x = a * cos (t), y = b * sin(t). \n    # So ts and te are the parameter values of the start- and endpoints (in the transformed coordinate system).\n    \n    if ts > te:\n        ts, te = te, ts #swap if the start point comes before the endpoint in the parametric parameter that goes around the ellipse.\n    if te - ts < np.pi:\n        times = np.linspace(ts, te, pointsOnCurve) #parameter of ellipse curve. NOT angle to point on curve (like it could be for a circle).\n    else: #the shortest parameter distance between start- and end-point stradles the discontinuity that jumps from pi to -pi.  \n        ps1 = round(pointsOnCurve * (pi-te)/(2*pi-te+ts)) #number of points on the first length.\n        ps2 = round(pointsOnCurve * (ts+pi)/(2*pi-te+ts)) #number of points on the first length.\n        times = np.concatenate((np.linspace(te, pi, ps1), np.linspace(-pi, ts, ps2)))\n    \n    ellArc = np.array([[a*cos(t), b*sin(t)] for t in times]).T #points on arc (in 2D)\n    ellArc = np.vstack((ellArc, np.repeat(np.matrix([[0],[1]]), ellArc.shape[1], 1))) #Make 3D homogenous coords by adding rows of 0s and 1s.\n    ellArc = T * ellArc #Transform back to the original coordinate system   \n    return np.asarray(ellArc.T[:,0:3]) #return points as an N-by-3 array. \n\nclass _elementsWobject(vv.Wobject, Colormapable):\n    \'\'\'\n    Custom wobject for drawing element values.  \n    Based on example http://code.google.com/p/visvis/wiki/example_customWobject\n    \'\'\'\n    #TODO: Find a way to make rendering faster. (Dump internal faces, cull backfaces, \n    #TODO: Don\'t draw lines separately, pass array to GL instead of looping, etc?)\n    def __init__(self, parent, fVals, verts, faces, verticesPerFace, doDrawMesh, clim=None):\n        vv.Wobject.__init__(self, parent)\n        self._fVals = fVals # N-by-1 array?            values of N faces (not elements if 3D)\n        self._verts = verts # M-by-3 array             coordinates of M vertices  \n        self._faces = faces # N-by-3 or N-by-4 array   verts that make up N faces\n        self.verticesPerFace = verticesPerFace #3 or 4. Either we have triangle faces or quads.\n        self.doDrawMesh = doDrawMesh\n        self._valMin = np.amin(fVals)\n        self._valMax = np.amax(fVals)\n        Colormapable.__init__(self)\n        self._texture = None\n        self.clim = minmax(self._fVals) if clim is None else clim\n        self.colormap = vv.colormaps[\'jet\']\n    \n    def _drawFaces(self, how):\n        for (value, faceVerts) in zip(self._fVals, self._faces):\n            valueIndex = int( 255 * (value-self.clim.min)/(self.clim.max-self.clim.min) ) #Turn the value into an index between 0 and 255\n            if valueIndex > 255:\n                valueIndex = 255\n            elif valueIndex < 0:\n                valueIndex = 0\n            color = self.mapData[valueIndex, :] #get colour from value\n            coords = self._verts[faceVerts.astype(int), :] #get coordinates of the vertices of the face.\n            gl.glColor(*color)\n            gl.glBegin(how)\n            for (x,y,z) in coords:\n                gl.glVertex(x,y,z)\n            gl.glEnd()\n            \n    def _drawLines(self, how=gl.GL_LINE_LOOP, color=(0,0,0)):\n        for faceVerts in self._faces:\n            coords = self._verts[faceVerts.astype(int), :] #get coordinates of the vertices of the face.\n            gl.glColor(*color)\n            gl.glBegin(how)\n            for (x,y,z) in coords:\n                gl.glVertex(x,y,z)\n            gl.glEnd()\n            \n    def _GetLimits(self):\n        """""" Tell the axes how big this object is.\n        """""" \n        # Get limits\n        x1, x2 = minmax(self._verts[:,0])\n        y1, y2 = minmax(self._verts[:,1])\n        z1, z2 = minmax(self._verts[:,2])\n        return vv.Wobject._GetLimits(self, x1, x2, y1, y2, z1, z2)\n    \n    def OnDraw(self):\n        """""" To draw the object.\n        """""" \n        if self.doDrawMesh:\n            gl.glDisable(gl.GL_LINE_SMOOTH)\n            gl.glLineWidth(2)\n            self._drawLines(gl.GL_LINE_LOOP, (0,0,0))\n        if self.verticesPerFace == 3:\n            self._drawFaces(gl.GL_TRIANGLES)\n        elif self.verticesPerFace == 4:\n            self._drawFaces(gl.GL_QUADS)\n    \n    def OnDrawShape(self, clr):\n        """""" To draw the shape of the object.\n        Only necessary if you want to be able to ""pick"" this object\n        """"""\n        self._drawFaces(gl.GL_TRIANGLES, clr)\n    \n    def OnDrawScreen(self):\n        """""" If the object also needs to draw in screen coordinates.\n        Text needs this for instance.\n        """"""\n        pass\n    \n    def OnDestroyGl(self):\n        """""" To clean up any OpenGl resources such as textures or shaders.\n        """"""\n        pass\n    \n    def OnDestroy(self):\n        """""" To clean up any other resources.\n        """"""\n        pass\n    \n    #Overload _SetColormap get-setter so that we can change self.mapData, which we use \n    #to map values to colours without calling self._colormap.GetData() every draw call.\n    def _SetColormap(self, value):\n        self._colormap.SetMap(value)\n        self.mapData = self._colormap.GetData()\n'"
old/solver.py,0,"b'nCols = 20\nnRows = 30\n\nD = hooke(1, 2.1e9, 0.4)\n\nnDofs = dofs.max()\nnElements = nodeTopo.shape[0]\n\nprint ""Number of elements = "", nElements\nprint ""Max dofs           = "", nDofs\n\nK = zeros( [nDofs, nDofs] )\nf = zeros( [nDofs, 1] )\n\nfor i in range(24):\n    \n    ep = [1,0.1]\n    Ke, fe = plante(ex[i,:], ey[i,:], ep, D)\n\n    n1 = nodeTopo[i,0]\n    n2 = nodeTopo[i,1]\n    n3 = nodeTopo[i,2]\n    edof = array( [dofs[n1,0],dofs[n1,1],dofs[n2,0],dofs[n2,1],dofs[n3,0],dofs[n3,1]], \'int32\' )-1\n    K[ix_((edof),(edof))] = K[ix_((edof),(edof))] + Ke\n\nf[nDofs-1,0] = 10000\n\nbc = ones(nDofs, \'bool\')\nbcDofs = arange(nDofs)\nbc[0] = False\nbc[1] = False\nbc[int(nCols+1)*2] = False\nbc[int(nCols+1)*2+1] = False\nbc[2*int(nCols+1)*2] = False\nbc[2*int(nCols+1)*2+1] = False\nbc[3*int(nCols+1)*2] = False\nbc[3*int(nCols+1)*2+1] = False\n\nbcDofs = bcDofs[bc]\nprint bcDofs\n\nfsys = f[bcDofs]\n\nt = time()\na = linalg.solve(K[ix_((bcDofs),(bcDofs))], fsys);\nprint time()-t\n\nprint a\n\n#print K\n\n#spy(K)\n#show()\n#print Ke\n#print fe'"
old/test_patches.py,0,"b'import matplotlib\nfrom matplotlib.patches import Circle, Wedge, Polygon\nfrom matplotlib.collections import PatchCollection\nimport pylab\n\nfig=pylab.figure()\nax=fig.add_subplot(111)\n\nresolution = 50 # the number of vertices\nN = 3\nx       = pylab.rand(N)\ny       = pylab.rand(N)\nradii   = 0.1*pylab.rand(N)\npatches = []\nfor x1,y1,r in zip(x, y, radii):\n    circle = Circle((x1,y1), r)\n    patches.append(circle)\n\nx       = pylab.rand(N)\ny       = pylab.rand(N)\nradii   = 0.1*pylab.rand(N)\ntheta1  = 360.0*pylab.rand(N)\ntheta2  = 360.0*pylab.rand(N)\nfor x1,y1,r,t1,t2 in zip(x, y, radii, theta1, theta2):\n    wedge = Wedge((x1,y1), r, t1, t2)\n    patches.append(wedge)\n\n# Some limiting conditions on Wedge\npatches += [\n    Wedge((.3,.7), .1, 0, 360),             # Full circle\n    Wedge((.7,.8), .2, 0, 360, width=0.05), # Full ring\n    Wedge((.8,.3), .2, 0, 45),              # Full sector\n    Wedge((.8,.3), .2, 45, 90, width=0.10), # Ring sector\n]\n\nfor i in range(N):\n    polygon = Polygon(pylab.rand(N,2), True)\n    patches.append(polygon)\n\ncolors = 100*pylab.rand(len(patches))\np = PatchCollection(patches, cmap=matplotlib.cm.jet, alpha=0.4)\np.set_array(pylab.array(colors))\nax.add_collection(p)\npylab.colorbar(p)\n\npylab.show()\n'"
docs/source/conf.py,0,"b'#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# CALFEM for Python documentation build configuration file, created by\n# sphinx-quickstart on Mon May 30 23:34:38 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\'../..\'))\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = \'1.0\'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named \'sphinx.ext.*\') or your custom\n# ones.\nextensions = [\n    \'sphinx.ext.autodoc\',\n    \'sphinx.ext.viewcode\',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\'_templates\']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = [\'.rst\', \'.md\']\nsource_suffix = \'.rst\'\n\n# The encoding of source files.\n#source_encoding = \'utf-8-sig\'\n\n# The master toctree document.\nmaster_doc = \'index\'\n\n# General information about the project.\nproject = \'CALFEM for Python\'\ncopyright = \'2016-2020, Jonas Lindemann\'\nauthor = \'Jonas Lindemann\'\n\n# The version info for the project you\'re documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \'3.5\'\n# The full version, including alpha/beta/rc tags.\nrelease = \'3.5.1\'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set ""language"" from the command line for these cases.\nlanguage = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = \'\'\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = \'%B %d, %Y\'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = []\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, \'()\' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \'sphinx\'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as ""system message"" paragraphs in the built documents.\n#keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \'sphinx_rtd_theme\'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# ""<project> v<release> documentation"".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named ""default.css"" will overwrite the builtin ""default.css"".\nhtml_static_path = [\'_static\']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not \'\', a \'Last updated on:\' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = \'%b %d, %Y\'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, ""Created using Sphinx"" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, ""(C) Copyright ..."" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = \'\'\n\n# This is the file name suffix for HTML files (e.g. "".xhtml"").\n#html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   \'da\', \'de\', \'en\', \'es\', \'fi\', \'fr\', \'h\', \'it\', \'ja\'\n#   \'nl\', \'no\', \'pt\', \'ro\', \'r\', \'sv\', \'tr\'\n#html_search_language = \'en\'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only \'ja\' uses this config value\n#html_search_options = {\'type\': \'default\'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#html_search_scorer = \'scorer.js\'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \'CALFEMforPythondoc\'\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size (\'letterpaper\' or \'a4paper\').\n#\'papersize\': \'letterpaper\',\n\n# The font size (\'10pt\', \'11pt\' or \'12pt\').\n#\'pointsize\': \'10pt\',\n\n# Additional stuff for the LaTeX preamble.\n#\'preamble\': \'\',\n\n# Latex figure (float) alignment\n#\'figure_align\': \'htbp\',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \'CALFEMforPython.tex\', \'CALFEM for Python Documentation\',\n     \'Jonas Lindemann\', \'manual\'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For ""manual"" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \'calfemforpython\', \'CALFEM for Python Documentation\',\n     [author], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (master_doc, \'CALFEMforPython\', \'CALFEM for Python Documentation\',\n     author, \'CALFEMforPython\', \'One line description of project.\',\n     \'Miscellaneous\'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: \'footnote\', \'no\', or \'inline\'.\n#texinfo_show_urls = \'footnote\'\n\n# If true, do not generate a @detailmenu in the ""Top"" node\'s menu.\n#texinfo_no_detailmenu = False\n'"
examples/experimental/exed1.py,0,"b'import sys\nfrom math import sqrt\n\nfrom PyQt5.QtCore import pyqtSlot, pyqtSignal, QThread\nfrom PyQt5.QtWidgets import QApplication, QDialog, QWidget, QMainWindow, QFileDialog, QGraphicsScene, QGraphicsView, QGraphicsItem, QGraphicsEllipseItem, QGraphicsLineItem\nfrom PyQt5.QtGui import QPen, QBrush\nfrom PyQt5.Qt import Qt\nfrom PyQt5 import uic\n\nimport numpy as np\n\nimport calfem.geometry as cfg\n#import calfem.mesh as cfm\n#import calfem.vis as cfv\n#import calfem.utils as cfu\n#import calfem.core as cfc\n\nclass NodeItem(QGraphicsEllipseItem):\n    def __init__(self, x, y, width, height, parent = None):\n        super().__init__(x, y, width, height, parent)\n\n    def sceneEvent(self, event):\n        print(event.type())\n        return False\n\n\nclass MainWindow(QMainWindow):\n    """"""Main window class of our UI""""""\n    def __init__(self, g):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()\n\n        self.g = g\n\n        # Load user interface from UI-file\n\n        uic.loadUi(\'exed1.ui\', self)\n\n        self.init_scene()\n\n    def calc_bounding_box(self):\n        """"""Calc geometry bounding box""""""\n\n        self.max_x = -1e300\n        self.max_y = -1e300\n        self.min_x = 1e300\n        self.min_y = 1e300\n\n        for p in self.g.points.values():\n            if p[0][0]>self.max_x:\n                self.max_x = p[0][0]\n            if p[0][0]<self.min_x:\n                self.min_x = p[0][0]\n            if p[0][1]>self.max_y:\n                self.max_y = p[0][1]\n            if p[0][1]<self.min_y:\n                self.min_y = p[0][1]\n\n        self.bw = self.max_x - self.min_x\n        self.bh = self.max_y - self.min_y\n        self.hs = (self.bw+self.bh)*0.5*0.075\n\n\n    def init_scene(self):\n        """"""Setup scene""""""\n        self.scene = QGraphicsScene()\n        self.green_brush = QBrush(Qt.green)\n        self.gray_brush = QBrush(Qt.gray)\n        self.white_brush = QBrush(Qt.white)\n        self.pen = QPen(Qt.gray)\n        self.pen.setWidth(4)\n        self.pen.setCosmetic(True)\n        self.line_pen = QPen(Qt.red)\n        self.line_pen.setWidth(4)\n        self.line_pen.setCosmetic(True)\n\n        self.calc_bounding_box()\n\n        for c in self.g.curves.values():\n            if c[0] == \'Spline\':\n                i0 = c[1][0]\n                i1 = c[1][1]\n                p0 = self.g.points[i0][0]\n                p1 = self.g.points[i1][0]\n                gi = self.scene.addLine(p0[0], p0[1], p1[0], p1[1], self.pen)\n\n        for p in self.g.points.values():\n            gi = NodeItem(-self.hs/2, -self.hs/2, self.hs, self.hs)\n            gi.setBrush(self.white_brush)\n            gi.setPen(self.pen)\n            gi.setPos(p[0][0], p[0][1])\n            gi.setFlag(QGraphicsItem.ItemIsMovable)\n            gi.setFlag(QGraphicsItem.ItemIsSelectable)\n            self.scene.addItem(gi)\n            #gi = self.scene.addEllipse(-self.hs/2, -self.hs/2, self.hs, self.hs, self.pen, self.white_brush)\n\n        self.graphics_view.setScene(self.scene)\n        self.graphics_view.scale(200.0, 200.0)\n\n        print(self.scene.sceneRect())\n\n        #self.scene.setSceneRect(self.min_x, self.min_y, self.max_x-self.min_x, self.max_y-self.min_y)\n        #self.graphics_view.fitInView(self.scene.sceneRect())\n\n\n        #ellipse = self.scene.addEllipse(20,20, 200,200, self.pen, self.greenBrush)\n        #rect = self.scene.addRect(-100,-100, 200,200, self.pen, self.grayBrush)\n\n        #ellipse.setFlag(QGraphicsItem.ItemIsMovable)\n        #rect.setFlag(QGraphicsItem.ItemIsMovable)\n        #ellipse.setFlag(QGraphicsItem.ItemIsSelectable)\n\n        self.scene.focusItemChanged.connect(self.on_focus_item_changed)\n        self.scene.selectionChanged.connect(self.on_selection_changed)\n\n    def on_focus_item_changed(self, new_focus_item, old_focus_item, reason):\n        print(new_focus_item, reason)\n\n    def on_selection_changed(self):\n        if len(self.scene.selectedItems())>0:\n            print(self.scene.selectedItems()[0].pos())\n\n    def on_item_mouse_move(self):\n        print(""on_item_mouse_move"")\n\ndef edit_geometry(g):\n    app = QApplication(sys.argv)\n    widget = MainWindow(g)\n    widget.show()\n    sys.exit(app.exec_())\n\n\nif __name__ == ""__main__"":\n\n    g = cfg.Geometry()  # Create a GeoData object that holds the geometry.\n\n    # Add points:\n    #  The first parameter is the coordinates. These can be in 2D or 3D.\n    #  The other parameters are not defined in this example. These parameters are\n    #  ID, marker, and elSize.\n    #  Since we do not specify an ID the points are automatically assigned IDs,\n    #  starting from 0.\n\n    g.point([0, 0])\n    g.point([2, 0])\n    g.point([2, 1])\n    g.point([0, 1])\n    g.point([0.5, 0.3])\n    g.point([0.3, 0.7])\n    g.point([0.7, 0.7])\n    g.point([0.8, 0.5])\n    g.point([1.7, 0.5])\n    g.point([1.5, 0.5])\n    g.point([1.7, 0.7])\n\n    g.ellipse([7, 8, 9, 10], marker=50)\n    g.spline([0, 1], marker=80)\n    g.spline([2, 1])                      # 2\n    g.spline([3, 2])                      # 3\n    g.spline([0, 3])                      # 4\n    g.spline([7, 9], marker=50)           # 5\n    g.spline([10, 9])                     # 6\n    g.spline([4, 5, 6, 4])                # 7 - This is a closed spline.\n\n    g.surface([4, 3, 2, 1], [[7], [5, 6, 0]])    \n\n    edit_geometry(g)\n\n\n'"
examples/experimental/exint1.py,0,"b'# -*- coding: utf-8 -*-\n\nimport calfem.intvis as iv\n\n# --- Parametrar som kan \xc3\xa4ndras\n\na_edit = 1\nb_slider = 2.0\nc_list = [1, 2, 3]\nd_check = True\nf_param = 42.0\ng_float = 84.0\ng_int = 34\n\n# --- Redigera parametrar interaktivt\n\niv.edit_params(vars())\n\n# --- Redigera geometri\n\n#iv.edit_geometry(g)\n\n'"
examples/experimental/exm11.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.shapes as cfs\nimport calfem.solver as cfslv\n\ncfu.enableLogging()\n  \n# ---- General parameters ---------------------------------------------------\n\n# Define marker constants instead of using numbers in the code\n\ncfu.info(""Creating rectangle"")\n\nrect = cfs.Rectangle(5.0, 1.0, element_type=3, dofs_per_node=2, max_area=0.08)\nrect.t = 0.2\nrect.v = 0.35\nrect.E = 2e9\nrect.ptype = 1\nrect.ep = [rect.ptype, rect.t]\nrect.D = cfc.hooke(rect.ptype, rect.E, rect.v)\n\ncfu.info(""Creating mesh..."")\n\nmesh = cfs.ShapeMesh(rect)    \n\n# ---- Solve problem --------------------------------------------------------\n\nsolver = cfslv.Plan2DSolver(mesh)\n\nsolver.addBC(rect.left_id, 0.0)\nsolver.addForceTotal(rect.top_id, -10e5, dimension=2)\n\nresults = solver.execute()       \n       \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.draw_geometry(rect.geometry(), title=""Geometry"")\n\ncfv.figure() \ncfv.draw_mesh(mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure()\ncfv.draw_displacements(results.a, mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n                      draw_undisplaced_mesh=False, title=""Displacements"", \n                      magnfac=1)\n\ncfv.figure()\ncfv.draw_element_values(results.el_forces, mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, results.a, \n                      draw_elements=True, draw_undisplaced_mesh=False, \n                      title=""Effective Stress"", magnfac=1)\n                      \n#cfv.colorBar().SetLabel(""Effective stress"")\n\ncfu.info(""Done drawing..."")\n\ncfv.show_and_wait()'"
examples/experimental/exm11_mpl.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.shapes as cfs\nimport calfem.solver as cfslv\n\ncfu.enableLogging()\n  \n# ---- General parameters ---------------------------------------------------\n\n# Define marker constants instead of using numbers in the code\n\ncfu.info(""Creating rectangle"")\n\nrect = cfs.Rectangle(5.0, 1.0, element_type=3, dofs_per_node=2, max_area=0.08)\nrect.t = 0.2\nrect.v = 0.35\nrect.E = 2e9\nrect.ptype = 1\nrect.ep = [rect.ptype, rect.t]\nrect.D = cfc.hooke(rect.ptype, rect.E, rect.v)\n\ncfu.info(""Creating mesh..."")\n\nmesh = cfs.ShapeMesh(rect)    \n\n# ---- Solve problem --------------------------------------------------------\n\nsolver = cfslv.Plan2DSolver(mesh)\n\nsolver.addBC(rect.left_id, 0.0)\nsolver.addForceTotal(rect.top_id, -10e5, dimension=2)\n\nresults = solver.execute()       \n       \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.draw_geometry(rect.geometry(), title=""Geometry"")\n\ncfv.figure() \ncfv.draw_mesh(mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure()\ncfv.draw_displacements(results.a, mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n                      draw_undisplaced_mesh=False, title=""Displacements"", \n                      magnfac=1)\n\ncfv.figure()\ncfv.draw_element_values(results.el_forces, mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, results.a, \n                      draw_elements=True, draw_undisplaced_mesh=False, \n                      title=""Effective Stress"", magnfac=1)\n                      \n#cfv.colorBar().SetLabel(""Effective stress"")\n\ncfu.info(""Done drawing..."")\n\ncfv.show_and_wait()'"
examples/experimental/exm12.py,1,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.vis as cfv\nimport calfem.utils as cfu\nimport calfem.shapes as cfs\nimport calfem.solver as cfslv\n\nimport numpy as np\n\ncfu.enableLogging()\n  \n# ---- General parameters ---------------------------------------------------\n\n# Define marker constants instead of using numbers in the code\n\ncfu.info(""Creating rectangle"")\n\nrect = cfs.Rectangle(5.0, 1.0, element_type=3, dofs_per_node=1, max_area=0.08)\n\nrect.t = 1\nrect.ep = [rect.t, 1]\n\nrect.D = np.diag([1.7, 1.7])\n\ncfu.info(""Creating mesh..."")\n\nmesh = cfs.ShapeMesh(rect)    \n\n# ---- Solve problem --------------------------------------------------------\n\nsolver = cfslv.Flow2DSolver(mesh)\n\nsolver.addBC(rect.left_id, 0.0)\nsolver.addBC(rect.right_id, 120.0)\n#solver.addForceTotal(rect.topId, -10e5, dimension=2)\n\nresults = solver.execute()       \n       \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.drawGeometry(rect.geometry(), title=""Geometry"")\n\ncfv.figure() \ncfv.drawMesh(mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure() \ncfv.drawNodalValues(results.a, mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type)\n\ncfv.showAndWait()'"
examples/experimental/exm12_mpl.py,1,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 10\n\nThe use case from the user manual. \nThe example does not contain anything that is not covered in the previous examples.\n\'\'\'\n\nimport calfem.core as cfc\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.shapes as cfs\nimport calfem.solver as cfslv\n\nimport numpy as np\n\nimport matplotlib.pyplot as plt\n\ncfu.enableLogging()\n  \n# ---- General parameters ---------------------------------------------------\n\n# Define marker constants instead of using numbers in the code\n\ncfu.info(""Creating rectangle"")\n\nrect = cfs.Rectangle(5.0, 1.0, element_type=2, dofs_per_node=1, max_area=0.08)\n\nrect.t = 1\nrect.ep = [rect.t, 1]\n\nrect.D = np.diag([1.7, 1.7])\n\ncfu.info(""Creating mesh..."")\n\nmesh = cfs.ShapeMesh(rect)    \n\n# ---- Solve problem --------------------------------------------------------\n\nsolver = cfslv.Flow2DSolver(mesh)\n\nsolver.addBC(rect.left_id, 0.0)\nsolver.addBC(rect.right_id, 120.0)\n#solver.addForceTotal(rect.topId, -10e5, dimension=2)\n\nresults = solver.execute()       \n       \n# ---- Visualise results ----------------------------------------------------\n\ncfu.info(""Drawing results..."")\n\ncfv.figure() \ncfv.draw_geometry(rect.geometry(), title=""Geometry"")\n\ncfv.figure() \ncfv.draw_mesh(mesh.coords, mesh.edof, rect.dofs_per_node, rect.element_type, \n             filled=True, title=""Mesh"") #Draws the mesh.\n\ncfv.figure() \ncfv.draw_nodal_values_shaded(results.a, mesh.coords, mesh.edof)\ncfv.colorbar()\n\ncfv.figure() \ncfv.draw_nodal_values_contourf(results.a, mesh.coords, mesh.edof)\ncfv.colorbar()\n\ncfv.showAndWait()'"
examples/experimental/exm1_mpl_edit.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'Example 01\n\nShows how to create simple geometry from splines and ellipse arcs, and how to mesh a quad mesh in GmshMesher.\nAlso demonstrates drawGeometry(), drawMesh, and drawing texts and labels in a figure.\n\'\'\'\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\nimport exed1 as cfi\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()  # Create a GeoData object that holds the geometry.\n\n# Add points:\n#  The first parameter is the coordinates. These can be in 2D or 3D.\n#  The other parameters are not defined in this example. These parameters are\n#  ID, marker, and elSize.\n#  Since we do not specify an ID the points are automatically assigned IDs,\n#  starting from 0.\n\ng.point([0, 0])\ng.point([2, 0])\ng.point([2, 1])\ng.point([0, 1])\ng.point([0.5, 0.3])\ng.point([0.3, 0.7])\ng.point([0.7, 0.7])\ng.point([0.8, 0.5])\ng.point([1.7, 0.5])\ng.point([1.5, 0.5])\ng.point([1.7, 0.7])\n\n#cfi.edit_geometry(g)\n\n# Add curves:\n#  There are four types of curves. In this example we create an ellipse arc\n#  and some splines. The first parameter is a list of point IDs that define\n#  the curve. Curves can have have IDs and markers. In this example the IDs\n#  are undefined so the curves are automatically assigned IDs. The markers can\n#  be used for identifying regions/boundaries in the model.\n\n\n# 0 - An ellipse arc. Read the function\n#     doc for more information. The four\n#     points are\n#     [start, center, majorAxis, end]\n\ng.ellipse([7, 8, 9, 10], marker=50)\n\ng.spline([0, 1], marker=80)           # 1 - A spline. Splines pass through the\n                                      #     points in the first parameter.\ng.spline([2, 1])                      # 2\ng.spline([3, 2])                      # 3\ng.spline([0, 3])                      # 4\ng.spline([7, 9], marker=50)           # 5\ng.spline([10, 9])                     # 6\ng.spline([4, 5, 6, 4])                # 7 - This is a closed spline.\n                                      #     The start and end points are the same\n\n# Add a surface:\n#  Surfaces are defined by its curve boundaries.\n#  The first parameter is a list of curve IDs that specify the outer boundary\n#  of the surface. The second parameter is a list of lists of curve IDs that\n#  specify holes in the surface. In this example there are two holes. The\n#  boundaries and holes must be closed paths. We can see that [7] is closed\n#  because curve 7 is a closed spline. addSurface creates a flat surface, so\n#  all curves must lie on the same plane.\n\ng.surface([4, 3, 2, 1], [[7], [5, 6, 0]])\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 3 is quad.\n# (2 is triangle. See user manual for more element types)\n\nmesh.el_type = 3\nmesh.dofs_per_node = 1  # Degrees of freedom per node.\nmesh.el_size_factor = 0.05  # Factor that changes element sizes.\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\n# Mesh the geometry:\n#\n# The first four return values are the same as those that trimesh2d() returns.\n# coords is as list of node coordinates. edof is the element topology\n# (element degrees of freedom). dofs is a lists of all degrees of freedom\n# bdofs is a dictionary of boundary dofs (dofs of geometric entities with\n# markers). elementmarkers is a list of markers, and is used for finding the\n# marker of a given element (index).\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry. Note that surfaces and volumes are not drawn at all by\n# this function.\n\ncfv.draw_geometry(g)\n\n# New figure window\n\ncfv.figure()\n\n# Draw the mesh.\n\ncfv.draw_mesh(\n    coords=coords,\n    edof=edof,\n    dofs_per_node=mesh.dofs_per_node,\n    el_type=mesh.el_type,\n    filled=True,\n    title=""Example 01""\n)\n\n# Adds a text in world space\n\ncfv.text(""This is a Text"", pos=(1, -0.3), rotation=45)\n\n# Adds a label in the screen space\n\nour_label = cfv.label(""This is a Label"", pos=(1, 0.3), rotation=-45)\n\n# We can change the attributes of labels and texts, such as color, text, and position.\n\nour_label.set_text(""Label, changed."")\nour_label.set_color(\'r\')  # Make it red. (1,0,0) would also have worked.\nour_label.set_position((1, 0.3))\n\n# Enter main loop:\n\ncfv.showAndWait()\n'"
examples/experimental/exui1.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Apr 11 09:44:29 2016\n\n@author: lindemann\n""""""\n\nimport sys\n\nfrom PyQt5.QtCore import pyqtSlot, pyqtSignal, QMetaObject\nfrom PyQt5.QtWidgets import *\nfrom PyQt5.QtGui import QPixmap\nfrom PyQt5.uic import loadUi\n\nclass MainWindow(QMainWindow):\n    """"""Main window class of our UI""""""\n    def __init__(self):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()\n\n        self.resize(640,480)\n        self.move(50,50)\n        self.setWindowTitle(""MyWindow"")\n\n        self.executeButton = QPushButton(""Tryck"", self)\n        self.executeButton.move(50,50)\n        self.executeButton.resize(100,50)\n        #self.button.clicked.connect(self.on_button_clicked)\n        \n        QMetaObject.connectSlotsByName(self)\n\n    @pyqtSlot()\n    def on_executeButton_clicked(self):\n        print(""Button pressed"")\n\n\n#    def show(self):\n#        """"""Show and raise window""""""\n#        self.ui.show()\n#        self.ui.raise_()\n\nif __name__ == \'__main__\':\n\n    app = QApplication(sys.argv)\n    widget = MainWindow()\n    widget.show()\n    sys.exit(app.exec_())'"
examples/experimental/plot_test.py,0,"b'# -*- coding: utf-8 -*-\n\n\'\'\'\nExample 02\nCreating geometry from B-Splines and circle arcs.\nAlso shows how to set ID numbers for geometry entities and how to specify element density. \n\'\'\'\n\nimport matplotlib.pyplot as plt\nimport matplotlib.collections\nimport numpy as np\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\n\n# ---- Define geometry ------------------------------------------------------\n\ng = cfg.Geometry()\n\n# Add points:\n#  In this example we set the IDs manually.\n\ng.point([ -2,  0], ID=0)\ng.point([  0,  1], ID=1, elSize=5) # elSize determines the size of the elements near this point.\ng.point([  1,  0], 2, elSize=5)    #  elSize is 1 by default. Larger number means less dense mesh.\ng.point([  0, -2], 3)              #  Size means the length of the sides of the elements.\ng.point([  0,  0], 4, elSize=5)\ng.point([ .5, .2], 5)\ng.point([-.5, .5], 6)\ng.point([-.7,-.5], 7)\n\n# Add curves:\n\n# The 3 points that define the circle arc are [start, center, end]. \n# The arc must be smaller than Pi.\n\ng.circle([1, 4, 2], 2) \n\n# BSplines are similar to Splines, but do not necessarily pass through the \n# control points.\n\ng.bspline([5,6,7,5], 5) \ng.bspline([1,0,3,2], 4)\n\n# Add surface:\n\ng.surface([4,2], [[5]])\n\n# Markers do not have to be set when the curve is created. It can be done afterwards.\n#  Set marker=80 for curves 2 and 4:\n\nfor curveID in [2, 4]:\n    g.curveMarker(curveID, 80)\n\n# ---- Generate mesh --------------------------------------------------------\n\nmesh = cfm.GmshMesh(g)\n\n# Element type 2 is triangle. (3 is quad. See user manual for more element types)\n\nmesh.el_type = 3\n\n# Degrees of freedom per node.\n\nmesh.dofs_per_node = 2\nmesh.el_size_factor = 0.05\n# mesh.gmsh_exec_path = ""D:\\\\vsmn20-software\\\\gmsh\\gmsh.exe""\n\ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n# ---- Visualise mesh -------------------------------------------------------\n\n# Hold left mouse button to pan.\n# Hold right mouse button to zoom.\n\n# Draw the geometry.\n\n#cfv.draw_geometry(g, labelCurves=True)\n\n# New figure window\n\ncfv.figure()\n\n# Draws the mesh. \n\ncfv.draw_mesh(\n    coords=coords, \n    edof=edof, \n    dofs_per_node = mesh.dofs_per_node, \n    el_type=mesh.el_type, \n    filled=True, \n    title=""Example 02""\n    ) \n\n# Show grid\n\n#cfv.show_grid()\n\n# Enter main loop\n\ncfv.show_and_wait()\n'"
examples/experimental/qt1.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Wed Mar  1 16:23:37 2017\n\n@author: Jonas Lindemann\n""""""\n\nimport sys\nimport time\n\nfrom calfem.qt5 import *\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis as cfv\n\nclass MainWindow(QMainWindow):\n    def __init__(self):\n        """"""Constructor""""""\n        super(MainWindow, self).__init__()       \n        \nif __name__ == ""__main__"":\n    \n    app = QApplication(sys.argv)\n    widget = MainWindow()\n    widget.show()\n    sys.exit(app.exec_())  \n'"
examples/experimental/qt2.py,0,"b'# -*- coding: utf-8 -*-\n""""""\nCreated on Fri Mar  9 17:14:04 2018\n\n@author: Jonas Lindemann\n""""""\n\n# -*- coding: utf-8 -*-\n""""""\nCreated on Mon Apr 11 09:44:29 2016\n\n@author: lindemann\n""""""\n\nimport sys\n\nfrom PyQt5.QtWidgets import *\n\nclass MyWindow(QWidget):\n    """"""Main Window class for our application""""""\n\n    def __init__(self):\n        """"""Class constructor""""""\n        super().__init__()\n\n        self.init_ui()\n\n    def init_ui(self):\n\n        self.resize(200,200)\n        self.move(50,50)\n        self.setWindowTitle(""MyWindow"")\n        \n        self.main_widget = QWidget(self)\n        \n        self.button1 = QPushButton(\'Button1\')\n        self.button2 = QPushButton(\'Button2\')\n        self.button3 = QPushButton(\'Button3\')\n        self.button4 = QPushButton(\'Button4\')\n        \n        self.button5 = QPushButton(\'Button5\')\n        self.button6 = QPushButton(\'Button6\')\n        self.button7 = QPushButton(\'Button7\')\n        self.button8 = QPushButton(\'Button8\')\n\n        self.vbox = QVBoxLayout(self)\n        self.vbox.addWidget(self.button1)\n        self.vbox.addWidget(self.button2)\n        self.vbox.addWidget(self.button3)\n        self.vbox.addWidget(self.button4)\n        \n        self.hbox = QHBoxLayout(self)\n        self.hbox.addWidget(self.button5)\n        self.hbox.addWidget(self.button6)\n        self.hbox.addWidget(self.button7)\n        self.hbox.addWidget(self.button8)\n        \n        self.vbox.addLayout(self.hbox)\n        \n        self.main_widget.setLayout(self.vbox)\n        self.setCentralWidget(self.main_widget)\n\n\nif __name__ == \'__main__\':\n    \n    app = QApplication(sys.argv)\n    \n    window = MyWindow()\n    window.show()\n    \n    sys.exit(app.exec_())\n'"
examples/experimental/test_point_in_geom.py,0,"b'import calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.tri as tri\n\nimport numpy as np\n\n# ---- Create Geometry ------------------------------------------------------\n\ng = cfg.geometry()\n\n# Add Points:\n\npoints = [\n    [0,0], \n    [0,100], \n    [0,150], \n    [100,0], \n    [150,0], \n    [100,-100], \n    [150,-100]\n]\n\nfor p in points:\n    g.point(p)\n\n# Add Splines:\n\ng.spline([1,2], marker=2, elOnCurve=4)\ng.spline([3,4], elOnCurve=4)\ng.circle([1,0,3], elOnCurve = 10)\ng.circle([2,0,4], elOnCurve = 10)\ng.spline([3,5], elOnCurve = 6)\ng.spline([5,6], marker=3, elOnCurve = 4)\ng.spline([6,4], elOnCurve = 6)\n\n# Add Surfaces:\n#\n# When we set markers for surfaces, and have 2D elements, we can find which \n# region an element is in via the list \'elementmarkers\', which is returned by \n# GmshMesher.create()\n\ng.structuredSurface([0,2,1,3], marker = 10)\ng.structuredSurface([1,4,5,6], marker = 11)\n\nel_type = 16 \ndofs_per_node = 1 \n\nmesh = cfm.GmshMeshGenerator(g, el_type, dofs_per_node) \ncoords, edof, dofs, bdofs, elementmarkers = mesh.create()\n\n\n# ---- Visualise results ----------------------------------------------------\n\nprint(""Visualising..."")\n\nmpl.rcParams[\'figure.dpi\'] = 160\n\ncfv.figure()\n\ncfv.draw_geometry(g, title=""Geometry"")\n\ncfv.point_in_geometry(g, [0.0, 0.0])\n\ncfv.show_and_wait()\n\nprint(""Done."")\n'"
examples/experimental/test_tri_mesh.py,2,"b'# -*- coding: utf-8 -*-\n\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport matplotlib.tri as tri\n\nimport calfem.geometry as cfg\nimport calfem.mesh as cfm\nimport calfem.vis_mpl as cfv\nimport calfem.utils as cfu\nimport calfem.core as cfc\n\nimport numpy as np\n\ncoords = np.array([\n        [0.000, 0.000],\n        [1.000, 0.000],\n        [2.000, 0.500],\n        [0.000, 1.000],\n        [1.000, 1.000],\n        [1.750, 1.300],\n        [1.000, 1.700]])\n        \nedof = np.array([\n        [1, 2, 5],\n        [5, 4, 1],\n        [2, 3, 6],\n        [6, 5, 2],\n        [4, 5, 7],\n        [5, 6, 7]])\n\nvalues = [1, 2, 1, 2, 7, 4, 5]\n\nplt.figure()\ncfv.draw_nodal_values_contours(values, coords, edof)\nplt.colorbar()\n\nplt.figure()\ncfv.draw_nodal_values_shaded(values, coords, edof)\nplt.colorbar()\n\nplt.show()'"
old/PyQt/QtBindingHelper.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2011, Dirk Thomas, Dorian Scholz, TU Darmstadt\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#   * Redistributions of source code must retain the above copyright\n#     notice, this list of conditions and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above\n#     copyright notice, this list of conditions and the following\n#     disclaimer in the documentation and/or other materials provided\n#     with the distribution.\n#   * Neither the name of the TU Darmstadt nor the names of its\n#     contributors may be used to endorse or promote products derived\n#     from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\nfrom __future__ import print_function\n\nprint(\'Deprecation warning: the ""python_qt_binding.QtBindingHelper"" module is deprecated and will be removed in the near future.\')\nprint(\'Replace your usage of QtBindingHelper with import statements like:\')\nprint(\'  from python_qt_binding.QtCore import QObject\')\nprint(\'  from python_qt_binding import QtGui, loadUi\')\n'"
old/PyQt/__init__.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2011, Dirk Thomas, Dorian Scholz, TU Darmstadt\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#   * Redistributions of source code must retain the above copyright\n#     notice, this list of conditions and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above\n#     copyright notice, this list of conditions and the following\n#     disclaimer in the documentation and/or other materials provided\n#     with the distribution.\n#   * Neither the name of the TU Darmstadt nor the names of its\n#     contributors may be used to endorse or promote products derived\n#     from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\n""""""\nAbstraction for different Python Qt bindings.\n\nSupported Python Qt bindings are PyQt4 and PySide.\nThe Qt modules can be imported like this:\n\nfrom python_qt_binding.QtCore import QObject\nfrom python_qt_binding import QtGui, loadUi\n\nThe name of the selected binding is available in QT_BINDING.\nThe version of the selected binding is available in QT_BINDING_VERSION.\nAll available Qt modules are listed in QT_BINDING_MODULES.\n\nThe default binding order (\'pyqt\', \'pyside\') can be overridden with a\nSELECT_QT_BINDING_ORDER attribute on sys:\n  setattr(sys, \'SELECT_QT_BINDING_ORDER\', [FIRST_NAME, NEXT_NAME, ..])\n\nA specific binding can be selected with a SELECT_QT_BINDING attribute on sys:\n  setattr(sys, \'SELECT_QT_BINDING\', MY_BINDING_NAME)\n""""""\n\nimport sys\nfrom .binding_helper import loadUi, QT_BINDING, QT_BINDING_MODULES, QT_BINDING_VERSION  # @UnusedImport\n\n# register all binding modules as sub modules of this package (python_qt_binding) for easy importing\nfor module_name, module in QT_BINDING_MODULES.items():\n    sys.modules[__name__ + \'.\' + module_name] = module\n    setattr(sys.modules[__name__], module_name, module)\n    del module_name\n    del module\n\ndel sys\n'"
old/PyQt/binding_helper.py,0,"b'#!/usr/bin/env python\n\n# Copyright (c) 2011, Dirk Thomas, Dorian Scholz, TU Darmstadt\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#   * Redistributions of source code must retain the above copyright\n#     notice, this list of conditions and the following disclaimer.\n#   * Redistributions in binary form must reproduce the above\n#     copyright notice, this list of conditions and the following\n#     disclaimer in the documentation and/or other materials provided\n#     with the distribution.\n#   * Neither the name of the TU Darmstadt nor the names of its\n#     contributors may be used to endorse or promote products derived\n#     from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# ""AS IS"" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\ntry:\n    import __builtin__ as builtins\nexcept ImportError:\n    # since the \'future\' package provides a \'builtins\' module in Python 2\n    # this must not be checked second\n    import builtins\nimport os\nimport sys\n\n\nQT_BINDING = None\nQT_BINDING_MODULES = {}\nQT_BINDING_VERSION = None\n\n\ndef _select_qt_binding(binding_name=None, binding_order=None):\n    global QT_BINDING, QT_BINDING_VERSION\n\n    # order of default bindings can be changed here\n    DEFAULT_BINDING_ORDER = [\'pyqt\', \'pyside\']\n    binding_order = binding_order or DEFAULT_BINDING_ORDER\n\n    # determine binding preference\n    if binding_name:\n        if binding_name not in binding_order:\n            raise ImportError(""Qt binding \'%s\' is unknown"" % binding_name)\n        binding_order = [binding_name]\n\n    required_modules = [\n        \'QtCore\',\n        \'QtGui\',\n        \'uic\',\n    ]\n    optional_modules = [\n        \'QtDeclarative\',\n        \'QtMultimedia\',\n        \'QtNetwork\',\n        \'QtOpenGL\',\n        \'QtOpenVG\',\n        \'QtScript\',\n        \'QtScriptTools\'\n        \'QtSql\',\n        \'QtSvg\',\n        \'QtWebKit\',\n        \'QtXml\',\n        \'QtXmlPatterns\',\n        \'QtUiTools\',\n    ]\n\n    # try to load preferred bindings\n    error_msgs = []\n    for binding_name in binding_order:\n        try:\n            binding_loader = getattr(sys.modules[__name__], \'_load_%s\' % binding_name, None)\n            if binding_loader:\n                QT_BINDING_VERSION = binding_loader(required_modules, optional_modules)\n                QT_BINDING = binding_name\n                break\n            else:\n                error_msgs.append(""  Binding loader \'_load_%s\' not found."" % binding_name)\n        except ImportError as e:\n            error_msgs.append(""  ImportError for \'%s\': %s"" % (binding_name, e))\n\n    if not QT_BINDING:\n        raise ImportError(""Could not find Qt binding (looked for: %s):\\n%s"" % (\', \'.join([""\'%s\'"" % b for b in binding_order]), \'\\n\'.join(error_msgs)))\n\n\ndef _register_binding_module(module_name, module):\n    # register module using only its own name (TODO: legacy compatibility, remove when possible)\n    sys.modules[module_name] = module\n    # add module to the binding modules\n    QT_BINDING_MODULES[module_name] = module\n\n\ndef _named_import(name):\n    parts = name.split(\'.\')\n    assert(len(parts) >= 2)\n    module = builtins.__import__(name)\n    for m in parts[1:]:\n        module = module.__dict__[m]\n    module_name = parts[-1]\n    _register_binding_module(module_name, module)\n\n\ndef _named_optional_import(name):\n    try:\n        _named_import(name)\n    except ImportError:\n        pass\n\n\ndef _load_pyqt(required_modules, optional_modules):\n    # set environment variable QT_API for matplotlib\n    os.environ[\'QT_API\'] = \'pyqt\'\n\n    # select PyQt4 API, see http://pyqt.sourceforge.net/Docs/PyQt4/incompatible_apis.html\n    import sip\n    try:\n        sip.setapi(\'QDate\', 2)\n        sip.setapi(\'QDateTime\', 2)\n        sip.setapi(\'QString\', 2)\n        sip.setapi(\'QTextStream\', 2)\n        sip.setapi(\'QTime\', 2)\n        sip.setapi(\'QUrl\', 2)\n        sip.setapi(\'QVariant\', 2)\n    except ValueError as e:\n        raise RuntimeError(\'Could not set API version (%s): did you import PyQt4 directly?\' % e)\n\n    # register required and optional PyQt4 modules\n    for module_name in required_modules:\n        _named_import(\'PyQt4.%s\' % module_name)\n    for module_name in optional_modules:\n        _named_optional_import(\'PyQt4.%s\' % module_name)\n\n    # set some names for compatibility with PySide\n    sys.modules[\'QtCore\'].Signal = sys.modules[\'QtCore\'].pyqtSignal\n    sys.modules[\'QtCore\'].Slot = sys.modules[\'QtCore\'].pyqtSlot\n    sys.modules[\'QtCore\'].Property = sys.modules[\'QtCore\'].pyqtProperty\n\n    # try to register PyQt4.Qwt5 module\n    try:\n        import PyQt4.Qwt5\n        _register_binding_module(\'Qwt\', PyQt4.Qwt5)\n    except ImportError:\n        pass\n\n    global _loadUi\n\n    def _loadUi(uifile, baseinstance=None, custom_widgets_=None):\n        from PyQt4 import uic\n        return uic.loadUi(uifile, baseinstance=baseinstance)\n\n    # override specific function to improve compatibility between different bindings\n    from QtGui import QFileDialog\n    QFileDialog.getOpenFileName = QFileDialog.getOpenFileNameAndFilter\n    QFileDialog.getSaveFileName = QFileDialog.getSaveFileNameAndFilter\n\n    import PyQt4.QtCore\n    return PyQt4.QtCore.PYQT_VERSION_STR\n\n\ndef _load_pyside(required_modules, optional_modules):\n    # set environment variable QT_API for matplotlib\n    os.environ[\'QT_API\'] = \'pyside\'\n\n    # register required and optional PySide modules\n    for module_name in required_modules:\n        _named_import(\'PySide.%s\' % module_name)\n    for module_name in optional_modules:\n        _named_optional_import(\'PySide.%s\' % module_name)\n\n    # set some names for compatibility with PyQt4\n    sys.modules[\'QtCore\'].pyqtSignal = sys.modules[\'QtCore\'].Signal\n    sys.modules[\'QtCore\'].pyqtSlot = sys.modules[\'QtCore\'].Slot\n    sys.modules[\'QtCore\'].pyqtProperty = sys.modules[\'QtCore\'].Property\n\n    # try to register PySideQwt module\n    try:\n        import PySideQwt\n        _register_binding_module(\'Qwt\', PySideQwt)\n    except ImportError:\n        pass\n\n    global _loadUi\n\n    def _loadUi(uifile, baseinstance=None, custom_widgets=None):\n        from PySide.QtUiTools import QUiLoader\n        from PySide.QtCore import QMetaObject\n\n        class CustomUiLoader(QUiLoader):\n            class_aliases = {\n                \'Line\': \'QFrame\',\n            }\n\n            def __init__(self, baseinstance=None, custom_widgets=None):\n                super(CustomUiLoader, self).__init__(baseinstance)\n                self._base_instance = baseinstance\n                self._custom_widgets = custom_widgets or {}\n\n            def createWidget(self, class_name, parent=None, name=\'\'):\n                # don\'t create the top-level widget, if a base instance is set\n                if self._base_instance and not parent:\n                    return self._base_instance\n\n                if class_name in self._custom_widgets:\n                    widget = self._custom_widgets[class_name](parent)\n                else:\n                    widget = QUiLoader.createWidget(self, class_name, parent, name)\n\n                if str(type(widget)).find(self.class_aliases.get(class_name, class_name)) < 0:\n                    sys.modules[\'QtCore\'].qDebug(str(\'PySide.loadUi(): could not find widget class ""%s"", defaulting to ""%s""\' % (class_name, type(widget))))\n\n                if self._base_instance:\n                    setattr(self._base_instance, name, widget)\n\n                return widget\n\n        loader = CustomUiLoader(baseinstance, custom_widgets)\n\n        # instead of passing the custom widgets, they should be registered using QUiLoader.registerCustomWidget(),\n        # but this does not work in PySide 1.0.6: it simply segfaults...\n        #loader = CustomUiLoader(baseinstance)\n        #custom_widgets = custom_widgets or {}\n        #for custom_widget in custom_widgets.values():\n        #    loader.registerCustomWidget(custom_widget)\n\n        ui = loader.load(uifile)\n        QMetaObject.connectSlotsByName(ui)\n        return ui\n\n    import PySide\n    return PySide.__version__\n\n\ndef loadUi(uifile, baseinstance=None, custom_widgets=None):\n    """"""\n    @type uifile: str\n    @param uifile: Absolute path of .ui file\n    @type baseinstance: QWidget\n    @param baseinstance: the optional instance of the Qt base class.\n                         If specified then the user interface is created in\n                         it. Otherwise a new instance of the base class is\n                         automatically created.\n    @type custom_widgets: dict of {str:QWidget}\n    @param custom_widgets: Class name and type of the custom classes used\n                           in uifile if any. This can be None if no custom\n                           class is in use. (Note: this is only necessary\n                           for PySide, see\n                           http://answers.ros.org/question/56382/what-does-python_qt_bindingloaduis-3rd-arg-do-in-pyqt-binding/\n                           for more information)\n    """"""\n    return _loadUi(uifile, baseinstance, custom_widgets)\n\n\n_select_qt_binding(\n    getattr(sys, \'SELECT_QT_BINDING\', None),\n    getattr(sys, \'SELECT_QT_BINDING_ORDER\', None),\n)\n\nprint(""-----------------------------"")\nprint(""Checking installed Qt version"")\nprint(""-----------------------------"")\nprint()\n\nprint(""Selected Qt version :"", QT_BINDING)\n\nprint(""Loaded Qt modules   :"")\nprint()\nfor qtmodule in QT_BINDING_MODULES.keys():\n    print(""\\t""+qtmodule)\n    \nprint()\nprint(""Qt binding version  :"", QT_BINDING_VERSION)\nprint()\n'"
