file_path,api_count,code
spatial_pooler.py,7,"b'#! /usr/bin/python3\nimport numpy as np\nimport sys, random, json\n\n\n\ndef overlap(x,y):\n    # You can\'t overlap sdrs\n    # with different shapes\n    if x.shape != y.shape:\n        return None\n    result = np.zeros(x.shape,dtype=np.bool_)\n    for i in range(x.shape[0]):\n        result[i] = x[i] and y[i]\n    return result\n\n\nclass SpatialPooler():\n\n    def __init__(   self,\n                    num_collumns=128,\n                    input_size=256,\n                    threshhold_permances=0.5,\n                    threshhold_activation=0.6,\n                    size_of_potential_pool=0.75,\n                    permanence_inc=0.1,\n                    permanence_dec=0.01):\n        self.current = 0\n        self.permanence_inc = permanence_inc\n        self.permanence_dec = permanence_dec\n        self.threshhold_permanences = threshhold_permances\n        self.threshhold_activation = threshhold_activation\n        self.collumns = self.init_collumn(num_collumns,input_size,1-size_of_potential_pool)\n\n\n    def init_collumn(self,num_collumns,input_size,size_of_potential_pool=0.75):\n        collumns = [{} for i in range(num_collumns)]\n        for i in range(num_collumns):\n            collumns[i][\'potential_pool\'] = np.random.rand(input_size) > size_of_potential_pool # Create a random potential pool with a certain percantage of potential connections\n            collumns[i][\'permanences\'] = np.random.rand(np.sum(collumns[i][\'potential_pool\'])) # Random values for the permanence between  0-1\n        return collumns\n\n\n    def activation(self,state):\n        """"""\n        Sum state and then compare that to threshhold_activation\n        """"""\n        length = state.shape[0]\n        return ((np.sum(state)/length) > self.threshhold_activation)\n\n    def permanence(self,state):\n        """"""\n        For all permanences\n        filter all those out that are below self.threshhold_permances\n        And increase those that are above the same by self.permanence_inc\n        """"""\n        active = self.collumns[self.current][\'permanences\'] > self.threshhold_permanences\n        inactive = self.collumns[self.current][\'permanences\'] <= self.threshhold_permanences\n        self.collumns[self.current][\'permanences\'][active] += self.permanence_inc\n        self.collumns[self.current][\'permanences\'][inactive] -= self.permanence_dec\n        return (self.collumns[self.current][\'permanences\'] > self.threshhold_permanences) * state\n\n\n    def potential_pool(self,state):\n        predicat = self.collumns[self.current][\'potential_pool\']\n        return np.extract(predicat,state)\n\n    def spatial_pooler(self,state):\n        """"""\n        state := np.array (bool)\n        Spatial Pooler:\n        Input -> potetial pool -> permanence -> activation -> output\n        """"""\n        return self.activation(self.permanence(self.potential_pool(state)))\n\n    def run(self,input_sdr):\n        self.current = 0\n        output = np.zeros(len(self.collumns),dtype=np.bool_)\n        for i in range(len(self.collumns)):\n            output[i] = self.spatial_pooler(input_sdr)\n            self.current += 1\n        self.current = 0\n        return output\n'"
test_spatial_pooler.py,16,"b""import numpy as np\nfrom spatial_pooler import SpatialPooler\nfrom spatial_pooler import overlap\nimport math\n\nspatial_pooler_instance = SpatialPooler(num_collumns = 50,input_size=100,threshhold_permances=0.5)\n\ndef test_init_collumn():\n    test_cols = spatial_pooler_instance.init_collumn(500,600,0.75)\n\n    assert type(test_cols[0]['permanences']) == type(np.array([0.5],dtype=np.float))\n    assert np.sum(test_cols[0]['potential_pool'] > 0) > 0.6 # The potential pool should be at least 60 % of all collumns if not more\n\n\ndef test_activation():\n    spatial_pooler_instance.current = 0\n    state = np.random.randn(len(spatial_pooler_instance.collumns[0]['permanences'])) > 0\n    for i in range(1000):\n        state_n = spatial_pooler_instance.activation(state)\n        assert np.bool_ == type(state_n)\n\n        mutate = np.random.randint(0,6)\n        state[mutate] = not state[mutate]\n\ndef test_permanence():\n    spatial_pooler_instance.current = 0\n    state = np.random.randn(len(spatial_pooler_instance.collumns[0]['permanences'])) > 0\n    for i in range(1000):\n        state_n = spatial_pooler_instance.permanence(state)\n        assert type(state_n) == type(state)\n        assert state_n.shape == state.shape\n\n        mutate = np.random.randint(0,6)\n        state[mutate] = not state[mutate]\n\n\ndef test_potential_pool():\n    state = np.random.randn(100) > 0\n    for i in range(1000):\n        state_n = spatial_pooler_instance.potential_pool(state)\n        assert type(state_n) == type(np.array([True]))\n        assert type(state) == type(state_n)\n        assert state_n.shape == spatial_pooler_instance.collumns[0]['permanences'].shape\n\n        mutate = np.random.randint(0,6)\n        state[mutate] = not state[mutate]\n\ndef test_overlap():\n    x = np.array([True,True,False,False,True])\n    y = np.array([True,True,False,True,False])\n    z = overlap(x,y)\n    assert np.array_equal(z,np.array([True,True,False,False,False]))\n\ndef test_run():\n    input_sp = np.random.randn(100) > 0\n    output_sp = spatial_pooler_instance.run(input_sp)\n\n    # Has the same shape as desired\n    assert output_sp.shape[0] == 50\n\n    # Less than 20% of the output_sp is on.\n    # Sparsity\n    assert np.sum(output_sp)/output_sp.shape[0] < 0.2\n\n    assert type(output_sp) == type(np.array([],dtype=np.bool_))\n"""
