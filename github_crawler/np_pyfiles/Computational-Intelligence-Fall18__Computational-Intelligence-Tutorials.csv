file_path,api_count,code
Week 3 - Genetic Algorithm(part 2)/genetic_utils.py,10,"b'import numpy as np\nfrom matplotlib.pyplot import pie\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation\nfrom IPython.display import HTML\n\nclass Item:\n    def __init__(self, value, weight) :\n        self.value = value\n        self.weight = weight\n\nclass Bag:\n    def __init__(self, capacity) :\n        self.capacity = capacity\n\nclass Chromosome :\n    def __init__(self, length) :\n        self.genes = np.random.rand(length) > .5\n        self.fitness = float(\'-inf\')\n        \n    def __len__(self) :\n        return len(self.genes)\n    \n    def reset(self) :\n        self.fitness = float(\'-inf\')\n        \ndef get_fake_knapsack(seed=0, max_value=30, max_weight=40, items_number=30):\n    """"""\n    Items & Bag capacity of fake knapsack problem will be generated and returned\n    """"""\n    np.random.seed(seed)\n#     items_number = np.random.randint(items_number)\n    # List Comprehensions, for more details see : https://www.pythonforbeginners.com/basics/list-comprehensions-in-python\n    items = np.array([Item(np.random.rand()*max_value, np.random.rand()*max_weight) for _ in range(items_number)])\n    bag = Bag(np.random.rand()*(max_weight*len(items)) + max_weight)\n    print(\'We have {} items with weight and values of :\'.format(len(items)))\n    for i,item in enumerate(items) :\n        print(\'item {}: Weight=>{} Value=>{}\'.format(i, item.weight, item.value))\n    print(\'We have a bag with capacity of {}\'.format(bag.capacity))\n    return items, bag\n\n# Population Initialization Method\npopulation_init = lambda size, chrom_size : np.array([Chromosome(chrom_size) for _ in range(size)])\n\n\ndef fitness_eval(chrom, items, bag, epsilon=2) :\n    selected_items = items[chrom.genes]\n    capacity_full = 0\n    fitness = 0\n    for item in selected_items :\n        capacity_full += item.weight\n        if capacity_full > bag.capacity :\n            fitness = epsilon\n            break\n        fitness += item.value\n    return fitness\n\ndef roulette_selection(chromosomes, show_plot = False) :\n    i = 0\n    fitnesses = np.array(list(map(lambda c: c.fitness, chromosomes)))\n    sum_of_fitnesses = np.sum(fitnesses)\n    sel_prob = fitnesses/sum_of_fitnesses\n    if show_plot:\n        pie(sel_prob) # Ploting pie chart of probablity of each individual\n    sum_prob = sel_prob[i]\n    pointer = np.random.rand()\n    while sum_prob < pointer :\n        i += 1\n        sum_prob += sel_prob[i]            \n    return chromosomes[i]\n\ntournament_selection = lambda chromosomes, sel_pressure: max(np.random.choice(chromosomes, sel_pressure),key=lambda c: c.fitness)\n\n# First set up the figure, the axis, and the plot element we want to animate\ndef plot_generations(generations, fitnesses) :\n    fig = plt.figure()\n    ax = plt.axes(xlim=(0, 20), ylim=(0, 20))\n\n    X = generations[:, :, 0]\n    Y = generations[:, :, 1]\n\n    # animation function.  This is called sequentially\n    def animate(i):\n        x = X[i]\n        y = Y[i]\n        ax.clear()\n        scat = ax.scatter(x, y, s=fitnesses[i])\n        ax.set_title(\'Generation {}\'.format(i))\n        return scat, ax\n\n    # call the animator.  blit=True means only re-draw the parts that have changed.\n    anim = animation.FuncAnimation(fig, animate, frames=generations.shape[0], interval=200)\n    plt.close()\n    # call our new function to display the animation\n    return HTML(anim.to_jshtml())'"
Week 4 - Genetic Algorithm(part 3)/genetic_utils.py,21,"b'import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom copy import deepcopy\nfrom matplotlib.pyplot import pie\nfrom matplotlib import animation\nfrom IPython.display import HTML\n\n\nclass Chromosome :\n    def __init__(self, length) :\n        self.genes = np.random.rand(length) > .5\n        self.fitness = float(\'-inf\')\n        \n    def __len__(self) :\n        return len(self.genes)\n    \n    def reset(self) :\n        self.fitness = float(\'-inf\')\n        \ndef get_fake_knapsack(seed=0, max_value=30, max_weight=40, items_number=30):\n    """"""\n    Items & Bag capacity of fake knapsack problem will be generated and returned\n    """"""\n    np.random.seed(seed)\n#     items_number = np.random.randint(items_number)\n    # List Comprehensions, for more details see : https://www.pythonforbeginners.com/basics/list-comprehensions-in-python\n    items = np.array([Item(np.random.rand()*max_value, np.random.rand()*max_weight) for _ in range(items_number)])\n    bag = Bag(np.random.rand()*(max_weight*len(items)) + max_weight)\n    print(\'We have {} items with weight and values of :\'.format(len(items)))\n    for i,item in enumerate(items) :\n        print(\'item {}: Weight=>{} Value=>{}\'.format(i, item.weight, item.value))\n    print(\'We have a bag with capacity of {}\'.format(bag.capacity))\n    return items, bag\n\n# Population Initialization Method\npopulation_init = lambda size, chrom_size : np.array([Chromosome(chrom_size) for _ in range(size)])\n\n\ndef fitness_eval(chrom, items, bag, epsilon=2) :\n    selected_items = items[chrom.genes]\n    capacity_full = 0\n    fitness = 0\n    for item in selected_items :\n        capacity_full += item.weight\n        if capacity_full > bag.capacity :\n            fitness = epsilon\n            break\n        fitness += item.value\n    return fitness\n\ndef roulette_selection(chromosomes, show_plot = False) :\n    i = 0\n    fitnesses = np.array(list(map(lambda c: c.fitness, chromosomes)))\n    sum_of_fitnesses = np.sum(fitnesses)\n    sel_prob = fitnesses/sum_of_fitnesses\n    if show_plot:\n        pie(sel_prob) # Ploting pie chart of probablity of each individual\n    sum_prob = sel_prob[i]\n    pointer = np.random.rand()\n    while sum_prob < pointer :\n        i += 1\n        sum_prob += sel_prob[i]            \n    return chromosomes[i]\n\ntournament_selection = lambda chromosomes, sel_pressure: max(np.random.choice(chromosomes, sel_pressure),key=lambda c: c.fitness)\n\ndef one_point_crossover(pop, selection_method, pc) :\n\n    p1 = selection_method(pop)\n    p2 = selection_method(pop)\n    \n    chrom_length = len(p1)\n    \n    point = np.random.randint(1,chrom_length -1)    \n\n    if np.random.random() < pc :\n        c1 = Chromosome(chrom_length)\n        c2 = Chromosome(chrom_length)\n        for i in range(chrom_length) :\n            if i < point :\n                c1.genes[i] = p1.genes[i]\n                c2.genes[i] = p2.genes[i]\n            else :\n                c1.genes[i] = p2.genes[i]\n                c2.genes[i] = p1.genes[i]\n    else :\n        c1 = deepcopy(p1)\n        c2 = deepcopy(p2)\n    \n    # Reset fitness of each parent\n    c1.reset()\n    c2.reset()\n    \n    return c1, c2\n\ndef two_point_crossover(pop, selection_method, pc) :\n    \n    p1 = selection_method(pop)\n    p2 = selection_method(pop)\n    \n    chrom_length = len(p1)\n    \n    point1 = np.random.randint(1,chrom_length -1)    \n    point2 = np.random.randint(1,chrom_length -1)\n    \n    if np.random.random() < pc :\n        c1 = Chromosome(chrom_length)\n        c2 = Chromosome(chrom_length)\n    \n        for i in range(chrom_length) :\n            if i < point1 :\n                c1.genes[i] = p1.genes[i]\n                c2.genes[i] = p2.genes[i]\n            elif i < point2 :\n                c1.genes[i] = p2.genes[i]\n                c2.genes[i] = p1.genes[i]\n            else :\n                c1.genes[i] = p1.genes[i]\n                c2.genes[i] = p2.genes[i]\n    else :\n        c1 = deepcopy(p1)\n        c2 = deepcopy(p2)\n    \n    # Reset fitness of each parent\n    c1.reset()\n    c2.reset()\n    \n    return c1, c2\n\n\ndef unifrom_crossover(pop, selection_method, pc) :\n    p1 = selection_method(pop)\n    p2 = selection_method(pop)\n    \n    chrom_length = len(p1)\n    \n    mask = np.random.randint(0, 2, chrom_length)\n\n    if np.random.random() < pc :\n        c1 = Chromosome(chrom_length)\n        c2 = Chromosome(chrom_length)\n        for i in chrom_length :\n            if mask[i]:\n                c1.genes[i] = p2.genes[i]\n                c2.genes[i] = p1.genes[i]\n            else :\n                c1.genes[i] = p1.genes[i]\n                c2.genes[i] = p2.genes[i]\n    else :\n        c1 = deepcopy(p1)\n        c2 = deepcopy(p2)\n    \n    # Reset fitness of each parent\n    c1.reset()\n    c2.reset()\n    \n    return c1, c2\n\ndef random_mutation(chrom, pm) :\n    for i in range(len(chrom)):\n        if np.random.random() < pm :\n            chrom.genes[i] = not chrom.genes[i]\n    return chrom\n\ndef random_mutation_v2(chrom, pm) :\n    if np.random.random() < pm :\n        point = np.random.randint(len(chrom))\n        chrom.genes[point] = not chrom.genes[point]\n    return chrom\n    \ndef inorder_mutation(chrom, pm, mutation_points) :\n    for i in mutation_points:\n        if np.random.random() < pm :\n            chrom.genes[i] = not chrom.genes[i]\n    return chrom\n\n# First set up the figure, the axis, and the plot element we want to animate\ndef plot_generations(generations, fitnesses) :\n    fig = plt.figure()\n    ax = plt.axes(xlim=(0, 20), ylim=(0, 20))\n\n    X = generations[:, :, 0]\n    Y = generations[:, :, 1]\n\n    # animation function.  This is called sequentially\n    def animate(i):\n        x = X[i]\n        y = Y[i]\n        ax.clear()\n        scat = ax.scatter(x, y, s=fitnesses[i])\n        ax.set_title(\'Generation {}\'.format(i))\n        return scat, ax\n\n    # call the animator.  blit=True means only re-draw the parts that have changed.\n    anim = animation.FuncAnimation(fig, animate, frames=generations.shape[0], interval=200)\n    plt.close()\n    # call our new function to display the animation\n    return HTML(anim.to_jshtml())'"
Week 6 - Particle Swarm Optimization/pso_utils.py,6,"b""import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom mpl_toolkits.mplot3d import Axes3D\nfrom matplotlib import animation\nfrom IPython.display import HTML\n\ndef data_point_creator(x_bound, y_bound, func, prec=.1):\n    x = np.arange(-5.12, 5.12, prec)\n    y = np.arange(-5.12, 5.12, prec)\n    x, y = np.meshgrid(x, y)\n    z = np.array(list(map(func, x, y)))\n    return x, y, z\n\ndef three_d_plot(x, y, z, p_type='surface', genetic_points=None, with_countour=False, elev=45):\n    fig = plt.figure()\n    ax = fig.gca(projection='3d')\n\n\n    plot_dict = {\n        'surface': ax.plot_surface,\n        'wireframe': ax.plot_wireframe,\n    }\n    \n    assert p_type in plot_dict.keys()\n    \n    def animate(i):\n        x_gen = genetic_points[i, :, 0]\n        y_gen = genetic_points[i, :, 1]\n        z_gen = genetic_points[i, :, 2]\n        ax.clear()\n        ax.scatter(x_gen, y_gen, z_gen, c='black',s=30)\n        plot_dict[p_type](x, y, z)\n        ax.contour(x, y, z, zdir='z', offset=-2, cmap=cm.coolwarm)\n        ax.set_title('Generation {}'.format(i))\n        ax.set_xlabel('X')\n        ax.set_xlim(-10, 10)\n        ax.set_ylabel('Y')\n        ax.set_ylim(-10, 10)\n        ax.set_zlabel('Z')\n        ax.set_zlim(-2.2, 100)\n        ax.view_init(elev=elev)\n        \n\n        return ax\n    \n    plot_dict[p_type](x, y, z)\n    \n    if with_countour :\n#         cset = ax.contour(x, y, z, zdir='z', offset=-25, cmap=cm.coolwarm)\n#         cset = ax.contour(x, y, z, zdir='x', offset=-10, cmap=cm.coolwarm)\n        cset = ax.contour(x, y, z, zdir='y', offset=10, cmap=cm.coolwarm)\n        ax.set_xlabel('X')\n        ax.set_xlim(-10, 10)\n        ax.set_ylabel('Y')\n        ax.set_ylim(-10, 10)\n        ax.set_zlabel('Z')\n        ax.set_zlim(-25, 25)\n    if not(genetic_points is None) :\n        anim = animation.FuncAnimation(fig, animate, frames=genetic_points.shape[0], interval=200)\n        plt.close()\n        # call our new function to display the animation\n        return HTML(anim.to_jshtml())\n    \ndef two_d_plot(x, y, z, genetic_points=None, with_countour=False, elev=45):\n    fig = plt.figure()\n    ax = fig.gca()\n     \n    def animate(i):\n        x_gen = genetic_points[i, :, 0]\n        y_gen = genetic_points[i, :, 1]\n        ax.clear()\n        ax.scatter(x_gen, y_gen, c='black',s=30)\n        ax.contour(x, y, z, zdir='z', offset=-2, cmap=cm.coolwarm)\n        ax.set_title('Generation {}'.format(i))\n        ax.set_xlabel('X')\n        ax.set_xlim(-10, 10)\n        ax.set_ylabel('Y')\n        ax.set_ylim(-10, 10)\n        return ax\n    \n    \n    if with_countour :\n        cset = ax.contour(x, y, z, zdir='y', offset=10, cmap=cm.coolwarm)\n        ax.set_xlabel('X')\n        ax.set_xlim(-10, 10)\n        ax.set_ylabel('Y')\n        ax.set_ylim(-10, 10)\n    if not(genetic_points is None) :\n        anim = animation.FuncAnimation(fig, animate, frames=genetic_points.shape[0], interval=200)\n        plt.close()\n        # call our new function to display the animation\n        return HTML(anim.to_jshtml())\n    \nde_jong_func = lambda x, y: x**2 + y**2\na_p_hyper_ellipsoid_func = lambda x, y: x**2 + 2*y**2\nros_valley_func = lambda x, y: 100*(y - x**2)**2 + (1 -x)**2\nrastrigin_func = lambda x, y: 20 + np.floor(x**2 + 10*np.cos(2*np.pi*x)) + np.floor(y**2 + 10*np.cos(2*np.pi*y))\nmulti_rastrigin_func = lambda x: 10*len(x) + sum([np.floor(i**2 + 10*np.cos(2*np.pi*i)) for i in x])"""
Week 7 - Logistic Regression/utils.py,4,"b""import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sb\nimport pandas as pd\nfrom sklearn import datasets\n\ndef plot_prediction(X, Y, predict_func, params):\n    X = np.array(X)\n    Y = np.array(Y)\n    plt.figure(figsize=(10, 6))\n    plt.scatter(X[Y == 0][:, 0], X[Y == 0][:, 1], color='b', label='0')\n    plt.scatter(X[Y == 1][:, 0], X[Y == 1][:, 1], color='r', label='1')\n    plt.legend()\n    x1_min, x1_max = X[:,0].min(), X[:,0].max(),\n    x2_min, x2_max = X[:,1].min(), X[:,1].max(),\n    xx1, xx2 = np.meshgrid(np.linspace(x1_min, x1_max), np.linspace(x2_min, x2_max))\n    grid = np.c_[xx1.ravel(), xx2.ravel()]\n    probs = predict_func(params['w'], params['b'], grid.T).reshape(xx1.shape)\n    plt.contour(xx1, xx2, probs, [0.5], linewidths=1, colors='black')"""
