file_path,api_count,code
ds_main.py,0,"b'""""""\nDiamond square algorithm for random terrain generation.\nPython version 3.4.3\nnumpy version 1.11.2\nmatplotlib version 1.5.3\nrequires mpl_toolkits.mplot3d library for 3d plots.\n""""""\nfrom methods import *\n\n# Inputs here. Recommend ds_steps = 3 up to 11 for 2d and 3 - 5 for 3d.\nds_steps = 5  # Number of levels. Grid points = ((ds_steps^2)+1)^2.\nmax_rnd = 1.0  # Min & Max random value.\nplot_type = ""3d""  # ""3d"" for 3d.  Makes 2d plot for any other input.\n# Inputs end.\nmax_index = 2 ** ds_steps\nseeded_map = f_seed_grid(2**ds_steps + 1, max_rnd)\nFinal_height_map = f_dsmain(seeded_map, ds_steps, max_index, max_rnd) # Calcs.\nf_plotting(Final_height_map, max_index, plot_type)  # Plotting.\n'"
methods.py,2,"b'import numpy as np\r\nimport matplotlib.pyplot as plt\r\nfrom matplotlib import cm\r\nfrom mpl_toolkits.mplot3d import Axes3D\r\nimport random\r\nimport time\r\n\r\n\r\ndef f_avg(*args):\r\n    """"""Takes in arbitray arguments and computes their average.""""""\r\n    return float(sum(args)) / float(len(args))\r\n\r\n\r\ndef f_rnjesus(rand):\r\n    """"""Returns uniformly distributed presudo-random value between +/- rand.""""""\r\n    return random.uniform(-rand, rand)\r\n\r\ndef f_rngauss(rand):  # Incomplete.  Experimenting with.\r\n    return random.gauss(0, 2*rand/5)\r\n\r\n\r\ndef f_seed_grid(grid_size, max_rnd):\r\n    """"""Initialisation function. Creates and seeds 4 corners of grid.""""""\r\n    height_map = np.zeros((grid_size, grid_size), dtype=float)\r\n    height_map[0, 0] = f_rnjesus(max_rnd)\r\n    height_map[0, grid_size - 1] = f_rnjesus(max_rnd)\r\n    height_map[grid_size - 1, 0] = f_rnjesus(max_rnd)\r\n    height_map[grid_size - 1, grid_size - 1] = f_rnjesus(max_rnd)\r\n    return height_map\r\n\r\n\r\ndef f_plotting(height_map, max_index, plot_type):\r\n    """"""Function plots either 2D or 3D heatmap.""""""\r\n    timestr = time.strftime(""%Y%m%d-%H%M%S"")\r\n\r\n    if plot_type == ""3d"":\r\n        x_index = [i for i in range(0, max_index + 1)]\r\n        y_index = [i for i in range(0, max_index + 1)]\r\n        x_vals, y_vals = np.meshgrid(x_index, y_index)\r\n        fig = plt.figure()\r\n        p2 = fig.add_subplot(111, projection=""3d"")\r\n        p2.set_title(""Diamond Square 3D Surface Plot"")\r\n        p2.set_aspect(""equal"")\r\n        p2.plot_surface(x_vals, y_vals, height_map, rstride=1, cstride=1, cmap=cm.jet)\r\n        plt.savefig(""3D_dS%s.png"" % timestr, bbox_inches=""tight"")\r\n        plt.show()\r\n    else:\r\n        fig = plt.figure()\r\n        p3 = fig.add_subplot(111)\r\n        p3.set_title(""Diamond Square 2D Terrain Heatmap"")\r\n        p3.set_aspect(""equal"")\r\n        plt.imshow(height_map, origin=""lower"", cmap=cm.jet)\r\n        plt.savefig(""2D_dS%s.png"" % timestr, bbox_inches=""tight"")\r\n        plt.show()\r\n\r\n\r\ndef f_square_step(height_map, grid_split, shape_length, lo_rnd):\r\n    """"""Function computes square step (reference points form square).""""""\r\n    for i in range(grid_split):\r\n        for j in range(grid_split):\r\n            # REDEFINE STEP SIZE INCREMENTER & SHAPE INDICES.\r\n            half_v_grid_size = shape_length // 2\r\n            i_min = i * shape_length\r\n            i_max = (i + 1) * shape_length\r\n            j_min = j * shape_length\r\n            j_max = (j + 1) * shape_length\r\n            i_mid = i_min + half_v_grid_size\r\n            j_mid = j_min + half_v_grid_size\r\n            # ASSIGN REFERENCE POINTS & DO SQUARE STEP.\r\n            north_west = height_map[i_min, j_min]\r\n            north_east = height_map[i_min, j_max]\r\n            south_west = height_map[i_max, j_min]\r\n            south_east = height_map[i_max, j_max]\r\n            height_map[i_mid, j_mid] = f_avg(north_west, north_east, \\\r\n            south_east, south_west) + f_rnjesus(lo_rnd)\r\n    return height_map\r\n\r\n\r\ndef f_diamond_step(height_map, grid_split, shape_length, lo_rnd, max_index):\r\n    """"""Function computes diamond step (reference points form diamond).""""""\r\n    for i in range(grid_split):\r\n        for j in range(grid_split):\r\n            # REDEFINE STEP SIZE INCREMENTER & SHAPE INDICES.\r\n            half_v_grid_size = shape_length // 2\r\n            i_min = i * shape_length\r\n            i_max = (i + 1) * shape_length\r\n            j_min = j * shape_length\r\n            j_max = (j + 1) * shape_length\r\n            i_mid = i_min + half_v_grid_size\r\n            j_mid = j_min + half_v_grid_size\r\n            center = height_map[i_mid, j_mid]\r\n            north_west = height_map[i_min, j_min]\r\n            north_east = height_map[i_min, j_max]\r\n            south_west = height_map[i_max, j_min]\r\n            south_east = height_map[i_max, j_max]\r\n            # DO DIAMOND STEP.\r\n            # Top Diamond - wraps if at edge.\r\n            if i_min == 0:\r\n                temp = max_index - half_v_grid_size\r\n            else:\r\n                temp = i_min - half_v_grid_size\r\n            # If Top value exists then skip else compute.\r\n            if height_map[i_min, j_mid] == 0:\r\n                height_map[i_min, j_mid] = f_avg(center, north_west, \\\r\n                north_east, height_map[temp, j_mid]) + f_rnjesus(lo_rnd)\r\n\r\n            # Left Diamond - wraps if at edge.\r\n            if j_min == 0:\r\n                temp = max_index - half_v_grid_size\r\n            else:\r\n                temp = j_min - half_v_grid_size\r\n            # If Left value exists then skip else compute.\r\n            if height_map[i_mid, j_min] == 0:\r\n                height_map[i_mid, j_min] = f_avg(center, north_west, \\\r\n                south_west, height_map[i_mid, temp]) + f_rnjesus(lo_rnd)\r\n\r\n            # Right Diamond - wraps if at edge.\r\n            if j_max == max_index:\r\n                temp = 0 + half_v_grid_size\r\n            else:\r\n                temp = j_max + half_v_grid_size\r\n            height_map[i_mid, j_max] = f_avg(center, north_east, south_east, \\\r\n            height_map[i_mid, temp]) + f_rnjesus(lo_rnd)\r\n\r\n            # Bottom Diamond - wraps at edge.\r\n            if i_max == max_index:\r\n                temp = 0 + half_v_grid_size\r\n            else:\r\n                temp = i_max + half_v_grid_size\r\n            height_map[i_max, j_mid] = f_avg(center, south_west, south_east, \\\r\n            height_map[temp, j_mid]) + f_rnjesus(lo_rnd)\r\n    return height_map\r\n\r\n\r\ndef f_dsmain(height_map, steps, max_index, max_rnd):\r\n    """"""Main looping function.  Calls methods in proper step.""""""\r\n    # Set iterators\r\n    shape_length = len(height_map) - 1\r\n    grid_split = 1  # Number of shapes is this number squared.\r\n    for level in range(steps):\r\n        lo_rnd = max_rnd / (level + 1)\r\n        f_square_step(height_map, grid_split, shape_length, lo_rnd)\r\n        f_diamond_step(height_map, grid_split, shape_length, lo_rnd, max_index)\r\n        # Increment iterators for next loop. Use floor divide to force int.\r\n        shape_length //= 2\r\n        grid_split *= 2\r\n    return height_map\r\n'"
