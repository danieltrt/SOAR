file_path,api_count,code
04_Entropy&Inf/code/maxwells_demon.py,3,"b'# Oirignal code by David Ji \r\n# Modified by Davit Potoyan\r\n\r\nfrom tkinter import *\r\nimport numpy as np\r\nfrom numpy.random import choice, uniform\r\nimport random\r\nimport copy\r\nimport scipy.special\r\nimport math\r\n\r\nclass Ball:\r\n\r\n    def __init__(self, speed, col): #random initialization\r\n\r\n        self.x = random.randint(50,350) + choice((0,400))\r\n        self.y = random.randint(50,550)\r\n        phase1 = uniform(30,55)/180.0\r\n        phase = (choice((1,2,3,4))/2.0 + phase1)*math.pi\r\n        self.dx = math.cos(phase)*speed\r\n        self.dy = math.sin(phase)*speed\r\n        self.radius = 10 \r\n        self.color = col\r\n\r\ndef drawSplashScreen(): #draws the splash screen with four boxes\r\n\r\n    inc=cd.boxSize*2/3\r\n    canvas.create_text(cd.width/2,cd.border,text=""MAXWELL\'S DEMON"",\r\n                       font=""Helvetica 24"",)\r\n    canvas.create_oval(cd.border,cd.border,cd.border*2,cd.border*2,fill=""red""\r\n                       ,width=0)\r\n    canvas.create_oval(cd.width-cd.border,cd.border,cd.width-cd.border*2,\r\n                       cd.border*2,fill=""blue"", width=0)\r\n    leftX=cd.width/2-cd.boxSize\r\n    rightX=cd.width/2+cd.boxSize\r\n    topY=cd.boxSize/2\r\n    botY=cd.boxSize\r\n    for incNum in np.arange(cd.menus): #creates the rectangles for the splashscreen\r\n        canvas.create_rectangle(leftX, topY+inc*incNum,rightX,botY+inc*incNum,\r\n                                fill= ""gray"")\r\n    canvas.create_text(cd.width/2,cd.boxSize*.75,text=""Information"",\r\n                       font=""Helvetica 24"")\r\n    canvas.create_text(cd.width/2,cd.boxSize*.75+inc,text=""Sandbox"",\r\n                       font=""Helvetica 24"")\r\n    canvas.create_text(cd.width/2,cd.boxSize*.75+inc*2,text=""Play"",\r\n                       font=""Helvetica 24"")\r\n    canvas.create_text(cd.width/2,cd.boxSize*.75+inc*cd.lastMenu, text=""Demo"",\r\n                       font=""Helvetica 24"")\r\n\r\ndef mousePressed(event):#mouse only works for the splash screen sets the\r\n    #game mode for clicking on the respective box\r\n    inc=cd.boxSize*2/3\r\n    leftX=cd.width/2-cd.boxSize\r\n    rightX=cd.width/2+cd.boxSize\r\n    topY=cd.boxSize/2\r\n    botY=cd.boxSize\r\n    if cd.isSplashScreen:\r\n        if event.x>leftX and event.x<rightX:\r\n            if event.y<botY and event.y>topY:\r\n                cd.gameMode=""info""\r\n                cd.isSplashScreen=False\r\n            elif event.y<botY+inc and event.y>topY+inc:\r\n                cd.gameMode=""sandbox""\r\n                cd.isSplashScreen=False\r\n            elif event.y<botY+inc*2 and event.y>topY+inc*2:\r\n                startGameNorm()\r\n                cd.gameMode=""normal""\r\n                cd.isSplashScreen=False\r\n                cd.gameTime=cd.gameTimeDef\r\n            elif event.y<botY+inc*cd.lastMenu and event.y>topY+inc*cd.lastMenu:\r\n                startGameDemo()\r\n                cd.gameMode=""demo""\r\n                cd.isSplashScreen=False\r\n                cd.gameTime=cd.gameTimeDef\r\n    \r\ndef drawInformation():#Information on Maxwell\'s Demon/the project in general\r\n    canvas.create_text(cd.width/2,cd.border,text=""MAXWELL\'S DEMON"",\r\n                       font=""Helvetica 24"",)\r\n    canvas.create_oval(cd.border,cd.border,cd.border*2,cd.border*2,fill=""red""\r\n                       ,width=0)\r\n    canvas.create_oval(cd.width-cd.border,cd.border,cd.width-cd.border*2,\r\n                       cd.border*2,fill=""blue"", width=0)\r\n    mes=""Maxwell\'s Demon is a physics thought experiment about the second "" \\\r\n         +""law of \\nthermodynamics demonstrating how it could hypothetically""\\\r\n         +"" be violated.\\nThis program includes three game modes: Sandbox, ""\\\r\n         +"" Play, and Demo.\\n""\\\r\n         +"" \\nPress \'Esc\' to return to the main menu.""\\\r\n         +"" \\n\\nSandbox:\\nPress \'a\' to""\\\r\n         +"" add a pair of balls,""\\\r\n         +"" \'b\' to remove a pair of balls, or the \'space bar\'\\nto open/close ""\\\r\n         +""the door.""\\\r\n         +""\\n \\nPlay: \\nThe goal of the game will be for you to try to get""\\\r\n         +"" all of the balls of each \\ncolor on their respective sides with""\\\r\n         +"" the door closed. Press the \'space bar\' \\nto open/close the door.""\\\r\n         +""\\n\\nDemo: ""\\\r\n         +""\\nThe game is played by computer using AI algorithm.""\r\n    canvas.create_text(cd.width/2,cd.height/2,text=mes,\r\n                       font=""Arial 24"")\r\n    \r\ndef addBallPair():#adds a pair of balls(different colors) to the board\r\n    cd.ballList.append(Ball(10.0,""red""))\r\n    cd.ballList.append(Ball(9.0,""blue""))\r\n\r\ndef removeBallPair():#removes a pair of balls (last ones added) from the board\r\n    #(only available in sandbox mode\r\n    if len(cd.ballList)==0:\r\n        print(""Ball list is empty"")\r\n    else:\r\n        cd.ballList.pop()\r\n        cd.ballList.pop()\r\n\r\ndef keyPressed(event):#keys only work during a game\r\n    if event.keysym==""Escape"":\r\n        cd.isSplashScreen=True\r\n        cd.ballList=[]\r\n    elif not cd.isSplashScreen:\r\n        if cd.gameMode==""sandbox"":\r\n            if event.char==""a"":\r\n                addBallPair()\r\n            elif event.char==""b"":\r\n                removeBallPair()\r\n            elif event.keysym==""space"":\r\n                cd.doorIsOpen= not cd.doorIsOpen\r\n        elif cd.gameMode==""normal"":\r\n            #print ""Normal Mode""\r\n            if event.keysym==""space"" and not cd.gameWon:\r\n                cd.doorIsOpen= not cd.doorIsOpen\r\n    redrawAll()\r\n\r\ndef timerFired():\r\n    redrawAll()\r\n    cd.gameTime-=cd.delay*2\r\n    canvas.after(cd.delay, timerFired) # pause, then call timerFired again\r\n\r\ndef redrawAll():#draws the necessary \r\n    canvas.delete(ALL)\r\n    if cd.isSplashScreen:\r\n        drawSplashScreen()\r\n    else:\r\n        if cd.gameMode==""info"":\r\n            drawInformation()\r\n        elif cd.gameMode==""sandbox"":\r\n            drawBoard()\r\n            drawBalls()\r\n        elif cd.gameMode==""normal"":\r\n            drawBoard()\r\n            drawBalls()\r\n            drawTimer()\r\n            displayEntropy()\r\n            if cd.gameWon:\r\n                drawWinner()\r\n            elif cd.gameTime<0:\r\n                drawLoser()\r\n        elif cd.gameMode==""demo"":\r\n            WantdoorOpen = useAI()\r\n            if cd.doorIsOpen == True:\r\n                if WantdoorOpen == True:\r\n                    cd.doordelay -= 1\r\n                elif cd.doordelay > 0:\r\n                    cd.doordelay -= 1\r\n                else:\r\n                    cd.doorIsOpen = False\r\n                    cd.doordelay = 5 \r\n                    \r\n            if cd.doorIsOpen == False:\r\n                if WantdoorOpen == False:\r\n                    cd.doordelay -= 1\r\n                elif cd.doordelay > 0:\r\n                    cd.doordelay -= 1\r\n                else:\r\n                    cd.doorIsOpen = True\r\n                    cd.doordelay = 5 \r\n                \r\n            drawBoard()\r\n            drawBalls()\r\n            drawTimer()\r\n            displayEntropy()\r\n            if cd.gameWon:\r\n                drawWinner()\r\n            elif cd.gameTime<0:\r\n                drawLoser()\r\n    \r\ndef drawTimer():#draws the timer if the time is greater than 0\r\n    if cd.gameTime>0:\r\n        minutes=int(cd.gameTime/1000/60)\r\n        seconds=int(cd.gameTime/1000%60)\r\n        if seconds>9:\r\n            canvas.create_text(cd.width/3,cd.border,text=""Time Remaining: ""\\\r\n                               +str(minutes)+"":""+str(seconds),\r\n                               font=""Arial 24"")\r\n        else:\r\n            canvas.create_text(cd.width/3,cd.border,text=""Time Remaining: ""\\\r\n                               +str(minutes)+"":0""+str(seconds),\r\n                               font=""Arial 24"")\r\n            \r\ndef displayEntropy():#display the entropy number\r\n    if cd.gameTime>0:\r\n        #entropy = 0.0\r\n        canvas.create_text(2*cd.width/3,cd.border,text=""Entropy = ""\\\r\n                               + ""%.2f"" % round(cd.entropy,2) + "" bit"",\r\n                               font=""Arial 24"")\r\n            \r\ndef drawLoser():#draws losing screen\r\n    canvas.create_rectangle(cd.width/4,cd.height/4,cd.width*3/4,cd.height*3/4,\r\n                            fill= ""white"")\r\n    canvas.create_text(cd.width/2,cd.height/2, text=""Sorry You Lose!""+\r\n                       ""\\nPress Esc to go to the menu"",\r\n                       font=""Helvetica 24"")\r\n\r\ndef drawWinner():#draws winning screen\r\n    canvas.create_rectangle(cd.width/4,cd.height/4,cd.width*3/4,cd.height*3/4,\r\n                            fill= ""white"")\r\n    canvas.create_text(cd.width/2,cd.height/2, text=""Congratulations You Win!""+\r\n                       ""\\nPress Esc to go to the menu"",\r\n                       font=""Helvetica 24"")\r\n\r\ndef startGameDemo():#Creates game with a demo amount of balls\r\n    cd.ballList=[]\r\n    for numPairs in np.arange(cd.demo):\r\n        addBallPair()\r\n\r\ndef startGameNorm():#Creates game with a normal amount of balls\r\n    cd.ballList=[]\r\n    for numPairs in np.arange(cd.norm):\r\n        addBallPair()\r\n\r\n#draws the board\r\ndef drawBoard():\r\n    canvas.create_rectangle(0, 0, cd.wall, cd.height, fill=""red"", width=0)\r\n    canvas.create_rectangle(cd.width-cd.wall, 0, cd.width, cd.height,\r\n                            fill=""blue"", width=0)\r\n    canvas.create_rectangle(0, 0, cd.width/2, cd.wall, fill=""red"", width=0)\r\n    canvas.create_rectangle(0, cd.height-cd.wall, cd.width/2, cd.height,\r\n                            fill=""red"", width=0)\r\n    canvas.create_rectangle(cd.width/2,0,cd.width,cd.wall,fill=""blue"", width=0)\r\n    canvas.create_rectangle(cd.width/2,cd.height-cd.wall,cd.width,cd.height,\r\n                            fill=""blue"", width=0)\r\n    canvas.create_rectangle((cd.width-cd.wall)/2, 0, (cd.width+cd.wall)/2,\r\n                            200, fill=""red"", width=0)\r\n    canvas.create_rectangle((cd.width-cd.wall)/2, 400, (cd.width+cd.wall)/2,\r\n                            cd.height, fill=""blue"", width=0)\r\n    if cd.doorIsOpen == False:\r\n        canvas.create_rectangle((cd.width-cd.wall)/2, 200,\r\n                                (cd.width+cd.wall)/2, 400, fill=""lightblue"")\r\n\r\ndef drawBalls():\r\n\r\n    count=0.#count of balls that are in the right spot\r\n    for ball in cd.ballList:\r\n        if cd.doorIsOpen: redisplayBall_opendoor(ball)\r\n        else: redisplayBall_closedoor(ball)\r\n\r\n    red_left = 0\r\n    red_right = 0\r\n    blue_left = 0\r\n    blue_right = 0\r\n    for ball in cd.ballList:\r\n        if ball.color==""red"":\r\n            if ball.x<= cd.width/2:\r\n                red_left+=1\r\n            else:\r\n                red_right+=1\r\n        else:\r\n            if ball.x<= cd.width/2:\r\n                blue_left+=1\r\n            else:\r\n                blue_right+=1  \r\n    red_total = scipy.special.binom(red_left+red_right,red_left)\r\n    blue_total = scipy.special.binom(blue_left+blue_right,blue_left)\r\n    cd.entropy = math.log(red_total,2) + math.log(blue_total,2)\r\n    \r\n    if cd.gameMode==""normal"" or cd.gameMode==""demo"":\r\n        if cd.doorIsOpen==False:\r\n            won=True\r\n            for ball in cd.ballList:\r\n                if not isInRightSpot(ball):\r\n                    won=False\r\n            cd.gameWon=won\r\n\r\ndef redisplayBall_opendoor(ball):#checks if the ball is hitting the wall\r\n    #and bounces it back if so\r\n    if (ball.x) < (cd.width/2-cd.wall/2-ball.radius) and \\\r\n    (ball.x + ball.dx) > (cd.width/2-cd.wall/2-ball.radius) and \\\r\n    ((ball.y+ball.dy) < (200+cd.wall/2+ball.radius) or (ball.y+ball.dy) > \\\r\n    (400-ball.radius-cd.wall/2)): ball.dx = -ball.dx\r\n    if (ball.x) > (cd.width/2+cd.wall/2+ball.radius) and \\\r\n    (ball.x + ball.dx) < (cd.width/2+cd.wall/2+ball.radius) and \\\r\n    ((ball.y+ball.dy) < (200+ball.radius+cd.wall/2) or (ball.y+ball.dy) > \\\r\n     (400-ball.radius-cd.wall/2)): ball.dx = -ball.dx\r\n    elif (ball.x + ball.dx) < cd.wall+ball.radius: ball.dx = -ball.dx\r\n    elif (ball.x + ball.dx) > (cd.width-cd.wall-ball.radius):ball.dx = -ball.dx\r\n    elif (ball.y + ball.dy) > cd.height-cd.wall-ball.radius: ball.dy = -ball.dy\r\n    elif (ball.y + ball.dy) < cd.wall+ball.radius: ball.dy = -ball.dy\r\n    ball.x += ball.dx\r\n    ball.y += ball.dy\r\n    canvas.create_oval(ball.x - ball.radius, ball.y - ball.radius,\r\n                            ball.x + ball.radius, ball.y + ball.radius,\r\n                            fill = ball.color, width=0)\r\n\r\ndef redisplayBall_closedoor(ball):#checks if the ball is hitting the door or\r\n    #the wall and bounces it back if so\r\n    if (ball.x) < (cd.width/2-cd.wall/2-ball.radius) and \\\r\n    (ball.x + ball.dx) > (cd.width/2-cd.wall/2-ball.radius):\r\n        ball.dx = -ball.dx\r\n    elif (ball.x) > (cd.width/2+cd.wall/2+ball.radius) and \\\r\n    (ball.x + ball.dx) < (cd.width/2+cd.wall/2+ball.radius):\r\n        ball.dx = -ball.dx  \r\n    elif (ball.x + ball.dx) < cd.wall+ball.radius:\r\n        ball.dx = -ball.dx\r\n    elif (ball.x + ball.dx) > (cd.width-cd.wall-ball.radius):\r\n        ball.dx = -ball.dx\r\n    elif (ball.y + ball.dy) > cd.height-cd.wall-ball.radius:\r\n        ball.dy = -ball.dy  \r\n    elif (ball.y + ball.dy) < cd.wall+ball.radius:\r\n        ball.dy = -ball.dy\r\n    ball.x += ball.dx\r\n    ball.y += ball.dy\r\n    canvas.create_oval(ball.x - ball.radius, ball.y - ball.radius,\r\n                       ball.x + ball.radius, ball.y + ball.radius,\r\n                       fill = ball.color,width=0)\r\n    \r\ndef isInRightSpot(ball):#checks if the ball is in the correct position\r\n\r\n    if ball.color==""red"":\r\n        if ball.x<=(cd.width-cd.wall)/2:\r\n            return True\r\n        else:\r\n            return False\r\n    else:\r\n        if ball.x>=(cd.width-cd.wall)/2:\r\n            return True\r\n        else:\r\n            return False\r\n\r\ndef init():#initializes cd variables\r\n\r\n    cd=canvas.data\r\n    cd.width=800\r\n    cd.height = 600\r\n    cd.border=50\r\n    cd.wall=10\r\n    cd.doorIsOpen=True\r\n    cd.ballList=[]\r\n    cd.isSplashScreen=True\r\n    cd.boxSize=175\r\n    cd.gameMode=""""\r\n    cd.delay=20\r\n    cd.delayDef=20\r\n    cd.gameWon=False\r\n    cd.norm=4\r\n    cd.demo=8\r\n    cd.menus=4\r\n    cd.lastMenu=3\r\n    cd.gameTime=120000\r\n    cd.gameTimeDef=120000\r\n    cd.tSize=100\r\n    cd.doordelay=5\r\n\r\ndef useAI():\r\n    ahead = 2\r\n    decision = 0\r\n    # print ""use AI""\r\n    for ball in cd.ballList:\r\n        count = 0\r\n        if (ball.x) < (cd.width/2-cd.wall/2-ball.radius) and \\\r\n        (ball.x + ball.dx) > (cd.width/2-cd.wall/2-ball.radius) and \\\r\n        ((ball.y+ball.dy) > (200+cd.wall/2+ball.radius) and (ball.y+ball.dy) < \\\r\n        (400-ball.radius-cd.wall/2)): \r\n            if ball.color==""red"":\r\n                count = -1\r\n            else:\r\n                count = 1\r\n        if (ball.x) > (cd.width/2+cd.wall/2+ball.radius) and \\\r\n        (ball.x + ball.dx) < (cd.width/2+cd.wall/2+ball.radius) and \\\r\n        ((ball.y+ball.dy) > (200+ball.radius+cd.wall/2) and (ball.y+ball.dy) < \\\r\n        (400-ball.radius-cd.wall/2)): \r\n            if ball.color==""red"":\r\n                count = 1\r\n            else:\r\n                count = -1\r\n        decision += count\r\n    \r\n    if decision > 0: X = True\r\n    else: X = False   \r\n    return X      \r\n            \r\ndef run():\r\n    # create the root and the canvas\r\n    global canvas\r\n    root = Tk()\r\n    canvas = Canvas(root, width=800, height=600)\r\n    canvas.pack()\r\n    # Set up canvas data and call init\r\n    global cd\r\n    class Struct: pass\r\n    canvas.data = Struct()\r\n    cd=canvas.data\r\n    init()\r\n    # set up events\r\n    root.bind(""<Button-1>"", mousePressed)\r\n    root.bind(""<Key>"", keyPressed)\r\n    timerFired()\r\n    # and launch the app\r\n    root.mainloop()  # This call BLOCKS (so your program waits until you close\r\n    #the window!)\r\n\r\nrun()\r\n'"
05_Ising_MC/codes/basic_Ising2d.py,4,"b'import numpy as np\nfrom numpy.random import choice, rand, randint\n\n\n######## Main Code ###########\n\ndef ising2d_mcmc(N,J,B,T, n_steps=10**7, out_freq = 10**4):\n\n    #Initialize\n    spins    = np.ones((N,N)) #choice([-1,1], (N,N))\n\n    #Empty array/matrix for recording\n    confs       = []\n    M, E        = [], []\n\n    for step in range(n_steps):\n\n        #Pick random spin\n        i, j = randint(N), randint(N)\n\n        #Compute energy change\n        z  = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i, (j+1)%N] + spins[i, (j-1)%N]\n        dE = 2*spins[i,j]*(J*z + B)\n\n        #Metropolis condition\n        if dE <= 0 or np.exp(-dE/T) > rand():\n            \n            spins[i,j] *= -1 # flip spin\n\n        #Store the spin configuration\n        if step % out_freq == 0:\n            \n            confs.append(spins.copy())\n            M.append(getM(spins))\n            E.append(getE(spins,J,B))\n\n    return confs, M, E\n\n\n####### Thermo Output  #######\n\ndef getM(spins):\n    \n    return np.mean(spins)\n\n\ndef getE(spins,J,B):    \n    \n    E = 0\n    N = len(spins)\n    \n    for i in range(N):\n        for j in range(N):   \n            \n            z = spins[(i+1)%N, j] + spins[(i-1)%N, j] +\\\n                spins[i,(j+1)%N] +  spins[i,(j-1)%N]\n            \n            E += -J*z*spins[i,j]/4 # Since we overcounted interactions 4 times divide by 4.\n\n    return E - B*np.sum(spins) #Field contribution added\n\n\n####### Print  #######\n'"
05_Ising_MC/codes/optim_Ising2d.py,4,"b""import numpy as np\nfrom numpy.random import choice, rand, randint\nfrom numba import jit, njit\n\n######## Main Code ###########\n\n@njit\ndef ising2d_mcmc(N,J,B,T, n_steps=10**7, out_freq = 10**4):\n\n    #Initialize\n    spins    =  np.ones((N,N))   # choice([-1,1], (N,N))\n\n    #Empty array/matrix for recording\n    confs       = []\n    M, E        = [], []\n    \n    for step in range(n_steps):\n\n        #Pick random spin\n        i, j = randint(N), randint(N)\n\n        #Compute energy change\n        z  = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i, (j+1)%N] + spins[i, (j-1)%N] # nearest neighbours of i,j\n        dE = 2*spins[i,j]*(J*z + B)\n\n        #Metropolis condition\n        if dE <= 0 or np.exp(-dE/T) > rand():\n            \n            spins[i,j] *= -1 \n\n        #Store the spin configuration\n        if step % out_freq == 0:\n            \n            confs.append(spins.copy())\n            M.append(getM(spins))\n            E.append(getE(spins,J,B))\n\n    return confs, M, E\n\n\n###### Initializing function #######\n\ndef initalize(N, mode='random'):\n    \n    if mode =='random'\n        spins = choice([-1,1],(N,N))\n        \n    if mode == 'ones'\n        spins = ones((N,N))\n        \n    return spins\n\n####### Thermo Output  #######\n@njit\ndef getM(spins):\n    \n    return np.mean(spins)\n\n\n@njit\ndef getE(spins,J,B):    \n    \n    E = 0\n    N = len(spins)\n    \n    for i in range(N):\n        for j in range(N):   \n            \n            z = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i,(j+1)%N] +  spins[i,(j-1)%N]\n            \n            E += -J*z*spins[i,j]/4 # Since we overcounted interactions 4 times divide by 4.\n\n    return E - B*np.sum(spins) #Field contribution added\n\n\n####### Print  #######\n\n"""
05_Ising_MC/codes/parallel_temp_ising2D.py,5,"b""import numpy as np\nfrom numpy.random import choice, rand, randint\nfrom numba import jit, njit\n\n######## Main Code ###########\n\n@njit\ndef mcmc(spins, N, J, B, T, n_steps = 10000, out_freq = 1000):\n    \n    '''mcmc takes spin configuration and samples with given N,J,B,T \n    for n_steps outputing results every out_freq'''\n\n    confs = [] \n    \n    for step in range(n_steps):\n\n        #Pick random spin\n        i, j = randint(N), randint(N)\n\n        #Compute energy change\n        z  = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i, (j+1)%N] + spins[i, (j-1)%N]\n        dE = 2*spins[i,j]*(J*z + B)\n\n        #Metropolis condition\n        if dE <= 0 or np.exp(-dE/T) > rand():\n            \n            spins[i,j] *= -1 \n\n        #Store the spin configuration\n        if step % out_freq == 0:\n            \n            confs.append(spins.copy())\n        \n    return confs\n\n@njit\ndef getM(spins):\n    \n    return np.mean(spins)\n\n\n@njit\ndef getE(spins,N,J,B):    \n    \n    E = 0\n    \n    for i in range(N):\n        for j in range(N):   \n            \n            z = spins[(i+1)%N, j] + spins[(i-1)%N, j] +spins[i,(j+1)%N] +  spins[i,(j-1)%N]\n            \n            E += -J*z*spins[i,j]/4 # Since we overcounted interactions 4 times divide by 4.\n\n    return E - B*np.sum(spins) #Field contribution added\n\n\n@jit\ndef temper(configs):\n    \n    '''Randomly pick two adjacent replicas and attempt an exchange'''\n    \n    i       = np.random.randint(N_repl-1)\n    j       = i+1\n    \n    deltaBeta      = 1/T[i] - 1/T[j]\n    \n    deltaEnergy    = getE(configs[i][-1],N,J,B) - getE(configs[j][-1],N,J,B)\n    \n    if deltaBeta*deltaEnergy < 0 or np.exp(-deltaBeta*deltaEnergy) > rand():\n        \n        configs[i][-1], configs[j][-1] = configs[j][-1], configs[i][-1]\n        \n    return configs\n\n@jit\ndef pt_mcmc(N, J, B, T=[1, 0.1], n_exch=1000, n_steps=10000, out_freq=1000):\n    \n    N_repl     = len(T)\n    configs    = [[choice([-1,1], (N,N))] for i in range(N_repl)]\n    \n    \n    for exch_attempt in range(n_exch): #Exchange attemps\n    \n        configs = temper(configs)\n    \n        for i in range(N_repl): #mcmc in between exchange attemps\n    \n            configs_new = mcmc(configs[i][-1],N, J, B, T[i])\n    \n            configs[i].extend(configs_new)\n        \n    return configs\n\n        \n\n        \n\n"""
05_Ising_MC/codes/us_mcmc.py,5,"b""import numpy as np\nfrom numpy.random import choice, rand, randint\nfrom numba import jit, njit\n\n######## Main Code ###########\n\n@njit\ndef us_mcmc(spins, J, B, T, W, n_steps = 10000, out_freq = 100):\n    \n    '''mcmc takes spin configuration and samples with given N,J,B,T \n    for n_steps outputing results every out_freq'''\n    \n    N = len(spins)\n    confs = [] \n    Ms    = []\n    \n    for step in range(n_steps):\n        \n        #Pick random spin\n        i, j = randint(N), randint(N)\n\n        #Change in bulk energy due to spin flip\n        z            = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i, (j+1)%N] + spins[i, (j-1)%N]\n        dE_bulk      = 2*spins[i,j]*(J*z + B)\n        \n        #Change in magnetizaton coordinate\n        dm           = getM(spins)   - (2/N)*spins[i,j] \n        dE_umb       = U_hard(W, dm) \n    \n        #Compute energy change\n        dE = dE_bulk + dE_umb \n        \n        \n        #Metropolis condition\n        if dE <= 0 or np.exp(-dE/T) > rand():\n            \n            spins[i,j] *= -1 \n\n        #Store the spin configuration\n        if step % out_freq == 0:\n            \n            confs.append(spins.copy())\n            Ms.append(getM(spins))\n    \n    return confs, np.array(Ms)\n\n@jit\ndef initalize(N, mode='ones'):\n    \n    if mode =='random':\n        spins = choice([-1,1],(N,N))\n        \n    if mode == 'ones':\n        spins = np.ones((N,N))\n        \n    return spins\n\n@jit\ndef U_hard(W, m):\n    \n    U = 1e6\n    \n    if min(W) <= m <= max(W):\n        \n        U = 0\n        \n    return U\n\n@jit\ndef U_soft(W, m):\n        \n    return 0.5*W[1]*(W[0]-m)**2\n\n@njit\ndef getM(spins):\n    \n    return np.mean(spins)\n\n\n@njit\ndef getE(spins,J,B):    \n    \n    N = len(spins)\n    E = 0\n    \n    for i in range(N):\n        for j in range(N):   \n            \n            z = spins[(i+1)%N, j] + spins[(i-1)%N, j] +spins[i,(j+1)%N] +  spins[i,(j-1)%N]\n            \n            E += -J*z*spins[i,j]/4 # Since we overcounted interactions 4 times divide by 4.\n\n    return E - B*np.sum(spins) #Field contribution added\n\n"""
06_MC_LJ/code/mc_lj.py,1,"b""import warnings\nwarnings.filterwarnings('ignore')\n\nimport matplotlib.pyplot as plt\nimport scipy as sp\nimport numpy as np\nfrom numpy.random import rand, randint, uniform, choice, normal \nfrom numba import jit, njit\n\n\n######### Main MCMC loop for simulating LJ fluid #################\n\n@njit\ndef doMC_LJ(particles, rho=0.1, T=2.5, sig=1, eps=1, trunc=3, steps=10000, freq=1000):\n\n    N      = len(particles)\n    L      = (N/rho)**(1/3)\n    \n    E_tot       = getE_tot(particles, L, sig, eps, trunc) \n    confs, es   = [particles.copy()], [E_tot]\n    \n    #Loop through MC steps\n    \n    for step in range(0, steps):\n        \n        # Randomly choose some particle i in  \n        i = randint(N)\n    \n        #Position and Energy of particle i\n        pos_i      = particles[i]\n        eng_i      = getE_one(particles, i, pos_i, L, sig, eps, trunc)\n    \n        #Give a particle i a random push:\n        pos_i_new  = particles[i] + (rand(3)-0.5)\n        eng_i_new  = getE_one(particles, i, pos_i_new, L, sig, eps, trunc)\n        \n        # Evaluate change in energy\n        dE = eng_i_new - eng_i\n\n        # Metropolis acceptance/rejection conditions\n        if  np.exp(-dE/T) > rand():\n            \n            particles[i] = pos_i_new\n            E_tot       += dE\n            \n        if step % freq ==0:\n            \n            confs.append(particles.copy())\n            es.append(E_tot)\n                    \n    return confs, es\n    \n\n########## Helper functions ####################\n    \n@njit\ndef pbc_wrap(pp, L):\n    \n    ''' (a) if pp = (x,y,z) position; wraps it back to box (with origin in the center!) \n        (b) if pp = (dr_x, dr_y, dr_z) distances; uses nearest image convension'''\n    \n    if pp[0] >  L/2:  pp[0] = pp[0] - L     \n    if pp[0] <= -L/2: pp[0] = pp[0] + L\n        \n    if pp[1] >  L/2:  pp[1] = pp[1] - L     \n    if pp[1] <= -L/2: pp[1] = pp[1] + L\n    \n    if pp[2] >  L/2:  pp[2] = pp[2] - L     \n    if pp[2] <= -L/2: pp[2] = pp[2] + L\n    \n    return pp\n\n@njit\ndef get_r2(p1, p2, L):\n    \n    ''' Compute squared distance between two particles \n   p1(x,y,z) and p2(x,y,z) while enforcing PBC.'''\n    \n    p1, p2 = pbc_wrap(p1, L), pbc_wrap(p2, L)  # position wrap back into box\n   \n    dr     = p2 - p1\n    \n    dr     = pbc_wrap(dr, L)                   # distance via minimum image \n    \n    return dr[0]**2 + dr[1]**2 + dr[2]**2\n\n\n@njit\ndef get_e2(pos_i, pos_j, L, sig, eps, trunc ):\n    \n    pair_e  = 0\n    \n    dist_sq = get_r2(pos_i, pos_j, L)\n                \n    if dist_sq <= trunc**2:\n                \n        pair_e += (sig/dist_sq)**6 - (sig/dist_sq)**3\n        \n    return 4*eps*pair_e\n  \n    \n@njit\ndef getE_tot(particles, L, sig, eps, trunc):\n    \n    '''Compute Total energy \n    by summing all pairwise interactions'''\n    \n    N = len(particles)\n    energy = 0\n    \n    for i in range(0, N-1):\n        for j in range(i+1, N):\n            \n                energy += get_e2(particles[i], particles[j], L, sig, eps, trunc)\n                    \n    return energy\n    \n    \n@njit\ndef getE_one(particles, j, tag_j, L, sig, eps, trunc):\n    \n    '''Compute energy of a tagged particle j \n    by summing all pairwise interactions with j'''\n    \n    N = len(particles)\n    energy = 0\n        \n    for i in range(N):\n        if i!=j:\n                \n            energy += get_e2(particles[i], tag_j, L, sig, eps, trunc)\n    \n    return energy \n"""
05_Ising_MC/codes/.ipynb_checkpoints/optim_Ising2d-checkpoint.py,4,"b'import numpy as np\nfrom numpy.random import choice, rand, randint\nfrom numba import jit, njit\n\n######## Main Code ###########\n\n@njit\ndef ising2d_mcmc(N,J,B,T, n_steps=10**7, out_freq = 10**4):\n\n    #Initialize\n    spins    =  np.ones((N,N))   # choice([-1,1], (N,N))\n\n    #Empty array/matrix for recording\n    confs       = []\n    M, E        = [], []\n    \n    for step in range(n_steps):\n\n        #Pick random spin\n        i, j = randint(N), randint(N)\n\n        #Compute energy change\n        z  = spins[(i+1)%N, j] + spins[(i-1)%N, j] + spins[i, (j+1)%N] + spins[i, (j-1)%N]\n        dE = 2*spins[i,j]*(J*z + B)\n\n        #Metropolis condition\n        if dE <= 0 or np.exp(-dE/T) > rand():\n            \n            spins[i,j] *= -1 \n\n        #Store the spin configuration\n        if step % out_freq == 0:\n            \n            confs.append(spins.copy())\n            M.append(getM(spins))\n            E.append(getE(spins,N,J,B))\n\n    return confs, M, E\n\n\n####### Thermo Output  #######\n@njit\ndef getM(spins):\n    \n    return np.mean(spins)\n\n\n@njit\ndef getE(spins,N,J,B):    \n    \n    E = 0\n    \n    for i in range(N):\n        for j in range(N):   \n            \n            z = spins[(i+1)%N, j] + spins[(i-1)%N, j] +\\\n                spins[i,(j+1)%N] +  spins[i,(j-1)%N]\n            \n            E += -J*z*spins[i,j]/4 # Since we overcounted interactions 4 times divide by 4.\n\n    return E - B*np.sum(spins) #Field contribution added\n\n\n####### Print  #######\n\n'"
